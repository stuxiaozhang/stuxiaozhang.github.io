<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><script></script><link rel="apple-touch-icon" sizes="180x180" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/avatar-removebg-preview.png"><link rel="icon" type="image/png" sizes="32x32" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/avatar-removebg-preview.png"><link rel="icon" type="image/png" sizes="16x16" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/avatar-removebg-preview.png"><link rel="mask-icon" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/avatar-removebg-preview.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!1,style:"default"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="0. Django介绍 Django是基于Python的Web开发框架。Web开发指的是开发基于B&#x2F;S架构，通过前后端的配合，将后台服务器的数据在浏览器上展现给前台用户的应用。 一般Web框架的架构是这样的：  image-20201029080219087  大多数基于Python的web框架，如Django、Tornado、Flask、Webpy都是在这个范围内进行增删裁剪。例如T"><meta property="og:type" content="article"><meta property="og:title" content="Django基础----模型层"><meta property="og:url" content="http://stuxiaozhang.github.io/2020/10/28/Django%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="小张同学的博客"><meta property="og:description" content="0. Django介绍 Django是基于Python的Web开发框架。Web开发指的是开发基于B&#x2F;S架构，通过前后端的配合，将后台服务器的数据在浏览器上展现给前台用户的应用。 一般Web框架的架构是这样的：  image-20201029080219087  大多数基于Python的web框架，如Django、Tornado、Flask、Webpy都是在这个范围内进行增删裁剪。例如T"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201029080219087.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Django/image-20201029083915147.png"><meta property="article:published_time" content="2020-10-28T15:07:52.000Z"><meta property="article:modified_time" content="2020-10-30T07:54:43.841Z"><meta property="article:author" content="小张同学"><meta property="article:tag" content="Python"><meta property="article:tag" content="Django"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201029080219087.png"><link rel="canonical" href="http://stuxiaozhang.github.io/2020/10/28/Django%E5%9F%BA%E7%A1%80/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Django基础----模型层 | 小张同学的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">小张同学的博客</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">天道酬勤</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>动态</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://stuxiaozhang.github.io/2020/10/28/Django%E5%9F%BA%E7%A1%80/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/codedog.jpg"><meta itemprop="name" content="小张同学"><meta itemprop="description" content="不要停止奔跑 不要回顾来路"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小张同学的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Django基础----模型层</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-10-28 23:07:52" itemprop="dateCreated datePublished" datetime="2020-10-28T23:07:52+08:00">2020-10-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2020/10/28/Django%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/10/28/Django%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>30k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>27 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="django介绍">0. Django介绍</h1><p>Django是基于Python的Web开发框架。Web开发指的是开发基于B/S架构，通过前后端的配合，将后台服务器的数据在浏览器上展现给前台用户的应用。</p><p>一般Web框架的架构是这样的：</p><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201029080219087.png" alt="image-20201029080219087"><figcaption>image-20201029080219087</figcaption></figure><p>大多数基于Python的web框架，如Django、Tornado、Flask、Webpy都是在这个范围内进行增删裁剪。例如Tornado用的是自己的异步非阻塞“WSGI”网关接口，Flask则只提供了最精简和基本的框架，Django则是直接使用了现成的WSGI，并实现了大部分功能，提供了大量的应用工具。</p><p>MVC及MTV设计模式：</p><ul><li><p>MVC设计模式</p><p><code>MVC</code>把Web框架分为三个基础部分：</p><ul><li><p><strong>模型(Model)</strong>：用于封装与应用程序的业务逻辑相关的数据及对数据的处理方法，是Web应用程序中用于处理应用程序的数据逻辑的部分，Model只提供功能性的接口，通过这些接口可以获取Model的所有功能。白话说，这个模块就是业务逻辑和数据库的交互层，定义了数据表。</p></li><li><p><strong>视图(View)</strong>：负责数据的显示和呈现，是对用户的直接输出。</p></li><li><p><strong>控制器(Controller)</strong>：负责从用户端收集用户的输入，可以看成提供View的反向功能。</p></li></ul><p>这三个部分互相独立，但又相互联系，使得改进和升级界面及用户交互流程，在Web开发过程任务分配时，不需要重写业务逻辑及数据访问代码。</p><p>MVC在Python之外的语言中也有广泛应用，例如VC++的MFC，Java的Structs及Spring、C#的.NET开发框架，都非常有名。</p></li><li><p>MTV设计模式：</p><p>MTV和MVC本质上是一样的。</p><p>Django对传统的MVC设计模式进行了修改，将视图分成View模块和Template模块两部分，将动态的逻辑处理与静态的页面展示分离开。而<u>Model采用了ORM技术，将关系型数据库表抽象成面向对象的Python类，将数据库的表操作转换成Python的类操作，避免了编写复杂的SQL语句。</u></p><ul><li><p><strong>模型(Model)</strong>：和MVC中的定义一样</p></li><li><p><strong>模板(Template)</strong>：将模型数据与HTML页面结合起来的引擎</p></li><li><p><strong>视图(View)</strong>：负责实际的业务逻辑实现</p></li></ul><p>Django的MTV模型组织可参考下图所示：</p><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Django/image-20201029083915147.png" alt="image-20201029083915147"><figcaption>image-20201029083915147</figcaption></figure></li></ul><h1 id="模型层">1. 模型层</h1><h2 id="模型和字段">1.1 模型和字段</h2><p>一个模型（model）就是一个单独的、确定的数据的信息源，包含了数据的字段和操作方法。通常，每个模型映射为一张数据库中的表。</p><p>基本的原则如下：</p><ul><li>每个模型在Django中的存在形式为一个Python类</li><li>每个类都是<code>django.db.models.Model</code>的子类</li><li>模型（类）的每个字段（属性）代表数据表的某一列</li><li>Django自动为你生成访问数据库的API</li></ul><p>举个栗子：</p><p>下面的模型定义了一个“人”，它具有<code>first_name</code>和<code>last_name</code>字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>每一个字段都是一个类属性，每个类属性表示数据表中的一个列。</p><p>上面的代码，相当于下面的原生SQL语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE myapp_person (</span><br><span class="line">    <span class="string">&quot;id&quot;</span> serial NOT NULL PRIMARY KEY,</span><br><span class="line">    <span class="string">&quot;first_name&quot;</span> varchar(<span class="number">30</span>) NOT NULL,</span><br><span class="line">    <span class="string">&quot;last_name&quot;</span> varchar(<span class="number">30</span>) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>表名<code>myapp_person</code>由Django自动生成，默认格式为“<code>项目名称+下划线+小写类名</code>”，你可以重写这个规则。</li><li>Django会自动创建自增主键<code>id</code>，当然，你也可以自己指定主键。</li><li>上面的SQL语句基于<code>PostgreSQL</code>语法。</li></ul><p>通常，我们会将模型编写在其所属app下的models.py文件中，没有特别需求时，请坚持这个原则，不要自己给自己添加麻烦。</p><p>创建了模型之后，在使用它之前，需要先在settings文件中的<code>INSTALLED_APPS</code> 处，注册<code>models.py</code>文件所在的<code>myapp</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    #...</span><br><span class="line">    &#39;myapp&#39;,</span><br><span class="line">    #...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>每次对模型进行增、删、修改时，先执行<code>python manage.py makemigrations</code>让修改动作保存到记录文件中，再执行命令<code>python manage.py migrate</code>，让操作实际应用到数据库上。</strong></p><h2 id="模型方法">模型方法</h2><p>模型的方法其实就是Python的实例方法。Django内置了一些，我们也可以自定义一些。</p><ul><li><code>__str__()</code>： 这个其实是Python的魔法方法，用于返回实例对象的打印字符串。为了让显示的内容更直观更易懂，我们往往自定义这个方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    birth_date = models.DateField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.first_name + self.last_name</span><br></pre></td></tr></table></figure><ul><li><code>get_absolute_url()</code>: 这个方法是返回每个模型实例的相应的访问url。</li><li>...</li></ul><h2 id="模型字段fields">模型字段fields</h2><p>Django内置了许多字段类型，它们都位于<code>django.db.models</code>中，例如<code>models.CharField</code>，它们的父类都是Field类。这些类型基本满足需求，如果还不够，也可以自定义字段。</p><table><colgroup><col style="width:29%"><col style="width:70%"></colgroup><thead><tr class="header"><th>类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>AutoField</td><td>一个自动增加的整数类型字段。通常你不需要自己编写它，Django会自动帮你添加字段：<code>id = models.AutoField(primary_key=True)</code>，这是一个自增字段，从1开始计数。如果你非要自己设置主键，那么请务必将字段设置为<code>primary_key=True</code>。Django在一个模型中只允许有一个自增字段，并且该字段必须为主键！</td></tr><tr class="even"><td>BigAutoField</td><td>64位整数类型自增字段，数字范围更大，从1到9223372036854775807</td></tr><tr class="odd"><td>BigIntegerField</td><td>64位整数字段（看清楚，非自增），类似IntegerField ，-9223372036854775808 到9223372036854775807。在Django的模板表单里体现为一个<code>NumberInput</code>标签。</td></tr><tr class="even"><td><strong>BooleanField</strong></td><td>布尔值类型。默认值是None。在HTML表单中体现为CheckboxInput标签。如果设置了参数null=True，则表现为NullBooleanSelect选择框。可以提供default参数值，设置默认值。</td></tr><tr class="odd"><td><strong>CharField</strong></td><td>最常用的类型，字符串类型。必须接收一个max_length参数，表示字符串长度不能超过该值。默认的表单标签是text input。</td></tr><tr class="even"><td><strong>DateField</strong></td><td><code>class DateField(auto_now=False, auto_now_add=False, **options)</code> , 日期类型。一个Python中的datetime.date的实例。在HTML中表现为DateInput标签。在admin后台中，Django会帮你自动添加一个JS日历表和一个“Today”快捷方式，以及附加的日期合法性验证。两个重要参数：（参数互斥，不能共存） <code>auto_now</code>:每当对象被保存时将字段设为当前日期，常用于保存最后修改时间。<code>auto_now_add</code>：每当对象被创建时，设为当前日期，常用于保存创建日期(注意，它是不可修改的)。设置上面两个参数就相当于给field添加了<code>editable=False</code>和<code>blank=True</code>属性。如果想具有修改属性，请用default参数。例子：<code>pub_time = models.DateField(auto_now_add=True)</code>，自动添加发布时间。</td></tr><tr class="odd"><td>DateTimeField</td><td>日期时间类型。Python的datetime.datetime的实例。与DateField相比就是多了小时、分和秒的显示，其它功能、参数、用法、默认值等等都一样。</td></tr><tr class="even"><td>DecimalField</td><td>固定精度的十进制小数。相当于Python的Decimal实例，必须提供两个指定的参数！参数<code>max_digits</code>：最大的位数，必须大于或等于小数点位数 。<code>decimal_places</code>：小数点位数，精度。 当<code>localize=False</code>时，它在HTML表现为NumberInput标签，否则是textInput类型。例子：储存最大不超过999，带有2位小数位精度的数，定义如下：<code>models.DecimalField(..., max_digits=5, decimal_places=2)</code>。</td></tr><tr class="odd"><td><strong>EmailField</strong></td><td>邮箱类型，默认max_length最大长度254位。使用这个字段的好处是，可以使用Django内置的EmailValidator进行邮箱格式合法性验证。</td></tr><tr class="even"><td><strong>FileField</strong></td><td><code>class FileField(upload_to=None, max_length=100, **options)</code>上传文件类型，后面单独介绍。</td></tr><tr class="odd"><td>FilePathField</td><td>文件路径类型，后面单独介绍</td></tr><tr class="even"><td>FloatField</td><td>浮点数类型，对应Python的float。参考整数类型字段。</td></tr><tr class="odd"><td><strong>ImageField</strong></td><td>图像类型，后面单独介绍。</td></tr><tr class="even"><td><strong>IntegerField</strong></td><td>整数类型，最常用的字段之一。取值范围-2147483648到2147483647。在HTML中表现为NumberInput或者TextInput标签。</td></tr><tr class="odd"><td><strong>GenericIPAddressField</strong></td><td><code>class GenericIPAddressField(protocol='both', unpack_ipv4=False, **options)</code>,IPV4或者IPV6地址，字符串形式，例如<code>192.0.2.30</code>或者<code>2a02:42fe::4</code>。在HTML中表现为TextInput标签。参数<code>protocol</code>默认值为‘both’，可选‘IPv4’或者‘IPv6’，表示你的IP地址类型。</td></tr><tr class="even"><td>JSONField</td><td>JSON类型字段。Django3.1新增。签名为<code>class JSONField(encoder=None,decoder=None,**options)</code>。其中的encoder和decoder为可选的编码器和解码器，用于自定义编码和解码方式。如果为该字段提供default值，请务必保证该值是个不可变的对象，比如字符串对象。</td></tr><tr class="odd"><td><strong>TextField</strong></td><td>用于储存大量的文本内容，在HTML中表现为Textarea标签，最常用的字段类型之一！如果你为它设置一个max_length参数，那么在前端页面中会受到输入字符数量限制，然而在模型和数据库层面却不受影响。只有CharField才能同时作用于两者。</td></tr><tr class="even"><td>TimeField</td><td>时间字段，Python中datetime.time的实例。接收同DateField一样的参数，只作用于小时、分和秒。</td></tr><tr class="odd"><td><strong>URLField</strong></td><td>一个用于保存URL地址的字符串类型，默认最大长度200。</td></tr><tr class="even"><td><strong>UUIDField</strong></td><td>用于保存通用唯一识别码（Universally Unique Identifier）的字段。使用Python的UUID类。在PostgreSQL数据库中保存为uuid类型，其它数据库中为char(32)。这个字段是自增主键的最佳替代品。</td></tr></tbody></table><h2 id="关系类型字段">1.2 关系类型字段</h2><p>除了普通类型字段，Django还定义了一组关系类型字段，用来表示模型与模型之间的关系。</p><h3 id="多对一foreignkey">1.2.1 多对一（ForeignKey）</h3><p>多对一的关系，通常被称为外键。外键字段类的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForeignKey</span>(<span class="params">to, on_delete, **options</span>)</span></span><br></pre></td></tr></table></figure><p>外键需要两个位置参数，一个是关联的模型，另一个是<code>on_delete</code>。</p><p><strong>外键要定义在‘多’的一方！</strong></p><p>举栗：</p><p>每辆车都会有一个生产工厂，一个工厂可以生产N辆车，于是用一个外键字段manufacturer表示，并放在Car模型中。注意，此manufacturer非彼Manufacturer模型类，它是一个字段的名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manufacturer</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>在实际的数据库后台，Django会为每一个外键添加<code>_id</code>后缀，并以此创建数据表里的一列。在上面的工厂与车的例子中，Car模型对应的数据表中，会有一列叫做<code>manufacturer_id</code>。但实际上，在Django代码中你不需要使用这个列名，除非你书写原生的SQL语句，一般我们都直接使用字段名<code>manufacturer</code>。</p><p>多对一字段的变量名一般设置为关联的模型的小写单数，而多对多则一般设置为小写复数。在Django的模型定义中，经常出现类似的英文单词大小写不同，一定要注意区分！</p><p>如果要创建一个递归的外键，也就是自己关联自己的的外键，使用下面的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">models.ForeignKey(<span class="string">&#x27;self&#x27;</span>, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>关系字段的定义还有个小坑。在后面<code>verbose_name</code>参数用于设置字段的别名。很多情况下，为了方便，我们都会设置这么个值，并且作为字段的第一位置参数。但是对于关系字段，其第一位置参数永远是关系对象，不能是<code>verbose_name</code>，一定要注意！</p><h4 id="参数说明">参数说明</h4><h4 id="on_delete">on_delete</h4><p>当一个外键关联的对象被删除时，Django将模仿<code>on_delete</code>参数定义的SQL约束执行相应操作。</p><p>该参数可选的值都内置在<code>django.db.models</code>中（全部为大写），包括：</p><ul><li>CASCADE：模拟SQL语言中的<code>ON DELETE CASCADE</code>约束，将定义有外键的模型对象同时删除！</li><li>PROTECT:阻止上面的删除操作，但是弹出<code>ProtectedError</code>异常</li><li>SET_NULL：将外键字段设为null，只有当字段设置了<code>null=True</code>时，方可使用该值。</li><li>SET_DEFAULT:将外键字段设为默认值。只有当字段设置了default参数时，方可使用。</li><li>DO_NOTHING：什么也不做。</li><li>SET()：设置为一个传递给SET()的值或者一个回调函数的返回值。注意大小写。</li></ul><h4 id="limit_choices_to">limit_choices_to</h4><p>该参数用于限制外键所能关联的对象，只能用于Django的ModelForm（Django的表单模块）和admin后台，对其它场合无限制功能。其值可以是一个字典、Q对象或者一个返回字典或Q对象的函数调用，如下例所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">staff_member = models.ForeignKey(</span><br><span class="line">    User,</span><br><span class="line">    on_delete=models.CASCADE,</span><br><span class="line">    limit_choices_to=&#123;<span class="string">&#x27;is_staff&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样定义，则ModelForm的<code>staff_member</code>字段列表中，只会出现那些<code>is_staff=True</code>的Users对象，这一功能对于admin后台非常有用。</p><h4 id="related_name">related_name</h4><p>用于关联对象反向引用模型的名称。以前面车和工厂的例子解释，就是从工厂反向关联到车的关系名称。</p><p>通常情况下，这个参数我们可以不设置，Django会默认以模型的小写加上<code>_set</code>作为反向关联名，比如对于工厂就是<code>car_set</code>，如果你觉得<code>car_set</code>还不够直观，可以如下定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    manufacturer = models.ForeignKey(</span><br><span class="line">        <span class="string">&#x27;production.Manufacturer&#x27;</span>,      </span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">        related_name=<span class="string">&#x27;car_producted_by_this_manufacturer&#x27;</span>,  <span class="comment"># 看这里！！</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>也许我定义了一个蹩脚的词，但表达的意思很清楚。以后从工厂对象反向关联到它所生产的汽车，就可以使用<code>maufacturer.car_producted_by_this_manufacturer</code>了。</p><h3 id="多对多manytomanyfield">1.2.2 多对多（ManyToManyField）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManyToManyField</span>(<span class="params">to, **options</span>)</span></span><br></pre></td></tr></table></figure><p>多对多关系在数据库中也是非常常见的关系类型。比如一本书可以有好几个作者，一个作者也可以写好几本书。多对多的字段可以定义在任何的一方，请尽量定义在符合人们思维习惯的一方，但不要同时都定义，只能选择一个模型设置该字段（比如我们通常将披萨上的配料字段放在披萨模型中，而不是在配料模型中放置披萨字段）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topping</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    toppings = models.ManyToManyField(Topping)</span><br></pre></td></tr></table></figure><ul><li><p>建议为多对多字段名使用复数形式。</p></li><li><p>多对多关系需要一个位置参数：关联的对象模型，其它用法和外键多对一基本类似。</p></li><li><p>如果要创建一个关联自己的多对多字段，依然是通过<code>'self'</code>引用。</p></li></ul><h3 id="一对一onetoonefield">1.2.3 一对一（OneToOneField）</h3><p>一对一关系类型的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneToOneField</span>(<span class="params">to, on_delete, parent_link=<span class="literal">False</span>, **options</span>)</span></span><br></pre></td></tr></table></figure><p>从概念上讲，一对一关系非常类似具有<code>unique=True</code>属性的外键关系，但是反向关联对象只有一个。这种关系类型多数用于当一个模型需要从别的模型扩展而来的情况。比如，Django自带auth模块的User用户表，如果你想在自己的项目里创建用户模型，又想方便的使用Django的auth中的一些功能，那么一个方案就是在你的用户模型里，使用一对一关系，添加一个与auth模块User模型的关联字段。</p><p>该关系的第一位置参数为关联的模型，其用法和前面的多对一外键一样。</p><p>如果你没有给一对一关系设置<code>related_name</code>参数，Django将使用当前模型的小写名作为默认值。</p><p>看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个字段都使用一对一关联到了Django内置的auth模块中的User模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpecialUser</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    user = models.OneToOneField(</span><br><span class="line">        settings.AUTH_USER_MODEL,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">    )</span><br><span class="line">    supervisor = models.OneToOneField(</span><br><span class="line">        settings.AUTH_USER_MODEL,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">        related_name=<span class="string">&#x27;supervisor_of&#x27;</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2 id="字段的参数">1.3 字段的参数</h2><p>所有的模型字段都可以接收一定数量的参数，比如CharField至少需要一个max_length参数。下面的这些参数是所有字段都可以使用的，并且是可选的。</p><h4 id="null">null</h4><p>该值为True时，Django在数据库用NULL保存空值。默认值为False。对于保存字符串类型数据的字段，请尽量避免将此参数设为True，那样会导致两种‘没有数据’的情况，一种是<code>NULL</code>，另一种是空字符串<code>''</code>。Django 的惯例是使用空字符串而不是 <code>NULL</code>。</p><h4 id="blank">blank</h4><p>True时，字段可以为空。默认False。和null参数不同的是，null是纯数据库层面的，而blank是验证相关的，它与表单验证是否允许输入框内为空有关，与数据库无关。所以要小心一个null为False，blank为True的字段接收到一个空值可能会出bug或异常。</p><h4 id="choices">choices</h4><p>用于页面上的选择框标签，需要先提供一个二维的二元元组，第一个元素表示存在数据库内真实的值，第二个表示页面上显示的具体内容。在浏览器页面上将显示第二个元素的值。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    YEAR_IN_SCHOOL_CHOICES = (</span><br><span class="line">        (FRESHMAN, <span class="string">&#x27;Freshman&#x27;</span>),</span><br><span class="line">        (SOPHOMORE, <span class="string">&#x27;Sophomore&#x27;</span>),</span><br><span class="line">        (JUNIOR, <span class="string">&#x27;Junior&#x27;</span>),</span><br><span class="line">        (SENIOR, <span class="string">&#x27;Senior&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    year_in_school = models.CharField(</span><br><span class="line">        max_length=<span class="number">2</span>,</span><br><span class="line">        choices=YEAR_IN_SCHOOL_CHOICES,</span><br><span class="line">        default=FRESHMAN,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_upperclass</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.year_in_school <span class="keyword">in</span> (self.JUNIOR, self.SENIOR)</span><br></pre></td></tr></table></figure><h4 id="primary_key">primary_key</h4><p>如果你没有给模型的任何字段设置这个参数为True，Django将自动创建一个AutoField自增字段，名为‘id’，并设置为主键。也就是<code>id = models.AutoField(primary_key=True)</code>。</p><p>如果你为某个字段设置了primary_key=True，则当前字段变为主键，并关闭Django自动生成id主键的功能。</p><p><strong><code>primary_key=True</code>隐含<code>null=False</code>和<code>unique=True</code>的意思。一个模型中只能有一个主键字段！</strong></p><p>另外，主键字段不可修改，如果你给某个对象的主键赋个新值实际上是创建一个新对象，并不会修改原来的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">###############    </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruit = Fruit.objects.create(name=<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruit.name = <span class="string">&#x27;Pear&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruit.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fruit.objects.values_list(<span class="string">&#x27;name&#x27;</span>, flat=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="unique">unique</h4><p>设为True时，在整个数据表内该字段的数据不可重复。</p><p>注意：</p><ul><li><p>对于ManyToManyField和OneToOneField关系类型，该参数无效。</p></li><li><p>当unique=True时，db_index参数无须设置，因为unqiue隐含了索引。</p></li></ul><h4 id="verbose_name">verbose_name</h4><p>为字段设置一个人类可读，更加直观的别名。</p><p>对于每一个字段类型，除了<code>ForeignKey</code>、<code>ManyToManyField</code>和<code>OneToOneField</code>这三个特殊的关系类型，其第一可选位置参数都是<code>verbose_name</code>。如果没指定这个参数，Django会利用字段的属性名自动创建它，并将下划线转换为空格。</p><p>下面这个例子的<code>verbose name</code>是&quot;person’s first name&quot;:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_name = models.CharField(<span class="string">&quot;person&#x27;s first name&quot;</span>, max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>下面这个例子的<code>verbose name</code>是&quot;first name&quot;:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_name = models.CharField(max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>对于外键、多对多和一对一字字段，由于第一个参数需要用来指定关联的模型，因此必须用关键字参数<code>verbose_name</code>来明确指定。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">poll = models.ForeignKey(</span><br><span class="line">    Poll,</span><br><span class="line">    on_delete=models.CASCADE,</span><br><span class="line">    verbose_name=<span class="string">&quot;the related poll&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">sites = models.ManyToManyField(Site, verbose_name=<span class="string">&quot;list of sites&quot;</span>)</span><br><span class="line">    place = models.OneToOneField(</span><br><span class="line">    Place,</span><br><span class="line">    on_delete=models.CASCADE,</span><br><span class="line">    verbose_name=<span class="string">&quot;related place&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="模型的元数据meta">1.4 模型的元数据Meta</h2><p>模型的元数据，指的是“除了字段外的所有内容”，例如排序方式、数据库表名、人类可读的单数或者复数名等等。想在模型中增加元数据，方法很简单，在模型类中添加一个子类，名字是固定的<code>Meta</code>，然后在这个Meta类下面增加各种元数据选项或者说设置项。参考下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ox</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    horn_length = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>         <span class="comment"># 注意，是模型的子类，要缩进！</span></span><br><span class="line">        ordering = [<span class="string">&quot;horn_length&quot;</span>]</span><br><span class="line">        verbose_name_plural = <span class="string">&quot;oxen&quot;</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们为模型Ox增加了两个元数据‘ordering’和‘verbose_name_plural’，分别表示排序和复数名。</p><p>介绍一些常用的元数据选项：</p><h4 id="abstract">abstract</h4><p>如果<code>abstract=True</code>，那么模型会被认为是一个抽象模型。抽象模型本身不实际生成数据库表，而是作为其它模型的父类，被继承使用。具体内容可以参考Django模型的继承。</p><h3 id="ordering">ordering</h3><p>最常用的元数据之一了！</p><p>用于指定该模型生成的所有对象的排序方式，接收一个字段名组成的元组或列表。默认按升序排列，如果在字段名前加上字符“-”则表示按降序排列，如果使用字符问号“？”表示随机排列。请看下面的例子：</p><p>这个顺序是你通过查询语句，获得Queryset后的列表内元素的顺序，切不可和前面的<code>get_latest_by</code>等混淆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ordering = [<span class="string">&#x27;pub_date&#x27;</span>]             <span class="comment"># 表示按&#x27;pub_date&#x27;字段进行升序排列</span></span><br><span class="line">ordering = [<span class="string">&#x27;-pub_date&#x27;</span>]            <span class="comment"># 表示按&#x27;pub_date&#x27;字段进行降序排列</span></span><br><span class="line">ordering = [<span class="string">&#x27;-pub_date&#x27;</span>, <span class="string">&#x27;author&#x27;</span>]  <span class="comment"># 表示先按&#x27;pub_date&#x27;字段进行降序排列，再按`author`字段进行升序排列。</span></span><br></pre></td></tr></table></figure><h4 id="unique_together">unique_together</h4><p>这个元数据是非常重要的一个！它<strong>等同于数据库的联合约束！</strong></p><p>举个例子，假设有一张用户表，保存有用户的姓名、出生日期、性别和籍贯等等信息。要求是所有的用户唯一不重复，可现在有好几个叫“张伟”的，如何区别它们呢？（不要说主键唯一，这里讨论的不是这个问题）</p><p>我们可以设置不能有两个用户在同一个地方同一时刻出生并且都叫“张伟”，使用这种联合约束，保证数据库能不能重复添加用户（也不要和我谈小概率问题）。在Django的模型中，如何实现这种约束呢？</p><p>使用<code>unique_together</code>，也就是联合唯一！</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_together = [[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;birth_day&#x27;</span>, <span class="string">&#x27;address&#x27;</span>],......]</span><br></pre></td></tr></table></figure><p>这样，哪怕有两个在同一天出生的张伟，但他们的籍贯不同，也就是两个不同的用户。一旦三者都相同，则会被Django拒绝创建。这个元数据选项经常被用在admin后台，并且强制应用于数据库层面。</p><p>unique_together接收一个二维的列表，每个元素都是一维列表，表示一组联合唯一约束，可以同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_together = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;birth_day&#x27;</span>, <span class="string">&#x27;address&#x27;</span>]</span><br></pre></td></tr></table></figure><p>联合唯一无法作用于普通的多对多字段。</p><h4 id="proxy">proxy</h4><p>如果设置了<code>proxy = True</code>，表示使用代理模式的模型继承方式。具体内容与abstract选项一样，参考模型继承章节。</p><h4 id="verbose_name-1">verbose_name</h4><p>最常用的元数据之一！用于设置模型对象的直观、人类可读的名称，用于在各种打印、页面展示等场景。可以用中文。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verbose_name = <span class="string">&quot;story&quot;</span></span><br><span class="line">verbose_name = <span class="string">&quot;披萨&quot;</span></span><br></pre></td></tr></table></figure><p>如果你不指定它，那么Django会使用小写的模型名作为默认值。</p><h4 id="verbose_name_plural">verbose_name_plural</h4><p>英语有单数和复数形式。这个就是模型对象的复数名，比如“apples”。因为我们中文通常不区分单复数，所以保持和<code>verbose_name</code>一致也可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">verbose_name_plural = <span class="string">&quot;stories&quot;</span></span><br><span class="line">verbose_name_plural = <span class="string">&quot;披萨&quot;</span></span><br><span class="line">verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure><p>如果不指定该选项，那么默认的复数名字是<code>verbose_name</code>加上‘s’</p><h4 id="permissions">permissions</h4><p>该元数据用于当创建对象时增加额外的权限。它接收一个所有元素都是二元元组的列表或元组，每个元素都是<code>(权限代码, 直观的权限名称)</code>的格式。比如下面的例子：</p><p>这个Meta选项非常重要，和auth框架的权限系统紧密相关。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permissions = ((<span class="string">&quot;can_deliver_pizzas&quot;</span>, <span class="string">&quot;可以送披萨&quot;</span>),)</span><br></pre></td></tr></table></figure><h2 id="模型的继承">1.5 模型的继承</h2><p>Django中所有的模型都必须继承<code>django.db.models.Model</code>模型</p><p>Django有三种继承的方式：</p><ul><li><u>抽象基类</u>：被用来继承的模型被称为<code>Abstract base classes</code>，将子类共同的数据抽离出来，供子类继承重用，它不会创建实际的数据表；</li><li><u>多表继承</u>：<code>Multi-table inheritance</code>，每一个模型都有自己的数据库表，父子之间独立存在；</li><li><u>代理模型</u>：如果你只想修改模型的Python层面的行为，并不想改动模型的字段，可以使用代理模型。</li></ul><p><strong>注意！同Python的继承一样，Django也是可以同时继承两个以上父类的！</strong></p><h3 id="抽象基类">1.5.1 抽象基类</h3><p>只需要在模型的Meta类里添加<code>abstract=True</code>元数据项，就可以将一个模型转换为抽象基类。Django不会为这种类创建实际的数据库表，它们也没有管理器，不能被实例化也无法直接保存，它们就是被当作父类供起来，让子类继承的。抽象基类完全就是用来保存子模型们共有的内容部分，达到重用的目的。当它们被继承时，它们的字段会全部复制到子模型中。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    age = models.PositiveIntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">CommonInfo</span>):</span></span><br><span class="line">    home_group = models.CharField(max_length=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>Student模型将拥有name，age，home_group三个字段，并且CommonInfo模型不能当做一个正常的模型使用，不会有这张表出现。</p><p>那如果我想修改CommonInfo父类中的name字段的定义呢？</p><ul><li>在Student类中创建一个name字段，覆盖父类的即可。</li></ul><p>那如果我不需要CommonInfo父类中的name字段呢？</p><ul><li>在Student类中创建一个name变量，值设为None即可。</li></ul><h4 id="抽象基类的meta数据">抽象基类的Meta数据：</h4><p>如果子类没有声明自己的Meta类，那么它将自动继承抽象基类的Meta类。</p><p>如果子类要设置自己的Meta属性，则需要扩展基类的Meta：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line">        ordering = [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">CommonInfo</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>(<span class="params">CommonInfo.Meta</span>):</span>   <span class="comment"># 注意这里有个继承关系</span></span><br><span class="line">        db_table = <span class="string">&#x27;student_info&#x27;</span></span><br></pre></td></tr></table></figure><p>这里有几点要特别说明：</p><ul><li><p>抽象基类中有的元数据，子模型没有的话，直接继承；子模型也有的话，直接覆盖；</p></li><li><p>子模型可以额外添加元数据；</p></li><li><p>抽象基类中的<code>abstract=True</code>这个元数据不会被继承。也就是说如果想让一个抽象基类的子模型，同样成为一个抽象基类，那你必须显式的在该子模型的Meta中同样声明一个<code>abstract = True</code>；</p></li><li><p>有一些元数据对抽象基类无效，比如<code>db_table</code>，首先是抽象基类本身不会创建数据表，其次它的所有子类也不会按照这个元数据来设置表名。</p></li><li><p>由于Python继承的工作机制，如果子类继承了多个抽象基类，则默认情况下仅继承第一个列出的基类的 Meta 选项。如果要从多个抽象基类中继承 Meta 选项，必须显式地声明 Meta 继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    age = models.PositiveIntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line">        ordering = [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unmanaged</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line">        managed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">CommonInfo, Unmanaged</span>):</span></span><br><span class="line">    home_group = models.CharField(max_length=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>(<span class="params">CommonInfo.Meta, Unmanaged.Meta</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="多表继承">1.5.2 多表继承</h3><p>这种继承方式下，父类和子类都是独立自主、功能完整、可正常使用的模型，都有自己的数据库表，内部隐含了一个一对一的关系。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Place</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span>(<span class="params">Place</span>):</span></span><br><span class="line">    serves_hot_dogs = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    serves_pizza = models.BooleanField(default=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="meta和多表继承">Meta和多表继承</h4><p>在多表继承的情况下，由于父类和子类都在数据库内有物理存在的表，父类的Meta类会对子类造成不确定的影响，因此，Django在这种情况下关闭了子类继承父类的Meta功能。这一点和抽象基类的继承方式有所不同。</p><p>但是，还有两个Meta元数据属性特殊一点，那就是<code>ordering</code>和<code>get_latest_by</code>，这两个参数是会被继承的。因此，如果在多表继承中，你不想让你的子类继承父类的上面两种参数，就必须在子类中显示的指出或重写。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildModel</span>(<span class="params">ParentModel</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># 移除父类对子类的排序影响</span></span><br><span class="line">        ordering = []</span><br></pre></td></tr></table></figure><h4 id="多表继承和反向关联">多表继承和反向关联</h4><p>因为多表继承使用了一个隐含的OneToOneField来链接子类与父类，所以象上例那样，你可以从父类访问子类。但是这个OnetoOneField字段默认的<code>related_name</code>值与ForeignKey和 ManyToManyField默认的反向名称相同。如果你与父类或另一个子类做多对一或是多对多关系，你就必须在每个多对一和多对多字段上强制指定<code>related_name</code>。如果你没这么做，Django就会在你运行或验证(validation)时抛出异常。</p><p>仍以上面Place类为例，我们创建一个带有ManyToManyField字段的子类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Supplier</span>(<span class="params">Place</span>):</span></span><br><span class="line">    customers = models.ManyToManyField(Place)</span><br></pre></td></tr></table></figure><p>这会产生下面的错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reverse query name <span class="keyword">for</span> <span class="string">&#x27;Supplier.customers&#x27;</span> clashes <span class="keyword">with</span> reverse query</span><br><span class="line">name <span class="keyword">for</span> <span class="string">&#x27;Supplier.place_ptr&#x27;</span>.</span><br><span class="line">HINT: Add <span class="keyword">or</span> change a related_name argument to the definition <span class="keyword">for</span></span><br><span class="line"><span class="string">&#x27;Supplier.customers&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;Supplier.place_ptr&#x27;</span>.</span><br></pre></td></tr></table></figure><p>解决方法是：向customers字段中添加<code>related_name</code>参数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customers = models.ManyToManyField(Place, related_name=<span class="string">&#x27;provider&#x27;</span>)。</span><br></pre></td></tr></table></figure><h3 id="代理模型">1.5.3 代理模型</h3><p>使用多表继承时，父类的每个子类都会创建一张新数据表，通常情况下，这是我们想要的操作，因为子类需要一个空间来存储不包含在父类中的数据。但有时，你可能只想更改模型在Python层面的行为，比如更改默认的manager管理器，或者添加一个新方法。</p><p>代理模型就是为此而生的。你可以创建、删除、更新代理模型的实例，并且所有的数据都可以像使用原始模型（非代理类模型）一样被保存。不同之处在于你可以在代理模型中改变默认的排序方式和默认的manager管理器等等，而不会对原始模型产生影响。</p><p>代理模型其实就是给原模型换了件衣服（API），实际操作的还是原来的模型和数据。</p><p><strong>声明一个代理模型只需要将Meta中proxy的值设为True。</strong></p><p>例如你想给Person模型添加一个方法。你可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPerson</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        proxy = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>MyPerson类将操作和Person类同一张数据库表。并且任何新的Person实例都可以通过MyPerson类进行访问，反之亦然。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person.objects.create(first_name=<span class="string">&quot;foobar&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyPerson.objects.get(first_name=<span class="string">&quot;foobar&quot;</span>)</span><br><span class="line">&lt;MyPerson: foobar&gt;</span><br></pre></td></tr></table></figure><p>下面的例子通过代理进行排序，但父类却不排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedPerson</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># 现在，普通的Person查询是无序的，而OrderedPerson查询会按照`last_name`排序。</span></span><br><span class="line">        ordering = [<span class="string">&quot;last_name&quot;</span>]</span><br><span class="line">        proxy = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>一些约束：</strong></p><ul><li>代理模型必须继承自一个非抽象的基类，并且不能同时继承多个非抽象基类；</li><li>代理模型可以同时继承任意多个抽象基类，前提是这些抽象基类没有定义任何模型字段。</li><li>代理模型可以同时继承多个别的代理模型，前提是这些代理模型继承同一个非抽象基类。</li></ul><h3 id="多重继承">1.5.4 多重继承</h3><p>注意，多重继承和多表继承是两码事，两个概念。</p><p>Django的模型体系支持多重继承，就像Python一样。如果多个父类都含有Meta类，则只有第一个父类的会被使用，剩下的会忽略掉。</p><p>一般情况，能不要多重继承就不要，尽量让继承关系简单和直接，避免不必要的混乱和复杂。</p><h2 id="验证器">1.6 验证器</h2><p>在Django的模型字段参数中，有一个参数叫做<code>validators</code>，这个参数是用来指定当前字段需要使用的验证器，也就是对字段数据的合法性进行验证，比如大小、类型等。</p><p>Django的验证器可以分为模型相关的验证器和表单相关的验证器，它们基本类似，但在使用上有区别。</p><p>详情请见<a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/101">这里</a>，这里讨论模型相关的验证器。</p><h2 id="查询操作">1.7 查询操作</h2><p>查询操作是Django的ORM框架中最重要的内容之一。我们建立模型、保存数据为的就是在需要的时候可以查询得到数据。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    tagline = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    email = models.EmailField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)</span><br><span class="line">    headline = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    body_text = models.TextField()</span><br><span class="line">    pub_date = models.DateField()</span><br><span class="line">    mod_date = models.DateField()</span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br><span class="line">    number_of_comments = models.IntegerField()</span><br><span class="line">    number_of_pingbacks = models.IntegerField()</span><br><span class="line">    rating = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.headline</span><br></pre></td></tr></table></figure><h3 id="创建对象">1.7.1 创建对象</h3><p>创建一个模型实例，也就是一条数据库记录，最一般的方式是使用模型类的实例化构造方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = Blog.objects.create(name=<span class="string">&#x27;小张&#x27;</span>, tagline=<span class="string">&#x27;你猜&#x27;</span>)</span><br></pre></td></tr></table></figure><p>有时实现一些额外需求，常见的做法是自定义<code>__init__</code>方法。但这不好，容易打断Django源码的调用链，存在漏洞。更推荐的是下面的方法：</p><ul><li>自定义管理器，并在其中添加创建对象的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookManager</span>(<span class="params">models.Manager</span>):</span>   <span class="comment"># 继承默认的管理器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_book</span>(<span class="params">self, title</span>):</span></span><br><span class="line">        book = self.create(title=title)</span><br><span class="line">        <span class="comment"># 将你的个人代码放在这里</span></span><br><span class="line">        print(<span class="string">&#x27;测试一下是否工作正常&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> book</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    objects = BookManager()   <span class="comment"># 赋值objects</span></span><br><span class="line"></span><br><span class="line">book = Book.objects.create_book(<span class="string">&quot;www&quot;</span>)   <span class="comment">#改为使用create_book方法创建对象</span></span><br></pre></td></tr></table></figure><h3 id="修改对象并保存">1.7.2 修改对象并保存</h3><p>我们往往会重写save方法，添加自己的业务逻辑，然后在其中调用原来的save方法，保证Django基本工作机制正常。比如下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Blog(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;100)</span><br><span class="line">    tagline &#x3D; models.TextField()</span><br><span class="line"></span><br><span class="line">    def save(self, *args, **kwargs):</span><br><span class="line">        do_something()   # 保存前做点私活</span><br><span class="line">        super().save(*args, **kwargs)  # 一定不要忘记这行代码</span><br><span class="line">        do_something_else()  # 保存后又加塞点东西</span><br></pre></td></tr></table></figure><p>这样，任何一篇博客在保存前后都会执行一些额外的代码。</p><p>注意，千万不要忘记<code>super().save(*args, **kwargs)</code>，这行确保了Django源码中关于save方法的代码会依然被执行。</p><p>下面的例子则是对博客名字做限制，只有小张的博客才可以保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    tagline = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.name != <span class="string">&quot;小张的博客&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="comment"># 只有小张的博客才可以保存</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">super</span>().save(*args, **kwargs)  <span class="comment"># 调用真正的save方法</span></span><br></pre></td></tr></table></figure><p><code>*args, **kwargs</code>的参数设计，确保我们自定义的save方法是个万金油，不论Django源码中的save方法的参数怎么变，我们自己的save方法不会因为参数定义的不正确而出现bug。</p><p>此外：</p><p>执行save方法后，Django才会真正为对象设置自增主键的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = Blog(name=<span class="string">&#x27;Cheddar Talk&#x27;</span>, tagline=<span class="string">&#x27;Thoughts on cheese.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2.<span class="built_in">id</span>     <span class="comment"># 返回None，因为此时b2还没有写入数据库，没有id值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2.<span class="built_in">id</span>     <span class="comment"># 这回有了</span></span><br></pre></td></tr></table></figure><p>当然，你也可以自己指定主键的值，不需要等待数据库为主键分配值，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b3 = Blog(<span class="built_in">id</span>=<span class="number">3</span>, name=<span class="string">&#x27;Cheddar Talk&#x27;</span>, tagline=<span class="string">&#x27;Thoughts on cheese.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b3.<span class="built_in">id</span>     <span class="comment"># 返回 3.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b3.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b3.<span class="built_in">id</span>     <span class="comment"># 返回 3.</span></span><br></pre></td></tr></table></figure><p>很显然，你必须确保分配的主键值是没有被使用过的，否则肯定出问题，因为在这种情况下，Django认为你是在更新一条已有的数据对象，而不是新建对象，比如下面的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b4 = Blog(<span class="built_in">id</span>=<span class="number">3</span>, name=<span class="string">&#x27;Not Cheddar&#x27;</span>, tagline=<span class="string">&#x27;Anything but cheese.&#x27;</span>)</span><br><span class="line">b4.save() </span><br><span class="line"><span class="comment"># 实际上是更新了上面的b3，而不是新建，此时b4==b3</span></span><br></pre></td></tr></table></figure><p>上面现象的本质是Django对SQL的INSERT和UPDATE语句进行了抽象合并，共用一个save方法。</p><p>有些罕见情况下，可能你必须强制进行INSERT或者UPDATE操作，而不是让Django自动决定。这时候可以使用save方法的<code>force_insert</code>和<code>force_update</code>参数，将其中之一设置为True，强制指定保存模式。</p><ul><li>保存外键和多对多字段:</li></ul><p>保存一个外键字段和保存普通字段没什么区别，只是要注意值的类型要正确。下面的例子，有一个Entry的实例entry和一个Blog的实例<code>cheese_blog</code>，然后把<code>cheese_blog</code>作为值赋给了entry的blog属性，最后调用save方法进行保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from blog.models import Blog, Entry</span><br><span class="line">&gt;&gt;&gt; entry &#x3D; Entry.objects.get(pk&#x3D;1)</span><br><span class="line">&gt;&gt;&gt; cheese_blog &#x3D; Blog.objects.get(name&#x3D;&quot;Cheddar Talk&quot;)</span><br><span class="line">&gt;&gt;&gt; entry.blog &#x3D; cheese_blog</span><br><span class="line">&gt;&gt;&gt; entry.save()</span><br></pre></td></tr></table></figure><p>多对多字段的保存稍微有点区别，需要调用一个<code>add()</code>方法，而不是直接给属性赋值，但它不需要调用save方法。如下例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from blog.models import Author</span><br><span class="line">&gt;&gt;&gt; joe &#x3D; Author.objects.create(name&#x3D;&quot;Joe&quot;)</span><br><span class="line">&gt;&gt;&gt; entry.authors.add(joe)</span><br></pre></td></tr></table></figure><p>在一行语句内，可以同时添加多个对象到多对多的字段，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; john &#x3D; Author.objects.create(name&#x3D;&quot;John&quot;)</span><br><span class="line">&gt;&gt;&gt; paul &#x3D; Author.objects.create(name&#x3D;&quot;Paul&quot;)</span><br><span class="line">&gt;&gt;&gt; george &#x3D; Author.objects.create(name&#x3D;&quot;George&quot;)</span><br><span class="line">&gt;&gt;&gt; ringo &#x3D; Author.objects.create(name&#x3D;&quot;Ringo&quot;)</span><br><span class="line">&gt;&gt;&gt; entry.authors.add(john, paul, george, ringo)</span><br></pre></td></tr></table></figure><p>如果你指定或添加了错误类型的对象，Django会抛出异常。</p><h3 id="检索对象">1.7.3 检索对象</h3><p>想要从数据库内检索对象，你需要基于模型类，通过管理器（Manager）操作数据库并返回一个查询结果集（QuerySet）。</p><p>详情请看有关<a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/129">查询结果集（QuerySet）</a>的介绍</p><h2 id="返回querysets的api">1.8 返回QuerySets的API</h2><p><a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/130">详情请看有关介绍</a></p><h2 id="不返回querysets的api">1.9 不返回QuerySets的API</h2><p>以下的方法不会返回QuerySets，但是作用非常强大，尤其是粗体显示的方法，需要背下来。</p><table><thead><tr class="header"><th>方法名</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><strong>get()</strong></td><td>获取单个对象</td></tr><tr class="even"><td><strong>create()</strong></td><td>创建对象，无需save()</td></tr><tr class="odd"><td><strong>get_or_create()</strong></td><td>查询对象，如果没有找到就新建对象</td></tr><tr class="even"><td><strong>update_or_create()</strong></td><td>更新对象，如果没有找到就创建对象</td></tr><tr class="odd"><td><code>bulk_create()</code></td><td>批量创建对象</td></tr><tr class="even"><td>bulk_update()</td><td>批量更新对象</td></tr><tr class="odd"><td><strong>count()</strong></td><td>统计对象的个数</td></tr><tr class="even"><td><code>in_bulk()</code></td><td>根据主键值的列表，批量返回对象</td></tr><tr class="odd"><td><code>iterator()</code></td><td>获取包含对象的迭代器</td></tr><tr class="even"><td><strong>latest()</strong></td><td>获取最近的对象</td></tr><tr class="odd"><td><strong>earliest()</strong></td><td>获取最早的对象</td></tr><tr class="even"><td><strong>first()</strong></td><td>获取第一个对象</td></tr><tr class="odd"><td><strong>last()</strong></td><td>获取最后一个对象</td></tr><tr class="even"><td><strong>aggregate()</strong></td><td>聚合操作</td></tr><tr class="odd"><td><strong>exists()</strong></td><td>判断queryset中是否有对象</td></tr><tr class="even"><td><strong>update()</strong></td><td>更新对象</td></tr><tr class="odd"><td><strong>delete()</strong></td><td>删除对象</td></tr><tr class="even"><td>as_manager()</td><td>获取管理器</td></tr><tr class="odd"><td>explain()</td><td>对数据库操作的解释性信息</td></tr></tbody></table><h4 id="get">1. get()</h4><p>返回按照查询参数匹配到的单个对象，参数的格式应该符合Field lookups的要求。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">Entry.objects.get(blog=blog, entry_number=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>如果匹配到的对象个数不只一个的话，触发<code>MultipleObjectsReturned</code>异常:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.get(name=<span class="string">&#x27;张伟&#x27;</span>) </span><br><span class="line"><span class="comment"># raises Entry.MultipleObjectsReturned</span></span><br></pre></td></tr></table></figure><p>如果根据给出的参数匹配不到对象的话，触发DoesNotExist异常。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.get(<span class="built_in">id</span>=-<span class="number">999</span>) </span><br><span class="line"><span class="comment"># raises Entry.DoesNotExist</span></span><br></pre></td></tr></table></figure><p>DoesNotExist异常从<code>django.core.exceptions.ObjectDoesNotExist</code>继承，可以定位多个DoesNotExist异常。 例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ObjectDoesNotExist</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    blog = Blog.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">    entry = Entry.objects.get(blog=blog, entry_number=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">    print(<span class="string">&quot;Either the blog or entry doesn&#x27;t exist.&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果希望查询器只返回一个对象，则可以使用get()，无需添加任何参数：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">entry = Entry.objects.filter(...).exclude(...).get()</span></span><br></pre></td></tr></table></figure><h4 id="create">2. create()</h4><p>在一步操作中同时创建并且保存对象的便捷方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = Person.objects.create(first_name=<span class="string">&quot;Bruce&quot;</span>, last_name=<span class="string">&quot;Springsteen&quot;</span>)</span><br></pre></td></tr></table></figure><p>等于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = Person(first_name=<span class="string">&quot;Bruce&quot;</span>, last_name=<span class="string">&quot;Springsteen&quot;</span>)</span><br><span class="line">p.save(force_insert=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>参数<code>force_insert</code>表示强制创建对象。如果model中有一个你手动设置的主键，并且这个值已经存在于数据库中, 调用create()将会失败并且触发IntegrityError因为主键必须是唯一的。如果你手动设置了主键，做好异常处理的准备。</p><h4 id="get_or_create">3. get_or_create()</h4><p><strong>通过kwargs来查询对象的便捷方法（如果模型中的所有字段都有默认值，可以为空），如果该对象不存在则创建一个新对象</strong>。</p><p>该方法<strong>返回一个由(object, created)组成的元组</strong>，元组中的object 是一个查询到的或者是被创建的对象， created是一个表示是否创建了新的对象的布尔值。</p><p>对于下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    obj = Person.objects.get(first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line">    obj = Person(first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>, birthday=date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">9</span>))</span><br><span class="line">    obj.save()</span><br></pre></td></tr></table></figure><p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用<code>get_or_create()</code>重写 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj, created = Person.objects.get_or_create(</span><br><span class="line">    first_name=<span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    last_name=<span class="string">&#x27;Lennon&#x27;</span>,</span><br><span class="line">    defaults=&#123;<span class="string">&#x27;birthday&#x27;</span>: date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">9</span>)&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>任何传递给<code>get_or_create()</code>的关键字参数，除了一个可选的defaults，都将传递给get()调用。 如果查找到一个对象，返回一个包含匹配到的对象以及False 组成的元组。</p><h4 id="update_or_create">4. update_or_create()</h4><p>类似前面的<code>get_or_create()</code>。</p><p><strong>通过给出的kwargs来更新对象的便捷方法， 如果没找到对象，则创建一个新的对象</strong>。defaults是一个由 (field, value)对组成的字典，用于更新对象。defaults中的值可以是可调用对象（也就是说函数等）。</p><p>该方法返回一个由(object, created)组成的元组,元组中的object是一个创建的或者是被更新的对象， created是一个标示是否创建了新的对象的布尔值。</p><p><code>update_or_create</code>方法尝试通过给出的kwargs 去从数据库中获取匹配的对象。 如果找到匹配的对象，它将会依据defaults 字典给出的值更新字段。</p><p>像下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaults = &#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    obj = Person.objects.get(first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> defaults.items():</span><br><span class="line">        <span class="built_in">setattr</span>(obj, key, value)</span><br><span class="line">    obj.save()</span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line">    new_values = &#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Lennon&#x27;</span>&#125;</span><br><span class="line">    new_values.update(defaults)</span><br><span class="line">    obj = Person(**new_values)</span><br><span class="line">    obj.save()</span><br></pre></td></tr></table></figure><p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用<code>update_or_create()</code> 重写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj, created = Person.objects.update_or_create(</span><br><span class="line">    first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>,</span><br><span class="line">    defaults=&#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>kwargs中的名称如何解析的详细描述可以参见<code>get_or_create()</code>。</p><p>和<code>get_or_create()</code>一样，这个方法也容易导致竞态条件，如果数据库层级没有前置唯一性会让多行同时插入。</p><h4 id="count">5. count()</h4><p>count()</p><p>返回在数据库中对应的QuerySet对象的个数。count()永远不会引发异常。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回总个数.</span></span><br><span class="line">Entry.objects.count()</span><br><span class="line"><span class="comment"># 返回包含有&#x27;Lennon&#x27;的对象的总数</span></span><br><span class="line">Entry.objects.<span class="built_in">filter</span>(headline__contains=<span class="string">&#x27;Lennon&#x27;</span>).count()</span><br></pre></td></tr></table></figure><h4 id="exists">6. exists()</h4><p>如果QuerySet包含任何结果，则返回True，否则返回False。</p><p>查找具有唯一性字段（例如primary_key）的模型是否在一个QuerySet中的最高效的方法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entry = Entry.objects.get(pk=<span class="number">123</span>)</span><br><span class="line"><span class="keyword">if</span> some_queryset.<span class="built_in">filter</span>(pk=entry.pk).exists():</span><br><span class="line">    print(<span class="string">&quot;Entry contained in queryset&quot;</span>)</span><br></pre></td></tr></table></figure><p>它将比下面的方法快很多，这个方法要求对QuerySet求值并迭代整个QuerySet：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> entry <span class="keyword">in</span> some_queryset:</span><br><span class="line">   print(<span class="string">&quot;Entry contained in QuerySet&quot;</span>)</span><br></pre></td></tr></table></figure><p>若要查找一个QuerySet是否包含任何元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> some_queryset.exists():</span><br><span class="line">    print(<span class="string">&quot;There is at least one object in some_queryset&quot;</span>)</span><br></pre></td></tr></table></figure><p>将快于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> some_queryset:</span><br><span class="line">    print(<span class="string">&quot;There is at least one object in some_queryset&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="update">7. update()</h4><p><strong>对指定的字段执行更新操作，并返回匹配的行数</strong>（如果某些行已具有新值，则可能不等于已更新的行数）。</p><p>例如，要对2010年发布的所有博客条目关闭评论功能，可以执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2010</span>).update(comments_on=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>可以同时更新多个字段 （没有多少字段的限制）。 例如同时更新comments_on和headline字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2010</span>).update(comments_on=<span class="literal">False</span>, headline=<span class="string">&#x27;This is old&#x27;</span>)</span><br></pre></td></tr></table></figure><p>update()方法无需save操作，会立刻写入数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update只能更新模型主表中的字段，不能更新关联模型中的字段。</span><br></pre></td></tr></table></figure><p>例如不能这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.update(blog__name=<span class="string">&#x27;foo&#x27;</span>) <span class="comment"># 这样做是无效的</span></span><br></pre></td></tr></table></figure><p>但是，仍然可以根据相关字段进行过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(blog__id=<span class="number">1</span>).update(comments_on=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>update()方法返回受影响的行数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">64</span>).update(comments_on=<span class="literal">True</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(slug=<span class="string">&#x27;nonexistent-slug&#x27;</span>).update(comments_on=<span class="literal">True</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2010</span>).update(comments_on=<span class="literal">False</span>)</span><br><span class="line"><span class="number">132</span></span><br></pre></td></tr></table></figure><p>如果你只是更新一下对象，不需要为对象做别的事情，最有效的方法是调用update()，而不是将模型对象加载到内存中。 例如，不要这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e = Entry.objects.get(<span class="built_in">id</span>=<span class="number">10</span>)</span><br><span class="line">e.comments_on = <span class="literal">False</span></span><br><span class="line">e.save()</span><br></pre></td></tr></table></figure><p>建议如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">10</span>).update(comments_on=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>用update()还可以防止在加载对象和调用save()之间的短时间内数据库中某些内容可能发生更改的竞争条件。</p><p><code>update()方法不会调用save()方法，也不会发出pre_save和post_save信号。</code>所以，如果想更新一个具有自定义save()方法的模型的记录，请循环遍历它们并调用save()，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2020</span>):</span><br><span class="line">    e.comments_on = <span class="literal">False</span></span><br><span class="line">    e.save()</span><br></pre></td></tr></table></figure><h4 id="delete">8. delete()</h4><p>批量删除QuerySet中的所有对象，并返回删除的对象个数和每个对象类型的删除次数的字典。</p><p>delete()动作是立即执行的。</p><p>例如，要删除特定博客中的所有条目：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Blog.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 删除b下所属的所有条目</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(blog=b).delete()</span><br><span class="line">(<span class="number">4</span>, &#123;<span class="string">&#x27;weblog.Entry&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下，任何具有指向要删除的对象的外键的对象将与它们一起被删除。 像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>blogs = Blog.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="comment"># This will delete all Blogs and all of their Entry objects.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blogs.delete()</span><br><span class="line">(<span class="number">5</span>, &#123;<span class="string">&#x27;weblog.Blog&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;weblog.Entry&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><p>这种级联的行为可以通过的ForeignKey的<code>on_delete</code>参数自定义。（什么时候要改变这种行为呢？比如日志数据，就不能和它关联的主体一并被删除！）</p><p>delete()会为所有已删除的对象（包括级联删除）发出<code>pre_delete</code>和<code>post_delete</code>信号。</p><p>详情请百度，或查阅<a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/131">这里</a>。</p><h2 id="注解与聚合">1.10 注解与聚合</h2><p>Django的ORM提供的API主要是用来增删查改单个对象的方法。 然而，有时候你要获取的值需要根据一组对象聚合后才能得到，比如几个学生成绩的平均分，非常类似数据分析和统计。</p><p>本节以下面的模型为例，来记录多个网上书店的库存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line">    pages = models.IntegerField()</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">10</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    rating = models.FloatField()</span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br><span class="line">    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)</span><br><span class="line">    pubdate = models.DateField()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line">    books = models.ManyToManyField(Book)</span><br></pre></td></tr></table></figure><h3 id="速查表">速查表</h3><p>下面是根据以上模型执行常见的聚合查询范例，注意阅读其中的注释文字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 书籍的总数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.count()</span><br><span class="line"><span class="number">2452</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BaloneyPress出版社出版的书籍总数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.<span class="built_in">filter</span>(publisher__name=<span class="string">&#x27;BaloneyPress&#x27;</span>).count()</span><br><span class="line"><span class="number">73</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有书籍的平均价格</span></span><br><span class="line"><span class="comment"># 要注意！Avg，Count等聚合工具是由Django提供的，不是Python内置的，也不是你自己编写的。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.<span class="built_in">all</span>().aggregate(Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;price__avg&#x27;</span>: <span class="number">34.35</span>&#125;   <span class="comment"># 本来返回的是查询集，聚合后返回的是一个数据字典，字典的键名是有规律的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有书籍中最高的价格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Max</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.<span class="built_in">all</span>().aggregate(Max(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;price__max&#x27;</span>: Decimal(<span class="string">&#x27;81.20&#x27;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有书籍中最高价和平均价的差</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> FloatField</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.aggregate(</span><br><span class="line"><span class="meta">... </span>    price_diff=Max(<span class="string">&#x27;price&#x27;</span>, output_field=FloatField()) - Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;price_diff&#x27;</span>: <span class="number">46.85</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是annonte注解的用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个被过滤出来的出版社对象都被附加了一个&quot;num_books&quot;属性，这个属性就是所谓的注释</span></span><br><span class="line"><span class="comment"># 和aggregate不同，annotate返回的依然是查询集，添加了私货的查询集。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="string">&#x27;book&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs</span><br><span class="line">&lt;QuerySet [&lt;Publisher: BaloneyPress&gt;, &lt;Publisher: SalamiPress&gt;, ...]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].num_books</span><br><span class="line"><span class="number">73</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个出版商都被附加了两个额外的属性，分别表示好评率大于5和好评率小于等于5的书籍的总数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"><span class="comment"># 统计每个出版社中好评率大于5的书籍的数量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>above_5 = Count(<span class="string">&#x27;book&#x27;</span>, <span class="built_in">filter</span>=Q(book__rating__gt=<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>below_5 = Count(<span class="string">&#x27;book&#x27;</span>, <span class="built_in">filter</span>=Q(book__rating__lte=<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要理解这里的链式调用含义。annotate不是filter，不会增减查询集的元素。</span></span><br><span class="line"><span class="comment"># 所以Publisher.objects实际上等于pubs=Publisher.objects.all()</span></span><br><span class="line"><span class="comment"># 第一个annotate为pubs增加below_5属性，第二个annotate又再次增加above_5属性</span></span><br><span class="line"><span class="comment"># 虽然是链式调用，但不是过滤行为，而是追加行为</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(below_5=below_5).annotate(above_5=above_5)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].above_5</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].below_5</span><br><span class="line"><span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个比较复杂。首先获取了所有的出版社。其次统计每个出版社的发行书籍数量，保存在num_books属性中。</span></span><br><span class="line"><span class="comment"># 然后对所有的出版社进行排序，根据num_books属性进行反向由多到少排序，最后切片获取前5个出版社。</span></span><br><span class="line">The top <span class="number">5</span> publishers, <span class="keyword">in</span> order by number of books.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="string">&#x27;book&#x27;</span>)).order_by(<span class="string">&#x27;-num_books&#x27;</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].num_books</span><br><span class="line"><span class="number">1323</span></span><br></pre></td></tr></table></figure></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>小张同学</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://stuxiaozhang.github.io/2020/10/28/Django%E5%9F%BA%E7%A1%80/" title="Django基础----模型层">http://stuxiaozhang.github.io/2020/10/28/Django基础/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Python/" rel="tag"><i class="fa fa-tag"></i> Python</a> <a href="/tags/Django/" rel="tag"><i class="fa fa-tag"></i> Django</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/10/26/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="prev" title="《机器学习》课程笔记"><i class="fa fa-chevron-left"></i> 《机器学习》课程笔记</a></div><div class="post-nav-item"><a href="/2020/10/30/Django%E5%9F%BA%E7%A1%802/" rel="next" title="Django基础----视图层">Django基础----视图层 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#django%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">0. Django介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">1. 模型层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AD%97%E6%AE%B5"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 模型和字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">模型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%AD%97%E6%AE%B5fields"><span class="nav-number">2.3.</span> <span class="nav-text">模型字段fields</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5"><span class="nav-number">2.4.</span> <span class="nav-text">1.2 关系类型字段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80foreignkey"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.2.1 多对一（ForeignKey）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">参数说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#on_delete"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">on_delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#limit_choices_to"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">limit_choices_to</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#related_name"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">related_name</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9Amanytomanyfield"><span class="nav-number">2.4.2.</span> <span class="nav-text">1.2.2 多对多（ManyToManyField）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80onetoonefield"><span class="nav-number">2.4.3.</span> <span class="nav-text">1.2.3 一对一（OneToOneField）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">1.3 字段的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">2.5.0.1.</span> <span class="nav-text">null</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#blank"><span class="nav-number">2.5.0.2.</span> <span class="nav-text">blank</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#choices"><span class="nav-number">2.5.0.3.</span> <span class="nav-text">choices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#primary_key"><span class="nav-number">2.5.0.4.</span> <span class="nav-text">primary_key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique"><span class="nav-number">2.5.0.5.</span> <span class="nav-text">unique</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#verbose_name"><span class="nav-number">2.5.0.6.</span> <span class="nav-text">verbose_name</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AEmeta"><span class="nav-number">2.6.</span> <span class="nav-text">1.4 模型的元数据Meta</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#abstract"><span class="nav-number">2.6.0.1.</span> <span class="nav-text">abstract</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ordering"><span class="nav-number">2.6.1.</span> <span class="nav-text">ordering</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unique_together"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">unique_together</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#proxy"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">proxy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#verbose_name-1"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">verbose_name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#verbose_name_plural"><span class="nav-number">2.6.1.4.</span> <span class="nav-text">verbose_name_plural</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#permissions"><span class="nav-number">2.6.1.5.</span> <span class="nav-text">permissions</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">2.7.</span> <span class="nav-text">1.5 模型的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-number">2.7.1.</span> <span class="nav-text">1.5.1 抽象基类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E7%9A%84meta%E6%95%B0%E6%8D%AE"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">抽象基类的Meta数据：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E7%BB%A7%E6%89%BF"><span class="nav-number">2.7.2.</span> <span class="nav-text">1.5.2 多表继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#meta%E5%92%8C%E5%A4%9A%E8%A1%A8%E7%BB%A7%E6%89%BF"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">Meta和多表继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8F%8D%E5%90%91%E5%85%B3%E8%81%94"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">多表继承和反向关联</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.7.3.</span> <span class="nav-text">1.5.3 代理模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">2.7.4.</span> <span class="nav-text">1.5.4 多重继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E5%99%A8"><span class="nav-number">2.8.</span> <span class="nav-text">1.6 验证器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">2.9.</span> <span class="nav-text">1.7 查询操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.9.1.</span> <span class="nav-text">1.7.1 创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%BF%9D%E5%AD%98"><span class="nav-number">2.9.2.</span> <span class="nav-text">1.7.2 修改对象并保存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.9.3.</span> <span class="nav-text">1.7.3 检索对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9Equerysets%E7%9A%84api"><span class="nav-number">2.10.</span> <span class="nav-text">1.8 返回QuerySets的API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%BF%94%E5%9B%9Equerysets%E7%9A%84api"><span class="nav-number">2.11.</span> <span class="nav-text">1.9 不返回QuerySets的API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get"><span class="nav-number">2.11.0.1.</span> <span class="nav-text">1. get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#create"><span class="nav-number">2.11.0.2.</span> <span class="nav-text">2. create()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get_or_create"><span class="nav-number">2.11.0.3.</span> <span class="nav-text">3. get_or_create()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#update_or_create"><span class="nav-number">2.11.0.4.</span> <span class="nav-text">4. update_or_create()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#count"><span class="nav-number">2.11.0.5.</span> <span class="nav-text">5. count()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exists"><span class="nav-number">2.11.0.6.</span> <span class="nav-text">6. exists()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#update"><span class="nav-number">2.11.0.7.</span> <span class="nav-text">7. update()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete"><span class="nav-number">2.11.0.8.</span> <span class="nav-text">8. delete()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E4%B8%8E%E8%81%9A%E5%90%88"><span class="nav-number">2.12.</span> <span class="nav-text">1.10 注解与聚合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="nav-number">2.12.1.</span> <span class="nav-text">速查表</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="小张同学" src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/codedog.jpg"><p class="site-author-name" itemprop="name">小张同学</p><div class="site-description" itemprop="description">不要停止奔跑 不要回顾来路</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=709634432" title="QQ → tencent:&#x2F;&#x2F;AddContact&#x2F;?fromId&#x3D;50&amp;fromSubId&#x3D;1&amp;subcmd&#x3D;all&amp;uin&#x3D;709634432" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-qq"></i>QQ</a> </span><span class="links-of-author-item"><a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">小张同学</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">264k</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var i=["nick","mail","link"],e="nick,mail,link".split(",").filter(e=>i.includes(e));new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",avatar:"mm",meta:e,pageSize:"10",visitor:!1,lang:"zh-cn",path:location.pathname,recordIP:!0,serverURLs:""})},window.Valine)})</script></body></html>