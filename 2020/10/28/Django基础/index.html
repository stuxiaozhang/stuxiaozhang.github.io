<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/favicon.png"><link rel="icon" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="0. Django介绍
Django是基于Python的Web开发框架。Web开发指的是开发基于B/S架构，通过前后端的配合，将后台服务器的数据在浏览器上展现给前台用户的应用。
一般Web框架的架构是这样的：

image-20201029080219087

大多数基于Python的web框架，如Django、Tornado、Flask、Webpy都是在这个范围内进行增删裁剪。例如T"><meta name="author" content="小张同学"><meta name="keywords" content=""><title>Django基础----模型层 - 小张同学的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",app_key:"CgnvRL262D07ied40NiXm2VL",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><header style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>xiaozhang's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/schedule/"><i class="iconfont icon-cliplist"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Django基础----模型层"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 小张同学 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-10-28 23:07" pubdate>2020年10月28日</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 12.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 186 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-1"></div><div class="col-lg-9 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Django基础----模型层</h1><p class="note note-info">本文最后更新于：2020年10月30日</p><div class="markdown-body"><h1 id="django介绍">0. Django介绍</h1><p>Django是基于Python的Web开发框架。Web开发指的是开发基于B/S架构，通过前后端的配合，将后台服务器的数据在浏览器上展现给前台用户的应用。</p><p>一般Web框架的架构是这样的：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201029080219087.png" srcset="/img/loading.gif" lazyload alt="image-20201029080219087"><figcaption>image-20201029080219087</figcaption></figure><p>大多数基于Python的web框架，如Django、Tornado、Flask、Webpy都是在这个范围内进行增删裁剪。例如Tornado用的是自己的异步非阻塞“WSGI”网关接口，Flask则只提供了最精简和基本的框架，Django则是直接使用了现成的WSGI，并实现了大部分功能，提供了大量的应用工具。</p><p>MVC及MTV设计模式：</p><ul><li><p>MVC设计模式</p><p><code>MVC</code>把Web框架分为三个基础部分：</p><ul><li><p><strong>模型(Model)</strong>：用于封装与应用程序的业务逻辑相关的数据及对数据的处理方法，是Web应用程序中用于处理应用程序的数据逻辑的部分，Model只提供功能性的接口，通过这些接口可以获取Model的所有功能。白话说，这个模块就是业务逻辑和数据库的交互层，定义了数据表。</p></li><li><p><strong>视图(View)</strong>：负责数据的显示和呈现，是对用户的直接输出。</p></li><li><p><strong>控制器(Controller)</strong>：负责从用户端收集用户的输入，可以看成提供View的反向功能。</p></li></ul><p>这三个部分互相独立，但又相互联系，使得改进和升级界面及用户交互流程，在Web开发过程任务分配时，不需要重写业务逻辑及数据访问代码。</p><p>MVC在Python之外的语言中也有广泛应用，例如VC++的MFC，Java的Structs及Spring、C#的.NET开发框架，都非常有名。</p></li><li><p>MTV设计模式：</p><p>MTV和MVC本质上是一样的。</p><p>Django对传统的MVC设计模式进行了修改，将视图分成View模块和Template模块两部分，将动态的逻辑处理与静态的页面展示分离开。而<u>Model采用了ORM技术，将关系型数据库表抽象成面向对象的Python类，将数据库的表操作转换成Python的类操作，避免了编写复杂的SQL语句。</u></p><ul><li><p><strong>模型(Model)</strong>：和MVC中的定义一样</p></li><li><p><strong>模板(Template)</strong>：将模型数据与HTML页面结合起来的引擎</p></li><li><p><strong>视图(View)</strong>：负责实际的业务逻辑实现</p></li></ul><p>Django的MTV模型组织可参考下图所示：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Django/image-20201029083915147.png" srcset="/img/loading.gif" lazyload alt="image-20201029083915147"><figcaption>image-20201029083915147</figcaption></figure></li></ul><h1 id="模型层">1. 模型层</h1><h2 id="模型和字段">1.1 模型和字段</h2><p>一个模型（model）就是一个单独的、确定的数据的信息源，包含了数据的字段和操作方法。通常，每个模型映射为一张数据库中的表。</p><p>基本的原则如下：</p><ul><li>每个模型在Django中的存在形式为一个Python类</li><li>每个类都是<code>django.db.models.Model</code>的子类</li><li>模型（类）的每个字段（属性）代表数据表的某一列</li><li>Django自动为你生成访问数据库的API</li></ul><p>举个栗子：</p><p>下面的模型定义了一个“人”，它具有<code>first_name</code>和<code>last_name</code>字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">models.Model</span>):</span><br>    first_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br>    last_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>每一个字段都是一个类属性，每个类属性表示数据表中的一个列。</p><p>上面的代码，相当于下面的原生SQL语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">CREATE TABLE myapp_person (<br>    <span class="hljs-string">&quot;id&quot;</span> serial NOT NULL PRIMARY KEY,<br>    <span class="hljs-string">&quot;first_name&quot;</span> varchar(<span class="hljs-number">30</span>) NOT NULL,<br>    <span class="hljs-string">&quot;last_name&quot;</span> varchar(<span class="hljs-number">30</span>) NOT NULL<br>);<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>表名<code>myapp_person</code>由Django自动生成，默认格式为“<code>项目名称+下划线+小写类名</code>”，你可以重写这个规则。</li><li>Django会自动创建自增主键<code>id</code>，当然，你也可以自己指定主键。</li><li>上面的SQL语句基于<code>PostgreSQL</code>语法。</li></ul><p>通常，我们会将模型编写在其所属app下的models.py文件中，没有特别需求时，请坚持这个原则，不要自己给自己添加麻烦。</p><p>创建了模型之后，在使用它之前，需要先在settings文件中的<code>INSTALLED_APPS</code> 处，注册<code>models.py</code>文件所在的<code>myapp</code>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">INSTALLED_APPS</span> = [<br>    <span class="hljs-comment">#...</span><br>    <span class="hljs-string">&#x27;myapp&#x27;</span>,<br>    <span class="hljs-comment">#...</span><br>]<br></code></pre></td></tr></table></figure><p><strong>每次对模型进行增、删、修改时，先执行<code>python manage.py makemigrations</code>让修改动作保存到记录文件中，再执行命令<code>python manage.py migrate</code>，让操作实际应用到数据库上。</strong></p><h2 id="模型方法">模型方法</h2><p>模型的方法其实就是Python的实例方法。Django内置了一些，我们也可以自定义一些。</p><ul><li><code>__str__()</code>： 这个其实是Python的魔法方法，用于返回实例对象的打印字符串。为了让显示的内容更直观更易懂，我们往往自定义这个方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">models.Model</span>):</span><br>    first_name = models.CharField(max_length=<span class="hljs-number">50</span>)<br>    last_name = models.CharField(max_length=<span class="hljs-number">50</span>)<br>    birth_date = models.DateField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.first_name + self.last_name<br></code></pre></td></tr></table></figure><ul><li><code>get_absolute_url()</code>: 这个方法是返回每个模型实例的相应的访问url。</li><li>...</li></ul><h2 id="模型字段fields">模型字段fields</h2><p>Django内置了许多字段类型，它们都位于<code>django.db.models</code>中，例如<code>models.CharField</code>，它们的父类都是Field类。这些类型基本满足需求，如果还不够，也可以自定义字段。</p><table><colgroup><col style="width:29%"><col style="width:70%"></colgroup><thead><tr class="header"><th>类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>AutoField</td><td>一个自动增加的整数类型字段。通常你不需要自己编写它，Django会自动帮你添加字段：<code>id = models.AutoField(primary_key=True)</code>，这是一个自增字段，从1开始计数。如果你非要自己设置主键，那么请务必将字段设置为<code>primary_key=True</code>。Django在一个模型中只允许有一个自增字段，并且该字段必须为主键！</td></tr><tr class="even"><td>BigAutoField</td><td>64位整数类型自增字段，数字范围更大，从1到9223372036854775807</td></tr><tr class="odd"><td>BigIntegerField</td><td>64位整数字段（看清楚，非自增），类似IntegerField ，-9223372036854775808 到9223372036854775807。在Django的模板表单里体现为一个<code>NumberInput</code>标签。</td></tr><tr class="even"><td><strong>BooleanField</strong></td><td>布尔值类型。默认值是None。在HTML表单中体现为CheckboxInput标签。如果设置了参数null=True，则表现为NullBooleanSelect选择框。可以提供default参数值，设置默认值。</td></tr><tr class="odd"><td><strong>CharField</strong></td><td>最常用的类型，字符串类型。必须接收一个max_length参数，表示字符串长度不能超过该值。默认的表单标签是text input。</td></tr><tr class="even"><td><strong>DateField</strong></td><td><code>class DateField(auto_now=False, auto_now_add=False, **options)</code> , 日期类型。一个Python中的datetime.date的实例。在HTML中表现为DateInput标签。在admin后台中，Django会帮你自动添加一个JS日历表和一个“Today”快捷方式，以及附加的日期合法性验证。两个重要参数：（参数互斥，不能共存） <code>auto_now</code>:每当对象被保存时将字段设为当前日期，常用于保存最后修改时间。<code>auto_now_add</code>：每当对象被创建时，设为当前日期，常用于保存创建日期(注意，它是不可修改的)。设置上面两个参数就相当于给field添加了<code>editable=False</code>和<code>blank=True</code>属性。如果想具有修改属性，请用default参数。例子：<code>pub_time = models.DateField(auto_now_add=True)</code>，自动添加发布时间。</td></tr><tr class="odd"><td>DateTimeField</td><td>日期时间类型。Python的datetime.datetime的实例。与DateField相比就是多了小时、分和秒的显示，其它功能、参数、用法、默认值等等都一样。</td></tr><tr class="even"><td>DecimalField</td><td>固定精度的十进制小数。相当于Python的Decimal实例，必须提供两个指定的参数！参数<code>max_digits</code>：最大的位数，必须大于或等于小数点位数 。<code>decimal_places</code>：小数点位数，精度。 当<code>localize=False</code>时，它在HTML表现为NumberInput标签，否则是textInput类型。例子：储存最大不超过999，带有2位小数位精度的数，定义如下：<code>models.DecimalField(..., max_digits=5, decimal_places=2)</code>。</td></tr><tr class="odd"><td><strong>EmailField</strong></td><td>邮箱类型，默认max_length最大长度254位。使用这个字段的好处是，可以使用Django内置的EmailValidator进行邮箱格式合法性验证。</td></tr><tr class="even"><td><strong>FileField</strong></td><td><code>class FileField(upload_to=None, max_length=100, **options)</code>上传文件类型，后面单独介绍。</td></tr><tr class="odd"><td>FilePathField</td><td>文件路径类型，后面单独介绍</td></tr><tr class="even"><td>FloatField</td><td>浮点数类型，对应Python的float。参考整数类型字段。</td></tr><tr class="odd"><td><strong>ImageField</strong></td><td>图像类型，后面单独介绍。</td></tr><tr class="even"><td><strong>IntegerField</strong></td><td>整数类型，最常用的字段之一。取值范围-2147483648到2147483647。在HTML中表现为NumberInput或者TextInput标签。</td></tr><tr class="odd"><td><strong>GenericIPAddressField</strong></td><td><code>class GenericIPAddressField(protocol='both', unpack_ipv4=False, **options)</code>,IPV4或者IPV6地址，字符串形式，例如<code>192.0.2.30</code>或者<code>2a02:42fe::4</code>。在HTML中表现为TextInput标签。参数<code>protocol</code>默认值为‘both’，可选‘IPv4’或者‘IPv6’，表示你的IP地址类型。</td></tr><tr class="even"><td>JSONField</td><td>JSON类型字段。Django3.1新增。签名为<code>class JSONField(encoder=None,decoder=None,**options)</code>。其中的encoder和decoder为可选的编码器和解码器，用于自定义编码和解码方式。如果为该字段提供default值，请务必保证该值是个不可变的对象，比如字符串对象。</td></tr><tr class="odd"><td><strong>TextField</strong></td><td>用于储存大量的文本内容，在HTML中表现为Textarea标签，最常用的字段类型之一！如果你为它设置一个max_length参数，那么在前端页面中会受到输入字符数量限制，然而在模型和数据库层面却不受影响。只有CharField才能同时作用于两者。</td></tr><tr class="even"><td>TimeField</td><td>时间字段，Python中datetime.time的实例。接收同DateField一样的参数，只作用于小时、分和秒。</td></tr><tr class="odd"><td><strong>URLField</strong></td><td>一个用于保存URL地址的字符串类型，默认最大长度200。</td></tr><tr class="even"><td><strong>UUIDField</strong></td><td>用于保存通用唯一识别码（Universally Unique Identifier）的字段。使用Python的UUID类。在PostgreSQL数据库中保存为uuid类型，其它数据库中为char(32)。这个字段是自增主键的最佳替代品。</td></tr></tbody></table><h2 id="关系类型字段">1.2 关系类型字段</h2><p>除了普通类型字段，Django还定义了一组关系类型字段，用来表示模型与模型之间的关系。</p><h3 id="多对一foreignkey">1.2.1 多对一（ForeignKey）</h3><p>多对一的关系，通常被称为外键。外键字段类的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForeignKey</span>(<span class="hljs-params">to, on_delete, **options</span>)</span><br></code></pre></td></tr></table></figure><p>外键需要两个位置参数，一个是关联的模型，另一个是<code>on_delete</code>。</p><p><strong>外键要定义在‘多’的一方！</strong></p><p>举栗：</p><p>每辆车都会有一个生产工厂，一个工厂可以生产N辆车，于是用一个外键字段manufacturer表示，并放在Car模型中。注意，此manufacturer非彼Manufacturer模型类，它是一个字段的名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manufacturer</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>(<span class="hljs-params">models.Model</span>):</span><br>    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)<br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>在实际的数据库后台，Django会为每一个外键添加<code>_id</code>后缀，并以此创建数据表里的一列。在上面的工厂与车的例子中，Car模型对应的数据表中，会有一列叫做<code>manufacturer_id</code>。但实际上，在Django代码中你不需要使用这个列名，除非你书写原生的SQL语句，一般我们都直接使用字段名<code>manufacturer</code>。</p><p>多对一字段的变量名一般设置为关联的模型的小写单数，而多对多则一般设置为小写复数。在Django的模型定义中，经常出现类似的英文单词大小写不同，一定要注意区分！</p><p>如果要创建一个递归的外键，也就是自己关联自己的的外键，使用下面的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">models.ForeignKey(<span class="hljs-string">&#x27;self&#x27;</span>, on_delete=models.CASCADE)<br></code></pre></td></tr></table></figure><p>关系字段的定义还有个小坑。在后面<code>verbose_name</code>参数用于设置字段的别名。很多情况下，为了方便，我们都会设置这么个值，并且作为字段的第一位置参数。但是对于关系字段，其第一位置参数永远是关系对象，不能是<code>verbose_name</code>，一定要注意！</p><h4 id="参数说明">参数说明</h4><h4 id="on_delete">on_delete</h4><p>当一个外键关联的对象被删除时，Django将模仿<code>on_delete</code>参数定义的SQL约束执行相应操作。</p><p>该参数可选的值都内置在<code>django.db.models</code>中（全部为大写），包括：</p><ul><li>CASCADE：模拟SQL语言中的<code>ON DELETE CASCADE</code>约束，将定义有外键的模型对象同时删除！</li><li>PROTECT:阻止上面的删除操作，但是弹出<code>ProtectedError</code>异常</li><li>SET_NULL：将外键字段设为null，只有当字段设置了<code>null=True</code>时，方可使用该值。</li><li>SET_DEFAULT:将外键字段设为默认值。只有当字段设置了default参数时，方可使用。</li><li>DO_NOTHING：什么也不做。</li><li>SET()：设置为一个传递给SET()的值或者一个回调函数的返回值。注意大小写。</li></ul><h4 id="limit_choices_to">limit_choices_to</h4><p>该参数用于限制外键所能关联的对象，只能用于Django的ModelForm（Django的表单模块）和admin后台，对其它场合无限制功能。其值可以是一个字典、Q对象或者一个返回字典或Q对象的函数调用，如下例所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">staff_member = models.ForeignKey(<br>    User,<br>    on_delete=models.CASCADE,<br>    limit_choices_to=&#123;<span class="hljs-string">&#x27;is_staff&#x27;</span>: <span class="hljs-literal">True</span>&#125;,<br>)<br></code></pre></td></tr></table></figure><p>这样定义，则ModelForm的<code>staff_member</code>字段列表中，只会出现那些<code>is_staff=True</code>的Users对象，这一功能对于admin后台非常有用。</p><h4 id="related_name">related_name</h4><p>用于关联对象反向引用模型的名称。以前面车和工厂的例子解释，就是从工厂反向关联到车的关系名称。</p><p>通常情况下，这个参数我们可以不设置，Django会默认以模型的小写加上<code>_set</code>作为反向关联名，比如对于工厂就是<code>car_set</code>，如果你觉得<code>car_set</code>还不够直观，可以如下定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>(<span class="hljs-params">models.Model</span>):</span><br>    manufacturer = models.ForeignKey(<br>        <span class="hljs-string">&#x27;production.Manufacturer&#x27;</span>,      <br>        on_delete=models.CASCADE,<br>        related_name=<span class="hljs-string">&#x27;car_producted_by_this_manufacturer&#x27;</span>,  <span class="hljs-comment"># 看这里！！</span><br>    )<br></code></pre></td></tr></table></figure><p>也许我定义了一个蹩脚的词，但表达的意思很清楚。以后从工厂对象反向关联到它所生产的汽车，就可以使用<code>maufacturer.car_producted_by_this_manufacturer</code>了。</p><h3 id="多对多manytomanyfield">1.2.2 多对多（ManyToManyField）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManyToManyField</span>(<span class="hljs-params">to, **options</span>)</span><br></code></pre></td></tr></table></figure><p>多对多关系在数据库中也是非常常见的关系类型。比如一本书可以有好几个作者，一个作者也可以写好几本书。多对多的字段可以定义在任何的一方，请尽量定义在符合人们思维习惯的一方，但不要同时都定义，只能选择一个模型设置该字段（比如我们通常将披萨上的配料字段放在披萨模型中，而不是在配料模型中放置披萨字段）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Topping</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pizza</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    toppings = models.ManyToManyField(Topping)<br></code></pre></td></tr></table></figure><ul><li><p>建议为多对多字段名使用复数形式。</p></li><li><p>多对多关系需要一个位置参数：关联的对象模型，其它用法和外键多对一基本类似。</p></li><li><p>如果要创建一个关联自己的多对多字段，依然是通过<code>'self'</code>引用。</p></li></ul><h3 id="一对一onetoonefield">1.2.3 一对一（OneToOneField）</h3><p>一对一关系类型的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneToOneField</span>(<span class="hljs-params">to, on_delete, parent_link=<span class="hljs-literal">False</span>, **options</span>)</span><br></code></pre></td></tr></table></figure><p>从概念上讲，一对一关系非常类似具有<code>unique=True</code>属性的外键关系，但是反向关联对象只有一个。这种关系类型多数用于当一个模型需要从别的模型扩展而来的情况。比如，Django自带auth模块的User用户表，如果你想在自己的项目里创建用户模型，又想方便的使用Django的auth中的一些功能，那么一个方案就是在你的用户模型里，使用一对一关系，添加一个与auth模块User模型的关联字段。</p><p>该关系的第一位置参数为关联的模型，其用法和前面的多对一外键一样。</p><p>如果你没有给一对一关系设置<code>related_name</code>参数，Django将使用当前模型的小写名作为默认值。</p><p>看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-comment"># 两个字段都使用一对一关联到了Django内置的auth模块中的User模型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpecialUser</span>(<span class="hljs-params">models.Model</span>):</span><br>    user = models.OneToOneField(<br>        settings.AUTH_USER_MODEL,<br>        on_delete=models.CASCADE,<br>    )<br>    supervisor = models.OneToOneField(<br>        settings.AUTH_USER_MODEL,<br>        on_delete=models.CASCADE,<br>        related_name=<span class="hljs-string">&#x27;supervisor_of&#x27;</span>,<br>    )<br></code></pre></td></tr></table></figure><h2 id="字段的参数">1.3 字段的参数</h2><p>所有的模型字段都可以接收一定数量的参数，比如CharField至少需要一个max_length参数。下面的这些参数是所有字段都可以使用的，并且是可选的。</p><h4 id="null">null</h4><p>该值为True时，Django在数据库用NULL保存空值。默认值为False。对于保存字符串类型数据的字段，请尽量避免将此参数设为True，那样会导致两种‘没有数据’的情况，一种是<code>NULL</code>，另一种是空字符串<code>''</code>。Django 的惯例是使用空字符串而不是 <code>NULL</code>。</p><h4 id="blank">blank</h4><p>True时，字段可以为空。默认False。和null参数不同的是，null是纯数据库层面的，而blank是验证相关的，它与表单验证是否允许输入框内为空有关，与数据库无关。所以要小心一个null为False，blank为True的字段接收到一个空值可能会出bug或异常。</p><h4 id="choices">choices</h4><p>用于页面上的选择框标签，需要先提供一个二维的二元元组，第一个元素表示存在数据库内真实的值，第二个表示页面上显示的具体内容。在浏览器页面上将显示第二个元素的值。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">models.Model</span>):</span><br>    YEAR_IN_SCHOOL_CHOICES = (<br>        (FRESHMAN, <span class="hljs-string">&#x27;Freshman&#x27;</span>),<br>        (SOPHOMORE, <span class="hljs-string">&#x27;Sophomore&#x27;</span>),<br>        (JUNIOR, <span class="hljs-string">&#x27;Junior&#x27;</span>),<br>        (SENIOR, <span class="hljs-string">&#x27;Senior&#x27;</span>),<br>    )<br>    year_in_school = models.CharField(<br>        max_length=<span class="hljs-number">2</span>,<br>        choices=YEAR_IN_SCHOOL_CHOICES,<br>        default=FRESHMAN,<br>    )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_upperclass</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.year_in_school <span class="hljs-keyword">in</span> (self.JUNIOR, self.SENIOR)<br></code></pre></td></tr></table></figure><h4 id="primary_key">primary_key</h4><p>如果你没有给模型的任何字段设置这个参数为True，Django将自动创建一个AutoField自增字段，名为‘id’，并设置为主键。也就是<code>id = models.AutoField(primary_key=True)</code>。</p><p>如果你为某个字段设置了primary_key=True，则当前字段变为主键，并关闭Django自动生成id主键的功能。</p><p><strong><code>primary_key=True</code>隐含<code>null=False</code>和<code>unique=True</code>的意思。一个模型中只能有一个主键字段！</strong></p><p>另外，主键字段不可修改，如果你给某个对象的主键赋个新值实际上是创建一个新对象，并不会修改原来的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>, primary_key=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">###############    </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fruit = Fruit.objects.create(name=<span class="hljs-string">&#x27;Apple&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>fruit.name = <span class="hljs-string">&#x27;Pear&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fruit.save()<br><span class="hljs-meta">&gt;&gt;&gt; </span>Fruit.objects.values_list(<span class="hljs-string">&#x27;name&#x27;</span>, flat=<span class="hljs-literal">True</span>)<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Pear&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="unique">unique</h4><p>设为True时，在整个数据表内该字段的数据不可重复。</p><p>注意：</p><ul><li><p>对于ManyToManyField和OneToOneField关系类型，该参数无效。</p></li><li><p>当unique=True时，db_index参数无须设置，因为unqiue隐含了索引。</p></li></ul><h4 id="verbose_name">verbose_name</h4><p>为字段设置一个人类可读，更加直观的别名。</p><p>对于每一个字段类型，除了<code>ForeignKey</code>、<code>ManyToManyField</code>和<code>OneToOneField</code>这三个特殊的关系类型，其第一可选位置参数都是<code>verbose_name</code>。如果没指定这个参数，Django会利用字段的属性名自动创建它，并将下划线转换为空格。</p><p>下面这个例子的<code>verbose name</code>是&quot;person’s first name&quot;:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">first_name = models.CharField(<span class="hljs-string">&quot;person&#x27;s first name&quot;</span>, max_length=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>下面这个例子的<code>verbose name</code>是&quot;first name&quot;:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">first_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>对于外键、多对多和一对一字字段，由于第一个参数需要用来指定关联的模型，因此必须用关键字参数<code>verbose_name</code>来明确指定。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">poll = models.ForeignKey(<br>    Poll,<br>    on_delete=models.CASCADE,<br>    verbose_name=<span class="hljs-string">&quot;the related poll&quot;</span>,<br>    )<br>sites = models.ManyToManyField(Site, verbose_name=<span class="hljs-string">&quot;list of sites&quot;</span>)<br>    place = models.OneToOneField(<br>    Place,<br>    on_delete=models.CASCADE,<br>    verbose_name=<span class="hljs-string">&quot;related place&quot;</span>,<br>)<br></code></pre></td></tr></table></figure><h2 id="模型的元数据meta">1.4 模型的元数据Meta</h2><p>模型的元数据，指的是“除了字段外的所有内容”，例如排序方式、数据库表名、人类可读的单数或者复数名等等。想在模型中增加元数据，方法很简单，在模型类中添加一个子类，名字是固定的<code>Meta</code>，然后在这个Meta类下面增加各种元数据选项或者说设置项。参考下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ox</span>(<span class="hljs-params">models.Model</span>):</span><br>    horn_length = models.IntegerField()<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>         <span class="hljs-comment"># 注意，是模型的子类，要缩进！</span><br>        ordering = [<span class="hljs-string">&quot;horn_length&quot;</span>]<br>        verbose_name_plural = <span class="hljs-string">&quot;oxen&quot;</span><br></code></pre></td></tr></table></figure><p>上面的例子中，我们为模型Ox增加了两个元数据‘ordering’和‘verbose_name_plural’，分别表示排序和复数名。</p><p>介绍一些常用的元数据选项：</p><h4 id="abstract">abstract</h4><p>如果<code>abstract=True</code>，那么模型会被认为是一个抽象模型。抽象模型本身不实际生成数据库表，而是作为其它模型的父类，被继承使用。具体内容可以参考Django模型的继承。</p><h3 id="ordering">ordering</h3><p>最常用的元数据之一了！</p><p>用于指定该模型生成的所有对象的排序方式，接收一个字段名组成的元组或列表。默认按升序排列，如果在字段名前加上字符“-”则表示按降序排列，如果使用字符问号“？”表示随机排列。请看下面的例子：</p><p>这个顺序是你通过查询语句，获得Queryset后的列表内元素的顺序，切不可和前面的<code>get_latest_by</code>等混淆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ordering = [<span class="hljs-string">&#x27;pub_date&#x27;</span>]             <span class="hljs-comment"># 表示按&#x27;pub_date&#x27;字段进行升序排列</span><br>ordering = [<span class="hljs-string">&#x27;-pub_date&#x27;</span>]            <span class="hljs-comment"># 表示按&#x27;pub_date&#x27;字段进行降序排列</span><br>ordering = [<span class="hljs-string">&#x27;-pub_date&#x27;</span>, <span class="hljs-string">&#x27;author&#x27;</span>]  <span class="hljs-comment"># 表示先按&#x27;pub_date&#x27;字段进行降序排列，再按`author`字段进行升序排列。</span><br></code></pre></td></tr></table></figure><h4 id="unique_together">unique_together</h4><p>这个元数据是非常重要的一个！它<strong>等同于数据库的联合约束！</strong></p><p>举个例子，假设有一张用户表，保存有用户的姓名、出生日期、性别和籍贯等等信息。要求是所有的用户唯一不重复，可现在有好几个叫“张伟”的，如何区别它们呢？（不要说主键唯一，这里讨论的不是这个问题）</p><p>我们可以设置不能有两个用户在同一个地方同一时刻出生并且都叫“张伟”，使用这种联合约束，保证数据库能不能重复添加用户（也不要和我谈小概率问题）。在Django的模型中，如何实现这种约束呢？</p><p>使用<code>unique_together</code>，也就是联合唯一！</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">unique_together = [[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;birth_day&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>],......]<br></code></pre></td></tr></table></figure><p>这样，哪怕有两个在同一天出生的张伟，但他们的籍贯不同，也就是两个不同的用户。一旦三者都相同，则会被Django拒绝创建。这个元数据选项经常被用在admin后台，并且强制应用于数据库层面。</p><p>unique_together接收一个二维的列表，每个元素都是一维列表，表示一组联合唯一约束，可以同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">unique_together = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;birth_day&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>]<br></code></pre></td></tr></table></figure><p>联合唯一无法作用于普通的多对多字段。</p><h4 id="proxy">proxy</h4><p>如果设置了<code>proxy = True</code>，表示使用代理模式的模型继承方式。具体内容与abstract选项一样，参考模型继承章节。</p><h4 id="verbose_name-1">verbose_name</h4><p>最常用的元数据之一！用于设置模型对象的直观、人类可读的名称，用于在各种打印、页面展示等场景。可以用中文。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">verbose_name = <span class="hljs-string">&quot;story&quot;</span><br>verbose_name = <span class="hljs-string">&quot;披萨&quot;</span><br></code></pre></td></tr></table></figure><p>如果你不指定它，那么Django会使用小写的模型名作为默认值。</p><h4 id="verbose_name_plural">verbose_name_plural</h4><p>英语有单数和复数形式。这个就是模型对象的复数名，比如“apples”。因为我们中文通常不区分单复数，所以保持和<code>verbose_name</code>一致也可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">verbose_name_plural = <span class="hljs-string">&quot;stories&quot;</span><br>verbose_name_plural = <span class="hljs-string">&quot;披萨&quot;</span><br>verbose_name_plural = verbose_name<br></code></pre></td></tr></table></figure><p>如果不指定该选项，那么默认的复数名字是<code>verbose_name</code>加上‘s’</p><h4 id="permissions">permissions</h4><p>该元数据用于当创建对象时增加额外的权限。它接收一个所有元素都是二元元组的列表或元组，每个元素都是<code>(权限代码, 直观的权限名称)</code>的格式。比如下面的例子：</p><p>这个Meta选项非常重要，和auth框架的权限系统紧密相关。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">permissions = ((<span class="hljs-string">&quot;can_deliver_pizzas&quot;</span>, <span class="hljs-string">&quot;可以送披萨&quot;</span>),)<br></code></pre></td></tr></table></figure><h2 id="模型的继承">1.5 模型的继承</h2><p>Django中所有的模型都必须继承<code>django.db.models.Model</code>模型</p><p>Django有三种继承的方式：</p><ul><li><u>抽象基类</u>：被用来继承的模型被称为<code>Abstract base classes</code>，将子类共同的数据抽离出来，供子类继承重用，它不会创建实际的数据表；</li><li><u>多表继承</u>：<code>Multi-table inheritance</code>，每一个模型都有自己的数据库表，父子之间独立存在；</li><li><u>代理模型</u>：如果你只想修改模型的Python层面的行为，并不想改动模型的字段，可以使用代理模型。</li></ul><p><strong>注意！同Python的继承一样，Django也是可以同时继承两个以上父类的！</strong></p><h3 id="抽象基类">1.5.1 抽象基类</h3><p>只需要在模型的Meta类里添加<code>abstract=True</code>元数据项，就可以将一个模型转换为抽象基类。Django不会为这种类创建实际的数据库表，它们也没有管理器，不能被实例化也无法直接保存，它们就是被当作父类供起来，让子类继承的。抽象基类完全就是用来保存子模型们共有的内容部分，达到重用的目的。当它们被继承时，它们的字段会全部复制到子模型中。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonInfo</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    age = models.PositiveIntegerField()<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        abstract = <span class="hljs-literal">True</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">CommonInfo</span>):</span><br>    home_group = models.CharField(max_length=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>Student模型将拥有name，age，home_group三个字段，并且CommonInfo模型不能当做一个正常的模型使用，不会有这张表出现。</p><p>那如果我想修改CommonInfo父类中的name字段的定义呢？</p><ul><li>在Student类中创建一个name字段，覆盖父类的即可。</li></ul><p>那如果我不需要CommonInfo父类中的name字段呢？</p><ul><li>在Student类中创建一个name变量，值设为None即可。</li></ul><h4 id="抽象基类的meta数据">抽象基类的Meta数据：</h4><p>如果子类没有声明自己的Meta类，那么它将自动继承抽象基类的Meta类。</p><p>如果子类要设置自己的Meta属性，则需要扩展基类的Meta：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonInfo</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        abstract = <span class="hljs-literal">True</span><br>        ordering = [<span class="hljs-string">&#x27;name&#x27;</span>]<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">CommonInfo</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>(<span class="hljs-params">CommonInfo.Meta</span>):</span>   <span class="hljs-comment"># 注意这里有个继承关系</span><br>        db_table = <span class="hljs-string">&#x27;student_info&#x27;</span><br></code></pre></td></tr></table></figure><p>这里有几点要特别说明：</p><ul><li><p>抽象基类中有的元数据，子模型没有的话，直接继承；子模型也有的话，直接覆盖；</p></li><li><p>子模型可以额外添加元数据；</p></li><li><p>抽象基类中的<code>abstract=True</code>这个元数据不会被继承。也就是说如果想让一个抽象基类的子模型，同样成为一个抽象基类，那你必须显式的在该子模型的Meta中同样声明一个<code>abstract = True</code>；</p></li><li><p>有一些元数据对抽象基类无效，比如<code>db_table</code>，首先是抽象基类本身不会创建数据表，其次它的所有子类也不会按照这个元数据来设置表名。</p></li><li><p>由于Python继承的工作机制，如果子类继承了多个抽象基类，则默认情况下仅继承第一个列出的基类的 Meta 选项。如果要从多个抽象基类中继承 Meta 选项，必须显式地声明 Meta 继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonInfo</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    age = models.PositiveIntegerField()<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        abstract = <span class="hljs-literal">True</span><br>        ordering = [<span class="hljs-string">&#x27;name&#x27;</span>]<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unmanaged</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        abstract = <span class="hljs-literal">True</span><br>        managed = <span class="hljs-literal">False</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">CommonInfo, Unmanaged</span>):</span><br>    home_group = models.CharField(max_length=<span class="hljs-number">5</span>)<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>(<span class="hljs-params">CommonInfo.Meta, Unmanaged.Meta</span>):</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="多表继承">1.5.2 多表继承</h3><p>这种继承方式下，父类和子类都是独立自主、功能完整、可正常使用的模型，都有自己的数据库表，内部隐含了一个一对一的关系。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Place</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">50</span>)<br>    address = models.CharField(max_length=<span class="hljs-number">80</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Restaurant</span>(<span class="hljs-params">Place</span>):</span><br>    serves_hot_dogs = models.BooleanField(default=<span class="hljs-literal">False</span>)<br>    serves_pizza = models.BooleanField(default=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h4 id="meta和多表继承">Meta和多表继承</h4><p>在多表继承的情况下，由于父类和子类都在数据库内有物理存在的表，父类的Meta类会对子类造成不确定的影响，因此，Django在这种情况下关闭了子类继承父类的Meta功能。这一点和抽象基类的继承方式有所不同。</p><p>但是，还有两个Meta元数据属性特殊一点，那就是<code>ordering</code>和<code>get_latest_by</code>，这两个参数是会被继承的。因此，如果在多表继承中，你不想让你的子类继承父类的上面两种参数，就必须在子类中显示的指出或重写。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildModel</span>(<span class="hljs-params">ParentModel</span>):</span><br>    <span class="hljs-comment"># ...</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        <span class="hljs-comment"># 移除父类对子类的排序影响</span><br>        ordering = []<br></code></pre></td></tr></table></figure><h4 id="多表继承和反向关联">多表继承和反向关联</h4><p>因为多表继承使用了一个隐含的OneToOneField来链接子类与父类，所以象上例那样，你可以从父类访问子类。但是这个OnetoOneField字段默认的<code>related_name</code>值与ForeignKey和 ManyToManyField默认的反向名称相同。如果你与父类或另一个子类做多对一或是多对多关系，你就必须在每个多对一和多对多字段上强制指定<code>related_name</code>。如果你没这么做，Django就会在你运行或验证(validation)时抛出异常。</p><p>仍以上面Place类为例，我们创建一个带有ManyToManyField字段的子类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Supplier</span>(<span class="hljs-params">Place</span>):</span><br>    customers = models.ManyToManyField(Place)<br></code></pre></td></tr></table></figure><p>这会产生下面的错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Reverse query name <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Supplier.customers&#x27;</span> clashes <span class="hljs-keyword">with</span> reverse query<br>name <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Supplier.place_ptr&#x27;</span>.<br>HINT: Add <span class="hljs-keyword">or</span> change a related_name argument to the definition <span class="hljs-keyword">for</span><br><span class="hljs-string">&#x27;Supplier.customers&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;Supplier.place_ptr&#x27;</span>.<br></code></pre></td></tr></table></figure><p>解决方法是：向customers字段中添加<code>related_name</code>参数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">customers = models.ManyToManyField(Place, related_name=<span class="hljs-string">&#x27;provider&#x27;</span>)。<br></code></pre></td></tr></table></figure><h3 id="代理模型">1.5.3 代理模型</h3><p>使用多表继承时，父类的每个子类都会创建一张新数据表，通常情况下，这是我们想要的操作，因为子类需要一个空间来存储不包含在父类中的数据。但有时，你可能只想更改模型在Python层面的行为，比如更改默认的manager管理器，或者添加一个新方法。</p><p>代理模型就是为此而生的。你可以创建、删除、更新代理模型的实例，并且所有的数据都可以像使用原始模型（非代理类模型）一样被保存。不同之处在于你可以在代理模型中改变默认的排序方式和默认的manager管理器等等，而不会对原始模型产生影响。</p><p>代理模型其实就是给原模型换了件衣服（API），实际操作的还是原来的模型和数据。</p><p><strong>声明一个代理模型只需要将Meta中proxy的值设为True。</strong></p><p>例如你想给Person模型添加一个方法。你可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">models.Model</span>):</span><br>    first_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br>    last_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPerson</span>(<span class="hljs-params">Person</span>):</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        proxy = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_something</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># ...</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>MyPerson类将操作和Person类同一张数据库表。并且任何新的Person实例都可以通过MyPerson类进行访问，反之亦然。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Person.objects.create(first_name=<span class="hljs-string">&quot;foobar&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>MyPerson.objects.get(first_name=<span class="hljs-string">&quot;foobar&quot;</span>)<br>&lt;MyPerson: foobar&gt;<br></code></pre></td></tr></table></figure><p>下面的例子通过代理进行排序，但父类却不排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderedPerson</span>(<span class="hljs-params">Person</span>):</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        <span class="hljs-comment"># 现在，普通的Person查询是无序的，而OrderedPerson查询会按照`last_name`排序。</span><br>        ordering = [<span class="hljs-string">&quot;last_name&quot;</span>]<br>        proxy = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>一些约束：</strong></p><ul><li>代理模型必须继承自一个非抽象的基类，并且不能同时继承多个非抽象基类；</li><li>代理模型可以同时继承任意多个抽象基类，前提是这些抽象基类没有定义任何模型字段。</li><li>代理模型可以同时继承多个别的代理模型，前提是这些代理模型继承同一个非抽象基类。</li></ul><h3 id="多重继承">1.5.4 多重继承</h3><p>注意，多重继承和多表继承是两码事，两个概念。</p><p>Django的模型体系支持多重继承，就像Python一样。如果多个父类都含有Meta类，则只有第一个父类的会被使用，剩下的会忽略掉。</p><p>一般情况，能不要多重继承就不要，尽量让继承关系简单和直接，避免不必要的混乱和复杂。</p><h2 id="验证器">1.6 验证器</h2><p>在Django的模型字段参数中，有一个参数叫做<code>validators</code>，这个参数是用来指定当前字段需要使用的验证器，也就是对字段数据的合法性进行验证，比如大小、类型等。</p><p>Django的验证器可以分为模型相关的验证器和表单相关的验证器，它们基本类似，但在使用上有区别。</p><p>详情请见<a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/101">这里</a>，这里讨论模型相关的验证器。</p><h2 id="查询操作">1.7 查询操作</h2><p>查询操作是Django的ORM框架中最重要的内容之一。我们建立模型、保存数据为的就是在需要的时候可以查询得到数据。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blog</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    tagline = models.TextField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">200</span>)<br>    email = models.EmailField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>(<span class="hljs-params">models.Model</span>):</span><br>    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)<br>    headline = models.CharField(max_length=<span class="hljs-number">255</span>)<br>    body_text = models.TextField()<br>    pub_date = models.DateField()<br>    mod_date = models.DateField()<br>    authors = models.ManyToManyField(Author)<br>    number_of_comments = models.IntegerField()<br>    number_of_pingbacks = models.IntegerField()<br>    rating = models.IntegerField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.headline<br></code></pre></td></tr></table></figure><h3 id="创建对象">1.7.1 创建对象</h3><p>创建一个模型实例，也就是一条数据库记录，最一般的方式是使用模型类的实例化构造方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">b = Blog.objects.create(name=<span class="hljs-string">&#x27;小张&#x27;</span>, tagline=<span class="hljs-string">&#x27;你猜&#x27;</span>)<br></code></pre></td></tr></table></figure><p>有时实现一些额外需求，常见的做法是自定义<code>__init__</code>方法。但这不好，容易打断Django源码的调用链，存在漏洞。更推荐的是下面的方法：</p><ul><li>自定义管理器，并在其中添加创建对象的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookManager</span>(<span class="hljs-params">models.Manager</span>):</span>   <span class="hljs-comment"># 继承默认的管理器</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_book</span>(<span class="hljs-params">self, title</span>):</span><br>        book = self.create(title=title)<br>        <span class="hljs-comment"># 将你的个人代码放在这里</span><br>        print(<span class="hljs-string">&#x27;测试一下是否工作正常&#x27;</span>)<br>        <span class="hljs-keyword">return</span> book<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">models.Model</span>):</span><br>    title = models.CharField(max_length=<span class="hljs-number">100</span>)<br><br>    objects = BookManager()   <span class="hljs-comment"># 赋值objects</span><br><br>book = Book.objects.create_book(<span class="hljs-string">&quot;www&quot;</span>)   <span class="hljs-comment">#改为使用create_book方法创建对象</span><br></code></pre></td></tr></table></figure><h3 id="修改对象并保存">1.7.2 修改对象并保存</h3><p>我们往往会重写save方法，添加自己的业务逻辑，然后在其中调用原来的save方法，保证Django基本工作机制正常。比如下面的例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Blog</span>(<span class="hljs-title">models</span>.<span class="hljs-type">Model</span>):</span><br><span class="hljs-class">    name = models.<span class="hljs-type">CharField</span>(<span class="hljs-title">max_length</span>=100)</span><br><span class="hljs-class">    tagline = models.<span class="hljs-type">TextField</span>()</span><br><span class="hljs-class"></span><br><span class="hljs-class">    def save(<span class="hljs-title">self</span>, *<span class="hljs-title">args</span>, **<span class="hljs-title">kwargs</span>):</span><br><span class="hljs-class">        do_something()   # 保存前做点私活</span><br><span class="hljs-class">        super().save(*<span class="hljs-title">args</span>, **<span class="hljs-title">kwargs</span>)  # 一定不要忘记这行代码</span><br><span class="hljs-class">        do_something_else()  # 保存后又加塞点东西</span><br></code></pre></td></tr></table></figure><p>这样，任何一篇博客在保存前后都会执行一些额外的代码。</p><p>注意，千万不要忘记<code>super().save(*args, **kwargs)</code>，这行确保了Django源码中关于save方法的代码会依然被执行。</p><p>下面的例子则是对博客名字做限制，只有小张的博客才可以保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blog</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    tagline = models.TextField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        <span class="hljs-keyword">if</span> self.name != <span class="hljs-string">&quot;小张的博客&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-comment"># 只有小张的博客才可以保存</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">super</span>().save(*args, **kwargs)  <span class="hljs-comment"># 调用真正的save方法</span><br></code></pre></td></tr></table></figure><p><code>*args, **kwargs</code>的参数设计，确保我们自定义的save方法是个万金油，不论Django源码中的save方法的参数怎么变，我们自己的save方法不会因为参数定义的不正确而出现bug。</p><p>此外：</p><p>执行save方法后，Django才会真正为对象设置自增主键的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b2 = Blog(name=<span class="hljs-string">&#x27;Cheddar Talk&#x27;</span>, tagline=<span class="hljs-string">&#x27;Thoughts on cheese.&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b2.<span class="hljs-built_in">id</span>     <span class="hljs-comment"># 返回None，因为此时b2还没有写入数据库，没有id值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b2.save()<br><span class="hljs-meta">&gt;&gt;&gt; </span>b2.<span class="hljs-built_in">id</span>     <span class="hljs-comment"># 这回有了</span><br></code></pre></td></tr></table></figure><p>当然，你也可以自己指定主键的值，不需要等待数据库为主键分配值，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b3 = Blog(<span class="hljs-built_in">id</span>=<span class="hljs-number">3</span>, name=<span class="hljs-string">&#x27;Cheddar Talk&#x27;</span>, tagline=<span class="hljs-string">&#x27;Thoughts on cheese.&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b3.<span class="hljs-built_in">id</span>     <span class="hljs-comment"># 返回 3.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b3.save()<br><span class="hljs-meta">&gt;&gt;&gt; </span>b3.<span class="hljs-built_in">id</span>     <span class="hljs-comment"># 返回 3.</span><br></code></pre></td></tr></table></figure><p>很显然，你必须确保分配的主键值是没有被使用过的，否则肯定出问题，因为在这种情况下，Django认为你是在更新一条已有的数据对象，而不是新建对象，比如下面的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">b4 = Blog(<span class="hljs-built_in">id</span>=<span class="hljs-number">3</span>, name=<span class="hljs-string">&#x27;Not Cheddar&#x27;</span>, tagline=<span class="hljs-string">&#x27;Anything but cheese.&#x27;</span>)<br>b4.save() <br><span class="hljs-comment"># 实际上是更新了上面的b3，而不是新建，此时b4==b3</span><br></code></pre></td></tr></table></figure><p>上面现象的本质是Django对SQL的INSERT和UPDATE语句进行了抽象合并，共用一个save方法。</p><p>有些罕见情况下，可能你必须强制进行INSERT或者UPDATE操作，而不是让Django自动决定。这时候可以使用save方法的<code>force_insert</code>和<code>force_update</code>参数，将其中之一设置为True，强制指定保存模式。</p><ul><li>保存外键和多对多字段:</li></ul><p>保存一个外键字段和保存普通字段没什么区别，只是要注意值的类型要正确。下面的例子，有一个Entry的实例entry和一个Blog的实例<code>cheese_blog</code>，然后把<code>cheese_blog</code>作为值赋给了entry的blog属性，最后调用save方法进行保存。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">from</span> blog.models <span class="hljs-keyword">import</span> Blog, Entry</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry = Entry.objects.get(pk=<span class="hljs-number">1</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">cheese_blog = Blog.objects.get(name=<span class="hljs-string">&quot;Cheddar Talk&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry.blog = cheese_blog</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry.save()</span><br></code></pre></td></tr></table></figure><p>多对多字段的保存稍微有点区别，需要调用一个<code>add()</code>方法，而不是直接给属性赋值，但它不需要调用save方法。如下例所示：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">from</span> blog.models <span class="hljs-keyword">import</span> Author</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">joe = Author.objects.create(name=<span class="hljs-string">&quot;Joe&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry.authors.add(joe)</span><br></code></pre></td></tr></table></figure><p>在一行语句内，可以同时添加多个对象到多对多的字段，如下所示：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">john = Author.objects.create(name=<span class="hljs-string">&quot;John&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">paul = Author.objects.create(name=<span class="hljs-string">&quot;Paul&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">george = Author.objects.create(name=<span class="hljs-string">&quot;George&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">ringo = Author.objects.create(name=<span class="hljs-string">&quot;Ringo&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry.authors.add(john, paul, george, ringo)</span><br></code></pre></td></tr></table></figure><p>如果你指定或添加了错误类型的对象，Django会抛出异常。</p><h3 id="检索对象">1.7.3 检索对象</h3><p>想要从数据库内检索对象，你需要基于模型类，通过管理器（Manager）操作数据库并返回一个查询结果集（QuerySet）。</p><p>详情请看有关<a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/129">查询结果集（QuerySet）</a>的介绍</p><h2 id="返回querysets的api">1.8 返回QuerySets的API</h2><p><a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/130">详情请看有关介绍</a></p><h2 id="不返回querysets的api">1.9 不返回QuerySets的API</h2><p>以下的方法不会返回QuerySets，但是作用非常强大，尤其是粗体显示的方法，需要背下来。</p><table><thead><tr class="header"><th>方法名</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><strong>get()</strong></td><td>获取单个对象</td></tr><tr class="even"><td><strong>create()</strong></td><td>创建对象，无需save()</td></tr><tr class="odd"><td><strong>get_or_create()</strong></td><td>查询对象，如果没有找到就新建对象</td></tr><tr class="even"><td><strong>update_or_create()</strong></td><td>更新对象，如果没有找到就创建对象</td></tr><tr class="odd"><td><code>bulk_create()</code></td><td>批量创建对象</td></tr><tr class="even"><td>bulk_update()</td><td>批量更新对象</td></tr><tr class="odd"><td><strong>count()</strong></td><td>统计对象的个数</td></tr><tr class="even"><td><code>in_bulk()</code></td><td>根据主键值的列表，批量返回对象</td></tr><tr class="odd"><td><code>iterator()</code></td><td>获取包含对象的迭代器</td></tr><tr class="even"><td><strong>latest()</strong></td><td>获取最近的对象</td></tr><tr class="odd"><td><strong>earliest()</strong></td><td>获取最早的对象</td></tr><tr class="even"><td><strong>first()</strong></td><td>获取第一个对象</td></tr><tr class="odd"><td><strong>last()</strong></td><td>获取最后一个对象</td></tr><tr class="even"><td><strong>aggregate()</strong></td><td>聚合操作</td></tr><tr class="odd"><td><strong>exists()</strong></td><td>判断queryset中是否有对象</td></tr><tr class="even"><td><strong>update()</strong></td><td>更新对象</td></tr><tr class="odd"><td><strong>delete()</strong></td><td>删除对象</td></tr><tr class="even"><td>as_manager()</td><td>获取管理器</td></tr><tr class="odd"><td>explain()</td><td>对数据库操作的解释性信息</td></tr></tbody></table><h4 id="get">1. get()</h4><p>返回按照查询参数匹配到的单个对象，参数的格式应该符合Field lookups的要求。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Entry.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>)<br>Entry.objects.get(blog=blog, entry_number=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>如果匹配到的对象个数不只一个的话，触发<code>MultipleObjectsReturned</code>异常:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Entry.objects.get(name=<span class="hljs-string">&#x27;张伟&#x27;</span>) <br><span class="hljs-comment"># raises Entry.MultipleObjectsReturned</span><br></code></pre></td></tr></table></figure><p>如果根据给出的参数匹配不到对象的话，触发DoesNotExist异常。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Entry.objects.get(<span class="hljs-built_in">id</span>=-<span class="hljs-number">999</span>) <br><span class="hljs-comment"># raises Entry.DoesNotExist</span><br></code></pre></td></tr></table></figure><p>DoesNotExist异常从<code>django.core.exceptions.ObjectDoesNotExist</code>继承，可以定位多个DoesNotExist异常。 例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.core.exceptions <span class="hljs-keyword">import</span> ObjectDoesNotExist<br><br><span class="hljs-keyword">try</span>:<br>    blog = Blog.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>)<br>    entry = Entry.objects.get(blog=blog, entry_number=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">except</span> ObjectDoesNotExist:<br>    print(<span class="hljs-string">&quot;Either the blog or entry doesn&#x27;t exist.&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果希望查询器只返回一个对象，则可以使用get()，无需添加任何参数：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml">entry = Entry.objects.filter(...).exclude(...).get()</span><br></code></pre></td></tr></table></figure><h4 id="create">2. create()</h4><p>在一步操作中同时创建并且保存对象的便捷方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Person.objects.create(first_name=<span class="hljs-string">&quot;Bruce&quot;</span>, last_name=<span class="hljs-string">&quot;Springsteen&quot;</span>)<br></code></pre></td></tr></table></figure><p>等于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Person(first_name=<span class="hljs-string">&quot;Bruce&quot;</span>, last_name=<span class="hljs-string">&quot;Springsteen&quot;</span>)<br>p.save(force_insert=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>参数<code>force_insert</code>表示强制创建对象。如果model中有一个你手动设置的主键，并且这个值已经存在于数据库中, 调用create()将会失败并且触发IntegrityError因为主键必须是唯一的。如果你手动设置了主键，做好异常处理的准备。</p><h4 id="get_or_create">3. get_or_create()</h4><p><strong>通过kwargs来查询对象的便捷方法（如果模型中的所有字段都有默认值，可以为空），如果该对象不存在则创建一个新对象</strong>。</p><p>该方法<strong>返回一个由(object, created)组成的元组</strong>，元组中的object 是一个查询到的或者是被创建的对象， created是一个表示是否创建了新的对象的布尔值。</p><p>对于下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    obj = Person.objects.get(first_name=<span class="hljs-string">&#x27;John&#x27;</span>, last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>)<br><span class="hljs-keyword">except</span> Person.DoesNotExist:<br>    obj = Person(first_name=<span class="hljs-string">&#x27;John&#x27;</span>, last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>, birthday=date(<span class="hljs-number">2020</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>))<br>    obj.save()<br></code></pre></td></tr></table></figure><p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用<code>get_or_create()</code>重写 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj, created = Person.objects.get_or_create(<br>    first_name=<span class="hljs-string">&#x27;John&#x27;</span>,<br>    last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>,<br>    defaults=&#123;<span class="hljs-string">&#x27;birthday&#x27;</span>: date(<span class="hljs-number">2020</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>)&#125;,<br>)<br></code></pre></td></tr></table></figure><p>任何传递给<code>get_or_create()</code>的关键字参数，除了一个可选的defaults，都将传递给get()调用。 如果查找到一个对象，返回一个包含匹配到的对象以及False 组成的元组。</p><h4 id="update_or_create">4. update_or_create()</h4><p>类似前面的<code>get_or_create()</code>。</p><p><strong>通过给出的kwargs来更新对象的便捷方法， 如果没找到对象，则创建一个新的对象</strong>。defaults是一个由 (field, value)对组成的字典，用于更新对象。defaults中的值可以是可调用对象（也就是说函数等）。</p><p>该方法返回一个由(object, created)组成的元组,元组中的object是一个创建的或者是被更新的对象， created是一个标示是否创建了新的对象的布尔值。</p><p><code>update_or_create</code>方法尝试通过给出的kwargs 去从数据库中获取匹配的对象。 如果找到匹配的对象，它将会依据defaults 字典给出的值更新字段。</p><p>像下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">defaults = &#123;<span class="hljs-string">&#x27;first_name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>&#125;<br><span class="hljs-keyword">try</span>:<br>    obj = Person.objects.get(first_name=<span class="hljs-string">&#x27;John&#x27;</span>, last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>)<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> defaults.items():<br>        <span class="hljs-built_in">setattr</span>(obj, key, value)<br>    obj.save()<br><span class="hljs-keyword">except</span> Person.DoesNotExist:<br>    new_values = &#123;<span class="hljs-string">&#x27;first_name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;last_name&#x27;</span>: <span class="hljs-string">&#x27;Lennon&#x27;</span>&#125;<br>    new_values.update(defaults)<br>    obj = Person(**new_values)<br>    obj.save()<br></code></pre></td></tr></table></figure><p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用<code>update_or_create()</code> 重写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">obj, created = Person.objects.update_or_create(<br>    first_name=<span class="hljs-string">&#x27;John&#x27;</span>, last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>,<br>    defaults=&#123;<span class="hljs-string">&#x27;first_name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>&#125;,<br>)<br></code></pre></td></tr></table></figure><p>kwargs中的名称如何解析的详细描述可以参见<code>get_or_create()</code>。</p><p>和<code>get_or_create()</code>一样，这个方法也容易导致竞态条件，如果数据库层级没有前置唯一性会让多行同时插入。</p><h4 id="count">5. count()</h4><p>count()</p><p>返回在数据库中对应的QuerySet对象的个数。count()永远不会引发异常。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 返回总个数.</span><br>Entry.objects.count()<br><span class="hljs-comment"># 返回包含有&#x27;Lennon&#x27;的对象的总数</span><br>Entry.objects.<span class="hljs-built_in">filter</span>(headline__contains=<span class="hljs-string">&#x27;Lennon&#x27;</span>).count()<br></code></pre></td></tr></table></figure><h4 id="exists">6. exists()</h4><p>如果QuerySet包含任何结果，则返回True，否则返回False。</p><p>查找具有唯一性字段（例如primary_key）的模型是否在一个QuerySet中的最高效的方法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">entry = Entry.objects.get(pk=<span class="hljs-number">123</span>)<br><span class="hljs-keyword">if</span> some_queryset.<span class="hljs-built_in">filter</span>(pk=entry.pk).exists():<br>    print(<span class="hljs-string">&quot;Entry contained in queryset&quot;</span>)<br></code></pre></td></tr></table></figure><p>它将比下面的方法快很多，这个方法要求对QuerySet求值并迭代整个QuerySet：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> entry <span class="hljs-keyword">in</span> some_queryset:<br>   print(<span class="hljs-string">&quot;Entry contained in QuerySet&quot;</span>)<br></code></pre></td></tr></table></figure><p>若要查找一个QuerySet是否包含任何元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> some_queryset.exists():<br>    print(<span class="hljs-string">&quot;There is at least one object in some_queryset&quot;</span>)<br></code></pre></td></tr></table></figure><p>将快于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> some_queryset:<br>    print(<span class="hljs-string">&quot;There is at least one object in some_queryset&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="update">7. update()</h4><p><strong>对指定的字段执行更新操作，并返回匹配的行数</strong>（如果某些行已具有新值，则可能不等于已更新的行数）。</p><p>例如，要对2010年发布的所有博客条目关闭评论功能，可以执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(pub_date__year=<span class="hljs-number">2010</span>).update(comments_on=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>可以同时更新多个字段 （没有多少字段的限制）。 例如同时更新comments_on和headline字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(pub_date__year=<span class="hljs-number">2010</span>).update(comments_on=<span class="hljs-literal">False</span>, headline=<span class="hljs-string">&#x27;This is old&#x27;</span>)<br></code></pre></td></tr></table></figure><p>update()方法无需save操作，会立刻写入数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">update只能更新模型主表中的字段，不能更新关联模型中的字段。<br></code></pre></td></tr></table></figure><p>例如不能这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.update(blog__name=<span class="hljs-string">&#x27;foo&#x27;</span>) <span class="hljs-comment"># 这样做是无效的</span><br></code></pre></td></tr></table></figure><p>但是，仍然可以根据相关字段进行过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(blog__id=<span class="hljs-number">1</span>).update(comments_on=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>update()方法返回受影响的行数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">id</span>=<span class="hljs-number">64</span>).update(comments_on=<span class="hljs-literal">True</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(slug=<span class="hljs-string">&#x27;nonexistent-slug&#x27;</span>).update(comments_on=<span class="hljs-literal">True</span>)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(pub_date__year=<span class="hljs-number">2010</span>).update(comments_on=<span class="hljs-literal">False</span>)<br><span class="hljs-number">132</span><br></code></pre></td></tr></table></figure><p>如果你只是更新一下对象，不需要为对象做别的事情，最有效的方法是调用update()，而不是将模型对象加载到内存中。 例如，不要这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">e = Entry.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-number">10</span>)<br>e.comments_on = <span class="hljs-literal">False</span><br>e.save()<br></code></pre></td></tr></table></figure><p>建议如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Entry.objects.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">id</span>=<span class="hljs-number">10</span>).update(comments_on=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>用update()还可以防止在加载对象和调用save()之间的短时间内数据库中某些内容可能发生更改的竞争条件。</p><p><code>update()方法不会调用save()方法，也不会发出pre_save和post_save信号。</code>所以，如果想更新一个具有自定义save()方法的模型的记录，请循环遍历它们并调用save()，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> Entry.objects.<span class="hljs-built_in">filter</span>(pub_date__year=<span class="hljs-number">2020</span>):<br>    e.comments_on = <span class="hljs-literal">False</span><br>    e.save()<br></code></pre></td></tr></table></figure><h4 id="delete">8. delete()</h4><p>批量删除QuerySet中的所有对象，并返回删除的对象个数和每个对象类型的删除次数的字典。</p><p>delete()动作是立即执行的。</p><p>例如，要删除特定博客中的所有条目：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b = Blog.objects.get(pk=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 删除b下所属的所有条目</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(blog=b).delete()<br>(<span class="hljs-number">4</span>, &#123;<span class="hljs-string">&#x27;weblog.Entry&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>默认情况下，任何具有指向要删除的对象的外键的对象将与它们一起被删除。 像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>blogs = Blog.objects.<span class="hljs-built_in">all</span>()<br><span class="hljs-comment"># This will delete all Blogs and all of their Entry objects.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>blogs.delete()<br>(<span class="hljs-number">5</span>, &#123;<span class="hljs-string">&#x27;weblog.Blog&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;weblog.Entry&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>这种级联的行为可以通过的ForeignKey的<code>on_delete</code>参数自定义。（什么时候要改变这种行为呢？比如日志数据，就不能和它关联的主体一并被删除！）</p><p>delete()会为所有已删除的对象（包括级联删除）发出<code>pre_delete</code>和<code>post_delete</code>信号。</p><p>详情请百度，或查阅<a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/131">这里</a>。</p><h2 id="注解与聚合">1.10 注解与聚合</h2><p>Django的ORM提供的API主要是用来增删查改单个对象的方法。 然而，有时候你要获取的值需要根据一组对象聚合后才能得到，比如几个学生成绩的平均分，非常类似数据分析和统计。</p><p>本节以下面的模型为例，来记录多个网上书店的库存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    age = models.IntegerField()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">300</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">300</span>)<br>    pages = models.IntegerField()<br>    price = models.DecimalField(max_digits=<span class="hljs-number">10</span>, decimal_places=<span class="hljs-number">2</span>)<br>    rating = models.FloatField()<br>    authors = models.ManyToManyField(Author)<br>    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)<br>    pubdate = models.DateField()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">300</span>)<br>    books = models.ManyToManyField(Book)<br></code></pre></td></tr></table></figure><h3 id="速查表">速查表</h3><p>下面是根据以上模型执行常见的聚合查询范例，注意阅读其中的注释文字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 书籍的总数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.count()<br><span class="hljs-number">2452</span><br><br><span class="hljs-comment"># BaloneyPress出版社出版的书籍总数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.<span class="hljs-built_in">filter</span>(publisher__name=<span class="hljs-string">&#x27;BaloneyPress&#x27;</span>).count()<br><span class="hljs-number">73</span><br><br><span class="hljs-comment"># 所有书籍的平均价格</span><br><span class="hljs-comment"># 要注意！Avg，Count等聚合工具是由Django提供的，不是Python内置的，也不是你自己编写的。</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Avg<br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.<span class="hljs-built_in">all</span>().aggregate(Avg(<span class="hljs-string">&#x27;price&#x27;</span>))<br>&#123;<span class="hljs-string">&#x27;price__avg&#x27;</span>: <span class="hljs-number">34.35</span>&#125;   <span class="hljs-comment"># 本来返回的是查询集，聚合后返回的是一个数据字典，字典的键名是有规律的</span><br><br><span class="hljs-comment"># 所有书籍中最高的价格</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Max<br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.<span class="hljs-built_in">all</span>().aggregate(Max(<span class="hljs-string">&#x27;price&#x27;</span>))<br>&#123;<span class="hljs-string">&#x27;price__max&#x27;</span>: Decimal(<span class="hljs-string">&#x27;81.20&#x27;</span>)&#125;<br><br><span class="hljs-comment"># 所有书籍中最高价和平均价的差</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> FloatField<br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.aggregate(<br><span class="hljs-meta">... </span>    price_diff=Max(<span class="hljs-string">&#x27;price&#x27;</span>, output_field=FloatField()) - Avg(<span class="hljs-string">&#x27;price&#x27;</span>))<br>&#123;<span class="hljs-string">&#x27;price_diff&#x27;</span>: <span class="hljs-number">46.85</span>&#125;<br><br><br><span class="hljs-comment"># 下面是annonte注解的用法</span><br><br><span class="hljs-comment"># 每一个被过滤出来的出版社对象都被附加了一个&quot;num_books&quot;属性，这个属性就是所谓的注释</span><br><span class="hljs-comment"># 和aggregate不同，annotate返回的依然是查询集，添加了私货的查询集。</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Count<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="hljs-string">&#x27;book&#x27;</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs<br>&lt;QuerySet [&lt;Publisher: BaloneyPress&gt;, &lt;Publisher: SalamiPress&gt;, ...]&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs[<span class="hljs-number">0</span>].num_books<br><span class="hljs-number">73</span><br><br><span class="hljs-comment"># 每一个出版商都被附加了两个额外的属性，分别表示好评率大于5和好评率小于等于5的书籍的总数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Q<br><span class="hljs-comment"># 统计每个出版社中好评率大于5的书籍的数量</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>above_5 = Count(<span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-built_in">filter</span>=Q(book__rating__gt=<span class="hljs-number">5</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>below_5 = Count(<span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-built_in">filter</span>=Q(book__rating__lte=<span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># 要理解这里的链式调用含义。annotate不是filter，不会增减查询集的元素。</span><br><span class="hljs-comment"># 所以Publisher.objects实际上等于pubs=Publisher.objects.all()</span><br><span class="hljs-comment"># 第一个annotate为pubs增加below_5属性，第二个annotate又再次增加above_5属性</span><br><span class="hljs-comment"># 虽然是链式调用，但不是过滤行为，而是追加行为</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(below_5=below_5).annotate(above_5=above_5)<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs[<span class="hljs-number">0</span>].above_5<br><span class="hljs-number">23</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs[<span class="hljs-number">0</span>].below_5<br><span class="hljs-number">12</span><br><br><span class="hljs-comment"># 这个比较复杂。首先获取了所有的出版社。其次统计每个出版社的发行书籍数量，保存在num_books属性中。</span><br><span class="hljs-comment"># 然后对所有的出版社进行排序，根据num_books属性进行反向由多到少排序，最后切片获取前5个出版社。</span><br>The top <span class="hljs-number">5</span> publishers, <span class="hljs-keyword">in</span> order by number of books.<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="hljs-string">&#x27;book&#x27;</span>)).order_by(<span class="hljs-string">&#x27;-num_books&#x27;</span>)[:<span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs[<span class="hljs-number">0</span>].num_books<br><span class="hljs-number">1323</span><br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Python/">Python</a> <a class="hover-with-bg" href="/tags/Django/">Django</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处来源：<a href="https://stuxiaozhang.github.io/">小张的宇宙空间站</a></p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/10/30/Django%E5%9F%BA%E7%A1%802/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Django基础----视图层</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"><span class="hidden-mobile">深度学习基础</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",function(){var e=Object.assign({appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:"https://cdn.bootcdn.net/ajax/libs/emojione/4.5.0/lib/js/emojione.min.js",emojiMaps:null,enableQQ:!0,requiredFields:["nick"]},{el:"#valine",path:window.location.pathname});new Valine(e)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://stuxiaozhang.github.io" target="_blank" rel="nofollow noopener"><span>小张同学的宇宙空间站</span></a> 已经运转了<span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{renderActions:{findScript:[10,a=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const n=new a.options.MathItem(e.textContent,a.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),n.start={node:t,delim:"",n:0},n.end={node:t,delim:"",n:0},a.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>