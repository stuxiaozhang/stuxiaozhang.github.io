<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><script></script><link rel="apple-touch-icon" sizes="180x180" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/avatar-removebg-preview.png"><link rel="icon" type="image/png" sizes="32x32" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/avatar-removebg-preview.png"><link rel="icon" type="image/png" sizes="16x16" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/avatar-removebg-preview.png"><link rel="mask-icon" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/avatar-removebg-preview.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!1,style:"default"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="2020.10.4：总结了一些有关操作系统的常见面试问题以及一些书上和笔记上的知识点。            第一章 操作系统概述  image-20201006083338715  1、什么是操作系统？它的主要特征是什么？ 操作系统是指控制和管理整个计算机系统硬件和软件资源的最基本的系统软件。"><meta property="og:type" content="article"><meta property="og:title" content="操作系统课堂笔记总结"><meta property="og:url" content="http://stuxiaozhang.github.io/2020/10/06/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><meta property="og:site_name" content="小张同学的博客"><meta property="og:description" content="2020.10.4：总结了一些有关操作系统的常见面试问题以及一些书上和笔记上的知识点。            第一章 操作系统概述  image-20201006083338715  1、什么是操作系统？它的主要特征是什么？ 操作系统是指控制和管理整个计算机系统硬件和软件资源的最基本的系统软件。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20201006083338715.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200827214637040.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200827190507593.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830115528580.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006112017650.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830104258275.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830114156802.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830104510608.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200827215158997.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829172422636.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828090515446.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006092312841.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828095244971.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/IMG_2285(20200829-102509).PNG"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828152139261.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828161817900.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901161312189.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111857860.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829102854372.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006101307403.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829110504215.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829111335944.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829165839493.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829120015942.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829121437044.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829130743530.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829130957970.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901090309778.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200831084249851.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829200126647.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901033503721.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829211857819.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829211145794.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901094051834.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901094752112.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111433996.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111522762.png"><meta property="og:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111541455.png"><meta property="article:published_time" content="2020-10-06T00:09:00.000Z"><meta property="article:modified_time" content="2020-10-28T05:18:15.121Z"><meta property="article:author" content="小张同学"><meta property="article:tag" content="计算机基础"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20201006083338715.png"><link rel="canonical" href="http://stuxiaozhang.github.io/2020/10/06/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>操作系统课堂笔记总结 | 小张同学的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">小张同学的博客</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">天道酬勤</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>动态</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://stuxiaozhang.github.io/2020/10/06/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/codedog.jpg"><meta itemprop="name" content="小张同学"><meta itemprop="description" content="不要停止奔跑 不要回顾来路"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小张同学的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">操作系统课堂笔记总结</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-10-06 08:09:00" itemprop="dateCreated datePublished" datetime="2020-10-06T08:09:00+08:00">2020-10-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2020/10/06/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/10/06/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>20k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>18 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p></p><div class="note warning"><p>2020.10.4：总结了一些有关操作系统的常见面试问题以及一些书上和笔记上的知识点。</p></div><p></p><h1 id="第一章-操作系统概述">第一章 操作系统概述</h1><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20201006083338715.png" alt="image-20201006083338715"><figcaption>image-20201006083338715</figcaption></figure><h2 id="什么是操作系统它的主要特征是什么">1、什么是操作系统？它的主要特征是什么？</h2><p><strong>操作系统是指控制和管理整个计算机系统硬件和软件资源的最基本的系统软件。</strong></p><p><strong>特征：</strong></p><ol type="1"><li><p><strong>并发性</strong>：两个或多个事件在<strong>同一时间间隔</strong>内发生（而并行性是指两个或多个事件在同一时刻发生）计算机系统中同时存在多个运行的程序，因此他有处理和调度多个程序同时执行的能力。在os中，引入进程的目的是使程序能够并发执行。</p><blockquote><p>并发和并行的区别？</p><ul><li>并发：同一时间间隔。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此微观上这些程序仍是分时交替执行的。操作系统的并发性是通过分时得以实现的。</li><li>并行：同一时刻</li></ul></blockquote></li><li><p><strong>共享性</strong>：系统中的硬件和软件资源不再为某个程序所独占，而是供多个用户共同使用（包括互斥共享（如<em>打印机，某些变量，队列等一段时间只能供一个作业使用的资源</em>）和同时访问（如<em>可重入代码，磁盘等</em>），后者作业访问资源的顺序不会影响访问的结果）</p></li><li><p><strong>虚拟性</strong>：把一个物理上的实体变为若干个逻辑上的对应物</p></li><li><p><strong>异步性</strong>：在多道程序环境中，由于资源等因素的限制，程序（进程）走走停停，以不可预知的速度向前推进</p></li></ol><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200827214637040.png" alt="image-20200827214637040"><figcaption>image-20200827214637040</figcaption></figure><h2 id="操作系统的功能">2、操作系统的功能</h2><h3 id="操作系统是计算机资源的管理者">1. 操作系统是计算机资源的管理者</h3><ol type="1"><li><strong>处理器管理</strong>：对处理器的分配和和运行（以进程为单位）实施有效的管理，包括<code>进程控制（负责进程的创建，撤销以及状态转换），进程同步（对并发执行的进程进行协调），进程通信（负责进程间的信息交流），进程调度（按一定算法进行处理器分配）</code></li><li><strong>存储器管理</strong>：对内存进行分配，保护和扩充，包括<code>内存分配（按一定策略为每道程序分配内存），内存保护（保证各程序在自己的内存区域内运行而不相互干扰），内存扩充（为允许大型最作业或多作业的运行，必须借助虚拟存储技术去获得增加内存的效果）</code></li><li><strong>文件管理</strong>：操作系统中负责信息管理的部分称为文件系统，文件管理的主要任务包括<code>文件存储空间的管理（存储空间的分配与回收），目录管理（提供按名存取的功能），文件操作管理（负责完成数据的读写），文件保护</code> 用户接口：方便用户使用操作系统，包括<code>命令接口（包括联机命令接口和脱机命令接口），程序接口（也称系统调用），图形接口</code></li><li><strong>设备管理</strong>：对计算机系统内的所有设备进行管理。包括<code>设备分配（根据一定的设备分配原则对设备进行分配），设备传输控制（实现物理的输入输出操作），设备独立性（用户程序中的设备与实际使用的物理设备无关)</code></li></ol><h3 id="提供用户与计算机之间的接口">2. 提供用户与计算机之间的接口</h3><h3 id="扩充机器">3. 扩充机器</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200827190507593.png" alt="image-20200827190507593"><figcaption>image-20200827190507593</figcaption></figure><h2 id="中断和异常">3、中断和异常</h2><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830115528580.png" alt="image-20200830115528580"><figcaption>image-20200830115528580</figcaption></figure><h3 id="中断的引入为了支持cpu和设备之间的并行操作">1. 中断的引入——为了支持CPU和设备之间的并行操作</h3><p>中断也称外中断，<u>指来自CPU执行指令以外的事件的发生</u>，如设备发出的I/O结束中断、时钟中断 等。这一类中断通常是与当前执行的指令无关的事件。</p><h3 id="异常的引入表示cpu执行指令本身时出现的问题">2. 异常的引入——表示CPU执行指令本身时出现的问题</h3><p>异常也称内中断、例外或陷入，<u>指源自CPU执行指令内部的事件</u>，如程序的非法操作码、地址越 界、算术溢出、缺页异常等。对异常的处理一般要依赖与当前程序的运行现场，不能被屏蔽。</p><h3 id="中断和异常的联系与区别">3. 中断和异常的联系与区别</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006112017650.png" alt="image-20201006112017650" style="zoom:80%"></p><h3 id="中断执行的流程">4. 中断执行的流程</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830104258275.png" alt="image-20200830104258275"><figcaption>image-20200830104258275</figcaption></figure><h2 id="系统调用是什么">4、系统调用是什么？</h2><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830114156802.png" alt="image-20200830114156802"><figcaption>image-20200830114156802</figcaption></figure><ul><li><strong>系统调用：是操作系统为应用程序使用内核功能所提供的接口。</strong></li><li>系统调用的目的：申请系统服务。OS不允许用户直接操作各种硬件资源，因此用户只能通过系统调用的方式来请求内核为其服务，间接地使用各种资源。</li></ul><p>操作系统为用户态进程与硬件设备进行交互提供了一组接口——系统调用:</p><ol type="1"><li><p>把用户从底层的硬件编程中解放了出来;</p></li><li><p>极大地提高了系统的安全性使用户程序具有可移植性；用户程序与具体硬件 已经被抽象接口所替代。</p></li></ol><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830104510608.png" alt="image-20200830104510608"><figcaption>image-20200830104510608</figcaption></figure><h3 id="与一般过程调用有何区别">与一般过程调用有何区别？</h3><p>一般过程调用工作在用户态，通过过程调用语句实现，可以无限制嵌套调用；</p><p>系统调用运行在核心态，通过访管中断进入，不可以嵌套调用。</p><h3 id="指令是内核态的多还是用户态的多">指令是内核态的多还是用户态的多？</h3><p>内核态，CPU可以访问内存所有数据，用户态下是受限访问，只能访问自己空间中的内存</p><h3 id="中断和系统调用的区别">中断和系统调用的区别:</h3><ol type="1"><li><p>中断是由外设产生, 无意的, 被动的</p><p>系统调用是由应用程序请求操作系统提供服务产生, 有意的, 主动的。要从用户态通过中断进入内核态。（联系）</p></li><li><p>中断过程：中断请求 中断响应 断点保护 执行中断服务程序 断点恢复 中断返回</p><p>系统调用过程：应用程序在用户态执行时请求系统调用，中断，从用户态进入内核态，在内核态执行相应的内核代码。</p></li></ol><h3 id="中断之后保存什么">中断之后保存什么？</h3><p>保存pc, psw, 通用寄存器。Pc程序计数器program count，存放下一条指令所在的单元的地址。Psw，program status word程序状态字，指处理器的状态。</p><h2 id="操作系统的发展与分类">5、操作系统的发展与分类</h2><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200827215158997.png" alt="image-20200827215158997"><figcaption>image-20200827215158997</figcaption></figure><h1 id="第二章-进程管理">第二章 进程管理</h1><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829172422636.png" alt="image-20200829172422636"><figcaption>image-20200829172422636</figcaption></figure><h2 id="进程与线程的基本概念">1、进程与线程的基本概念</h2><h2 id="进程">进程</h2><h3 id="进程的定义">进程的定义</h3><p><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong></p><h3 id="进程的组成进程映像-进程实体">进程的组成（进程映像 / 进程实体）</h3><ul><li><p>程序段：进程运行的程序的代码进程中能被进程调度程序调度到CPU上执行的代码段</p></li><li><p>数据段：存储程序运行过程中相关的一些数据</p></li><li><p>PCB：每一个进程都有一个PCB，记录进程的状态和控制进程的全部信息。既能标识进程存在（唯一标识），又能刻画执行瞬间的数据结构 。系统通过PCB对进程进行控制和管理。</p><p>【为什么PCB是进程存在的唯一标志？】</p><blockquote><p>在系统调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存地址，找到其程序和数据</p><p>进程在执行过程中，当需要和与之合作的进程实现同步，通信或访问文件时，也都需要访问PCB</p><p>当程序由于某种原因暂停执行时，又需要将其断点的处理机环境保存在PCB中</p></blockquote></li></ul><h3 id="进程的状态与转换">进程的状态与转换</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828090515446.png" alt="image-20200828090515446"><figcaption>image-20200828090515446</figcaption></figure><blockquote><p>就绪态和阻塞态的区别？</p><ul><li>就绪态：指进程进缺少处理机，只要获得处理机资源就立即执行。</li><li>阻塞态：指进程需要 其他资源（除了处理机）或 等待某事件发生。</li></ul><p>之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地由运行态转换到就绪态的。</p><p>而其它资源（如外设）的使用和分配 或 某一事件的发生（I/O操作的完成）对应的时间相对来说很长，进程由运行态转换为阻塞态的次数也相对较少。</p></blockquote><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006092312841.png" alt="image-20201006092312841"><figcaption>image-20201006092312841</figcaption></figure><h3 id="进程与程序的关系">进程与程序的关系</h3><ul><li>进程是动态的，程序是静态的</li><li>进程是暂时的，进程是永久的</li><li>进程与程序的组成不同<ul><li>进程是竞争计算机资源的基本单位</li><li>程序是一组有序的指令集合</li></ul></li><li>进程具有并发性，而程序没有</li><li>通过多次执行，一个程序可以产生多个不同的进程；通过调用关系，一个进程可以执行多个程序。进程可以创建其他进程，而程序不能形成新的程序。进程与程序之间不是一一对应的，一个进程可以执行多个程序，但一个进程只能对应一个程序。</li></ul><h3 id="进程同步有哪几种机制">进程同步有哪几种机制</h3><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p><h3 id="进程间通信ipc的几种方式">进程间通信IPC的几种方式</h3><h4 id="低级通信方式pv">低级通信方式PV</h4><p>我们通过信号量机制, 来解决进程同步和互斥的问题.而pv操作是可以访问信号量的两个原语. P<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原语">原语</a>操作的动作是：S减1；若S减1后仍大于或等于零，则进程继续执行；若S减1后小于零，则该进程被阻塞后进入等待队列。</p><p>V原语操作的动作是：S加1；若相加结果大于零，则进程继续执行；若相加结果小于或等于零，则从待队列中唤醒一等待进程.</p><h4 id="高级通信方式">高级通信方式</h4><ol type="1"><li><p>共享内存</p><p>顾名思义，共享内存就是两个进程同时共享一块内存，然后在这块内存上的数据可以共同修改和 读取，达到通信的目的。</p></li><li><p>无名管道</p><p>无名管道是半双工的通信方式；并且只能在具有亲缘关系的进程之间使用（亲缘关系是指进程间 的父子关系，兄弟关系等），具有亲缘关系的进程在创建时同时拥有一个无名管道的句柄，可以 进行读写；无名管道不存在磁盘节点，只存在与内存中用完即销毁。</p></li><li><p>命名管道</p><p>命名管道也是半双工的通信方式；可以在不具有亲缘关系的进程间通信；有名管道存在磁盘节 点，有对应的FIFO文件，凡是可以访问该路径的文件的进程均可以进行通信。</p></li><li><p>消息队列</p><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信 息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>套接字</p><p>套接字是网络编程的api，通过套接字可以不同的机器间的进程进行通信，常用于客户端进程和服 务器进程的通信。</p></li><li><p>信号</p><p>信号是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中 发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原 始机制。一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等） 都有可能产生一个信号。Shell也使用信号向它的子进程发送作业控制信号。</p></li></ol><h2 id="线程">线程</h2><h3 id="线程的定义">线程的定义</h3><ul><li><p>“轻量级进程”</p></li><li><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p></li></ul><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828095244971.png" alt="image-20200828095244971"><figcaption>image-20200828095244971</figcaption></figure><h3 id="线程的实现">线程的实现</h3><ul><li>用户级线程：不依赖于操作系统核心，线程管理（现成的创建、撤销和切换等）的所有工作都有应用程序完成，内核意识不到线程的存在。</li><li>内核级线程：<strong>依赖于内核</strong>，线程管理的所有工作都有内核完成。应用程序没有进行线程管理的代码，只有一个到被内核级线程的编程接口。内核为进程及起内部的每个进程维护上下文信息，调度也在内核基于线程架构的基础上完成。</li></ul><h3 id="线程同步的方式">线程同步的方式</h3><ul><li>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li><li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li></ul><h3 id="线程与进程的比较">线程与进程的比较</h3><blockquote><ul><li><p>引入进程的目的：为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量。</p><p>多道程序同时运行的过程，是一个动态的过程，而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程序内部的执行情况，即无法从程序的字面上看出他何时停顿，中止，也无法看出它与其他执行程序的关系，因此，程序这个静态概念已不能如实反映程序的并发执行的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。</p></li><li><p>引入线程的目的：为了减小程序在并发执行时所付出的时空开销，提高OS的并发性能。</p></li></ul></blockquote><ol type="1"><li><p><strong>调度。</strong>引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位；在同一进程中，线程的切换不会引起进程切换；在不同进程中进行线程切换，将引起进程切换。</p></li><li><p><strong>拥有资源。</strong>进程始终是拥有资源的基本单位；线程不拥有系统资源，但可以访问其隶属进程的系统资源</p></li><li><p><strong>并发性。</strong>引入线程的操作系统中，不仅进程之间可以并发执行，而且同一进程内的多个线程之间也可以并发执行，这使得操作系统具有更好的并发性，提高了系统的资源吞吐量。</p></li><li><p><strong>系统开销。</strong>引入线程后，线程之间的切换开销很小，而且由于同一进程内的多个线程共享进程的地址空间，因此多线程之间的同步与通信容易实现</p></li><li><p><strong>通信方面。</strong>进程间通信IPC需要进程同步和互斥手段的辅助，以保正数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p></li></ol><blockquote><p>【进程的特征】</p><ul><li>动态性：进程是程序的一次执行过程，是动态地产生，变化和消亡的</li><li>并发性：内存中有多个进程实体，各进程可并发执行</li><li>独立性：进程是能独立运行，独立获得资源，独立接受调度的基本单位</li><li>异步性：各进程按各自独立的，不可预知的速度向前推进</li><li>结构性：每个进程都会配置一个PCB，结构上看，进程由数据段，程序段，PCB组成</li></ul><p>【导致进程创建的事件有哪些？】</p><ul><li><p>用户登录。在分时系统中，用户在终端输入登录信息，系统检测通过后就为该终端用户建立新进程并插入到就绪队列</p></li><li><p>作业调度。在批处理系统中，当作业调度程序按照一定的算法调度到某个作业时，将该作业装入内存，并为其分配资源并创建进程，并插入到就绪队列</p></li><li><p>请求服务。基于进程的需要，由其自身创建一个新进程并完成特定任务</p></li></ul><p>【创建进程时，操作系统需要完成的主要工作是什么？】</p><ul><li><p>先向系统申请一个空闲PCB，并指定唯一的进程标识符（PID）</p></li><li><p>为新进程分配必要的资源</p></li><li><p>将新进程的PCB初始化。为新进程的PCB填入进程名，家族信息，程序数据地址，优先级等信息</p></li><li><p>将新进程的PCB插入到就绪队列</p></li></ul><p>【导致进程撤销的事件有哪些？】</p><p>进程正常结束，进程异常结束以及外界干预等</p><p>【撤销一个进程时，操作系统主要完成的工作是什么？】</p><ul><li><p>先从PCB集合中找到被撤销进程的PCB</p></li><li><p>若被撤销进程正处于执行状态，则应立即停止该进程的执行，设置重新调度标识，以便进程重新后将处理器分配给其他进程</p></li><li><p>对后一种撤销策略，若被撤销进程有子孙进程，还应将该进程的子孙进程撤销</p></li><li><p>回收被撤销进程所占有的资源，或者归还给父进程，或者归还给系统。最后，回收其PCB</p></li></ul><p>【阻塞一个进程时，操作系统主要完成的工作是什么？】</p><ul><li><p>首先停止当前进程的运行。因该进程正处于执行状态，故应中断处理器</p></li><li><p>保存该进程的CPU现场以便之后可以重新调用该进程并从中断点开始执行</p></li><li><p>停止运行该进程，将进程状态由执行状态改为阻塞状态，然后将该进程插入到相应事件的等待队列中</p></li><li><p>转到进程调度程序，从就绪队列中选择一个新的进程投入运行</p></li></ul><p>【唤醒一个进程时，操作系统主要完成的工作是什么？】</p><ul><li><p>将被唤醒进程从相应的等待队列中移出</p></li><li><p>将状态改为就绪并插入相应的就绪队列</p></li></ul><p>【简述进程上下文切换的过程】==【切换进程时，操作系统主要完成的工作是什么？】</p><ul><li><p>保存处理及上下文，包括程序计数器和其他寄存器</p></li><li><p>更新PCB信息</p></li><li><p>把进程的PCB移入相应队列，如就绪，某事件的阻塞队列</p></li><li><p>选择另一个进程执行，更新其PCB</p></li><li><p>更新内存管理的数据结构</p></li><li><p>恢复处理器上下文</p></li></ul><p>【进程与作业的关系】</p><p>作业是用户向计算机提交任务的任务实体，而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位</p><p>一个作业可由一个或多个进程组成，但一个进程不能构成多个作业</p><p>作业的概念主要用在批处理系统中，而进程的概念则几乎用在所有的多道程序系统中</p></blockquote><h2 id="进程调度的基本概念调度方式调度算法">2、进程调度的基本概念、调度方式、调度算法</h2><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/IMG_2285(20200829-102509).PNG" alt="IMG_2285(20200829-102509)"><figcaption>IMG_2285(20200829-102509)</figcaption></figure><h3 id="进程调度的概念">进程调度的概念</h3><ul><li><strong>系统按照某种算法动态地把处理器分配给就绪队列中的某个进程，以便使之执行</strong></li></ul><h3 id="操作系统中的3级调度">操作系统中的3级调度</h3><blockquote><p>高级调度，又称作业调度，按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程，发生频率最低</p><p>中级调度，又称内存调度，按照某种规则，从挂起队列中选择合适的进程将其数据调回内存，发生频率中等</p><p>低级调度，又称进程调度，按照某种规则，从就绪队列中选择一个进程为其分配处理机，发生频率最高</p></blockquote><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828152139261.png" alt="image-20200828152139261"><figcaption>image-20200828152139261</figcaption></figure><h3 id="进程调度的方式cpu调度算法中抢占式调度和非抢占式调度有何区别">进程调度的方式/CPU调度算法中抢占式调度和非抢占式调度有何区别？</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828161817900.png" alt="image-20200828161817900"><figcaption>image-20200828161817900</figcaption></figure><ul><li><p>抢占方式，当一个进程正在处理器上运行时，若有更高优先级的进程进入就绪队列，则立即暂停执行当前进程，将处理器分配给新进程。可优先处理紧急进程，也可实现让各进程按时间片轮流执行，适用于分时操作系统，实时操作系统</p></li><li><p>非抢占方式，当一个进程正在处理器上运行时，即使有更高优先级的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或者因发生某种事件而进入完成或者阻塞状态时，才把处理器分配个新进程。实现简单，开销小，但无法处理紧急任务，适用于早期批处理系统</p></li></ul><h3 id="在交互式系统中非剥夺是不是一个好的策略为什么">在交互式系统中，非剥夺是不是一个好的策略？为什么？</h3><p>在分时系统中不剥夺并不是一个好的策略。因为在分时系统中，除了交互性以外，及时性是很重要的性能因素。当一个作业被阻塞后，CPU就完全空闲了，别的用户的及时性就无法保证了，而完全可以把这些时间分配给别的作业运行。以提高整体的吞吐量。</p><h3 id="调度算法的评级指标">调度算法的评级指标</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901161312189.png" alt="image-20200901161312189"><figcaption>image-20200901161312189</figcaption></figure><h3 id="调度算法">调度算法</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111857860.png" alt="image-20201006111857860"><figcaption>image-20201006111857860</figcaption></figure><ul><li><p>先来先服务：先请求CPU的进程先分配到CPU</p></li><li><p>短作业优先：平均等待时间最短，但难以知道下一个CPU区间长度</p></li><li><p>优先级调度：分为抢占式和非抢占式，优先级相同时，通常按照先来先服务或者短作业优先的顺序执行</p></li><li><p>时间片轮转：各进程执行一个时间片</p></li><li><p>高响应比优先：响应比=（等待时间+运行时间）/运行时间</p></li><li><p>多级反馈队列调度</p><p>与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p></li></ul><blockquote><p><u>优先级调度算法</u>按照任务的优先级进行调度，对于更紧急的任务会有更高的优先级，适合实时操作系统。</p><p><u>高响应比优先调度算法，时间片轮转调度算法，多级反馈队列调度算法</u> 都能保证每个任务在一定时间内分到时间片，并轮流占用CPU，适合分时操作系统。</p></blockquote><h3 id="为什么要进行处理机的调度">为什么要进行处理机的调度？</h3><p>答：若没有处理机的调度，就意味着要等到当前运行的进程执行完毕后，下一个进程才能执行，而实际情况中，进程时常需要等待一些外部设备的输入，而外部设备的速度与处理机相比是非常缓慢的，若让处理机总是等待外部设备，则对处理机的资源是一种极大的浪费。而引进处理机调度后，可在运行进程等待外部设备时，把处理机调度给其他进程，从而提高处理机的利用率。简单来说，就是<strong>为了合理地处理计算机的软/硬件资源</strong>。</p><blockquote><p>【引起进程调度的原因】</p><p>当前进程运行结束，包括任务完成而正常结束或者因出现错误而异常结束</p><p>当前运行进程因某种原因，如I/O请求，P操作，阻塞原语等从运行态变为阻塞态</p><p>执行完系统调用等系统程序后返回用户进程，这时可以看作系统进程执行完毕，从而可以调度一个新的用户进程</p><p>在采用抢占式调度方式的系统中，更高优先级的进程要求使用处理器，则使当前运行进程进入就绪队列</p><p>在分时系统中，分配给该进程的时间片已用完</p><p>【不能进行进程调度的情况】</p><p>处理中断的过程中。处理中断过程复杂，很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理器资源</p><p>在操作系统内核程序临界区中。进程进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放</p><p>在其他需要完全屏蔽中断的原子操作过程中。原子操作不可再分，不能进行进程切换</p></blockquote><h2 id="进程同步的基本概念临界区信号量经典同步问题">3、进程同步的基本概念、临界区、信号量、经典同步问题</h2><h3 id="为什么要引入进程同步的概念">为什么要引入进程同步的概念？</h3><p>答：在多道程序共同执行的条件下，进程与进程之间是并发执行的，不同进程之间存在不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p><h3 id="两种形式的制约关系同步和互斥">两种形式的制约关系：同步和互斥？</h3><ul><li><p>同步：直接相互制约关系。多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消 息，获得消息之前进入阻塞态；</p></li><li><p>互斥：间接相互制约关系。多个进程在同一时刻只有一个进程能进入临界区</p></li></ul><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829102854372.png" alt="image-20200829102854372"><figcaption>image-20200829102854372</figcaption></figure><blockquote><p>临界资源：同时仅允许一个进程使用的资源</p><p>临界区：进程中用于访问临界资源的代码，又称临界段</p></blockquote><h3 id="临界区互斥的要求同步机制的4个准则">临界区互斥的要求/同步机制的4个准则</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006101307403.png" alt="image-20201006101307403"><figcaption>image-20201006101307403</figcaption></figure><ul><li><strong>空闲让进</strong>：当没有进程处于临界区时，可以允许一个请求进入临界区的进程立即进入临界区</li><li><strong>忙则等待</strong>：当已有进程进入临界区时，其他师徒进入的进程必须等待</li><li><strong>有限等待</strong>：对要求访问临界区的进程，应在有限的时间内进入自己的临界区</li><li><strong>让权等待</strong>：当一个进程因为某些已有无法进入自己的临界区时，应释放处理器给其他进程</li></ul><h3 id="信号量">信号量</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829110504215.png" alt="image-20200829110504215"><figcaption>image-20200829110504215</figcaption></figure><blockquote><p>(1)整型信号量：未遵循让权等待</p><p>(2)记录型信号量（资源信号量），P&amp;V 操作主要用这个</p></blockquote><h3 id="经典ipc问题">经典IPC问题</h3><blockquote><p>生产者-消费者 读者写者问题（读优先，读写公平，写优先） 哲学家进餐 理发师</p></blockquote><h3 id="什么是管程">什么是管程？</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829111335944.png" alt="image-20200829111335944"><figcaption>image-20200829111335944</figcaption></figure><p>管程是由<strong>一组局部变量</strong>、<strong>对局部变量进行操作的一组过程</strong>和<strong>对局部变量进行初始化的语句序列</strong>组成。 引入的原因是因为P/V操作太过分散，对它的<strong>维护很麻烦且容易造成死锁</strong>。 管程的特点是：</p><ol type="1"><li>管程的过程只能访问管程的局部变量，管程的局部变量只能由其过程来访问；</li><li>任何时刻只能有一个进程进入管程执行；</li><li>进程只能通过管程提供的过程入口进入管程。</li></ol><h2 id="死锁的基本概念处理策略死锁预防和死锁避免的算法死锁检测">4、死锁的基本概念、处理策略、死锁预防和死锁避免的算法、死锁检测</h2><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829165839493.png" alt="image-20200829165839493"><figcaption>image-20200829165839493</figcaption></figure><h3 id="死锁的定义">死锁的定义</h3><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829120015942.png" alt="image-20200829120015942"><figcaption>image-20200829120015942</figcaption></figure><h3 id="饥饿和死锁">饥饿和死锁？</h3><p>饥饿：指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。</p><p>相同：二者都是因为竞争资源引起的。</p><p>差别：</p><ol type="1"><li><p>进入饥饿的进程可以只有一个，但是死锁必须大于等于两个；</p></li><li><p>出于饥饿状态的进程可以是一个就绪进程，但是死锁状态的进程必定是阻塞进程。</p></li></ol><h3 id="可剥夺资源与不可剥夺资源的区别">可剥夺资源与不可剥夺资源的区别</h3><ul><li><p>可剥夺资源是指虽然资源占有者进程需要使用该资源，但另一个进程可以强行把该资源剥夺来归自己使用</p></li><li><p>不可剥夺资源是指除占有者进程不再需要使用该资源而主动释放资源，其他进程不可在资源占有者使用资源过程中强行剥夺</p></li></ul><h3 id="死锁产生的原因">死锁产生的原因</h3><ul><li><p>系统资源不足（根本原因）（对不可剥夺资源的竞争）</p></li><li><p>进程推进顺序不当（P1拥有A申请B，P2拥有B申请A）</p></li></ul><h3 id="死锁产生的必要条件">死锁产生的必要条件</h3><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829121437044.png" alt="image-20200829121437044"><figcaption>image-20200829121437044</figcaption></figure><ul><li><p><strong>互斥条件</strong>：进程要求对所分配的资源进行排他性控制，即在一段时间内某种资源仅为一个进程所占有</p></li><li><p><strong>不剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，只能由获得该资源的进程主动释放</p></li><li><p><strong>请求和保持条件</strong>：也成部分分配条件，是指进程已经保持了至少一个资源，但又提出了新的资源请求，而在等待新的资源被分配的同时，又对已有资源保持占有</p></li><li><p><strong>循环等待条件</strong>：存在一种资源的循环等待链，而链中每一个进程已获得的资源同时被链中的下一个进程所请求</p></li></ul><h3 id="有什么方法解决死锁问题处理死锁的基本方法">有什么方法解决死锁问题？（处理死锁的基本方法）</h3><ol start="0" type="1"><li><p>鸵鸟算法：视死锁不见</p></li><li><p>预防死锁：破坏死锁产生的4个必要条件中的一个或多个</p></li><li><p>避免死锁：在资源的动态分配过程中，用 某种方法(一些算法)去防止系统进入不安全状态，从而避免发生死锁。</p></li><li>检测死锁：若不加任何限制措施，系统可在为进程分配资源的同时，记录下来进程的请求和分配信息，然后按某种算法计算系统是否会发生死锁；</li><li><p>解除死锁：系统发生死锁时通常采用撤销进程或剥夺进程资源的方法使系统解除死锁。</p></li></ol><h3 id="死锁的预防静态策略">死锁的预防（静态策略）</h3><ol type="1"><li><p>破坏互斥条件：允许多个进程同时访问资源，可行性不高</p></li><li><p>破坏不剥夺条件：对于一个已经获得了某些资源的进程，若新的资源请求不能立即得到满足，则它必须释放所拥有的全部资源，以后需要时再重新申请，实现复杂，可能导致部分工作失效，导致系统开销增大，导致饥饿</p></li><li><p>破坏请求和保持条件：运行之前一次行分配好所需要的全部资源，简单安全，但资源利用率低，可能导致饥饿</p></li><li><p>破坏循环等待条件：给资源编号，必须按照编号从小到大的顺序申请资源，不方便增加新设备，会造成资源浪费，用户编程麻烦</p></li></ol><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829130743530.png" alt="image-20200829130743530"><figcaption>image-20200829130743530</figcaption></figure><h3 id="死锁的避免动态策略">死锁的避免（动态策略）</h3><h4 id="什么是安全状态">什么是安全状态？</h4><p>安全状态是指系统按照某种进程顺序，为进程分配资源，使得每个进程都能获取所需的最大资源，并顺利完成。</p><p>当系统不安全时就是系统不一定是死锁状态，但是死锁状态一定是不安全状态。</p><h4 id="银行家算法">银行家算法</h4><p>主要思想是避免系统进入不安全状态，在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先试行分配，并对分配后的新状态进行安全性检查。如果新状态安全，则正式分配上述资 源，否则拒绝分配上述资源。这样就保证系统始终处于安全状态，从而避免死锁现象的发生。</p><h3 id="死锁的检测">死锁的检测</h3><h4 id="死锁定理">死锁定理</h4><p>系统状态为死锁的条件是：当且仅当g该状态下的资源分配图是不可完全简化的。</p><p>如果资源分配图是可以完全简化的（能消去所有的边），则没有死锁。</p><h3 id="死锁的解除">死锁的解除</h3><ul><li><p><strong>资源剥夺法</strong>：从其进程中抢占足够的资源给死锁的进程以解除其死锁状态</p></li><li><p><strong>撤销进程法</strong>：撤销一些进程，直到有足够的资源分配给其他进程，进程死锁状态</p></li><li><p><strong>进程回退法</strong>：让一个或多个进程回退到足以避免死锁的地步，进程回退时资源释放资源而不是被剥夺，要求系统保持进程的历史信息，设置还原点</p></li></ul><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829130957970.png" alt="image-20200829130957970"><figcaption>image-20200829130957970</figcaption></figure><h1 id="第三章-内存管理">第三章 内存管理</h1><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901090309778.png" alt="image-20200901090309778"><figcaption>image-20200901090309778</figcaption></figure><h2 id="内存管理基本概念">1、内存管理基本概念</h2><h4 id="内存管理的功能">内存管理的功能？</h4><ul><li><p>内存的分配与回收：实施内存的分配，回收系统或用户释放的内存空间。</p></li><li><p>地址变换：提供地址变换功能，将逻辑地址转换成物理地址。</p></li><li><p>内存扩充：借助于虚拟存储技术或其他自动覆盖技术，为用户提供比内存空间大的地址空间， 从逻辑 上扩充内存。</p></li><li><p>存储保护：保证进入内存的各道作业都在自己的存储空间内运行，互不干扰</p></li></ul><h4 id="将用户程序变为可在内存中执行的程序的步骤">将用户程序变为可在内存中执行的程序的步骤？</h4><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200831084249851.png" alt="image-20200831084249851"><figcaption>image-20200831084249851</figcaption></figure><ol start="0" type="1"><li><p>编辑</p></li><li><p><strong>编译</strong>：由编译程序将用户源代码编译成若干目标模块</p></li><li><p><strong>链接</strong>：由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的 装入模块。</p></li><li><p><strong>装入</strong>：由装入程序将装入模块装入内存中运行。</p></li></ol><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829200126647.png" alt="image-20200829200126647"><figcaption>image-20200829200126647</figcaption></figure><h4 id="链接的3种方式">链接的3种方式</h4><ul><li><p><strong>静态链接</strong>：在程序运行之前，先把各个目标模块及所需库链接为一个完整的可执行程序，以后不再拆开</p></li><li><p><strong>装入时动态链接</strong>：将应用程序编译后所得到一组目标模块装入内存时采用边装入边链接的动态链接方式</p></li><li><p><strong>运行时动态链接</strong>：在程序执行中需要该目标模块时，才对这些模块进行链接，便于修改和更新，便于实现对目标模块的共享</p></li></ul><h4 id="程序装入的3种方式">程序装入的3种方式</h4><ul><li><p><strong>绝对装入</strong>：编译时就知道程序将要驻留在内存中的物理地址，编译程序产生含有物理地址的目标代码，不适合多道程序设计</p></li><li><p><strong>可重定位装入</strong>：又称静态重定位，根据内存当前情况，将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，之后不再改变，适用于早期的多道批处理操作系统，容易实现，无需增加硬件地址变换机构，但要求为每个程序分配一个连续的存储区，而且在程序执行期间不能移动，不能再申请内存空间，难以做到程序和数据的共享</p></li><li><p><strong>动态运行时装入</strong>：又称动态重定位，允许程序运行时在内存中移动位置，把地址变换推迟到程序真正要执行时才进行，需要一个重定位寄存器的支持：物理地址=基址寄存器内容+逻辑地址</p></li></ul><p>【内存保护的方法】</p><blockquote><p>界限寄存器方法，包括上、下界寄存器方法和基址和限长寄存器方法</p><p>存储保护键方法,给每个存储块分配一个单独的保护键</p></blockquote><h2 id="内存交换及分页分段段页式内存分配管理">2、内存交换及分页、分段、段页式内存分配管理</h2><h3 id="内存空间的分配与回收----连续分配管理方式">内存空间的分配与回收----连续分配管理方式</h3><ol type="1"><li><p><strong>单一连续分配</strong></p><ul><li><p>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户 区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。</p></li><li><p>这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。缺点是只能 用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。</p></li></ul></li><li><p><strong>固定分区分配</strong></p><p>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小 的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中,选择适 当大小的作业装入该分区，如此循环。</p><p>固定分区分配在划分分区时，有两种不同的方法。</p><ul><li><p>分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。</p></li><li><p>分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。</p></li></ul></li><li><p><strong>动态分区分配</strong></p><p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内 存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进 程的需要。因此系统中分区的大小和数目是可变的。</p></li></ol><h3 id="动态分区分配算法">动态分区分配算法</h3><p>在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存 块给进程使用，这就是动态分区的分配策略，考虑以下几种算法：</p><ol type="1"><li><strong>首次适应(First Fit)算法</strong>：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能 满足要求的第一个空闲分区。</li><li><strong>最佳适应(Best Fit)算法</strong>：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分 区。</li><li><strong>最坏适应(Worst Fit)算法</strong>：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链 接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</li><li><strong>邻近适应(Next Fit)算法</strong>：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分 配内存时从上次查找结束的位置开始继续查找。</li></ol><h2 id="非连续分配管理">非连续分配管理</h2><h3 id="基本分页-存储管理方式的优缺点">基本分页 存储管理方式的优缺点</h3><ul><li><p>优点：内存利用率高，实现了离散分配，便于存储访问控制，无外部碎片</p></li><li><p>缺点：需要硬件支持（尤其是快表），内存访问效率下降，共享困难，有内部碎片</p></li></ul><h3 id="基本分段-存储管理方式的优缺点">基本分段 存储管理方式的优缺点</h3><ul><li><p>优点：便于程序模块化处理和处理变换的数据结构，便于动态链接和共享，无内部碎片</p></li><li><p>缺点：与分页类似，需要硬件支持；为满足分段的动态增长和减少外部碎片，要采用拼接技术；分段的最大尺寸受到主存可用空间的限制；有外部碎片</p></li></ul><h3 id="分段与分页的区别">分段与分页的区别</h3><ul><li><p>页是信息的物理单位，段是信息的逻辑单位；</p></li><li><p>分页的目的是系统管理所需，为了提高内存利用率；分段的目的是为了更好的满足用户的需要，实现地址共享</p></li><li><p>页的大小固定且由系统决定；段的长度不固定，段长由用户编写的程序决定</p></li><li><p>分页的地址空间是一维的；而分段的地址空间是二维的；</p></li><li><p>分页有内部碎片，无外部碎片；分段有外部碎片，无内部碎片</p></li></ul><h3 id="页式存储管理方式中设置快表的作用">页式存储管理方式中设置快表的作用</h3><p>快表，又称联想寄存器(TLB)，时一种访问速度比内存快很多的高速缓存，用来存放最近访问过的页表项的副本，若快表命中，则只要访问一次高速缓存以及一次主存即可，这样就可以加速地址变换的速度，从而提高了查找的速度和指令执行效率</p><h3 id="什么是页表和快表有什么作用">什么是页表和快表，有什么作用？</h3><p>页表指出逻辑地址中的页号与所占主存块号的对应关系。</p><p>作用：页式存储管理在用动态重定位方式装入作业时，要利用页表做地址转换工作。快表就是存放在高速缓冲存储器的部分页表。它起页表相同的作用。由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表， 有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><h3 id="地址翻译的过程">地址翻译的过程？</h3><blockquote><p>TLB-&gt;页表（TLB不命中）-&gt;Cache-&gt;主存（Cache不命中）-&gt;外存</p></blockquote><h2 id="虚拟内存">3、虚拟内存</h2><h3 id="内存空间的扩充">内存空间的扩充</h3><ul><li><p>覆盖</p></li><li><p>交换</p></li></ul><ol type="1"><li><p>覆盖技术： 把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位，把程序执行时并不要 求同时 装入内存的覆盖组成一组，成为覆盖段，这个覆盖段分配到同一个存储区域，这个存储区 域成为覆盖区，它与覆盖段一一对应。覆盖段的大小由覆盖段中最大的覆盖来确定。（为了解决 内存容量太小的问题，打破了必须将一个程序全部信息装入内存后才能运行的限制）</p></li><li><p>交换技术： 把暂时不用的某个程序及数据部分从内存移到外存中去，以便腾出必要的内存空间；或者把指定 的程序或数据从外存读到相应的内存中，并将控制权交给他，让其在系统上运行的一种内存扩充 技术。处理器的中级调度就是采用交换技术。</p></li><li><p>区别：</p></li></ol><p>① 与覆盖技术相比，交换技术不要求程序员给出的 程序段之间的覆盖结构；</p><p>② 交换技术主要在进程和作业之间进行，覆盖技术主要在同一个进程或作业中进行；</p><p>③ 覆盖技术只能覆盖于覆盖程序段无关的程序段，交换进程由换出和换入两个过程组成。</p><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901033503721.png" alt="image-20200901033503721"><figcaption>image-20200901033503721</figcaption></figure><h3 id="虚拟内存的特征">虚拟内存的特征</h3><ul><li><p><strong>离散性</strong>：程序在内存中离散存储</p></li><li><p><strong>多次性</strong>：一个作业可以分成多次调入内存</p></li><li><p><strong>对换性</strong>：又称交换性，指作业在运行过程中可以换入换出</p></li><li><p><strong>虚拟性</strong>：从逻辑上扩充内存容量，用户可以使用的空间远大于实际内存容量</p></li></ul><h3 id="局部性原理">局部性原理</h3><ul><li><p>时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问，都集中在一个较短的时期内</p></li><li><p>空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的数据，都集中在一个较小的区域内</p></li></ul><h3 id="页面置换算法决定应该换入换出哪页">页面置换算法（决定应该换入/换出哪页）</h3><p>进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲时间时，就需要从内存中调入一页程序或数据，送入磁盘的对换区。</p><p>选择调出页面的算法就成为页面置换算法。</p><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829211857819.png" alt="image-20200829211857819"><figcaption>image-20200829211857819</figcaption></figure><h4 id="最佳opt置换算法">1. 最佳（OPT）置换算法</h4><p>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。 于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 即被淘汰页面是以后永不使用或最长时间内不再访问的页面。（往后看）</p><h4 id="先进先出fifo置换算法">2. 先进先出（FIFO）置换算法</h4><p>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存 时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被 使用的可能性最大。 即优先淘汰最早进入内存的页面。（往前看）</p><h4 id="最近最久未使用lru算法">3. 最近最久未使用（LRU）算法</h4><p>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推 测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访 问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的 页面予以淘汰。 即淘汰最近最长时间未访问过的页面。（往前看）</p><h4 id="时钟clock置换算法">4. 时钟(CLOCK)置换算法</h4><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。 所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是 CLOCK算法的变体。</p><p>该算法为每个页面设置一位访问位，将内存中的所有页面通过指针链成一个循环队列。由于该算法<strong>只有一位访问位</strong>，只能用它表示该页是否已经使用过，而置换时是将最近未使用过的页面换出去，所以把该算法称为最近未用算法。 <strong>选择页置换的过程</strong>： 1.当某页被访问时，其访问位置“1”； 2.在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页； 3.在循环队列中检查下一个页面，直到访问到访问位为“0”的页面为止。</p><p>由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。</p><h3 id="抖动现象">抖动现象</h3><p>刚刚换出的页面，过后不久又要访问，并且调入不久后又被调出，如此反复，使得系统把大部分的时间用在了页面的调入调出上，而几乎不能有效的工作</p><h1 id="第四章-文件管理">第四章 文件管理</h1><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829211145794.png" alt="image-20200829211145794"><figcaption>image-20200829211145794</figcaption></figure><h2 id="文件系统基础">1、文件系统基础</h2><h3 id="文件的定义">文件的定义</h3><p>文件是具有文件名的一组相关元素的集合，在文件系统中是一个最大的数据单位，它描述了一个对象集，每个文件都有一个文件名，用户通过文件名来访问文件</p><h3 id="文件的组成结构">文件的组成结构</h3><p>数据项，文件系统中最低级的数据组织形式，包括基本数据项(<code>用于描述一个对象是的某种特性的一个值</code>)和组合数据项(<code>由多个数据项组合而成</code>)</p><p>记录，是指一组相关的数据项的集合，用于描述一个对象在某一方面的属性</p><p>文件，是指由创建者所定义的一组相关数据的集合，逻辑上可分为有结构文件和无结构文件</p><h3 id="文件的属性">文件的属性</h3><blockquote><p>名称。文件名唯一，以容易读取的形式保存</p><p>标识符。系统内文件的唯一标签，对用户透明</p><p>文件类型。被支持不同类型的文件系统使用</p><p>文件位置。指向文件的指针</p><p>文件的大小，建立时间，用户标识</p></blockquote><h3 id="文件的逻辑结构顺序文件索引文件和索引顺序文件">文件的逻辑结构：顺序文件、索引文件和索引顺序文件</h3><p>3种有结构文件：</p><ul><li><p>顺序文件：定长记录的顺序文件，若物理上采用顺序存储则可以实现随机存取，若再能保证记录的顺序结构，则可实现快速检索，但因为文件存储要求连续的存储空间，所以会产生碎片，同时也不利于文件的动态扩充</p></li><li><p>索引文件：可以进行随机访问，易于文件的增删，但索引表的使用增加了存储空间的开销，并且索引表的查找策略对文件系统的影响很大</p></li><li><p>索引顺序文件：大大提高了了顺序存取速度，但仍需配置一个索引表，增加了存储开销</p></li></ul><p>FAT: 文件配置表file allocation table: 分配给文件的所有盘块号都放在该表中，记录了文件所在位置。</p><p>文件系统：负责管理和存储文件信息的软件机构，由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性</p><p>文件系统类型： Windows中有FAT32，NTFS，Linus中有ext2,ext3,ext4</p><h3 id="目录结构">目录结构</h3><p>【目录的功能】</p><blockquote><p>实现按名存取</p><p>提高检索速度</p><p>允许文件同名</p><p>允许文件共享</p></blockquote><h4 id="区分文件目录目录文件">区分文件目录，目录文件</h4><ul><li><p>文件目录：又称文件控制块，存储的是文件的管理信息，控制对象是单个文件；</p><ul><li><p>文件控制块FCB</p><p>文件控制块是用于保存文件属性信息的数据结构，至少包含以下信息：文件名，文件的结构（有结构的记录式文件or无格式的流式文件），文件的物理位置，存取控制信息，管理信息</p></li></ul></li><li><p>目录文件：存储的是若干个文件目录，控制对象是整个文件系统；</p><ul><li>目前广泛采用的树形目录结构，优点是：允许文件重命名，实现了文件分类。</li></ul></li></ul><p>【索引结点】</p><blockquote><p>FCB的改进，把除了文件名之外的其他文件描述信息都放到<code>索引结点（i结点）</code>，文件目录中的每个目录项仅由文件名和指向该文件i节点的指针构成；</p><p>存放在磁盘上的使用节点称为<code>磁盘索引节点</code>，每个文件都有唯一的磁盘索引节点，主要包括以下内容：文件主标识符，文件类型，文件存取权限，文件物理地址，文件长度，文件链接计数，文件存取时间；</p><p>存放在内存中的索引节点称为<code>内存索引节点</code>，主要包括以下内容：索引节点编号，状态，访问计数，逻辑设备号，链接指针</p></blockquote><p>【文件的目录结构】</p><blockquote><p>单级目录结构，在整个文件系统中只建立一张目录表，每个文件占据其中的一个表目，易于实现，管理简单，但不允许文件重名，文件查找速度慢</p><p>二级目录结构，将文件目录分为主文件目录和用户文件目录，允许文件重名，可获得较高的查找速度，但缺乏灵活性，用户不能对自己的文件进行分类</p><p>多级目录结构，又称树形目录结构，，使用路径名来唯一标识文件，便于对文件分类，层次结构清晰，能更有效的进行文件的管理与保护，但查找文件时需按照路径名逐级访问中间节点，增加了磁盘访问次数，进而影响了查询速度</p><p>无环图目录结构，实现了文件的共享，但使得系统的管理变得复杂</p></blockquote><p>（4）文件的访问类型及访问控制</p><p>【访问类型】</p><blockquote><p>读，写，执行，添加，删除，列表清单</p></blockquote><p>【访问控制】</p><blockquote><p>对不同的用户访问同一个文件采取不同的访问类型，访问控制通常有四种方法：</p><p>访问控制矩阵，访问控制表和用户权限表都是采用某种数据结构来记录用户或用户组对每个文件的操作权限，而口令和密码是另一种访问控制方法，口令直接存储在系统内部，不够安全，密码方法的保密性强，节省存储空间，但编码和译码要花费一定时间</p></blockquote><h2 id="文件系统实现">2、文件系统实现</h2><p>（1）文件系统层次结构</p><p>【文件的层次结构】</p><blockquote><p>用户接口</p><p>文件目录系统</p><p>存取控制验证</p><p>逻辑文件系统与文件信息缓冲区</p><p>物理文件系统</p></blockquote><p>（2）目录实现</p><p>【目录的实现】</p><blockquote><p>线性表</p><p>散列表</p></blockquote><p>（3）文件实现</p><p>【外存分配方式】</p><blockquote><p>静态分配：在文件建立时一次性分配所需的全部空间</p><p>动态分配：根据动态增长的文件长度进行分配</p></blockquote><p>【连续分配】</p><blockquote><p>最简单的磁盘空间分配策略，为文件分配连续的磁盘区域，保证了逻辑文件中的记录顺序与存储器中文件占用盘块顺序一致；优点是查找速度快（只需起始块号和文件大小），目录中关于文件物理存储位置的信息也比较简单，缺点是不方便文件拓展，容易产生碎片，需要定期进行存储空间的紧缩</p></blockquote><p>【链接分配】</p><blockquote><p>分为隐式链接和显式链接。</p><p>隐式链接（默认）：目录项中有指向索引顺序文件的第一块盘块和最后一块盘块的指针，此外每个盘块中都含有指向下一个盘块的指针；缺点是不支持随机访问，访问效率低下，并且由于其中任何一个盘块的指针错误都会导致后面的盘块的位置丢失；另外，指向下一个盘块的指针也需要耗费少量的存储空间；优点是方便文件拓展，不会有碎片问题，外存利用率高</p><p>显式链接：把用于链接文件各物理块的指针显式地存放在一张表中，称为文件分配表(FAT)，一个磁盘仅设置一张FAT并且在开机时就将其读入内存且常驻内存；优点是既支持顺序访问，又支持随机访问，块号转换过程无需访问磁盘，因此访问速度较快；缺点是FAT需要占用一定的存储空间</p></blockquote><p>【索引分配】</p><blockquote><p>系统为每个文件分配一个索引块，索引块中存放索引表，索引表的每个表项对应分配给该文件的一个物理块；优点是支持随机访问，无外部碎片，便于文件拓展，缺点是访存次数增加导致文件的存取速度降低（可以通过提前将索引表调入内存来解决），索引表本身需占用一定的存储空间</p></blockquote><p>【文件的存储空间管理】</p><blockquote><p>空闲文件表 空闲块链表 位示图，保存在主存中</p><p>成组链接法(UNIX的文件存储空间管理方法)，适用于大型文件系统</p></blockquote><h2 id="磁盘组织与管理">3、磁盘组织与管理</h2><p>（1）磁盘的结构</p><blockquote><p>引导控制块</p><p>分区控制块</p><p>目录结构</p><p>文件控制块</p></blockquote><h3 id="磁盘调度算法有哪些">磁盘调度算法有哪些？</h3><h4 id="先来先服务算法fcfsfirst-come-first-service">1. 先来先服务算法（FCFS）First Come First Service</h4><p>这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优 点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满 足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低 设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较 小。</p><h4 id="最短寻道时间优先算法sstf-shortest-seek-time-first">2. 最短寻道时间优先算法（SSTF） Shortest Seek Time First</h4><p>该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时 间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的 服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况 下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。</p><h4 id="扫描算法scan电梯调度">3. 扫描算法（SCAN）电梯调度</h4><p>扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例 如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当 前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换 向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁 道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称 为电梯调度算法。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间 变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但 由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。</p><h4 id="循环扫描算法cscan">4. 循环扫描算法（CSCAN）</h4><p>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一 端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一 端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定 磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里 的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。</p><h1 id="第五章-输入输出管理">第五章 输入输出管理</h1><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901094051834.png" alt="image-20200901094051834"><figcaption>image-20200901094051834</figcaption></figure><p><strong>设备管理的主要任务就是控制设备和内存或处理及之间的数据传送。</strong></p><p>外设和内存之间的io控制方式有四种：</p><h2 id="io控制方式有哪些">I/O控制方式有哪些？</h2><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901094752112.png" alt="image-20200901094752112"><figcaption>image-20200901094752112</figcaption></figure><h3 id="程序-io-方式">1. 程序 I/O 方式</h3><p>早期的计算机系统中， 没有中断系统，所以CPU和I/O设备进行通信，传输数据时CPU速度远快于 I/O设备，于是CPU需要不断测试I/O设备，看其是否完成了传输。</p><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111433996.png" alt="image-20201006111433996" style="zoom:80%"></p><h3 id="中断驱动方式">2. 中断驱动方式</h3><p>当某进程要启动某个 I/O 设备工作时，便由 CPU 向相应的设备控制器发出一条 I/O 命令，然后立 即返回继续执行原来的任务。仅当输完一个数据时，才需 CPU 花费极短的时间去做些中断处理。</p><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111522762.png" alt="image-20201006111522762" style="zoom:80%"></p><h3 id="dma方式直接存储器访问">3. DMA方式（直接存储器访问）</h3><p>在中断驱动方式中，io设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度还是受限，而DMA（直接存储器存取）的思想是：在I/O设备和内存之间开辟直接的数据交换通路，彻底”解放“CPU。</p><p>通过在I/O设备和内存之间开启一个可以直接传输数据的通路，采用DMA控制器来控制一个数据块 的传输，CPU只需在一个数据块传输开始阶段设置好传输所需的控制信息，并在传输结束阶段做 进一步处理。</p><figure><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111541455.png" alt="image-20201006111541455"><figcaption>image-20201006111541455</figcaption></figure><h4 id="dma控制方式与中断驱动方式的主要区别">DMA控制方式与中断驱动方式的主要区别：</h4><ul><li><p>主要区别是，中断驱动方式在每个数据需要传输时中断CPU，而DMA控制方式则是在所要求的传送的一批数据完成传送结束后才中断CPU。</p></li><li><p>中断驱动方式的数据传送，在中断处理时由CPU控制，而DMA控制方式是在DMA控制器的控制下完成的。</p></li></ul><h3 id="io通道控制方式">4. I/O通道控制方式</h3><p>通道，独立于 CPU 的专门负责输入输出控制的处理机，它控制设备与内存直接进行数据交换。有自己的通道指令，这些指令由 CPU 启动，并在操作结束时向 CPU 发出中断信号。</p><p>直接程序控制方式和中断程序控制方式适合于低速设备的数据传送，而 DMA 方式虽然适合于高速设备的数据传送，但一个 DMA 控制器只能控制少量的同类设备，这远远不能满足大型计算机系统的需要。通常，一个大型计算机需要连接大量的高速和低速设备，通道控制方式可以满足这个要求。</p><h4 id="io通道与一般处理机的区别">I/O通道与一般处理机的区别：</h4><p>通道指令单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说 通道与CPU共享内存。</p><h4 id="io通道与dma控制方式的区别">I/O通道与DMA控制方式的区别：</h4><ul><li><p>DMA方式需要CPU来控制传输的数据块大小，传输的内存位置，而通道方式中这些信息是由通道控制的。</p></li><li><p>每个DMA控制对应一台设备与内存传递数据，而一个通道可以龙之多台设备与内训的数据交换。</p></li></ul><h2 id="spooling技术">Spooling技术？</h2><p>虚拟性是OS的四大特性之一。如果说可以通过多道程序技术将一台物理CPU虚拟为多台逻辑 CPU，从而允许多个用户共享一台主机，那么，通过SPOOling技术便可将一台物理I/O设备虚拟 为多台逻辑I/O设备，同样允许多个用户共享一台物理I/O设备。</p><p>SPOOLing技术是对脱机输入、输出系统的模拟。相应地，SPOOLing系统必须建立在具有多道程 序功能的操作系统上，而且还应有高速随机外存的支持，这通常是采用磁盘存储技术。</p><p>SPOOLing系统主要有以下三部分：</p><p>（1）输入井和输出井。这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设 备，用于暂存I/Q设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数 据。</p><p>（2）输入缓冲区和输出缓冲区。为了缓和和CPU和磁盘之间速度不匹配的矛盾，在内存中要开辟 两个缓冲区；输入缓冲区和输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传 送到输入井。输出缓冲区用与暂存从输出井送来的数据，以后在传送给输出设备。</p><p>（3）输入进程SPi 和输入进程SP0。这里利用两个进程来模拟脱机I/O时的外围控制机。其中，进 程SPi模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井， 当CPU需要输入数据时，直接从输入井读入内存；进程SP0模拟脱机输出时的外围控制机，把用户 要求输出的数据从先内存送到输出井，待输出设备空闲时，在将输出井中的数据经过输出缓冲区 送到输出设备上。</p><h3 id="spooling技术的特点">SPOOLing技术的特点：</h3><p>(1)提高了I/O速度。从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作，如同脱机操作 一样，提高了I/O速度，缓和了CPU与低速I/O设备速度不匹配的矛盾。</p><p>(2)将独占设备改造为共享设备。因为在SPOOLing系统的系统中，实际上并没为任何进程分配设 备，而知识在输入井或输出井中为进程分配一个存储区和建立一张I/O请求表。这样，便把独占设 备改造为共享设备。</p><p>(3)实现了虚拟设备功能。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这 一设备，从而实现了设备的虚拟分配。不过，该设备是逻辑上的设备。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>小张同学</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://stuxiaozhang.github.io/2020/10/06/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统课堂笔记总结">http://stuxiaozhang.github.io/2020/10/06/复习-操作系统/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 计算机基础</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/10/05/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/" rel="prev" title="前缀和与差分"><i class="fa fa-chevron-left"></i> 前缀和与差分</a></div><div class="post-nav-item"><a href="/2020/10/07/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="next" title="双指针">双指针 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">第一章 操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%83%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.</span> <span class="nav-text">1、什么是操作系统？它的主要特征是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.</span> <span class="nav-text">2、操作系统的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 操作系统是计算机资源的管理者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BE%9B%E7%94%A8%E6%88%B7%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 提供用户与计算机之间的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%85%85%E6%9C%BA%E5%99%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 扩充机器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">1.3.</span> <span class="nav-text">3、中断和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%BC%95%E5%85%A5%E4%B8%BA%E4%BA%86%E6%94%AF%E6%8C%81cpu%E5%92%8C%E8%AE%BE%E5%A4%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 中断的引入——为了支持CPU和设备之间的并行操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%BC%95%E5%85%A5%E8%A1%A8%E7%A4%BAcpu%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E6%9C%AC%E8%BA%AB%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 异常的引入——表示CPU执行指令本身时出现的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 中断和异常的联系与区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 中断执行的流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.4.</span> <span class="nav-text">4、系统调用是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.1.</span> <span class="nav-text">与一般过程调用有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%98%AF%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%A4%9A%E8%BF%98%E6%98%AF%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%A4%9A"><span class="nav-number">1.4.2.</span> <span class="nav-text">指令是内核态的多还是用户态的多？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.</span> <span class="nav-text">中断和系统调用的区别:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%B9%8B%E5%90%8E%E4%BF%9D%E5%AD%98%E4%BB%80%E4%B9%88"><span class="nav-number">1.4.4.</span> <span class="nav-text">中断之后保存什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">1.5.</span> <span class="nav-text">5、操作系统的发展与分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">第二章 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">1、进程与线程的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">进程的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F-%E8%BF%9B%E7%A8%8B%E5%AE%9E%E4%BD%93"><span class="nav-number">2.2.2.</span> <span class="nav-text">进程的组成（进程映像 &#x2F; 进程实体）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.</span> <span class="nav-text">进程的状态与转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.2.4.</span> <span class="nav-text">进程与程序的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.5.</span> <span class="nav-text">进程同步有哪几种机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.6.</span> <span class="nav-text">进程间通信IPC的几种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8E%E7%BA%A7%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8Fpv"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">低级通信方式PV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">高级通信方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">线程的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">线程的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.3.</span> <span class="nav-text">线程同步的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">2.3.4.</span> <span class="nav-text">线程与进程的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">2、进程调度的基本概念、调度方式、调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.4.1.</span> <span class="nav-text">进程调度的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%843%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.2.</span> <span class="nav-text">操作系统中的3级调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8Fcpu%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%B8%AD%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E5%92%8C%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.3.</span> <span class="nav-text">进程调度的方式&#x2F;CPU调度算法中抢占式调度和非抢占式调度有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%9D%9E%E5%89%A5%E5%A4%BA%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">2.4.4.</span> <span class="nav-text">在交互式系统中，非剥夺是不是一个好的策略？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E7%BA%A7%E6%8C%87%E6%A0%87"><span class="nav-number">2.4.5.</span> <span class="nav-text">调度算法的评级指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.6.</span> <span class="nav-text">调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.7.</span> <span class="nav-text">为什么要进行处理机的调度？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.</span> <span class="nav-text">3、进程同步的基本概念、临界区、信号量、经典同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.5.1.</span> <span class="nav-text">为什么要引入进程同步的概念？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="nav-number">2.5.2.</span> <span class="nav-text">两种形式的制约关系：同步和互斥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E8%A6%81%E6%B1%82%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%844%E4%B8%AA%E5%87%86%E5%88%99"><span class="nav-number">2.5.3.</span> <span class="nav-text">临界区互斥的要求&#x2F;同步机制的4个准则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.5.4.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8ipc%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.5.</span> <span class="nav-text">经典IPC问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%A1%E7%A8%8B"><span class="nav-number">2.5.6.</span> <span class="nav-text">什么是管程？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%E5%92%8C%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%E7%9A%84%E7%AE%97%E6%B3%95%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">2.6.</span> <span class="nav-text">4、死锁的基本概念、处理策略、死锁预防和死锁避免的算法、死锁检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.6.1.</span> <span class="nav-text">死锁的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A5%A5%E9%A5%BF%E5%92%8C%E6%AD%BB%E9%94%81"><span class="nav-number">2.6.2.</span> <span class="nav-text">饥饿和死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%89%A5%E5%A4%BA%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E8%B5%84%E6%BA%90%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.6.3.</span> <span class="nav-text">可剥夺资源与不可剥夺资源的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.6.4.</span> <span class="nav-text">死锁产生的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.6.5.</span> <span class="nav-text">死锁产生的必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.6.</span> <span class="nav-text">有什么方法解决死锁问题？（处理死锁的基本方法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2%E9%9D%99%E6%80%81%E7%AD%96%E7%95%A5"><span class="nav-number">2.6.7.</span> <span class="nav-text">死锁的预防（静态策略）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D%E5%8A%A8%E6%80%81%E7%AD%96%E7%95%A5"><span class="nav-number">2.6.8.</span> <span class="nav-text">死锁的避免（动态策略）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="nav-number">2.6.8.1.</span> <span class="nav-text">什么是安全状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.6.8.2.</span> <span class="nav-text">银行家算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-number">2.6.9.</span> <span class="nav-text">死锁的检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="nav-number">2.6.9.1.</span> <span class="nav-text">死锁定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="nav-number">2.6.10.</span> <span class="nav-text">死锁的解除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">第三章 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">1、内存管理基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">内存管理的功能？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%8F%98%E4%B8%BA%E5%8F%AF%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.0.2.</span> <span class="nav-text">将用户程序变为可在内存中执行的程序的步骤？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.0.3.</span> <span class="nav-text">链接的3种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.0.4.</span> <span class="nav-text">程序装入的3种方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E5%8F%8A%E5%88%86%E9%A1%B5%E5%88%86%E6%AE%B5%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">2、内存交换及分页、分段、段页式内存分配管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6----%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text">内存空间的分配与回收----连续分配管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">动态分区分配算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">非连续分配管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.3.1.</span> <span class="nav-text">基本分页 存储管理方式的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.3.2.</span> <span class="nav-text">基本分段 存储管理方式的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.3.</span> <span class="nav-text">分段与分页的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%BF%AB%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.3.4.</span> <span class="nav-text">页式存储管理方式中设置快表的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%BF%AB%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">3.3.5.</span> <span class="nav-text">什么是页表和快表，有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.3.6.</span> <span class="nav-text">地址翻译的过程？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">3.4.</span> <span class="nav-text">3、虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85"><span class="nav-number">3.4.1.</span> <span class="nav-text">内存空间的扩充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">3.4.2.</span> <span class="nav-text">虚拟内存的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">3.4.3.</span> <span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%86%B3%E5%AE%9A%E5%BA%94%E8%AF%A5%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA%E5%93%AA%E9%A1%B5"><span class="nav-number">3.4.4.</span> <span class="nav-text">页面置换算法（决定应该换入&#x2F;换出哪页）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3opt%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">1. 最佳（OPT）置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BAfifo%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">2. 先进先出（FIFO）置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8lru%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.4.3.</span> <span class="nav-text">3. 最近最久未使用（LRU）算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9Fclock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.4.4.</span> <span class="nav-text">4. 时钟(CLOCK)置换算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8%E7%8E%B0%E8%B1%A1"><span class="nav-number">3.4.5.</span> <span class="nav-text">抖动现象</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">第四章 文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="nav-number">4.1.</span> <span class="nav-text">1、文件系统基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.1.</span> <span class="nav-text">文件的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.2.</span> <span class="nav-text">文件的组成结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">4.1.3.</span> <span class="nav-text">文件的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%92%8C%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="nav-number">4.1.4.</span> <span class="nav-text">文件的逻辑结构：顺序文件、索引文件和索引顺序文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.5.</span> <span class="nav-text">目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6"><span class="nav-number">4.1.5.1.</span> <span class="nav-text">区分文件目录，目录文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">2、文件系统实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">3、磁盘组织与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">4.3.1.</span> <span class="nav-text">磁盘调度算法有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95fcfsfirst-come-first-service"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">1. 先来先服务算法（FCFS）First Come First Service</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95sstf-shortest-seek-time-first"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">2. 最短寻道时间优先算法（SSTF） Shortest Seek Time First</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95scan%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">3. 扫描算法（SCAN）电梯调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95cscan"><span class="nav-number">4.3.1.4.</span> <span class="nav-text">4. 循环扫描算法（CSCAN）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">第五章 输入输出管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">5.1.</span> <span class="nav-text">I&#x2F;O控制方式有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F-io-%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">1. 程序 I&#x2F;O 方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.2.</span> <span class="nav-text">2. 中断驱动方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dma%E6%96%B9%E5%BC%8F%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE"><span class="nav-number">5.1.3.</span> <span class="nav-text">3. DMA方式（直接存储器访问）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dma%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">DMA控制方式与中断驱动方式的主要区别：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.4.</span> <span class="nav-text">4. I&#x2F;O通道控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#io%E9%80%9A%E9%81%93%E4%B8%8E%E4%B8%80%E8%88%AC%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">I&#x2F;O通道与一般处理机的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#io%E9%80%9A%E9%81%93%E4%B8%8Edma%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">I&#x2F;O通道与DMA控制方式的区别：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spooling%E6%8A%80%E6%9C%AF"><span class="nav-number">5.2.</span> <span class="nav-text">Spooling技术？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spooling%E6%8A%80%E6%9C%AF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">5.2.1.</span> <span class="nav-text">SPOOLing技术的特点：</span></a></li></ol></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="小张同学" src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/codedog.jpg"><p class="site-author-name" itemprop="name">小张同学</p><div class="site-description" itemprop="description">不要停止奔跑 不要回顾来路</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=709634432" title="QQ → tencent:&#x2F;&#x2F;AddContact&#x2F;?fromId&#x3D;50&amp;fromSubId&#x3D;1&amp;subcmd&#x3D;all&amp;uin&#x3D;709634432" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-qq"></i>QQ</a> </span><span class="links-of-author-item"><a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">小张同学</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">264k</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,n=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const a=new n.options.MathItem(e.textContent,n.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),a.start={node:t,delim:"",n:0},a.end={node:t,delim:"",n:0},n.math.push(a)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var i=["nick","mail","link"],e="nick,mail,link".split(",").filter(e=>i.includes(e));new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",avatar:"mm",meta:e,pageSize:"10",visitor:!1,lang:"zh-cn",path:location.pathname,recordIP:!0,serverURLs:""})},window.Valine)})</script></body></html>