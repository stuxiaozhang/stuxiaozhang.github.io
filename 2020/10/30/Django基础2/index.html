<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/favicon.png"><link rel="icon" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="2. 视图层
视图层是Django处理请求的核心代码层，它对外接收用户请求，对内调度模型层和模版层，统合数据库和前端，最后根据业务逻辑，将处理好的数据，与前端结合，返回给用户。视图层是真正的后端，是Python工程师的‘主营业务’。
Django的视图层包含下面一些主要内容：

URL路由
视图函数
快捷方式
装饰器
请求与响应
类视图
文件上传
CSV/PDF生成
内置中"><meta name="author" content="小张同学"><meta name="keywords" content=""><title>Django基础----视图层 - 小张同学的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",app_key:"CgnvRL262D07ied40NiXm2VL",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><header style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>xiaozhang's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/schedule/"><i class="iconfont icon-cliplist"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Django基础----视图层"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 小张同学 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-10-30 09:17" pubdate>2020年10月30日</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 53 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-1"></div><div class="col-lg-9 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Django基础----视图层</h1><p class="note note-info">本文最后更新于：2020年10月30日</p><div class="markdown-body"><h1 id="视图层">2. 视图层</h1><p>视图层是Django处理请求的核心代码层，它对外接收用户请求，对内调度模型层和模版层，统合数据库和前端，最后根据业务逻辑，将处理好的数据，与前端结合，返回给用户。视图层是真正的后端，是Python工程师的‘主营业务’。</p><p>Django的视图层包含下面一些主要内容：</p><ul><li>URL路由</li><li>视图函数</li><li>快捷方式</li><li>装饰器</li><li>请求与响应</li><li>类视图</li><li>文件上传</li><li>CSV/PDF生成</li><li>内置中间件</li></ul><h2 id="url路由基础">2.1 URL路由基础</h2><p>URL是Web服务的入口，用户通过浏览器发送过来的任何请求，都是发送到一个指定的URL地址，然后被响应。</p><h3 id="django如何处理请求">2.1.1 Django如何处理请求</h3><p>当用户请求一个页面时，Django根据下面的逻辑执行操作：</p><ol type="1"><li><strong>决定要使用的根URLconf模块。</strong>通常，这是<code>ROOT_URLCONF</code>设置的值，但是如果传入的HttpRequest对象具有urlconf属性（由中间件设置），则其值将被用于代替<code>ROOT_URLCONF</code>设置。也就是说你可以自定义项目入口url是哪个文件！</li><li><strong>加载该模块并寻找可用的urlpatterns。</strong> 它是<code>django.urls.path()</code>或者<code>django.urls.re_path()</code>实例的一个列表。</li><li><strong>依次匹配每个URL模式，在与请求的URL相匹配的第一个模式停下来</strong>。也就是说，url匹配是从上往下的短路操作（匹配就停），所以url在列表中的位置非常关键。</li><li>导入并调用匹配行中给定的视图，该视图是一个简单的Python函数（被称为视图函数）,或基于类的视图。 视图将获得如下参数:</li><li>一个HttpRequest 实例。</li><li>如果匹配的表达式返回了未命名的组，那么匹配的内容将作为位置参数提供给视图。</li><li>关键字参数由表达式匹配的命名组组成，但是可以被<code>django.urls.path()</code>的可选参数kwargs覆盖。</li><li>如果没有匹配到任何表达式，或者过程中抛出异常，将调用一个适当的错误处理视图。（比如403，比如无任何反应）</li></ol><p>先看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;articles/2003/&#x27;</span>, views.special_case_2003),<br>    path(<span class="hljs-string">&#x27;articles/&lt;int:year&gt;/&#x27;</span>, views.year_archive),<br>    path(<span class="hljs-string">&#x27;articles/&lt;int:year&gt;/&lt;int:month&gt;/&#x27;</span>, views.month_archive),<br>    path(<span class="hljs-string">&#x27;articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/&#x27;</span>, views.article_detail),<br>]<br></code></pre></td></tr></table></figure><p>注意：</p><ol type="1"><li>urlpatterns是个列表，每个元素都是<code>path()</code> 或 <code>re_path()</code> 的实例</li><li>要捕获一段url中的值，需要使用<strong>尖括号</strong>，而不是之前的圆括号；</li><li>可以转换捕获到的值为指定类型，比如例子中的int。默认情况下，捕获到的结果保存为字符串类型，不包含<code>/</code>这个特殊字符；</li><li>匹配模式的最开头不需要添加<code>/</code>，因为默认情况下，每个url都带一个最前面的<code>/</code>，既然大家都有的部分，就不用浪费时间特别写一个了。</li><li>每个匹配模式都建议以斜杠结尾</li></ol><h3 id="path转换器">2.1.2 path转换器</h3><p>默认情况下，Django内置下面的路径转换器：</p><ul><li><code>str</code>：匹配任何非空字符串，但不含斜杠<code>/</code>，如果你没有专门指定转换器，默认使用该转换器</li><li><code>int</code>：匹配0和正整数，返回一个int类型</li><li>...</li></ul><p>对于更复杂的匹配需求，可能需要自定义自己的path转换器。</p><p>path转换器其实就是一个类，包含下面的成员和属性：</p><ul><li>类属性<code>regex</code>：一个字符串形式的正则表达式属性；</li><li><code>to_python(self, value)</code> 方法：一个用来将匹配到的字符串转换为你想要的那个数据类型，并传递给视图函数。如果转换失败，它必须弹出ValueError异常；</li><li><code>to_url(self, value)</code>方法：将Python数据类型转换为一段url的方法，上面方法的反向操作。如果转换失败，也会弹出<code>ValueError</code>异常。</li></ul><p>例如，新建一个<code>converters.py</code>文件，与urlconf同目录，写个下面的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FourDigitYearConverter</span>:</span><br>    regex = <span class="hljs-string">&#x27;[0-9]&#123;4&#125;&#x27;</span>  <span class="hljs-comment"># 1234,5678....</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_python</span>(<span class="hljs-params">self, value</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(value)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_url</span>(<span class="hljs-params">self, value</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;%04d&#x27;</span> % value<br></code></pre></td></tr></table></figure><p>写完类后，在URLconf 中使用<code>register_converter</code>注册它，如下所示，注册了一个yyyy：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> register_converter, path<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> converters, views<br><br>register_converter(converters.FourDigitYearConverter, <span class="hljs-string">&#x27;yyyy&#x27;</span>)<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;articles/2003/&#x27;</span>, views.special_case_2003),<br>    path(<span class="hljs-string">&#x27;articles/&lt;yyyy:year&gt;/&#x27;</span>, views.year_archive),<br>    ...<br>]<br></code></pre></td></tr></table></figure><ul><li>匹配部分</li></ul><p>请求的URL被看做是一个普通的Python字符串，URLconf在其上查找并匹配。<strong>进行匹配时将不包括GET或POST请求方式的参数以及域名。</strong></p><p>例如，在<code>https://www.example.com/myapp/</code>的请求中，URLconf将查找<code>myapp/</code>。</p><p>在<code>https://www.example.com/myapp/?page=3</code>的请求中，URLconf也将查找<code>myapp/</code>。</p><p>URLconf不检查使用何种HTTP请求方法，所有请求方法POST、GET、HEAD等都将路由到同一个URL的同一个视图。在视图中，才根据具体请求方法的不同，进行不同的处理。</p><ul><li>指定视图参数的默认值</li></ul><p>有一个小技巧，我们可以指定视图参数的默认值。 下面是一个URLconf和视图的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># URLconf</span><br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;blog/&#x27;</span>, views.page),<br>    path(<span class="hljs-string">&#x27;blog/page&lt;int:num&gt;/&#x27;</span>, views.page),<br>]<br><br><span class="hljs-comment"># 视图 (blog/views.py)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">page</span>(<span class="hljs-params">request, num=<span class="hljs-number">1</span></span>):</span><br>    <span class="hljs-comment"># Output the appropriate page of blog entries, according to num.</span><br>    ...<br></code></pre></td></tr></table></figure><p>在上面的例子中，两个URL模式指向同一个视图<code>views.page</code>。但是第一个模式不会从URL中捕获任何值。 如果第一个模式匹配，page()函数将使用num参数的默认值&quot;1&quot;。 如果第二个模式匹配，page()将使用捕获的num值。</p><h2 id="路由转发">2.2 路由转发</h2><p>通常，我们会在每个app里，各自创建一个urls.py路由模块，然后从根路由出发，将app所属的url请求，全部转发到相应的urls.py模块中。</p><p>路由转发使用的是<code>include()</code>方法，需要提前导入，它的参数是转发目的地路径的字符串，路径以圆点分割。每当Django 遇到<code>include()</code>时，它会去掉URL中匹配的部分并将剩下的字符串发送给include的URLconf做进一步处理，也就是转发到<strong>二级路由</strong>去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> include, path   <br><br>urlpatterns = [<br>    <span class="hljs-comment"># ... 省略...</span><br>    path(<span class="hljs-string">&#x27;community/&#x27;</span>, include(<span class="hljs-string">&#x27;aggregator.urls&#x27;</span>)),<br>    path(<span class="hljs-string">&#x27;contact/&#x27;</span>, include(<span class="hljs-string">&#x27;contact.urls&#x27;</span>)),<br>    <span class="hljs-comment"># 比如上面这个，直接跳转道contact文件？的urls里</span><br>]<br></code></pre></td></tr></table></figure><h2 id="视图函数">2.3 视图函数</h2><p>视图函数，简称视图，本质上是一个简单的Python函数，<strong>它接受Web请求并且返回Web响应。</strong></p><p>响应的内容可以是HTML网页、重定向、404错误，XML文档或图像等任何东西。但是，无论视图本身是个什么处理逻辑，最好都返回某种响应。</p><p>视图函数的代码放在项目或应用程序目录中的名为<code>views.py</code>的文件中。</p><h3 id="简单的视图">2.3.1 简单的视图</h3><p>下面是一个返回当前日期和时间作为HTML文档的视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">current_datetime</span>(<span class="hljs-params">request</span>):</span><br>    now = datetime.datetime.now()<br>    html = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;&quot;</span> % now<br>    <span class="hljs-keyword">return</span> HttpResponse(html)<br></code></pre></td></tr></table></figure><p>让我们逐行分析一下上面的代码：</p><ul><li>首先，从<code>django.http</code>模块导入了<code>HttpResponse</code>类，以及Python的datetime库。</li><li>接着，我们定义了<code>current_datetime</code>视图函数。</li><li>每个视图函数都接收一个<code>HttpRequest</code>对象作为第一位置参数，一般取名为<code>request</code>，你可以取别的名字，但这不符合潜规则，最好不要那么做。</li><li>视图函数的名称没有强制规则，但尽量不要和Python及Django内置的各种名称重名，并且尽量精确地反映出它的功能，比如这里的<code>current_datetime</code>。</li><li>该视图返回一个<code>HttpResponse</code>对象，其中包含生成的HTML页面。</li></ul><h3 id="返回错误">2.3.2 返回错误</h3><h4 id="默认的">默认的</h4><p>HttpResponse的许多子类对应着除了200（代表“OK”）以外的一些常用的HTTP状态码。</p><p>为了标示一个错误，可以直接返回那些子类中的一个实例，而不是普通的HttpResponse。像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse, HttpResponseNotFound<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">if</span> foo:<br>        <span class="hljs-keyword">return</span> HttpResponseNotFound(<span class="hljs-string">&#x27;&lt;h1&gt;Page not found&lt;/h1&gt;&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;&lt;h1&gt;Page was found&lt;/h1&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>Django为404错误提供了一个特化的子类HttpResponseNotFound。由于一些状态码不太常用，所以不是每个状态码都有一个特化的子类。</p><h4 id="自定义错误页面">自定义错误页面</h4><p>Django有内置的HTML模版，用于返回错误页面给用户，但是这些403，404页面实在丑陋，通常我们都自定义错误页面。</p><p>首先，在根URLconf中额外增加下面的条目，并导入views模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> app <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),<br>]<br><br><span class="hljs-comment"># 增加的条目</span><br>handler400 = views.bad_request<br>handler403 = views.permission_denied<br>handler404 = views.page_not_found<br>handler500 = views.error<br></code></pre></td></tr></table></figure><p>然后在，app/views.py文件中增加四个处理视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> django.views.decorators.csrf <span class="hljs-keyword">import</span> requires_csrf_token<br><br><span class="hljs-meta">@requires_csrf_token</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bad_request</span>(<span class="hljs-params">request, exception</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;400.html&#x27;</span>)<br><br><span class="hljs-meta">@requires_csrf_token</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permission_denied</span>(<span class="hljs-params">request, exception</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;403.html&#x27;</span>)<br><br><span class="hljs-meta">@requires_csrf_token</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">page_not_found</span>(<span class="hljs-params">request, exception</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;404.html&#x27;</span>)<br><br><span class="hljs-meta">@requires_csrf_token</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;500.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再根据自己的需求，创建对应的400、403、404、500.html四个页面文件，就可以了（要注意好模板文件的引用方式，视图的放置位置等等）。</p><p><strong>只有当DEBUG设置为False时，这些错误视图才会被自动使用。DEBUG为True表示开发模式，Django会展示详细的错误信息页面，而不是针对性的错误页面。</strong></p><h3 id="内置的快捷方法">2.3.3 内置的快捷方法</h3><p>Django在<code>django.shortcuts</code>模块中，为我们提供了很多快捷方便的类和方法，它们都很重要，使用频率很高。</p><h4 id="render">render()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">render(request, template_name, context=<span class="hljs-literal">None</span>, content_type=<span class="hljs-literal">None</span>, status=<span class="hljs-literal">None</span>, using=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p><strong>结合一个给定的模板和一个给定的上下文字典，返回一个渲染后的HttpResponse对象。</strong></p><p><strong>必需参数：</strong></p><ul><li><strong>request</strong>：视图函数处理的当前请求，封装了请求头的所有数据，其实就是视图参数request。</li><li><strong>template_name</strong>：要使用的模板的完整名称或者模板名称的列表。如果是一个列表，将使用其中能够查找到的第一个模板。</li></ul><p><strong>可选参数：</strong></p><ul><li><strong>context</strong>：添加到模板上下文的一个数据字典。默认是一个空字典。可以将认可需要提供给模板的数据以字典的格式添加进去。这里有个小技巧，使用Python内置的<code>locals()</code>方法，可以方便地将函数作用域内的所有变量一次性添加进去。</li><li><strong>content_type</strong>：用于生成的文档的MIME类型。 默认为<code>DEFAULT_CONTENT_TYPE</code>设置的值，也就是<code>'text/html'</code>。</li><li><strong>status</strong>：响应的状态代码。 默认为200。</li><li><strong>using</strong>：用于加载模板使用的模板引擎的NAME。</li></ul><p><strong>范例：</strong></p><p>下面的例子将渲染模板<code>myapp/index.html</code>，MIME类型为<code>application/xhtml+xml</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># View code here...</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;myapp/index.html&#x27;</span>, &#123;<br>        <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    &#125;, content_type=<span class="hljs-string">&#x27;application/xhtml+xml&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="redirect">redirect()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">redirect(to, *args, permanent=<span class="hljs-literal">False</span>,* *kwargs)<br></code></pre></td></tr></table></figure><p><strong>根据传递进来的url参数，返回HttpResponseRedirect。</strong></p><p>参数to可以是：</p><ul><li>一个模型实例：将调用模型的<code>get_absolute_url()</code>函数，反向解析出目的url；</li><li>URL的name名称：可能带有参数：reverse()将用于反向解析url；</li><li>一个绝对的或相对的URL：将原封不动的作为重定向的目标位置。</li></ul><p>默认情况下是临时重定向，如果设置<code>permanent=True</code>将永久重定向。</p><p><strong>范例：</strong></p><p>重定向到硬编码的URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    ...<br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;/some/url/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>重定向到一个完整的URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    ...<br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;https://www.liujiangblog.com/&#x27;</span>)<br><br><span class="hljs-comment">#或者</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    ...<br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;/some/url/&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="get_object_or_404">get_object_or_404()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">get_object_or_404(klass, *args,* *kwargs)<br></code></pre></td></tr></table></figure><p>这个方法，非常有用，一定熟记。</p><p><strong>常用于查询某个对象，找到了则进行下一步处理，如果未找到则给用户返回404页面。</strong></p><p>在后台，Django其实是调用了模型管理器的get()方法，只会返回一个对象。不同的是，如果get()发生异常，会引发Http404异常，从而返回404页面，而不是模型的DoesNotExist异常。</p><p><strong>必需参数</strong>：</p><ul><li><code>class</code>：要获取的对象的Model类名或者Queryset等；</li><li><code>**kwargs</code>:查询的参数，格式应该可以被get()接受。</li></ul><p><strong>范例：</strong></p><p>1.从MyModel中使用主键1来获取对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> get_object_or_404<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    obj = get_object_or_404(MyModel, pk=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这个示例等同于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> Http404<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        obj = MyModel.objects.get(pk=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">except</span> MyModel.DoesNotExist:<br>        <span class="hljs-keyword">raise</span> Http404(<span class="hljs-string">&quot;No MyModel matches the given query.&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="httprequest对象">2.4 HttpRequest对象</h2><p>每当一个用户请求发送过来，Django将HTTP数据包中的相关内容，打包成为一个HttpRequest对象，并传递给视图函数作为第一位置参数，也就是request，供我们调用。</p><p>所有的请求和响应对象都位于<code>django.http</code>模块内。</p><h4 id="httprequest.method">HttpRequest.method</h4><p>字符串类型，表示请求使用的HTTP方法。默认为大写。 像这样：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">request.method</span> == <span class="hljs-string">&#x27;GET&#x27;</span>:<br>    <span class="hljs-function"><span class="hljs-title">do_something</span>()</span><br><span class="hljs-variable">elif</span> <span class="hljs-variable">request.method</span> == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>    <span class="hljs-function"><span class="hljs-title">do_something_else</span>()</span><br></code></pre></td></tr></table></figure><p>通过这个属性来判断请求的方法，然后根据请求的方法不同，在视图中执行不同的代码。</p><h4 id="httprequest.session">HttpRequest.session</h4><p>来自<code>SessionMiddleware</code>中间件：一个可读写的，类似字典的对象，表示当前会话。我们要保存用户状态，回话过程等等，靠的就是这个中间件和这个属性。</p><h4 id="httprequest.user">HttpRequest.user</h4><p>来自<code>AuthenticationMiddleware</code>中间件：表示当前登录的用户的<code>AUTH_USER_MODEL</code>的实例，这个模型是Django内置的Auth模块下的User模型。如果用户当前未登录，则user将被设置为<code>AnonymousUser</code>的实例。</p><p>可以使用<code>is_authenticated</code>方法判断当前用户是否合法用户，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> request.user.is_authenticated:<br>    ... <span class="hljs-comment"># Do something for logged-in users.</span><br><span class="hljs-keyword">else</span>:<br>    ... <span class="hljs-comment"># Do something for anonymous users.</span><br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/138">其他的......</a></p><h2 id="httpresponse对象">2.5 HttpResponse对象</h2><p>HttpResponse类定义在django.http模块中。</p><p>HttpRequest对象是浏览器发送过来的请求数据的封装</p><p>HttpResponse对象则是你想要返回给浏览器的数据的封装。</p><p>HttpRequest对象由Django自动解析HTTP数据包而创建</p><p>而HttpResponse对象则由程序员手动创建。</p><p>我们编写的每个视图都要实例化、填充和返回一个HttpResponse对象。也就是函数的return值。</p><h4 id="content">content</h4><p>响应的内容。bytes类型。</p><h4 id="status_code">status_code</h4><p>响应的状态码，比如200。</p><p><a target="_blank" rel="noopener" href="https://www.liujiangblog.com/course/django/140">剩下的......</a></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Python/">Python</a> <a class="hover-with-bg" href="/tags/Django/">Django</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处来源：<a href="https://stuxiaozhang.github.io/">小张的宇宙空间站</a></p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/11/01/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">爬虫基础</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/10/28/Django%E5%9F%BA%E7%A1%80/"><span class="hidden-mobile">Django基础----模型层</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",function(){var e=Object.assign({appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:"https://cdn.bootcdn.net/ajax/libs/emojione/4.5.0/lib/js/emojione.min.js",emojiMaps:null,enableQQ:!0,requiredFields:["nick"]},{el:"#valine",path:window.location.pathname});new Valine(e)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://stuxiaozhang.github.io" target="_blank" rel="nofollow noopener"><span>小张同学的宇宙空间站</span></a> 已经运转了<span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{renderActions:{findScript:[10,a=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const n=new a.options.MathItem(e.textContent,a.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),n.start={node:t,delim:"",n:0},n.end={node:t,delim:"",n:0},a.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>