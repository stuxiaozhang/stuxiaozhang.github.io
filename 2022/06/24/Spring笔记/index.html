<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><link rel="icon" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="Spring笔记
一、什么是Spring？
1、介绍
Spring它是一个容器，也是一个框架，它是整合其它框架的框架。Spring看到其他什么框架好用，它就会把它整合进来，比如MyBatis框架就被Spring看上了，然后就整合进Spring里面。
Spring的核心是 控制反转IOC 和 面向切面编程AOP。它由20多个模块构成，它在很多领域都提供优秀的解决方案。
Spring 根据代"><meta name="author" content="小张同学"><meta name="keywords" content=""><title>Spring笔记 - 小张同学的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",app_key:"CgnvRL262D07ied40NiXm2VL",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><header style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>xiaozhang's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/schedule/"><i class="iconfont icon-cliplist"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150632.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Spring笔记"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 小张同学 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-06-24 19:57" pubdate>2022年6月24日</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 102 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-1"></div><div class="col-lg-9 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Spring笔记</h1><p class="note note-info">本文最后更新于：2022年6月27日</p><div class="markdown-body"><h1 id="spring笔记">Spring笔记</h1><h2 id="一什么是spring">一、什么是Spring？</h2><h3 id="介绍">1、介绍</h3><p>Spring它是一个容器，也是一个框架，它是整合其它框架的框架。Spring看到其他什么框架好用，它就会把它整合进来，比如MyBatis框架就被Spring看上了，然后就整合进Spring里面。</p><p>Spring的核心是 <strong>控制反转IOC</strong> 和 <strong>面向切面编程AOP。</strong>它由20多个模块构成，它在很多领域都提供优秀的解决方案。</p><p>Spring 根据代码的功能特点，使用 Ioc 降低业务对象之间耦合度。IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”，注入即赋值。 而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”。</p><h3 id="spring的特点">2、Spring的特点</h3><ol type="1"><li><p>轻量级 由20多个模块构成，每个模块jar包都很小，小于1M，Spring核心包也就3M左右。 编写代码比较自由，不用像MyBatis那样一定要写什么什么配置文件。</p></li><li><p>面向接口编程 使用接口，就是面向灵活，项目的可扩展性好，可维护性都极高。接口不关心实现类的类型。使用时接口指向实现类，只要切换实现类即可切换整个功能。</p></li><li><p>AOP：面向切面编程 就是将公共的，通用的，重复的代码单独开发在一个切面中，在需要的时候再从切面中反织回去。底层的原理是动态代理。</p></li><li><p>整合其它框架</p><p>它整合后使其它框架更易用，比如整合了MyBatis框架</p></li></ol><h2 id="二控制反转ioc">二、控制反转IOC</h2><h3 id="什么是iocinversion-of-control">1、什么是IOC（Inversion of Control）</h3><p>控制反转IOC（Inversion of Control）是一个概念，是一种思想。由Spring容器进行对象的创建和依赖注入.程序员在使用时直接取出使用。<strong>由容器集中进行对象和创建和依赖管理。</strong></p><p>Spring 根据代码的功能特点，使用 Ioc 降低业务对象之间耦合度。IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”,注入即赋值。</p><p><strong>正转</strong>：由程序员进行对象的创建和依赖注入称为正转.程序员说了算.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Student stu = <span class="hljs-keyword">new</span> Student();  ===&gt; 程序员自己创建对象<br>stu.setName(<span class="hljs-string">&quot;张三&quot;</span>);      ===&gt; 程序员自己进行赋值（依赖注入）<br>stu.setAge(<span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure><p><strong>反转</strong>：由Spring容器进行创建对象和依赖注入称为反转，将控制权从程序员手中夺走，由Spring容器进行控制，称为反转。 容器说了算.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.pojo.Student&quot;</span>&gt;</span>   ===&gt; Spring容器负责对象的创建<br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span>           ===&gt; Spring容器依赖注入值<br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="基于xml的ioc">2、基于xml的IOC</h3><p>对象的创建和注入依赖都在 <code>applicationContext.xml</code> 文件中的指定设置好。创建Spring容器的时候指明这个xml文件，Spring就会自动创建这个xml文件的对象并且注入好值。</p><p>基于xml的IOC：</p><ol type="1"><li>创建对象 和 依赖注入，交给Spring容器管理完成</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.pojo.Student&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>id：就是指明创建对象的名称</li><li>class：就是对象对应的全类名，Spring底层会通过反射创建对象（只能是类，不能是接口）</li></ul><ol start="2" type="1"><li><p>当启动Spring容器的时候：</p><ol type="1"><li><p>默认就会调用无参构造器创建此xml文件中的所有对象,所以<strong>必须提供无参构造器。</strong></p></li><li><p>相当于 <code>Student stu = new Student();</code></p></li></ol></li><li>同时会给创建的对象赋值<ol type="1"><li><strong>使用setter注入依赖</strong></li><li><strong>使用构造器注入依赖</strong></li></ol></li></ol><h4 id="使用setter注入依赖">1. 使用setter注入依赖</h4><p>第一种：注入基本数据类型，使用 value 属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二种：注入引用数据类型的数据，使用 ref 属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;school&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;school&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此引用数据类型必须在此配置文件.xml种配置过bean，在此文件中的bean实例对象。</p><p><strong>注意：使用setter注入必须提供无参的构造方法 和 <code>setXXX()</code> 方法。</strong></p><h4 id="使用构造器注入依赖">2. 使用构造器注入依赖</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure><ol type="1"><li>使用构造方法的参数名称进行注入值</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;school&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.pojo3.School&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;清华大学&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;海淀区&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用构造方法参数的下标注入值</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.pojo3.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;钱七&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;school&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>使用默认的构造方法的参数的<u>顺序</u>注入值</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuSequence&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.pojo3.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;陈十&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;school&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="基于注解的ioc">3、基于注解的IOC</h3><p>也称为DI(Dependency Injection)，它是IOC的具体实现的技术.</p><p><strong>基于注解的IOC,必须要在Spring的核心配置文件中添加包扫描.</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">“com.bjpowernode.s01”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>药: 创建对象并依赖注入</li><li>汤: xml 注解annotation</li></ul><blockquote><p>换汤不换药~</p></blockquote><h4 id="创建对象的注解">1. 创建对象的注解</h4><ul><li><code>@Component</code>:可以创建任意对象.创建的对象的默认名称是类名的驼峰命名法.也可以指定对象的名称 <code>@Component(“指定名称”)</code></li><li><code>@Controller</code>:专门用来创建控制器的对象(Servlet),这种对象可以接收用户的请求,可以返回处理结果给客户端.</li><li><code>@Service</code>:专门用来创建业务逻辑层的对象,负责向下访问数据访问层,处理完毕后的结果返回给界面层.</li><li><code>@Repository</code>:专门用来创建数据访问层的对象,负责数据库中的增删改查所有操作.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">案例:<br><span class="hljs-meta">@Component(&quot;stu&quot;)</span>  <span class="hljs-comment">// 交给Spring去创建对象,就是在容器启动时创建</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;张三&quot;)</span>  ===&gt; 简单类型的值注入<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-meta">@Value(&quot;22&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖注入的注解">2. 依赖注入的注解</h4><h5 id="简单类型8种基本类型string的注入">简单类型(8种基本类型+String)的注入</h5><ul><li><code>@Value</code>：用来给简单类型注入值</li></ul><h5 id="引用类型的注入">引用类型的注入</h5><ol type="1"><li><p><code>@Autowired</code>:使用<u>类型</u>注入值,从整个Bean工厂中搜索同源类型的对象进行注入. 同源类型也可注入.</p><p>什么是同源类型:</p><ol type="1"><li>被注入的类型(Student中的school)与注入的类型是<u>完全相同的类型</u><br></li><li>被注入的类型(Student中的school：父)与注入的类型(子)是<u>父子类</u><br></li><li>被注入的类型(Student中的school接口)与注入的类型(实现类)是<u>接口和实现类的类型</u></li></ol></li></ol><p>注意：在有父子类的情况下,使用按类型注入,就意味着有多个可注入的对象.此时按照名称进行二次筛选,选中<strong>与被注入对象相同名称的对象进行注入</strong></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220620103521.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220620103434.png" srcset="/img/loading.gif" lazyload></p><ol start="2" type="1"><li><code>@Autowired</code></li></ol><p><code>@Qualifier(&quot;名称&quot;)</code>：使用<u>名称</u>注入值,从整个Bean工厂中搜索相同名称的对象进行注入.</p><p><strong>注意:如果有父子类的情况下,直接按名称进行注入值.</strong></p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建School对象</span><br><span class="hljs-meta">@Component(&quot;schoolNew&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">School</span> </span>&#123;<br>    <span class="hljs-comment">// 简单类型的数据注入</span><br>    <span class="hljs-meta">@Value(&quot;清华大学&quot;)</span><br>    <span class="hljs-keyword">private</span> String schoolName;<br>    <span class="hljs-meta">@Value(&quot;北京&quot;)</span><br>    <span class="hljs-keyword">private</span> String address;<br>    ...<br>&#125;<br>    <br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;测试&quot;)</span><br>    <span class="hljs-keyword">private</span> String stuName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 引用数据类型的数据注入采用 @Autowired和@Qualifier(&quot;名称&quot;)注解</span><br><span class="hljs-comment">     * Spring会自动去bean工厂中找@Qualifier(&quot;名称&quot;)指定名称的对象进行注入，赋值给school引用</span><br><span class="hljs-comment">     * 我们已经使用注解创建了School对象。</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;schoolNew&quot;)</span><br>    <span class="hljs-keyword">private</span> School school;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220620104852.png" srcset="/img/loading.gif" lazyload></p><h4 id="添加包扫描的方式">添加包扫描的方式</h4><p>1)单个包扫描(推荐使用)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.service.impl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2)多个包扫描,多个包之间以逗号或空格或分号分隔</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller com.bjpowernode.service ,com.bjpowernode.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3)扫描根包(不推荐)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>会降低容器启动的速度,导致多做无用功.</p><h2 id="三三层架构项目的分析">三、三层架构项目的分析</h2><blockquote><p>界面层view和controller</p><p>业务逻辑层service</p><p>数据持久层bean和dao/mapper</p></blockquote><p><strong>controller 调用业务逻辑层，业务逻辑层调用数据访问层，数据访问层插入数据到数据库中</strong></p><h3 id="普通的三层项目">1、 普通的三层项目</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数据访问层的实现类</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users u)</span> </span>&#123;<br>        System.out.println(u.getUname() + <span class="hljs-string">&quot;用户增加成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 业务逻辑层的实现类</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersService</span> </span>&#123;<br><br>    <span class="hljs-comment">// 切记：在所有的业务逻辑层中都必定有数据访问层的对象！</span><br>    <span class="hljs-keyword">private</span> UsersMapper usersMapper = <span class="hljs-keyword">new</span> UsersMapperImpl();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-comment">// 调用数据持久层将注册的信息插入到底层数据库</span><br>        <span class="hljs-keyword">return</span> usersMapper.insert(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之界面层的controller</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersController</span> </span>&#123;<br><br>    <span class="hljs-comment">// 如何去访问业务逻辑层？ 就是创建对象</span><br>    <span class="hljs-comment">// 切记：所有的界面层都会有业务逻辑层的对象</span><br>    <span class="hljs-keyword">public</span> UsersService usersService = <span class="hljs-keyword">new</span> UsersServiceImpl();<br><br>    <span class="hljs-comment">// 界面层的功能实现，对外提供访问的功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> usersService.insert(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于xml的ioc三层架构项目spring接管对象">2、基于xml的IOC三层架构项目（Spring接管对象）</h3><p>由Spring管理三层架构项目中的对象创建，包含界面层、业务逻辑层和数据访问层的对象创建。要创建的对象以及依赖信息在 <code>applicationContext.xml</code> 文件中配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之数据访问层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users u)</span> </span>&#123;<br>        System.out.println(u.getUname() + <span class="hljs-string">&quot;用户增加成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之业务逻辑层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersService</span></span>&#123;<br> <br>    <span class="hljs-comment">// 这个数据访问层的对象userMapper交给Spring创建了,因此这个依赖也交给Spring注入(需要提供setXXX方法)</span><br>    <span class="hljs-comment">// private UserMapper userMapper = new UserMapperImpl();</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br> <br>    <span class="hljs-comment">// 交给Spring去依赖注入值，必须提供无参构造方法和setXXX()方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserMapper</span><span class="hljs-params">(UserMapper userMapper)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userMapper = userMapper;<br>    &#125;<br><br>	<span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-comment">// 调用数据持久层将注册的信息插入到底层数据库</span><br>        <span class="hljs-keyword">return</span> usersMapper.insert(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之界面层的controller</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 面向接口编程</span><br>    <span class="hljs-comment">// 这个业务逻辑层的对象userService交给Spring创建了,因此这个依赖也交给Spring注入(需要提供setXXX方法)</span><br>    <span class="hljs-comment">// private UserService userService = new UserServiceImpl();</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserService</span><span class="hljs-params">(UserService userService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userService = userService;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 界面层的功能实现，对外提供访问的功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> usersService.insert(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>applicationContext.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建项目中需要的各种对象--&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建数据访问层的对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.mapper.UsersMapperImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建业务逻辑层的对象，实现类对象赋给接口引用（多态）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.service.impl.UsersServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usersMapper&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;uMapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建界面层的对象--&gt;</span><br>    <span class="hljs-comment">&lt;!--创建界面层的对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersController&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usersService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;uService&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建Spring容器对象同时启动容器,创建里面的所有对象</span><br>    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>    <span class="hljs-comment">// 从Spring容器中获取界面控制层的userController对象</span><br>    UserServlet uerController = (UserServlet) ac.getBean(<span class="hljs-string">&quot;uerController&quot;</span>);<br>    <br>    <span class="hljs-comment">// 测试功能</span><br>    <span class="hljs-keyword">int</span> num = usersController.insert(<span class="hljs-keyword">new</span> Users(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">12</span>));<br>    System.out.println(num);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于注解的ioc三层架构项目spring接管对象">3、基于注解的IOC三层架构项目（Spring接管对象）</h3><p>由Spring管理三层架构项目中的对象创建，包含界面层、业务逻辑层和数据访问层的对象创建。要创建的对象以及依赖信息都直接使用注解配置即可。</p><p>Note：<strong>基于注解的IOC,必须要在Spring的核心配置文件中添加包扫描.</strong></p><ul><li><code>@Component</code>:可以创建任意对象.创建的对象的默认名称是类名的驼峰命名法.也可以指定对象的名称 <code>@Component(“指定名称”)</code></li><li><code>@Controller</code>:专门用来创建控制器的对象(Servlet),这种对象可以接收用户的请求,可以返回处理结果给客户端.</li><li><code>@Service</code>:专门用来创建业务逻辑层的对象,负责向下访问数据访问层,处理完毕后的结果返回给界面层.</li><li><code>@Repository</code>:专门用来创建数据访问层的对象,负责数据库中的增删改查所有操作.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之数据访问层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Repository</span> <span class="hljs-comment">// 此注解说明交给Spring用来创建数据访问层的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersMapper</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users u)</span> </span>&#123;<br>        System.out.println(u.getUname() + <span class="hljs-string">&quot;用户增加成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsersMapperImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UsersMapperImpl的无参构造方法。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之业务逻辑层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span> <span class="hljs-comment">// 此注解说明交给Spring来专门创建Service业务逻辑层的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 依赖注入也交给Spring</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>	<span class="hljs-comment">// private UserMapper userMapper = new UserMapperImpl();</span><br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-comment">// 调用数据持久层将注册的信息插入到底层数据库</span><br>        <span class="hljs-keyword">return</span> usersMapper.insert(users);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsersServiceImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UsersServiceImpl的无参构造方法。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之界面层的controller</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Controller</span> <span class="hljs-comment">// 此注解说明交给Spring专门用来创建界面层之控制层的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersController</span> </span>&#123;<br>    <span class="hljs-comment">// 面向接口编程</span><br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>	<span class="hljs-comment">// private UserService userService = new UserServiceImpl();</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> usersService.insert(users);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsersController</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UsersController的无参构造方法。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--指明要Spring扫描的包--&gt;</span><br>    <span class="hljs-comment">&lt;!--只要是基于注解开发，必须包扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建并启动容器</span><br>    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    <span class="hljs-comment">// 取出对象</span><br>    UsersController usersController = (UsersController) ac.getBean(<span class="hljs-string">&quot;usersController&quot;</span>);<br>    <br>    usersController.insert(<span class="hljs-keyword">new</span> Users(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;haha&quot;</span>, <span class="hljs-number">23</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220620115551.png" srcset="/img/loading.gif" lazyload></p><h2 id="四添加包扫描的方式">四、添加包扫描的方式</h2><ol type="1"><li>单个包扫描(推荐使用)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.service.impl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>多个包扫描,多个包之间以逗号或空格或分号分隔</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller com.bjpowernode.service ,com.bjpowernode.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>扫描根包(不推荐)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​ 会降低容器启动的速度,导致多做无用功.</p><h2 id="五为应用指定多个-spring-配置文件">五、为应用指定多个 Spring 配置文件</h2><p>当项目越来越大,需要多人合作开发,一个配置就存在很大隐患.</p><ol type="1"><li>拆分配置文件的策略</li></ol><p>按层拆</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">applicationContext_controller.xml<br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersController&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookController&quot;</span>&gt;</span><br>applicationContext_service.xml<br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersService&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookService&quot;</span>&gt;</span><br>applicationContext_mapper.xml<br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersMapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookMapper&quot;</span>&gt;</span>    <br></code></pre></td></tr></table></figure><p>按功能拆</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">applicationContext_users.xml        <br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersController&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersService&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersMapper&quot;</span>&gt;</span><br>applicationContext_book.xml      <br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookController&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookService&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookMapper&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="六spring-配置文件的整合">六、Spring 配置文件的整合</h2><ol type="1"><li>单个文件导入</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.mapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.service&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>批量导入</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext_*.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="七面向切面编程aop">七、面向切面编程AOP</h2><p>AOP（Aspect Orient Programming），面向切面编程。</p><p>切面：公共的，通用的，重复的功能称为切面，面向切面编程就是将切面提取出来，单独开发，在需要调用的方法中通过动态代理的方式进行织入。</p><h3 id="手写aop框架">1、手写AOP框架</h3><p>业务：图书购买业务</p><p><strong>切面：事务</strong></p><ol type="1"><li><p>第一个版本：业务和切面紧耦合在一起,没有拆分.</p></li><li><p>第二个版本：使用子类代理的方式拆分业务和切面.</p></li><li><p>第三个版本：使用静态代理拆分业务和切面.业务和业务接口已拆分.此时切面紧耦合在业务中.</p><blockquote><p>静态代理：同样的业务接口，目标对象实现业务接口，代理对象和目标对象实现同一个业务接口）</p></blockquote></li><li>第四个版本：使用静态代理拆分业务和业务接口,切面和切面接口.</li><li><p>第五个版本：使用动态代理完成第四个版本的优化.</p></li></ol><h4 id="第一个版本业务和切面紧耦合在一起没有拆分.">第一个版本：业务和切面紧耦合在一起,没有拆分.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy1;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 图书购买业务和事务切面耦合在一起</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;事务开启......&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;图书购买业务功能实现......&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;事务提交......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;事务回滚......&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二个版本使用子类代理的方式拆分业务和切面.">第二个版本：使用子类代理的方式拆分业务和切面.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy2;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用子类代理的方式进行图书业务和事务切面的拆分</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> </span>&#123;<br>    <span class="hljs-comment">// 在父类中只有干干净净的任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;图书购买功能实现......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy2;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  子类就是代理类，将父类的图书购买功能添加业务切面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubBookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceImpl</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 事务切面</span><br>            System.out.println(<span class="hljs-string">&quot;事务开启......&quot;</span>);<br>            <span class="hljs-comment">// 主业务实现</span><br>            <span class="hljs-keyword">super</span>.buy();<br>            <span class="hljs-comment">// 事务切面</span><br>            System.out.println(<span class="hljs-string">&quot;事务提交......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;事务回滚......&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三个版本使用静态代理拆分业务和切面.业务和业务接口已拆分.此时切面紧耦合在业务中.">第三个版本：使用静态代理拆分业务和切面.业务和业务接口已拆分.此时切面紧耦合在业务中.</h4><p>静态代理：同样的业务接口，目标对象实现业务接口，代理对象和目标对象实现同一个业务接口）</p><p><em>Service.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy3;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-comment">// 规定业务功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>BookServiceImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy3;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  目标对象：业务功能的具体实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Service</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;图书购买业务功能实现......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>ProductServiceImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy3;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  目标对象：业务功能的具体实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Service</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;商品购买业务功能实现......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>Agent.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy3;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  静态代理实现了目标对象的灵活切换</span><br><span class="hljs-comment"> *  图书购买业务，商品购买业务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-comment">// 类中的成员变量的类型设计为接口，为了灵活切换目标对象</span><br>    <span class="hljs-keyword">public</span> Service service;<br><br>    <span class="hljs-comment">// 使用构造方法传入目标对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Agent</span><span class="hljs-params">(Service service)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.service = service;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 事务切面</span><br>            System.out.println(<span class="hljs-string">&quot;事务开启......&quot;</span>);<br>            <span class="hljs-comment">// 主业务实现</span><br>            service.buy();<br>            <span class="hljs-comment">// 事务切面</span><br>            System.out.println(<span class="hljs-string">&quot;事务提交......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第四个版本使用静态代理拆分业务和业务接口切面和切面接口.">第四个版本：使用静态代理拆分业务和业务接口,切面和切面接口.</h4><p><em>AOP.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy4;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AOP</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接口默认方法：关键字default默认方法在接口的实现类中，不强制重写，但是也可以被重写，而且在接口中，这个默认方法可以有方法体内容.....</span><br><span class="hljs-comment">     * 如果实现类没有重新默认方法，但是会继承这个默认方法</span><br><span class="hljs-comment">     * 所以创建实现类对象后，可以调用默认方法。跟继承一样，如果实现类没有重写，那就调用的是接口中的方法体</span><br><span class="hljs-comment">     */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>LogAOP.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy4;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAOP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AOP</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置日志输出......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>TransAOP.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy4;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransAOP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AOP</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;事务开启......&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;事务提交......&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exception</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;事务回滚......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>Agent.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy4;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Service</span> </span>&#123;<br><br>    <span class="hljs-comment">// 传入目标（业务）对象，切面对象</span><br>    Service target;<br>    AOP aop;<br><br>    <span class="hljs-comment">// 使用构造方法初始化业务对象和切面对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Agent</span><span class="hljs-params">(Service target, AOP aop)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>        <span class="hljs-keyword">this</span>.aop = aop;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 切面</span><br>            aop.before();  <span class="hljs-comment">// 事务  日志</span><br>            <span class="hljs-comment">// 业务</span><br>            target.buy();  <span class="hljs-comment">// 图书  商品</span><br>            <span class="hljs-comment">// 切面</span><br>            aop.after();  <span class="hljs-comment">// 事务</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 切面</span><br>            aop.exception();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220624165919.png" srcset="/img/loading.gif" lazyload></p><h4 id="第五个版本使用动态代理完成第四个版本的优化.">第五个版本：使用动态代理完成第四个版本的优化.</h4><p><em>ProxyFactory.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy5;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getAgent</span><span class="hljs-params">(Service service, AOP aop)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回的是生成的动态代理对象</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>                <span class="hljs-comment">// 类加载器</span><br>                service.getClass().getClassLoader(),<br>                <span class="hljs-comment">// 目标对象实现的所有的接口</span><br>                service.getClass().getInterfaces(),<br>                <span class="hljs-comment">// 代理功能实现</span><br>                <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-comment">//               生成的代理对象，正在被调用的目标方法buy() show()  ，目标方法的参数</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                        Object obj = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 切面</span><br>                            aop.before();<br>                            <span class="hljs-comment">// 业务</span><br>                            obj = method.invoke(service, args);<br>                            <span class="hljs-comment">// 切面</span><br>                            aop.after();<br>                        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                            aop.exception();<br>                        &#125;<br><br>                        <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// 目标方法的返回值</span><br>                    &#125;<br>                &#125;<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220624170553.png" srcset="/img/loading.gif" lazyload></p><h3 id="spring支持的aop的实现">2、Spring支持的AOP的实现</h3><p>Spring支持AOP的编程，常用的有以下几种：</p><ol type="1"><li>Before通知：在目标方法被调用前调用，涉及接口org.springframework.aop.MethodBeforeAdvice;</li><li>After通知：在目标方法被调用后调用，涉及接口为org.springframework.aop.AfterReturningAdvice;</li><li>Throws通知：目标方法抛出异常时调用，涉及接口org.springframework.aop.ThrowsAdvice;</li><li>Around通知：拦截对目标对象方法调用，涉及接口为org.aopalliance.intercept.MethodInterceptor。</li></ol><h3 id="aop常用的术语">3、AOP常用的术语</h3><ol type="1"><li>切面：就是那些重复的，公共的，通用的功能称为切面，例如：日志,事务,权限.</li><li>连接点：就是目标方法。因为在目标方法中要实现目标方法的功能和切面功能.</li><li>切入点(Pointcut)：指定切入的位置，多个连接点构成切入点。切入点可以是一个目标方法，可以是一个类中的所有方法，可以是某个包下的所有类中的方法。</li><li>目标对象：操作谁，谁就是目标对象。</li><li>通知(Advice)：来指定切入的时机。是在目标方法执行前还是执行后还是出错时，还是环绕目标方法切入切面功能.</li></ol><h2 id="八aspectj-基于注解的-aop-实现">八、AspectJ 基于注解的 AOP 实现</h2><p>AspectJ 是一个优秀面向切面的框架，它扩展了 Java 语言，提供了强大的切面实现。它因为是基于java语言开发的,所以无缝扩展。</p><h3 id="aspectj常见通知类型">1、AspectJ常见通知类型</h3><p>AspectJ 中常用的通知有四种类型：</p><ol type="1"><li>前置通知@Before</li><li>后置通知@AfterReturning</li><li>环绕通知@Around</li><li>最终通知@After</li><li>定义切入点@Pointcut(了解)</li></ol><h3 id="aspectj-的切入点表达式掌握">2、AspectJ 的切入点表达式(掌握)</h3><ul><li><p>规范的公式:</p><p><code>execution(访问权限 方法返回值 方法声明(参数) 异常类型)</code></p><p>访问权限和异常类型可省略，但是方法返回值和方法声明(参数)是不可省略的</p></li><li><p>简化后的公式:</p><p><code>execution(方法返回值 方法声明(参数) )</code></p></li><li><p>用到的符号:</p><p><code>*</code>： 代表任意个任意的字符(通配符) <code>..</code>： 如果出现在方法的参数中,则代表任意参数；如果出现在路径中,则代表本路径及其所有的子路径</p></li></ul><h4 id="示例">示例</h4><ul><li><code>execution(public * *(..))</code>：任意的公共方法</li><li><code>execution(* set*(..))</code>：任何一个以“set”开始的方法</li><li><code>execution(* com.xyz.service.impl.*.*(..))</code>：任意的返回值类型，在 <code>com.xyz.service.impl</code> 包下的任意类的任意方法的任意参数</li><li><code>execution(* com.xyz.service..*.*(..))</code>：任意的返回值类型，在 <code>com.xyz.service</code> <u>及其子包下的</u>任意类的任意方法的任意参数 。比如可以是：<code>com.xyz.service.a.b.*.*(..)</code>， <code>com.xyz.service.*.*(..)</code></li><li><code>execution(* *..service.*.*(..))</code>：service之前可以有任意的子包</li><li><code>execution(* *.service.*.*(..))</code>：service之前只有一个包</li></ul><h3 id="aspectj-的前置通知-before">3、AspectJ 的前置通知 <span class="citation" data-cites="Before">@Before</span></h3><p><strong>前置通知在目标方法执行前切入切面功能。</strong>在切面方法中不可以获得目标方法的返回值，只能通过<strong>JoinPoint类型</strong>得到目标方法的签名（即访问权限，返回值，方法名以及参数，这些叫做目标方法的签名）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(value = &quot;execution( * com.bjpowernode.s01.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">(JoinPoint jp)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;目标方法的签名:&quot;</span>+jp.getSignature());<br>        System.out.println(<span class="hljs-string">&quot;目标方法的参数:&quot;</span>+ Arrays.toString(jp.getArgs()));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="前置通知的切面方法的规范">前置通知的切面方法的规范</h4><ol type="1"><li><p>访问权限是public</p></li><li><p>方法的返回值是void</p></li><li><p>方法名称自定义</p></li><li><p>方法没有参数,如果有也只能是JoinPoint类型</p></li><li><p>必须使用@Before注解来声明切入的时机是前切功能 和 切入点</p><p>参数：value 指定切入点表达式</p></li></ol><h4 id="实现的步骤">实现的步骤：</h4><ol type="1"><li>创建业务接口</li><li>创建业务实现</li><li>创建切面类，实现切面方法</li><li>在applicationContext.xml文件中绑定业务和切面</li></ol><h4 id="创建业务接口">1. 创建业务接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义各种业务功能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SomeService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showName</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建业务实现类">2. 创建业务实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 具体业务实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SomeService</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showName</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;showName方法执行&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建切面类实现切面方法">3. 创建切面类，实现切面方法</h4><p>所有切面的功能都是由切面方法来实现的，可以将各种切面都在此类中进行开发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 指明这是一个切面，交给AspectJ框架管理，扫描到这个注解就会知道这个是一个切面类然后进行切面的操作</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 创建切面对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br><br>    <span class="hljs-comment">// 前置通知，在目标方法执行之前执行。</span><br>    <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 切面方法，前置通知</span><br><span class="hljs-comment">     * 1)访问权限是public</span><br><span class="hljs-comment">     * 2)方法的返回值是void</span><br><span class="hljs-comment">     * 3)方法名称自定义</span><br><span class="hljs-comment">     * 4)方法没有参数,如果有也只能是JoinPoint类型</span><br><span class="hljs-comment">     * 5)必须使用<span class="hljs-doctag">@Before</span>注解来声明切入的时机是前置通知和切入点</span><br><span class="hljs-comment">     *   参数:value  指定切入点表达式，</span><br><span class="hljs-comment">     *   这里是切入点就是一个连接点com.lin.aspectj1.UserServiceImpl.showName（方法名）</span><br><span class="hljs-comment">     *   在此showName方法执行前执行这个前置通知。</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">// 业务方法</span><br>    <span class="hljs-comment">// public String showName(String name, int age)</span><br>    <span class="hljs-meta">@Before(value  = &quot;execution(public String com.bjpowernode.s01.SomeServiceImpl.*(String,int))&quot;)</span> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Before(value = &quot;execution(public * com.bjpowernode.s01.SomeServiceImpl.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Before(value = &quot;execution( * com.bjpowernode.s01.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">(JoinPoint jp)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;目标方法的签名:&quot;</span>+jp.getSignature());<br>        System.out.println(<span class="hljs-string">&quot;目标方法的参数:&quot;</span>+ Arrays.toString(jp.getArgs()));<br>    &#125;<br>    <br>    <span class="hljs-meta">@Before(value = &quot;execution( * com.bjpowernode.s01..*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Before(value = &quot;execution( * *(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在applicationcontext.xml文件中绑定业务和切面">4. 在applicationContext.xml文件中绑定业务和切面</h4><h2 id="section"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建业务对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lin.aspectj.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--创建切面对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;LogAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lin.aspectj.LogAspect&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>	<span class="hljs-comment">&lt;!--绑定--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></h2><h4 id="关于aspectj框架切换jdk动态代理和cglib动态代理">关于AspectJ框架切换JDK动态代理和CGLib动态代理</h4><p><code>&lt;aop:aspectj-autoproxy &gt;&lt;/aop:aspectj-autoproxy&gt;</code> 默认是JDK动态代理,取时必须使用接口类型</p><p><code>&lt;aop:aspectj-autoproxy proxy-target-class=“true”&gt;&lt;/aop:aspectj-autoproxy&gt;</code>设置为CGLib子类代理,可以使用接口和实现类接</p><p>记住：使用接口来接,永远不出错.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">当业务实现类没有父接口时，可以使用CGLib子类代理，然后用实现类接代理对象。<br>SomeServiceImpl service = (SomeServiceImpl)ac.getBean(<span class="hljs-string">&quot;someServiceImpl&quot;</span>);<br>当业务实现类有父接口时，就直接用jdk动态代理，用接口接收代理对象。<br>SomeService service = (SomeService)ac.getBean(<span class="hljs-string">&quot;someServiceImpl&quot;</span>);<br></code></pre></td></tr></table></figure><p>说白了就是JDK动态代理只能用接口来接，但是CGLIB动态代理可以用接口的实现类（子类）来接</p><hr><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// 启动容器</span><br>    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;aspectj1/applicationContext.xml&quot;</span>);<br><br>    SomeService userService = (SomeService) ac.getBean(<span class="hljs-string">&quot;UserService&quot;</span>);<br><br>    <span class="hljs-comment">// 底层aspectj通过动态代理将业务对象的代理对象创建了</span><br>    System.out.println(userService.getClass());<span class="hljs-comment">// 输出：class com.sun.proxy.$Proxy12</span><br><br>    <span class="hljs-comment">// 这个业务方法绑定了一个前置通知</span><br>    userService.showName(<span class="hljs-string">&quot;dfd&quot;</span>,<span class="hljs-number">34</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220624175155.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><h3 id="aspectj-的后置通知-afterreturning">4、AspectJ 的后置通知 <span class="citation" data-cites="AfterReturning">@AfterReturning</span></h3><p><strong>后置通知是在目标方法执行后切入切面功能</strong>。可以得到目标方法的返回值。如果目标方法的返回值是简单类型(8种基本类型+String)则不可改变。如果目标方法的返回值是引用类型则可以改变。</p><ul><li><p>基本数据类型是值传递的，是将基本数据类型复制一份传递给下面的，它无法更改人家本来的</p></li><li><p>引用数据类型保存的是内存地址，把内存地址给了下边以后，下边一改变，那上面的也会改变</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220625200516.png" srcset="/img/loading.gif" lazyload></p><h4 id="后置通知的方法的规范">后置通知的方法的规范</h4><ol type="1"><li><p>访问权限是public</p></li><li><p>方法没有返回值void</p></li><li><p>方法名称自定义</p></li><li><p>方法有参数(也可以没有参数,如果目标方法没有返回值，则可以写无参的方法，但一般会写有参，这样可以处理无参可以处理有参)，这个切面方法的参数就是目标方法的返回值</p></li><li><p>使用 <span class="citation" data-cites="AfterReturning">@AfterReturning</span> 注解表明是后置通知</p><p>参数:</p><ul><li><p>value：指定切入点表达式</p></li><li><p>returning：指定目标方法的返回值的名称,则名称必须与切面方法的参数名称一致.</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>  <br><span class="hljs-meta">@Component</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 后置通知</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@AfterReturning(value  = &quot;execution(  com.bjpowernode.s02..*(..))&quot;,returning = &quot;obj&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myAfterReturning</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后置通知功能实现..............&quot;</span>);<br>        <span class="hljs-keyword">if</span>(obj != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> String)&#123;<br>                obj = obj.toString().toUpperCase();<br>                System.out.println(<span class="hljs-string">&quot;在切面方法中目标方法的返回值:&quot;</span>+obj);<br>            &#125;<br>        <br>            <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> Student)&#123;<br>                Student stu = (Student) obj;<br>                stu.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;在切面方法中目标方法的返回值:&quot;</span>+stu);<br>            &#125;<br>       	&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220625202106.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>目标方法的返回值是Student类型，切面方法和测试方法返回值相同，都是改变后的。</p></blockquote><h3 id="aspectj-的环绕通知-around">5、AspectJ 的环绕通知 <span class="citation" data-cites="Around">@Around</span></h3><p><strong>环绕通知是通过拦截目标方法的方式，在目标方法前后增强功能的通知。</strong>它是功能最强大的通知，一般事务使用此通知。它可以轻易的改变目标方法的返回值。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220626105306.png" srcset="/img/loading.gif" lazyload></p><h4 id="环绕通知方法的规范">环绕通知方法的规范</h4><ol type="1"><li><p>访问权限是public</p></li><li><p>切面方法有返回值,此返回值就是目标方法的返回值</p></li><li><p>方法名称自定义</p></li><li><p>方法有参数,此参数就是目标方法</p></li><li><p>回避异常Throwable</p></li><li><p>使用@Around注解声明是环绕通知</p><p>参数:</p><ul><li>value:指定切入点表达式</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(value = &quot;execution(* com.bjpowernode.s03.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">myAround</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">// 前切功能实现</span><br>        System.out.println(<span class="hljs-string">&quot;环绕功能中的前置功能实现...&quot;</span>);<br>        <span class="hljs-comment">// 目标方法调用</span><br>        Object obj = pjp.proceed(pjp.getArgs());<br>        System.out.println(<span class="hljs-string">&quot;    在切面方法中，目标方法的返回值:&quot;</span> + obj);<br>        <span class="hljs-comment">// 后切功能实现</span><br>        System.out.println(<span class="hljs-string">&quot;环绕功能中的后置功能实现...&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj.toString().toUpperCase();  <span class="hljs-comment">// 改变了目标方法的返回值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220626112059.png" srcset="/img/loading.gif" lazyload></p><h3 id="aspectj-的最终通知-after">6、AspectJ 的最终通知 <span class="citation" data-cites="After">@After</span></h3><p><strong>无论目标方法是否正常执行，最终通知的代码都会被执行。</strong></p><p>可以理解为 <code>try catch finally</code> 中的 <code>finally</code>。</p><p>​</p><h4 id="最终通知方法的规范">最终通知方法的规范</h4><ol type="1"><li><p>访问权限是public</p></li><li><p>方法没有返回值</p></li><li><p>方法名称自定义</p></li><li><p>方法没有参数,如果有也只能是 JoinPoint</p></li><li><p>使用 <span class="citation" data-cites="After">@After</span> 注解表明是最终通知</p><p>参数：</p><ul><li>value：指定切入点表达式</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最终通知方法的规范</span><br><span class="hljs-comment">     * 1)访问权限是public</span><br><span class="hljs-comment">     * 2)方法没有返回值</span><br><span class="hljs-comment">     * 3)方法名称自定义</span><br><span class="hljs-comment">     * 4)方法没有参数,如果有也只能是JoinPoint</span><br><span class="hljs-comment">     * 5)使用<span class="hljs-doctag">@After</span>注解表明是最终通知</span><br><span class="hljs-comment">     *   参数:</span><br><span class="hljs-comment">     *     value:指定切入点表达式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@After(&quot;execution(* com.bjpowernode.s04.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myAfter</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;最终通知:释放资源........&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="给切入点表达式起别名-pointcut">7、给切入点表达式起别名 <span class="citation" data-cites="Pointcut">@Pointcut</span></h3><p>如果多个切面切入到同一个切入点，可以使用别名简化开发。</p><p>使用 <span class="citation" data-cites="Pointcut">@Pointcut</span> 注解，创建一个空方法，此方法的名称就是别名。</p><h2 id="九sm整合的步骤">九、SM整合的步骤</h2><ol type="1"><li>建表</li><li>新建项目,选择quickstart模板</li><li>修改目录</li><li>修改pom.xml文件,添加相关的依赖(使用老师提供)</li><li>添加MyBatis相应的模板(SqlMapConfig.xml和XXXMapper.xml文件)</li><li>添加SqlMapConfig.xml文件(MyBatis核心配置文件),并拷贝jdbc.propertiest属性文件到resources目录下</li><li>添加applicationContext_mapper.xml</li><li>添加applicationContext_service.xml</li><li>添加Users实体类,Accounts实体类</li><li>添加mapper包,添加UsersMapper接口和UsersMapper.xml文件并开发</li><li>添加service包,添加UsersService接口和UsersServiceImpl实现类</li><li>添加测试类进行功能测试</li></ol><h2 id="十事务">十、事务</h2><h3 id="spring-中添加事务的两种方式">1、Spring 中添加事务的两种方式</h3><p><strong>正常是使用事务，一旦出错就回滚，撤销出错前的代码。</strong></p><p>Spring能够自动提交事务，但是不能自动回滚，所以需要手动添加。</p><p>Spring 中添加事务的两种方式：</p><p><strong>1) 注解式的事务</strong> 使用@Transactional注解完成事务控制，此注解可添加到类上，则对类中所有的方法执行事务的设定。此注解也可添加到方法上，只是对此方法执行事务的处理。</p><p>此方式有缺点，事务一般用于增删改操作，有出错则回滚增删改操作。倘若一个类中有查询方法的话，<span class="citation" data-cites="Transactional注解声明在类上的话">@Transactional注解声明在类上的话</span>，就不合适了，因为查询方法不需要事务，这样就得在每个增删改方法上面声明@Transactional注解，代码量太大，如果只有增删改方法，则可以用用。</p><p><strong>2) 声明式事务(必须掌握)，在配置文件中添加一次，整个项目遵循事务的设定.</strong></p><h4 id="通过-transactional-注解添加事务">1. 通过 <span class="citation" data-cites="Transactional">@Transactional</span> 注解添加事务</h4><p><span class="citation" data-cites="Transactional">@Transactional</span> 注解参数详解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED,  // 事务的传播特性</span><br><span class="hljs-meta">            noRollbackForClassName = &quot;ArithmeticException&quot;,  // 指定发生什么异常不回滚,使用的是异常的名称</span><br><span class="hljs-meta">            noRollbackFor = ArithmeticException.class,  // 指定发生什么异常不回滚,使用的是异常的类型</span><br><span class="hljs-meta">            rollbackForClassName = &quot;&quot;,  // 指定发生什么异常必须回滚</span><br><span class="hljs-meta">            rollbackFor = ArithmeticException.class,  // 指定发生什么异常必须回滚</span><br><span class="hljs-meta">            timeout = -1,  // 连接超时设置,默认值是-1,表示永不超时</span><br><span class="hljs-meta">            readOnly = false,  // 默认是false。如果是查询操作,必须设置为true.</span><br><span class="hljs-meta">            isolation = Isolation.DEFAULT  // 使用数据库默认的隔离级别        </span><br><span class="hljs-meta">    )</span><br></code></pre></td></tr></table></figure><h4 id="为什么要添加事务管理器">为什么要添加事务管理器？</h4><ul><li><p>JDBC 的事务处理: <code>Connection</code> <code>con.commit();</code> <code>con.rollback();</code></p></li><li><p>MyBatis 的事务处理: <code>SqlSession</code> <code>sqlSession.commit();</code> <code>sqlSession.rollback();</code></p></li><li><p>Hibernate 的事务处理: <code>Session</code> <code>session.commit();</code> <code>session.rollback();</code></p></li></ul><p><strong>事务管理器用来生成相应技术的连接+执行语句的数据库操作对象.</strong></p><ul><li>如果使用MyBatis框架，必须使用 <code>DataSourceTransactionManager</code> 类完成处理，用于生成SqlSession对象。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加事务管理器对象，用于生成数据库操作对象。--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--因为事务必须关联数据库处理,所以要配置数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red"><strong>项目中的所有事务,必须添加到业务逻辑层上.</strong></font></p><h4 id="声明式事务">2. 声明式事务</h4><p>Spring非常有名的事务处理方式，声明式事务。</p><p>要求项目中的方法命名有规范：</p><ol type="1"><li>完成增加操作包含 add save insert set</li><li>更新操作包含 update change modify</li><li>删除操作包含 delete drop remove clear</li><li>查询操作包含 select find search get</li></ol><p>配置事务切面时可以使用通配符 * 来匹配所有方法</p><h4 id="声明式事务的实现">声明式事务的实现</h4><p>Spring配置文件：</p><p>此配置文件与 applicationContext_service.xml 功能一样，只是事务配置不同。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br> <br> <br>    <span class="hljs-comment">&lt;!--添加包扫描，告知Spring哪些包中包含要交给Spring创建对象的类--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.service.impl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--导入Spring整合MyBatis的配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext_mapper.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--Spring的声明式事务处理--&gt;</span><br>    <span class="hljs-comment">&lt;!--1.创建事务管理器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--事务管理器需要配合数据库操作，所以需要添加数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--2.配置事务切面功能--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCut&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--指定哪些业务方法拥有此事务切面功能--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*insert*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--只要方法名包含insert的方法，都拥有传播特性属性为REQUIRED的事务--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*add*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*Register*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*delete*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*remove*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*update*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*modify*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*select*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*get*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--只要方法名包含get的方法，都拥有只读属性为true的事务--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--3.将 事务切面 和 切入点 绑定，指定哪些接入点拥有上面的事务切面--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--给切入点起个id标识--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myServiceCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bjpowernode.service.impl.*.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--绑定--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;myCut&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myServiceCut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>UserServiceImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-meta">@Service</span><span class="hljs-comment">// 交给Spring创建对象</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountService accountService;<br> <br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * userRegister这个方法可以看成事务A，在事务A中包含事务B</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">userRegister</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-comment">// 调用数据持久层的方法将用户的信息保存到底层数据库</span><br>        <span class="hljs-keyword">int</span> count = userMapper.insertUser(user);<br>        System.out.println(<span class="hljs-string">&quot;用户注册成功&quot;</span>);<br> <br>        <span class="hljs-comment">// 增加账户，包含事务B addAccount</span><br>        accountService.addAccount(<span class="hljs-keyword">new</span> Account(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;user5&quot;</span>,<span class="hljs-string">&quot;用户5&quot;</span>));<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>AccountServiceImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccountService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountMapper accountMapper;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * addAccount可以看成事务B</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> influencedRows = <span class="hljs-number">0</span>;<br>        influencedRows = accountMapper.insertAccount(account);<br>        System.out.println(<span class="hljs-string">&quot;增加账户成功，influencedRows=&quot;</span>+influencedRows);<br> <br>        <span class="hljs-comment">// 手动抛出一个异常,模拟网络出错,出错的话应该不要让数据插入到底层数据库</span><br>        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);<br> <br>        <span class="hljs-keyword">return</span> influencedRows;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUserByTrans</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建并启动Spring容器</span><br>    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext_serviceTrans.xml&quot;</span>);<br><br>    <span class="hljs-comment">// 取出userServiceImpl对象</span><br>    UserService userServiceImpl = (UserService) ac.getBean(<span class="hljs-string">&quot;userServiceImpl&quot;</span>);<br>    System.out.println(userServiceImpl.getClass());<br><br>    <span class="hljs-comment">// 要注册的用户</span><br>    User bat = <span class="hljs-keyword">new</span> User(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;bat&quot;</span>, <span class="hljs-string">&quot;234&quot;</span>);<br><br>    <span class="hljs-comment">// 注册业务实现</span><br>    <span class="hljs-keyword">int</span> count = userServiceImpl.userRegister(bat);<br>    System.out.println(count);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220626234738.png" srcset="/img/loading.gif" lazyload></p><p>可以看到，声明式事务起作用了，底层数据没有插入。即使在执行完插入数据库的代码后，在出错后，也能回滚事务。</p><h4 id="设置事务处理的优先级">设置事务处理的优先级</h4><p>当我们使用了声明式注解，又想使用注解式注解，就是某些不想受声明式事务管理。</p><p>就可以开启注解式事务，然后将注解式事务的优先级设置的比声明式事务的高，就会优先使用注解式事务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注解式事务的驱动，开启注解式事务。优先级order=&quot;100&quot;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:annotation-driven</span>&gt;</span><br> <br> <span class="hljs-comment">&lt;!--3.将事务切面 和 切入点 绑定，指定哪些接入点拥有上面的事务切面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--给切入点起个id标识--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myServiceCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.lin.sm.service.impl.*.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--绑定 advice-ref切面 pointcut-ref切入点--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;myCut&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myServiceCut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-comment">// 不使用声明式事务，使用自己的注解式事务</span><br><span class="hljs-meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccountService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountMapper accountMapper;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * addAccount可以看成事务B</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> influencedRows = <span class="hljs-number">0</span>;<br>        influencedRows = accountMapper.insertAccount(account);<br>        System.out.println(<span class="hljs-string">&quot;增加账户成功，influencedRows=&quot;</span>+influencedRows);<br> <br>        <span class="hljs-comment">// 手动抛出一个异常,模拟网络出错,出错的话应该不要让数据插入到底层数据库</span><br>        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);<br> <br>        <span class="hljs-keyword">return</span> influencedRows;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="事务的隔离级别">2、事务的隔离级别</h3><ul><li><p><strong>MySQL中默认的隔离级别：repeatable read可重复读</strong></p></li><li><p>Oracle中默认的隔离级别：read committed读取已提交的</p></li></ul><ol type="1"><li><p>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</p></li><li><p>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</p></li><li><p>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读，但是innoDB解决了幻读</p></li><li><p>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</p></li><li><p>isolation = Isolation.DEFAULT // 使用数据库默认的隔离级别</p></li></ol><blockquote><p>对于同时运行的多个事务，当这些事务同时操作同一个数据库中相同的数据时， 如果没有采取必要的隔离机制，就会导致各种并发问题，事务就相当于一个线程。(类似于Java中的线程安全问题，数据库就是共享数据)：</p><ul><li><p>脏读: 对于两个事务T1, T2；T1读取了T2 还没提交的数据，读到的是T2更新的数据. 之后, 若T2 回滚, T1读取的内容就是临时且无效的。</p></li><li><p>不可重复读: 对于两个事务T1, T2；T1 读取了一个字段, 然后T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了。</p></li><li><p>幻读: 对于两个事务T1, T2； T1在T2提交插入语句之前对表进行查询, 然后T2 在该表中插入了一些新的行。 之后, 如果T1 再次查询这个表, 就会多出几行，读到插入的数据，简单说就是在同一个事务T1中，两次查询的结果不一样</p></li></ul><p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.</p><p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别,</p><p>不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱，效率越低</p><p>通过设置隔离级别来解决并发问题</p><p>事务的隔离级别：</p><table><thead><tr class="header"><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr class="odd"><td>read uncommitted 读取未提交的</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td>read committed 读取已提交的</td><td>×</td><td>√</td><td>√</td></tr><tr class="odd"><td>repeatable read 可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr class="even"><td>serializable 串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></blockquote><h3 id="spring-事务的传播特性">3、Spring 事务的传播特性</h3><p>多个事务之间的合并，互斥等都可以通过设置事务的传播特性来解决。</p><p><strong>常用</strong></p><ul><li><code>PROPAGATION_REQUIRED</code>：必被包含事务（增删改必用）</li><li><code>PROPAGATION_REQUIRES_NEW</code>：自己新开事务，不管之前是否有事务</li><li><code>PROPAGATION_SUPPORTS</code>：支持事务，如果加入的方法有事务，则支持事务，如果没有，单开事务（跟外面的事务保持一致？）</li><li><code>PROPAGATION_NEVER</code>：不能运行中事务中，如果包在事务中，抛异常</li><li><code>PROPAGATION_NOT_SUPPORTED</code>：不支持事务，<u>运行在非事务</u>的环境</li></ul><p><strong>不常用</strong></p><ul><li><code>PROPAGATION_MANDATORY</code>：必须包在事务中，没有事务则抛异常</li><li><code>PROPAGATION_NESTED</code>：嵌套事务</li></ul><h4 id="事务传播特性解析">事务传播特性解析</h4><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220626230847.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><ul><li>场景8：底层直接报异常，方法都没执行。</li></ul></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Java/">Java</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Spring/">Spring</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处来源：<a href="https://stuxiaozhang.github.io/">小张的宇宙空间站</a></p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2022/06/24/A%20Survey%20of%20Advances%20in%20Evolutionary%20Neural%20Architecture%20Search/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">A Survey of Advances in Evolutionary Neural Architecture Search</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/06/22/AE-CNN/"><span class="hidden-mobile">【AE-CNN】Completely Automated CNN Architecture Design Based on Blocks</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",function(){var e=Object.assign({appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:"https://cdn.bootcdn.net/ajax/libs/emojione/4.5.0/lib/js/emojione.min.js",emojiMaps:null,enableQQ:!0,requiredFields:["nick"]},{el:"#valine",path:window.location.pathname});new Valine(e)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://stuxiaozhang.github.io" target="_blank" rel="nofollow noopener"><span>小张同学的宇宙空间站</span></a> 已经运转了<span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{renderActions:{findScript:[10,a=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const n=new a.options.MathItem(e.textContent,a.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),n.start={node:t,delim:"",n:0},n.end={node:t,delim:"",n:0},a.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>