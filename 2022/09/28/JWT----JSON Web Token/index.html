<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><link rel="icon" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="1. 什么是JWT？JSON Web Token (JWT)是⼀个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。 

通俗解释：JSON Web Token简称JWT，俨然就是通过JSON形式作为Web应用中的令牌，用于在各方之间安全地讲信息作为JSON对象传输。在数据传输过程中还可以完成数"><meta name="author" content="小张同学"><meta name="keywords" content=""><title>JWT----JSON Web Token - 小张同学的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",app_key:"CgnvRL262D07ied40NiXm2VL",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><header style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>xiaozhang's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/schedule/"><i class="iconfont icon-cliplist"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150632.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="JWT----JSON Web Token"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 小张同学 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-09-28 10:34" pubdate>2022年9月28日</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 30 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-1"></div><div class="col-lg-9 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">JWT----JSON Web Token</h1><p class="note note-info">本文最后更新于：2022年10月2日</p><div class="markdown-body"><h1 id="1-什么是JWT？"><a href="#1-什么是JWT？" class="headerlink" title="1. 什么是JWT？"></a>1. 什么是JWT？</h1><p>JSON Web Token (JWT)是⼀个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p><blockquote><p>通俗解释：JSON Web Token简称JWT，俨然就是通过JSON形式作为Web应用中的令牌，用于在各方之间安全地讲信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。</p></blockquote><h1 id="2-JWT能做什么？"><a href="#2-JWT能做什么？" class="headerlink" title="2. JWT能做什么？"></a>2. JWT能做什么？</h1><ul><li>Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含 JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特 性，因为它的开销很小，并且可以轻松地跨域使用。</li><li>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是⼀种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</li></ul><h1 id="3-为什么是JWT"><a href="#3-为什么是JWT" class="headerlink" title="3. 为什么是JWT"></a>3. 为什么是JWT</h1><h3 id="基于传统的Session认证"><a href="#基于传统的Session认证" class="headerlink" title="基于传统的Session认证"></a>基于传统的Session认证</h3><h4 id="1-认证方式"><a href="#1-认证方式" class="headerlink" title="1. 认证方式"></a>1. 认证方式</h4><p>http协议本身是一种无状态协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再进行一次用户验证。因为HTTP协议并不保留之前一切的请求或响应报文的信息。我们无法知道是哪个用户发出的请求，所以，在第一次请求时，在服务器端存储一份用户登陆的信息，这份信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自于哪个用户了。这是传统的Session认证</p><blockquote><p><strong>cookie</strong></p><p>Cookie是web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将KCookie发送到客户端，在客户端可以进行保存，以便下次使用。</p><p><strong>session</strong></p><p>在服务端会创建一个session对象，产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端，下一次访问时，sessionID发送到服务器，在服务端进行识别不同的用户。</p><p>cookie是保存在客户端浏览器，session保存在服务器，cookie保存sessionid。session是依赖Cookie的，如果Cookie被禁用，那么session也将失效，session默认的会话时长为30分钟。</p><p><strong>三者相同点与区别</strong></p><p>相同点：都是用于身份验证或鉴权的，都是服务器产生的</p><p>区别：</p><ol><li>cookie是保存在客户端，session是存储在服务器的</li><li>session保存在服务器的内存，默认是30分钟，token是保存在服务器的数据库里面，持久。</li></ol><p>HTTP 是一种不保存状态，即无状态（stateless）协议。 HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求和响应都不做持久化处理。使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议HTTP 是一种不保存状态，即无状态（stateless）协议。 HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求和响应都不做持久化处理。使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。</p></blockquote><h4 id="2-认证流程"><a href="#2-认证流程" class="headerlink" title="2. 认证流程"></a>2. 认证流程</h4><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220928115139.png" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="3-暴露问题"><a href="#3-暴露问题" class="headerlink" title="3. 暴露问题"></a>3. 暴露问题</h4><ol><li><p>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</p></li><li><p>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p></li><li><p>因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p></li><li><p>在前后端分离系统中就更加痛苦:如下图所示</p><p>也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session 每次携带sessionid到服务器，服务器还要查询用户信息。同时如果用户很多。这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF(跨站伪造请求攻击)攻击,session是基于cookie进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p><p>还有就是sessionid就是一个特征值，表达的信息不够丰富。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。不方便集群应用。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220928133837.png" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="基于JWT认证"><a href="#基于JWT认证" class="headerlink" title="基于JWT认证"></a>基于JWT认证</h3><h4 id="1-认证流程"><a href="#1-认证流程" class="headerlink" title="1. 认证流程"></a>1. 认证流程</h4><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220928133951.png" srcset="/img/loading.gif" lazyload alt=""></p><ol><li>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输(https协议) ，从而避免敏感信息被嗅探。</li><li>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload (负载)，将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同11. zzz. xxx的字符串。token head.payload.signature</li><li>后端将JWT字符串作为登录成功的返回结果返回给前端。 前端可以将返回的结果保存在 localStorage或sessionStorage上， 退出登录时前端删除保存的JWT即可。</li><li>前端在每次请求时将JWT放入HTTP Header中的Authorization位。 (解决XSS和XSRF问题)</li><li>后端检查是否存在，如存在验证JWT的有效性。<ul><li>检查签名是否正确;</li><li>检查Token是否过期;</li><li>检查Token的接收方是否是自己(可选)</li></ul></li><li>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</li></ol><blockquote><p>session存在服务器端，而jwt存在客户端</p><p>cookie和session本质上还是对用户信息的确认，需要消耗服务器端内存，而jwt是对用户权限的确认，不需要确认用户信息</p></blockquote><h4 id="2-JWT优势在哪"><a href="#2-JWT优势在哪" class="headerlink" title="2. JWT优势在哪?"></a>2. JWT优势在哪?</h4><ol><li>简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，数据量小，传输速度快</li><li>自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库。因为Token是 以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。</li><li>不需要在服务端保存会话信息，特别适用于分布式微服务。</li><li>支持跨域访问：cookie是无法跨域的，而token由于没有用到cookie(前提是将token放到请求头中)，所以跨域后不会存在信息丢失问题</li><li>无需考虑CSRF：由于不再依赖cookie，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御</li></ol><h1 id="4-JWT的结构是什么？"><a href="#4-JWT的结构是什么？" class="headerlink" title="4. JWT的结构是什么？"></a>4. JWT的结构是什么？</h1><h3 id="1-header"><a href="#1-header" class="headerlink" title="1. header"></a>1. header</h3><p><strong>JWT头</strong>是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存</p><p>注意:Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>	<span class="hljs-attr">&quot;alg&quot;</span>:<span class="hljs-string">&quot;HS256&quot;</span>,<br>	<span class="hljs-attr">&quot;typ&quot;</span>:<span class="hljs-string">&quot;JWT&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Payload"><a href="#2-Payload" class="headerlink" title="2. Payload"></a>2. Payload</h3><p>令牌的第二部分是<strong>有效负载</strong>，是JWT的主体内容部分，也是一个<strong>JSON对象</strong>，包含需要传递的数据。 JWT指定七个默认字段供选择</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">iss：发行人<br>exp：到期时间<br>sub：主题<br>aud：用户<br>nbf：在此之前不可用<br>iat：发布时间<br>jti：JWT ID用于标识该JWT<br></code></pre></td></tr></table></figure><p>这些预定义的字段并不要求强制使用。除以上默认字段外，我们还可以自定义私有字段，<strong>一般会把包含用户信息的数据放到payload中</strong>，如下例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;sub&quot;</span> : <span class="hljs-string">&quot;NB&quot;</span><br>    <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;yjiewei&quot;</span><br>    <span class="hljs-string">&quot;admin&quot;</span> : <span class="hljs-string">&quot;true&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Signature"><a href="#3-Signature" class="headerlink" title="3. Signature"></a>3. Signature</h3><p><strong>签名哈希</strong>部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以<strong>确保数据不会被篡改</strong>。首先，需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">HMACSHA256</span> (base<span class="hljs-number">64</span>Ur<span class="hljs-number">1</span>Encode(header) + <span class="hljs-string">&quot;.&quot;</span> + base<span class="hljs-number">64</span>Ur<span class="hljs-number">1</span>Encode(payload) , secret);<br></code></pre></td></tr></table></figure><p>在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用<code>.</code>分隔，就构成整个JWT对象</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220928164851.png" srcset="/img/loading.gif" lazyload alt=""></p><p><strong>注意</strong>JWT每部分的作用，在服务端接收到客户端发送过来的JWT token之后：</p><ul><li><code>header</code>和<code>payload</code>可以直接利用base64解码出原文，从<code>header</code>中获取哈希签名的算法，从<code>payload</code>中获取有效数据</li><li><code>signature</code>由于使用了不可逆的加密算法，无法解码出原文，它的作用是<strong>校验token有没有被篡改</strong>。服务端获取<code>header</code>中的加密算法之后，利用该算法加上<code>secret</code>对<code>header</code>、<code>payload</code>进行加密，比对加密后的数据和客户端发送过来的是否一致。注意<code>secret</code>只能保存在服务端，而且对于不同的加密算法其含义有所不同，一般对于MD5类型的摘要加密算法，<code>secret</code>实际上代表的是盐值</li></ul><h1 id="5-封装工具类"><a href="#5-封装工具类" class="headerlink" title="5. 封装工具类"></a>5. 封装工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTUtil</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 	密钥要⾃⼰保管好</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String SECRET = <span class="hljs-string">&quot;privatekey#^&amp;^%!save&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 	传⼊payload信息获取token</span><br><span class="hljs-comment">    * 	<span class="hljs-doctag">@param</span> map payload</span><br><span class="hljs-comment">    * 	<span class="hljs-doctag">@return</span> token</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getToken</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;<br>        JWTCreator.Builder builder = JWT.create();<br>        <span class="hljs-comment">//payload</span><br>        map.forEach(builder::withClaim);<br>        <br>        Calendar instance = Calendar.getInstance();<br>        instance.add(Calendar.DATE, <span class="hljs-number">3</span>); <span class="hljs-comment">//默认3天过期</span><br>        builder.withExpiresAt(instance.getTime());<span class="hljs-comment">//指定令牌的过期时间</span><br>        <br>        <span class="hljs-keyword">return</span> builder.sign(Algorithm.HMAC256(SECRET));<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 验证token</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DecodedJWT <span class="hljs-title">verify</span><span class="hljs-params">(String token)</span> </span>&#123;<br>        <span class="hljs-comment">//如果有任何验证异常，此处都会抛出异常</span><br>        <span class="hljs-keyword">return</span> JWT.require(Algorithm.HMAC256(SECRET)).build().verify(token);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 获取token中的payload</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Claim&gt; <span class="hljs-title">getPayloadFromToken</span><span class="hljs-params">(String token)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span><br>        JWT.require(Algorithm.HMAC256(SECRET)).build().verify(token).getClaims();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-JWT-整合SpringBoot"><a href="#6-JWT-整合SpringBoot" class="headerlink" title="6. JWT 整合SpringBoot"></a>6. JWT 整合SpringBoot</h1><blockquote><p>dao 就是mapper ，mapper就是 dao</p></blockquote><p>拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// 获取请求头中的令牌</span><br>        String token = response.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            JWTUtils.verify(token);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (SignatureVerificationException e) &#123;<br>            e.printStackTrace();<br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;签名不⼀致&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (TokenExpiredException e) &#123;<br>            e.printStackTrace();<br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;令牌过期&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (AlgorithmMismatchException e) &#123;<br>            e.printStackTrace();<br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;算法不匹配&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InvalidClaimException e) &#123;<br>            e.printStackTrace();<br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;失效的payload&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;token⽆效&quot;</span>);<br>        &#125;<br><br>        map.put(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// 将map转为json （用jackson）</span><br>        String json = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map);<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        response.getWriter().println(json);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定拦截路径</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterceptorConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> JWTInterceptor())<br>            .addPathPatterns(<span class="hljs-string">&quot;/user/test&quot;</span>)<br>            .excludePathPatterns(<span class="hljs-string">&quot;/user/login&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 拦截请求并验证请求头中的token</span><br><span class="hljs-meta">@PostMapping(&quot;/user/test&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">test</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>    String token = request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>    DecodedJWT verify = JWTUtil.verify(token);<br>    String id = verify.getClaim(<span class="hljs-string">&quot;id&quot;</span>).asString(); <span class="hljs-comment">// 我前⾯存的时候转字符串了</span><br>    String name = verify.getClaim(<span class="hljs-string">&quot;name&quot;</span>).asString();<br>    log.info(<span class="hljs-string">&quot;⽤⼾id：&#123;&#125;&quot;</span>, id);<br>    log.info(<span class="hljs-string">&quot;⽤⼾名: &#123;&#125;&quot;</span>, name);<br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>业务逻辑</span><br>    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-keyword">true</span>);<br>    map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;请求成功&quot;</span>);<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-JJWT使用详解"><a href="#7-JJWT使用详解" class="headerlink" title="7. JJWT使用详解"></a>7. JJWT使用详解</h1><p>JJWT旨在成为最易于使用和理解的库，用于在JVM和Android上创建和验证JSON Web令牌（JWT）</p><p>Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <span class="hljs-comment">&lt;!-- or jjwt-gson if Gson is preferred --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Uncomment this next dependency if you are using JDK 10 or earlier and you also want to use </span><br><span class="hljs-comment">     RSASSA-PSS (PS256, PS384, PS512) algorithms.  JDK 11 or later does not require it for those algorithms:</span><br><span class="hljs-comment">&lt;dependency&gt;</span><br><span class="hljs-comment">    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;</span><br><span class="hljs-comment">    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;</span><br><span class="hljs-comment">    &lt;version&gt;1.60&lt;/version&gt;</span><br><span class="hljs-comment">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="hljs-comment">&lt;/dependency&gt;</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><p>创建JWS：</p><p>可以如下创建一个JWS：</p><ol><li>使用该<code>Jwts.builder()</code>方法创建<code>JwtBuilder</code>实例。</li><li>调用<code>JwtBuilder</code>方法以根据需要添加标头参数和声明。</li><li>指定要用于签名JWT的<code>SecretKey</code>或不对称<code>PrivateKey</code>。</li><li>最后，调用该<code>compact()</code>方法进行压缩和签名，生成最终的jws。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String jws = Jwts.builder() <span class="hljs-comment">// (1)</span><br>    .setSubject(<span class="hljs-string">&quot;NB&quot;</span>)      <span class="hljs-comment">// (2) </span><br>    .setClaims(map)<br>    .setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + EXPIRATION_TIME))<br>    .signWith(SignatureAlgorithm.HS512, SECRET)  <span class="hljs-comment">// (3)</span><br>    .compact();             <span class="hljs-comment">// (4)</span><br></code></pre></td></tr></table></figure><h3 id="解析JWS"><a href="#解析JWS" class="headerlink" title="解析JWS"></a>解析JWS</h3><p>您阅读（解析）JWS的方法如下：</p><ol><li>使用该<code>Jwts.parserBuilder()</code>方法创建<code>JwtParserBuilder</code>实例。</li><li>指定要用于验证JWS签名的<code>SecretKey</code>或不对称<code>PublicKey</code>。1个</li><li>在<code>build()</code>上调用方法<code>JwtParserBuilder</code>以返回线程安全<code>JwtParser</code>。</li><li>最后，<code>parseClaimsJws(String)</code>用您的jws调用该方法<code>String</code>，生成原始的JWS。</li><li>如果解析或签名验证失败，则整个调用将包装在try / catch块中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Jws&lt;Claims&gt; jws;<br><span class="hljs-keyword">try</span> &#123;<br>    jws = Jwts.parserBuilder()  <span class="hljs-comment">// (1)</span><br>    .setSigningKey(key)         <span class="hljs-comment">// (2)</span><br>    .build()                    <span class="hljs-comment">// (3)</span><br>    .parseClaimsJws(jwsString); <span class="hljs-comment">// (4)</span><br>    <span class="hljs-comment">// 我们可以放心地信任JWT   </span><br><span class="hljs-keyword">catch</span> (JwtException ex) &#123;       <span class="hljs-comment">// (5)</span><br>    <span class="hljs-comment">// 我们不能按照其创建者的意图使用JWT </span><br>&#125;<br></code></pre></td></tr></table></figure><p>翻译文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45332753/article/details/113833777">https://blog.csdn.net/qq_45332753/article/details/113833777</a></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/jwt/">jwt</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处来源：<a href="https://stuxiaozhang.github.io/">小张的宇宙空间站</a></p><div class="post-prevnext"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2022/09/16/MyBatis-Plus%E7%AC%94%E8%AE%B0/"><span class="hidden-mobile">MyBatis-Plus笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",function(){var e=Object.assign({appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:"https://cdn.bootcdn.net/ajax/libs/emojione/4.5.0/lib/js/emojione.min.js",emojiMaps:null,enableQQ:!0,requiredFields:["nick"]},{el:"#valine",path:window.location.pathname});new Valine(e)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://stuxiaozhang.github.io" target="_blank" rel="nofollow noopener"><span>小张同学的宇宙空间站</span></a> 已经运转了<span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{renderActions:{findScript:[10,a=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const n=new a.options.MathItem(e.textContent,a.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),n.start={node:t,delim:"",n:0},n.end={node:t,delim:"",n:0},a.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>