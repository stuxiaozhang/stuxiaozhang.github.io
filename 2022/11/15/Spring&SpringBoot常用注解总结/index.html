<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><link rel="icon" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="1. @SpringBootApplication
这里先单独拎出@SpringBootApplication 注解说一下，虽然我们一般不会主动去使用它。
@SpringBootApplication注解一般放在项目的一个启动类上，用来把启动类注入到容器中，用来定义容器扫描的范围，用来加载classpath环境中一些bean。
123456@SpringBootApplicationpubl"><meta name="author" content="小张同学"><meta name="keywords" content=""><title>Spring&amp;SpringBoot常用注解总结 - 小张同学的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",app_key:"CgnvRL262D07ied40NiXm2VL",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><header style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>xiaozhang's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/schedule/"><i class="iconfont icon-cliplist"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150632.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Spring&SpringBoot常用注解总结"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 小张同学 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-11-15 09:11" pubdate>2022年11月15日</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 61 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-1"></div><div class="col-lg-9 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Spring&amp;SpringBoot常用注解总结</h1><p class="note note-info">本文最后更新于：2022年12月8日</p><div class="markdown-body"><h1 id="springbootapplication">1. <span class="citation" data-cites="SpringBootApplication">@SpringBootApplication</span></h1><p>这里先单独拎出<code>@SpringBootApplication</code> 注解说一下，虽然我们一般不会主动去使用它。</p><p><span class="citation" data-cites="SpringBootApplication注解一般放在项目的一个启动类上">@SpringBootApplication注解一般放在项目的一个启动类上</span>，用来把启动类注入到容器中，用来定义容器扫描的范围，用来加载classpath环境中一些bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurityJwtGuideApplication</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="citation" data-cites="SpringBootApplication注解主要包装了">@SpringBootApplication注解主要包装了</span><span class="citation" data-cites="SpringBootConfiguration">@SpringBootConfiguration</span>、<span class="citation" data-cites="EnableAutoConfiguration和">@EnableAutoConfiguration和</span><span class="citation" data-cites="ComponentScan注解">@ComponentScan注解</span>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.boot.autoconfigure;<br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123;</span><br><span class="hljs-meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>   ......<br>&#125;<br><br><span class="hljs-keyword">package</span> org.springframework.boot;<br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>根据 SpringBoot 官网，这三个注解的作用分别是： - <code>@SpringBootConfiguration</code> 主要用来把bean注入到容器中！因为该注解又封装了@Configuration注解。而@Configuration注解又封装了<span class="citation" data-cites="Component注解">@Component注解</span>，<span class="citation" data-cites="Component注解主要用来把一个bean注入到容器中">@Component注解主要用来把一个bean注入到容器中</span>。因此，<span class="citation" data-cites="SpringBootConfiguration注解就拥有了">@SpringBootConfiguration注解就拥有了</span><span class="citation" data-cites="Component注解的功能">@Component注解的功能</span>，用来把一个bean注入到容器中。</p><ul><li><p><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制。帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot，并创建对应配置类的Bean，并把该Bean实体交给IoC容器进行管理。</p></li><li><p><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Repository</code>,<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解 默认 会扫描该类所在的包下所有的类。从定义<strong>扫描的路径</strong>中找出标识了<strong>需要装配</strong>的类，自动装配到spring的bean容器中</p><blockquote><p>https://www.cnblogs.com/jpfss/p/11171655.html</p></blockquote></li></ul><p>如下面图片，这里只设置读取<code>ConfigService</code>类所在包的所有组件，但是最终输出也有<code>mainConfig</code>，是因为该注解作用于MainConfig类，默认会扫描config包。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/21a51b3e3742dc8e2a2f599aeab4692a.png" srcset="/img/loading.gif" lazyload alt="image-20220220195322567"><figcaption>image-20220220195322567</figcaption></figure><blockquote><p>所以，包的路径扫描是多种设置累加的结果</p></blockquote><h1 id="spring-bean-相关">2. Spring Bean 相关</h1><h2 id="bean">2.0 <code>@Bean</code></h2><p>简单来说，<strong>Bean 代指的就是那些被 IoC 容器所管理的对象。</strong></p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p><p><img src="https://img-blog.csdnimg.cn/062b422bd7ac4d53afd28fb74b2bc94d.png" srcset="/img/loading.gif" lazyload></p><p><strong>Spring帮助我们管理(装配)Bean分为两个部分</strong></p><ul><li>一个是注册Bean(<span class="citation" data-cites="Component">@Component</span> , <span class="citation" data-cites="Repository">@Repository</span> , @ Controller , <span class="citation" data-cites="Service">@Service</span> , <span class="citation" data-cites="Configuration">@Configuration</span>)。</li><li>一个是装配Bean(<span class="citation" data-cites="Autowired">@Autowired</span> , <span class="citation" data-cites="Resource">@Resource</span>，可以通过byTYPE（<span class="citation" data-cites="Autowired">@Autowired</span>）、byNAME（<span class="citation" data-cites="Resource">@Resource</span>）的方式获取Bean)。</li></ul><p>完成这两个动作有三种方式，一种是使用自动配置的方式、一种是使用JavaConfig的方式，一种就是使用XML配置的方式。 https://blog.csdn.net/qq_45470811/article/details/102903919</p><ul><li><span class="citation" data-cites="Component">@Component</span> 自动装配。（作用就相当于 XML配置） 要想实现Bean的自动装配需要先认识Spring的两个核心组件：<ul><li>组件扫描（component scanning）: Spring会自动的从应用上下文中发现创建的Bean。</li><li>自动装配（Autowring）：装配各个Bean之间的依赖关系。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;lkm&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><span class="citation" data-cites="Bean">@Bean</span> 需要在Java配置类中使用，即类上需要加上@Configuration注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">student</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StudentImpl();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两者都可以通过@Autowired装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>Student student;<br></code></pre></td></tr></table></figure><ul><li>上面的代码相当于下面的 xml 配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xz.StudentImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="component-和-bean-的区别是什么"><span class="citation" data-cites="Component">@Component</span> 和 <span class="citation" data-cites="Bean">@Bean</span> 的区别是什么？</h3><p><strong>两者的目的是一样的，都是注册bean到Spring容器中</strong></p><p><strong>区别：</strong></p><ul><li><p><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p></li><li><p><code>@Component</code> <code>@Component</code> 注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。通常用于自动检测以及类路径扫描自动装配bean到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。</p><p>注释类和bean之间存在隐式的一对一映射（即每个类一个bean）。</p><p><code>@Bean</code> 注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。</p></li><li><p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</p></li></ul><p><strong>那为什么有了@Compent,还需要@Bean呢？</strong></p><p>如果你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component注解的，因此就不能使用自动化装配的方案了，但是我们可以使用@Bean,当然也可以使用XML配置。</p><p>下面这个例子是通过 <code>@Component</code> 无法实现的。（这个例子还得再理解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> OneService <span class="hljs-title">getService</span><span class="hljs-params">(status)</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> (status)  &#123;<br>        when <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> serviceImpl1();<br>        when <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> serviceImpl2();<br>        when <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> serviceImpl3();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="autowired">2.1. <code>@Autowired</code></h2><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>   ......<br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> UserService userService;<br>   ......<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤</strong>：<span class="citation" data-cites="Autowird默认的注入方式为byType">@Autowird默认的注入方式为byType</span>，也就是根据类型匹配；当有多个实现时，则通过byName注入，也可以通过配合@Qualifier注解来显式指定name值，指明要使用哪个具体的实现类</p><p>举例：</p><p>首先有一个接口UserService和两个实现类UserServiceImpl1和UserServiceImpl2，并且这两个实现类已经加入到Spring的IOC容器中了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">@<span class="hljs-title">Service</span></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">UserServiceImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span><br></code></pre></td></tr></table></figure><p>错误示例：通过@Autowired注入使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br></code></pre></td></tr></table></figure><p>根据上面的步骤，可以很容易判断出，直接这么使用是会报错的</p><p>原因：首先通过byType注入，判断UserService类型有两个实现，无法确定具体是哪一个。于是通过byName方式，这里的变量名userService也无法匹配IOC容器中id（此处指的userServiceImpl1和userServiceImpl2），于是报错。</p><p><strong>注意</strong>：通过注解注入到IOC容器的id值默认是其类名首字母小写</p><p><strong>解决方案</strong></p><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式一：改变变量名</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userServiceImpl1;<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式二：配合@Qualifier注解来显式指定name值</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;userServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> UserService userService;<br></code></pre></td></tr></table></figure><h2 id="resource">2.2 <code>@Resource</code></h2><p><strong>步骤</strong>：<span class="citation" data-cites="Resource默认通过byName注入">@Resource默认通过byName注入</span>，如果没有匹配则通过byType注入</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">@<span class="hljs-title">Service</span></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">UserServiceImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span><br></code></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> UserService userService;<br></code></pre></td></tr></table></figure><p>首先通过byName匹配，变量名userService无法匹配IOC容器中任何一个id（这里指的userServiceImpl1和userServiceImpl2），于是通过byType匹配，发现类型UserService的实现类有两个，仍然无法确定，于是报错。</p><p>同时@Resource还有两个重要的属性：<strong>name和type，用来显式指定byName和byType方式注入</strong></p><p><strong>使用</strong>：对应4种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 默认方式：byName</span><br><span class="hljs-meta">@Resource</span>  <br><span class="hljs-keyword">private</span> UserService userDao; <br><br><span class="hljs-comment">// 2. 指定byName</span><br><span class="hljs-meta">@Resource(name=&quot;userService&quot;)</span>  <br><span class="hljs-keyword">private</span> UserService userService; <br><br><span class="hljs-comment">// 3. 指定byType</span><br><span class="hljs-meta">@Resource(type=UserService.class)</span>  <br><span class="hljs-keyword">private</span> UserService userService; <br><br><span class="hljs-comment">// 4. 指定byName和byType</span><br><span class="hljs-meta">@Resource(name=&quot;userService&quot;,type=UserService.class)</span>  <br><span class="hljs-keyword">private</span> UserService userService; <br></code></pre></td></tr></table></figure><ol type="1"><li><strong>既没指定name属性，也没指定type属性</strong>：默认通过byName方式注入，如果byName匹配失败，则使用byType方式注入（也就是上面的那个例子）</li><li><strong>指定name属性</strong>：通过byName方式注入，把变量名和IOC容器中的id去匹配，匹配失败则报错</li><li><strong>指定type属性</strong>：通过byType方式注入，在IOC容器中匹配对应的类型，如果匹配不到或者匹配到多个则报错</li><li><strong>同时指定name属性和type属性</strong>：在IOC容器中匹配，名字和类型同时匹配则成功，否则失败</li></ol><h3 id="autowired和resource注解的区别和联系"><span class="citation" data-cites="Autowired和">@Autowired和</span><span class="citation" data-cites="Resource注解的区别和联系">@Resource注解的区别和联系</span></h3><h4 id="联系">联系</h4><ol type="1"><li><span class="citation" data-cites="Autowired和">@Autowired和</span><span class="citation" data-cites="Resource注解都是作为bean对象注入的时候使用的">@Resource注解都是作为bean对象注入的时候使用的</span></li><li>两者都可以声明在字段和setter方法上</li></ol><p>注意：如果声明在字段上，那么就不需要再写setter方法。但是本质上，该对象还是作为set方法的实参，通过执行set方法注入，只是省略了setter方法罢了</p><h4 id="区别">区别</h4><ol type="1"><li><span class="citation" data-cites="Autowired注解是Spring提供的">@Autowired注解是Spring提供的</span>，而@Resource注解是J2EE本身提供的</li><li><span class="citation" data-cites="Autowird注解默认通过byType方式注入">@Autowird注解默认通过byType方式注入</span>，而@Resource注解默认通过byName方式注入</li><li><span class="citation" data-cites="Autowired注解注入的对象需要在IOC容器中存在">@Autowired注解注入的对象需要在IOC容器中存在</span>，否则需要加上属性required=false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错</li></ol><p>对于byName和byType方式不太熟悉的可以看一下这里：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tanga842428/article/details/54694484">Spring中的byName与byType</a></p><p>简单来说，<strong>byName就是变量名去匹配bean的id属性，而byType则是变量类型去匹配bean的class属性</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br></code></pre></td></tr></table></figure><p>此处byName就是拿变量名<code>userService</code>去匹配IOC容器的id <code>userService</code>，匹配成功；</p><p>而byType就是拿变量类型<code>UserService</code>去匹配IOC容器的id<code>com.test.UserService.UserServiceImpl</code>，因为UserServiceImpl是UserService实现，所以也匹配成功</p><h2 id="componentrepositoryservice-controller">2.3. <code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, <code>@Controller</code></h2><p>我们一般使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类，可以采用以下注解实现：</p><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。把普通POJO（Plain Ordinary Java Object简单的Java对象，实际就是普通JavaBeans）实例化到spring容器中，相当于配置文件中的 <code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code>。泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、<span class="citation" data-cites="Services等的时候">@Services等的时候</span>），我们就可以使用@Component来标注这个类。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="restcontroller"><code>@RestController</code></h3><p><code>@RestController</code>注解是<code>@Controller</code>和<code>@ResponseBody</code>的合集，表示这是个控制器 bean，并且是将函数的返回值直接填入 HTTP 响应体中，是 REST 风格的控制器。<code>@RestController</code>只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p><h4 id="spring-mvc-与-rest">Spring MVC 与 REST</h4><p>在传统的流程中，ModelAndView对象是从控制器转发到客户端的，通过在方法上加@ResponseBody，Spring直接从控制器返回数据，而不需要查找视图。</p><p>基于注解的MVC框架简化了创建RESTful web服务的过程。传统的Spring MVC控制器和RESTful web服务控制器之间的关键区别是HTTP响应体的创建方式。传统的MVC控制器依赖于视图技术，基于REST的web服务控制器仅返回对象，而对象数据直接以JSON/XML的形式写入HTTP响应。</p><blockquote><p>REST（英文：Representational State Transfer，简称 REST）描述了一个架构样式的网络系统， 比如 web 应用程序。它并没有一个明确的标准，而更像是一种设计风格。核心价值在于如何设计出符合 REST 风格的网络接口。</p><ol type="1"><li>资源（Resources）</li></ol><p>网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。</p><p>要获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。</p><ol start="2" type="1"><li>表现层（Representation）</li></ol><p>把资源具体呈现出来的形式，叫做它的表现层（Representation）。</p><p>比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进 制格式。</p><ol start="3" type="1"><li>状态转化（State Transfer）</li></ol><p>每发出一个请求，就代表了客户端和服务器的一次交互过程。</p><p>HTTP 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器， 必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。</p><p>而这种转化是建立在表现层之上的，所以就是“表现层状态转化”。</p><p>具体说， 就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p></blockquote><h4 id="使用controller-responsebody注解">使用@Controller + <span class="citation" data-cites="ResponseBody注解">@ResponseBody注解</span></h4><ul><li><p><span class="citation" data-cites="Controller用于标记在一个类上">@Controller用于标记在一个类上</span>，使用它标记的类就是一个Spring MVC Controller对象，分发处理器会扫描使用该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。</p></li><li><p><span class="citation" data-cites="ResponseBody注解用于将">@ResponseBody注解用于将</span><span class="citation" data-cites="Controller的方法返回的对象">@Controller的方法返回的对象</span>，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p></li></ul><p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般是用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。<code>@Controller</code> +<code>@ResponseBody</code> 返回 JSON 或 XML 形式数据</p><h2 id="scope">2.4 <code>@Scope</code></h2><p>声明 Spring Bean 的作用域，使用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(&quot;singleton&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">personSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>四种常见的 Spring Bean 的作用域：</strong></p><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li></ul><h2 id="configuration">2.5. <code>@Configuration</code></h2><p>一般用来声明一个类为配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化。</p><p><code>@Configuration</code>：声明一个类为配置类，用于取代bean.xml配置文件注册bean对象。</p><p><span class="citation" data-cites="Configuration注解常常一起搭配使用的注解有">@Configuration注解常常一起搭配使用的注解有</span><span class="citation" data-cites="Bean">@Bean</span>、<span class="citation" data-cites="Scope">@Scope</span>、<span class="citation" data-cites="Lazy三个比较常见">@Lazy三个比较常见</span>：</p><ul><li><span class="citation" data-cites="Bean">@Bean</span>：等价于Spring中的bean标签用于注册bean对象的，内部有一些初始化、销毁的属性…</li><li><span class="citation" data-cites="Scope">@Scope</span>：用于声明该bean的作用域，作用域有singleton、prototype、request、session。</li><li><span class="citation" data-cites="Lazy">@Lazy</span>：标记该bean是否开启懒加载。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="处理常见的-http-请求类型">3. 处理常见的 HTTP 请求类型</h1><p><strong>5 种常见的请求类型:</strong></p><ul><li><strong>GET</strong> ：请求从服务器获取特定资源。举个例子：<code>GET /users</code>（获取所有学生）</li><li><strong>POST</strong> ：在服务器上创建一个新的资源。举个例子：<code>POST /users</code>（创建学生）</li><li><strong>PUT</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /users/12</code>（更新编号为 12 的学生）</li><li><strong>DELETE</strong> ：从服务器删除特定的资源。举个例子：<code>DELETE /users/12</code>（删除编号为 12 的学生）</li><li><strong>PATCH</strong> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li></ul><h2 id="get-请求">3.1. GET 请求</h2><p><code>@GetMapping(&quot;users&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users&quot;, method=RequestMethod.GET)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/users&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() &#123;<br>   <span class="hljs-keyword">return</span> userRepository.findAll();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="post-请求">3.2 POST 请求</h2><p><code>@PostMapping(&quot;users&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users&quot;, method=RequestMethod.POST)</code></p><p>关于 <code>@RequestBody</code> 注解的使用，在下面的“前后端传值”这块会讲到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/users&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;User&gt; <span class="hljs-title">createUser</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> UserCreateRequest userCreateRequest)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> userRespository.save(userCreateRequest);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="put-请求">3.3. PUT 请求</h2><p><code>@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;, method=RequestMethod.PUT)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;User&gt; <span class="hljs-title">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId,</span></span><br><span class="hljs-function"><span class="hljs-params">   <span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> UserUpdateRequest userUpdateRequest)</span> </span>&#123;<br>   		......<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="delete-请求">3.4. DELETE 请求</h2><p><code>@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;, method=RequestMethod.DELETE)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId)</span></span>&#123;<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="patch-请求">3.5. <strong>PATCH 请求</strong></h2><p>一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PatchMapping(&quot;/profile&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">updateStudent</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> StudentUpdateRequest studentUpdateRequest)</span> </span>&#123;<br>    studentRepository.updateDetail(studentUpdateRequest);<br>    <span class="hljs-keyword">return</span> ResponseEntity.ok().build();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="前后端传值">4. 前后端传值</h1><p>掌握前后端传值的正确姿势，是我开始 CRUD 的第一步！</p><h2 id="pathvariable-和-requestparam">4.1 <code>@PathVariable</code> 和 <code>@RequestParam</code></h2><p><strong><code>@PathVariable</code> 用于获取路径参数。</strong></p><p><span class="citation" data-cites="PathVariable">@PathVariable</span> 映射 URL 绑定的占位符。通过 <span class="citation" data-cites="PathVariable">@PathVariable</span> 可以将 URL 中占位符参数绑定到控制器处理方法的入参中:URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx”) 绑定到操作方法的入参中。</p><p>1、若方法参数名称和需要绑定的url中变量名称一致时,可以简写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/getUser/&#123;name&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> userService.selectUser(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>2、若方法参数名称和需要绑定的url中变量名称不一致时，写成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/getUserById/&#123;name&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String userName)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> userService.selectUser(userName);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>@RequestParam</code> 用于获取查询参数</strong></p><ul><li><p>如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400。</p></li><li><p>如果参数前不写@RequestParam(xxx)的话，那么就前端可以有可以没有对应的xxx名字才行，如果有xxx名的话，那么就会自动匹配；没有的话，请求也能正确发送。</p></li></ul><p>追注：这里与feign消费服务时不同；feign消费服务时，如果参数前什么也不写，那么会被默认是@RequestBody的。</p><p>举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Teacher&gt; <span class="hljs-title">getKlassRelatedTeachers</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> </span>&#123;<br>		  	...<br>	 &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们请求的 url 是：<code>/klasses/123456/teachers?type=web</code></p><p>那么我们服务获取到的数据就是：<code>klassId=123456,type=web</code>。</p><h2 id="requestbody">4.2. <code>@RequestBody</code></h2><p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会（会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code> ）自动<strong>将前端请求的 body 中的 json 字符串转换为 java 对象。</strong></p><p>用一个简单的例子来演示一下基本使用！</p><p>我们有一个注册的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/sign-up&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">signUp</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> UserRegisterRequest userRegisterRequest)</span> </span>&#123;<br>  userService.save(userRegisterRequest);<br>  <span class="hljs-keyword">return</span> ResponseEntity.ok().build();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>UserRegisterRequest</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRegisterRequest</span> </span>&#123;<br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-keyword">private</span> String fullName;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发送 post 请求到这个接口，并且 body 携带 JSON 数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;userName&quot;</span>:<span class="hljs-string">&quot;coder&quot;</span>,<span class="hljs-attr">&quot;fullName&quot;</span>:<span class="hljs-string">&quot;shuangkou&quot;</span>,<span class="hljs-attr">&quot;password&quot;</span>:<span class="hljs-string">&quot;123456&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>这样我们的后端就可以直接把 json 格式的数据映射到我们的 <code>UserRegisterRequest</code> 类上。</p><p>👉 需要注意的是：<strong>一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个<code>@RequestParam</code>和<code>@PathVariable</code></strong>。 如果你的方法必须要用两个 <code>@RequestBody</code>来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！</p><h3 id="requestparam-和-requestbody"><span class="citation" data-cites="RequestParam">@RequestParam</span> 和 <span class="citation" data-cites="RequestBody">@RequestBody</span></h3><ol type="1"><li><p>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。</p></li><li><p>当同时使用@RequestParam 和@RequestBody时，<span class="citation" data-cites="RequestParam">@RequestParam</span> 定的参数可以是普通元素、数组、集合、对象等等(即:当@RequestBody 与@RequestParam同时使用时，原SpringMVC接收参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收)。</p><p>即：如果参数时放在请求体中，application/json传入后台的话，那么后台要用@RequestBody才能接收到；如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收，或者形参前 什么也不写也能接收。</p></li></ol><blockquote><p>详细的例子可以<a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/80972817">看这里。</a></p></blockquote><h1 id="读取配置信息">5. 读取配置信息</h1><p>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</p><p>下面我们来看一下 Spring 为我们提供了哪些方式帮助我们从配置文件中读取这些配置信息。</p><p>我们的数据源<code>application.yml</code>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">wuhan2020:</span> <span class="hljs-number">2020</span><span class="hljs-string">年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！</span><br><br><span class="hljs-attr">my-profile:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Guide哥</span><br>  <span class="hljs-attr">email:</span> <span class="hljs-string">koushuangbwcx@163.com</span><br><br><span class="hljs-attr">library:</span><br>  <span class="hljs-attr">location:</span> <span class="hljs-string">湖北武汉加油中国加油</span><br>  <span class="hljs-attr">books:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">天才基本法</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">时间的秩序</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">了不起的我</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？</span> <span class="hljs-string">如何走出人生的艰难时刻？</span><br></code></pre></td></tr></table></figure><h2 id="value常用">5.1. <code>@Value</code>(常用)</h2><p>通过在properties文件中自定义一个属性，给这个属性赋值为有可能改变的值。使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息：</p><blockquote><p>单独举例子</p></blockquote><ol type="1"><li><p>properties文件中自定义属性:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">   # 自定义一个属性，然后用哪个打开那个的属性即可</span><br>   <span class="hljs-meta">use.indicator.value</span> = <span class="hljs-string">indicator_value</span><br><span class="hljs-comment">   # use.indicator.value = indicator_revise_value</span><br><br><span class="hljs-meta">2.</span> <span class="hljs-string">代码中使用@Value()注解创建Bean对象:</span><br><br>   <span class="hljs-attr">```java</span><br>   <span class="hljs-attr">@Value(&quot;$&#123;use.indicator.value&#125;&quot;)</span><br>   <span class="hljs-attr">private</span> <span class="hljs-string">String userIndicatorValue;</span><br></code></pre></td></tr></table></figure></li><li><p>然后再使用该对象即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;userIndicatorValue&quot;</span> + userIndicatorValue);<br></code></pre></td></tr></table></figure></li><li><p>输出结果:</p><figure><img src="C:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20221205141817300.png" srcset="/img/loading.gif" lazyload alt="image-20221205141817300"><figcaption>image-20221205141817300</figcaption></figure></li></ol><p>需要注意的是<code>@value</code>这种方式是不被推荐的，Spring 比较建议的是下面几种读取配置信息的方式。</p><h2 id="configurationproperties常用">5.2. <code>@ConfigurationProperties</code>(常用)</h2><blockquote><p><code>LibraryProperties</code>类上加了<code>@Component</code>注解，我们可以像使用普通 bean 一样将其注入到类中使用。(开始的例子)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Getter;<br><span class="hljs-keyword">import</span> lombok.Setter;<br><span class="hljs-keyword">import</span> lombok.ToString;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LibraryProperties</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String location;<br>    <span class="hljs-keyword">private</span> List&lt;Book&gt; books;<br><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@ToString</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>        String name;<br>        String description;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候你就可以像使用普通 bean 一样，将其注入到类中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javaguide.readconfigproperties;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.InitializingBean;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br>publicclass ReadConfigPropertiesApplication implements InitializingBean &#123;<br><br>    privatefinal LibraryProperties library;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadConfigPropertiesApplication</span><span class="hljs-params">(LibraryProperties library)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.library = library;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ReadConfigPropertiesApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(library.getLocation());<br>        System.out.println(library.getBooks());    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">湖北武汉加油中国加油<br><span class="hljs-meta">[</span>LibraryProperties.Book(name=天才基本法, description<span class="hljs-params">...</span><span class="hljs-params">...</span>..<span class="hljs-meta">]</span><br></code></pre></td></tr></table></figure><h3 id="通过configurationproperties读取并校验">通过<code>@ConfigurationProperties</code>读取并校验</h3><p>我们先将<code>application.yml</code>修改为如下内容，明显看出这不是一个正确的 email 格式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">my-profile:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Guide哥</span><br>  <span class="hljs-attr">email:</span> <span class="hljs-string">koushuangbwcx@</span><br></code></pre></td></tr></table></figure><blockquote><p><code>ProfileProperties</code>类没有加<code>@Component</code>注解。我们在我们要使用<code>ProfileProperties</code>的地方使用<code>@EnableConfigurationProperties</code>注册我们的配置 bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Getter;<br><span class="hljs-keyword">import</span> lombok.Setter;<br><span class="hljs-keyword">import</span> lombok.ToString;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.validation.annotation.Validated;<br><br><span class="hljs-keyword">import</span> javax.validation.constraints.Email;<br><span class="hljs-keyword">import</span> javax.validation.constraints.NotEmpty;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;my-profile&quot;)</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileProperties</span> </span>&#123;<br>   <span class="hljs-meta">@NotEmpty</span><br>   <span class="hljs-keyword">private</span> String name;<br><br>   <span class="hljs-meta">@Email</span><br>   <span class="hljs-meta">@NotEmpty</span><br>   <span class="hljs-keyword">private</span> String email;<br><br>   <span class="hljs-comment">//配置文件中没有读取到的话就用默认值</span><br>   <span class="hljs-keyword">private</span> Boolean handsome = Boolean.TRUE;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javaguide.readconfigproperties;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.InitializingBean;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableConfigurationProperties(ProfileProperties.class)</span><br>publicclass ReadConfigPropertiesApplication implements InitializingBean &#123;<br>    privatefinal ProfileProperties profileProperties;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadConfigPropertiesApplication</span><span class="hljs-params">(ProfileProperties profileProperties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.profileProperties = profileProperties;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ReadConfigPropertiesApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(profileProperties.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们的邮箱格式不正确，所以程序运行的时候就报错，根本运行不起来，保证了数据类型的安全性：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Binding to target org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.properties</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.BindException</span>: Failed to bind properties under <span class="hljs-string">&#x27;my-profile&#x27;</span> to cn<span class="hljs-selector-class">.javaguide</span><span class="hljs-selector-class">.readconfigproperties</span><span class="hljs-selector-class">.ProfileProperties</span> failed:<br><br>    Property: my-profile.email<br>    Value: koushuangbwcx@<br>    Origin: class path resource [application.yml]:<span class="hljs-number">5</span>:<span class="hljs-number">10</span><br>    Reason: must be <span class="hljs-selector-tag">a</span> well-formed email address<br></code></pre></td></tr></table></figure><p>我们把邮箱测试改为正确的之后再运行，控制台就能成功打印出读取到的信息：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">ProfileProperties</span>(name=Guide哥, email=koushuangbwcx<span class="hljs-variable">@163</span>.com, handsome=true)<br></code></pre></td></tr></table></figure><h2 id="propertysource不常用">5.3. <code>@PropertySource</code>（不常用）</h2><p><code>@PropertySource</code>读取指定 properties 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:website.properties&quot;)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSite</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br><br>    省略getter/setter<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> WebSite webSite;<br><br>System.out.println(webSite.getUrl());<span class="hljs-comment">//https://javaguide.cn/</span><br></code></pre></td></tr></table></figure><h1 id="参数校验">6. 参数校验</h1><hr><p>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。</p><blockquote><p><strong>JSR(Java Specification Requests）</strong> 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，非常方便！</p><p>校验的时候我们实际用的是 <strong>Hibernate Validator</strong> 框架。SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。</p><p><strong>注</strong>：更新版本的 spring-boot-starter-web 依赖中不再有 hibernate-validator 包（如2.3.11.RELEASE），需要自己引入 <code>spring-boot-starter-validation</code> 依赖。</p></blockquote><h2 id="一些常用的字段验证的注解">6.1. 一些常用的字段验证的注解</h2><ul><li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li><li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</li><li><code>@Null</code> 被注释的元素必须为 null</li><li><code>@NotNull</code> 被注释的元素必须不为 null</li><li><code>@AssertTrue</code> 被注释的元素必须为 true</li><li><code>@AssertFalse</code> 被注释的元素必须为 false</li><li><code>@Pattern(regex=,flag=)</code> 被注释的元素必须符合指定的正则表达式</li><li><code>@Email</code> 被注释的元素必须是 Email 格式。</li><li><code>@Min(value)</code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@Max(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@DecimalMin(value)</code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@Size(max=, min=)</code> 被注释的元素的大小必须在指定的范围内</li><li><code>@Digits(integer, fraction)</code> 被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li><code>@Past</code> 被注释的元素必须是一个过去的日期</li><li><code>@Future</code> 被注释的元素必须是一个将来的日期</li><li>......</li></ul><h2 id="验证请求体requestbody">6.2. 验证请求体(RequestBody)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-meta">@NotNull(message = &quot;classId 不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String classId;<br><br>    <span class="hljs-meta">@Size(max = 33)</span><br>    <span class="hljs-meta">@NotNull(message = &quot;name 不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Pattern(regexp = &quot;((^Man$|^Woman$|^UGM$))&quot;, message = &quot;sex 值不在可选范围&quot;)</span><br>    <span class="hljs-meta">@NotNull(message = &quot;sex 不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-meta">@Email(message = &quot;email 格式不正确&quot;)</span><br>    <span class="hljs-meta">@NotNull(message = &quot;email 不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String email;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>正则表达式说明：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby"> ^string : 匹配以 string 开头的字符串</span><br><span class="ruby">- string<span class="hljs-variable">$ </span>：匹配以 string 结尾的字符串</span><br><span class="ruby">- ^string<span class="hljs-variable">$ </span>：精确匹配 string 字符串</span><br><span class="ruby">- ((^Man<span class="hljs-variable">$|</span>^Woman<span class="hljs-variable">$|</span>^UGM<span class="hljs-variable">$)</span>) : 值只能在 Man,Woman,UGM 这三个值中选择</span><br></code></pre></td></tr></table></figure><p>我们在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出 <code>MethodArgumentNotValidException</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonController</span> </span>&#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/person&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Person&gt; <span class="hljs-title">getPerson</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok().body(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="验证请求参数pathvariable-和-requestparam">6.3. 验证请求参数(<span class="citation" data-cites="PathVariable">@PathVariable</span> 和 <span class="citation" data-cites="RequestParam">@RequestParam</span>)</h2><p><strong>一定一定不要忘记在类上加上 <code>@Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api&quot;)</span><br><span class="hljs-meta">@Validated</span><br>publicclass PersonController &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/person/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="hljs-title">getPersonByID</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-meta">@Max(value = 5,message = &quot;超过 id 的范围了&quot;)</span> Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok().body(id);<br>    &#125;<br><br>    <span class="hljs-meta">@PutMapping(&quot;/person&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">getPersonByName</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> <span class="hljs-meta">@Size(max = 6,message = &quot;超过 name 的范围了&quot;)</span> String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok().body(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更多关于如何在 Spring 项目中进行参数校验的内容，请看《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485783&amp;idx=1&amp;sn=a407f3b75efa17c643407daa7fb2acd6&amp;chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&amp;token=292197051&amp;lang=zh_CN#rd">如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！open in new window</a>》这篇文章</p><h1 id="全局处理-controller-层异常">7. 全局处理 Controller 层异常</h1><p>相关注解：</p><ol type="1"><li><code>@ControllerAdvice</code> ：注解定义全局异常处理类</li><li><code>@ExceptionHandler</code> ：注解声明异常处理方法</li></ol><p>如何使用呢？拿我们在第 5 节参数校验这块来举例子。如果方法参数不对的话就会抛出<code>MethodArgumentNotValidException</code>，我们来处理这个异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求参数异常处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) &#123;<br>       ......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更多关于 Spring Boot 异常处理的内容，请看我的这两篇文章：</p><ol type="1"><li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485568&amp;idx=2&amp;sn=c5ba880fd0c5d82e39531fa42cb036ac&amp;chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&amp;token=2133161636&amp;lang=zh_CN#rd">SpringBoot 处理异常的几种常见姿势open in new window</a></li><li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486379&amp;idx=2&amp;sn=48c29ae65b3ed874749f0803f0e4d90e&amp;chksm=cea24460f9d5cd769ed53ad7e17c97a7963a89f5350e370be633db0ae8d783c3a3dbd58c70f8&amp;token=1054498516&amp;lang=zh_CN#rd">使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！</a></li></ol><hr></div><hr><div><div class="post-metas mb-3"></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处来源：<a href="https://stuxiaozhang.github.io/">小张的宇宙空间站</a></p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2022/12/04/aa/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile"></span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/11/01/Spring%20%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"><span class="hidden-mobile">Spring 基础总结</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",function(){var e=Object.assign({appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:"https://cdn.bootcdn.net/ajax/libs/emojione/4.5.0/lib/js/emojione.min.js",emojiMaps:null,enableQQ:!0,requiredFields:["nick"]},{el:"#valine",path:window.location.pathname});new Valine(e)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://stuxiaozhang.github.io" target="_blank" rel="nofollow noopener"><span>小张同学的宇宙空间站</span></a> 已经运转了<span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{renderActions:{findScript:[10,a=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const n=new a.options.MathItem(e.textContent,a.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),n.start={node:t,delim:"",n:0},n.end={node:t,delim:"",n:0},a.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>