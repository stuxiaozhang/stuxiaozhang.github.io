<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><link rel="icon" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="RENAS: Reinforced Evolutionary Neural Architecture Search

CVPR 2019

论文提出了强化进化神经架构搜索（RENAS），它将RL集成到进化框架中以解决RL和EA问题。RENAS引入了一个reinforced mutation controller来帮助探索搜索空间。由于EA的性质，子模型可以从其父模型继承大多数参数，从而使搜"><meta name="author" content="小张同学"><meta name="keywords" content=""><title>【RENAS】Reinforced Evolutionary Neural Architecture Search - 小张同学的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",app_key:"CgnvRL262D07ied40NiXm2VL",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><header style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>xiaozhang's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/schedule/"><i class="iconfont icon-cliplist"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150632.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="【RENAS】Reinforced Evolutionary Neural Architecture Search"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 小张同学 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-10 08:24" pubdate>2022年8月10日</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 21 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-1"></div><div class="col-lg-9 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">【RENAS】Reinforced Evolutionary Neural Architecture Search</h1><p class="note note-info">本文最后更新于：2022年8月11日</p><div class="markdown-body"><h1 id="renas-reinforced-evolutionary-neural-architecture-search">RENAS: Reinforced Evolutionary Neural Architecture Search</h1><ul><li>CVPR 2019</li></ul><p>论文提出了强化进化神经架构搜索（RENAS），它将RL集成到进化框架中以解决RL和EA问题。RENAS引入了一个reinforced mutation controller来帮助探索搜索空间。由于EA的性质，子模型可以从其父模型继承大多数参数，从而使搜索更加有效。主要贡献总结如下：</p><ol type="1"><li>提出了一种新的神经结构搜索框架RENAS，将EA和RL相结合。该框架综合了两者的优点，保证了搜索效率。</li><li>设计了一个强化变异控制器来学习轻微修改的效果，并采取行动来指导进化。这有助于种群在更少的迭代中进化到更好的状态。</li><li>发现了一个神经网络结构RENASNet</li></ol><h2 id="background">Background</h2><p>EA-based NAS的局限性：对于EA-based NAS，它倾向于进化一个体系结构的种群，以确保潜在结果的多样性。然而，由于进化过程严重依赖于随机不可控突变，因此<strong>EA的进化过程缓慢。</strong>例如，AmoebaNet通过基于EA的方法进行搜索，其最终结果优于RL生成的NASNet。但在相同的搜索空间中，AmoebaNet比NASNet使用更多的计算资源。</p><p>RL-based NAS的局限性：它依赖超参数来保证稳定性。但在逐层确定架构时，RL控制器需要尝试数十种操作，以获得作为监控信号的正奖励。训练和评估单个模型，非常耗时。</p><hr><p>作者将mutation controller集成到进化框架中，以学习修改的效果并做出合理的变异动作。与仅RL方法和仅EA方法相比，这种集成有以下好处：</p><ol type="1"><li>RL训练变得更有效。因为对网络进行修改所需的操作比逐层构建模型要少得多。由于子模型是从父模型修改而来的，变异控制器很容易学习细微差异的影响。</li><li>在reinforced mutation controller的帮助下，进化过程变得更加高效和稳定。模型架构及其验证精度以前被忽略，但在进化过程中产生了有价值的提示。作者重用这些有用的监控信号来训练mutation controller。反过来，它消除了有害突变的积累。</li></ol><h2 id="search-space">Search Space</h2><h3 id="block">Block</h3><p>图2右侧显示，每个block中，将两个输入 <span class="math inline">\(\{i_1,i_2\}\)</span> 分别通过两种操作 <span class="math inline">\(\{o_1,o_2\}\)</span> ，然后通过element-wise addition <span class="math inline">\(A\)</span> 结合成一个输出 <span class="math inline">\(O\)</span>。所以每个block可以表示为长度为4的字符串 <span class="math inline">\(\{i_1,i_2,o_1,o_2\}\)</span>。</p><p><span class="math inline">\(\{i_1,i_2\}\)</span> 从 <span class="math inline">\(\left\{O_{1}^{c}, O_{2}^{c}, \ldots, O_{b-1}^{c}, O_{B}^{c-1}, O_{B}^{c-2}\right\}\)</span> 中选择，<span class="math inline">\(O_{1}^{c},..., O_{2}^{c}\)</span> 是当前cell中前几个block的输出，而 <span class="math inline">\(O_{B}^{c-1}, O_{B}^{c-2}\)</span> 是前一个和前两个cell的输出。</p><p><span class="math inline">\(\{o_1,o_2\}\)</span> 操作可以从下列中选择：</p><ul><li>3x3 depth-wise separable convolution</li><li>5x5 depth-wise separable convolution</li><li>7x7 depth-wise separable convolution</li><li>3x3 avg pooling</li><li>3x3 max pooling</li><li>identity.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220810100628.png" srcset="/img/loading.gif" lazyload></p><h3 id="cell">Cell</h3><p>每个cell可以被表示为一个有向无环图由 B 个block组成。</p><h3 id="network">Network</h3><p>每个网络可以指定三个因素：单元结构，#N 要堆叠的单元数和 #F 第一层中的过滤器数量。在搜索过程中固定 #N 和 #F 时，搜索空间被限制在所有可能的单元结构中。搜索完成后，将构建不同大小的模型以适应各种任务或数据集。作者调整重复的单元数#N 和第一层中的过滤器数量来控制网络的深度和宽度。如图 2 (a) 所示，ImageNet 的架构还有两个步长为 2 的单元。由于 ImageNet (224x224) 中的图像尺寸远大于 CIFAR-10 (32x32) 中的图像尺寸，因此需要更多的下采样操作。</p><p>因此，每个网络都指定有 5 x #B tokens，其中 4 x #B tokens在搜索期间是可变的。因为每个cell由#B个block组成，每个block由5个tokens指定：两个输入 <span class="math inline">\(\{i_1,i_2\}\)</span> ，两个操作 <span class="math inline">\(\{o_1,o_2\}\)</span> 和一个固定为加法的组合操作 A。因此，搜索网络架构转换为搜索 4 x #B 变量。这个搜索空间小于 NASNet 搜索空间。</p><h2 id="search-strategy">Search Strategy</h2><h3 id="evolution-framework">Evolution Framework</h3><p>流程如下：首先随机初始化种群P。种群P的每个个体在训练集上进行训练，并在验证集评估，得到验证精度作为适应度值。然后开始进化，在每一个进化步骤中，采用锦标赛选择算法：从P中随机抽取一个子集S。根据其适应度值，从S中选择最佳个体B和最差个体W。W被排除在P之外，B成为父母，产生具有突变的子C。然后对C进行训练和评估，以测量其适应度。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220810112934.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><h3 id="reinforced-mutation">Reinforced Mutation</h3><p>通过mutation controller实现Reinforced Mutation，以学习轻微修改的效果并做出变异动作。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220810090210.png" srcset="/img/loading.gif" lazyload></p><p>控制器采用长度为5#B的字符串，该字符串表示给定的cell架构。具体而言，控制器由4部分组成：</p><ol type="1"><li>Encoder <span class="math inline">\(Enc\)</span>：embedding layer后的编码器 （Enc）学习cell的每个部分的效果</li><li>Mutation-router <span class="math inline">\(Mut-rt\)</span>：从block的<span class="math inline">\(\{i_1,i_2,o_1,o_2\}\)</span>中选择一个的Mutation-router</li><li>Input-mutator <span class="math inline">\(IN-Mut\)</span>：用新输入 <span class="math inline">\(i_{new}\)</span> 改变节点的输入</li><li>OP-mutator <span class="math inline">\(OP-Mut\)</span>：用新的运算符 <span class="math inline">\(o_{new}\)</span> 改变节点的运算符。</li></ol><h4 id="encoder">1. Encoder</h4><p><span class="math inline">\(Enc\)</span> 是一种具有输入嵌入层的 Bi-RNN。<span class="math inline">\(Enc\)</span> 学习到的隐藏状态表示局部对整个网络的影响。对于Enc中的块b，其隐藏状态为 <span class="math inline">\(\left\{H_{i_{1}}^{b}, H_{i_{2}}^{b}, H_{o_{1}}^{b}, H_{o_{2}}^{b}\right\}\)</span>，其中 <span class="math inline">\(H_{o_{1}}^{b}\)</span> 表示block b的 <span class="math inline">\(o_1\)</span> 对整个网络的影响。由于每个模型由 5 x #B 个参数组成，<span class="math inline">\(Enc\)</span> 每一步生成 5 x #B 个hidden state。此外，还初始化了两个begin状态 <span class="math inline">\(H^{c-1}, H^{c-2}\)</span> 表示前一和前两个cell的信息。</p><hr><p><strong>mutation controller 的过程是这样的</strong>：对于块b，控制器按序做出两个决策。首先，根据 <span class="math inline">\(\left\{H_{i_{1}}^{b}, H_{i_{2}}^{b}, H_{o_{1}}^{b}, H_{o_{2}}^{b}\right\}\)</span>，<span class="math inline">\(Mut-rt\)</span> 决定需要修改块b中的 <span class="math inline">\(i1、i2、o1、o2\)</span> 中的哪一个。它通过softmax分类器以 Attention 机制进行采样。如果选择了一个输入 <span class="math inline">\(i_1\)</span> 或 <span class="math inline">\(i_2\)</span>，则通过 <span class="math inline">\(IN-Mut\)</span> 从 <span class="math inline">\(\left\{O_{1}^{c}, O_{2}^{c}, \ldots, O_{b-1}^{c}, O_{B}^{c-1}, O_{B}^{c-2}\right\}\)</span> 中选择一个。否则 <span class="math inline">\(OP-Mut\)</span> 将从这6个操作选项中选择一个新运算符。由于每个单元中有B个块，因此该过程将重复B次以修改给定的体系结构。因此，它对每个模型进行2#B修改动作。下面描述实现细节。</p><hr><h4 id="mutation-router">2. Mutation-router</h4><p>Mutation-router 决定需要修改块b中的 <span class="math inline">\(i1、i2、o1、o2\)</span> 中的哪一个。对于每个块，<span class="math inline">\(Mut-rt\)</span> 的输入是 Enc 输出的 <span class="math inline">\(\left\{H_{i_{1}}^{b}, H_{i_{2}}^{b}, H_{o_{1}}^{b}, H_{o_{2}}^{b}\right\}\)</span> 的子集，<span class="math inline">\(Mut-rt\)</span> 的输出是 <span class="math inline">\(i1、i2、o1、o2\)</span> 中的一个，是要突变的ID。每个隐藏状态后接全连接层，用 SOFTMAX 计算每个成分 <span class="math inline">\(\left\{P_{i_{1}}^{b}, P_{i_{2}}^{b}, P_{o_{1}}^{b}, P_{o_{2}}^{b}\right\}\)</span> 的修改概率，根据这些概率从 <span class="math inline">\(i1、i2、o1、o2\)</span> 中采样一个。</p><h4 id="in-mutator">3. IN-mutator</h4><p>如果选中 <span class="math inline">\(I D \in\left(i_{1}, i_{2}\right)\)</span>，则为节点选择一个新输入。输入包括：所选ID的隐藏状态 <span class="math inline">\(H_{ID}^{1}\)</span>、所有先前blocks的输出的隐藏状态 <span class="math inline">\(\left[H_{A}^{1}, \ldots, H_{A}^{b-1}\right]\)</span> 和 前cell和前前cell的隐藏状态 <span class="math inline">\(H^{c-1}, H^{c-2}\)</span>。concate <span class="math inline">\(\left[H_{ID}^{1};H_{A}^{1}, \ldots, H_{A}^{b-1}, H^{c-1}, H^{c-2}\right]\)</span> 然后接全连接层。</p><p>与 <span class="math inline">\(Mut-rt\)</span> 类似，用softmax计算上面的概率来替换原始输入的概率，然后通过从 <span class="math inline">\(1,…,b-1,c-1,c-2\)</span> 中选择这些概率来确定新输入 <span class="math inline">\(i_{new}\)</span> 。</p><h4 id="op-mutator">4. OP-mutator</h4><p><span class="math inline">\(OP-Mut\)</span> 根据输入的 <span class="math inline">\(H_{ID}^{1}\)</span> 输出一个新的运算符 <span class="math inline">\(o_{new}\)</span> 。这个过程类似于<span class="math inline">\(Mut-rt\)</span> 。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220810165801.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><blockquote><p>我的理解是 mutation controller 先把各种输入输出转为嵌入向量，然后通过注意力机制寻找一个向量，作者没有详细说是什么样的向量。然后对这个进行突变。。。。</p></blockquote><h3 id="search-details">Search Details</h3><h4 id="controller">Controller</h4><p>在每个进化步骤中，Controller都会做出一系列变异动作。然后生成修改了父模型的子模型C。然后，使用参数继承计算验证精度 <span class="math inline">\(f_C\)</span>，该参数继承将在下一段中介绍。奖励 <span class="math inline">\(γ\)</span> 是 <span class="math inline">\(f_C\)</span>的非线性函数， <span class="math inline">\(\gamma=\tan \left(f_{C} \cdot \frac{\pi}{2}\right)\)</span>，因为提高精度的增益应该更大，而其父项的验证精度更高。通过策略梯度更新控制器参数θ。</p><h4 id="child-models">Child Models</h4><p>子模型通过从父模型继承的参数进行训练和评估。对于种群中的每个模型B，存储其结构字符串、适应度<span class="math inline">\(f_B\)</span>及其可学习参数<span class="math inline">\(ω_B\)</span>。由于每个子模型C都是从其父模型生成的，只需稍加修改，因此它们之间的差异仅存在于突变层中。因此，子级可以从父级B继承大多数参数。</p><p><span class="math inline">\(ω_C\)</span>分为可继承参数<span class="math inline">\(ω^C_{inh}\)</span>和新初始化参数<span class="math inline">\(ω^C_{new}\)</span>。并且其适合度<span class="math inline">\(f_C\)</span>可以通过微调而不是从头开始的训练来评估。在微调过程中，我们以<span class="math inline">\(ω^C_{new}\)</span>的学习率是<span class="math inline">\(ω^C_{inh}\)</span>的10倍的学习率通过<span class="math inline">\(D_{train}\)</span>对<span class="math inline">\(ω_C\)</span>进行整体训练。实验中，<span class="math inline">\(ω^C_{new}\)</span>的学习率等于0.01。</p><h4 id="deriving-architectures">Deriving Architectures</h4><p>在搜索过程中，将每个单元设置为包含#B=5个块，在第一个卷积单元中设置#F=24个滤波器，并将单元展开为#N=2。在达到最大迭代数#E后，仅从头开始重新训练总体中的模型，然后以最高精度获取模型。通过从头开始重新训练更多采样模型可以改进结果，但要证明我们控制器的性能是不公平的。在实验中，种群大小#P设置为20。为了更好的比较，我们将#F和#N设置为与NASNets相同。</p><h2 id="experiments">Experiments</h2><p>RENASNet结构如下：（1个cell）</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811095406.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p><h3 id="results-on-cifar-10">Results on CIFAR-10</h3><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811094948.png" srcset="/img/loading.gif" lazyload></p><p>RENASNet 的准确率和其他先进模型差不多。</p><p>只有NASNet-A和AmoebaNet的性能比RENASNet稳定且更好，而它们使用的计算资源比我们的要多得多。ENAS比我们的方法更有效，但我们的模型参数更少，精度更高。</p><h3 id="results-on-cifar-10-1">Results on CIFAR-10</h3><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811094953.png" srcset="/img/loading.gif" lazyload></p><h3 id="search-efficiency">Search Efficiency</h3><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811100402.png" srcset="/img/loading.gif" lazyload style="zoom:33%"></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Papers/">Papers</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/RENAS/">RENAS</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处来源：<a href="https://stuxiaozhang.github.io/">小张的宇宙空间站</a></p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2022/08/12/nsga/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">【NSGA-Net】Neural Architecture Search using Multi-Objective Genetic Algorithm</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/08/09/%E3%80%90Hierarchical%20Representations%E3%80%91Hierarchical%20Representations%20For%20Efficient%20Architecture%20Search/"><span class="hidden-mobile">【Hierarchical Representations】Hierarchical Representations For Efficient Architecture Search</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",function(){var e=Object.assign({appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:"https://cdn.bootcdn.net/ajax/libs/emojione/4.5.0/lib/js/emojione.min.js",emojiMaps:null,enableQQ:!0,requiredFields:["nick"]},{el:"#valine",path:window.location.pathname});new Valine(e)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://stuxiaozhang.github.io" target="_blank" rel="nofollow noopener"><span>小张同学的宇宙空间站</span></a> 已经运转了<span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{renderActions:{findScript:[10,a=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const n=new a.options.MathItem(e.textContent,a.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),n.start={node:t,delim:"",n:0},n.end={node:t,delim:"",n:0},a.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>