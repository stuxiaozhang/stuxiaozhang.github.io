<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><link rel="icon" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="Redis笔记Redis 是典型的 NoSQL 数据库。是一个开源的 key-value 存储系统。

和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string、list、set、zset、sorted set、hash。

这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。

在此基础上，Red"><meta name="author" content="小张同学"><meta name="keywords" content=""><title>Redis笔记 - 小张同学的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",app_key:"CgnvRL262D07ied40NiXm2VL",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><header style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>xiaozhang's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/schedule/"><i class="iconfont icon-cliplist"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150632.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Redis笔记"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 小张同学 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-03 09:33" pubdate>2022年8月3日</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 85 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-1"></div><div class="col-lg-9 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Redis笔记</h1><p class="note note-info">本文最后更新于：2022年8月5日</p><div class="markdown-body"><h1 id="Redis笔记"><a href="#Redis笔记" class="headerlink" title="Redis笔记"></a>Redis笔记</h1><p><strong><em>Redis</em></strong> 是典型的 <strong><em>NoSQL</em></strong> 数据库。是一个开源的 <strong><em>key-value</em></strong> 存储系统。</p><ul><li><p>和 <strong><em>Memcached</em></strong> 类似，它支持存储的 <strong><em>value</em></strong> 类型相对更多，包括 <strong><em>string、list、set、zset、sorted set、hash</em></strong>。</p></li><li><p>这些数据类型都支持 <strong><em>push/pop、add/remove</em></strong> 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p></li><li><p>在此基础上，<strong><em>Redis</em></strong> 支持各种不同方式的排序。</p></li><li><p>与 <strong><em>memcached</em></strong>一样，为了保证效率，数据都是缓存在内存中。</p></li><li><p>区别的是 <strong><em>Redis</em></strong> 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p></li><li><p>并且在此基础上实现了<strong><em>master-slave</em></strong> （主从）同步。</p></li><li><p>单线程 + <strong><em>IO</em></strong> 多路复用。</p><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p></li><li><p><strong>串行 vs 多线程 + 锁（memcached） vs 单线程 + 多路 IO 复用 (Redis)</strong>（与 Memcache 三点不同：支持多数据类型，支持持久化，单线程 + 多路 IO 复用） 。</p></li><li><p>Redis优点：</p><ul><li>打破传统关系型数据库以业务逻辑为依据的存储模式，而针对不同数据结构类型改为以性能为最优先的存储方式。</li><li><p>减少CPU、IO压力，通过内存读取</p></li><li><p>NoSQL能够直接作为缓存使用，减少IO的读操作</p></li></ul></li></ul><h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><blockquote><p>安装 <strong><em>C</em></strong> 语言的编译环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install centos-release-scl scl-utils-build<br>yum install -y devtoolset-8-toolchain<br>scl <span class="hljs-built_in">enable</span> devtoolset-8 bash<br></code></pre></td></tr></table></figure><p>通过 <strong><em>wget</em></strong> 下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://download.redis.io/releases/redis-6.2.6.tar.gz<br><br>// 下载路径：/opt<br></code></pre></td></tr></table></figure><p>解压至当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf redis-6.2.6.tar.gz <br></code></pre></td></tr></table></figure><p>解压完成后进入目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis-6.2.6<br></code></pre></td></tr></table></figure><p>在当前目录下执行 <strong><em>make</em></strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> &amp;&amp; <span class="hljs-built_in">make</span> install<br></code></pre></td></tr></table></figure><p>默认安装在 <code>/usr/local/bin</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何<br>redis-<span class="hljs-keyword">check</span>-aof：修复有问题的AOF文件，rdb和aof后面讲<br>redis-<span class="hljs-keyword">check</span>-dump：修复有问题的dump.rdb文件<br>redis-sentinel：Redis集群使用<br>redis-<span class="hljs-keyword">server</span>：Redis服务器启动命令<br>redis-cli：客户端，操作入口<br></code></pre></td></tr></table></figure><p>前台启动：<code>/usr/local/bin</code> 目录下启动 <strong><em>redis</em></strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">redis-server</span><span class="hljs-params">(前台启动)</span></span><br></code></pre></td></tr></table></figure><p>后台启动：</p><ul><li><p>安装 <strong><em>redis</em></strong> 的目录 <strong><em>/opt/redis-6.2.6</em></strong> 中将 <strong><em>redis.conf</em></strong> 复制到任意一个文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp redis.conf /etc/redis.conf<br>// 将redis.conf复制到/etc/下<br></code></pre></td></tr></table></figure></li><li><p>修改 <strong><em>/etc/redis.conf</em></strong> 配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">vim</span> <span class="hljs-string">redis.conf#</span> <span class="hljs-string">daemonize</span> <span class="hljs-literal">no</span> <span class="hljs-string">修改为</span> <span class="hljs-string">daemonize</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241224181.png" srcset="/img/loading.gif" lazyload alt=""></p></li><li><p><strong><em>/usr/local/bin</em></strong> 目录下启动 <strong><em>redis</em></strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">redis-server <span class="hljs-regexp">/etc/</span>redis.conf<br></code></pre></td></tr></table></figure></li></ul><p>关闭 <strong><em>redis</em></strong></p><ul><li><strong><em>kill</em></strong> 进程</li><li>命令 <strong><em>shutdown</em></strong></li></ul></blockquote><p><u><strong>默认端口号：6379</strong></u></p><h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><p><strong><em>NoSQL（Not Only SQL）</em></strong> ，非关系型数据库</p><p><strong><em>NoSQL</em></strong> 不依赖业务逻辑方式存储，而以简单的 <strong><em>key-value</em></strong> 模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循 <strong><em>SQL</em></strong> 标准。</li><li>不支持 <strong><em>ACID</em></strong>。</li><li>远超于 <strong><em>SQL</em></strong> 的性能。</li></ul><p><strong>适用于的场景</strong></p><ul><li>对数据高并发的读写；</li><li>海量数据的读写；</li><li>对数据高可扩展性的。</li></ul><p><strong>不适用的场景</strong></p><ul><li>需要事务支持；</li><li>基于 <strong><em>sql</em></strong> 的结构化查询存储，处理复杂的关系，需要即席查询。</li></ul><p>常见的 <strong><em>NoSQL</em></strong> 数据库</p><ul><li>Redis</li><li>MongoDB</li></ul><p>Redis 使用的是<strong>单线程 + 多路 IO 复用</strong>技术：</p><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p><p>串行 vs <u>多线程 + 锁（memcached）</u> vs <u>单线程 + 多路 IO 复用 (Redis)</u>（与 Memcache 三点不同：<strong>Redis支持多数据类型；支持持久化；单线程 + 多路 IO 复用</strong>） 。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><strong><em>redis.conf</em></strong></p><h2 id="Units"><a href="#Units" class="headerlink" title="Units"></a><strong><em>Units</em></strong></h2><blockquote><p>单位，配置大小单位，开头定义了一些基本的度量单位，只支持 <strong><em>bytes</em></strong>，不支持 <strong><em>bit</em></strong>。</p><p>大小写不敏感。</p></blockquote><p><a target="_blank" rel="noopener" href="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230368.png"><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230368.png" srcset="/img/loading.gif" lazyload alt="img"></a></p><h2 id="INCLUDES"><a href="#INCLUDES" class="headerlink" title="INCLUDES"></a><strong><em>INCLUDES</em></strong></h2><blockquote><p>包含，多实例的情况可以把公用的配置文件提取出来。</p></blockquote><p><a target="_blank" rel="noopener" href="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230370.png"><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230370.png" srcset="/img/loading.gif" lazyload alt="img"></a></p><h2 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a><strong><em>NETWORK</em></strong></h2><blockquote><p>网络相关配置。</p><p><strong><em>bind</em></strong></p><p>默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。</p><p>不写的情况下，无限制接受任何 <strong><em>ip</em></strong> 地址的访问。</p><p>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，所以需要将其注释掉。</p><p>如果开启了<strong><em>protected-mode</em></strong>，那么在没有设定 <strong><em>bind ip</em></strong> 且没有设密码的情况下，<strong><em>Redis</em></strong> 只允许接受本机的响应。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241231037.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>protected-mode</em></strong></p><p>将本机访问保护模式设置 <strong><em>no</em></strong>。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241232546.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>port</em></strong></p><p>端口号，默认 <strong><em>6379</em></strong>。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241232526.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>tcp-backlog</em></strong></p><p>设置 <strong><em>tcp</em></strong> 的 <strong><em>backlog</em></strong>，<strong><em>backlog</em></strong> 其实是一个连接队列，<strong><em>backlog</em></strong> 队列总和 $=$ 未完成三次握手队列 $+$ 已经完成三次握手队列。</p><p>在高并发环境下你需要一个高 <strong><em>backlog</em></strong> 值来避免慢客户端连接问题。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241233656.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>timeout</em></strong></p><p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241233384.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>tcp-keepalive</em></strong></p><p>对访问客户端的一种心跳检测，每个 <strong><em>n</em></strong> 秒检测一次。</p><p>单位为秒，如果设置为 0，则不会进行 <strong><em>Keepalive</em></strong> 检测，建议设置成 60。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241234246.png" srcset="/img/loading.gif" lazyload alt="img"></p></blockquote><h2 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a><strong><em>GENERAL</em></strong></h2><blockquote><p>通用。</p><p><strong><em>daemonize</em></strong></p><p>是否为后台进程，设置为 <strong><em>yes</em></strong>。</p><p>守护进程，后台启动。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241235837.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>pidfile</em></strong></p><p>存放 <strong><em>pid</em></strong> 文件的位置，每个实例会产生一个不同的 <strong><em>pid</em></strong> 文件。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241235968.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>loglevel</em></strong></p><p>指定日志记录级别，<strong><em>Redis</em></strong> 总共支持四个级别：<strong><em>debug、verbose、notice、warning</em></strong>，默认为 <strong><em>notice</em></strong>。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241235383.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>logfile</em></strong></p><p>日志文件名称。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241236971.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>database</em></strong></p><p>设定库的数量 默认16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 <strong><em>id</em></strong>。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241236379.png" srcset="/img/loading.gif" lazyload alt="img"></p></blockquote><h2 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a><strong><em>SECURITY</em></strong></h2><blockquote><p>安全。</p><p>访问密码的查看、设置和取消。</p><p>在命令中设置密码，只是临时的。重启 <strong><em>redis</em></strong> 服务器，密码就还原了。</p><p>永久设置，需要在配置文件中进行设置。</p></blockquote><h2 id="LIMITS"><a href="#LIMITS" class="headerlink" title="LIMITS"></a><strong><em>LIMITS</em></strong></h2><blockquote><p>限制。</p><p><strong><em>maxclients</em></strong></p><p>设置 <strong><em>redis</em></strong> 同时可以与多少个客户端进行连接。</p><p>默认情况下为 <strong><em>10000</em></strong> 个客户端。</p><p>如果达到了此限制，<strong><em>redis</em></strong> 则会拒绝新的连接请求，并且向这些连接请求方发出 <strong><em>max number of clients reached</em></strong> 以作回应。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241237488.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>maxmemory</em></strong></p><p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p><p>设置 <strong><em>redis</em></strong> 可以使用的内存量。一旦到达内存使用上限，<strong><em>redis</em></strong> 将会试图移除内部数据，移除规则可以通过 <strong><em>maxmemory-policy</em></strong> 来指定。</p><p>如果 <strong><em>redis</em></strong> 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 <strong><em>redis</em></strong> 则会针对那些需要申请内存的指令返回错误信息，比如 <strong><em>SET、LPUSH</em></strong> 等。</p><p>但是对于无内存申请的指令，仍然会正常响应，比如 <strong><em>GET</em></strong> 等。如果你的 <strong><em>redis</em></strong> 是主 <strong><em>redis</em></strong>（ 说明你的 <strong><em>redis</em></strong> 有从 <strong><em>redis</em></strong> ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241237150.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>maxmemory-policy</em></strong></p><p><strong><em>volatile-lru</em></strong>：使用 <strong><em>LRU</em></strong> 算法移除 <strong><em>key</em></strong>，只对设置了过期时间的键（最近最少使用）。</p><p><strong><em>allkeys-lru</em></strong>：在所有集合 <strong><em>key</em></strong> 中，使用 <strong><em>LRU</em></strong> 算法移除 <strong><em>key</em></strong>。</p><p><strong><em>volatile-random</em></strong>：在过期集合中移除随机的 <strong><em>key</em></strong>，只对设置了过期时间的键。</p><p><strong><em>allkeys-random</em></strong>：在所有集合 <strong><em>key</em></strong> 中，移除随机的 <strong><em>key</em></strong>。</p><p><strong><em>volatile-ttl</em></strong>：移除那些 <strong><em>TTL</em></strong> 值最小的 <strong><em>key</em></strong>，即那些最近要过期的 <strong><em>key</em></strong>。</p><p><strong><em>noeviction</em></strong>：不进行移除。针对写操作，只是返回错误信息。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241238328.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>maxmemory-samples</em></strong></p><p>设置样本数量，<strong><em>LRU</em></strong> 算法和最小 <strong><em>TTL</em></strong> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<strong><em>redis</em></strong> 默认会检查这么多个 <strong><em>key</em></strong> 并选择其中 <strong><em>LRU</em></strong> 的那个。</p><p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241238581.png" srcset="/img/loading.gif" lazyload alt="img"></p></blockquote><h1 id="常用五大基本数据类型"><a href="#常用五大基本数据类型" class="headerlink" title="常用五大基本数据类型"></a>常用五大基本数据类型</h1><h2 id="key操作"><a href="#key操作" class="headerlink" title="key操作"></a>key操作</h2><blockquote><p><code>keys *</code>：查看当前库所有 <strong><em>key</em></strong></p><p><code>exists key</code>：判断某个 <strong><em>key</em></strong> 是否存在</p><p><code>type key</code>：查看你的 <strong><em>key</em></strong> 是什么类型</p><p><code>del key</code> ：删除指定的 <strong><em>key</em></strong> 数据</p><p><code>unlink key</code>：根据 <strong><em>value</em></strong> 选择非阻塞删除，仅将 <strong><em>keys</em></strong> 从 <strong><em>keyspace</em></strong> 元数据中删除，真正的删除会在后续异步操作</p><p><code>expire key 10</code> ：为给定的 <strong><em>key</em></strong> 设置过期时间</p><p><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</p><p><code>select</code>：命令切换数据库</p><p><code>dbsize</code>：查看当前数据库的 <strong><em>key</em></strong> 的数量</p><p><code>flushdb</code>：清空当前库</p><p><code>flushall</code>：通杀全部库</p></blockquote><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p><strong><em>String</em></strong> 类型是二进制安全的。意味着 <strong><em>Redis</em></strong> 的 <strong><em>string</em></strong> 可以包含任何数据。比如 <strong><em>jpg</em></strong> 图片或者序列化的对象。</p><p><strong><em>String</em></strong> 类型是 <strong><em>Redis</em></strong> 最基本的数据类型，一个 <strong><em>Redis</em></strong> 中字符串 <strong><em>value</em></strong> 最多可以是 512M。</p><blockquote><p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对</p><p><code>get &lt;key&gt;</code>：查询对应键值</p><p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 <strong><em><value></value></em></strong>追加到原值的末尾</p><p><code>strlen &lt;key&gt;</code>：获得值的长度</p><p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 <strong><em>key</em></strong> 不存在时，设置 <strong><em>key</em></strong> 的值</p><p><code>incr &lt;key&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（<strong>具有原子性</strong>）</p><p><code>decr &lt;key&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1</p><p><code>incrby/decrby &lt;key&gt;&lt;步长&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值增减。自定义步长</p><p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code> ：同时设置一个或多个 <strong><em>key-value</em></strong> 对</p><p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...</code>：同时获取一个或多个 <strong><em>value</em></strong></p><p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;...</code>：同时设置一个或多个 <strong><em>key-value</em></strong> 对，当且仅当所有给定 <strong><em>key</em></strong> 都不存在。（原子性，有一个失败就都失败）</p><p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值的范围</p><p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：用 <strong><em>value</em></strong> 覆写 <strong><em>key</em></strong> 所储存的字符串值</p><p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒。</p><p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p></blockquote><p><strong>原子性</strong></p><p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作；</p><p>这种操作一旦开始，就一直运行到结束，中间不会有任何 <strong><em>context switch</em></strong> （切换到另一个线程）。</p><ul><li>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li><li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li></ul><p><strong><em>Redis</em></strong> 单命令的原子性主要得益于 <strong><em>Redis的单线程</em></strong> 。</p><p><strong>数据结构</strong></p><p>String 的数据结构为简单动态字符串，是可以修改的字符串。内部结构实现上类似于 <strong><em>Java</em></strong> 的 <strong><em>ArrayList</em></strong>，采用预分配冗余空间的方式来减少内存的频繁分配.</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803153309.png" srcset="/img/loading.gif" lazyload style="zoom:55%"></p><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p><strong><em>List</em></strong> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803182755.png" srcset="/img/loading.gif" lazyload alt=""></p><blockquote><p><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边/右边插入一个或多个值。（我想象成一个双向的栈）</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803183843.png" srcset="/img/loading.gif" lazyload alt=""></p><p><code>lpop/rpop &lt;key&gt;</code>：从左边/右边吐出一个值。值在键在，值光键亡。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803185239.png" srcset="/img/loading.gif" lazyload alt=""></p><p><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>：从 <strong><em>key1</em></strong> 列表右边吐出一个值，插到 <strong><em>key2</em></strong> 列表左边。</p><p><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>：按照索引下标获得元素（从左到右）</p><p><code>lrange mylist 0 -1 0</code>：左边第一个，-1右边第一个，（0 -1表示获取所有）</p><p><code>lindex &lt;key&gt;&lt;index&gt;</code>：按照索引下标获得元素（从左到右）</p><p><code>llen &lt;key&gt;</code>：获得列表长度</p><p><code>linsert &lt;key&gt; before/after &lt;value&gt;&lt;newvalue&gt;</code>：在 <strong><em>value</em></strong> 的前面/后面插入 <strong><em>newvalue</em></strong> 插入值</p><p><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>：从左边删除 <strong><em>n</em></strong> 个 <strong><em>value</em></strong>（从左到右）</p><p><code>ltrim &lt;key&gt;&lt;start&gt;&lt;end&gt;</code>：按照索引截取下标元素（从左到右）</p><p><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>：将列表 <strong><em>key</em></strong> 下标为 <strong><em>index</em></strong> 的值替换成 <strong><em>value</em></strong></p></blockquote><p><strong>数据结构</strong></p><p><strong><em>List</em></strong> 的数据结构为快速链表 <strong><em>quickList</em></strong>。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <strong><em>ziplist</em></strong>，也即是压缩列表。</p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成 <strong><em>quicklist</em></strong>。</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 <strong><em>int</em></strong> 类型的数据，结构上还需要两个额外的指针 <strong><em>prev</em></strong> 和 <strong><em>next</em></strong>。</p><p><strong><em>Redis</em></strong> 将链表和 <strong><em>ziplist</em></strong> 结合起来组成了 <strong><em>quicklist</em></strong>。也就是将多个 <strong><em>ziplist</em></strong> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p><strong><em>Set</em></strong> 对外提供的功能与 <strong><em>List</em></strong> 类似列表的功能，特殊之处在于 <strong><em>Set</em></strong> 是可以 <strong>自动排重</strong> 的，当需要存储一个列表数据，又不希望出现重复数据时，<strong><em>Set</em></strong> 是一个很好的选择，并且 <strong><em>Set</em></strong> 提供了判断某个成员是否在一个 <strong><em>Set</em></strong> 集合内的重要接口，这个也是 <strong><em>List</em></strong> 所不能提供的。</p><p><strong><em>Redis</em></strong> 的 <strong><em>Set</em></strong> 是 <strong><em>String</em></strong> 类型的无序集合。它底层其实是一个 <strong><em>value</em></strong> 为 <strong><em>null</em></strong> 的 <strong><em>hash</em></strong> 表，所以添加，删除，查找的复杂度都是 <strong><em>O(1)</em></strong>。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是 <strong><em>O(1)</em></strong>，数据增加，查找数据的时间不变。</p><blockquote><p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code>：将一个或多个 <strong><em>member</em></strong> 元素加入到集合 <strong><em>key</em></strong> 中，已经存在的 <strong><em>member</em></strong> 元素将被忽略</p><p><code>smembers &lt;key&gt;</code>：取出该集合的所有值。</p><p><code>sismember &lt;key&gt;&lt;value&gt;</code>：判断集合 <strong><em><key></key></em></strong>是否为含有该 <strong><em><value></value></em></strong>值，有返回 1，没有返回 0</p><p><code>scard&lt;key&gt;</code>：返回该集合的元素个数。</p><p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code>：删除集合中的某个元素</p><p><code>spop &lt;key&gt;</code>：随机从该集合中吐出一个值</p><p><code>srandmember &lt;key&gt;&lt;n&gt;</code>：随机从该集合中取出 <strong><em>n</em></strong> 个值，不会从集合中删除</p><p><code>smove &lt;source&gt;&lt;destination&gt;value</code>：把集合中一个值从一个集合移动到另一个集合</p><p><code>sinter &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的交集元素</p><p><code>sunion &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的并集元素</p><p><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的差集元素（<strong><em>key1</em></strong> 中的，不包含 <strong><em>key2</em></strong> 中的）</p></blockquote><p><strong>数据结构</strong></p><p><strong><em>Set</em></strong> 数据结构是字典，字典是用哈希表实现的。</p><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p><strong><em>Redis hash</em></strong> 是一个键值对集合。</p><p><strong><em>Redis hash</em></strong> 是一个 <strong><em>String</em></strong> 类型的 <strong><em>field</em></strong> 和 <strong><em>value</em></strong> 的映射表，<strong><em>hash</em></strong> 特别适合用于存储对象。</p><blockquote><p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给 <strong><em><key></key></em></strong>集合中的 <strong><em><field></field></em></strong>键赋值 <strong><em><value></value></em></strong></p><p><code>hget &lt;key1&gt;&lt;field&gt;</code>：从 <strong><em><key1></key1></em></strong>集合 <strong><em><field></field></em></strong>取出 <strong><em>value</em></strong></p><p><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code>： 批量设置 <strong><em>hash</em></strong> 的值</p><p><code>hexists &lt;key1&gt;&lt;field&gt;</code>：查看哈希表 <strong><em>key</em></strong> 中，给定域 <strong><em>field</em></strong> 是否存在</p><p><code>hkeys &lt;key&gt;</code>：列出该 <strong><em>hash</em></strong> 集合的所有 <strong><em>field</em></strong></p><p><code>hvals &lt;key&gt;</code>：列出该 <strong><em>hash</em></strong> 集合的所有 <strong><em>value</em></strong></p><p><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>：为哈希表 <strong><em>key</em></strong> 中的域 <strong><em>field</em></strong> 的值加上增量 1 -1</p><p><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：将哈希表 <strong><em>key</em></strong> 中的域 <strong><em>field</em></strong> 的值设置为 <strong><em>value</em></strong> ，当且仅当域 <strong><em>field</em></strong> 不存在</p></blockquote><p><strong>数据结构</strong></p><p><strong><em>Hash</em></strong> 类型对应的数据结构是两种：<strong><em>ziplist</em></strong>（压缩列表），<strong><em>hashtable</em></strong>（哈希表）。</p><p>当 <strong><em>field-value</em></strong> 长度较短且个数较少时，使用 <strong><em>ziplist</em></strong>，否则使用 <strong><em>hashtable</em></strong>。</p><h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p><strong><em>Redis</em></strong> 有序集合 <strong><em>zset</em></strong> 与普通集合 <strong><em>set</em></strong> 非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个评分（<strong><em>score</em></strong>）,这个评分（<strong><em>score</em></strong>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。</p><p>因为元素是有序的，所以可以很快的根据评分（<strong><em>score</em></strong>）或者次序（<strong><em>position</em></strong>）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p><blockquote><p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>：将一个或多个 <strong><em>member</em></strong> 元素及其 <strong><em>score</em></strong> 值加入到有序集 <strong><em>key</em></strong> 当中</p><p><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]</code>：返回有序集 <strong><em>key</em></strong> 中，下标在 <strong><em><start><stop></stop></start></em></strong>之间的元素</p><ul><li>当带 <strong><em>WITHSCORES</em></strong>，可以让分数一起和值返回到结果集</li></ul><p><code>zrangebyscore key min max [withscores] [limit offset count]</code>：返回有序集 <strong><em>key</em></strong> 中，所有 <strong><em>score</em></strong> 值介于 <strong><em>min</em></strong> 和 <strong><em>max</em></strong> 之间（包括等于 <strong><em>min</em></strong> 或 <strong><em>max</em></strong> ）的成员。有序集成员按 <strong><em>score</em></strong> 值递增（从小到大）次序排列。</p><p><code>zrevrangebyscore key max min [withscores] [limit offset count]</code>：同上，改为从大到小排列</p><p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code>：为元素的 <strong><em>score</em></strong> 加上增量</p><p><code>zrem &lt;key&gt;&lt;value&gt;</code>：删除该集合下，指定值的元素</p><p><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>：统计该集合，分数区间内的元素个数</p><p><code>zrank &lt;key&gt;&lt;value&gt;</code>：返回该值在集合中的排名，从 0 开始。</p></blockquote><p><strong>数据结构</strong></p><p><strong><em>SortedSet（zset）</em></strong>是 <strong><em>Redis</em></strong> 提供的一个非常特别的数据结构，一方面它等价于 <strong><em>Java</em></strong> 的数据结构 <strong><em>Map<string , double></string></em></strong>，可以给每一个元素 <strong><em>value</em></strong> 赋予一个权重 <strong><em>score</em></strong>，另一方面它又类似于 <strong><em>TreeSet</em></strong>，内部的元素会按照权重 <strong><em>score</em></strong> 进行排序，可以得到每个元素的名次，还可以通过 <strong><em>score</em></strong> 的范围来获取元素的列表。</p><p><strong><em>zset</em></strong> 底层使用了两个数据结构</p><ul><li><strong><em>hash</em></strong>，<strong><em>hash</em></strong> 的作用就是关联元素 <strong><em>value</em></strong> 和权重 <strong><em>score</em></strong>，保障元素 <strong><em>value</em></strong> 的唯一性，可以通过元素 <strong><em>value</em></strong> 找到相应的 <strong><em>score</em></strong> 值</li><li>跳跃表，跳跃表的目的在于给元素 <strong><em>value</em></strong> 排序，根据 <strong><em>score</em></strong> 的范围获取元素列表</li></ul><h1 id="Redis的发布与订阅"><a href="#Redis的发布与订阅" class="headerlink" title="Redis的发布与订阅"></a>Redis的发布与订阅</h1><p><strong><em>Redis</em></strong> 发布订阅（ <strong><em>pub/sub</em></strong> ）是一种消息通信模式：发送者（ <strong><em>pub</em></strong> ）发送消息，订阅者（ <strong><em>sub</em></strong> ）接收消息。</p><p><strong><em>Redis</em></strong> 客户端可以订阅任意数量的频道。</p><ol><li>客户端可以订阅频道</li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220804093321.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><ol><li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220804093351.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">subscribe channel <span class="hljs-comment"># 订阅频道</span><br><br>publish channel hello <span class="hljs-comment"># 频道发送信息</span><br></code></pre></td></tr></table></figure><h1 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h1><p><strong><em>Redis</em></strong> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p><strong><em>Redis</em></strong> 事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p><h2 id="Multi、Exec、Discard"><a href="#Multi、Exec、Discard" class="headerlink" title="Multi、Exec、Discard"></a><em>Multi</em>、<em>Exec</em>、<em>Discard</em></h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220804140908.png" srcset="/img/loading.gif" lazyload alt="202206241242519"></p><p><strong><em>Multi</em></strong></p><p><strong><em>Exec</em></strong></p><p><strong><em>Discard</em></strong></p><p>从输入 <strong><em>Multi</em></strong> 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 <strong><em>Exec</em></strong> 后，<strong><em>Redis</em></strong> 会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过 <strong><em>Discard</em></strong> 来放弃组队。</p><ul><li><p>组队成功，提交成功</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241243427.png" srcset="/img/loading.gif" lazyload alt=""></p></li><li><p>放弃组队</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241243951.png" srcset="/img/loading.gif" lazyload alt=""></p></li><li><p>组队中有命令错误，不会执行</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241244858.png" srcset="/img/loading.gif" lazyload alt=""></p></li><li><p>组队中不报错，执行时报错</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241244271.png" srcset="/img/loading.gif" lazyload alt=""></p></li></ul><p>当组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁（<strong><em>Pessimistic Lock</em></strong>），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 <strong><em>block</em></strong> 直到成功拿到锁。（效率低）</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁（<strong><em>Optimistic Lock</em></strong>），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制。</p><p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。</p><p><strong><em>Redis</em></strong> 就是利用这种 <strong><em>check-and-set</em></strong> 机制实现事务的。</p><h2 id="Watch、unwatch"><a href="#Watch、unwatch" class="headerlink" title="Watch、unwatch"></a><em>Watch、unwatch</em></h2><p>在执行 <strong><em>multi</em></strong> 之前，先执行 <strong><em>watch key1 [key2]</em></strong>，可以监视一个（或多个 ）<strong><em>key</em></strong> 。如果在事务执行之前这个 <strong><em>key</em></strong> 被其他命令所改动，那么事务将被打断。</p><p>取消 <strong><em>WATCH</em></strong> 命令对所有 <strong><em>key</em></strong> 的监视。如果在执行 <strong><em>WATCH</em></strong> 命令之后，<strong><em>EXEC</em></strong> 命令或 <strong><em>DISCARD</em></strong> 命令先被执行，那么就不需要再执行 <strong><em>UNWATCH</em></strong> 。</p><h2 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h2><ul><li><p>单独的隔离操作</p><p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>没有隔离级别的概念</p><p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p></li><li><p>不保证原子性</p><p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p></li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><p>RDB：在指定的时间间隔内将内存中的数据集快照写入磁盘， 即 <strong><em>Snapshot</em></strong> 快照，恢复时是将快照文件直接读到内存里。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241245966.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><p><strong><em>Redis</em></strong> 会单独创建一个子进程（<strong><em>fork</em></strong>）来进行持久化。先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件内容覆盖到 <strong><em>dump.rdb</em></strong>。</p><blockquote><p>这样做的目的是保证数据的完整性。假如直接同步过去，在同步时发生错误（比如服务器挂了），会造成数据缺失。</p><p>所以出现了这个技术：写时复制技术。</p></blockquote><p>整个过程中，主进程是不进行任何 <strong><em>IO</em></strong> 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 <strong><em>RDB</em></strong> 方式要比 <strong><em>AOF</em></strong> 方式更加的高效。</p><p><strong>RDB 的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul><li>作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li><li>在 <strong><em>Linux</em></strong> 程序中，<strong><em>fork()</em></strong> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <strong><em>exec</em></strong> 系统调用，出于效率考虑，<strong><em>Linux</em></strong> 中引入了 <strong>写时复制技术</strong></li><li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p><strong><em>dump</em> 文件名字</strong></p><p>在 <strong><em>redis.conf</em></strong> 中配置文件名称，默认为 <strong><em>dump.rdb</em></strong>。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241245089.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>dump</em> 保存位置</strong></p><p><strong><em>rdb</em></strong> 文件的保存路径可以修改。默认为 <strong><em>Redis</em></strong> 启动时命令行所在的目录下。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241245951.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>stop-writes-on-bgsave-error</em></strong></p><p>即当 <strong><em>redis</em></strong> 无法写入磁盘，关闭 <strong><em>redis</em></strong> 的写入操作。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241246038.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>rdbcompression</em></strong></p><p>持久化的文件是否进行压缩存储。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241246917.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>rdbchecksum</em></strong></p><p>完整性的检查，即数据是否完整性、准确性。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241247735.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>save</em></strong></p><p>表示写操作的次数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">格式：<span class="hljs-keyword">save</span> 秒 写操作次数<br></code></pre></td></tr></table></figure><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241247583.png" srcset="/img/loading.gif" lazyload alt="img"></p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>适合大规模的数据恢复；</li><li>对数据完整性和一致性要求不高更适合使用；</li><li>节省磁盘空间；</li><li>恢复速度快。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong><em>Fork</em></strong> 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑；</li><li>虽然 <strong><em>Redis</em></strong> 在 <strong><em>fork</em></strong> 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能；</li><li>在备份周期在一定间隔时间做一次备份，所以如果 <strong><em>Redis</em></strong> 意外 <strong><em>down</em></strong> 掉的话，就会丢失最后一次快照后的所有修改。</li></ul><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>AOF：以日志的形式来记录每个写操作（增量保存），将 <strong><em>Redis</em></strong> 执行过的所有写指令记录下来（读操作不记录）， 只许追加文件但不可以改写文件，<strong><em>Redis</em></strong> 启动之初会读取该文件重新构建数据，换言之，如果 <strong><em>Redis</em></strong> 重启就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p><strong>执行流程</strong></p><ul><li>客户端的请求写命令会被 <strong><em>append</em></strong> 追加到 <strong><em>AOF</em></strong> 缓冲区内；</li><li><strong><em>AOF</em></strong> 缓冲区根据 <strong><em>AOF</em></strong> 持久化策略 <code>[always,everysec,no]</code> 将操作 <strong><em>sync</em></strong> 同步到磁盘的 <strong><em>AOF</em></strong> 文件中；</li><li><strong><em>AOF</em></strong> 文件大小超过重写策略或手动重写时，会对 <strong><em>AOF</em></strong> 文件 <strong><em>Rewrite</em></strong> 重写，压缩 <strong><em>AOF</em></strong> 文件容量；</li><li><strong><em>Redis</em></strong> 服务重启时，会重新 <strong><em>load</em></strong> 加载 <strong><em>AOF</em></strong> 文件中的写操作达到数据恢复的目的。</li></ul><p><strong><em>AOF</em></strong> 和 <strong><em>RDB</em></strong> 同时开启时，系统默认读取 <strong><em>AOF</em></strong> 的数据（数据不会存在丢失）</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><blockquote><p><strong><em>AOF</em> 默认不开启</strong></p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241248962.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong>文件名字</strong></p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241248396.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>AOF</em> 同步频率设置</strong></p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241249139.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong><em>appendfsync always</em></strong></p><p>始终同步，每次 <strong><em>Redis</em></strong> 的写入都会立刻记入日志；</p><p>性能较差但数据完整性比较好。</p><p><strong><em>appendfsync everysec</em></strong></p><p>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p><strong><em>appendfsync no</em></strong></p><p><strong><em>Redis</em></strong> 不主动进行同步，把同步时机交给操作系统。</p><p><strong><em>Rewrite</em> 压缩</strong></p><p>当 <strong><em>AOF</em></strong> 文件的大小超过所设定的阈值时，<strong><em>Redis</em></strong> 就会启动 <strong><em>AOF</em></strong> 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 <strong><em>bgrewriteaof</em></strong>。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241249997.png" srcset="/img/loading.gif" lazyload alt="img"></p></blockquote><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>备份机制更稳健，丢失数据概率更低；</li><li>可读的日志文本，通过操作 <strong><em>AOF</em></strong> 稳健，可以处理误操作。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>比起 <strong><em>RDB</em></strong> 占用更多的磁盘空间；</li><li>恢复备份速度要慢；</li><li>每次读写都同步的话，有一定的性能压力；</li><li>存在个别 <strong><em>Bug</em></strong>，造成不能恢复。</li></ul><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><blockquote><p>官方推荐两个都启用。</p><p>如果对数据不敏感，可以选单独用 <strong><em>RDB</em></strong>。</p><p>不建议单独用 <strong><em>AOF</em></strong>，因为可能会出现 <strong><em>Bug</em></strong>。</p><p>如果只是做纯内存缓存，可以都不用。</p></blockquote><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主机数据更新后根据配置和策略， 自动同步到备机的 <strong><em>master/slaver</em></strong> 机制，<strong><em>Master</em></strong> 以写为主，<strong><em>Slaver</em></strong> 以读为主。主从复制节点间数据是全量的。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805085119.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><p>作用：</p><ol><li>读写分离，性能扩展</li><li>容灾快速恢复</li><li>一主多从！</li></ol><h2 id="搭建一主两从"><a href="#搭建一主两从" class="headerlink" title="搭建一主两从"></a>搭建一主两从</h2><ol><li>创建文件目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/opt/etc<br></code></pre></td></tr></table></figure><ol><li>将 <strong><em>redis.conf</em></strong> 复制到当前目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp /etc/redis.conf /opt/etc/<br></code></pre></td></tr></table></figure><ol><li>创建 3 个 <strong><em>redis.conf</em></strong> 配置文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">redis6379.conf<br>redis6380.conf<br>redis6381.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># redis6379.conf</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br><br><span class="hljs-comment"># redis6380.conf</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6380.pid<br>port 6380<br>dbfilename dump6380.rdb<br><br><span class="hljs-comment"># redis6381.conf</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6381.pid<br>port 6381<br>dbfilename dump6381.rdb<br>Copy<br></code></pre></td></tr></table></figure><ol><li>启动 3 台 <strong><em>redis</em></strong> 服务器</li></ol><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241250298.png" srcset="/img/loading.gif" lazyload alt=""></p><ol><li>查看主机运行情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">info replication<br></code></pre></td></tr></table></figure><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241251598.png" srcset="/img/loading.gif" lazyload alt=""></p><ol><li>配从不配主</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">slaveof  &lt;ip&gt;&lt;port&gt;<br><span class="hljs-comment"># 成为某个实例的从服务器</span><br></code></pre></td></tr></table></figure><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241251672.png" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241251039.png" srcset="/img/loading.gif" lazyload alt=""></p><ol><li>再次查看主机运行情况</li></ol><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241252641.png" srcset="/img/loading.gif" lazyload alt=""></p><p>成功搭建。</p><h2 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h2><p>主机 <strong><em>6379</em></strong>，从机 <strong><em>6380</em></strong> 和 <strong><em>6381</em></strong>。</p><ol><li>假设从机 <strong><em>6380</em></strong> 挂掉。</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">当<span class="hljs-number">6380</span>重启后，<span class="hljs-number">6380</span>不再是<span class="hljs-number">6379</span>的从机，而是作为新的<span class="hljs-literal">master</span>；<br>当再次把<span class="hljs-number">6380</span>作为<span class="hljs-number">6379</span>的从机加入后，从机会把数据从头到尾复制。<br></code></pre></td></tr></table></figure><ol><li>假设主机 <strong><em>6379</em></strong> 挂掉。</li></ol><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">6380和6381</span>仍然是<span class="hljs-number">6379</span>的从机，不会做任何事；<br>当<span class="hljs-number">6379</span>重启后，依然是主服务器。<br></code></pre></td></tr></table></figure><h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241253497.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><p>上一个 <strong><em>slave</em></strong> 可以是下一个 <strong><em>slave</em></strong> 的 <strong><em>master</em></strong>，<strong><em>slave</em></strong> 同样可以接收其他 <strong><em>slave</em></strong>的连接和同步请求，那么该 <strong><em>slave</em></strong> 作为了链条中下一个的 <strong><em>master</em></strong>，可以有效减轻 <strong><em>master</em></strong> 的写压力，去中心化降低风险。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">slaveof &lt;ip&gt;&lt;port&gt;<br></code></pre></td></tr></table></figure><p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p><p>当某个 <strong><em>slave</em></strong> 宕机，后面的 <strong><em>slave</em></strong> 都没法备份。</p><p>即当主机挂掉，从机还是从机，但是无法继续写数据。</p><h2 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h2><p>当一个 <strong><em>master</em></strong> 宕机后，后面的 <strong><em>slave</em></strong> 可以立刻升为 <strong><em>master</em></strong>，其后面的 <strong><em>slave</em></strong> 不用做任何修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">slaveof no one<br></code></pre></td></tr></table></figure><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><strong>反客为主的自动版</strong>，即能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><ol><li>创建 <strong><em>sentinel.conf</em></strong> 文件</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/opt/</span>etc/sentinel.conf<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><ol><li>配置哨兵</li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">sentinel<span class="hljs-built_in"> monitor </span>mymaster 172.16.88.168 6379 1<br><br><span class="hljs-comment"># mymaster：监控对象起的服务器名称</span><br><span class="hljs-comment"># 1：至少有多少个哨兵同意迁移的数量。 </span><br>Copy<br></code></pre></td></tr></table></figure><ol><li>启动哨兵</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">redis-sentinel  <span class="hljs-regexp">/opt/</span>etc/sentinel.conf <br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241253197.png"><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241253197.png" srcset="/img/loading.gif" lazyload alt="img"></a></p><p>主机挂掉，会从机选举中产生新的主机。选举的规则。</p><h3 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h3><ul><li><p>根据优先级别，<strong><em>slave-priority/replica-priority</em></strong>，优先选择优先级靠前的。</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241253826.png" srcset="/img/loading.gif" lazyload alt="img"></p></li><li><p>根据偏移量，优先选择偏移量大的。</p></li><li><p>根据 <strong><em>runid</em></strong>，优先选择最小的服务。</p></li></ul><h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在 <strong><em>master</em></strong> 上操作，然后同步更新到 <strong><em>slave</em></strong> 上，所以从 <strong><em>master</em></strong> 同步到 <strong><em>slave</em></strong> 从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<strong><em>slave</em></strong> 机器数量的增加也会使这个问题更加严重。</p><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><ul><li><strong><em>slave</em></strong> 启动成功连接到 <strong><em>master</em></strong> 后会发送一个 <strong><em>sync</em></strong> 命令（同步命令）。</li><li><strong><em>master</em></strong> 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<strong><em>master</em></strong> 将传送整个数据文件（<strong><em>rdb</em></strong>）到 <strong><em>slave</em></strong>，以完成一次完全同步。</li><li>当主服务进行写操作后，和从服务器进行数据同步。</li><li>全量复制：而 <strong><em>slave</em></strong> 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：<strong><em>master</em></strong> 继续将新的所有收集到的修改命令依次传给 <strong><em>slave</em></strong>，完成同步。</li><li>只要是重新连接 <strong><em>master</em></strong>，一次完全同步（全量复制）将被自动执行。</li></ul><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>容量不够，<strong><em>redis</em></strong> 如何进行扩容？</p><p>并发写操作， <strong><em>redis</em></strong> 如何分摊？</p><p>主从模式，薪火相传模式，主机宕机，导致 <strong><em>ip</em></strong> 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>解决方法：</p><ul><li><p>代理主机（ <strong><em>之前</em></strong> ）</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805090723.png" srcset="/img/loading.gif" lazyload alt=""></p></li><li><p>无中心化集群配置（ <strong><em>redis3.0</em></strong> ）</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805090746.png" srcset="/img/loading.gif" lazyload alt="202206241255698"></p></li></ul><p><strong><em>Redis</em></strong> 集群实现了对 <strong><em>Redis</em></strong> 的水平扩容，即启动 <strong><em>N</em></strong> 个 <strong><em>Redis</em></strong> 节点，将整个数据库分布存储在这 <strong><em>N</em></strong> 个节点中，每个节点存储总数据的 <strong><em>1/N</em></strong> 。</p><p><strong><em>Redis</em></strong> 集群通过分区（<strong><em>partition</em></strong>）来提供一定程度的可用性（<strong><em>availability</em></strong>），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="redis-cluster-如何分配这六个节点"><a href="#redis-cluster-如何分配这六个节点" class="headerlink" title="redis cluster 如何分配这六个节点?"></a><em>redis cluster</em> 如何分配这六个节点?</h3><p>一个集群至少要有三个主节点。</p><p>选项 <code>--cluster-replicas 1</code>，表示希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的 <strong><em>IP</em></strong> 地址，每个从库和主库不在一个 <strong><em>IP</em></strong> 地址上。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805090840.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><h3 id="什么是-slots？"><a href="#什么是-slots？" class="headerlink" title="什么是 slots？"></a>什么是 <em>slots</em>？</h3><p>一个 <strong><em>Redis</em></strong> 集群包含 <strong><em>16384</em></strong> 个插槽（<strong><em>hash slot</em></strong>）， 数据库中的每个键都属于这 <strong><em>16384</em></strong> 个插槽的其中一个。</p><p>集群使用公式 <strong><em>CRC16(key) % 16384</em></strong> 来计算键 <strong><em>key</em></strong> 属于哪个槽， 其中 <strong><em>CRC16(key)</em></strong> 语句用于计算键 <strong><em>key</em></strong> 的 <strong><em>CRC16</em></strong> 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：</p><ul><li>节点 <strong><em>A</em></strong> 负责处理 <strong><em>0</em></strong> 号至 <strong><em>5460</em></strong> 号插槽。</li><li>节点 <strong><em>B</em></strong> 负责处理 <strong><em>5461</em></strong> 号至 <strong><em>10922</em></strong> 号插槽。</li><li>节点 <strong><em>C</em></strong> 负责处理 <strong><em>10923</em></strong> 号至 <strong><em>16383</em></strong> 号插槽。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805091147.png" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="如何在集群中录入值？"><a href="#如何在集群中录入值？" class="headerlink" title="如何在集群中录入值？"></a>如何在集群中录入值？</h3><p>在 <strong><em>redis-cli</em></strong> 每次录入、查询键值，<strong><em>redis</em></strong> 都会计算出该 <strong><em>key</em></strong> 应该送往的插槽，如果不是该客户端对应服务器的插槽，<strong><em>redis</em></strong> 会报错，并告知应前往的 <strong><em>redis</em></strong> 实例地址和端口。</p><p><strong><em>redis-cli</em></strong> 客户端提供了 <strong><em>–c</em></strong> 参数实现自动重定向。</p><p>例如 <strong><em>redis-cli -c –p 6379</em></strong> 登入后，再录入、查询键值对可以自动重定向。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805084413.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p><h3 id="如何查询集群中的值？"><a href="#如何查询集群中的值？" class="headerlink" title="如何查询集群中的值？"></a>如何查询集群中的值？</h3><p>每个主机只能查询自己范围内部的插槽。</p><p><code>cluster keyslot &lt;key&gt;</code>：查询某个 <strong><em>key</em></strong> 的 <strong><em>slot</em> </strong>。</p><p><code>cluster countkeysinslot &lt;slot&gt;</code>：查询某个 <strong><em>slot</em></strong> 是否有值。</p><p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code>：返回 <strong><em>count</em></strong> 个 <strong><em>slot</em></strong> 槽中的键。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805091452.png" srcset="/img/loading.gif" lazyload style="zoom:67%"></p><h3 id="故障恢复？"><a href="#故障恢复？" class="headerlink" title="故障恢复？"></a>故障恢复？</h3><blockquote><p>15秒超时是：在十五秒内，重启好，还是主机，否则就是从机。</p></blockquote><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong><em>15</em></strong> 秒超时。</p><ul><li>当 <strong><em>6379</em></strong> 挂掉后，<strong><em>6380</em></strong> 成为新的主机。</li></ul><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p><ul><li>当 <strong><em>6379</em></strong> 重启后，<strong><em>6379</em></strong> 成为 <strong><em>6380</em></strong> 的从机。</li></ul><p>如果所有某一段插槽的主从节点都宕掉，<strong><em>redis</em></strong> 服务是否还能继续?</p><ul><li>如果某一段插槽的主从都挂掉，而 <strong><em>cluster-require-full-coverage=yes</em></strong>，那么 ，整个集群都挂掉。</li><li>如果某一段插槽的主从都挂掉，而 <strong><em>cluster-require-full-coverage=no</em></strong>，那么，该插槽数据全都不能使用，也无法存储。</li></ul><p><code>redis.conf</code> 中的参数 <code>cluster-require-full-coverage</code></p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul><li>实现扩容；</li><li>分摊压力；</li><li>无中心配置相对简单。</li></ul><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul><li>多键操作是不被支持的；</li><li>多键的 <strong><em>Redis</em></strong> 事务是不被支持的。<strong><em>lua</em></strong> 脚本不被支持；</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至<strong><em>redis cluster</em></strong>，需要整体迁移而不是逐步过渡，复杂度较大。</li></ul><h1 id="Jedis操作Redis"><a href="#Jedis操作Redis" class="headerlink" title="Jedis操作Redis"></a>Jedis操作Redis</h1><p>即 <strong><em>Java</em></strong> 操作 <strong><em>Redis</em></strong>。</p><ol><li>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>连接 <strong><em>Redis</em></strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.57.101&quot;</span>, <span class="hljs-number">6379</span>);<br>    String pong = jedis.ping();<br>    System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span> + pong);<br>    jedis.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><em>Key</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k3&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>);<br>Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>System.out.println(keys.size());<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br>	System.out.println(key);<br>&#125;<br>System.out.println(jedis.exists(<span class="hljs-string">&quot;k1&quot;</span>));<br>System.out.println(jedis.ttl(<span class="hljs-string">&quot;k1&quot;</span>));                <br>System.out.println(jedis.get(<span class="hljs-string">&quot;k1&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong><em>String</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.mset(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>System.out.println(jedis.mget(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong><em>List</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.lpush(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;lucy&quot;</span>, <span class="hljs-string">&quot;mary&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);<br>List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br>System.out.println(list);<br></code></pre></td></tr></table></figure><blockquote><p>jack,mary,lucy</p></blockquote><p><strong><em>Set</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order01&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order03&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order04&quot;</span>);<br>Set&lt;String&gt; smembers = jedis.smembers(<span class="hljs-string">&quot;orders&quot;</span>);<br><span class="hljs-keyword">for</span> (String order : smembers) &#123;<br>	System.out.println(order);<br>&#125;<br>jedis.srem(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong><em>Hash</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.hset(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>System.out.println(jedis.hget(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>));<br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>map.put(<span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;13810169999&quot;</span>);<br>map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;atguigu&quot;</span>);<br>map.put(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;abc@163.com&quot;</span>);<br>jedis.hmset(<span class="hljs-string">&quot;hash2&quot;</span>,map);<br>List&lt;String&gt; result = jedis.hmget(<span class="hljs-string">&quot;hash2&quot;</span>, <span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br><span class="hljs-keyword">for</span> (String element : result) &#123;<br>	System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><em>zset</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">100d</span>, <span class="hljs-string">&quot;z3&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">90d</span>, <span class="hljs-string">&quot;l4&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">80d</span>, <span class="hljs-string">&quot;w5&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">70d</span>, <span class="hljs-string">&quot;z6&quot;</span>);<br><br>Set&lt;String&gt; zrange = jedis.zrange(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (String e : zrange) &#123;<br>	System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><ol><li>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>配置文件 application.properties 配置 <strong><em>Redis</em></strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">#Redis服务器地址<br>spring.redis.host= ip<br>#Redis服务器连接端口<br>spring.redis.port=<span class="hljs-number">6379</span><br>#Redis数据库索引（默认为0）<br>spring.redis.database= <span class="hljs-number">0</span><br>#连接超时时间（毫秒）<br>spring.redis.timeout=<span class="hljs-number">1800000</span><br>#连接池最大连接数（使用负值表示没有限制）<br>spring.redis.lettuce.pool.max-active=<span class="hljs-number">20</span><br>#最大阻塞等待时间(负数表示没限制)<br>spring.redis.lettuce.pool.max-wait=-<span class="hljs-number">1</span><br>#连接池中的最大空闲连接<br>spring.redis.lettuce.pool.max-idle=<span class="hljs-number">5</span><br>#连接池中的最小空闲连接<br>spring.redis.lettuce.pool.min-idle=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ol><li><strong><em>Redis</em></strong> 配置类（需要继承 <strong><em>CachingConfigurerSupport</em></strong>）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CachingConfigurerSupport</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br>				<span class="hljs-comment">// key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br>				<span class="hljs-comment">// value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>				<span class="hljs-comment">// value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>				<span class="hljs-comment">// 解决查询缓存转换异常的问题</span><br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>				<span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        RedisCacheConfiguration config = <br>          RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>   .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集群的-Jedis-开发"><a href="#集群的-Jedis-开发" class="headerlink" title="集群的 Jedis 开发"></a>集群的 <em>Jedis</em> 开发</h2><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisClusterTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>     Set&lt;HostAndPort&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;HostAndPort&gt;();<br>     set.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">&quot;172.16.88.168&quot;</span>,<span class="hljs-number">6379</span>)); <span class="hljs-comment">// 任何一个端口</span><br>     JedisCluster jedisCluster = <span class="hljs-keyword">new</span> JedisCluster(set);<br>     jedisCluster.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>     System.out.println(jedisCluster.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="应用问题解决"><a href="#应用问题解决" class="headerlink" title="应用问题解决"></a>应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805092950.png" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><strong><em>key</em></strong> 对应的数据在数据源并不存在，每次针对此 <strong><em>key</em></strong> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</p><p>比如用一个不存在的用户 <strong><em>id</em></strong> 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p>造成现象：</p><ol><li>应用服务器压力变大（大量请求过来了）。</li><li><strong><em>redis</em></strong> 命中率下降（缓存中查不到） $\longrightarrow$ 一直查询数据库 。</li></ol><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p><strong>对空值缓存</strong></p><p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<strong><em>null</em></strong>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p></li><li><p><strong>设置可访问的名单（白名单）：</strong></p><p>使用 <strong><em>bitmaps</em></strong> 类型定义一个可以访问的名单，名单 <strong><em>id</em></strong> 作为 <strong><em>bitmaps</em></strong> 的偏移量，每次访问和 <strong><em>bitmap</em></strong> 里面的 <strong><em>id</em></strong> 进行比较，如果访问 <strong><em>id</em></strong> 不在 <strong><em>bitmaps</em></strong> 里面，进行拦截，则不允许访问。</p></li><li><p><strong>采用布隆过滤器</strong></p><p>布隆过滤器（<strong><em>Bloom Filter</em></strong>）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>将所有可能存在的数据哈希到一个足够大的 <strong><em>bitmaps</em></strong> 中，一个一定不存在的数据会被这个 <strong><em>bitmaps</em></strong> 拦截掉，从而避免了对底层存储系统的查询压力。</p></li><li><p><strong>进行实时监控</strong></p><p>当发现 <strong><em>Redis</em></strong> 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805093556.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><p><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p><ol><li>数据库访问压力瞬间增大。</li><li><strong><em>redis</em></strong> 中没有出现大量 <strong><em>key</em></strong> 过期，<strong><em>redis</em></strong> 正常运行。</li><li>（即某个经常访问的 <strong><em>key</em></strong> 过期，突然有大量访问这个数据）</li></ol><h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p>预先设置热门数据</p><p>在 <strong><em>redis</em></strong> 高峰访问之前，把一些热门数据提前存入到 <strong><em>redis</em></strong> 里面，加大这些热门数据 <strong><em>key</em></strong> 的时长。</p></li><li><p>实时调整</p><p>现场监控哪些数据热门，实时调整 <strong><em>key</em></strong> 的过期时长。</p></li><li><p>使用锁</p></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多 <strong><em>key</em></strong> 缓存，前者则是某一个 <strong><em>key</em></strong>。</p><ol><li>数据库压力变大。</li><li>即极少的时间段，查询大量 <strong><em>key</em></strong> 的集中过期情况。</li></ol><h3 id="如何解决-2"><a href="#如何解决-2" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p><strong>构建多级缓存架构</strong></p><p><strong><em>nginx</em></strong> 缓存 + <strong><em>redis</em></strong> 缓存 + 其他缓存（<strong><em>ehcache</em></strong>等）</p></li><li><p><strong>使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p></li><li><p><strong>设置过期标志更新缓存：</strong></p><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 <strong><em>key</em></strong> 的缓存。</p></li><li><p><strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li></ul><hr><p>来自于</p><p><a target="_blank" rel="noopener" href="https://zhangc233.github.io/2021/05/02/Redis/#Redis%E6%A6%82%E8%BF%B0">https://zhangc233.github.io/2021/05/02/Redis/#Redis%E6%A6%82%E8%BF%B0</a></p><p><a target="_blank" rel="noopener" href="https://tsuiraku.com/2021/08/19/redis/#Redis">https://tsuiraku.com/2021/08/19/redis/#Redis</a></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Java/">Java</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Redis/">Redis</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处来源：<a href="https://stuxiaozhang.github.io/">小张的宇宙空间站</a></p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2022/08/09/%E3%80%90Hierarchical%20Representations%E3%80%91Hierarchical%20Representations%20For%20Efficient%20Architecture%20Search/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">【Hierarchical Representations】Hierarchical Representations For Efficient Architecture Search</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/07/29/SpringBoot%E7%AC%94%E8%AE%B0/"><span class="hidden-mobile">SpringBoot笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",function(){var e=Object.assign({appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:"https://cdn.bootcdn.net/ajax/libs/emojione/4.5.0/lib/js/emojione.min.js",emojiMaps:null,enableQQ:!0,requiredFields:["nick"]},{el:"#valine",path:window.location.pathname});new Valine(e)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://stuxiaozhang.github.io" target="_blank" rel="nofollow noopener"><span>小张同学的宇宙空间站</span></a> 已经运转了<span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{renderActions:{findScript:[10,a=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const n=new a.options.MathItem(e.textContent,a.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),n.start={node:t,delim:"",n:0},n.end={node:t,delim:"",n:0},a.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>