<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><link rel="icon" href="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150132.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="Redis笔记
Redis 是典型的 NoSQL 数据库。是一个开源的 key-value 存储系统。

和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string、list、set、zset、sorted set、hash。
这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。
在此基础上"><meta name="author" content="小张同学"><meta name="keywords" content=""><title>Redis笔记 - 小张同学的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",app_key:"CgnvRL262D07ied40NiXm2VL",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><header style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>xiaozhang's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/schedule/"><i class="iconfont icon-cliplist"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330150632.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Redis笔记"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 小张同学 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-03 09:33" pubdate>2022年8月3日</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 50 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-1"></div><div class="col-lg-9 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Redis笔记</h1><p class="note note-info">本文最后更新于：2022年8月4日</p><div class="markdown-body"><h1 id="redis笔记">Redis笔记</h1><p><strong><em>Redis</em></strong> 是典型的 <strong><em>NoSQL</em></strong> 数据库。是一个开源的 <strong><em>key-value</em></strong> 存储系统。</p><ul><li><p>和 <strong><em>Memcached</em></strong> 类似，它支持存储的 <strong><em>value</em></strong> 类型相对更多，包括 <strong><em>string、list、set、zset、sorted set、hash</em></strong>。</p></li><li><p>这些数据类型都支持 <strong><em>push/pop、add/remove</em></strong> 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p></li><li><p>在此基础上，<strong><em>Redis</em></strong> 支持各种不同方式的排序。</p></li><li><p>与 <strong><em>memcached</em></strong>一样，为了保证效率，数据都是缓存在内存中。</p></li><li><p>区别的是 <strong><em>Redis</em></strong> 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p></li><li><p>并且在此基础上实现了<strong><em>master-slave</em></strong> （主从）同步。</p></li><li><p>单线程 + <strong><em>IO</em></strong> 多路复用。</p><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p></li><li><p><strong>串行 vs 多线程 + 锁（memcached） vs 单线程 + 多路 IO 复用 (Redis)</strong>（与 Memcache 三点不同：支持多数据类型，支持持久化，单线程 + 多路 IO 复用） 。</p></li><li><p>Redis优点：</p><ul><li>打破传统关系型数据库以业务逻辑为依据的存储模式，而针对不同数据结构类型改为以性能为最优先的存储方式。</li><li><p>减少CPU、IO压力，通过内存读取</p></li><li><p>NoSQL能够直接作为缓存使用，减少IO的读操作</p></li></ul></li></ul><h1 id="安装和启动">安装和启动</h1><blockquote><p>安装 <strong><em>C</em></strong> 语言的编译环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install centos-release-scl scl-utils-build<br>yum install -y devtoolset-8-toolchain<br>scl <span class="hljs-built_in">enable</span> devtoolset-8 bash<br></code></pre></td></tr></table></figure><p>通过 <strong><em>wget</em></strong> 下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://download.redis.io/releases/redis-6.2.6.tar.gz<br><br>// 下载路径：/opt<br></code></pre></td></tr></table></figure><p>解压至当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf redis-6.2.6.tar.gz <br></code></pre></td></tr></table></figure><p>解压完成后进入目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis-6.2.6<br></code></pre></td></tr></table></figure><p>在当前目录下执行 <strong><em>make</em></strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> &amp;&amp; <span class="hljs-built_in">make</span> install<br></code></pre></td></tr></table></figure><p>默认安装在 <code>/usr/local/bin</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何<br>redis-<span class="hljs-keyword">check</span>-aof：修复有问题的AOF文件，rdb和aof后面讲<br>redis-<span class="hljs-keyword">check</span>-dump：修复有问题的dump.rdb文件<br>redis-sentinel：Redis集群使用<br>redis-<span class="hljs-keyword">server</span>：Redis服务器启动命令<br>redis-cli：客户端，操作入口<br></code></pre></td></tr></table></figure><p>前台启动：<code>/usr/local/bin</code> 目录下启动 <strong><em>redis</em></strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">redis-server</span><span class="hljs-params">(前台启动)</span></span><br></code></pre></td></tr></table></figure><p>后台启动：</p><ul><li><p>安装 <strong><em>redis</em></strong> 的目录 <strong><em>/opt/redis-6.2.6</em></strong> 中将 <strong><em>redis.conf</em></strong> 复制到任意一个文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp redis.conf /etc/redis.conf<br>// 将redis.conf复制到/etc/下<br></code></pre></td></tr></table></figure></li><li><p>修改 <strong><em>/etc/redis.conf</em></strong> 配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">vim</span> <span class="hljs-string">redis.conf#</span> <span class="hljs-string">daemonize</span> <span class="hljs-literal">no</span> <span class="hljs-string">修改为</span> <span class="hljs-string">daemonize</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241224181.png" srcset="/img/loading.gif" lazyload></p></li><li><p><strong><em>/usr/local/bin</em></strong> 目录下启动 <strong><em>redis</em></strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">redis-server <span class="hljs-regexp">/etc/</span>redis.conf<br></code></pre></td></tr></table></figure></li></ul><p>关闭 <strong><em>redis</em></strong></p><ul><li><strong><em>kill</em></strong> 进程</li><li>命令 <strong><em>shutdown</em></strong></li></ul></blockquote><p><u><strong>默认端口号：6379</strong></u></p><h1 id="nosql数据库">NoSQL数据库</h1><p><strong><em>NoSQL（Not Only SQL）</em></strong> ，非关系型数据库</p><p><strong><em>NoSQL</em></strong> 不依赖业务逻辑方式存储，而以简单的 <strong><em>key-value</em></strong> 模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循 <strong><em>SQL</em></strong> 标准。</li><li>不支持 <strong><em>ACID</em></strong>。</li><li>远超于 <strong><em>SQL</em></strong> 的性能。</li></ul><p><strong>适用于的场景</strong></p><ul><li>对数据高并发的读写；</li><li>海量数据的读写；</li><li>对数据高可扩展性的。</li></ul><p><strong>不适用的场景</strong></p><ul><li>需要事务支持；</li><li>基于 <strong><em>sql</em></strong> 的结构化查询存储，处理复杂的关系，需要即席查询。</li></ul><p>常见的 <strong><em>NoSQL</em></strong> 数据库</p><ul><li>Redis</li><li>MongoDB</li></ul><p>Redis 使用的是<strong>单线程 + 多路 IO 复用</strong>技术：</p><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p><p>串行 vs <u>多线程 + 锁（memcached）</u> vs <u>单线程 + 多路 IO 复用 (Redis)</u>（与 Memcache 三点不同：<strong>Redis支持多数据类型；支持持久化；单线程 + 多路 IO 复用</strong>） 。</p><h1 id="配置文件">配置文件</h1><p><strong><em>redis.conf</em></strong></p><h2 id="units"><strong><em>Units</em></strong></h2><blockquote><p>单位，配置大小单位，开头定义了一些基本的度量单位，只支持 <strong><em>bytes</em></strong>，不支持 <strong><em>bit</em></strong>。</p><p>大小写不敏感。</p></blockquote><p><a target="_blank" rel="noopener" href="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230368.png"><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230368.png" srcset="/img/loading.gif" lazyload alt="img"></a></p><h2 id="includes"><strong><em>INCLUDES</em></strong></h2><blockquote><p>包含，多实例的情况可以把公用的配置文件提取出来。</p></blockquote><p><a target="_blank" rel="noopener" href="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230370.png"><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230370.png" srcset="/img/loading.gif" lazyload alt="img"></a></p><h2 id="network"><strong><em>NETWORK</em></strong></h2><blockquote><p>网络相关配置。</p><p><strong><em>bind</em></strong></p><p>默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。</p><p>不写的情况下，无限制接受任何 <strong><em>ip</em></strong> 地址的访问。</p><p>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，所以需要将其注释掉。</p><p>如果开启了<strong><em>protected-mode</em></strong>，那么在没有设定 <strong><em>bind ip</em></strong> 且没有设密码的情况下，<strong><em>Redis</em></strong> 只允许接受本机的响应。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241231037.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>protected-mode</em></strong></p><p>将本机访问保护模式设置 <strong><em>no</em></strong>。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241232546.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>port</em></strong></p><p>端口号，默认 <strong><em>6379</em></strong>。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241232526.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>tcp-backlog</em></strong></p><p>设置 <strong><em>tcp</em></strong> 的 <strong><em>backlog</em></strong>，<strong><em>backlog</em></strong> 其实是一个连接队列，<strong><em>backlog</em></strong> 队列总和 <span class="math inline">\(=\)</span> 未完成三次握手队列 <span class="math inline">\(+\)</span> 已经完成三次握手队列。</p><p>在高并发环境下你需要一个高 <strong><em>backlog</em></strong> 值来避免慢客户端连接问题。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241233656.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>timeout</em></strong></p><p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241233384.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>tcp-keepalive</em></strong></p><p>对访问客户端的一种心跳检测，每个 <strong><em>n</em></strong> 秒检测一次。</p><p>单位为秒，如果设置为 0，则不会进行 <strong><em>Keepalive</em></strong> 检测，建议设置成 60。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241234246.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure></blockquote><h2 id="general"><strong><em>GENERAL</em></strong></h2><blockquote><p>通用。</p><p><strong><em>daemonize</em></strong></p><p>是否为后台进程，设置为 <strong><em>yes</em></strong>。</p><p>守护进程，后台启动。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241235837.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>pidfile</em></strong></p><p>存放 <strong><em>pid</em></strong> 文件的位置，每个实例会产生一个不同的 <strong><em>pid</em></strong> 文件。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241235968.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>loglevel</em></strong></p><p>指定日志记录级别，<strong><em>Redis</em></strong> 总共支持四个级别：<strong><em>debug、verbose、notice、warning</em></strong>，默认为 <strong><em>notice</em></strong>。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241235383.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>logfile</em></strong></p><p>日志文件名称。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241236971.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>database</em></strong></p><p>设定库的数量 默认16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 <strong><em>id</em></strong>。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241236379.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure></blockquote><h2 id="security"><strong><em>SECURITY</em></strong></h2><blockquote><p>安全。</p><p>访问密码的查看、设置和取消。</p><p>在命令中设置密码，只是临时的。重启 <strong><em>redis</em></strong> 服务器，密码就还原了。</p><p>永久设置，需要在配置文件中进行设置。</p></blockquote><h2 id="limits"><strong><em>LIMITS</em></strong></h2><blockquote><p>限制。</p><p><strong><em>maxclients</em></strong></p><p>设置 <strong><em>redis</em></strong> 同时可以与多少个客户端进行连接。</p><p>默认情况下为 <strong><em>10000</em></strong> 个客户端。</p><p>如果达到了此限制，<strong><em>redis</em></strong> 则会拒绝新的连接请求，并且向这些连接请求方发出 <strong><em>max number of clients reached</em></strong> 以作回应。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241237488.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>maxmemory</em></strong></p><p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p><p>设置 <strong><em>redis</em></strong> 可以使用的内存量。一旦到达内存使用上限，<strong><em>redis</em></strong> 将会试图移除内部数据，移除规则可以通过 <strong><em>maxmemory-policy</em></strong> 来指定。</p><p>如果 <strong><em>redis</em></strong> 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 <strong><em>redis</em></strong> 则会针对那些需要申请内存的指令返回错误信息，比如 <strong><em>SET、LPUSH</em></strong> 等。</p><p>但是对于无内存申请的指令，仍然会正常响应，比如 <strong><em>GET</em></strong> 等。如果你的 <strong><em>redis</em></strong> 是主 <strong><em>redis</em></strong>（ 说明你的 <strong><em>redis</em></strong> 有从 <strong><em>redis</em></strong> ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241237150.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>maxmemory-policy</em></strong></p><p><strong><em>volatile-lru</em></strong>：使用 <strong><em>LRU</em></strong> 算法移除 <strong><em>key</em></strong>，只对设置了过期时间的键（最近最少使用）。</p><p><strong><em>allkeys-lru</em></strong>：在所有集合 <strong><em>key</em></strong> 中，使用 <strong><em>LRU</em></strong> 算法移除 <strong><em>key</em></strong>。</p><p><strong><em>volatile-random</em></strong>：在过期集合中移除随机的 <strong><em>key</em></strong>，只对设置了过期时间的键。</p><p><strong><em>allkeys-random</em></strong>：在所有集合 <strong><em>key</em></strong> 中，移除随机的 <strong><em>key</em></strong>。</p><p><strong><em>volatile-ttl</em></strong>：移除那些 <strong><em>TTL</em></strong> 值最小的 <strong><em>key</em></strong>，即那些最近要过期的 <strong><em>key</em></strong>。</p><p><strong><em>noeviction</em></strong>：不进行移除。针对写操作，只是返回错误信息。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241238328.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure><p><strong><em>maxmemory-samples</em></strong></p><p>设置样本数量，<strong><em>LRU</em></strong> 算法和最小 <strong><em>TTL</em></strong> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<strong><em>redis</em></strong> 默认会检查这么多个 <strong><em>key</em></strong> 并选择其中 <strong><em>LRU</em></strong> 的那个。</p><p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</p><figure><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241238581.png" srcset="/img/loading.gif" lazyload alt="img"><figcaption>img</figcaption></figure></blockquote><h1 id="常用五大基本数据类型">常用五大基本数据类型</h1><h2 id="key操作">key操作</h2><blockquote><p><code>keys *</code>：查看当前库所有 <strong><em>key</em></strong></p><p><code>exists key</code>：判断某个 <strong><em>key</em></strong> 是否存在</p><p><code>type key</code>：查看你的 <strong><em>key</em></strong> 是什么类型</p><p><code>del key</code> ：删除指定的 <strong><em>key</em></strong> 数据</p><p><code>unlink key</code>：根据 <strong><em>value</em></strong> 选择非阻塞删除，仅将 <strong><em>keys</em></strong> 从 <strong><em>keyspace</em></strong> 元数据中删除，真正的删除会在后续异步操作</p><p><code>expire key 10</code> ：为给定的 <strong><em>key</em></strong> 设置过期时间</p><p><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</p><p><code>select</code>：命令切换数据库</p><p><code>dbsize</code>：查看当前数据库的 <strong><em>key</em></strong> 的数量</p><p><code>flushdb</code>：清空当前库</p><p><code>flushall</code>：通杀全部库</p></blockquote><h2 id="string字符串">String（字符串）</h2><p><strong><em>String</em></strong> 类型是二进制安全的。意味着 <strong><em>Redis</em></strong> 的 <strong><em>string</em></strong> 可以包含任何数据。比如 <strong><em>jpg</em></strong> 图片或者序列化的对象。</p><p><strong><em>String</em></strong> 类型是 <strong><em>Redis</em></strong> 最基本的数据类型，一个 <strong><em>Redis</em></strong> 中字符串 <strong><em>value</em></strong> 最多可以是 512M。</p><blockquote><p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对</p><p><code>get &lt;key&gt;</code>：查询对应键值</p><p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 <strong><em><value></value></em></strong>追加到原值的末尾</p><p><code>strlen &lt;key&gt;</code>：获得值的长度</p><p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 <strong><em>key</em></strong> 不存在时，设置 <strong><em>key</em></strong> 的值</p><p><code>incr &lt;key&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（<strong>具有原子性</strong>）</p><p><code>decr &lt;key&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1</p><p><code>incrby/decrby &lt;key&gt;&lt;步长&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值增减。自定义步长</p><p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code> ：同时设置一个或多个 <strong><em>key-value</em></strong> 对</p><p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...</code>：同时获取一个或多个 <strong><em>value</em></strong></p><p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;...</code>：同时设置一个或多个 <strong><em>key-value</em></strong> 对，当且仅当所有给定 <strong><em>key</em></strong> 都不存在。（原子性，有一个失败就都失败）</p><p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值的范围</p><p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：用 <strong><em>value</em></strong> 覆写 <strong><em>key</em></strong> 所储存的字符串值</p><p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒。</p><p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p></blockquote><p><strong>原子性</strong></p><p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作；</p><p>这种操作一旦开始，就一直运行到结束，中间不会有任何 <strong><em>context switch</em></strong> （切换到另一个线程）。</p><ul><li>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li><li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li></ul><p><strong><em>Redis</em></strong> 单命令的原子性主要得益于 <strong><em>Redis的单线程</em></strong> 。</p><p><strong>数据结构</strong></p><p>String 的数据结构为简单动态字符串，是可以修改的字符串。内部结构实现上类似于 <strong><em>Java</em></strong> 的 <strong><em>ArrayList</em></strong>，采用预分配冗余空间的方式来减少内存的频繁分配.</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803153309.png" srcset="/img/loading.gif" lazyload style="zoom:55%"></p><h2 id="list列表">List（列表）</h2><p><strong><em>List</em></strong> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803182755.png" srcset="/img/loading.gif" lazyload></p><blockquote><p><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边/右边插入一个或多个值。（我想象成一个双向的栈）</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803183843.png" srcset="/img/loading.gif" lazyload></p><p><code>lpop/rpop &lt;key&gt;</code>：从左边/右边吐出一个值。值在键在，值光键亡。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803185239.png" srcset="/img/loading.gif" lazyload></p><p><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>：从 <strong><em>key1</em></strong> 列表右边吐出一个值，插到 <strong><em>key2</em></strong> 列表左边。</p><p><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>：按照索引下标获得元素（从左到右）</p><p><code>lrange mylist 0 -1 0</code>：左边第一个，-1右边第一个，（0 -1表示获取所有）</p><p><code>lindex &lt;key&gt;&lt;index&gt;</code>：按照索引下标获得元素（从左到右）</p><p><code>llen &lt;key&gt;</code>：获得列表长度</p><p><code>linsert &lt;key&gt; before/after &lt;value&gt;&lt;newvalue&gt;</code>：在 <strong><em>value</em></strong> 的前面/后面插入 <strong><em>newvalue</em></strong> 插入值</p><p><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>：从左边删除 <strong><em>n</em></strong> 个 <strong><em>value</em></strong>（从左到右）</p><p><code>ltrim &lt;key&gt;&lt;start&gt;&lt;end&gt;</code>：按照索引截取下标元素（从左到右）</p><p><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>：将列表 <strong><em>key</em></strong> 下标为 <strong><em>index</em></strong> 的值替换成 <strong><em>value</em></strong></p></blockquote><p><strong>数据结构</strong></p><p><strong><em>List</em></strong> 的数据结构为快速链表 <strong><em>quickList</em></strong>。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <strong><em>ziplist</em></strong>，也即是压缩列表。</p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成 <strong><em>quicklist</em></strong>。</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 <strong><em>int</em></strong> 类型的数据，结构上还需要两个额外的指针 <strong><em>prev</em></strong> 和 <strong><em>next</em></strong>。</p><p><strong><em>Redis</em></strong> 将链表和 <strong><em>ziplist</em></strong> 结合起来组成了 <strong><em>quicklist</em></strong>。也就是将多个 <strong><em>ziplist</em></strong> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h2 id="set集合">Set（集合）</h2><p><strong><em>Set</em></strong> 对外提供的功能与 <strong><em>List</em></strong> 类似列表的功能，特殊之处在于 <strong><em>Set</em></strong> 是可以 <strong>自动排重</strong> 的，当需要存储一个列表数据，又不希望出现重复数据时，<strong><em>Set</em></strong> 是一个很好的选择，并且 <strong><em>Set</em></strong> 提供了判断某个成员是否在一个 <strong><em>Set</em></strong> 集合内的重要接口，这个也是 <strong><em>List</em></strong> 所不能提供的。</p><p><strong><em>Redis</em></strong> 的 <strong><em>Set</em></strong> 是 <strong><em>String</em></strong> 类型的无序集合。它底层其实是一个 <strong><em>value</em></strong> 为 <strong><em>null</em></strong> 的 <strong><em>hash</em></strong> 表，所以添加，删除，查找的复杂度都是 <strong><em>O(1)</em></strong>。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是 <strong><em>O(1)</em></strong>，数据增加，查找数据的时间不变。</p><blockquote><p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code>：将一个或多个 <strong><em>member</em></strong> 元素加入到集合 <strong><em>key</em></strong> 中，已经存在的 <strong><em>member</em></strong> 元素将被忽略</p><p><code>smembers &lt;key&gt;</code>：取出该集合的所有值。</p><p><code>sismember &lt;key&gt;&lt;value&gt;</code>：判断集合 <strong><em><key></key></em></strong>是否为含有该 <strong><em><value></value></em></strong>值，有返回 1，没有返回 0</p><p><code>scard&lt;key&gt;</code>：返回该集合的元素个数。</p><p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code>：删除集合中的某个元素</p><p><code>spop &lt;key&gt;</code>：随机从该集合中吐出一个值</p><p><code>srandmember &lt;key&gt;&lt;n&gt;</code>：随机从该集合中取出 <strong><em>n</em></strong> 个值，不会从集合中删除</p><p><code>smove &lt;source&gt;&lt;destination&gt;value</code>：把集合中一个值从一个集合移动到另一个集合</p><p><code>sinter &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的交集元素</p><p><code>sunion &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的并集元素</p><p><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的差集元素（<strong><em>key1</em></strong> 中的，不包含 <strong><em>key2</em></strong> 中的）</p></blockquote><p><strong>数据结构</strong></p><p><strong><em>Set</em></strong> 数据结构是字典，字典是用哈希表实现的。</p><h2 id="hash哈希">Hash（哈希）</h2><p><strong><em>Redis hash</em></strong> 是一个键值对集合。</p><p><strong><em>Redis hash</em></strong> 是一个 <strong><em>String</em></strong> 类型的 <strong><em>field</em></strong> 和 <strong><em>value</em></strong> 的映射表，<strong><em>hash</em></strong> 特别适合用于存储对象。</p><blockquote><p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给 <strong><em><key></key></em></strong>集合中的 <strong><em><field></field></em></strong>键赋值 <strong><em><value></value></em></strong></p><p><code>hget &lt;key1&gt;&lt;field&gt;</code>：从 <strong><em><key1></key1></em></strong>集合 <strong><em><field></field></em></strong>取出 <strong><em>value</em></strong></p><p><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code>： 批量设置 <strong><em>hash</em></strong> 的值</p><p><code>hexists &lt;key1&gt;&lt;field&gt;</code>：查看哈希表 <strong><em>key</em></strong> 中，给定域 <strong><em>field</em></strong> 是否存在</p><p><code>hkeys &lt;key&gt;</code>：列出该 <strong><em>hash</em></strong> 集合的所有 <strong><em>field</em></strong></p><p><code>hvals &lt;key&gt;</code>：列出该 <strong><em>hash</em></strong> 集合的所有 <strong><em>value</em></strong></p><p><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>：为哈希表 <strong><em>key</em></strong> 中的域 <strong><em>field</em></strong> 的值加上增量 1 -1</p><p><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：将哈希表 <strong><em>key</em></strong> 中的域 <strong><em>field</em></strong> 的值设置为 <strong><em>value</em></strong> ，当且仅当域 <strong><em>field</em></strong> 不存在</p></blockquote><p><strong>数据结构</strong></p><p><strong><em>Hash</em></strong> 类型对应的数据结构是两种：<strong><em>ziplist</em></strong>（压缩列表），<strong><em>hashtable</em></strong>（哈希表）。</p><p>当 <strong><em>field-value</em></strong> 长度较短且个数较少时，使用 <strong><em>ziplist</em></strong>，否则使用 <strong><em>hashtable</em></strong>。</p><h2 id="zset有序集合">Zset（有序集合）</h2><p><strong><em>Redis</em></strong> 有序集合 <strong><em>zset</em></strong> 与普通集合 <strong><em>set</em></strong> 非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个评分（<strong><em>score</em></strong>）,这个评分（<strong><em>score</em></strong>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。</p><p>因为元素是有序的，所以可以很快的根据评分（<strong><em>score</em></strong>）或者次序（<strong><em>position</em></strong>）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p><blockquote><p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>：将一个或多个 <strong><em>member</em></strong> 元素及其 <strong><em>score</em></strong> 值加入到有序集 <strong><em>key</em></strong> 当中</p><p><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]</code>：返回有序集 <strong><em>key</em></strong> 中，下标在 <strong><em><start><stop></stop></start></em></strong>之间的元素</p><ul><li>当带 <strong><em>WITHSCORES</em></strong>，可以让分数一起和值返回到结果集</li></ul><p><code>zrangebyscore key min max [withscores] [limit offset count]</code>：返回有序集 <strong><em>key</em></strong> 中，所有 <strong><em>score</em></strong> 值介于 <strong><em>min</em></strong> 和 <strong><em>max</em></strong> 之间（包括等于 <strong><em>min</em></strong> 或 <strong><em>max</em></strong> ）的成员。有序集成员按 <strong><em>score</em></strong> 值递增（从小到大）次序排列。</p><p><code>zrevrangebyscore key max min [withscores] [limit offset count]</code>：同上，改为从大到小排列</p><p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code>：为元素的 <strong><em>score</em></strong> 加上增量</p><p><code>zrem &lt;key&gt;&lt;value&gt;</code>：删除该集合下，指定值的元素</p><p><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>：统计该集合，分数区间内的元素个数</p><p><code>zrank &lt;key&gt;&lt;value&gt;</code>：返回该值在集合中的排名，从 0 开始。</p></blockquote><p><strong>数据结构</strong></p><p><strong><em>SortedSet（zset）</em></strong>是 <strong><em>Redis</em></strong> 提供的一个非常特别的数据结构，一方面它等价于 <strong><em>Java</em></strong> 的数据结构 <strong><em>Map&lt;String, Double&gt;</em></strong>，可以给每一个元素 <strong><em>value</em></strong> 赋予一个权重 <strong><em>score</em></strong>，另一方面它又类似于 <strong><em>TreeSet</em></strong>，内部的元素会按照权重 <strong><em>score</em></strong> 进行排序，可以得到每个元素的名次，还可以通过 <strong><em>score</em></strong> 的范围来获取元素的列表。</p><p><strong><em>zset</em></strong> 底层使用了两个数据结构</p><ul><li><strong><em>hash</em></strong>，<strong><em>hash</em></strong> 的作用就是关联元素 <strong><em>value</em></strong> 和权重 <strong><em>score</em></strong>，保障元素 <strong><em>value</em></strong> 的唯一性，可以通过元素 <strong><em>value</em></strong> 找到相应的 <strong><em>score</em></strong> 值</li><li>跳跃表，跳跃表的目的在于给元素 <strong><em>value</em></strong> 排序，根据 <strong><em>score</em></strong> 的范围获取元素列表</li></ul><h1 id="redis的发布与订阅">Redis的发布与订阅</h1><p><strong><em>Redis</em></strong> 发布订阅（ <strong><em>pub/sub</em></strong> ）是一种消息通信模式：发送者（ <strong><em>pub</em></strong> ）发送消息，订阅者（ <strong><em>sub</em></strong> ）接收消息。</p><p><strong><em>Redis</em></strong> 客户端可以订阅任意数量的频道。</p><ol type="1"><li>客户端可以订阅频道</li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220804093321.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></p><ol start="2" type="1"><li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220804093351.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">subscribe channel <span class="hljs-comment"># 订阅频道</span><br><br>publish channel hello <span class="hljs-comment"># 频道发送信息</span><br></code></pre></td></tr></table></figure><h1 id="事务和锁机制">事务和锁机制</h1><p><strong><em>Redis</em></strong> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p><strong><em>Redis</em></strong> 事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p><h2 id="multiexecdiscard"><em>Multi</em>、<em>Exec</em>、<em>Discard</em></h2><figure><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220804140908.png" srcset="/img/loading.gif" lazyload alt="202206241242519"><figcaption>202206241242519</figcaption></figure><p><strong><em>Multi</em></strong></p><p><strong><em>Exec</em></strong></p><p><strong><em>Discard</em></strong></p><p>从输入 <strong><em>Multi</em></strong> 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 <strong><em>Exec</em></strong> 后，<strong><em>Redis</em></strong> 会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过 <strong><em>Discard</em></strong> 来放弃组队。</p><ul><li><p>组队成功，提交成功</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241243427.png" srcset="/img/loading.gif" lazyload></p></li><li><p>放弃组队</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241243951.png" srcset="/img/loading.gif" lazyload></p></li><li><p>组队中有命令错误，不会执行</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241244858.png" srcset="/img/loading.gif" lazyload></p></li><li><p>组队中不报错，执行时报错</p><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241244271.png" srcset="/img/loading.gif" lazyload></p></li></ul><p>当组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><h1 id="jedis操作redis">Jedis操作Redis</h1><p>即 <strong><em>Java</em></strong> 操作 <strong><em>Redis</em></strong>。</p><ol type="1"><li>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>连接 <strong><em>Redis</em></strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.57.101&quot;</span>, <span class="hljs-number">6379</span>);<br>    String pong = jedis.ping();<br>    System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span> + pong);<br>    jedis.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><em>Key</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k3&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>);<br>Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>System.out.println(keys.size());<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br>	System.out.println(key);<br>&#125;<br>System.out.println(jedis.exists(<span class="hljs-string">&quot;k1&quot;</span>));<br>System.out.println(jedis.ttl(<span class="hljs-string">&quot;k1&quot;</span>));                <br>System.out.println(jedis.get(<span class="hljs-string">&quot;k1&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong><em>String</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.mset(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>System.out.println(jedis.mget(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong><em>List</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.lpush(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;lucy&quot;</span>, <span class="hljs-string">&quot;mary&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);<br>List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br>System.out.println(list);<br></code></pre></td></tr></table></figure><blockquote><p>jack,mary,lucy</p></blockquote><p><strong><em>Set</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order01&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order03&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order04&quot;</span>);<br>Set&lt;String&gt; smembers = jedis.smembers(<span class="hljs-string">&quot;orders&quot;</span>);<br><span class="hljs-keyword">for</span> (String order : smembers) &#123;<br>	System.out.println(order);<br>&#125;<br>jedis.srem(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong><em>Hash</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.hset(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>System.out.println(jedis.hget(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>));<br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>map.put(<span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;13810169999&quot;</span>);<br>map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;atguigu&quot;</span>);<br>map.put(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;abc@163.com&quot;</span>);<br>jedis.hmset(<span class="hljs-string">&quot;hash2&quot;</span>,map);<br>List&lt;String&gt; result = jedis.hmget(<span class="hljs-string">&quot;hash2&quot;</span>, <span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br><span class="hljs-keyword">for</span> (String element : result) &#123;<br>	System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><em>zset</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">100d</span>, <span class="hljs-string">&quot;z3&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">90d</span>, <span class="hljs-string">&quot;l4&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">80d</span>, <span class="hljs-string">&quot;w5&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">70d</span>, <span class="hljs-string">&quot;z6&quot;</span>);<br><br>Set&lt;String&gt; zrange = jedis.zrange(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (String e : zrange) &#123;<br>	System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="springboot整合redis">SpringBoot整合Redis</h1><ol type="1"><li>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>配置文件 application.properties 配置 <strong><em>Redis</em></strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">#Redis服务器地址<br>spring.redis.host= ip<br>#Redis服务器连接端口<br>spring.redis.port=<span class="hljs-number">6379</span><br>#Redis数据库索引（默认为0）<br>spring.redis.database= <span class="hljs-number">0</span><br>#连接超时时间（毫秒）<br>spring.redis.timeout=<span class="hljs-number">1800000</span><br>#连接池最大连接数（使用负值表示没有限制）<br>spring.redis.lettuce.pool.max-active=<span class="hljs-number">20</span><br>#最大阻塞等待时间(负数表示没限制)<br>spring.redis.lettuce.pool.max-wait=-<span class="hljs-number">1</span><br>#连接池中的最大空闲连接<br>spring.redis.lettuce.pool.max-idle=<span class="hljs-number">5</span><br>#连接池中的最小空闲连接<br>spring.redis.lettuce.pool.min-idle=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><strong><em>Redis</em></strong> 配置类（需要继承 <strong><em>CachingConfigurerSupport</em></strong>）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CachingConfigurerSupport</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br>				<span class="hljs-comment">// key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br>				<span class="hljs-comment">// value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>				<span class="hljs-comment">// value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>				<span class="hljs-comment">// 解决查询缓存转换异常的问题</span><br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>				<span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        RedisCacheConfiguration config = <br>          RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>   .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Java/">Java</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Redis/">Redis</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处来源：<a href="https://stuxiaozhang.github.io/">小张的宇宙空间站</a></p><div class="post-prevnext"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2022/07/29/SpringBoot%E7%AC%94%E8%AE%B0/"><span class="hidden-mobile">SpringBoot笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",function(){var e=Object.assign({appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:"https://cdn.bootcdn.net/ajax/libs/emojione/4.5.0/lib/js/emojione.min.js",emojiMaps:null,enableQQ:!0,requiredFields:["nick"]},{el:"#valine",path:window.location.pathname});new Valine(e)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://stuxiaozhang.github.io" target="_blank" rel="nofollow noopener"><span>小张同学的宇宙空间站</span></a> 已经运转了<span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{renderActions:{findScript:[10,a=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const n=new a.options.MathItem(e.textContent,a.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),n.start={node:t,delim:"",n:0},n.end={node:t,delim:"",n:0},a.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>