<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux常用指令记录</title>
    <link href="/2021/10/13/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/10/13/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>以后学某一项技术，可以去看官方文档入门教程。以后边写边查即可。(from y总)</p><p>不定时更新。努力学习记录中...:p</p>          </div><h2 id="文件管理命令">文件管理命令</h2><p><code>.</code>：当前目录（也是文件）</p><p><code>..</code>：上层目录</p><p>绝对路径 以 <code>/</code> 开头，相对路径直接是文件夹名</p><p>常用命令介绍</p><ol type="1"><li><p><code>ctrl c</code>：取消命令，并且换行（比如说你不想打这行或者打错了，直接 crtl c 换一行，就是 换行＋清空）</p></li><li><p><code>ctrl u</code>：清空本行命令</p></li><li><p><code>tab键</code>：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p><code>ls</code>: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p><ul><li><code>-a</code> 显示所有文件及目录 (. 开头的隐藏文件也会列出)</li><li><code>-l</code> 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<ul><li><code>-lh</code> 加个 h，可以人性化输出，比如 30952字节，就会写成 31k，方便看~</li></ul></li><li><code>-A</code> 同 <code>-a</code> ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录)</li><li><code>-t</code> 按建立时间</li></ul></li><li><p><code>pwd</code>：显示当前路径</p></li><li><p><code>cd XXX</code>： 进入XXX目录下，<code>cd ..</code> 返回上层目录</p></li><li><p><code>cp XXX YYY</code>：将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如 ../dir_c/a.txt，表示上层目录下的 dir_c 文件夹下的文件 a.txt</p><p><code>cp</code> = 复制 + 粘贴 + 重命名</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211013194235811.png"  /></p><p>可以将一个文件夹整个复制到另一个文件夹下面：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211013195447038.png" alt="image-20211013195447038" /><figcaption>image-20211013195447038</figcaption></figure><p>也可以将一个文件夹复制到当前目录下：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211013202037725.png" /></p><p>Note：复制文件夹一定要加 <code>-r</code> （r 是递归的缩写）</p></li><li><p><code>mkdir XXX</code>：创建目录XXX</p><blockquote><p>遇到文件夹名称有空格，转义字符就行 <code>/</code>。eg <code>cp a y/ c</code></p></blockquote></li><li><p><code>rm XXX</code>：删除普通文件;</p><p><code>rm XXX -r</code>：删除文件夹</p><p>可以删掉整个文件夹连带着里面的文件</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211013204307488.png" /></p><p>也可以只删除文件夹下面的文件而保留文件夹</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211013204516116.png" /></p></li><li><p><code>mv XXX YYY</code>：剪切+粘贴+重命名。将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211013205719642.png" /></p><p>重命名也是用这个命令</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211013205810011.png" /></p><blockquote><p>cp：是拷贝一份</p><p>mv：是移动一份</p></blockquote></li><li><p><code>touch XXX</code>：创建一个文件</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211013203427931.png" /></p></li><li><p><code>cat XXX</code>：展示文件XXX中的内容</p></li><li><p>复制文本 windows/Linux下：<code>Ctrl + insert</code>，Mac下：<code>command + c</code></p></li><li><p>粘贴文本 windows/Linux下：<code>Shift + insert</code>，Mac下：<code>command + v</code></p></li></ol><blockquote><p>笔记本上需要加 fn 键，复制是 <code>ctrl + fn + insert</code>，粘贴是 <code>shift + fn +insert</code></p></blockquote><h2 id="tmux">tmux</h2><h3 id="功能">功能：</h3><ol type="1"><li>分屏。</li><li><strong>允许断开Terminal连接后，继续运行进程</strong>。</li></ol><h3 id="结构">结构：</h3><p>一个 tmux 可以包含多个 session，一个 session 可以包含多个 window，一个 window 可以包含多个 pane。</p><h3 id="实例">实例：</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">tmux:<br>session <span class="hljs-number">0</span>:<br><span class="hljs-built_in">window</span> <span class="hljs-number">0</span>:<br>pane <span class="hljs-number">0</span><br>pane <span class="hljs-number">1</span><br>pane <span class="hljs-number">2</span><br>...<br><span class="hljs-built_in">window</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">window</span> <span class="hljs-number">2</span><br>...<br>session <span class="hljs-number">1</span><br>session <span class="hljs-number">2</span><br>...<br></code></pre></td></tr></table></figure><p>操作：</p><ol type="1"><li><p><code>tmux</code>：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>%</code>：将当前pane左右平分成两个pane。</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>&quot;</code>（注意是双引号&quot;）：将当前pane上下平分成两个pane。</p></li><li><p><code>Ctrl + d</code>：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</p></li><li><p>鼠标点击可以选pane。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按方向键：选择相邻的pane。</p></li><li><p>鼠标拖动pane之间的分割线，可以调整分割线的位置。</p></li><li><p>按住<code>ctrl + a</code>的同时按方向键，可以调整pane之间分割线的位置。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>z</code>：将当前pane全屏/取消全屏。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>d</code>：挂起当前session。</p></li><li><p><code>tmux a</code>：打开之前挂起的session。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>s</code>：选择其它session。 方向键 —— 上：选择上一项 session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键 —— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>c</code>：在当前session中创建一个新的window。</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>w</code>：选择其他window，操作方法与(12)完全相同。</p><blockquote><p>每个 session 开一个 window 这样清楚些..</p></blockquote></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>PageUp</code>：翻阅当前pane内的内容。</p></li><li><p><code>鼠标滚轮</code>：翻阅当前pane内的内容。</p></li><li><p>在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</p></li><li><p>tmux中复制/粘贴文本的通用方式：</p></li><li><p>按下<code>Ctrl + a</code>后松开手指，然后按<code>[</code></p></li><li><p>用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</p></li><li><p>按下Ctrl + a后松开手指，然后按<code>]</code>，会将剪贴板中的内容粘贴到光标处</p></li></ol><h2 id="vim-教程">vim 教程</h2><h3 id="功能-1">功能：</h3><ol type="1"><li><p>命令行模式下的文本编辑器。</p></li><li><p>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</p></li><li><p>使用方式：<code>vim filename</code> 如果已有该文件，则打开它。 如果没有该文件，则打开个一个新的文件，并命名为filename</p></li></ol><h3 id="模式">模式：</h3><ol type="1"><li><p>一般命令模式</p><p>默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</p></li><li><p>编辑模式</p><p>在一般命令模式里按下<code>i</code>，会进入编辑模式。 按下<code>ESC</code>会退出编辑模式，返回到一般命令模式。</p></li><li><p>命令行模式</p><p>在一般命令模式里按下<code>: / ?</code>三个字母中的任意一个，会进入命令行模式。命令行在最下面。 可以查找、替换、保存、退出、配置编辑器等。</p></li></ol><h3 id="操作">操作：</h3><ol type="1"><li><p><code>i</code>：进入编辑模式</p></li><li><p><code>ESC</code>：进入一般命令模式</p></li><li><p><code>h</code> 或 <code>左箭头键</code>：光标向左移动一个字符</p></li><li><p><code>j</code> 或 <code>向下箭头</code>：光标向下移动一个字符</p></li><li><p><code>k</code> 或 <code>向上箭头</code>：光标向上移动一个字符</p></li><li><p><code>l</code> 或 <code>向右箭头</code>：光标向右移动一个字符</p></li><li><p><code>n&lt;Space&gt;</code>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</p></li><li><p><code>0</code> 或 <code>功能键[Home]</code>：光标移动到本行开头</p></li><li><p><code>$</code> 或 <code>功能键[End]</code>：光标移动到本行末尾</p></li><li><p><code>G</code>：光标移动到最后一行</p></li><li><p><code>:n</code> 或 <code>nG</code>：n为数字，光标移动到第n行</p></li><li><p><code>gg</code>：光标移动到第一行，相当于1G</p></li><li><p><code>n&lt;Enter&gt;</code>：n为数字，光标向下移动n行</p></li><li><p><code>/word</code>：向光标之下寻找第一个值为word的字符串。7</p></li><li><p><code>?word</code>：向光标之上寻找第一个值为word的字符串。</p></li><li><p><code>n</code>：重复前一个查找操作</p></li><li><p><code>N</code>：反向重复前一个查找操作</p></li><li><p><code>:n1,n2s/word1/word2/g</code>：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</p></li><li><p><code>:1,$s/word1/word2/g</code>：将全文的word1替换为word2</p></li><li><p><code>:1,$s/word1/word2/gc</code>：将全文的word1替换为word2，且在替换前要求用户确认。</p></li><li><p><code>v</code>：选中文本</p></li><li><p><code>d</code>：删除选中的文本.其实是剪切，可以粘贴回来的.</p></li><li><p><code>dd</code>：删除当前行</p></li><li><p><code>y</code>：复制选中的文本</p></li><li><p><code>yy</code>：复制当前行</p></li><li><p><code>p</code>：将复制的数据在光标的下一行/下一个位置粘贴</p></li><li><p><code>u</code>：撤销</p></li><li><p><code>Ctrl + r</code>：取消撤销</p></li><li><p><code>大于号 &gt;</code>：将选中的文本整体向右缩进一次</p></li><li><p><code>小于号 &lt;</code>：将选中的文本整体向左缩进一次</p></li><li><p><code>:w</code> 保存</p></li><li><p><code>:w!</code> 强制保存</p></li><li><p><code>:q</code> 退出</p></li><li><p><code>:q!</code> 强制退出</p></li><li><p><code>:wq</code> 保存并退出</p></li><li><p><code>:set paste</code> 设置成粘贴模式，取消代码自动缩进</p></li><li><p><code>:set nopaste</code> 取消粘贴模式，开启代码自动缩进</p></li><li><p><code>:set nu</code> 显示行号</p></li><li><p><code>:set nonu</code> 隐藏行号(为了复制文本时没有行号)</p></li><li><p><code>gg=G</code>：将全文代码格式化。</p><p><code>ggdG</code>：全删</p></li><li><p><code>:noh</code> 关闭查找关键词高亮</p></li><li><p><code>Ctrl + q</code>：当vim卡死时，可以取消当前正在执行的命令</p></li></ol><h3 id="异常处理">异常处理：</h3><p>每次用vim编辑文件时，会自动创建一个<code>.filename.swp</code>的临时文件。</p><p>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</p><ol type="1"><li>找到正在打开该文件的程序，并退出</li><li>直接删掉该swp文件即可</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPL：Collaborative Policy Learning for Open Knowledge Graph Reasoning</title>
    <link href="/2021/10/12/CPL%EF%BC%9ACollaborative%20Policy%20Learning%20for%20Open%20Knowledge%20Graph%20Reasoning/"/>
    <url>/2021/10/12/CPL%EF%BC%9ACollaborative%20Policy%20Learning%20for%20Open%20Knowledge%20Graph%20Reasoning/</url>
    
    <content type="html"><![CDATA[<h1 id="cplcollaborative-policy-learning-for-open-knowledge-graph-reasoning">CPL：Collaborative Policy Learning for Open Knowledge Graph Reasoning</h1><p>这是一篇发表在 EMNLP 2019 上的文章. 提出了一个强化学习框架 CPL 联合了两个 agent：multi-hop graph reasoner 和 fact extractor.</p><h2 id="basic-idea">Basic Idea</h2><p><u>开放知识图谱推理 OKGR 是一项旨在通过背景文本语料库对图中缺失的事实进行推理的任务。</u>该任务的一个关键挑战是过滤掉从语料库中抽取的“无关”事实，以便在路径推理过程中保持有效的搜索空间。本文提出了一个新的强化学习框架 CPL 来联合训练两个 collaborative agent，即 a multi-hop graph reasoner and a fact extractor。fact extractor agent 从语料库生成事实三元组，以动态地丰富 graph；而 reasoning agent 则向 fact extractor 提供反馈，并引导其提升有助于解释性推理的事实。</p><h2 id="background">Background</h2><blockquote><p>目前这些推理方法将链接推理任务定义为图上的路径查找问题。</p></blockquote><p>目前的推理方法面临以下两个主要挑战：</p><ol type="1"><li>它们的性能往往对图的稀疏性和完整性敏感，缺少边（即潜在的 false negatives）使得寻找到达目标实体的证据路径变得更加困难。</li><li>现有模型假设 graph 是静态的，并且不能适应 不断添加新事实的动态丰富的 graph 。此外，向图中添加大量边将创建无效的搜索空间，并导致路径查找模型的可伸缩性问题。</li></ol><p>因此，需要设计一种能够过滤掉不相关事实的方法来扩充推理模型。</p><blockquote><p>通常，KGR 方法通过对找到的路径进行排序来生成多个候选答案，而传统的 KG 完成方法通过穷举枚举对所有可能的答案三元组进行排序。</p></blockquote><h2 id="some-defination-about-mdp">Some Defination About MDP</h2><ul><li><span class="math inline">\(G\)</span>：三元组集合</li><li><em>background corpus</em>：背景语料库是 标有各自实体对的句子 的集合。<span class="math inline">\(C = \left\{\left(s_{i}:\left(e_{k}, e_{j}\right)\right) \mid s_{i} \in S, e_{k}, e_{j} \in E\right\}\)</span> ，S 是句子集，语料库与 G 共享同一实体集</li></ul><p>CPL 联合训练两个 agent。给定一个查询 <span class="math inline">\((e_s,r_q,e_q)\)</span>，reasoning agent 试图通过在（扩充的） G 上找到一条推理路径来推断 <span class="math inline">\(e_q\)</span>，而 fact extraction agent 则旨在从 C 中选择信息量最大的事实来动态丰富 G。有了这样一个抽取器，框架可以有效地克服<strong>边缘稀疏问题</strong>，同时保持合理的效率（与将所有可能的事实添加到 G 中的 naive 解决方案相比）。通过根据 reasoning agent 的性能对 fact extraction agent 进行奖励来训练 fact extraction agent 。因此， fact extraction agent 可以学习如何抽取信息量最大的事实，以利于推理。</p><h3 id="graph-reasoning-agent">Graph Reasoning Agent</h3><p><strong>推理代理的目标是通过 KG 上的路径查找学习推理。</strong></p><p>MDP 定义：</p><p><strong>State.</strong>：<span class="math inline">\(s_{R}^{t}=\left(e_{s}, r_{q}, h^{t}\right) \in \mathcal{S}_{R}\)</span> ，<span class="math inline">\(h_t\)</span> 是历史路径，<span class="math inline">\((e_s,r_q)\)</span> 是所有状态共享的 context。用 LSTM 编码历史路径： <span class="math display">\[h^{t}=\operatorname{LSTM}\left(h^{t-1},\left[r^{t}, e^{t}\right]\right)\]</span> 其中，<span class="math inline">\(e^t\)</span> 是当前推理位置，<span class="math inline">\(r^t\)</span> 是前一个连接 <span class="math inline">\(e^t\)</span> 的关系</p><p><strong>Action.</strong> <span class="math inline">\(e^t\)</span> 的出边。其实就是 <span class="math inline">\(G \cup C\)</span>，下文会提.</p><p><strong>Transtion.</strong> 转移函数 <span class="math inline">\(f(s_{R}^{t}, a_{R}^{t})=(e^{s}, r^{q}, h^{t+1})\)</span></p><p><strong>Reward.</strong> 只有当它到达正确的目标实体时，才会收到终端奖励1，否则为0。所有中间状态始终获得奖励0。</p><h3 id="fact-extraction-agent">Fact Extraction Agent</h3><p><strong>事实抽取代理学习在推理代理的当前推理步骤中，提出最相关的事实。</strong>即，推理代理在时间 t 到达图中实体 <span class="math inline">\(e^t\)</span>，事实抽取代理将从语料库中抽取 <span class="math inline">\(\left(e^{t}, r^{\prime}, e^{\prime}\right) \notin G\)</span> ，并将它们临时添加到图表中。</p><p><strong>State.</strong> 找 <span class="math inline">\(e_t\)</span> 的出边。<span class="math inline">\(b_{e^t}\)</span> 是标有 <span class="math inline">\((e^t,e&#39;)\)</span> 的<font color="red">句子袋?</font>，定义事实抽取代理的状态 <span class="math inline">\(s_{E}^{t}=\left(b_{e^{t} }, e^{t}\right) \in \mathcal{S}_{E}\)</span>，<span class="math inline">\(\mathcal{S}_{E}\)</span> 是整个 state space。</p><p><strong>Action.</strong> 事实抽取器的目标是从语义上选择语料库中包含的与推理相关的事实。当推理代理在时间 t 移动到 <span class="math inline">\(e_t\)</span>，事实抽取代理从句子袋中抽取 <span class="math inline">\((e^{t}, r^{\prime}, e^{\prime})\)</span> ，可以获得动作 <span class="math inline">\(a_{E}^{t}=\left(r^{\prime}, e^{\prime}\right)\)</span> 。Action space 定义为 <span class="math inline">\(A^t_E=\left\{\left(r^{\prime}, e^{\prime}\right)\right\}\left(e^{t}, r^{\prime}, e^{\prime}\right) \in b_{e t} \subset \mathcal{A}_{E}\)</span></p><p><strong>Transtion.</strong> 转移函数 <span class="math inline">\(f\left(s_{E}^{t}, a_{E}^{t}\right)=\left(r^{\prime}, e^{\prime}\right)\)</span></p><p><strong>Reward.</strong> 事实抽取代理将从推理代理获得一个 step-wise delayed reward 。当事实抽取代理提的建议有利于推理过程时，将得到积极的奖励。</p><h2 id="cplcollaborative-policy-learning">CPL：Collaborative Policy Learning</h2><p>作者采用一种替代性的训练过程来联合更新两个代理：训练其中一个代理进行几次迭代，同时冻结另一个代理；反之亦然。两个代理的策略都通过强化算法更新。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211017100442824.png" /></p><h3 id="augmented-action-space-for-reasoning.">Augmented Action Space for Reasoning.</h3><p>事实抽取代理抽取高置信度的边，添加到推理代理的动作空间中。</p><p><span class="math inline">\(A_{K}^{t}\)</span> 是 current KG 里的出边。 <span class="math display">\[A_{K}^{t}=\left\{(r, e) \mid\left(e^{t}, r, e\right) \in G\right\}\]</span> <span class="math inline">\(A_{C}^{t}\)</span> 是抽取代理抽取出的出边。 <span class="math display">\[A_{C}^{t}=\left\{\left(r^{\prime}, e^{\prime}\right) \mid\left(e^{t}, r^{\prime}, e^{\prime}\right) \in C\right\}\]</span> 所以推理代理的 Action space <span class="math inline">\(A_{R}^{t}\)</span> 为： <span class="math display">\[A_{R}^{t}=A_{K}^{t} \cup A_{C}^{t}, A_{R}^{t} \subset \mathcal{A}_{R}\]</span></p><h3 id="reasoning-feedback-for-fact-extraction.">Reasoning Feedback for Fact Extraction.</h3><p>Reasoner 通过 extractor 对推理的贡献程度的反馈，帮助 extractor 学习提取策略。因此，定义事实提取代理从推理代理处获得 step-wise reward。</p><p>具体来说，当推理代理正确到达目标时，认为这条路径是有效的，正确的推理。如果抽取代理有助于这条正确的推理路径，就可以获得积极的奖励。即，如果抽取器在时间 t 抽取了正确推理路径上的边（<span class="math inline">\(0≤ t≤ T\)</span>），抽取器将在时间 t 奖励 1，否则奖励 0。触发 positive reward 的提取边将保留在图中，而当两个代理移动到下一个状态时，其他边将被删除。</p><blockquote><p>即使正确到达目标，路径就一定正确吗？如何去衡量这条路径？我只知道PCRA....有没有其他新一点的方法？</p></blockquote><h3 id="policy-update.">Policy Update.</h3><p>使用强化学习来训练两个代理，目标是最大化 reward： <span class="math display">\[J(\theta)=\mathbb{E}_{\pi_{\theta}(a \mid s)}[R(s, a)]\]</span> 其中，<span class="math inline">\(R(s,a)\)</span> 是给定 s 选择 a 的 reward，</p><p>给定训练 <span class="math inline">\(\pi_{\theta} = \left\{\left(s^{1}, a^{1}, r^{1}\right), \ldots,\left(s^{T}, a^{T}, r^{T}\right)\right\}, r^{t}=R\left(s^{t}, a^{t}\right)\)</span>，参数通过 RL 更新： <span class="math display">\[\begin{array}{c}\theta \leftarrow \theta+\alpha \nabla_{\theta} \log \pi_{\theta}\left(a^{t} \mid s^{t}\right) G^{t} \\G^{t}=\sum_{k=t}^{T} \gamma^{k-t} R\left(s^{k}, a^{k}\right)\end{array}\]</span> 其中，<span class="math inline">\(G^t\)</span> 是 discounted accumulated reward。可以发现，参数只有当 <span class="math inline">\(G^t\)</span> 非0的时候才更新，而 <span class="math inline">\(G^t\)</span> 又由参数 <span class="math inline">\(\gamma\)</span> 决定。如果 <span class="math inline">\(γ&gt;0\)</span>，对于正确训练序列，容易验证所有状态的 <span class="math inline">\(G^t\)</span>值都将为非零。因此，内部状态将得到积极奖励，模型参数将通过内部状态的梯度进行更新。对于不同的任务，应该仔细选择 <span class="math inline">\(γ\)</span> 的值。对于抽取器设置 <span class="math inline">\(γ=0\)</span>，以避免对零奖励状态根据经验进行策略更新。这是因为零回报的经历大多是负面的例子。具体地说，如果提取器的状态为零，可以推断建议的边没有被推理器选择，或者选择的边没有帮助到达目标。我们不能允许模型根据这些经验进行更新，因此设置 <span class="math inline">\(γ=0\)</span> 以避免未来的影响。相反，推理器设置 <span class="math inline">\(γ=1\)</span>，因为所有中间选择的边都是有意义的，只要它最终指向目标。</p><h4 id="train">Train</h4><p>使用 model pre-training 和 adaptive sampling 来提高训练效率。特别是，首先在原始 KG 上训练 reasoner agent，以获得更好的初始化。同样，作者在远程监督标记的语料库上训练事实抽取器。接下来，在为两个代理生成训练经验时，作者使用自适应采样自适应地增加抽取的边的选择优先级。自适应采样旨在鼓励推理代理探索更多新的边，并促进联合培训期间的协作。Replay memories 也用于提高训练效率。</p><h4 id="inference">Inference</h4><p>在推理时，作者使用经过训练的模型通过 path finding 来预测缺失的事实。该过程类似于 training 阶段的生成训练经验，即，使用 reasoner 进行路径推理，而 extractor 不断地从语料库中抽取 edge。唯一的区别是推断不要求 reward，作者使用 beam search 在图上生成多条推理路径，并根据 reasoner 的得分对它们进行排序。</p><h2 id="policy-network-architectures">Policy Network Architectures</h2><h3 id="reasoning-agent.">Reasoning Agent.</h3><p>state embedding，action embedding： <span class="math display">\[s_{R}^{t}=\left[e_{s}, r_{q}, h^{t}\right] \\h^{t}=\mathrm{LSTM}\left(h^{t-1},\left[r^{t}, e^{t}\right]\right) \\a_{R}^{t}=[r, e],\left(e^{t}, r, e\right) \in G \cup C \\\]</span> Policy network： <span class="math display">\[\pi_{\theta}\left(a_{R}^{t} \mid s_{R}^{t}\right)=\sigma\left(\mathbf{A}_{R}^{t} W_{2}\left(\operatorname{Relu}\left(W_{1}\left[e_{s}, r_{q}, h^{t}\right]\right)\right)\right)\]</span></p><h3 id="fact-extraction-agent.">Fact extraction Agent.</h3><p><span class="math inline">\(b_{e^t}\)</span> 是标有 <span class="math inline">\((e^t,e&#39;)\)</span> 的句子袋，将 <span class="math inline">\(b_{e^t}\)</span> 输入 PCNN-ATT 获得 句子袋级别的 embeddings <span class="math inline">\(E^t_b\)</span> <span class="math display">\[\pi_{\theta}\left(a_{E}^{t} \mid s_{E}^{t}\right)=\sigma\left(\mathbf{A}_{E}^{t} W E_{b}^{t}\right)\]</span></p><blockquote><p>PCNN-ATT 没看，还有什么是句子袋？？</p></blockquote><h2 id="summary">Summary</h2><p>本文作者在“开放世界”环境下研究知识图推理，从背景语料库中抽取的新事实可用于促进路径发现。然后，依据此提出了一种新的协作策略学习（CPL）框架，以相互增强的方式联合训练两个RL代理。在CPL中，除了训练用于路径发现的 Reasoner Agent 之外，还引入了Fact Extractor Agent，该代理根据推理过程和语料库的上下文学习从语料库中抽取相关事实的策略。在推理时，事实抽取代理仅使用信息量最大的边动态扩充图，从而使推理代理能够有效地识别正路径。</p><div class="note note-primary">            <p>推理代理通过抽取代理的置信度分数进行正反馈，帮助抽取代理学习策略。作者认为推理代理正确到达目标时，认为这条路径是有效的，正确的推理。</p><p>但是我觉着，即使正确到达目标，路径就一定正确吗？作者是如何去衡量这条路径的(我没看源码==)？我只知道PCRA....有没有其他新一点的方法？</p>          </div>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>KGR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Multi-Hop Knowledge Graph Reasoning with Reward Shaping</title>
    <link href="/2021/10/11/Multi-Hop%20Knowledge%20Graph%20Reasoning%20with%20Reward%20Shaping/"/>
    <url>/2021/10/11/Multi-Hop%20Knowledge%20Graph%20Reasoning%20with%20Reward%20Shaping/</url>
    
    <content type="html"><![CDATA[<h1 id="multi-hop-knowledge-graph-reasoning-with-reward-shaping">Multi-Hop Knowledge Graph Reasoning with Reward Shaping</h1><p>该论文基于上篇 MINERVA（Das ICLR 2018）指出了强化学习在 incomplete knowledge graph 中进行 reasoning 时存在的两个问题，</p><ol type="1"><li>虚假负reward：查询出的路径由于知识图谱中的信息缺失导致判定为错误路径</li><li>虚假路径：由假路径导致的偶然正确答案。由于强化学习是一种基于策略的算法，鼓励过去的行动，并反馈回较高的reward，因此会更偏向初期存在的虚假正确的情况。(false positive path)</li></ol><p>针对以上问题,本文提出解决方案：Reward Shaping 和 Action dropout</p><h2 id="background">Background</h2><p>多跳推理是解决 incomplete knowledge graph 问题的一种有效方法。该问题可以在强化学习（RL）设置中表述，其中基于 policy 的代理顺序扩展其推理路径，直到到达目标。然而，在一个不完整的 KG 环境中，代理会收到训练数据中的 false negatives 所破坏造成的低质量奖励，这会损害测试时的泛化。此外，由于没有正确动作序列用于训练，代理可能会被虚假的搜索轨迹误导，从而意外地导致正确答案(false positive path)。</p><p>最近的工作 MINERVA 将多跳推理表述为一个顺序决策问题，并利用强化学习（RL）执行有效的路径搜索。MINERVA 使用强化算法训练多跳 KG query answering 的端到端模型：给定查询关系和源实体，经过训练的代理从源开始搜索 KG，并在不访问任何预计算路径的情况下到达候选答案。</p><h2 id="model">Model</h2><h3 id="rl-formulation">RL Formulation</h3><p>使用马尔科夫随机过程(Markov Decision Process)：</p><ul><li><p><strong>States.</strong> <span class="math inline">\(s_{t}=\left(e_{t},\left(e_{s}, r_{q}\right)\right) \in \mathcal{S}\)</span> ，<span class="math inline">\(e_t\)</span> 是 step t 下的实体，<span class="math inline">\((e_{s}, r_{q})\)</span> 是原实体和查询关系。</p></li><li><p><strong>Actions.</strong> <span class="math inline">\(A_{t}=\left\{\left(r^{\prime}, e^{\prime}\right) \mid\left(e_{t}, r^{\prime}, e^{\prime}\right) \in \mathcal{G}\right\}\)</span> ，<span class="math inline">\(e_t\)</span> 的出边</p></li><li><p><strong>Transition.</strong> <span class="math inline">\(\delta\left(s_{t}, A_{t}\right)=\delta\left(e_{t},\left(e_{s}, r_{q}\right), A_{t}\right)\)</span></p></li><li><p><strong>Rewards.</strong> 在默认公式中，如果代理在搜索结束时到达正确的目标实体，则代理将收到1的最终奖励，否则为0。</p></li></ul><p><span class="math display">\[R_{b}\left(s_{T}\right)=\mathbb{1}\left\{\left(e_{s}, r_{q}, e_{T}\right) \in \mathcal{G}\right\}\]</span></p><h3 id="policy-network">Policy Network</h3><p>搜索策略使用 state 信息和 全局上下文 以及 搜索历史记录 <span class="math inline">\(h_t\)</span> 进行参数化.</p><p>搜索历史记录 <span class="math inline">\(h_t\)</span> 由步骤 t 之前采取的行动序列 $ h_t = (e_{s}, r_{1}, e_{1}, , r_{t}, e_{t}) $ 组成，用 LSTM 进行编码: <span class="math display">\[\begin{aligned}\mathbf{h}_{0} &amp;=\operatorname{LSTM}\left(\mathbf{0},\left[\mathbf{r}_{0} ; \mathbf{e}_{s}\right]\right) \\\mathbf{h}_{t} &amp;=\operatorname{LSTM}\left(\mathbf{h}_{t-1}, \mathbf{a}_{t-1}\right), t&gt;0\end{aligned}\]</span> 其中，<span class="math inline">\(r_0\)</span> 是从 <span class="math inline">\(e_s\)</span> 开始的关系，<span class="math inline">\(a_t = (t_{t+1}, e_{t+1})\)</span></p><p>Policy Network 定义为： <span class="math display">\[\pi_{\theta}\left(a_{t} \mid s_{t}\right)=\sigma\left(\mathbf{A}_{t} \times W_{2} \operatorname{ReLU}\left(W_{1}\left[\mathbf{e}_{t} ; \mathbf{h}_{t} ; \mathbf{r}_{q}\right]\right)\right)\]</span> 其中，动作空间 <span class="math inline">\(A_t\)</span> 是通过叠加所有动作的嵌入来编码的。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20211012135638682.png" /></p><h3 id="knowledge-based-reward-shaping">Knowledge-Based Reward Shaping</h3><p>MINERVA 中的奖励函数就是，正确奖励1，其余为0. 然而 G 本质上是不完整的，这种方法惩罚 false negative 搜索的方式与 true negatives 相同。 <span class="math display">\[R\left(s_{T}\right)=R_{b}\left(s_{T}\right)+\left(1-R_{b}\left(s_{T}\right)\right) f\left(e_{s}, r_{q}, e_{T}\right)\]</span></p><h3 id="optimization">Optimization</h3><p>Policy Network 通过最大化预期 reward 进行训练。其实我觉得就是目标函数。 <span class="math display">\[J(\theta)=\mathbb{E}_{\left(e_{s}, r, e_{o}\right) \in \mathcal{G}}\left[\mathbb{E}_{a_{1}, \ldots, a_{T} \sim \pi_{\theta}}\left[R\left(s_{T} \mid e_{s}, r\right)\right]\right]\]</span> 用 SGD 更新参数 <span class="math inline">\(\theta\)</span>： <span class="math display">\[\nabla_{\theta} J(\theta) \approx \nabla_{\theta} \sum_{t=1}^{T} R\left(s_{T} \mid e_{s}, r\right) \log \pi_{\theta}\left(a_{t} \mid s_{t}\right)\]</span></p><h3 id="action-dropout">Action dropout</h3><blockquote><p>一般情况下，虚假路径多于正确路径，因此通常首先发现虚假路径，随后的探索可能会越来越偏向于这些路径。具有较大扇入（入度）和扇出（出度）的实体，这种现象更严重。</p></blockquote><p>为了避免虚假路径误导模型，模型根据状态计算当前动作的概率，加入随机的伯努利分布，从而使得部分动作被屏蔽，公式中用于平滑当动作被屏蔽时的概率分布，使得被误导的模型也能有机会找到正确的滤镜加以训练。 <span class="math display">\[\begin{array}{l}\tilde{\pi}_{\theta}\left(a_{t} \mid s_{t}\right) \propto\left(\pi_{\theta}\left(a_{t} \mid s_{t}\right) \cdot \mathbf{m}+\epsilon\right) \\m_{i} \sim \operatorname{Bernoulli}(1-\alpha), i=1, \ldots\left|A_{t}\right|\end{array}\]</span> 其中，<span class="math inline">\(\mathbf{m} \in\{0,1\}^{\left|A_{t}\right|}\)</span> 是一个从伯努利分布中采样的二元变量，参数为 <span class="math inline">\(1-α\)</span>。 在 m=0 的情况下，使用一个小值 <span class="math inline">\(ϵ\)</span> 来平滑分布，其中 <span class="math inline">\(\tilde{\pi}_{\theta}\left(a_{t} \mid s_{t}\right)\)</span> 变得均匀。</p><h2 id="summary">Summary</h2><p>为了解决 MINERVA，作者在其基础上提出了两个 RL 方法进行改进：</p><ol type="1"><li>Reward Shaping：通过采用 pretrained one-hop embedding model，对任意三元组有一个预期奖励，有效避免训练时 False Negatives 对测试效果造成的影响。</li><li>Action dropout：对每一个路径上的中间实体，随机对其出边进行dropout，以强制有效探索不同的路径集，并稀释虚假路径的负面影响。</li></ol>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>KGR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go for a Walk and Arrive at the Answer：Reasoning Over Paths in Knowledge Bases using Reinforcement Learning</title>
    <link href="/2021/10/08/Go%20for%20a%20Walk%20and%20Arrive%20at%20the%20Answer%EF%BC%9AReasoning%20Over%20Paths%20in%20Knowledge%20Bases%20using%20Reinforcement%20Learning/"/>
    <url>/2021/10/08/Go%20for%20a%20Walk%20and%20Arrive%20at%20the%20Answer%EF%BC%9AReasoning%20Over%20Paths%20in%20Knowledge%20Bases%20using%20Reinforcement%20Learning/</url>
    
    <content type="html"><![CDATA[<h1 id="go-for-a-walk-and-arrive-at-the-answer-reasoning-over-paths-in-knowledge-bases-using-reinforcement-learning">Go for a Walk and Arrive at the Answer: Reasoning Over Paths in Knowledge Bases using Reinforcement Learning</h1><p>在知识图谱补全任务中，大多数模型都是依赖低维 representation 对三元组进行打分。本文提出了一种基于输入问题的强化学习（RL）方法，该方法可以有效地在图中搜索答案提供路径，从而消除了对预计算路径的任何需要。给定一个海量知识图，我们学习一个策略，该策略在给定查询 <code>(entity1,relation,?)</code>的情况下，从 entity1 开始，通过选择在每一步取一个带标签的关系边，学习走到答案节点，条件是查询关系和整个路径历史。这将查询-应答任务描述为强化学习（RL）问题，其目标是采取最佳决策序列（选择关系边）以最大化预期回报（到达正确的答案节点）。称 RL 代理 MINERVA 为 ”Meandering In Networks of Entities to Reach Verisimilar Answers.”</p><p>MINERVA 的特点：</p><ol type="1"><li>首先，MINERVA 具有采用可变长度路径的内置灵活性，这对于回答需要复杂推理链的较难问题很重要。</li><li>其次，MINERVA 不需要预先训练，通过强化学习从零开始在知识图上进行训练；无需进行其他监督或微调，这表明 RL 在 NLP 中的先前应用取得了重大进展。</li><li>第三，作者的基于路径的方法在计算上是高效的，因为通过在查询实体周围的一个小邻域中搜索，它避免了像以前的工作一样在KB中对所有实体进行排序。</li><li>最后，模型的代理发现的推理路径自动形成其预测的可解释来源。</li></ol><h2 id="model">Model</h2><h3 id="environment">Environment</h3><p>我们的环境是一个有限视界的、确定性的、部分观测的<strong>马尔可夫决策过程</strong>，它依赖于从知识库导出的知识图谱 G。在这个图上，现将指定一个确定性的部分观测马尔可夫决策过程，它是一个5元组 <span class="math inline">\((S,O,a,δ,R)\)</span></p><p><strong>States.</strong> 当前所在节点 <span class="math inline">\(e_t\)</span>，初始节点 <span class="math inline">\(e_{1q}\)</span>，初始查询关系 <span class="math inline">\(r_q\)</span>，正确答案 <span class="math inline">\(e_{2q}\)</span> 四元组。所以 State 表示为 <span class="math inline">\(S = (e_t,e_{1q},r_q,e_{2q})\)</span></p><p><strong>Observations.</strong> 未观察到环境的完整状态。即 除了正确答案 <span class="math inline">\(e_{2q}\)</span> 无法观测之外 都知道。所以函数定义为 <span class="math inline">\(O(s=(e_t,e_{1q},r_q,e_{2q}))=(e_t,e_{1q},r_q)。\)</span></p><p><strong>Actions.</strong> 由当前节点 <span class="math inline">\(e_t\)</span> 的关联的三元组 <span class="math inline">\(\mathcal{A}_{S}=\left\{\left(e_t, r, v\right) \in E: S=(e_t,e_{1q},r_q,e_{2q}), r \in \mathcal{R}, v \in V\right\} \cup\{(s, \varnothing, s)\}\)</span>。处于每个状态的代理都可以选择它希望获取的输出边，并且知道边 <span class="math inline">\(r\)</span> 和目标顶点 <span class="math inline">\(v\)</span> 的标签。</p><p><strong>Transition. </strong> States 结合 Actions 来进行状态转移。转移函数定义为 <span class="math inline">\(\mathcal{S} \times \mathcal{A} \rightarrow \mathcal{S} \text { defined by } \delta(S, A)=\left(v, \mathrm{e}_{1 \mathrm{q} }, \mathrm{r}_{\mathrm{q} }, \mathrm{e}_{2 \mathrm{q} }\right)\)</span>，其中 <span class="math inline">\(S = (e_t,e_{1q},r_q,e_{2q})\)</span> , <span class="math inline">\(A=(e_t，r，v)\)</span>, <span class="math inline">\(\delta : S \times A\)</span>。</p><p><strong>Rewards.</strong> 如果最后的当前位置是正确答案，给 ==+1== 的最终奖励，否则为0。</p><h3 id="policy-network">Policy Network</h3><p>结合当前历史行为和状态，对当前可执行运动进行概率评估 <span class="math display">\[R\left(S_{T}\right)=\mathbb{I}\left\{\mathrm{e}_{\mathrm{t}}=\mathrm{e}_{2 \mathrm{q} }\right\}\]</span></p><p>策略 <span class="math inline">\(\pi=\left(\mathbf{d}_{\mathbf{1} }, \mathbf{d}_{\mathbf{2} }, \ldots, \mathbf{d}_{\mathbf{T}-\mathbf{1} }\right),\mathbf{d}_{\mathbf{t} }: H_{t} \rightarrow \mathcal{P}\left(\mathcal{A}_{S_{t} }\right)\)</span>，历史状态 <span class="math inline">\(H_{t}=\left(H_{t-1}, A_{t-1}, O_{t}\right)\)</span> 是观察和采取行动的顺序。</p><p>Agent 基于 LSTM 对历史行为进行编码，得到历史状态的隐藏表示 <span class="math inline">\(h_t\)</span>： <span class="math display">\[\mathbf{h}_{\mathbf{t}}=\operatorname{LSTM}\left(\mathbf{h}_{\mathbf{t}-\mathbf{1} },\left[\mathbf{a}_{\mathbf{t}-\mathbf{1} } ; \mathbf{o}_{\mathbf{t} }\right]\right)\]</span> 其中，<span class="math inline">\(\mathbf{a}_{\mathbf{t}-\mathbf{1} }\)</span> 是在 <span class="math inline">\(t-1\)</span> 时刻的 action/relation， <span class="math inline">\(\mathbf{o}_\mathbf{t}\)</span> 是在 <span class="math inline">\(t\)</span> 时刻的 observation/entity ，<span class="math inline">\([;]\)</span> 将两者拼接起来。栗：<span class="math inline">\(\mathbf{a}_{\mathbf{t}-\mathbf{1} }=\mathbf{r}_{A_{t-1} }\)</span> 是 agent 在 <span class="math inline">\(t-1\)</span> 时刻选择的 关系嵌入对应的 edge 的 label，<span class="math inline">\(\mathbf{o}_{\mathbf{t} }=\mathbf{e}_{\mathrm{e} }\)</span> 是 agent 在 <span class="math inline">\(t\)</span> 时刻选择的 实体嵌入对应着的 edge 的 label</p><p>根据历史状态的隐藏表示 <span class="math inline">\(h_t\)</span>，当前观测状态即所处节点表示 <span class="math inline">\(o_t\)</span> 和初始查询中所含关系表示 <span class="math inline">\(r_q\)</span> 对下一步的行为做决策 <span class="math inline">\(d_t\)</span>： <span class="math display">\[\begin{array}{l}\mathbf{d}_{\mathbf{t} }=\operatorname{softmax}\left(\mathbf{A}_{\mathbf{t} }\left(\mathbf{W}_{2} \operatorname{ReLU}\left(\mathbf{W}_{\mathbf{1} }\left[\mathbf{h}_{\mathbf{t} } ; \mathbf{o}_{\mathbf{t} } ; \mathbf{r}_{\mathbf{q} }\right]\right)\right)\right) \\A_{t} \sim \text { Categorical }\left(\mathbf{d}_{\mathbf{t} }\right)\end{array}\]</span></p><h2 id="experiments">Experiments</h2><p>做了几个实验，验证了：</p><ol type="1"><li><p>MINERVA 在小 KB 和大 KB 的查询回答方面具有竞争力</p></li><li><p>MINERVA 优于基于路径的模型，该模型不能有效搜索知识库或训练查询特定模型</p><p>MINERVA 的表现明显优于 Path-Baseline。这表明，基于一组随机采样路径进行预测的模型不如 MINERVA，因为它要么在随机行走过程中丢失重要路径，要么无法聚合所有k条路径的预测特征，其中许多路径与回答给定查询无关。后者类似于远程监督问题，即重要证据在大量无关信息中丢失。然而，通过以查询关系为条件采取每一步，MINERVA 可以有效地减少搜索空间，并将重点放在与回答查询相关的路径上。</p></li><li><p>MINERVA 不仅可以用于格式良好的查询，还可以轻松处理部分结构化的自然语言查询</p></li><li><p>MINERVA 具有很强的长链推理能力</p></li><li><p>MINERVA 具有很强的训练能力，并且推理时间更快。</p></li></ol><h2 id="summary">Summary</h2><p>本文提出了 MINERVA 模型，使用了 Reinforcement Learning 的方法，根据 query 在图谱上游走获得 path，抵达目标节点后停止，该方法可以通过在知识图谱上游走推理 path 获得答案，不需要对所有实体进行枚举。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>KGR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Survey on Dialogue Summarization：Recent Advances and New Frontiers</title>
    <link href="/2021/09/25/A%20Survey%20on%20Dialogue%20Summarization%EF%BC%9ARecent%20Advances%20and%20New%20Frontiers/"/>
    <url>/2021/09/25/A%20Survey%20on%20Dialogue%20Summarization%EF%BC%9ARecent%20Advances%20and%20New%20Frontiers/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Survey-on-Dialogue-Summarization-Recent-Advances-and-New-Frontiers"><a href="#A-Survey-on-Dialogue-Summarization-Recent-Advances-and-New-Frontiers" class="headerlink" title="A Survey on Dialogue Summarization: Recent Advances and New Frontiers"></a>A Survey on Dialogue Summarization: Recent Advances and New Frontiers</h1><p>对话摘要旨在将对话中最重要的信息提取到较短的段落中，帮助人们快速捕捉半结构化、多参与者对话的亮点，而无需回顾复杂的对话背景。</p><p>单参与者文档摘要已经取得了成功，但这些方法很难推广到多参与者对话摘要。问题在于：</p><ol><li>一个对话的关键信息往往是分散的，跨越了不同参与者的多个话语和话轮，导致信息密度低。</li><li>对话包含多个参与者、固有的话题转移、频繁的共同引用、多样的交互信号和领域术语。</li></ol><p>有关对话摘要，过去的五年中有60多篇paper涵盖了不同的对话领域，如图。</p><p><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210924220315084.png" alt="image-20210924220315084" style="zoom: 67%;" /></p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Overview-of-Summarization"><a href="#Overview-of-Summarization" class="headerlink" title="Overview of Summarization"></a>Overview of Summarization</h3><p>自动摘要的目的是将原始输入压缩成包含显著信息的较短版本，帮助人们快速掌握核心内容，而不必深入细节。主要分为两种：</p><ul><li>抽取式摘要：选取重要句子作为摘要，更准确、更忠实</li><li>生成式摘要：采用新颖的词语生成摘要，提高了摘要的简洁性和流畅性。</li></ul><h3 id="Evaluation-Metrics"><a href="#Evaluation-Metrics" class="headerlink" title="Evaluation Metrics"></a>Evaluation Metrics</h3><p><strong>ROUGE</strong>：通常被用作评估总结任务的标准度量，主要包括 ROUGE-1、ROUGE-2 和 ROUGE-L 的 F1 分数，分别测量 ground truth 和生成的摘要之间的单词重叠、二元重叠和最长公共序列。</p><p>最近一些工作提出了基于情景化表示的新指标，比如 BERTScore 和 MoverScore，而不是精确的表面形式匹配，它们与人类判断具有更高的相关性。</p><h2 id="对话摘要-按领域分类"><a href="#对话摘要-按领域分类" class="headerlink" title="对话摘要 按领域分类"></a>对话摘要 按领域分类</h2><h3 id="Meeting-Summarization"><a href="#Meeting-Summarization" class="headerlink" title="Meeting Summarization"></a>Meeting Summarization</h3><p>以前用的是抽取式摘要生成，但是由于多方参与的性质，会议中的信息分散且不连贯。所以后人转向自动摘要抽取。</p><p>随着神经网络的发展，许多研究探索了深度学习在满足总结任务中的应用，并取得了显著的成功。尽管基于深度学习的方法具有很强的建模能力，但仅仅考虑字面上的信息是不够的。这是因为在会议发言中有不同的交互信号，长时间的会议记录进一步对传统的顺序模型提出了挑战。为此，一些作品致力于将<u>辅助信息</u>纳入更好的建模会议，如 <code>dialogue discourse</code> [Ganesh  and Dingliwal，2019；Feng et al.，2020a]、<code>dialogue acts</code> [Goo and Chen，2018；Di et  al.，2020]和 <code>domain terminologies</code> [Koay et  al.，2020]。为了处理长时间的会议记录，Zhao等人[2019b]提出了一种分层自适应分段编码器-解码器网络，该网络可自动将会议分段为局部一致的部分。Zhu等人[2020]和Rohde等人[2021]采用分层架构，从 token-level 级别到 turn-level 对会议进行建模。Koay等人[2021]提出了一种滑动窗口方法来逐步处理冗长的会议。</p><p>除了会议摘要，也可以生成会议特定方面的摘要，比如决策、行动、想法和假设等等。最近，提出了基于查询的会议摘要任务，其目的是根据给定的一般查询和特定查询对会议的特定部分进行摘要。除了多方和多流特征外，会议摘要也是一项多模态任务[Renals，2011]。会议可以包括参与者显示的各种类型的非语言信息，如音频、视频和运动功能。因此，大多数工作通过融合言语和非言语特征来研究抽取式多模态会议摘要问题，以丰富话语的表达[Erol等人，2003年；Murray等人，2005年；Nihei等人，2018年]。最近，Li 等人[2019a]研究了抽象<u>多模态会议摘要问题</u>。他们建议使用非语言特征，即视觉注意力焦点（VFOA），来强调一个话语的重要性。</p><p><strong>Leaderboard</strong>：Fabbri 等人[2021]已经尝试创建一个 benchmark。基于他们的努力，SCIR 提供了更全面的 benchmark。</p><p><strong>Highlight</strong>：会议总是有几个特定角色的参与者参与。因此，有必要对这种独特的角色特征进行建模。此外，long transcripts 还需要模型能够处理长序列。此外，会议的视听记录提供了利用多种方式信息的机会。然而，这是一把双刃剑。自动语音识别系统和视觉工具的错误率也对当前的模型提出了挑战，这要求它们更加健壮。</p><h3 id="Chat-Summarization"><a href="#Chat-Summarization" class="headerlink" title="Chat Summarization"></a>Chat Summarization</h3><p>SAMSum 是第一个高质量、手动注释的聊天摘要语料库，并进行了 baseline 实验，迅速激发了这一研究方向。Chen和Yang[2020]迈出了第一步，提出了一种结合主题段和对话阶段的多视图摘要器。更重要的是，他们对这项任务中的挑战进行了全面的研究，如多个参与者之间的不同互动以及频繁出现的共同引用，这可以推动这一方向。</p><p>为了对交互进行建模，一些工作采用了图建模策略。赵等人[2020]利用细粒度主题词作为话语之间的桥梁，构建主题词引导的对话图。陈和杨（2021）认为 话语间对话话语结构 和 话语内作用三元组 明确地塑造了相互作用。Feng等人[2020b]将 常识知识 视为对话背后的认知交互信号，并展示了知识整合和异构建模对不同类型数据的有效性</p><p>由于多个参与者的性质和频繁出现的共指，模型生成的对话摘要总是存在事实不一致的问题[Gabriel  et al.，2020]。为此，Lei等人[2021]强调通过说话人感知的自我注意机制模拟参与者及其相关人称代词之间的复杂关系。Liu等人[2021b]明确地将共指信息纳入对话摘要模型中。值得注意的是，他们进行数据后处理，以减少由文档共指解析模型导致的不正确的共指分配。从另一个角度来看，Narayan等人[2021]和Wu等人[2021]都通过从粗到精的生成改进了对话摘要的事实一致性。最终对话摘要由先例控制，例如草图或实体链。</p><p>由于当前的对话摘要系统通常使用附加信息对文本进行编码，Feng等人[2021]提出了一种无监督的DialoGPT注释器，它可以执行三个注释任务，包括关键词提取、冗余检测和主题分割。</p><p>尽管 SAMSum 已经成为对话总结的 benchmark，但它也可以扩展到其他研究方向。Gunasekara等人[2021]探讨了 summary-to-dialogue generation 的问题，并验证了增强的 dialogue-summary 对能够很好地进行对话摘要。Mehnaz等人[2021]将SAMSum中的英语对话转换为印地语英语对话，并在代码切换设置下学习聊天摘要。</p><p><strong>Highlight</strong>：得益于预先训练的语言模型，当前的方法能够熟练地将原始聊天转化为简单的摘要实现。然而，他们仍然很难选择重要的部分，并且容易产生幻觉。在未来，这项任务需要探索强大的聊天建模策略和推理能力。</p><h3 id="Email-Threads-Summarization"><a href="#Email-Threads-Summarization" class="headerlink" title="Email Threads Summarization"></a>Email Threads Summarization</h3><p>电子邮件线程是一种异步多方通信，由多个参与者之间一致交换电子邮件消息组成，广泛应用于企业、学术和工作环境。与其他类型的对话相比，电子邮件有一些独特的特点。首先，它和元数据相关联，包括发送方、接收方、主体和签名。其次，电子邮件信息始终代表发件人的意图，包含行动项目，并可能使用引号来突出重要部分。第三，与面对面的口头对话不同，电子邮件中的回复不会立即发生。这种异步性质可能导致消息包含长句。为了应对电子邮件过载，电子邮件服务提供商寻求高效的摘要技术来改善用户体验。</p><h3 id="Customer-Service-Summarization"><a href="#Customer-Service-Summarization" class="headerlink" title="Customer Service Summarization"></a>Customer Service Summarization</h3><p>Customer Service 是顾客和代理人之间一对一的直接互动，经常发生在消费者行为之前和之后。</p><p>一方面， Customer Service 的参与者有很强的解决问题的意图和明确的动机，这使得 Customer Service 具有内在的逻辑性和围绕特定的主题。为此，一些工作探索了这个任务的主题建模。Liuet  al.[2019a]采用粗到细的生成框架，首先生成一系列关键点(主题)来指示对话的逻辑，然后实现详细的总结。例如，一个关键点序列可以是提问→解决→用户认可→结束，这清楚地展示了对话的演变。Zouet  al.[2021b] 为了缓解数据不足的问题，Zouet等人[2021a]提出了一个名为RankAE的无监督框架，其中首先根据中心性和多样性同时选择主题话语，并进一步使用去噪自动编码器生成最终的摘要。</p><p>另一方面， Customer Service 是一种面向任务的对话，它包含信息实体，涉及多个领域，并涉及两种不同类型的参与者。为了整合各种信息，Yuan和Yu[2019]提出了Scaffold  Pointer  Network，利用speaker角色、语义槽和对话域三种信息。以往的工作以第三人称的视角进行总结。由于 Customer Service 的参与者扮演着不同的角色，zhang等人[2021]提出了一个基于变分自动编码器的无监督框架，分别为客户和代理生成摘要。</p><p> Customer Service 旨在解决代理商提出的问题。因此，它自然具有强烈的动机，这使得对话在两个具有鲜明特征的参与者——客户和代理之间的互动之后，有了特定的演化方式。因此，对参与者角色、演进链和固有主题进行建模对于这项任务是很重要的。此外，还需要考虑一些细粒度的信息，如 slot 和 intent  [Qinet al.， 2021]。</p><h3 id="Medical-Dialogue-Summarization"><a href="#Medical-Dialogue-Summarization" class="headerlink" title="Medical Dialogue Summarization"></a>Medical Dialogue Summarization</h3><p><strong>重点</strong>：医疗对话总结主要是帮助医生快速完成电子病历，医疗对话总结应该更加忠实而非创造性。因此，优选提取方法与简单提取方法相结合的方法。主题信息可以作为生成半结构化摘要的指导原则。此外，医学对话中的术语和否定应谨慎处理。</p><h3 id="Other-Types-of-Dialogue-Summarization"><a href="#Other-Types-of-Dialogue-Summarization" class="headerlink" title="Other Types of Dialogue Summarization"></a>Other Types of Dialogue Summarization</h3><p>对话是由一个以上的人所产生的任何话语[Ford, 1991]。除了以上提到的对话类型，之前的工作还涉及播客[Zheng et al.，  2020]、在线讨论论坛[Tarnpradabet al.， 2021]、法律辩论[Duanet al.， 2019]和读者评论线程[Barkeret al.，  2016]总结任务。朝着更实用的方向，Tepperet  al.[2018]提出了个性化聊天摘要任务，该任务通过话题分布和社交图连接隐式学习用户兴趣，并基于此提供个性化摘要。</p><h2 id="New-Frontiers"><a href="#New-Frontiers" class="headerlink" title="New Frontiers"></a>New Frontiers</h2><h3 id="对话总结中的忠实度"><a href="#对话总结中的忠实度" class="headerlink" title="对话总结中的忠实度"></a>对话总结中的忠实度</h3><p>尽管目前最先进的摘要系统已经取得了很大的进展，但它们存在事实不一致的问题，扭曲或捏造文章中的事实信息，也被称为幻觉 hallucinations [Huanget al.，  2021]。Chen and Yang [2020]指出错误的引用是因为对话摘要模型犯的一个主要错误，这意味着所生成的摘要包含不忠实于原对话信息(例如,将一个人的行为或位置与错误的 speaker 结合起来)，如图2所示。这种错误在很大程度上阻碍了对话摘要系统的应用。</p><p><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210925232320623.png" alt="image-20210925232320623" style="zoom: 80%;" /></p><p>作者认为，这一问题主要是由对话的多重参与者和不同的参考因素造成的。通过明确地将人称代词信息[Leiet al.，  2021]和共指信息[Liuet al.，  2021b]纳入摘要模型。尽管如此，由于缺乏高质量的对话共参分辨率模型，导致了低质量的分辨率结果，进一步影响了摘要的质量。</p><p>为了缓解这一挑战，不仅可以增强具有对话特征的共指解析模型，还可以利用语境信息和语篇信息对共指进行隐式建模。</p><h3 id="Multi-modal-Dialogue-Summarization"><a href="#Multi-modal-Dialogue-Summarization" class="headerlink" title="Multi-modal Dialogue Summarization"></a>Multi-modal Dialogue Summarization</h3><p>对话往往发生在多模态的情况下，如会议的视听记录。除了语言信息外，非语言信息既可以补充已有信息，也可以提供新的信息，有效地丰富了纯语篇对话的表征。根据不同模式是否可以对齐，多模态信息的类型可分为同步和异步两类。</p><p>同步多模态对话主要是指会议，会议可能包含文本文本、韵律音频和视频。一方面，考虑对齐的音频和视频可以增强文本的表示。另一方面，音频和视频都可以提供新的见解，比如一个人进入房间加入会议或情感讨论。然而，面部特征和声纹特征已经成为了个人优越的隐私，这使得它们难以被获取和敏感。未来的工作可以考虑在联邦学习框架下的多模式会议总结[Liet  al.， 2019b]。</p><p>异步多模态对话是指在不同时间发生的不同模态。随着通信技术的发展，应用程序在聊天对话中频繁使用语音、图片、表情等多模式信息。这些消息提供了丰富的信息，作为对话流的一部分。未来工作可以通过ASR系统获得的语音信息的文本信息，与表情相关的图片和情感提供的新实体，以产生有意义的总结。</p><h3 id="Multi-domain-Dialogue-Summarization"><a href="#Multi-domain-Dialogue-Summarization" class="headerlink" title="Multi-domain Dialogue Summarization"></a>Multi-domain Dialogue Summarization</h3><p>领域学习可以挖掘不同领域之间的共享信息，进一步帮助特定领域的任务，是一种适用于低资源场景的有效学习方法。由于摘要数据集的多样性，已经有一些研究对话摘要的多领域学习或领域适应的著作[Sanduet  al.， 2010;Zhuet, 2020;Y et al.， 2021]。我们将这一方向分为宏观多领域学习和微观多领域学习两类。</p><p>宏观多领域学习旨在使用通用领域摘要数据集，如新闻和科学论文，以帮助对话摘要任务。这种学习方法工作的基础是，不管它们属于什么数据类型，它们的目标是选择原始文本的核心内容。然而，对话具有一些独特的特征，如更多的引用和参与者相关的特征。因此，直接使用这些通用数据集可能会降低它们的有效性。未来的作品可以首先注入一些对话的特定特征，比如用人称代词代替名字，或者将原始的通用领域文档转化为表层的turn-level文档。</p><p>微观多领域学习的目标是使用对话摘要数据集来帮助完成一个特定的对话摘要任务。例如，使用会议数据集来帮助电子邮件任务。如表1所示，近年来，人们提出了涵盖不同领域的多种对话摘要数据集。未来的工作可以采用元学习方法或依赖预先训练的语言模型来使用不同的数据集。</p><p>现在都用什么做？</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BERT：Pre-training of Deep Bidirectional Transformers for Language Understanding</title>
    <link href="/2021/09/23/BERT%EF%BC%9APre-training%20of%20Deep%20Bidirectional%20Transformers%20for%20Language%20Understanding/"/>
    <url>/2021/09/23/BERT%EF%BC%9APre-training%20of%20Deep%20Bidirectional%20Transformers%20for%20Language%20Understanding/</url>
    
    <content type="html"><![CDATA[<h1 id="BERT：Pre-training-of-Deep-Bidirectional-Transformers-for-Language-Understanding"><a href="#BERT：Pre-training-of-Deep-Bidirectional-Transformers-for-Language-Understanding" class="headerlink" title="BERT：Pre-training of Deep Bidirectional Transformers for Language Understanding"></a>BERT：Pre-training of Deep Bidirectional Transformers for Language Understanding</h1><blockquote><p>还没写完 没时间细看了….只是肤浅的了解了一下</p></blockquote><p>BERT的全称为Bidirectional Encoder Representation from Transformers，是一个预训练的语言表征模型。它强调了不再像以往一样采用传统的单向语言模型或者把两个单向语言模型进行浅层拼接的方法进行预训练，而是采用新的<strong>masked language model（MLM）</strong>，以致能生成<strong>深度的双向</strong>语言表征。BERT论文发表时提及在11个NLP（Natural Language Processing，自然语言处理）任务中获得了新的state-of-the-art的结果，令人目瞪口呆。</p><p>该模型有以下主要优点：</p><p>1）采用MLM对双向的Transformers进行预训练，以生成深层的双向语言表征。</p><p>2）预训练后，只需要添加一个额外的输出层进行fine-tune，就可以在各种各样的下游任务中取得state-of-the-art的表现。在这过程中并不需要对BERT进行任务特定的结构修改。</p><h2 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h2><p>论文为 BERT 提供了两种模型尺寸：</p><ul><li>BERT BASE – 在大小上与 OpenAI Transformer 相当以比较性能</li><li>BERT LARGE – 一个巨大模型，达到了论文中报告的最先进的结果</li></ul><p>BERT 基本上是经过训练的 Transformer Encoder 堆栈。两种 BERT 模型大小都有大量的编码器层（论文称之为 Transformer Blocks）——Base 版本有 12 个，Large 版本有 24 个。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210924153318372.png" alt="image-20210924153318372" style="zoom: 50%;" /></p><p>以往的预训练模型的结构会受到单向语言模型<em>（从左到右或者从右到左）</em>的限制，因而也限制了模型的表征能力，使其只能获取单方向的上下文信息。而 BERT 利用 MLM 进行预训练并且采用深层的双向 Transformer 组件来构建整个模型，因此最终生成<strong>能融合左右上下文信息</strong>的深层双向语言表征。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210924085521642.png" alt=""></p><h3 id="BERT的输入输出"><a href="#BERT的输入输出" class="headerlink" title="BERT的输入输出"></a>BERT的输入输出</h3><h4 id="BERT的输入"><a href="#BERT的输入" class="headerlink" title="BERT的输入"></a>BERT的输入</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210924100223494.png" style="zoom:67%;" /></p><p>BERT 的输入为每一个 token 对应的表征<em>（图中的粉红色块就是 token，橙色块就是 token 对应的表征）</em>，并且单词字典是采用 WordPiece 算法来进行构建的。为了完成具体的分类任务，除了单词的 token 之外，作者还在输入的每一个序列开头都插入特定的<strong>分类token <code>[CLS]</code></strong>，该分类 token 对应的最后一个Transformer 层输出被用来起到聚集整个序列表征信息的作用。</p><p>由于 BERT 是一个预训练模型，其必须要适应各种各样的自然语言任务，因此模型所输入的序列必须有能力包含一句话<em>（文本情感分类，序列标注任务）</em>或者两句话以上<em>（文本摘要，自然语言推断，问答任务）</em>。BERT 采用了两种方法来区分输入的两个句子：</p><ol><li>在序列 tokens 中把<strong>分割 token <code>[SEP]</code></strong>插入到每个句子后，以分开不同的句子 tokens。</li><li>为每一个 token 表征都添加一个可学习的分割 embedding 来指示其属于句子A还是句子B。</li></ol><p>因此最后模型的输入序列 tokens 如上图<em>（如果输入序列只包含一个句子的话，则没有 <code>[SEP]</code> 及之后的 token）</em>.</p><p>BERT 的输入为每一个 token 对应的表征，实际上该表征是由三部分组成的，分别是<strong>对应的token</strong>，<strong>分割</strong>和<strong>位置</strong> embeddings</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210923160242048.png" alt="token表征的组成"></p><p>输出向量接了一个分类器。<code>[CLS]</code> 向量不能代表整个句子的语义信息？？？</p><ul><li><code>Token Embeddings</code>：是词向量，对所有词汇做 embedding</li><li><code>Segment Embeddings</code>：用来区别两种句子，因为预训练不光做 LM 还要做以两个句子为输入的分类任务</li><li><code>Position Embeddings</code>：随机初始化，模型自己去学（和 Transformer 不一样）。</li></ul><h4 id="BERT-的输出"><a href="#BERT-的输出" class="headerlink" title="BERT 的输出"></a>BERT 的输出</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210924101528545.png" style="zoom: 67%;" /></p><p><strong>C</strong> 为分类 token <code>[CLS]</code> 对应最后一个 Transformer 的输出，$T_i$ 则代表其他 token 对应最后一个 Transformer 的输出。对于一些 token 级别的任务<em>（如，序列标注和问答任务）</em>，就把 $T_i$ 输入到额外的输出层中进行预测。对于一些句子级别的任务<em>（如，自然语言推断和情感分类任务）</em>，就把 <strong>C</strong> 输入到额外的输出层中，这里也就解释了为什么要在每一个 token 序列前都要插入特定的分类 token。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210924083719931.png" alt=""></p><h3 id="BERT-的预训练任务"><a href="#BERT-的预训练任务" class="headerlink" title="BERT 的预训练任务"></a>BERT 的预训练任务</h3><h4 id="Masked-Language-Model（MLM）"><a href="#Masked-Language-Model（MLM）" class="headerlink" title="Masked Language Model（MLM）"></a>Masked Language Model（MLM）</h4><p>MLM 是 BERT 能够不受单向语言模型所限制的原因。简单来说就是以15%的概率用 mask token <code>[MASK]</code> 随机地对每一个训练序列中的 token 进行替换，然后预测出 <code>[MASK]</code> 位置原有的单词。然而，由于 <code>[MASK]</code> 并不会出现在下游任务的微调（fine-tuning）阶段，因此预训练阶段和微调阶段之间产生了<strong>不匹配</strong>（这里很好解释，就是预训练的目标会令产生的语言表征对 <code>[MASK]</code> 敏感，但是却对其他token不敏感）。因此 BERT 采用了以下策略来解决这个问题：</p><p>首先在每一个训练序列中以 15% 的概率随机地选中某个 token 位置用于预测，假如是第 $i$ 个 token 被选中，则会被替换成以下三个 token 之一</p><ol><li><p>80% 的时候是[MASK]。如，my dog is <strong>hairy</strong>——&gt;my dog is <strong>[MASK]</strong></p></li><li><p>10% 的时候是随机的其他 token。如，my dog is <strong>hairy</strong>——&gt;my dog is <strong>apple</strong></p></li><li><p>10% 的时候是原来的 token<em>（保持不变，有博主认为是作为 2. 所对应的负类）</em>。如，my dog is <strong>hairy</strong>——&gt;my dog is <strong>hairy</strong></p></li></ol><p>再用该位置对应的 $T_i$ 去预测出原来的 token，即输入到全连接，然后用 softmax 输出每个 token 的概率，最后用交叉熵计算 loss）。该策略令到 BERT 不再只对 <code>[MASK]</code> 敏感，而是对所有的 token都敏感，以致能抽取出任何 token 的表征信息。</p><p><strong>那么为啥要以一定的概率使用随机词呢？</strong></p><p>这是因为 transformer 要保持对每个输入 token 分布式的表征，否则 Transformer 很可能会记住这个 <code>[MASK]</code> 就是 “hairy”。至于使用随机词带来的负面影响，文章中解释说,所有其他的 token (即非 “hairy” 的 token)共享 15%*10% = 1.5% 的概率，其影响是可以忽略不计的。Transformer 全局的可视，又增加了信息的获取，但是不让模型获取全量信息。</p><blockquote><p>论文中有关于该策略的实验数据，可以去<a href="https://arxiv.org/pdf/1810.04805.pdf">原文</a>查看详情。</p></blockquote><p>注意：</p><ul><li>有参数 <code>dupe_factor</code> 决定数据 duplicate 的次数。</li><li>其中，<code>create_instance_from_document</code> 函数，是构造了一个 sentence-pair 的样本。对每一句，先生成 <code>[CLS]+A+[SEP]+B+[SEP]</code>，有长（0.9）有短（0.1），再加上 mask，然后做成样本类 object。</li><li><code>create_masked_lm_predictions</code> 函数返回的 tokens 是已经被遮挡词替换之后的 tokens</li><li><code>masked_lm_labels</code> 则是遮挡词对应位置真实的 label</li></ul><h4 id="Next-Sentence-Prediction（NSP）"><a href="#Next-Sentence-Prediction（NSP）" class="headerlink" title="Next Sentence Prediction（NSP）"></a>Next Sentence Prediction（NSP）</h4><p>一些如问答、自然语言推断等任务需要理解两个句子之间的关系，而 MLM 任务倾向于抽取 <strong>token 层次</strong>的表征，因此不能直接获取<strong>句子层次</strong>的表征。为了使模型能够有能力理解句子间的关系，BERT 使用了 NSP 任务来预训练，简单来说就是预测两个句子是否连在一起。具体的做法是：对于每一个训练样例，在语料库中挑选出句子A和句子B来组成，50% 的时候句子B就是句子A的下一句<em>（标注为 IsNext）</em>，剩下 50% 的时候句子B是语料库中的随机句子<em>（标注为 NotNext）</em>。接下来把训练样例输入到 BERT 模型中，用 <code>[CLS]</code> 对应的 C 信息去进行二分类的预测。</p><ul><li><p>Bert 先是用 Mask 来提高视野范围的信息获取量，增加 duplicate 再随机 Mask，这样跟RNN类方法依次训练预测没什么区别了除了mask不同位置外；</p></li><li><p>全局视野极大地降低了学习的难度，然后再用 <code>A + B or C</code> 来作为样本，这样每条样本都有 50% 的概率看到一半左右的噪声；</p></li><li><p>但直接学习 <code>Mask A + B or C</code> 是没法学习的，因为不知道哪些是噪声，所以又加上 next_sentence 预测任务，与 MLM 同时进行训练，这样用 next 来辅助模型对噪声/非噪声的辨识，用 MLM 来完成语义的大部分的学习。</p></li></ul><h4 id="预训练任务总结"><a href="#预训练任务总结" class="headerlink" title="预训练任务总结"></a>预训练任务总结</h4><p>最后训练样例长这样：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input1 = <span class="hljs-comment">[CLS]</span> the <span class="hljs-keyword">man</span> went to <span class="hljs-comment">[MASK]</span> store <span class="hljs-comment">[SEP]</span> he bought a gallon <span class="hljs-comment">[MASK]</span> milk <span class="hljs-comment">[SEP]</span><br><br>Label1 = IsNext<br><br>Input2 = <span class="hljs-comment">[CLS]</span> the <span class="hljs-keyword">man</span> <span class="hljs-comment">[MASK]</span> to the store <span class="hljs-comment">[SEP]</span> penguin <span class="hljs-comment">[MASK]</span> <span class="hljs-keyword">are</span> flight ##less birds <span class="hljs-comment">[SEP]</span><br><br>Label2 = NotNext<br></code></pre></td></tr></table></figure><p>把每一个训练样例输入到 BERT 中可以相应获得两个任务对应的 loss，再把这两个 loss 加在一起就是整体的预训练 loss。<em>（也就是两个任务<strong>同时</strong>进行训练）</em></p><blockquote><p>可以明显地看出，这两个任务所需的数据其实都可以从<strong>无标签的</strong>文本数据中构建（自监督性质），比 CV 中需要人工标注的 ImageNet 数据集可简单多了。</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>总结下 BERT 的<strong>主要贡献</strong>：</p><ul><li>引入了Masked LM，使用双向 LM 做模型预训练。</li><li>为预训练引入了新目标 NSP，它可以学习句子与句子间的关系。</li><li>进一步验证了更大的模型效果更好： 12 —&gt; 24 层。</li><li>为下游任务引入了很通用的求解框架，不再为任务做模型定制。</li><li>刷新了多项NLP任务的记录，引爆了NLP无监督预训练技术。</li></ul><p><strong>BERT优点</strong>：</p><ul><li><p>Transformer Encoder 因为有 Self-attention 机制，因此 BERT 自带双向功能</p></li><li><p>因为双向功能以及多层 Self-attention 机制的影响，使得 BERT 必须使用 Cloze 版的语言模型 Masked-LM 来完成 token 级别的预训练</p></li><li><p>为了获取比词更高级别的句子级别的语义表征，BERT 加入了 Next Sentence Prediction 来和 Masked-LM 一起做联合训练</p></li><li><p>为了适配多任务下的迁移学习，BERT 设计了更通用的输入层和输出层</p></li><li><p>微调 fine-tine 成本小</p></li></ul><p><strong>BERT缺点：</strong></p><ul><li><p>task1: MLM 的随机遮挡策略略显粗犷，推荐阅读《Data Nosing As Smoothing In Neural Network Language Models》</p></li><li><p><code>[MASK]</code> 标记在实际预测中不会出现，训练时用过多 <code>[MASK]</code> 影响模型表现;</p></li><li><p>每个 batch 只有15%的 token 被预测，所以 BERT 收敛得比 left-to-right 模型要慢（它们会预测每个 token）</p></li><li><p>BERT 对硬件资源的消耗巨大（大模型需要16个 tpu，历时四天；更大的模型需要64个 tpu，历时四天。)</p></li></ul><h5 id="训练-Bert："><a href="#训练-Bert：" class="headerlink" title="训练 Bert："></a>训练 Bert：</h5><ol><li>找一个预训练 Language Model。（例如 中文谷歌BERT）</li><li>在相同领域上 继续训练 LM（Domain transfer）。</li><li>在任务相关的小数据  继续训练 LM（Task transfer）。</li><li>在任务相关数据上做具体任务（Fine-tune）。</li></ol><h5 id="如何在相同领域数据中进行-further-pre-training？"><a href="#如何在相同领域数据中进行-further-pre-training？" class="headerlink" title="如何在相同领域数据中进行 further pre-training？"></a>如何在相同领域数据中进行 further pre-training？</h5><ol><li>动态 mask：就是每次 epoch 训练前去 mask，不是一直使用同一个</li><li>n-gram mask：比如做 ERNIE 和 SpanBert 都是做了类似词的 mask</li></ol>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELMo：Deep contextualized word representations</title>
    <link href="/2021/09/19/ELMo%EF%BC%9ADeep%20contextualized%20word%20representations/"/>
    <url>/2021/09/19/ELMo%EF%BC%9ADeep%20contextualized%20word%20representations/</url>
    
    <content type="html"><![CDATA[<h1 id="ELMo：Deep-contextualized-word-representations"><a href="#ELMo：Deep-contextualized-word-representations" class="headerlink" title="ELMo：Deep contextualized word representations"></a>ELMo：Deep contextualized word representations</h1><p>ELMo 模型出自《Deep contextualized word representations》，是 NAACL 2018 best paper。</p><p>ELMo 是一种基于语境的深度词表示模型（Word Representation Model），它可以捕获单词的复杂特征（词性句法），也可以解决同一个单词在不同语境下的不同表示（语义）。</p><p>ELMo 采用了典型的两阶段过程，<strong>第一个阶段是利用语言模型进行预训练；第二个阶段是在做下游任务时，从预训练网络中提取对应单词的网络各层的Word Embedding作为新特征补充到下游任务中。</strong></p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>以 Word2Vec 和 GloVe 为代表的词表示模型通过训练为每个单词训练出固定大小的词向量，这在以往的 NLP 任务中都取得了不错的效果，但是他们都存在两个问题：</p><ol><li>没法处理复杂的单词用法，即语法问题；</li><li>没办法结合语境给出正确词向量，即一词多义；</li></ol><p>为了解决这2个问题，作者提出了一个新的深层语境词表示模型——ELMo。</p><p>区别于传统模型生成的固定单词映射表的形式（为每个单词生成一个固定的词向量），ELMo 使用了预训练的语言模型（Language Model），模型会扫面句子结构，并更新内部状态，从而为句子中的每个单词都生成一个<strong>基于当前的句子</strong>的词向量（Embedding）。这也是就是 ELMo 取名的由来：Embeddings from Language Models。</p><p>此外，ELMo <strong>采用字符级的多层 BI-LM 模型</strong>作为语言模型，高层的网络能够捕获基于语境的词特征（例如主题情感），而底层的 LSTM 可以学到语法层次的信息（例如词性句法），前者可以处理一词多义，后者可以被用作词性标注，作者通过线性组合多层 LSTM 的内部状态来丰富单词的表示。</p><h2 id="ELMo"><a href="#ELMo" class="headerlink" title="ELMo"></a>ELMo</h2><p>这是 ELMo 整体架构。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210919184321765.png" style="zoom:67%;" /></p><h3 id="Char-Encode-Layer"><a href="#Char-Encode-Layer" class="headerlink" title="Char Encode Layer"></a>Char Encode Layer</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210919184310425.png" alt=""></p><ol><li>Char Embedding：这就是正常的 embedding 层，针对每个char进行编码</li><li>Multi-Scale 卷积层：这里用的是不同 scale 的卷积层，注意是在宽度上扩展，而不是深度上，即输入都是一样的，卷积之间的不同在于其<code>kernel_size</code>和<code>channel_size</code>的大小不同，用于捕捉不同 n-grams 之间的信息，这点其实是仿照  <em>TextCNN</em> 的模型结构。</li><li>Concat 层：上一步得出的是m个不同维度的矩阵，为了方便后期处理，这里将其在最后一维上进行拼接，而后将其 reshape 回单词级别的维度</li><li>Highway 层：Highway（参见：<a href="https://arxiv.org/abs/1505.00387">Highway Network</a> ）是仿照图像中 <strong>residual</strong> 的做法，在 NLP 领域中常有应用，这一层实现的公式其实就是一种<strong>全连接+残差</strong>的实现方式，只不过这里还需要一个 element-wise 的 gate 矩阵对 x 和 f(A(x)) 进行变换。</li><li>Linear 映射层：经过前面的计算，得到的向量维度 $d1+d2+…+dm$ 往往比较长，这里额外加了一层的Linear进行映射，将维度映射到D，作为词的embedding送入后续的层中，这里输出的维度为 $B <em> W </em> D$。</li></ol><h3 id="Bi-LM"><a href="#Bi-LM" class="headerlink" title="Bi-LM"></a>Bi-LM</h3><p>ELMo 是一种称为 Bi-LM 的特殊类型的语言模型，它是两个方向上的 LM 的组合，如下图所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210919135130780.png" style="zoom: 67%;" /></p><p>ELMo 利用<strong>正向</strong>和<strong>反向</strong>扫描句子计算单词的词向量，并通过级联的方式产生一个中间向量。通过这种方式得到的词向量它可以了解到当前句子的结构(语义)和该单词的使用方式。</p><p>设一个序列有 N 个 token $(t_1, t_2,…,t_N)$（这里说 token 是为了兼容字符和单词，EMLo 使用的是字符级别的 Embedding）</p><p>对于一个前向语言模型来说，是基于先前的序列来预测当前 token：</p><script type="math/tex; mode=display">p\left(t_{1}, t_{2}, \ldots, t_{N}\right)=\prod_{k=1}^{N} p\left(t_{k} \mid t_{1}, t_{2}, \ldots, t_{k-1}\right)</script><p>而对于一个后向语言模型来说，是基于后面的序列来预测当前 token：</p><script type="math/tex; mode=display">p\left(t_{1}, t_{2}, \ldots, t_{N}\right)=\prod_{k=1}^{N} p\left(t_{k} \mid t_{k+1}, t_{k+2}, \ldots, t_{N}\right)</script><p>可以用 $\overrightarrow{h<em>{k, j}}$ 和 $\overleftarrow{h</em>{k, j}}$ 分别表示前向和后向语言模型。</p><p>损失函数：ELMo 用的是多层双向的 LSTM，所以我们联合前向模型和后向模型给出对数似然估计：</p><script type="math/tex; mode=display">\begin{array}{l}\sum_{k=1}^{N}\left(\log p\left(t_{k} \mid t_{1}, \ldots, t_{k-1} ; \Theta_{x}, \vec{\Theta}_{L S T M}, \Theta_{s}\right)\right. \\\left.\quad+\log p\left(t_{k} \mid t_{k+1}, \ldots, t_{N} ; \Theta_{x}, \overleftarrow{\Theta}_{L S T M}, \Theta_{s}\right)\right)\end{array}</script><p>其中，$\Theta<em>{x}$ 表示 token 的向量，$\Theta</em>{s}$ 表示 Softmax 层分类的参数， $\overleftarrow{\Theta}<em>{L S T M}$ 和 $\overrightarrow{\Theta}</em>{L S T M}$ 表示前向和后向的 LSTM 的参数。</p><h3 id="生成-ELMo-词向量"><a href="#生成-ELMo-词向量" class="headerlink" title="生成 ELMo 词向量"></a>生成 ELMo 词向量</h3><p>上文提到：ELMo 通过<strong>级联</strong>的方式给出<strong>中间向量</strong></p><p>对每一个 token $t_k$ 来说，一个 L 层的 ELMo 的 2L + 1 个表征：</p><script type="math/tex; mode=display">\begin{aligned}R_{k} &=\left\{\mathbf{x}_{k}^{L M}, \overrightarrow{\mathbf{h}}_{k, j}^{L M}, \overleftarrow{\mathbf{h}}_{k, j}^{L M} \mid j=1, \ldots, L\right\} \\&=\left\{\mathbf{h}_{k, j}^{L M} \mid j=0, \ldots, L\right\}\end{aligned}</script><p>其中，$\mathbf{h}<em>{k, 0}^{L M}$ 表示输入层，$\mathbf{h}</em>{k, j}^{L M}=[\overrightarrow{\mathbf{h}}<em>{k, j}^{L M}, \overleftarrow{\mathbf{h}}</em>{k, j}^{L M}]$  表示每一层的正向和反向输出拼接后的结果。（之所以是 2L + 1 是因为把输入层加了进来）</p><p>对于下游任务来说，ELMo 会将所有的表征加权合并为一个<strong>中间向量</strong>：</p><script type="math/tex; mode=display">\mathbf{E L M o}_{k}=E\left(R_{k} ; \boldsymbol{\Theta}_{e}\right)</script><p>最简单的情况下，ELMo 只选择顶层，$E\left(R<em>{k}\right)=\mathbf{h}</em>{k, L}^{L M}$ ，所有 biLM 层的任务特定权重：</p><script type="math/tex; mode=display">\mathbf{E L M o}_{k}^{\text {task }}=E\left(R_{k} ; \Theta^{\text {task }}\right)=\gamma^{\text {task }} \sum_{j=0}^{L} s_{j}^{t a s k} \mathbf{h}_{k, j}^{L M}</script><p>其中，$s$ 是 Softmax 的结果，用作权重；$\gamma$ 是常量参数，允许模型缩放整个 ELMo 向量，这两部分都是作为参数来学习的，针对不同任务会有不同的值。</p><p>同时论文里面还提到，每一层输出的分布之间可能会有较大差别，所以有时也会在线性融合之前，为每层的输出做一个 Layer Normalization，这与 Transformer 里面一致。</p><p>经过 Scalar Mixer之后的向量维度为 $B <em> W </em> 2$，即为生成的 ELMo 词向量，可以用于后续的任务。</p><p>整个为下游任务获取embedding的过程即为：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210919170249970.png" style="zoom: 67%;" /></p><div class="note note-info">            <p>注意是，ELMo 使用的 <strong>Bi-LM 与 Bi-LSTM 不同</strong>，虽然长得相似，但是 Bi-LM 是两个 LM 模型的串联，一个向前，一个向后。而 Bi-LSTM 不仅仅是两个 LSTM 串联，<strong>Bi-LSTM 模型中来自两个方向的内部状态在被送到下层时进行级联（注意下图的 out 部分，在 out 中进行级联），而在 Bi-LM 中，两个方向的内部状态仅从两个独立训练的 LM 中进行级联。</strong></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210919162000789.png" style="zoom: 67%;" /></p>          </div><h3 id="Supervised-NLP-task（结合下游NLP任务）"><a href="#Supervised-NLP-task（结合下游NLP任务）" class="headerlink" title="Supervised NLP task（结合下游NLP任务）"></a>Supervised NLP task（结合下游NLP任务）</h3><p>一般 ELMo 模型会在一个超大的语料库上进行预训练，因为是训练语言模型，不需要任何的标签，纯文本就可以，因而这里可以用超大的语料库，这一点的优势是十分明显的。训练完 ELMo 模型之后，就可以输入一个新句子，得到其中每个单词在当前这个句子上下文下的 ELMo 词向量了。</p><p>论文中提到，在训练的时候，发现使用合适的 dropout 和 L2 在 ELMo 模型上时会提升效果。</p><p>此时这个词向量就可以接入到下游的NLP任务中，比如问答、情感分析等。从接入的位置来看，可以与下游NLP任务本身输入的embedding拼接在一起，也可以与其输出拼接在一起。而从模型是否固定来看，又可以将ELMo词向量预先全部提取出来，即固定ELMo模型不让其训练，也可以在训练下游NLP任务时顺带fine-tune这个ELMo模型。总之，使用起来非常的方便，可以插入到任何想插入的地方进行增补。</p><h3 id="ELMo-的优点是什么？"><a href="#ELMo-的优点是什么？" class="headerlink" title="ELMo 的优点是什么？"></a>ELMo 的优点是什么？</h3><p>ELMo利用了深度上下文单词表征，该模型的优点：</p><ul><li>引入双向语言模型，其实是 2 个单向语言模型（前向和后向）的集成；</li><li>通过保存预训练好的 2 层 biLSTM，通过特征集成或 finetune 应用于下游任务；</li></ul><p>总结来说，通过上述结构，ELMo 能够达到区分多义词的效果，每个单词(token)不再是只有一个上下文无关的 embedding 表示。</p><h3 id="ELMo-为什么有效？"><a href="#ELMo-为什么有效？" class="headerlink" title="ELMo 为什么有效？"></a>ELMo 为什么有效？</h3><ul><li>首先，ELMo 的假设前提是<strong>一个词的词向量不应该是固定的</strong>，所以在多义词区分方面 ELMo 的效果必然比 word2vec 要好。</li><li>另外，ELMo 通过语言模型生成的词向量是通过特定上下文的“传递”而来，再根据下游任务，对原本上下文无关的词向量以及上下文相关的词向量表示引入一个权重，这样既在原来的词向量中引入了上下文的信息，又能根据下游任务适时调整各部分的权重(权重是在网络中学习得来的)，因此这也是 ELMo 有效的一个原因。</li></ul><h3 id="ELMo为什么能够达到区分多义词的效果？"><a href="#ELMo为什么能够达到区分多义词的效果？" class="headerlink" title="ELMo为什么能够达到区分多义词的效果？"></a>ELMo为什么能够达到区分多义词的效果？</h3><p>在ELMo第一阶段训练完成之后，将句子输入模型中在线提取各层embedding的时候，每个单词(token)对应两边LSTM网络的对应节点，那两个节点得到的embedding是动态改变的，会受到上下文单词的影响，周围单词的上下文不同应该会强化某种语义，弱化其它语义，这样就达到区分多义词的效果了。需要注意的是，第一个单词和最后一个单词也是有上下文的，譬如说第一个单词的上文是一个特殊的 token <code>&lt;BOS&gt;</code>，下文是除第一个单词外的所有单词，最后一个单词的下文是一个特殊的token <code>&lt;EOS&gt;</code>，上文是除最后一个单词外的所有单词。</p><p>论文中也举例说明了这个问题，图示如下：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210920084513229.png" alt="image-20210920084513229"></p><p>上图对于Glove训练出的word embedding来说，多义词比如play，根据它的embedding找出的最接近的其它单词大多数集中在体育领域，这很明显是因为训练数据中包含play的句子中体育领域的数量明显占优导致；而使用ELMo，根据上下文动态调整后的embedding不仅能够找出对应的“演出”的相同语义的句子，而且还可以保证找出的句子中的play对应的词性也是相同的，这是超出期待之处(当然也可能是因为论文中给出的例子都是比较好的例子，不过ELMo这样的做法是值得学习的)。</p><h3 id="ELMo-把三种不同的向量叠加的意义是什么？这样做能达到什么样的效果？"><a href="#ELMo-把三种不同的向量叠加的意义是什么？这样做能达到什么样的效果？" class="headerlink" title="ELMo 把三种不同的向量叠加的意义是什么？这样做能达到什么样的效果？"></a>ELMo 把三种不同的向量叠加的意义是什么？这样做能达到什么样的效果？</h3><p>因为通过ELMo模型，句子中每个单词都能得到对应的三个Embedding：最底层是单词的Word Embedding，往上走是第一层双向LSTM中对应单词位置的Embedding，这层编码单词的<strong>句法信息</strong>更多一些；再往上走是第二层LSTM中对应单词位置的Embedding，这层编码单词的<strong>语义信息</strong>更多一些。</p><p>需要注意的是，这里得到的结论是通过实验验证的，是在这样的模型设计中，能够得到上述结论，可能不同模型结构，得到的结论又是不一样的。</p><p>ELMo把三种不同的向量叠加的意义主要体现在以下两个点：</p><ul><li>一是之前很多方法都只用了最顶层LSTM的hidden state，但是通过实验验证，在很多任务中，将每一层hidden state融合在一起会取得更好的效果；</li><li>二是在上述实验中得到结论，每一层LSTM得到单词的embedding所蕴含的信息是不一样的，因此将所有信息融合起来，会让单词embedding的表达更丰富。</li></ul><p>这样做能够起到区分多义词的效果，如上个问题，而且在论文展示的6个任务中都取得了 SOTA 的效果。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210919192856819.png" alt=""></p><p>疑问</p><ol><li><p>为什么要用 LSTM 而不用类似 Transformer 的结构？毕竟 Transformer 在发表于 2017 年，早于 ELMo；</p></li><li><p>其次，ELMo 采用的并不是真正的双向 LSTM，而是两个独立的 LSTM 分别训练，并且只是在 Loss Function 中通过简单相加进行约束，只能一定程度上学习到单词两边句子的特征。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>ELMo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成对抗网络 GAN</title>
    <link href="/2021/09/17/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%20GAN/"/>
    <url>/2021/09/17/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%20GAN/</url>
    
    <content type="html"><![CDATA[<h1 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h1><p>生成对抗网络（GAN），是深度学习模型之一，2014年 lan Goodfellow 的开篇之作 <a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1406.2661">Generative Adversarial Network</a>，GAN 是一种无监督学习方法，它巧妙地利用“对抗”的思想来学习生成式模型，一旦训练完成后可以生成全新的数据样本。DCGAN 将 GAN 的概念扩展到卷积神经网络中，可以生成质量较高的图片样本。</p><h2 id="GAN-概述"><a href="#GAN-概述" class="headerlink" title="GAN 概述"></a>GAN 概述</h2><p>GAN包括两个模型，一个是<strong>生成模型 G</strong>（Generator），一个是<strong>判别模型 D</strong>（Discriminator）。他们分别的功能是：</p><ul><li>Generator 负责生成图片，他接收一个随机的噪声 z，通过该噪声生成图片，将生成的图片记为 G(z)</li><li>Discriminator 负责判别一张图片是不是“真实的”。它的输入是xx，xx 代表一张图片，输出 D(x) 表示 x 为真实图片的概率，如果为1，代表是真实图片的概率为100%，而输出为0，代表不可能是真实的图片（真实实例来源于数据集，伪造实例来源于生成模型）</li></ul><p>在训练过程中，生成模型 G 的目标是尽量生成看起来真的和原始数据相似的图片去欺骗判别模型 D。而判别模型 D 的目标是尽量把生成模型 G 生成的图片和真实的图片区分开来。这样，生成器试图欺骗判别器，判别器则努力不被生成器欺骗。两个模型经过交替优化训练，互相提升，G和 D 构成了一个动态的“<strong>博弈</strong>”，这是 GAN 的基本思想。</p><p>最后博弈的结果是什么？在最理想的状态下，G 可以生成足以“以假乱真”的图片 G(z)。对于 D 来说，它难以判定 G 生成的图片究竟是不是真实的，因此 D(G(z))=0.5。此时得到了一个生成式的模型 G，它可以用来生成图片。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210917222743285.png" style="zoom:67%;" /></p><p>如上图所示，我们有两个网络，生成网络G（Generator）和判别网络D（Discriminator）。生成网络接收一个（符合简单分布如高斯分布或者均匀分布的）随机噪声输入，通过这个噪声输出图片，记做 G(z)。判别网络的输入是x，x代表一张图片，输出 D(x) 代表 x 为真实图片的概率。</p><h1 id="GAN模型优化训练"><a href="#GAN模型优化训练" class="headerlink" title="GAN模型优化训练"></a>GAN模型优化训练</h1><p><strong>目的</strong>：将一个随机高斯噪声zz通过一个生成网络G得到一个和真实数据分布 $p<em>data(x)$ 差不多的生成数据分布 $p_G(x;θ)$，其中 $θ$ 是网络参数，我们希望找到 $θ$ 使得 $p_G(x;θ)$ 和 $p</em>{data}(x)$ 尽可能的接近。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210917220129102.png" style="zoom: 80%;" /></p><p>我们站在判别网络的角度想问题，首先判别器要能识别真实数据，同样也能识别出生成数据，在数学式子上的表达为 D(x)=1 和 D(G(z))=0。我们通过这两个式子，分别来构造 <strong>[正类]</strong>(判别出x属于真实数据) 和 <strong>[负类]</strong>(判别出G(z)属于生成数据) 的对数损失函数。</p><ul><li><strong>生成网络G的损失函数为 $log⁡(1−D(G(z)))$ 或者 $−logD(G(z))−log⁡D(G(z))$。</strong></li><li><strong>判别网络D的损失函数为 $−(log⁡D(x)+log⁡(1−D(G(z))))$。</strong></li></ul><p>我们从式子中解释对抗，损失函数的图像是一个类似于 y=log(x) 函数图形，x<0时，y>0，x=1时，y=0。生成网络和判别网络对抗（训练）的目的是使得各自的损失函数最小，生成网络G的训练希望 $D(G(z))$ 趋近于1，也就是正类，这样生成网络 G 的损失函数 $log⁡(1−D(G(z)))$ 就会最小。而判别网络的训练就是一个2分类，目的是让真实数据x的判别概率 D 趋近于1，而生成数据 G(z) 的判别概率 $D(G(z))$ 趋近于0，这是负类。</p><ul><li><strong>当判别网络遇到真实数据时</strong>：$E_{x∼pdata(x)}[log⁡D(x)]$，这个期望要取最大，只有当 D(x)=1 的时候，也就是判别网络判别出真实数据是真的。</li><li><strong>当判别网络遇到生成数据时</strong>：$E_{z∼Pz(z)}[log⁡(1−D(G(z)))]$，因为0&lt;概率&lt;1，且x&lt;1的对数为负，这个数学期望要想取最大值，则需要令 D(G(z))=0，D(G(z))=0 是判别器发现了生成数据 G(z) 是假的，</li></ul><p>结合以上两个概念，判别网络最大化目标函数为：</p><script type="math/tex; mode=display">E_{x \sim p_{d a t}(x)}[\log D(x)]+E_{z \sim P z(z)}[\log (1-D(G(z)))]</script><p>然后我们将最优化式子表述为：$D<em>{G}^{*}=\arg \max </em>{D} V(G, D)$</p><p>现在剧情大反转，对于判别网络 D 而言，希望目标函数(判别公式 $V(D,G)$ 最大化，但对于生成网络 G，希望目标函数（判别公式 $V(D,G)$ 最小化，即你判别网络判别不出我是真数据还是生成数据。有趣的事情来了，那到底是希望这个目标函数最大化好呢，还是最小化好呢？</p><p>来打一架吧。整个训练的过程是一个迭代的过程，其实当我们求得最优的 $D_G^∗$ 即 $D=D_G^∗$，我们反过来把 $D=D_G^∗$ 代入上面的式子，来求最优(最小)的 G，即 $D_G^∗$。整个训练优化过程就是一个循环迭代过程。在原论文中 lan J.Goodfellow 更喜欢求解最优化价值函数的G和D以求解极大极小博弈：</p><script type="math/tex; mode=display">\min _{G} \max _{D} V(D, G)=E_{\left.x \sim p_{d a t \&} x\right)}[\log D(x)]+E_{z \sim P z(z)}[\log (1-D(G(z)))]</script><p>式中：D是判别函数，x是真实数据，D(x)：判别真实数据的概率，D(G(z))：判别生成数据的概率</p><p>最后将最优化问题表达为：</p><script type="math/tex; mode=display">G_{D}^{*}=\arg \max _{G} V\left(G, D_{G}^{*}\right)</script><p>其实极小极大博弈可以分开理解，即在给定 G 的情况下先最大化 $V(D,G)$ 而取 $D_G^∗$，然后固定 D，并最小化 $V(D,G)$ 而得到 $D_G^∗$。其中给定G，最大化 $V(D,G)$ 评估了真实数据和生成数据之间的差异或距离。</p><p>在这样的对抗过程中，会有几个过程，原论文中的图如下：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210917221654676.png" style="zoom:80%;" /></p><p>黑色线表示真实数据的分布，绿色线表示生成数据的分布，蓝色线表示生成数据在判别器中的分布效果.</p><p>对每个图逐一进行分析</p><p>（a）判别网络D还未经过训练，分类能力有限，有波动，但是真实数据x和生成数据G(z)还是可以的</p><p>（b）判别网络D训练的比较好，可以明显区分出生成数据G(z)。</p><p>（c）绿色的线与黑色的线偏移了，蓝色线下降了，也就是判别生成数据的概率下降了。</p><p>由于绿色线的目标是提升提升概率，因此会往蓝色线高的方向引动。那么随着训练的持续，由于G网络的提升，生成网络G也反过来影响判别网络D的分布。在不断循环训练判别网络D的过程中，判别网络的判别能力会趋于一个收敛值，从而达到最优。</p><script type="math/tex; mode=display">D_{G}^{*}(x)=\frac{p_{d a t a}(x)}{p_{d a t a}(x)+p_{g}(x)}</script><p>因此随着 $p<em>g(x)$ 趋近于 $p</em>{data}(x)$，$D_G^*(x)$ 会趋近于 $\frac 1 2$，$\frac 1 2$ 的意思就是模棱两可，判别器已经分不清随是真实数据谁是生成数据，也就是图 d。</p><h2 id="GAN-的算法推导"><a href="#GAN-的算法推导" class="headerlink" title="GAN 的算法推导"></a>GAN 的算法推导</h2><p>深入了解，可继续阅读<a href="https://unclestrong.github.io/DeepLearning_LHY21_Notes/Notes_html/16_GAN_P3.html">李宏毅老师的课</a></p><p>想要深入时阅读这篇博客：<a href="https://www.cnblogs.com/LXP-Never/p/9706790.html">神经网络结构：生成式对抗网络（GAN）</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于翻译模型(Trans系列)的知识表示学习</title>
    <link href="/2021/09/14/%E5%9F%BA%E4%BA%8E%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%9E%8B(Trans%E7%B3%BB%E5%88%97)%E7%9A%84%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/09/14/%E5%9F%BA%E4%BA%8E%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%9E%8B(Trans%E7%B3%BB%E5%88%97)%E7%9A%84%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基于翻译模型trans系列的知识表示学习">基于翻译模型(Trans系列)的知识表示学习</h1><p>表示学习旨在将研究对象的语义信息表示为稠密低维实值向量，知识表示学习主要是面向知识图谱中的实体和关系进行表示学习。使用建模方法将实体和向量表示在低维稠密向量空间中，然后进行计算和推理。一般而言的应用任务为 link prediction 和 triplet classification. 自从2013年 TransE 模型提出后，产生了一系列模型对 TransE 模型进行改进和补充。本文对Trans系列的一些模型进行简单的总结。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210914214531627.png" /></p><h2 id="transe">TransE</h2><p>TransE 是，学习目标是将实体和关系嵌入到低维向量空间中。</p><p>TransE 模型认为一个正确的三元组的 embedding 向量 <span class="math inline">\((h, r, t)\)</span> 会满足公式：<span class="math inline">\(h+r \approx t\)</span></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210813163920543.png" style="zoom: 67%;" /></p><p>得分函数： <span class="math display">\[f(h,r,t)=||h+r-t||_2\]</span> TransE 可以解决知识图谱中1对1的关系表示，而对于1对多，多对1和多对多的关系类型就无法很好的进行表示。</p><h2 id="transm">TransM</h2><p>TransM 算法是基于 TransE 算法进行的改进，目的还是为了解决在 TransE 中无法处理的一对多、多对一、多对多和自反关系问题。TransM 认为不同的关系类型应该具有不同的权重，利用不同的权重来更新参数。</p><p>具体意思就是一对一关系类型的三元组在计算得分时的权重最高，因为他的权重完全是由这个一个三元组来表达，但是多对一的关系的权重应该较低，因为多对一的权重应该由这些多个三元组一起来表达，所以在每个三元组身上的权重就应该下降。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912232102984.png" style="zoom:80%;" /></p><p>TransM 将每个三元组与表示映射程度的权重相关联。在计算得分时为每个三元组赋一个预计算的权重。</p><blockquote><p>其实 TransM 的做法和 TransE 相比，就是多了个权重系数</p></blockquote><p><span class="math display">\[f_{r}(h, t)=w_{\mathbf{r}}\|\mathbf{h}+\mathbf{r}-\mathbf{t}\|_{L_{1} / L_{2}}\]</span></p><p>权重取决于它的关系。计算方式： <span class="math display">\[w_{r}=\frac{1}{\log \left(h_{r} p t_{r}+t_{r} p h_{r}\right)}\]</span></p><h2 id="transh">TransH</h2><p>TransH 提出了<strong>超平面</strong>的想法，通过超平面，将同一关系映射成不同向量进行表示，来克服 TransE 在处理自反/一对多/多对一/多对多关系时的缺陷，同时模型复杂度与 TransE 基本相同。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210914194315363.png" style="zoom: 67%;" /></p><p>Idea： $$ <em>{}=-</em>{<em>{r}} =-</em>{r}^{}  _{r}</p><p>\</p><p><em>{}=-</em>{<em>{r}} =-</em>{r}^{}  _{r}</p><p>\ <em>{} + r = </em>{} $$</p><p>得分函数： <span class="math display">\[f_{r}(\mathbf{h}, \mathbf{t})= \left\|\mathbf{h}_{\perp}+\mathbf{d}_{r}-\mathbf{t}_{\perp}\right\|_{2}^{2}\]</span> TransH 存在的问题：如果两个实体本来就距离很近，那么关于一个关系向量得到的尾向量一定距离很近。然而，每个实体可以有许多属性，不同的关系关注实体的不同属性。关系和实体是完全不同的对象，在同一个语义空间中可能不足以表示它们。</p><h2 id="transr">TransR</h2><p>为了 TransH 的上述问题，作者让 TransR 在两个不同的空间，即<strong>实体空间</strong>和<strong>多个关系空间</strong>(关系特定的实体空间)中建模实体和关系，并在对应的关系空间 relation space 中进行转换，因此命名为 TransR。</p><p>TransR 认为不同的关系拥有不同的语义空间。对每个三元组，首先应将实体投影到对应的关系空间中，然后再建立从头实体到尾实体的平移关系来建模头尾实体在该关系空间中的关联性。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820195325259.png" style="zoom:50%;" /></p><p>对于每个关系 <span class="math inline">\(r\)</span>，设置一个投影矩阵 <span class="math inline">\(\mathbf{M}_r\in \mathbb{R}^{k \times d}\)</span>，可以将实体从实体空间投影到关系空间。通过映射矩阵，我们将实体的投影向量定义为： <span class="math display">\[\mathbf{h}_{r}=\mathbf{h} \mathbf{M}_{r}, \quad \mathbf{t}_{r}=\mathbf{t} \mathbf{M}_{r}\]</span> 得分函数定义为： <span class="math display">\[f_{r}(h, t)=\left\|\mathbf{h}_{r}+\mathbf{r}-\mathbf{t}_{r}\right\|_{2}^{2}\]</span></p><h3 id="ctransr">CTransR</h3><p>TransE、TransH 包括 TransR，为每个关系学习一个唯一的向量，该向量可能无法代表该关系下的所有实体对，因为这些关系通常是相当多样的。为了更好地模拟这些关系，引入了分段线性回归（piecewise linear regression）的思想来扩展 TransR。</p><p>基本思想是：</p><ol type="1"><li>首先将输入实例分为几个组。形式上，对于一个特定的关系 <span class="math inline">\(r\)</span>，训练数据中的所有实体对 <span class="math inline">\((h,t)\)</span> 都被聚集到多个簇 cluster 中，每个 簇 cluster 中的实体对都被期望与关系 <span class="math inline">\(r\)</span> 有关。所有实体对 <span class="math inline">\((h,t)\)</span> 都用它们的向量偏移量 <span class="math inline">\((h-t)\)</span> 表示，用于聚类，其中 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(t\)</span> 通过 TransE 获得。</li><li>然后，分别为每个簇学习一个单独的关系向量 <span class="math inline">\(\mathbf{r}_{c}\)</span> 和每个关系学习一个矩阵 <span class="math inline">\(\mathbf{M}_{r}\)</span>。然后将每个簇中的头实体和尾实体映射到对应关系空间中: <span class="math inline">\(\mathbf{h}_{r, c}=\mathbf{h} \mathbf{M}_{r}\)</span> 和 <span class="math inline">\(\mathbf{t}_{r, c}=\mathbf{t} \mathbf{M}_{r}\)</span>，得分函数定义为：</li></ol><p><span class="math display">\[f_{r}(h, t)=\left\|\mathbf{h}_{r, c}+\mathbf{r}_{c}-\mathbf{t}_{r, c}\right\|_{2}^{2}+\alpha\left\|\mathbf{r}_{c}-\mathbf{r}\right\|_{2}^{2}\]</span></p><p>其中，<span class="math inline">\(||\mathbf{r}_{c}-\mathbf{r}\|_{2}^{2}\)</span> 目的是确保特定于集群的关系向量 <span class="math inline">\(\mathbf{r}_{c}\)</span> 不会离原始关系向量 <span class="math inline">\(\mathbf{r}\)</span> 太远，<span class="math inline">\(α\)</span> 控制该约束的效果。此外，和 TransR 一样，CTransR 也对嵌入 <span class="math inline">\(h、r、t\)</span> 和映射矩阵的范数施加约束。</p><p><strong>TransR 和 CTransR 的区别在于两者的关系空间不同，前者只有一个关系空间，亦即对所有的关系都在同一个空间中；后者则是根据不同的关系，对属于同一个关系的所有实体对聚集在一个簇中，每个关系代表不同的空间</strong>。</p><p>TransR 存在一些问题：</p><ol type="1"><li><p>对于特定的关系 <span class="math inline">\(r\)</span>，所有的实体都共享相同的映射矩阵 <span class="math inline">\(M_r\)</span>。然而，由关系链接的实体总是包含各种类型和属性。</p></li><li><p>投影是实体和关系之间的交互过程，映射矩阵只能由关系决定是不合理的。</p></li><li><p>矩阵向量乘法使其具有大量计算，并且当关系数大时，它还具有比 TransE 和 TransH 更多的参数。 由于复杂性，TransR / CTransR 难以应用于大规模知识图。</p></li></ol><h2 id="transd">TransD</h2><p>D 代表 Dynamic，是针对 TransR 参数量太大做的改进。主要思想是：<strong>实体和关系共同构建映射矩阵</strong>。具体地，每个实体和关系由两个向量（meaning vector 和 projection vector）表示，一个表示本身的 embedding，另一个用于构建映射矩阵。每个“实体-关系”对使用的映射矩阵是不同的，头尾实体单独投影。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210911192901626.png" style="zoom: 67%;" /></p><p><span class="math inline">\(\mathbf{M}_{r h}, \mathbf{M}_{r t}\)</span> 分别是实体 <span class="math inline">\(h , t\)</span> 的映射矩阵，<span class="math inline">\(\mathbf{h}_{ip},\mathbf{t}_{ip}\)</span> 及关系 <span class="math inline">\(\mathbf{r}_{p}\)</span> 为投影向量，<span class="math inline">\(\mathbf{h}_{i\perp},\mathbf{t}_{i\perp}\)</span> 分别为头尾实体的投影向量。</p><p>对于一个三元组<span class="math inline">\((h,r,t)\)</span>，构建映射矩阵：</p><p><span class="math display">\[\begin{aligned}\mathbf{M}_{r h} &amp;=\mathbf{r}_{p} \mathbf{h}_{p}^{\top}+\mathbf{I}^{m \times n} \\\mathbf{M}_{r t} &amp;=\mathbf{r}_{p} \mathbf{t}_{p}^{\top}+\mathbf{I}^{m \times n}\end{aligned}\]</span></p><p>映射矩阵由实体和关系决定，这种操作使得两个投影向量充分交互。</p><p>投影向量： <span class="math display">\[\mathbf{h}_{\perp}=\mathbf{M}_{r h} \mathbf{h}, \quad \mathbf{t}_{\perp}=\mathbf{M}_{r t} \mathbf{t}\]</span> 三元组得分函数： <span class="math display">\[f_{r}(\mathbf{h}, \mathbf{t})=-\left\|\mathbf{h}_{\perp}+\mathbf{r}-\mathbf{t}_{\perp}\right\|_{2}^{2}\]</span></p><h3 id="与-transetransh-和-transr-的关系">与 TransE、TransH 和 TransR 的关系</h3><ol type="1"><li><p>与 TransE 的关系</p><p>当实体、关系维度相同 且 所有的投影向量设为 0 时，退化为 TransE</p></li><li><p>与 TransH 的关系</p><p>当实体、关系维度相同时，TransD 的投影操作可展开为： <span class="math display">\[\begin{aligned}\mathbf{h}_{\perp} &amp;=\mathbf{M}_{r h} \mathbf{h}=\mathbf{h}+\mathbf{h}_{p}^{\top} \mathbf{h} \mathbf{r}_{p} \\\mathbf{t}_{\perp} &amp;=\mathbf{M}_{r t} \mathbf{t}=\mathbf{t}+\mathbf{t}_{p}^{\top} \mathbf{t r}_{p}\end{aligned}\]</span> 而 TransH 的投影操作为： <span class="math display">\[\begin{aligned}\mathbf{h}_{\perp}=\mathbf{h}-\mathbf{w}_{r}^{\top} \mathbf{h} \mathbf{w}_{r}\\\mathbf{t}_{\perp}=\mathbf{t}-\mathbf{w}_{r}^{\top} \mathbf{t} \mathbf{w}_{r}\end{aligned}\]</span> 由此可看到，TransH 中投影的方向只取决于 <span class="math inline">\(r\)</span>, 而在 TransD 中, 由 <span class="math inline">\(e\)</span> 和 <span class="math inline">\(r\)</span> 共同决定.</p></li><li><p>与 TransR 的关系</p><p>TransR 为每个关系定义一个投影矩阵 <span class="math inline">\(M_r\)</span>。而 TransD 通过为每个实体和关系设置投影向量，为每个三元组动态构建两个映射矩阵： <span class="math display">\[\begin{aligned}\mathbf{M}_{r h} &amp;=\mathbf{r}_{p} \mathbf{h}_{p}^{\top}+\mathbf{I}^{m \times n} \\\mathbf{M}_{r t} &amp;=\mathbf{r}_{p} \mathbf{t}_{p}^{\top}+\mathbf{I}^{m \times n}\end{aligned}\]</span> 投影向量为： <span class="math display">\[\begin{aligned}\mathbf{h}_{\perp} &amp;=\mathbf{M}_{r h} \mathbf{h}=\mathbf{h}_{p}^{\top} \mathbf{h} \mathbf{r}_{p}+\left[\mathbf{h}^{\top}, \mathbf{0}^{\top}\right]^{\top} \\\mathbf{t}_{\perp} &amp;=\mathbf{M}_{r t} \mathbf{t}=\mathbf{t}_{p}^{\top} \mathbf{t r}_{p}+\left[\mathbf{t}^{\top}, \mathbf{0}^{\top}\right]^{\top}\end{aligned}\]</span> 没有“矩阵-向量”相乘的操作，大大减少了参数量和计算量。据原文称，TransD 比 TransR 快约三倍。</p></li></ol><h2 id="transa">TransA</h2><p>TransA 主要是对三元组函数进行改进：<strong>将欧氏距离改为马氏距离（加权的欧氏距离）</strong>。 <span class="math display">\[f_{r}(h, t)=(|\mathbf{h}+\mathbf{r}-\mathbf{t}|)^{\top} \mathbf{W}_{\mathbf{r} }(|\mathbf{h}+\mathbf{r}-\mathbf{t}|)\]</span> 其中，<span class="math inline">\(|\mathbf{h}+\mathbf{r}-\mathbf{t}|=\left(\left|h_{1}+r_{1}-t_{1}\right|,\left|h_{2}+r_{2}-t_{2}\right|, \ldots\right)\)</span> ，<strong><span class="math inline">\(\mathbf{W}_{\mathbf{r} }\)</span> 是对应于自适应度量的特定于关系 <span class="math inline">\(r\)</span> 的对称非负加权矩阵</strong>。</p><h2 id="ptranse">PTransE</h2><p>为突破现有 TransE 等模型孤立学习每个三元组的局限性，考虑关系路径的知识表示学习方法，以 TransE 作为基础进行扩展，提出 Path-based TransE（PTransE）模型，<strong>将知识图谱中的关系路径融入到知识表示学习模型中</strong>。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210914070942362.png" style="zoom:80%;" /></p><p><strong>可以看到，PTransE 仍然基于 TransE 的平移假设，但以关系路径取代了 TransE 中的单个关系三元组。即 PTransE 为关系三元组定义的能量函数考虑了实体间的多步关系路径信息。</strong></p><p>具体地，假定头实体 <span class="math inline">\(h\)</span> 和尾实体 <span class="math inline">\(t\)</span> 之间的多条关系路径集合为 <span class="math inline">\(P(h, t) = {p_1, . . ., p_N }\)</span>，其中 <span class="math inline">\(p = (r_1, . . .,r_l)\)</span> 表示关系路径 <span class="math inline">\(h \stackrel{r_{1}}{\rightarrow} \ldots \stackrel{r_{l}}{\rightarrow} t\)</span>。对于每个关系三元组 <span class="math inline">\((h,r, t)\)</span>，其能量函数定义为： <span class="math display">\[G(h, r, t)=E(h, r, t)+E(h, P, t)\]</span> 其中 <span class="math inline">\(E(h,r,t)\)</span> 用直接关系三元组刻画了关系和实体之间的相关性，如 TransE 中定义的： <span class="math display">\[E(h,r, t) = |h + r − t|_{L_1/L_2}\]</span> 由于一对实体 <span class="math inline">\(h, t\)</span> 在知识图谱中可能存在多个不同的关系路径置信，不同的关系路径在体现实体间联系方面的可靠性可能各不相同，定义 <span class="math inline">\(E(h, P, t)\)</span> 为各关系路径下能量函数根据其<strong>可靠性</strong>加权平均的结果： <span class="math display">\[E(h, P, t)=\frac{1}{Z} \sum_{p \in P(h, t)} R(p \mid h, t) E(h, p, t)\]</span> 其中，<span class="math inline">\(Z=\sum_{p \in P(h, t)} R(p \mid h, t)\)</span> 是归一化因子，<span class="math inline">\(R(p \mid h, t)\)</span> 是关系路径 p 可靠性，<span class="math inline">\(E(h,p,t)\)</span> 是关系路径 p 下实体对的能量(得分)。</p><h3 id="关系路径的置信度">关系路径的置信度</h3><p>作者提出了一种<strong>基于路径约束的资源分配算法</strong>（Pathconstraint resource allocation, PCRA）来衡量关系路径的可靠性。其基本思想是：假设存在一定数量的资源，从头部实体 <span class="math inline">\(h\)</span> 流出，且将沿着给定路径 <span class="math inline">\(p\)</span> 流动，使用最终流向尾部实体 <span class="math inline">\(t\)</span> 的资源总量，来衡量路径 <span class="math inline">\(p\)</span> 作为 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(t\)</span> 之间连接路径的可靠性。从 <span class="math inline">\(h\)</span> 开始，沿着关系路径 <span class="math inline">\(p\)</span>，可以将流动路径写为 <span class="math inline">\(S_{0} \stackrel{r_{1}}{\longrightarrow} S_{1} \stackrel{r_{2}}{\rightarrow} \ldots \stackrel{r_{l}}{\rightarrow} S_{l}\)</span>，其中 <span class="math inline">\(S_0 = {h}\)</span> 且 <span class="math inline">\(t \in S_l\)</span>。流向 <span class="math inline">\(m\)</span> 的资源被定义为： <span class="math display">\[R_{p}(m)=\sum_{n \in S_{i-1}(\cdot, m)} \frac{1}{\left|S_{i}(n, \cdot)\right|} R_{p}(n)\]</span> 其中，</p><ul><li><span class="math inline">\(S_{i−1}(·, m)\)</span> 是节点 m 的上一个节点的集合。</li><li>n 是其中一个节点(实体）</li><li><span class="math inline">\(Si(n, ·)\)</span> 是节点 n 的下一个节点的集合。</li><li><span class="math inline">\(R_p(n)\)</span> 是从实体 <span class="math inline">\(n\)</span> 获取的资源。</li></ul><p>对于每一条关系路径 p，令其头实体 h 最开始的资源为 <span class="math inline">\(Rp(h) = 1\)</span>。我们从头实体 h 通过路径 p 递归地执行资源分配算法，尾实体 t 最终获得了 <span class="math inline">\(R_p(t)\)</span> 的资源。<strong>尾实体获得的资源大小代表了其可以从头实体获取到的信息大小</strong>。因此， 采用尾实体资源 <span class="math inline">\(R_p(t)\)</span> 来衡量路径 p 对于实体对 <span class="math inline">\((h, t)\)</span> 的置信度，也就是 <span class="math display">\[R(p|h, t) = Rp(t)\]</span></p><h3 id="关系路径表示">关系路径表示</h3><p>如何得到一条关系路径 p 的向量表示 p。</p><p>除了关系路径置信度之外，还需要为路径三元组 <span class="math inline">\((h, p, t)\)</span> 定义能量函数 <span class="math inline">\(E(h, p, t)\)</span>，首先需要 在语义空间中将关系路径 p 表示为稠密向量。</p><p><strong>关系路径的语义很大程度上依赖于它所涉及的关系。</strong>因此，通过路径上涉及的所有关系的表示的语义组合来构建路径表示是合理的。如图2.6所示，路径表示 p 由 <code>BorninCity</code>，<code>CityInState</code> 和 <code>StateInCountry</code> 的表示组合而成。</p><p>具体来说，对于一个关系路径 <span class="math inline">\(p = (r1, . . .,rl)\)</span>，我们定义一个语义组合操作 ◦ 并获得关系路径表示 <span class="math inline">\(p = r_1 \circ . . . \circ r_l\)</span>。我们尝试了三种不同的方法得到关系路径的 表示：</p><ul><li><p><strong>加和</strong>：加和语义组合操作通过对所有关系的向量进行求和来获得关系路径的 表示向量，将其形式化为： <span class="math display">\[p = r_1 + · · · + r_l\]</span></p></li><li><p><strong>乘积</strong>：乘积语义组合操作通过对所有关系的向量进行累积乘积来获得路径的 表示向量，其被形式化为： <span class="math display">\[p = r_1 \circ  . . . \circ  r_l\]</span></p></li><li><p><strong>循环神经网络</strong>：使用矩阵 W 实现语义组合操作： <span class="math display">\[c_{i}=f\left(W\left[c_{i-1} ; r_{i}\right]\right)\]</span> 其中， <span class="math inline">\(f\)</span> 是一个非线性函数，<span class="math inline">\([a; b]\)</span> 表示两个向量的拼接。通过令 <span class="math inline">\(c_1 = r_1\)</span> 然后在关系路径上递归地执行循环神经网络操作，最后得到 <span class="math inline">\(p = c_l\)</span>，其中 <span class="math inline">\(c_l\)</span> 是 RNN 在序列 <span class="math inline">\(r_1, r_2, · · · , r_l\)</span> 上产生的最后一个状态。事实上，RNN 已经被尝试用于知识图谱中关系路径的表示。</p></li></ul><h3 id="能量函数得分函数">能量函数/得分函数</h3><p>可以将关系路径 p 看做根据 多步关系路径信息得到的对实体间关系 r 的近似，故定义 PTransE 的能量函数 <span class="math inline">\(E(h, p, t)\)</span> 为 p 与 r 的接近程度： <span class="math display">\[E(h,p, t) = |p-r|_{L_1/L_2}\]</span> 该能量函数在关系路径 p 和关系 r 一致时拥有较低的分数，不需要考虑实体的向量信息。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Trans系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PTransE：Modeling Relation Paths for Representation Learning of Knowledge Bases</title>
    <link href="/2021/09/14/PTransE%EF%BC%9AModeling%20Relation%20Paths%20for%20Representation%20Learning%20of%20Knowledge%20Bases/"/>
    <url>/2021/09/14/PTransE%EF%BC%9AModeling%20Relation%20Paths%20for%20Representation%20Learning%20of%20Knowledge%20Bases/</url>
    
    <content type="html"><![CDATA[<h1 id="PTransE：Modeling-Relation-Paths-for-Representation-Learning-of-Knowledge-Bases"><a href="#PTransE：Modeling-Relation-Paths-for-Representation-Learning-of-Knowledge-Bases" class="headerlink" title="PTransE：Modeling Relation Paths for Representation Learning of Knowledge Bases"></a>PTransE：Modeling Relation Paths for Representation Learning of Knowledge Bases</h1><p>这篇文章是清华大学刘知远老师团队发表在 EMNLP 2015 上的工作。为突破现有 TransE 等模型孤立学习每个三元组的局限性，考虑关系路径的知识表示学习方法，以 TransE 作为基础进行扩展，提出 Path-based TransE（PTransE）模型，<strong>将知识图谱中的关系路径融入到知识表示学习模型中</strong>。之前的模型只针对实体间的单跳关系，该工作则可以挖掘实体间的多跳关系，可用于知识推理。</p><blockquote><p>比如(小明,出生地,山东)，(山东,位于,中国)隐含了实体小明和实体中国之间的 nationality 关系。</p></blockquote><h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><p>PTransE 面临的挑战在于：</p><ul><li><p><strong>关系路径置信度</strong>：并不是所有的实体间的关系路径都是可靠且对于知识表示学习有意义的。例如一个人的职业可能跟他的朋友的职业完全无关。因此<strong>模型可能不能直接考虑所有的路径。</strong></p></li><li><p><strong>关系路径表示</strong>：为了在知识表示学习模型中考虑关系路径，我们需要将关系路径同样表示为低维稠密向量。也就是说 <strong>PTransE 模型需要建立关系路径的向量表示，参与从头实体到尾实体的关系推理过程</strong>。这是典型的组合语义问题，需要对路径上所有关系的向量进行语义组合产生路径向量。</p></li></ul><h2 id="PTransE"><a href="#PTransE" class="headerlink" title="PTransE"></a>PTransE</h2><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210914070942362.png" style="zoom: 67%;" /></p><p><strong>可以看到，PTransE 仍然基于 TransE 的平移假设，但以关系路径取代了 TransE 中的单个关系三元组。即 PTransE 为关系三元组定义的能量函数考虑了实体间的多步关系路径信息。</strong></p><p>具体地，假定头实体 $h$ 和尾实体 $t$ 之间的多条关系路径集合为 $P(h, t) = {p<em>1, . . ., p_N }$，其中 $p = (r_1, . . .,r_l)$ 表示关系路径 $h \stackrel{r</em>{1}}{\rightarrow} \ldots \stackrel{r_{l}}{\rightarrow} t$。对于每个关系三元组 $(h,r, t)$，其能量函数定义为：</p><script type="math/tex; mode=display">G(h, r, t)=E(h, r, t)+E(h, P, t)</script><p>其中 $E(h,r,t)$ 用直接关系三元组刻画了关系和实体之间的相关性，如 TransE 中定义的：</p><script type="math/tex; mode=display">E(h,r, t) = |h + r − t|_{L_1/L_2}</script><p>由于一对实体 $h, t$ 在知识图谱中可能存在多个不同的关系路径置信，不同的关系路径在体现实体间联系方面的可靠性可能各不相同，定义 $E(h, P, t)$ 为各关系路径下能量函数根据其<strong>可靠性</strong>加权平均的结果：</p><script type="math/tex; mode=display">E(h, P, t)=\frac{1}{Z} \sum_{p \in P(h, t)} R(p \mid h, t) E(h, p, t)</script><p>其中，$Z=\sum_{p \in P(h, t)} R(p \mid h, t)$ 是归一化因子，$R(p \mid h, t)$ 是关系路径 p 可靠性，$E(h,p,t)$ 是关系路径 p 下实体对的能量(得分)。</p><p>PTransE 模型设计的主要挑战便在于后两者的定义，即 </p><ul><li>如何评估一条关系路径 p 的可靠程度。</li><li>如何得到一条关系路径 p 的向量表示 p。</li></ul><h3 id="关系路径的置信度"><a href="#关系路径的置信度" class="headerlink" title="关系路径的置信度"></a>关系路径的置信度</h3><p>如何评估一条关系路径 p 的可靠程度。作者提出了一种<strong>基于路径约束的资源分配算法</strong>（Pathconstraint resource allocation, PCRA）来衡量关系路径的可靠性。其基本思想是：假设存在一定数量的资源，从头部实体 $h$ 流出，且将沿着给定路径 $p$ 流动，使用最终流向尾部实体 $t$ 的资源总量，来衡量路径 $p$ 作为 $h$ 和 $t$ 之间连接路径的可靠性。从 $h$ 开始，沿着关系路径 $p$，可以将流动路径写为 $S<em>{0} \stackrel{r</em>{1}}{\longrightarrow} S<em>{1} \stackrel{r</em>{2}}{\rightarrow} \ldots \stackrel{r<em>{l}}{\rightarrow} S</em>{l}$，其中 $S_0 = {h}$ 且 $t \in S_l$。流向 $m$ 的资源被定义为：</p><script type="math/tex; mode=display">R_{p}(m)=\sum_{n \in S_{i-1}(\cdot, m)} \frac{1}{\left|S_{i}(n, \cdot)\right|} R_{p}(n)</script><p>其中，</p><ul><li>$S_{i−1}(·, m)$ 是节点 m 的上一个节点的集合。</li><li>n 是其中一个节点(实体）</li><li>$S_i(n, ·)$ 是节点 n 的下一个节点的集合。</li><li>$R_p(n)$ 是从实体 $n$ 获取的资源。</li></ul><p>对于每一条关系路径 p，令其头实体 h 最开始的资源为 $Rp(h) = 1$。我们从头实体 h 通过路径 p <strong>递归</strong>地执行资源分配算法，尾实体 t 最终获得了 $R_p(t)$ 的资源。<strong>尾实体获得的资源大小代表了其可以从头实体获取到的信息大小</strong>。因此， 采用尾实体资源 $R_p(t)$ 来衡量路径 p 对于实体对 $(h, t)$ 的置信度，也就是</p><script type="math/tex; mode=display">R(p|h, t) = Rp(t)</script><div class="note note-primary">            <p>举个栗子：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210914171635963.png" style="zoom: 45%;" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210914171545734.png" style="zoom: 45%;" /></p>          </div><h3 id="关系路径表示"><a href="#关系路径表示" class="headerlink" title="关系路径表示"></a>关系路径表示</h3><p>如何得到一条关系路径 p 的向量表示 p。</p><p>除了关系路径置信度之外，还需要为路径三元组 $(h, p, t)$ 定义能量函数 $E(h, p, t)$，首先需要 在语义空间中将关系路径 p 表示为稠密向量。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210914092435613.png" style="zoom:80%;" /></p><p><strong>关系路径的语义很大程度上依赖于它所涉及的关系。</strong>因此，通过路径上涉及的所有关系的表示的语义组合来构建路径表示是合理的。如图2.6所示，路径表示 p 由 <code>BorninCity</code>，<code>CityInState</code> 和 <code>StateInCountry</code> 的表示组合而成。</p><p>具体来说，对于一个关系路径 $p = (r1, . . .,rl)$，我们定义一个语义组合操作 ◦ 并获得关系路径表示 $p = r_1 \circ  . . . \circ  r_l$。我们尝试了三种不同的方法得到关系路径的 表示：</p><ul><li><p><strong>加和</strong>：加和语义组合操作通过对所有关系的向量进行求和来获得关系路径的 表示向量，将其形式化为：</p><script type="math/tex; mode=display">p = r_1 + · · · + r_l</script></li><li><p><strong>乘积</strong>：乘积语义组合操作通过对所有关系的向量进行累积乘积来获得路径的 表示向量，其被形式化为：</p><script type="math/tex; mode=display">p = r_1 \circ  . . . \circ  r_l</script></li><li><p><strong>循环神经网络</strong>：使用矩阵 W 实现语义组合操作：</p><script type="math/tex; mode=display">c_{i}=f\left(W\left[c_{i-1} ; r_{i}\right]\right)</script><p>其中， $f$ 是一个非线性函数，$[a; b]$ 表示两个向量的拼接。通过令 $c_1 = r_1$ 然后在关系路径上递归地执行循环神经网络操作，最后得到 $p = c_l$，其中 $c_l$ 是 RNN 在序列 $r_1, r_2, · · · , r_l$ 上产生的最后一个状态。事实上，RNN 已经被尝试用于知识图谱中关系路径的表示。</p></li></ul><h4 id="能量函数-得分函数"><a href="#能量函数-得分函数" class="headerlink" title="能量函数/得分函数"></a>能量函数/得分函数</h4><p>可以将关系路径 p 看做根据 多步关系路径信息得到的对实体间关系 r 的近似，故定义 PTransE 的能量函数 $E(h, p, t)$ 为 p 与 r 的接近程度：</p><script type="math/tex; mode=display">E(h,p, t) = |p-r|_{L_1/L_2}</script><p>该能量函数在关系路径 p 和关系 r 一致时拥有较低的分数，不需要考虑实体的向量信息。</p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>定义 PTransE 模型的训练目标函数如下：</p><script type="math/tex; mode=display">L=\sum_{(h, r, t) \in \mathbf{T}}\left[L(h, r, t)+\frac{1}{Z} \sum_{p \in P(h, t)} R(p \mid h, t) L(p, r)\right]</script><p>其中，和 TransE 模型类似，我们采用<u>基于边界距离的函数</u>来定义 $L(h,r, t)$ 和 $L(p,r)$：</p><script type="math/tex; mode=display">L(h, r, t)=\sum_{\left(h^{\prime}, r^{\prime}, t^{\prime}\right) \in \mathbf{T}^{-}}\left[\gamma+E(h, r, t)-E\left(h^{\prime}, r^{\prime}, t^{\prime}\right)\right]_{+}</script><p>和</p><script type="math/tex; mode=display">L(p, r)=\sum_{\left(h, r^{\prime}, t\right) \in \mathbf{T}^{-}}\left[\gamma+E(p, r)-E\left(p, r^{\prime}\right)\right]_{+}</script><p>在训练过程中，PTransE 模型采用随机梯度下降来进行优化。在实际优化过程 中，对实体和关系表示向量添加如下约束：</p><script type="math/tex; mode=display">\|\mathbf{h}\|_{2} \leq 1, \quad\|\mathbf{r}\|_{2} \leq 1, \quad\|\mathbf{t}\|_{2} \leq 1 . \quad \forall h, r, t .</script><p>此外，在实验过程中还有一些具体问题需要考虑，这些具体问题会显著地影响模型的效果：</p><ul><li><p><strong>反向关系添加</strong>：PCRA 只考虑了一个方向，我们也需要反向关系，而反向关系在现有知识图谱中很可能不存在。</p><p>因此，作者对于知识图谱中的每一个关系添加一个反向关系，也就是，对于每一个关系事实三元组 $(h,r, t)$，向知识图谱中添加其对应的反向三元组 $(t,r^{−1}, h)$。</p><blockquote><p>不明白这个反向关系到底怎么加？</p></blockquote></li><li><p><strong>关系路径选择的约束</strong>：在知识图谱中，很多实体对应的关系和事实数目庞大，直接枚举头部和尾部实体之间的所有可能的关系路径会非常耗时占空间. 为了提高计算效率，将路径长度限制在最多 3 步，并仅考虑那些置信度分值大于 0.01 的关系路径。</p></li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="链接预测"><a href="#链接预测" class="headerlink" title="链接预测"></a>链接预测</h3><p>链接预测任务旨在 $(h,r,t)$ 中的某一元素缺失时，能够补全整个三元组。</p><p>定义如下评分函数用于评测：</p><script type="math/tex; mode=display">S(h, r, t)=G(h, r, t)+G\left(t, r^{-1}, h\right)\\G(h, r, t)=\|\boldsymbol{h}+\boldsymbol{r}-\boldsymbol{t}\|+\frac{1}{Z} \sum_{p \in P(h, t)} \operatorname{Pr}(r \mid p) R(p \mid h, t)\|\boldsymbol{p}-\boldsymbol{r}\|</script><p>这一评分函数和算法模型一节中定义的能量（得分）函数很相近。区别在于，作者认为<strong>某一关系路径 p 的可靠性也和 r 的推测强度有关</strong>。在这里根据训练数据对推测强度进行量化</p><script type="math/tex; mode=display">\operatorname{Pr}(r \mid p)= \frac{\operatorname{Pr}(r, p)}{\operatorname{Pr}(p)}</script><h4 id="实体预测"><a href="#实体预测" class="headerlink" title="实体预测"></a>实体预测</h4><p>理想情况下，PTransE 可以找到给定实体和所有候选实体之间的关系路径。然而，这是相当耗时且很难实际操作的。因为如果要考虑所有可能的关系路径，必须为每一个测试三元组迭代遍历实体集合 E 中的每一个候选实体，并寻找相应的关系路径。所以作者提出了一种重排序方法：首先根据 TransE 计算的评分 $||h+r-t||$ 对所有候选实体进行排序；然后对排名在前 500 的实体使用 PTransE 进行评分，并重新排序。</p><blockquote><p>先粗排，再细排，聪明!</p></blockquote><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210914153208520.png" style="zoom: 55%;" /></p><p>从表格2.6中观察到：</p><ol><li>PTransE 显著优于包括 TransE 在内的其他基准模型。这表明关系路径为 知识图谱的表示学习提供了一个很好的信息补充，并且这些知识图谱中的关系路径已经被 PTransE 成功嵌入到低维空间之中。</li><li>对于 PTransE，加和 ADD 操作均优于其他组合运算。作者认为原因在于加和操作同时符合 TransE 和 PTransE 的学习目标。以 $h \stackrel{r<em>{1}}{\longrightarrow} e</em>{1} \stackrel{r_{2}}{\longrightarrow} t$ 为例，两个直接关系在加和操作下的优化目标 $h+ r_1 = e_1$ 和 $e_1+ r_2 = t$， 可以很容易地从两个式子中得到关系路径的优化目标 $h + r_1 + r_2 = t$</li></ol><h4 id="关系预测"><a href="#关系预测" class="headerlink" title="关系预测"></a>关系预测</h4><p>关系预测旨在预测给定的两个实体之间的关系。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210914154746364.png" style="zoom: 50%;" /></p><p>针对 TransE：</p><ul><li>不含逆向关系的 TransE（TransE）</li><li>含有逆向关系的 TransE（+Rev）</li><li>考虑关系路径的 PTransE（+Rev+Path）</li></ul><p>针对 PTransE：</p><ul><li>仅考虑关系路径（-TransE）</li><li>仅考虑图谱特征（-Path）</li></ul><p>从表格2.8中观察到：</p><ol><li><p>PTransE 在关系预测上要显著优于 TransE+Rev+Path，即使 TransE 本身，考虑了关系路径的 TransE+Rev+Path 与 TransE+Rev 相比，在测试中也可以减少 17.3% 的预测错误率。表明对关系路径进行建模有利于关系预测。</p><blockquote><p>不太清楚 PTransE 和 TransE+Rev+Path 的区别？</p><p>是因为 PTransE 的 PCRA 算法和关系路径表示？</p></blockquote></li><li><p>仅考虑关系路径而没有图谱特征的模型（PTransE-TransE）的答案平均排名非常之高。考虑其中的原因，主要是测试三元组中并非所有实体对之间都有关系路径，这将导致 PTransE-TransE 模型在预测这一类实体对时对关系进行随机猜测，正确答案的排名期望值为 |R|/2。</p><p>与之相对的，是 PTransE-TransE 的 Hits@1 结果比较合理，这说明了建模关系路径对知识图谱表示学习是具有重要意义的。</p><p>与 TransE 相比，不考虑图谱特征的 PTransE-TransE 还是具有劣势的，这表明虽然建模关系路径有利于获取实体之间的关系，但图谱本身的实体表示为关系预测提供了关键信息，是知识表示学习中必不可少的特征。</p></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>PTransE 将知识图谱中的关系路径融入到知识表示学习模型(本文是TransE)中。提出了三种方式表示出关系路径：加和(效果最好，因为同时符合两种模型的优化目标)，乘积、RNN。然后提出基于路径约束的资源分配算法 PCRA 计算关系路径的置信度，并将得分(能量)函数增加了关系路径的置信度计算得分(能量). 通过实验证明了模型具有不错的效果.</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>PTransE</tag>
      
      <tag>KGR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TransM：Transition-based Knowledge Graph Embedding with Relational Mapping</title>
    <link href="/2021/09/12/TransM%EF%BC%9ATransition-based%20Knowledge%20Graph%20Embedding%20with%20Relational%20Mapping/"/>
    <url>/2021/09/12/TransM%EF%BC%9ATransition-based%20Knowledge%20Graph%20Embedding%20with%20Relational%20Mapping/</url>
    
    <content type="html"><![CDATA[<h1 id="transmtransition-based-knowledge-graph-embedding-with-relational-mapping">TransM：Transition-based Knowledge Graph Embedding with Relational Mapping</h1><p>该文是清华大学（不知道哪个团队）和埃默里大学共同发表在 PACLIC（CCF 列表上没有找到这个会，大概相当于C的水平） 2014 上的文章，提出了 TransM，M 代表 mapping。文章是在 TransE 后的第二年出的，还没有 TransH 和 TransR，所以 baseline 只对比了 TransE 和一些非 Trans 模型。</p><h2 id="basic-idea">Basic Idea</h2><p>TransM 算法是基于 TransE 算法进行的改进，目的还是为了解决在 TransE 中无法处理的一对多、多对一、多对多和自反关系问题。TransM 认为不同的关系类型应该具有不同的权重，利用不同的权重来更新参数。</p><p>具体意思就是一对一关系类型的三元组在计算得分时的权重最高，因为他的权重完全是由这个一个三元组来表达，但是多对一的关系的权重应该较低，因为多对一的权重应该由这些多个三元组一起来表达，所以在每个三元组身上的权重就应该下降。</p><h2 id="transm">TransM</h2><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912232102984.png" style="zoom:80%;" /></p><p>TransE 的”一对多“情况(左)，因为得分函数始得尾实体都被推到一个狭窄的范围内。作者希望能够失去约束，给”多(MANY)“一面更大的灵活性(如右所示)。</p><p>TransM 将每个三元组与表示映射程度的权重相关联。在计算得分时为每个三元组赋一个预计算的权重。</p><blockquote><p>其实 TransM 的做法和 TransE 相比，就是多了个权重系数</p></blockquote><p><span class="math display">\[f_{r}(h, t)=w_{\mathbf{r}}\|\mathbf{h}+\mathbf{r}-\mathbf{t}\|_{L_{1} / L_{2}}\]</span></p><p>权重取决于它的关系。计算方式： <span class="math display">\[w_{r}=\frac{1}{\log \left(h_{r} p t_{r}+t_{r} p h_{r}\right)}\]</span></p><blockquote><ul><li>每个头实体的平均尾实体数，表示为 <span class="math inline">\(tph\)</span> <em>(tail entities per head entity)</em>；</li><li>每个尾实体的平均头实体数，表示为 <span class="math inline">\(hpt\)</span> <em>(head entities per tail entity)</em>。</li></ul></blockquote><p>损失函数同 TransE。 <span class="math display">\[\begin{array}{l}\mathcal{L}=\min \sum_{(h, r, t) \in \Delta} \sum_{\left(h^{\prime}, r, t^{\prime}\right) \in \Delta_{(h, r, t)}^{\prime}}\left[\gamma+f_{r}(h, t)-f_{r}\left(h^{\prime}, t^{\prime}\right)\right]_{+} \\\text {s.t. } \quad \forall e \in E,\|e\|_{2}=1\end{array}\]</span></p><h3 id="algorithm">Algorithm</h3><p>TransM 的伪代码和 TransE 相比就是在初始化之后多了个计算权重的过程，但是权重系数是<strong>固定不变</strong>，使用<strong>随机初始化的实体及关系向量</strong>计算得到的。（因为关系远少于实体对数，所以直接算出每个关系对应的权重）</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210913081637885.png" /></p><h2 id="experiments">Experiments</h2><p>依旧是 Link Prediction 和 Triplet Classification 实验。</p><p>TransM 虽然是个名不见经传的冷门模型，但效果居然还不错，能超过 TransE 和 大多数非 Trans 模型。</p><h2 id="summary">Summary</h2><p>TransM 算法通过给三元组不同的权重，利用不同的权重来影响得分对于损失函数的效果，从而实现的对于多对一、一对多关系尽可能的消除 TransE 带来的影响。</p><p>但是依旧存在两个问题</p><ul><li>通过增加权重，实际上并没有解决多对一中，多的一样实体相等的状态，只是延缓了这个过程，</li><li>每个三元组的权重是一个固定的值，采用的是随机初始化的向量经过计算之后的结果，利用动态的向量计算权重是不是可解释性更高效果更好？</li></ul><p>虽然是个简单的 idea，但是效果却出奇地好，值得一篇 C。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>TransM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TranSparse：Knowledge graph completion with adaptive sparse transfer matrix</title>
    <link href="/2021/09/12/TranSparse%EF%BC%9AKnowledge%20graph%20completion%20with%20adaptive%20sparse%20transfer%20matrix/"/>
    <url>/2021/09/12/TranSparse%EF%BC%9AKnowledge%20graph%20completion%20with%20adaptive%20sparse%20transfer%20matrix/</url>
    
    <content type="html"><![CDATA[<h1 id="transparseknowledge-graph-completion-with-adaptive-sparse-transfer-matrix">TranSparse：Knowledge graph completion with adaptive sparse transfer matrix</h1><p>TranSparse 是自动化所赵军、刘康老师团队发表在 AAAI 2016 上的工作， 和 TransD 的作者是一个人。主要思想是：引入稀疏因子解决知识库的异质性和不平衡性问题。</p><h2 id="motivation">Motivation</h2><p>通过先前的模型，我们基本掌握了知识表示的学习方法：首先通过投影策略将实体和关系映射到对应的语义空间，其次均使用得分函数 <span class="math inline">\(f(h,t)=||h+r-t||\)</span> 表示实体对的评分。另外使用负采样生成错误样本进行训练，使得正确的样本得分函数值降低，错误样本的得分函数值升高。</p><p>然而这些模型均忽略了图谱的两个重要特性：<strong>异质性（heterogeneity）</strong>和 <strong>不平衡性（imbalance）</strong>。图谱中的异质性是指不同关系对应的实体对数量不一致，例如对于关系 <span class="math inline">\(r\)</span> 链接的所有实体对数量可能非常多，而对于 <span class="math inline">\(r ′\)</span> 链接的所有实体对数量可能只有1个。不平衡性是指头尾实体的数量不一致，例如形如对于 <code>(地名，local，洲名)</code> 的三元组，地名可能成千上万个，而洲名只有七个。由于数量的不对等，可知数量较多的对应关系的实体对或头尾实体，它们所包含的信息应该越多，而前面的几种模型忽略了这一点，使得针对每个实体对都用同样的方法训练，势必会导致<strong>数量多的部分出现欠拟合</strong>，<strong>数量少的部分出现过拟合</strong>。因此本文 TranSparse 处理这种问题的策略是引用<strong>稀疏矩阵</strong>。首先对于异质性，提出 TranSparse（Share），稀疏因子取决于关系链接对应的实体对数量，且两个实体对应的关系投影矩阵是相同的。对于不平衡性，提出 TranSparse（Separate），每个关系对应的实体对中，头尾实体使用不同的关系投影矩阵。</p><h2 id="transparse">TranSparse</h2><h3 id="稀疏矩阵">稀疏矩阵</h3><p>稀疏矩阵是指一个矩阵中含有大量的0元素，而 <strong>0元素所占总元素个数的比值为稀疏因子</strong> <span class="math inline">\(\theta\)</span>。稀疏因子 <span class="math inline">\(\theta\)</span> 越大表示这个矩阵越稀疏。用 <span class="math inline">\(M(\theta)\)</span> 表示稀疏因子为 <span class="math inline">\(\theta\)</span> 的矩阵。对于稀疏矩阵有两种结构，如图所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912164706797.png"  style="zoom:50%;" /></p><p>黑色表示非0元素，白色表示0元素。图（a）表示结构化的稀疏矩阵，可知所有非0元素沿着主对角线排列，因此可知对于 <span class="math inline">\(m\times m\)</span> 的对角矩阵的稀疏因子为 $ (m m - m) / (m m)$。图（b）中表示非结构稀疏矩阵，0元素是随机排布。</p><h3 id="为什么选择稀疏矩阵而不是低秩矩阵">为什么选择稀疏矩阵，而不是低秩矩阵？</h3><p><strong>自由度</strong>是衡量一个矩阵中相互独立的元素个数，而稀疏矩阵和低秩矩阵均可以在一定程度上降低自由度（稀疏矩阵包含大量的0，而低秩矩阵对应的梯形矩阵包含大量的0，0的个数越多，则非0的相互独立的元素个数变少）。对于低秩矩阵，由于许多变量之间存在线性约束条件（可回顾线性方程组和线性相关的概念），因此秩越低，自由度就越低。对于稀疏矩阵，由于含有非0元素数量少，所以在训练过程中让0元素保持不变，因此可变的元素就很少，亦即自由的变量很少。之所以引入自由度的概念，是因为对于一个矩阵，如果自由度越低，即包含有效的信息量就越少，对解决异质性和非平衡性很有效。</p><p>对于低秩矩阵，矩阵的秩的大小不大于该矩阵最小的维度数，而自由度也仅局限于一小范围内。具体地说，如果矩阵 $ M_{mn}$ ，秩 <span class="math inline">\(rank(M)\leq min(m,n)\)</span>，自由度也在 <span class="math inline">\(0-min(m,n)\)</span> 之间，因为矩阵的秩主要用于衡量行向量或列向量的线性最大无关组的数量，因此其可以控制大量的元素，不易于控制。如果使用稀疏矩阵，我们知道非0元素的个数即为自由元素的个数，因此其可以控制唯一的元素，使得自由度范围更大，亦即能够大范围的表示不同复杂度的图。稀疏矩阵中仅有非0元素参与运算，这比低秩矩阵更有效，因此选择稀疏矩阵来控制投影的复杂度。</p><div class="note note-primary">            <p>矩阵的秩：手工求矩阵的秩时，为了求矩阵 A 的秩，我们是通过矩阵初等变换把 A 化为阶梯型矩阵，若该阶梯型矩阵有 r 个非零行，那 A 的秩 rank(A) 就等于 r。<strong>从物理意义上讲，矩阵的秩度量的就是矩阵的行列之间的相关性。</strong>如果矩阵的各行或列是线性无关的，矩阵就是满秩的，也就是秩等于行数。</p><p>比如： <span class="math display">\[\left\{\begin{array}{l}3 x+5 y+z=15 \\x-y+z=8 \\2 x-2 y+2 z=16\end{array}\right.\]</span> 因为线性方程组可以用矩阵描述，所以秩就表示了有多少个有用的方程了。上面的方程组有3个方程，实际上只有2个是有用的，一个是多余的，所以对应的矩阵的秩就是2了。</p><p>既然秩可以度量相关性，而矩阵的相关性实际上就表示了矩阵的结构信息。如果矩阵之间各行的相关性很强，那么就表示这个矩阵实际可以投影到更低维的线性子空间，也就是用几个向量就可以完全表达了，它就是低秩的。所以总结的一点就是：如果矩阵表达的是结构性信息，例如图像、用户-商品推荐表等等，那么这个矩阵各行之间存在这一定的相关性，那这个矩阵一般就是低秩的。</p><p><strong>如果X是一个m行n列的数值矩阵，rank(X) 是X的秩，假如 rank (X) 远小于m和n，则称X是低秩矩阵。</strong>低秩矩阵每行或每列都可以用其他的行或列线性表出，可见它包含大量的冗余信息。利用这种冗余信息，可以对缺失数据进行恢复，也可以对数据进行特征提取。</p>          </div><h3 id="transparseshare">TranSparse（Share）</h3><p>先前的模型中，不论关系对应的实体或实体对数量多少，训练的参数是相同的，因此可能导致数量少的实体或实体对训练过拟合，数量多的实体或实体对训练欠拟合，因此<strong>需要考虑参数与实体对数量的关系。</strong>（针对异质性）</p><p>在 TranSparse（Share）中，设 <span class="math inline">\(N_r\)</span> 表示关系 <span class="math inline">\(r\)</span> 链接的实体对数量，<span class="math inline">\(N_{r^*}\)</span> 表示其中最大值，<span class="math inline">\(r^*\)</span> 表示对应的关系。设 <span class="math inline">\(\theta_{\min }\left(0 \leq \theta_{\min } \leq 1\right)^{3}\)</span> 表示矩阵 <span class="math inline">\(M_{r^*}\)</span> 的稀疏因子，则 <span class="math display">\[\theta_{r}=1-\left(1-\theta_{\min }\right) N_{r} / N_{r^{*}}\]</span> 公式中，取最大实体对数量为基数，其他实体对数量与之比值作为相对复杂度。该公式可计算对应关系投影矩阵的稀疏因子。</p><p>其次可将头尾实体通过同一个投影矩阵分别映射到关系空间中： <span class="math display">\[\mathbf{h}_{p}=\mathbf{M}_{r}\left(\theta_{r}\right) \mathbf{h}, \quad \mathbf{t}_{p}=\mathbf{M}_{r}\left(\theta_{r}\right) \mathbf{t}\]</span></p><h3 id="transparseseparate">TranSparse（Separate）</h3><p>TranSparse（Separate）与 Share 不同，头尾实体使用不同的投影矩阵，分别映射到不同的关系空间中。（针对不平衡性）<span class="math inline">\(\mathbf{M}_{r}^{h}\left(\theta_{r}^{h}\right)\)</span> 表示“头实体-关系”映射矩阵 ，<span class="math inline">\(\mathbf{M}_{r}^{t}\left(\theta_{r}^{t}\right)\)</span> 表示“尾实体-关系”映射矩阵。对于关系 <span class="math inline">\(r\)</span> ，最大数量头尾实体 <span class="math inline">\(h^*\)</span> 和 <span class="math inline">\(t^*\)</span> 分别对应的数量 <span class="math inline">\(N_{r^{*}}^{h^{*}}\)</span>，<span class="math inline">\(N_{r^{*}}^{t^{*}}\)</span>。因此“头实体-关系”映射矩阵的稀疏因子为 <span class="math display">\[\theta_{r}^{h}=1-\left(1-\theta_{\min }\right) N_{r}^{h} / N_{r^{*}}^{h^{*}}  \\\theta_{r}^{t}=1-\left(1-\theta_{\min }\right) N_{r}^{t} / N_{r^{*}}^{t^{*}} \]</span> 因此头尾实体分别映射到关系空间中： <span class="math display">\[\mathbf{h}_{p}=\mathbf{M}_{r}^{h}\left(\theta_{r}^{h}\right) \mathbf{h}, \quad \mathbf{t}_{p}=\mathbf{M}_{r}^{t}\left(\theta_{r}^{t}\right) \mathbf{t}\]</span></p><p>TranSparse（Share） 和 TranSparse（Separate）两者的得分函数为： <span class="math display">\[f_{r}(\mathbf{h}, \mathbf{t})=\left\|\mathbf{h}_{p}+\mathbf{r}-\mathbf{t}_{p}\right\|_{\ell_{1 / 2}}^{2}\]</span></p><h3 id="损失函数">损失函数</h3><p>由于图谱中都为真实的三元组，因此需要进行负采样。这一部分与 TransH 相同。损失函数为： <span class="math display">\[L=\sum_{(h, r, t) \in \Delta} \sum_{\left(h^{\prime}, r, t^{\prime}\right) \in \Delta^{\prime}}\left[\gamma+f_{r}(\mathbf{h}, \mathbf{t})-f_{r}\left(\mathbf{h}^{\prime}, \mathbf{t}^{\prime}\right)\right]_{+}\]</span></p><h3 id="algorithm">Algorithm</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912185154063.png" /></p><h2 id="experiments">Experiments</h2><h3 id="triplet-classification">Triplet Classification</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912191950720.png" style="zoom: 67%;" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912194325002.png" style="zoom:80%;" /></p><ol type="1"><li>在表3中，TranSparse（share）比Trans（E，H，R）获得更好的性能，并且接近 TransD，这表明异质性在我们的任务中很重要。在图3中可以看到 TranSparse 可以更好地处理数据的异质性。TranSparse 改进了 TransR 在简单和复杂关系上的性能，TranSparse 比 TransR 具有更少的简单关系参数和更多的复杂关系参数。</li><li>TranSparse（Separate）比 TranSparse（share）获得更好的性能，这说明不平衡也是一个关键问题，作者的方法可以减少其负面影响；</li><li>非结构化模式通常比结构化模式稍好一些。可能是非结构化模式更接近最佳稀疏模式。</li></ol><h3 id="link-prediction">Link Prediction</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912195347399.png" style="zoom: 80%;" /></p><ol type="1"><li><p>TranSparse（share）优于Trans（E，H，R），接近TransD，这表明作者的方法很好地处理了数据的异质性。</p></li><li><p>在大多数情况下，TranSparse（Separate）比 TranSparse（share）获得更好的性能。在表5中，对于典型的不平衡关系（1-to-N、N-to-1和N-to-N），TranSparse（Separate）在大多数预测精度上都优于 TranSparse（share）。</p><p>因此，我们可以得出这样的结论：<strong>TranSparse（Separate）可以同时克服数据的异构性和不平衡性；非结构化模式的性能也优于结构化模式。</strong></p></li></ol><h2 id="summary">Summary</h2><p>提出一种 TranSparse 模型用于补全知识图谱，考虑异质性和不平衡性，引入了稀疏变换矩阵。并提出了两种稀疏模式，并分析优劣。实验证明了方法是有效的，且含有少量的参数；在三元组分类和链接预测任务上达到了最优效果。</p><div class="note note-info">            <p>有人认为，实验中对比的 baseline 并不多，TranSparse 自己的模型就占了四行，很多论文是这样，自己提出的模型有很多个小 trick，可以视为几个子模型，与 baseline 一齐比较，即使其中任意一个达到 state-of-the-art 的效果，都是成功，看起来会比较好看，在 baseline 比较少的情况下不会使实验部分看起来很单薄。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>TranSparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TransA：An Adaptive Approach for Knowledge Graph Embedding</title>
    <link href="/2021/09/12/TransA%EF%BC%9AAn%20Adaptive%20Approach%20for%20Knowledge%20Graph%20Embedding/"/>
    <url>/2021/09/12/TransA%EF%BC%9AAn%20Adaptive%20Approach%20for%20Knowledge%20Graph%20Embedding/</url>
    
    <content type="html"><![CDATA[<h1 id="transaan-adaptive-approach-for-knowledge-graph-embedding">TransA：An Adaptive Approach for Knowledge Graph Embedding</h1><p>TransA 是清华大学朱小燕黄民烈老师团队发表在 AAAI 2015 上的文章。</p><p>先前的知识表示方法（TransE、TransH、TransR、TransD、TranSparse 等）的损失函数仅单纯的考虑到 <span class="math inline">\(h + r\)</span> 和 <span class="math inline">\(t\)</span> 在某个语义空间的欧式距离，认为只要欧式距离最小，就认为 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(t\)</span> 的关系为 <span class="math inline">\(r\)</span> 。显然这种度量标准过于简单，虽然先前的工作在得分函数上做出了不错的改进，但训练的损失函数制约了表示能力，因此，本文 TransA 模型的提出，主要对得分函数进行改进：<strong>将欧氏距离改为马氏距离（加权的欧氏距离）</strong>。虽然 TransA 的提出是在 TransD、TranSparse 之前，但实践表明 TransA 的提出很有价值。</p><h2 id="motivation">Motivation</h2><p>1、由于缺乏灵活的损失函数，当前的翻译模型均是应用球形等位超平面，因此越靠近中心，实体对与对应关系的向量越相似。如图所示，这是 TransE 模型在 FreeBase 上训练的向量通过 PCA 降维得到的图：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912091635183.png"  style="zoom: 60%;" /></p><p>橘黄色的为头实体，橘黄色的线与箭头则为对应的关系向量。蓝色的叉表示正确的尾实体，红色的圆点则是错误的尾实体，可知当简单的使用欧式距离来评判，会掺和进很多错误的实体。由于图谱是复杂多变的，这一点很难避免。</p><p>2、其次，由于过于简单的损失函数，使得当前几种翻译模型在对向量的每一个维度的训练处理方法相同。如图所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912091319574.png"  style="zoom:80%;" /></p><p>传统的方法采用欧氏距离度量实体对与关系向量的相似性（图(a)），假设这里向量只有两个维度 <span class="math inline">\(x,y\)</span>，度量方法则是对 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 一样。然而当错误的实体（橘黄色空心圆）比正确的实体（橘黄色实心圆）更接近头实体与关系的和向量 <span class="math inline">\(h + r\)</span> （黑色圆表示头实体，箭头表示关系），则会预测错误。但是如果分别对不同维度进行考虑，如图（b），降低 <span class="math inline">\(x\)</span> 维度对度量的影响，提升 <span class="math inline">\(y\)</span> 方向对度量的影响，就可以让正确的尾实体“距离” <span class="math inline">\(h + r\)</span> 更近。这种度量不是传统的欧氏距离，而是<strong>马氏距离</strong>。</p><p>因此作者推测，一个关系只能受到几个特定维度的影响，而其他不相关维度则会有噪声。相同地处理所有尺寸会产生大量噪音，并降低性能。</p><div class="note note-primary">            <p>我觉得好像反了？针对 b 中的情况应该是提升 <span class="math inline">\(y\)</span> 方向对度量的影响...</p><p>看到网上的博客，有人认为可能是按照之前模型的打分函数加负号的情况，就能说得通了。</p>          </div><h2 id="transa">TransA</h2><h3 id="自适应度量的得分函数">自适应度量的得分函数</h3><p>作者认为传统的得分函数只是单纯的考虑向量之间的距离，对应超平面是一个球面，因此可能会将最近的错误的向量被预测为正确，于是<strong>将三元组打分函数中的欧氏距离改为马氏（Mahalanobis）距离（即加权的欧式距离）</strong>。提出一种新的得分函数为 <span class="math display">\[f_{r}(h, t)=(|\mathbf{h}+\mathbf{r}-\mathbf{t}|)^{\top} \mathbf{W}_{\mathbf{r} }(|\mathbf{h}+\mathbf{r}-\mathbf{t}|)\]</span> 其中，<span class="math inline">\(|\mathbf{h}+\mathbf{r}-\mathbf{t}|=\left(\left|h_{1}+r_{1}-t_{1}\right|,\left|h_{2}+r_{2}-t_{2}\right|, \ldots\right)\)</span> ，<strong><span class="math inline">\(\mathbf{W}_{\mathbf{r} }\)</span> 是对应于自适应度量的特定于关系 <span class="math inline">\(r\)</span> 的对称非负加权矩阵</strong>。</p><p>不同于传统的方法，得分函数使用绝对值，作者给出两方面的解释：</p><ol type="1"><li><p>一方面，只有在 <span class="math inline">\(W_r\)</span> 的所有项都是<strong>非负</strong>的情况下，绝对值计算才能使分数函数成为一个定义良好的范数</p></li><li><p>另一方面，忽略几何学中正负的方向性在 TransA 的应用。如果得分函数存在负数，如果其对应的权重过大，则损失函数便降低，然而负数并不能说明 <span class="math inline">\(h + r\)</span> 的距离更近。</p></li></ol><div class="note note-primary">            <p>自适应度量应该就是指将欧氏距离改为马氏（Mahalanobis）距离（即加权的欧式距离）。</p>          </div><h3 id="从-椭球面-的角度">从 椭球面 的角度</h3><p>作者认为传统的方法是“球形等势面（Spherical Equipotential Surfaces）”的，何为球形等势面？由于传统的得分函数是欧式距离，<span class="math inline">\(h + r\)</span> 向量与 <span class="math inline">\(t\)</span> 向量存在一定的位移，当在训练过程中，一个 <span class="math inline">\(h\)</span> 可能与若干个 <span class="math inline">\(t\)</span> 存在 <span class="math inline">\(r\)</span> 关系，因此 <span class="math inline">\(h + r\)</span> 与 一定数量的 <span class="math inline">\(t\)</span> 之间应保持较近距离，为了将所有正确的 <span class="math inline">\(t\)</span> 纳含进去，普通的得分函数 <span class="math inline">\(\|(\mathbf{t}-\mathbf{h})-\mathbf{r}\|_{2}^{2}\)</span>，就是在 <span class="math inline">\(h + r\)</span> 处画一个球面（二维空间中就是一个圆），并将所有正确的包含进去。但在所有正确的 <span class="math inline">\(t\)</span> 的范围内，总会存在错误的实体，因此保证查全率的情况下准确率非常低。如果选用 <span class="math inline">\(f_r(h,t)=(|h+r-t|)^{\mathbf{T}}W_r(|h+r-t|)\)</span>，其对应的超平面由权重矩阵 <span class="math inline">\(W_r\)</span> 动态的控制，可能是一个球，也可能是压扁了的椭球，使得尽可能减少错误实体的条件下将所有正确的实体包含进去。</p><h3 id="从-特征加权-的角度">从 特征加权 的角度</h3><p>TransA 可视为加权变换特征。对于对称的权重矩阵 <span class="math inline">\(W_r\)</span> 。作者使用 <strong>LDL 分解</strong>，即： <span class="math display">\[\mathbf{W}_{\mathbf{r}  }=\mathbf{L}_{\mathbf{r} }^{\top} \mathbf{D}_{\mathbf{r} } \mathbf{L}_{\mathbf{r} }\]</span> <span class="math inline">\(\mathbf{L}_{\mathbf{r} }\)</span> 是一种变换矩阵，将 <span class="math inline">\(\mathbf{h}+\mathbf{r}-\mathbf{t}\)</span> 转换到其他空间，<span class="math inline">\(\mathbf{D}_{\mathbf{r}}=\operatorname{diag}\left(w_{1}, w_{2}, w_{3} \ldots\right)\)</span> 则是对角矩阵，<span class="math inline">\(w_{1}, w_{2}, w_{3}...\)</span> 即为对应每个维度的权重。得分函数可写作： <span class="math display">\[f_{r}=\left(\mathbf{L}_{\mathbf{r}}|\mathbf{h}+\mathbf{r}-\mathbf{t}|\right)^{\top} \mathbf{D}_{\mathbf{r}}\left(\mathbf{L}_{\mathbf{r}}|\mathbf{h}+\mathbf{r}-\mathbf{t}|\right)\]</span> 因为一个关系只能受到几个特定维度的影响，而其他维度则会产生噪音。现有的基于翻译的方法对不同的维度进行相同的处理，很难抑制噪声，从而产生不理想的性能。作者认为，不同的维度发挥着不同的作用，特别是当实体分布不同时。与现有方法不同，TransA 可以从数据中自动学习权重。这可以解释为什么 TransA 优于 TransR，尽管 TransA 和 TransR 都使用矩阵变换实体空间。</p><h3 id="training-algorithm">Training Algorithm</h3><p>依旧使用 margin-based ranking error。损失函数： <span class="math display">\[\begin{array}{ll}\min &amp; \sum_{(h, r, t) \in \Delta} \sum_{\left(h^{\prime}, r^{\prime}, t^{\prime}\right) \in \Delta^{\prime}}\left[f_{r}(h, t)+\gamma-f_{r^{\prime}}\left(h^{\prime}, t^{\prime}\right)\right]_{+}+ \\&amp; \lambda\left(\sum_{r \in R}\left\|\mathbf{W}_{\mathbf{r}}\right\|_{F}^{2}\right)+C\left(\sum_{e \in E}\|\mathbf{e}\|_{2}^{2}+\sum_{r \in R}\|\mathbf{r}\|_{2}^{2}\right) \\\text { s.t. } &amp; {\left[\mathbf{W}_{\mathbf{r}}\right]_{i j} \geq 0}\end{array}\]</span> <span class="math inline">\(\|\cdot\|_{F}\)</span> 是 F 范数。<span class="math inline">\(C\)</span> 控制缩放程度。 <span class="math inline">\(\lambda\)</span> 控制自适应权重矩阵的正则化。</p><p>为了减少参数量，达到与 TransE 相当的参数量，<span class="math inline">\(\mathbf{W}_{\mathbf{r} }\)</span> 由基于三元组的 embedding 计算得出： <span class="math display">\[\begin{aligned}\mathbf{W}_{\mathbf{r}} &amp;=-\sum_{(h, r, t) \in \Delta}\left(|\mathbf{h}+\mathbf{r}-\mathbf{t} \| \mathbf{h}+\mathbf{r}-\mathbf{t}|^{\top}\right) \\&amp;+\quad \sum_{\left(h^{\prime}, r^{r}, t^{\prime}\right) \in \Delta^{\prime}}\left(\left|\mathbf{h}^{\prime}+\mathbf{r}^{\prime}-\mathbf{t}^{\prime}\right|\left|\mathbf{h}^{\prime}+\mathbf{r}^{\prime}-\mathbf{t}^{\prime}\right|^{\top}\right)\end{aligned}\]</span></p><h2 id="experiments">Experiments</h2><h3 id="link-prediction">Link Prediction</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912105408028.png"  style="zoom: 50%;" /></p><p>从 表2 可以看出：</p><ol type="1"><li>TransA 性能真的显著。</li><li>在 FB15k 上表现得很好。因为 FB15k 一种非常多样化和复杂的实体/关系嵌入情况，因为它的 TPE(Triple number Per En- tity) 在所有数据集中是绝对最高的。这一比较表明 TransA 在各种复杂的嵌入环境中具有更大的优势。</li><li>TransA 在 WN18 数据集的平均排名中表现不佳。作者发现有27个测试三元组（占测试集的0.54%）的秩超过 30000，这几个案例将造成大约 162 个平均秩损失。所有这些三元组的尾部或头部实体从未与训练集中的对应关系同时出现。正是由于训练数据的不足导致了权重矩阵的过度扭曲，而过度扭曲的权重矩阵导致了较差的平均秩。</li></ol><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912105426462.png"  style="zoom:50%;" /></p><p>从 表3 可以看出：</p><ol type="1"><li>TransA 提升了 1-1 的性能，还提高了 1-N、N-1、N-N 关系的性能，这表明 TransA 在复杂关系嵌入方面效果更好。</li><li><p>与 TransR 相比，TransA 的性能更好，这意味着由绝对符引导的特征权重和广义度量形式具有显著的优势。</p></li><li><p>与没有加绝对值的自适应度量（PSD）进行了比较。验证出，TransA（加了绝对值）效果更好，因为采用了<strong>非负矩阵条件</strong>和<strong>绝对值</strong>的评分函数比采用 PSD 矩阵条件的评分函数更灵活</p></li></ol><h3 id="triples-classification">Triples Classification</h3><p>三元组分类任务的目的是预测给定的三元组 <span class="math inline">\((h,r,t)\)</span> 是否正确。对于三元组 <span class="math inline">\((h,r,t)\)</span> ，如果 <span class="math inline">\(f_r(h,t)\)</span> 低于阈值 <span class="math inline">\(\sigma_r\)</span>，然后为正；否则是否定的。阈值 <span class="math inline">\(\sigma_r\)</span> 在验证数据集上确定。最终的准确度取决于正确分类的三元组数量。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912105442904.png" style="zoom: 67%;" /></p><p>验证了：</p><ol type="1"><li>TransA 平均精度最高，验证了其有效性。</li><li>与自适应度量（PSD）相比，TransA 的性能更好，因为<strong>得分函数具有非负矩阵条件和绝对值运算符</strong>，比 PSD 矩阵条件更灵活。</li></ol><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210912134249329.png" style="zoom: 70%;" /></p><p>可以通过 LDL 分解计算出每个关系的权重。由于最小权重太小，无法进行显著分析，因此选择中位数来表示相对较小的权重，因此权重差异的计算：<span class="math inline">\(\left(\frac{\text { MaximalWeight-MedianWeight }}{\text { MedianWeight }}\right)\)</span>。权重差异越大，特征权重的影响越显著。</p><p>图中可以看到：精度随权重差异而变化，这意味着特征权重有利于精度。这证明了理论分析和 TransA 的有效性。</p><h2 id="summary">Summary</h2><p>总的来说，TransA 的创新只有一点：将三元组得分函数中的欧氏距离改为马氏（Mahalanobis）距离（即加权的欧式距离）。</p><div class="note note-info">            <p>这篇文章的创新点是改变了得分函数，然后发到了顶会上。有点震惊，想法很简单但是确实效果提升了很多。（很佩服!）从这篇文章本身可以学到几点：</p><ol type="1"><li><p>论文结构可以模仿。结构是中规中矩、简洁清晰的 “引言-相关工作-方法-实验-结论” 五段式结构。</p><ul><li>引言部分，针对自己方法，详细说明了传统欧氏距离方法的缺陷。</li></ul></li></ol><ul><li>相关工作将之前的工作分为“Translation-based”及其他两类，很严谨<ul><li>方法部分，因为对于指标做的小改进非常单薄，所以作者加上了 “Perspective from Equipotential Surfaces” 和 “Perspective from Feature Weighting” 两个角度的解释，使其看起来有理论支撑</li><li>实验部分，也是做了经典的链接预测和三元组分类两个实验，没有其他，但是在结果分析的时候分条解释的操作看起来很整齐</li><li>最后是结论</li></ul></li></ul><ol start="2" type="1"><li>有一些比较“聪明”的表述值得学习。比如由示意图解释 TransA 可以处理“一对多”关系，因为 TransA 的指标是对称的，所以也可以处理“多对一”关系，又，因为“多对多”关系可以被视为多个“一对一”关系，因此推断 TransA 也可以处理“多对多”关系，实验也证明了这一点。再比如，对于 TransA 在 WN18 的 Mean Rank 没有达到最优，也给出了合理的解释，是因为测试集中某些个别的被排在最后的样本影响了整体的平均值。</li></ol>          </div>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>TransA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TransD：Knowledge Graph Embedding via Dynamic Mapping Matrix</title>
    <link href="/2021/09/11/TransD%EF%BC%9AKnowledge%20Graph%20Embedding%20via%20Dynamic%20Mapping%20Matrix/"/>
    <url>/2021/09/11/TransD%EF%BC%9AKnowledge%20Graph%20Embedding%20via%20Dynamic%20Mapping%20Matrix/</url>
    
    <content type="html"><![CDATA[<h1 id="transdknowledge-graph-embedding-via-dynamic-mapping-matrix">TransD：Knowledge Graph Embedding via Dynamic Mapping Matrix</h1><p>本文是自动化所赵军、刘康老师团队发表在 ACL 2015 上的工作</p><h2 id="motivation">Motivation</h2><p>TransR 存在一些问题：</p><ol type="1"><li><p>对于特定的关系 <span class="math inline">\(r\)</span>，所有的实体都共享相同的映射矩阵 <span class="math inline">\(M_r\)</span>。然而，由关系链接的实体总是包含各种类型和属性。</p></li><li><p>投影是实体和关系之间的交互过程，映射矩阵只能由关系决定是不合理的。</p></li><li><p>矩阵向量乘法使其具有大量计算，并且当关系数大时，它还具有比 TransE 和 TransH 更多的参数。 由于复杂性，TransR / CTransR 难以应用于大规模知识图。</p></li></ol><h2 id="basic-idea">Basic Idea</h2><p>D 代表 Dynamic，是针对 TransR 参数量太大做的改进。主要思想是：<strong>实体和关系共同构建映射矩阵</strong>。具体地，每个实体和关系由两个向量（meaning vector 和 projection vector）表示，一个表示本身的 embedding，另一个用于构建映射矩阵。每个“实体-关系”对使用的映射矩阵是不同的，头尾实体单独投影。</p><h2 id="transd">TransD</h2><p>在 TransD 中，作者为每个实体和关系定义了两个向量。第一个向量表示实体或关系的含义，另一个向量（称为投影向量）表示如何将实体嵌入关系向量空间，并将其用于构造映射矩阵。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210911192901626.png" style="zoom: 67%;" /></p><p><span class="math inline">\(\mathbf{M}_{r h}, \mathbf{M}_{r t}\)</span> 分别是实体 <span class="math inline">\(h , t\)</span> 的映射矩阵，<span class="math inline">\(\mathbf{h}_{ip},\mathbf{t}_{ip}\)</span> 及关系 <span class="math inline">\(\mathbf{r}_{p}\)</span> 为投影向量，<span class="math inline">\(\mathbf{h}_{i\perp},\mathbf{t}_{i\perp}\)</span> 分别为头尾实体的投影向量。</p><p>对于一个三元组<span class="math inline">\((h,r,t)\)</span>，构建映射矩阵： <span class="math display">\[\begin{aligned}\mathbf{M}_{r h} &amp;=\mathbf{r}_{p} \mathbf{h}_{p}^{\top}+\mathbf{I}^{m \times n} \\\mathbf{M}_{r t} &amp;=\mathbf{r}_{p} \mathbf{t}_{p}^{\top}+\mathbf{I}^{m \times n}\end{aligned}\]</span> 映射矩阵由实体和关系决定，这种操作使得两个投影向量充分交互。</p><p>投影向量： <span class="math display">\[\mathbf{h}_{\perp}=\mathbf{M}_{r h} \mathbf{h}, \quad \mathbf{t}_{\perp}=\mathbf{M}_{r t} \mathbf{t}\]</span> 三元组得分函数： <span class="math display">\[f_{r}(\mathbf{h}, \mathbf{t})=-\left\|\mathbf{h}_{\perp}+\mathbf{r}-\mathbf{t}_{\perp}\right\|_{2}^{2}\]</span> 归一化约束： <span class="math display">\[\|\mathbf{h}\|_{2} \leq 1,\|\mathbf{t}\|_{2} \leq 1,\|\mathbf{r}\|_{2} \leq 1,\left\|\mathbf{h}_{\perp}\right\|_{2} \leq 1 \text { and }\left\|\mathbf{t}_{\perp}\right\|_{2} \leq1\]</span> 目标函数： <span class="math display">\[L=\sum_{\xi \in \Delta} \sum_{\xi^{\prime} \in \Delta^{\prime}}\left[\gamma+f_{r}\left(\xi^{\prime}\right)-f_{r}(\xi)\right]_{+}\]</span></p><h3 id="与-transetransh-和-transr-的关系">与 TransE、TransH 和 TransR 的关系</h3><ol type="1"><li><p>与 TransE 的关系</p><p>当实体、关系维度相同 且 所有的投影向量设为 0 时，退化为 TransE</p></li><li><p>与 TransH 的关系</p><p>当实体、关系维度相同时，TransD 的投影操作可展开为： <span class="math display">\[\begin{aligned}\mathbf{h}_{\perp} &amp;=\mathbf{M}_{r h} \mathbf{h}=\mathbf{h}+\mathbf{h}_{p}^{\top} \mathbf{h} \mathbf{r}_{p} \\\mathbf{t}_{\perp} &amp;=\mathbf{M}_{r t} \mathbf{t}=\mathbf{t}+\mathbf{t}_{p}^{\top} \mathbf{t r}_{p}\end{aligned}\]</span> 而 TransH 的投影操作为： <span class="math display">\[\begin{aligned}\mathbf{h}_{\perp}=\mathbf{h}-\mathbf{w}_{r}^{\top} \mathbf{h} \mathbf{w}_{r}\\\mathbf{t}_{\perp}=\mathbf{t}-\mathbf{w}_{r}^{\top} \mathbf{t} \mathbf{w}_{r}\end{aligned}\]</span> 由此可看到，TransH 中投影的方向只取决于 <span class="math inline">\(r\)</span>, 而在 TransD 中, 由 <span class="math inline">\(e\)</span> 和 <span class="math inline">\(r\)</span> 共同决定.</p></li><li><p>与 TransR 的关系</p><p>TransR 为每个关系定义一个投影矩阵 <span class="math inline">\(M_r\)</span>。而 TransD 通过为每个实体和关系设置投影向量，为每个三元组动态构建两个映射矩阵： <span class="math display">\[\begin{aligned}\mathbf{M}_{r h} &amp;=\mathbf{r}_{p} \mathbf{h}_{p}^{\top}+\mathbf{I}^{m \times n} \\\mathbf{M}_{r t} &amp;=\mathbf{r}_{p} \mathbf{t}_{p}^{\top}+\mathbf{I}^{m \times n}\end{aligned}\]</span> 投影向量为： <span class="math display">\[\begin{aligned}\mathbf{h}_{\perp} &amp;=\mathbf{M}_{r h} \mathbf{h}=\mathbf{h}_{p}^{\top} \mathbf{h} \mathbf{r}_{p}+\left[\mathbf{h}^{\top}, \mathbf{0}^{\top}\right]^{\top} \\\mathbf{t}_{\perp} &amp;=\mathbf{M}_{r t} \mathbf{t}=\mathbf{t}_{p}^{\top} \mathbf{t r}_{p}+\left[\mathbf{t}^{\top}, \mathbf{0}^{\top}\right]^{\top}\end{aligned}\]</span> 没有“矩阵-向量”相乘的操作，大大减少了参数量和计算量。据原文称，TransD 比 TransR 快约三倍。</p></li></ol><h2 id="experiments">Experiments</h2><h3 id="triplets-classification">Triplets Classification</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210911231051626.png" style="zoom: 67%;" /></p><ol type="1"><li>在WN11上，Trans 胜过包括 TransE、TransH和 TransR/CTransR 在内的所有其他先前模型，尤其是NTN（E）</li><li>在FB13上，TransD 的分类精度显著高于 TransE、TransH 和 TransR/CTransR，接近NTN（E）</li><li>在大多数情况下，“bern” 抽样法比 “unif” 抽样法效果更好。</li></ol><h3 id="link-prediction">Link Prediction</h3><p>链接预测是预测正确三元组 <span class="math inline">\((h，r，t)\)</span> 缺失的 h 或 t。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210911231634466.png" style="zoom: 50%;" /></p><p>从表4可以看出：</p><ol type="1"><li><p>TransD 优于其他 baseline 嵌入模型（TransE、TransH 和 TransR/CTransR），</p></li><li>与 CTransR 相比，TransD 是一个更细粒度的模型，它<strong>同时考虑了多种类型的实体和关系</strong>，并且获得了更好的性能。结果表明，TransD 比 CTransR 更好地处理知识图中实体和关系的复杂内部关联</li><li><p>“bern” 抽样法比 “unif” 抽样法减少假阴性标签。</p></li></ol><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210911231709384.png" style="zoom:50%;" /></p><p>表5 在 FB15k 上，显示了有关 关系的映射性质 的详细结果。结果验证了 TransD 的有效性。说明：</p><p>知识图谱中实体和关系的多样性是一个重要因素，动态映射矩阵适合于知识图的建模。</p><h2 id="summary">Summary</h2><ol type="1"><li>作者构建了一个新颖的模型 TransD，通过<strong>同时考虑实体和关系的多样性</strong>，为每一个实体-关系构建<strong>动态映射矩阵</strong>。它为实体表示映射到关系向量空间提供灵活的样式。</li><li>与 TransR / CTransR 相比，TransD 具有更少的参数并且没有矩阵向量乘法</li><li>在实验中，作者的方法优于之前的模型。</li></ol>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>TransD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS224n 03 神经网络</title>
    <link href="/2021/09/07/CS224n%2003%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/07/CS224n%2003%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="神经网络">神经网络</h2><p>线性分类能力有限，不能处理复杂的分类。（因为它只能在空间上画一条直线）,而神经网络则可以处理复杂的数据分布。</p><p>一个神经网络往往由多个隐藏层构成～</p><figure><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210909214118075.png" alt="image-20210909214118075" /><figcaption>image-20210909214118075</figcaption></figure><p>（第一层是输入层，不进行计算，其他的隐藏层+输出层都是进行计算的）</p><p>对于一层来说：</p><figure><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910061206461.png" alt="image-20210910061206461" /><figcaption>image-20210910061206461</figcaption></figure><p>为什么要引入非线形呢？或者说为什么需要激活函数/非线性化？</p><figure><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910061242840.png" alt="image-20210910061242840" /><figcaption>image-20210910061242840</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>CS224n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS224n 02 GloVe</title>
    <link href="/2021/08/29/CS224n%2002%20GloVe/"/>
    <url>/2021/08/29/CS224n%2002%20GloVe/</url>
    
    <content type="html"><![CDATA[<h1 id="cs224n-02-glove">CS224n 02 GloVe</h1><p>上一讲 <a href="https://stuxiaozhang.github.io/2021/07/29/CS224n%2001%20Introduction%20and%20Word%20Vectors/">CS224n 01 Introduction and Word Vectors.</a> 主要介绍了Word2Vec模型，它是一种基于 local context window 的 direct prediction 预测模型，对于学习 word vector，还有另一类模型是 count based global matrix factorization，这一讲主要介绍了后一类模型以及 Manning 教授组结合两者优点提出的 <strong>GloVe 模型</strong>。</p><h2 id="基于共现矩阵的词向量-vs.-word2vec词向量">基于共现矩阵的词向量 vs. Word2Vec词向量</h2><p>回顾一下 Word2Vec 的思想：</p><center>让相邻的词的向量表示相似。</center><p>实际上还有一种更加简单的思路——使用<strong>词语共现性</strong>，来构建词向量，也可以达到这样的目的。即，我们直接统计哪些词是经常一起出现的，那么这些词肯定就是相似的。那么，每一个词，都可以做一个这样的统计，得到一个共现矩阵。 这里直接贴一个 CS224n 上的例子：</p><ul><li>I like deep learning.</li><li>I like NLP.</li><li>I enjoy flying.</li></ul><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210829203506781.png"  style="zoom: 50%;" /></p><p>上面的例子中，给出了三句话，假设这就是我们全部的语料。我们使用一个size=1的窗口，对每句话依次进行滑动，相当于只统计紧邻的词。这样就可以得到一个共现矩阵。</p><p>共现矩阵的每一列，自然可以当做这个词的一个向量表示。这样的表示明显优于one-hot表示，因为它的每一维都有含义——共现次数，因此这样的向量表示可以求词语之间的相似度。</p><p>然后这样表示还有有一些问题：</p><ul><li>维度 = 词汇量大小，还是太大了；</li><li>还是太过于稀疏，在做下游任务的时候依然不够方便。</li></ul><p>但是，维度问题，我们有解决方法——<strong>SVD矩阵分解</strong>！ 我们将巨大的共现矩阵进行SVD分解后，只选取最重要的几个特征值，得到每一个词的低维表示。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210831200135983.png" style="zoom: 60%;" /></p><p>图中的 A 在我们的场景中就是共现矩阵，<span class="math inline">\(U、\Sigma、V\)</span>就是分解出的三个矩阵。我们只<strong>选择 U 矩阵的前 r 维来作为词的向量表示</strong>。</p><p>上述的过程使用python编程十分简单，这里也是直接引用cs224n课程中的例子：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210831200549707.png" style="zoom: 67%;" /></p><p>可见，即使这么简单的三句话构建的语料，我们通过构建共现矩阵、进行SVD降维、可视化，依然呈现出了类似Word2Vec的效果。</p><p>但是，由于共现矩阵巨大，SVD分解的计算代价也是很大的。另外，像a、the、is这种词，与其他词共现的次数太多，也会很影响效果。所以，我们需要使用很多技巧，来改善这样的词向量。例如，直接把一些常见且意义不大的词忽略掉；把极度不平衡的计数压缩到一个范围；使用皮尔森相关系数，来代替共现次数等等很多技巧。</p><p>上面的介绍中，我们发现基于共现矩阵的词向量，也可以表现出很多优秀的性质，它也可以得到一个低维的向量表示，进行相似度的计算，甚至也可以做一定的推理（即存在man to king is like women to queen这样的关系）。 但是，它主要的问题在于两方面：</p><ol type="1"><li>SVD要分解一个巨型的稀疏矩阵（共现矩阵），计算开销大，甚至无法计算；</li><li>需要进行复杂麻烦的预处理，例如计数的规范化、清除常见词、使用皮尔森系数等等。</li></ol><p>而 <strong>Word2Vec</strong> 的算法，<strong>不需要一次性处理这么大量的数据</strong>，而是通过<strong>迭代</strong>的方式，一批一批地进行处理，不断迭代词向量参数，使得我们可以处理海量的语料，构建十分稳健的词向量。所以在实验中，Word2Vec 的表现，一般都要优于传统的SVD类方法。</p><p>但是，<strong>基于共现矩阵的方法也有其优势</strong>，那就是<strong>充分利用了全局的统计信息</strong>。因为我们进行矩阵分解，是对整个共现矩阵进行分解，这个矩阵中包含着全局的信息。而 Word2Vec 由于是一个窗口一个窗口（或几个窗口）地进行参数的更新，所以学到的词向量更多的是局部的信息。</p><p>总之，二者各有优劣，这启发了斯坦福的一群研究者，GloVe 词向量就是在这样的动机下产生的。</p><h2 id="glove-是如何实现的">GloVe 是如何实现的？</h2><p>GloVe 的实现分为以下三步：</p><ol type="1"><li><p>根据语料库（corpus）构建一个共现矩阵（Co-ocurrence Matrix）X，<strong>矩阵中的每一个元素 <span class="math inline">\(X_{ij}\)</span> 代表单词 <span class="math inline">\(i\)</span> 和上下文单词 <span class="math inline">\(j\)</span> 在特定大小的上下文窗口（context window）内共同出现的次数。</strong>一般而言，这个次数的最小单位是 1，但是 GloVe 不这么认为：它根据两个单词在上下文窗口的距离 <span class="math inline">\(d\)</span>，提出了一个衰减函数（decreasing weighting）：<span class="math inline">\(decay=1/d\)</span> 用于计算权重，也就是说<strong>距离越远的两个单词所占总计数（total count）的权重越小</strong>。</p><blockquote><p><strong>共现count矩阵：</strong>里面的数值都是出现的次数，即 count，具体步骤如下：</p><ol type="1"><li>首先构建一个空矩阵，大小为 <span class="math inline">\(V\)</span>，即词汇表*词汇表，值全为空</li><li>确定一个滑动窗口的大小，比如：5</li><li>从语料库的第一个单词开始，滑动该窗口</li><li>因为是按照语料库的顺序开始的，所以中心词为到达的那个单词：<span class="math inline">\(i\)</span></li><li>上下文词为以中心词 <span class="math inline">\(i\)</span> 为滑动窗口的中心，两边的单词，为上下文词：<span class="math inline">\(j_1, j_2,…,j_m\)</span>（假如有m个j）</li><li>若窗口左右无单词，一般出现在语料库的首尾，则空着，不需要统计</li><li>在窗口内，统计上下文词j出现的次数，添在矩阵中</li><li>滑动过程中，不断将统计的信息添加在矩阵中，即可得到共现矩阵</li></ol></blockquote></li><li><p>构建词向量（Word Vector）和共现矩阵（Co-ocurrence Matrix）之间的近似关系，论文的作者提出以下的公式可以近似地表达两者之间的关系： <span class="math display">\[w_{i}^{T}\tilde{w_{j}} + b_i + \tilde{b_j} = \log(X_{ij}) \tag{1}\]</span> 其中，<strong><span class="math inline">\(w_i^T\)</span> 和 <span class="math inline">\(\tilde w_j\)</span> 是我们最终要求解的词向量；</strong><span class="math inline">\(b_i\)</span> 和 <span class="math inline">\(\tilde b_j\)</span> 分别是两个词向量的 bias term；</p><p>为什么要使用这个公式，为什么要构造两个词向量 <span class="math inline">\(w_i^T\)</span> 和 <span class="math inline">\(\tilde w_j\)</span>？下文会详细介绍。</p></li><li><p>有了公式1之后我们就可以构造它的 loss function： <span class="math display">\[J=\sum_{i, j=1}^{V} f\left(X_{i j}\right)\left(w_{i}^{T} \tilde{w}_{j}+b_{i}+\tilde{b_{j}}-\log \left(X_{i j}\right)\right)^{2}\]</span> 这个 loss function 的基本形式就是最简单的 mean square loss，只不过在此基础上加了一个权重函数 <span class="math inline">\(f(X_{ij})\)</span>，那么这个函数起了什么作用，为什么要添加这个函数呢？我们知道在一个语料库中，肯定存在很多单词他们在一起出现的次数是很多的（frequent co-occurrences），那么我们希望：</p><ol type="1"><li>这些单词的权重要大于那些很少在一起出现的单词（rare co-occurrences），所以这个函数要是非递减函数（non-decreasing）</li><li>但我们也不希望这个权重过大（overweighted），当到达一定程度之后应该不再增加</li><li>如果两个单词没有在一起出现，也就是 <span class="math inline">\(X_{ij}=0\)</span>，那么他们应该不参与到 loss function 的计算当中去，也就是 <span class="math inline">\(f(x)\)</span> 要满足 <span class="math inline">\(f(0)=0\)</span></li></ol><p>满足以上两个条件的函数有很多，作者采用了如下形式的分段函数： $$ f(x)=<span class="math display">\[\begin{equation}\begin{cases}(x/x_{max})^{\alpha}  &amp; \text{if} \ x &lt; x_{max} \\1 &amp; \text{otherwise}\end{cases}\end{equation}\]</span>  $$ 这个函数图像如下所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210831131845208.png"  style="zoom:67%;" /></p></li></ol><p>这篇论文中的所有实验，α 的取值都是 0.75，而 <span class="math inline">\(x_{max}\)</span> 取值都是100。以上就是 GloVe 的实现细节，那么 GloVe 是如何训练的呢？</p><h2 id="glove-是如何训练的">GloVe 是如何训练的？</h2><p>虽然很多人称 GloVe 是一种无监督（unsupervised learing）的学习方式（因为它确实不需要人工标注label），但其实它还是有 label 的，这个 label 就是公式2中的 <span class="math inline">\(\log(X_{ij})\)</span>，而公式2中的向量 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(\tilde{w}\)</span> 就是要不断更新/学习的参数，所以本质上它的训练方式跟监督学习的训练方法没什么不一样，都是基于梯度下降的。</p><p>具体地，这篇论文里的实验是这么做的：<strong>采用了 AdaGrad 的梯度下降算法，对矩阵 <span class="math inline">\(X\)</span> 中的所有非零元素进行随机采样，学习曲率（learning rate）设为0.05，在 vector size 小于300的情况下迭代了50次，其他大小的 vectors 上迭代了100次，直至收敛。</strong>最终学习得到的是两个 vector 是 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(\tilde{w}\)</span>，因为 <span class="math inline">\(X\)</span> 是对称的（symmetric），所以从原理上讲 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(\tilde{w}\)</span> 是也是对称的，他们唯一的区别是初始化的值不一样，而导致最终的值不一样。所以这两者其实是等价的，都可以当成最终的结果来使用。<strong>但是为了提高鲁棒性，我们最终会选择两者之和作为最终的 vector（两者的初始化不同相当于加了不同的随机噪声，所以能提高鲁棒性）。</strong>在训练了400亿个token组成的语料后，得到的实验结果如下图所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210831132316240.png"  style="zoom:67%;" /></p><p>这个图一共采用了三个指标：语义准确度，语法准确度以及总体准确度。那么我们不难发现 Vector Dimension 在300时能达到最佳，而 context Windows size 大致在6到10之间。</p><h2 id="glove-与-lsaword2vec-的比较">Glove 与 LSA、word2vec 的比较</h2><h3 id="glove-与-lsa-比较">Glove 与 LSA 比较：</h3><ul><li>两者都是基于共现矩阵在操作</li><li>LSA（Latent Semantic Analysis）可以基于 co-occurance matrix 构建词向量，实质上是基于全局语料采用 SVD 进行矩阵分解，然而 SVD 计算复杂度高，计算代价比较大。还有一点是它对所有单词的统计权重都是一致的。</li><li>Glove 没有直接利用共现矩阵，而是通过 ratio 的特性，将词向量和 ratio 联系起来，建立损失函数，采用 Adagrad 对最小平方损失进行优化（可看作是对 LSA 一种优化的高效矩阵分解算法）</li></ul><h3 id="glove-与-word2vec-比较">Glove 与 Word2vec 比较：</h3><ul><li>Word2vec 是局部语料库训练的，其特征提取是基于滑窗的；而 Glove 的滑窗是为了构建 co-occurance matrix（上面详细描述了窗口滑动的过程），统计了全部语料库里在固定窗口内的词共线的频次，是基于全局语料的，可见 Glove 需要事先统计共现概率；因此，Word2vec 可以进行在线学习，Glove 则需要统计固定语料信息。</li><li>Word2vec 是无监督学习。Glove 通常被认为是无监督学习，但实际上 Glove 还是有 label 的，在统计共现矩阵信息的时候，需要对语料进行标注，即共现次数 <span class="math inline">\(log(X_i,j)\)</span></li><li>Word2vec 损失函数实质上是带权重的交叉熵，权重固定；Glove 的损失函数是最小平方损失函数，权重可以做映射变换。</li><li>Glove利用了全局信息，使其在训练时收敛更快，训练周期较word2vec较短且效果更好。</li></ul><p>虽然 GloVe 的作者在原论文中说 GloVe 结合了 SVD 与 Word2Vec 的优势，训练速度快并且在各项任务中性能优于 Word2Vec，但是我们应该持有怀疑的态度看待这一结果，可能作者在比较结果时对于 GloVe 模型参数选择较为精细而 Word2Vec 参数较为粗糙导致 GloVe 性能较好，或者换另一个数据集，改换样本数量，两者的性能又会有不同。实际上，在另一篇论文 <a href="https://link.zhihu.com/?target=http%3A//www.aclweb.org/anthology/D15-1036">Evaluation methods for unsupervised word embeddings</a> 中基于各种 intrinsic 和 extrinsic 任务的性能比较中，Word2Vec 结果要优于或不亚于 GloVe。实际应用中也是 Word2Vec 被采用的更多，对于新的任务，不妨对各种 embedding 方法都做尝试，选择合适自己问题的方法。</p><h2 id="公式推导">公式推导</h2><blockquote><p>一个疑惑就是公式1到底是怎么来. 即使记录了下面的推导我还是很糊涂emm</p></blockquote><p>先定义一些变量：</p><ul><li>对于共现矩阵 <span class="math inline">\(X\)</span>，<span class="math inline">\(X_{ij}\)</span> 代表了单词 <span class="math inline">\(j\)</span> 出现在单词 <span class="math inline">\(i\)</span> 的上下文中的次数</li><li><span class="math inline">\(X_i\)</span> 代表单词 <span class="math inline">\(i\)</span> 的上下文中所有单词出现的总次数，即 <span class="math inline">\(X_{i}=\sum_{k} X_{i k}\)</span></li><li><span class="math inline">\(P_{i j}=P(j \mid i)=X_{i j} / X_{i}\)</span> ，代表单词 <span class="math inline">\(j\)</span> 出现在单词 <span class="math inline">\(i\)</span> 上下文中的概率。</li></ul><p>有了这些定义之后，我们来看一个表格：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210831143340274.png" style="zoom: 67%;" /></p><p>理解这个表格的重点在最后一行，它表示的是两个概率的比值（ratio），<strong>我们可以使用它观察出两个单词 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 相对于单词 <span class="math inline">\(k\)</span> 哪个更相关（relevant）。</strong>比如，ice 和 solid 更相关，而 stream 和 solid 明显不相关，于是我们会发现 <span class="math inline">\(P(solid|ice)/P(solid|steam)\)</span> 比1大更多。同样的 gas 和 steam 更相关，而和 ice 不相关，那么 <span class="math inline">\(P(gas|ice)/P(gas|steam)\)</span> 就远小于1；当都有关（比如water）或者都没有关(fashion)的时候，两者的比例接近于1；这个是很直观的。因此，<strong>以上推断可以说明通过概率的比例而不是概率本身去学习词向量可能是一个更恰当的方法</strong>，因此下文所有内容都围绕这一点展开。</p><p>于是为了捕捉上面提到的概率比例，我们可以构造如下函数： <span class="math display">\[F(w_i,w_j,\tilde{w_k}) = \frac{P_{ik}}{P_{jk}},\tag{4}\]</span> 其中，函数 F 的参数和具体形式未定，它有三个参数 <span class="math inline">\(w_i,w_j\)</span> 和 <span class="math inline">\(\tilde{w_k}\)</span>， <span class="math inline">\(w\)</span> 表示的是一个词向量，<span class="math inline">\(\tilde{w_k}\)</span> 表示其在 context_windows内的某个词。显然我们希望这个 F 能表示上述比率的关系。 因为向量空间是线性结构的，所以要表达出两个概率的比例差，最简单的办法是作差，于是我们得到： <span class="math display">\[F(w_i-w_j,\tilde{w_k}) = \frac{P_{ik}}{P_{jk}},\tag{5}\]</span> 使其仅仅依赖两目标向量的不同之处。这时我们发现公式5的右侧是一个数量，而左侧则是一个向量，为了保证 F 是个线性结构，于是我们把左侧转换成两个向量的内积形式： <span class="math display">\[F((w_i-w_j)^T \tilde{w_k}) = \frac{P_{ik}}{P_{jk}},\tag{6}\]</span> 这样就避免了过多的维度计算，回归到简单的线性关系。</p><p>我们注意到 <span class="math inline">\(w_i\)</span> 到 <span class="math inline">\(w_j\)</span> 的距离与 <span class="math inline">\(w_j\)</span> 到 <span class="math inline">\(w_i\)</span> 的距离是相等的，并且共现矩阵是一个对称的矩阵，即 <span class="math inline">\(X^T==X\)</span>，我们把 <span class="math inline">\(w_i\)</span> 称为主单词， <span class="math inline">\(\tilde w\)</span> 称为 <span class="math inline">\(w_i\)</span> 的上下文的某个单词，从某种角度看， <span class="math inline">\(w_i\)</span> 与 <span class="math inline">\(\tilde w\)</span> 的角色是可以互换的，它们的地位是相等的，那么我们就希望模型 F 能隐含这种特性。再看看上式： <span class="math display">\[F((w_{i}-w_{j})^{T}*{\tilde{w}_{k}}) = \frac{P_{ik}}{P_{jk}}\neq \frac{P_{ki}}{P_{kj}}\]</span> 于是论文中这样做的： <span class="math display">\[F((w_{i}-w_{j})^{T}*{\tilde{w}_{k}}) ＝ \frac{F(w_i^T\tilde{w}_{k})}{F(w_j^T\tilde{w}_{k})}== \frac{F(\tilde{w}_{k}^Tw_i)}{F(\tilde{w}_{k}^Tw_j)}\]</span> 上式中 <span class="math display">\[F((w_{i}-w_{j})^{T}*{\tilde{w}_{k}}) ＝F(w_i^T*\tilde{w}_{k}-w_j^T*\tilde{w}_{k}) =\frac{F(w_i^T\tilde{w}_{k})}{F(w_j^T\tilde{w}_{k})}\]</span> 显然 <span class="math inline">\(exp\)</span> 函数具有这个特性，再有： <span class="math display">\[F(w_i^T \tilde{w_k}) = P_{ik} = \frac{X_{ik}}{X_i},\tag{8}\]</span> 于是我们有： <span class="math display">\[w_i^T \tilde{w_k} = \log(P_{ik}) = \log(X_{ik}) – \log({X_i}),\tag{9}\]</span> 此时，我们发现因为等号右侧的 $log⁡(X_i) $ 的存在，公式9是不满足对称性（symmetry）的，而且这个 $log⁡(X_i) $ 其实是跟 <span class="math inline">\(k\)</span> 独立的，它只跟 <span class="math inline">\(i\)</span> 有关，于是我们可以针对 <span class="math inline">\(w_i\)</span> 增加一个 bias term <span class="math inline">\(b_i\)</span> 把它替换掉，于是我们有： <span class="math display">\[w_i^T \tilde{w_k} + b_i= \log(X_{ik}), \tag{10}\]</span> 但是公式10还是不满足对称性，于是我们针对 <span class="math inline">\(w_k\)</span> 增加一个bias term <span class="math inline">\(b_k\)</span>，从而得到公式1的形式：</p><p><span class="math display">\[w_i^T \tilde{w_k} + b_i + b_k= \log(X_{ik}), \tag{1}\]</span> 以上内容其实不能完全称之为推导，因为有很多不严谨的地方，只能说是解释作者如何一步一步构造出这个公式的，仅此而已。</p>]]></content>
    
    
    <categories>
      
      <category>CS224n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>GloVe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TransR：Learning Entity and Relation Embeddings for Knowledge Graph Completion</title>
    <link href="/2021/08/22/TransR%EF%BC%9ALearning%20Entity%20and%20Relation%20Embeddings%20for%20Knowledge%20Graph/"/>
    <url>/2021/08/22/TransR%EF%BC%9ALearning%20Entity%20and%20Relation%20Embeddings%20for%20Knowledge%20Graph/</url>
    
    <content type="html"><![CDATA[<h1 id="transrlearning-entity-and-relation-embeddings-for-knowledge-graph-completion">TransR：Learning Entity and Relation Embeddings for Knowledge Graph Completion</h1><p>TransH 在 TransE 基础上做出改进，提出<strong>超平面</strong>的想法解决了同一实体的多关系问题，提高了知识表示的效果，在一定程度上解决了复杂关系的处理。然而 TransH 也存在一定的问题。作者发现 TransH 模型虽然有效的处理了复杂语义关系表示，但两个实体仍然处于相同的语义空间，因此不能够充分表示实体与关系的语义联系。于是提出了 TransR 使实体和关系处于不同的空间，验证了其能达到不错的效果。</p><h2 id="basic-idea">Basic Idea</h2><p><strong>TransE 和 TransH 都假设实体和关系嵌入在同一个空间 <span class="math inline">\(R^k\)</span> 中。</strong>他们都假设实体和关系是语义空间中的向量，因此相似的实体在同一实体空间中会非常接近。然而，每个实体可以有许多属性，不同的关系关注实体的不同属性。关系和实体是完全不同的对象，在同一个语义空间中可能不足以表示它们。虽然 TransH 使用关系超平面扩展了建模的灵活性, 但它并没有完全打破这种假设。为了解决这个问题，作者让 TransR 在两个不同的空间，即<strong>实体空间</strong>和<strong>多个关系空间</strong>(关系特定的实体空间)中建模实体和关系，并在对应的关系空间 relation space 中进行转换，因此命名为 TransR。</p><blockquote><p>TransR 认为不同的关系拥有不同的语义空间。对每个三元组，首先应将实体投影到对应的关系空间中，然后再建立从头实体到尾实体的平移关系来建模头尾实体在该关系空间中的关联性。</p><p>e.g. 虽然 ‘‘奥巴马’’ 和 ‘‘乔治·布什’’ 这 样的实体在实体空间中可能彼此相距很远，但它们在某些特定关系（如总统）的 空间中是相似且彼此接近的；同样地，对于 ‘‘北京’’ 和 ‘‘上海’’ 这样的实体在实体 空间中可能彼此〸分接近，但它们在某些特定关系（如首都）的空间中是极其不 相似且相距很远的。</p></blockquote><p>TransR 的创新点是将 TransH 的投影到超平面更进一步——投影到空间，<strong>本质是将投影向量换为投影矩阵</strong>，实体还是用一个向量表示，关系用一个向量和一个矩阵表示。效果提升并不大，但计算量显著增大。</p><h2 id="method">Method</h2><p>对于每个三元组 <span class="math inline">\((h,r,t)\)</span>，首先根据当前的关系 <span class="math inline">\(r\)</span> 将头尾实体分别映射到关系空间中 <span class="math inline">\(h_r, t_r\)</span>，然后在关系空间中建模 <span class="math inline">\(h_{r}+r \approx t_{r}\)</span></p><p><strong>特定的关系投影（彩色的圆圈表示）能够使得头/尾实体在这个关系下真实的靠近彼此，使得不具有此关系（彩色的三角形表示）的实体彼此远离。</strong></p><blockquote><p>此外，在特定关系下，头尾实体对通常表现出不同的模式，因此不能单纯的将关系直接与实体对进行操作。根据分段线性回归的思想，我们通过将不同的头尾实体对 聚类到组中,并学习每个组的不同关系向量来扩展 TransR，称为基于聚类的 TransR（CTransR）。</p></blockquote><h3 id="transr">TransR</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820195325259.png" style="zoom:50%;" /></p><p>在 TransR 中，对于每个三元组 <span class="math inline">\((h,r,t)\)</span>，实体嵌入被设置为 <span class="math inline">\(\mathbf{h}, \mathbf{t} \in \mathbb{R}^{k}\)</span> 和关系嵌入设置为 <span class="math inline">\(\mathbf{r} \in \mathbb{R}^{d}\)</span>。注意，实体嵌入和关系嵌入的维度不一定相同，即 <span class="math inline">\(k \ne d\)</span>。对于每个关系 <span class="math inline">\(r\)</span>，设置一个投影矩阵 <span class="math inline">\(\mathbf{M}_r\in \mathbb{R}^{k \times d}\)</span>，可以将实体从实体空间投影到关系空间。通过映射矩阵，我们将实体的投影向量定义为： <span class="math display">\[\mathbf{h}_{r}=\mathbf{h} \mathbf{M}_{r}, \quad \mathbf{t}_{r}=\mathbf{t} \mathbf{M}_{r}\]</span> 得分函数定义为： <span class="math display">\[f_{r}(h, t)=\left\|\mathbf{h}_{r}+\mathbf{r}-\mathbf{t}_{r}\right\|_{2}^{2}\]</span> 同时对嵌入向量 <span class="math inline">\(h,r,t\)</span> 和映射矩阵用范数做限制： <span class="math display">\[\|\mathbf{h}\|_{2} \leq 1,\|\mathbf{r}\|_{2} \leq 1,\|\mathbf{t}\|_{2} \leq 1,\left\|\mathbf{h} \mathbf{M}_{\mathbf{r}}\right\|_{2} \leq 1,\left\|\mathbf{t} \mathbf{M}_{\mathbf{r}}\right\|_{2} \leq 1\]</span></p><blockquote><p>我觉得这个 ”relation space for r“ 应该是关系特定的实体空间。</p></blockquote><h3 id="ctransr">CTransR</h3><p>TransE、TransH 包括 TransR，为每个关系学习一个唯一的向量，该向量可能无法代表该关系下的所有实体对，因为这些关系通常是相当多样的。为了更好地模拟这些关系，引入了分段线性回归（piecewise linear regression）的思想来扩展 TransR。</p><p>基本思想是：</p><ol type="1"><li>首先将输入实例分为几个组。形式上，对于一个特定的关系 <span class="math inline">\(r\)</span>，训练数据中的所有实体对 <span class="math inline">\((h,t)\)</span> 都被聚集到多个簇 cluster 中，每个 簇 cluster 中的实体对都被期望与关系 <span class="math inline">\(r\)</span> 有关。所有实体对 <span class="math inline">\((h,t)\)</span> 都用它们的向量偏移量 <span class="math inline">\((h-t)\)</span> 表示，用于聚类，其中 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(t\)</span> 通过 TransE 获得。</li><li>然后，分别为每个簇学习一个单独的关系向量 <span class="math inline">\(\mathbf{r}_{c}\)</span> 和每个关系学习一个矩阵 <span class="math inline">\(\mathbf{M}_{r}\)</span>。然后将每个簇中的头实体和尾实体映射到对应关系空间中: <span class="math inline">\(\mathbf{h}_{r, c}=\mathbf{h} \mathbf{M}_{r}\)</span> 和 <span class="math inline">\(\mathbf{t}_{r, c}=\mathbf{t} \mathbf{M}_{r}\)</span>，得分函数定义为：</li></ol><p><span class="math display">\[f_{r}(h, t)=\left\|\mathbf{h}_{r, c}+\mathbf{r}_{c}-\mathbf{t}_{r, c}\right\|_{2}^{2}+\alpha\left\|\mathbf{r}_{c}-\mathbf{r}\right\|_{2}^{2}\]</span></p><p>其中，<span class="math inline">\(||\mathbf{r}_{c}-\mathbf{r}\|_{2}^{2}\)</span> 目的是确保特定于集群的关系向量 <span class="math inline">\(\mathbf{r}_{c}\)</span> 不会离原始关系向量 <span class="math inline">\(\mathbf{r}\)</span> 太远，<span class="math inline">\(α\)</span> 控制该约束的效果。此外，和 TransR 一样，CTransR 也对嵌入 <span class="math inline">\(h、r、t\)</span> 和映射矩阵的范数施加约束。</p><p><strong>TransR 和 CTransR 的区别在于两者的关系空间不同，前者只有一个关系空间，亦即对所有的关系都在同一个空间中；后者则是根据不同的关系，对属于同一个关系的所有实体对聚集在一个簇中，每个关系代表不同的空间</strong>。</p><h3 id="loss-function">Loss Function</h3><p>margin-based score function： <span class="math display">\[L=\sum_{(h, r, t) \in S} \sum_{\left(h^{\prime}, r, t^{\prime}\right) \in S^{\prime}} \max \left(0, f_{r}(h, t)+\gamma-f_{r}\left(h^{\prime}, t^{\prime}\right)\right)\]</span> 其中，<span class="math inline">\(max(x，y)\)</span> 旨在获得 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 之间的最大值，<span class="math inline">\(γ\)</span> 是 margin，<span class="math inline">\(S\)</span> 是正确三元组的集合，<span class="math inline">\(S&#39;\)</span> 是错误三元组的集合</p><p>现有的知识图谱只包含正确的三元组。损坏正确的三元组的常规操作(TransH)是替换头实体或尾实体来构造不正确的三元组。当破坏三重实体时，按照 TransH 为头/尾实体替换分配不同的概率。对于那些 1-to-N、N-to-1 和 N-to-N 关系，通过给予更多的机会来替换“一”方，将减少产生 False Negative 实例的机会。在实验中，将传统的抽样方法表示为“unif”，而在（Wang et al.2014）中的新方法表示为“bern”。TransR 和 CTransR 的学习过程使用随机梯度下降（SGD）进行。为了避免过度拟合，我们使用 TransE 的结果初始化实体和关系嵌入，并将关系矩阵初始化为单位矩阵。</p><blockquote><p>TransR 与 TransH 的训练策略和负样本的构建是一样的。</p></blockquote><h2 id="experiments">Experiments</h2><p>在本文中，我们使用了来自 WordNet 的两个数据集，即 WN18 和 WN11。还使用了来自 Freebase 的两个数据集，即 FB15K 和 FB13。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820221606208.png" style="zoom:50%;" /></p><h3 id="link-prediction">Link Prediction</h3><p>链接预测旨在预测关系事实三元组 <span class="math inline">\((h,r,t)\)</span> 中缺失的 <span class="math inline">\(h\)</span> 或 <span class="math inline">\(t\)</span>。在这个任务中，对于缺失实体的每个位置，系统被要求从知识图谱中对一组候选实体进行排序，而不是只给出一个最佳结果。在测试阶段，对于每个测试三元组，用知识图谱中的所有实体替换头部/尾部实体，并按照得分函数 <span class="math inline">\(f_r\)</span> 计算的相似性分数降序排列这些实体。接下来，用两个度量作为评估指标：（1）正确实体的平均等级 Mean Rank；（2）前10名实体中正确实体的比例 Hits@10 。 一个好的 link predictor 应该达到更低的 Mean Rank 或 更高的 Hits@10。然而，在替换实体时，可能会出现替换后还正确的三元组，因为是正确的所以排名会较高。因此，在进行排名之前，可以过滤掉出现的这些损坏但正确的三元组。我们将第一个评估设置命名为“Raw”，后一个命名为“Filter”。</p><blockquote><p>TransE、TransH 都是这么做的。</p></blockquote><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820223659727.png"  /></p><p>WN18 和 FB15K 的评估结果如表2所示。从表中我们观察到：</p><ol type="1"><li>TransR 和 CTransR 显著且一致地优于其他 baseline，包括 TransE 和 TransH。这表明 TransR 在模型复杂性和表达能力之间找到了一个更好的平衡点</li><li>CTransR 的性能优于 TransR，这表明应该建立细粒度模型来处理每种关系类型下的复杂内部相关性。CTransR是一项初步探索，作者今后的工作将是为此目的建立更复杂的模型</li><li>“bern”采样技巧对 TransH 和 TransR 都很有效，特别是在关系类型更多的FB15K上。</li></ol><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820224054136.png" /></p><p>在表3中，通过映射 FB15K 上关系1的属性显示了单独的评估结果。我们可以看到：</p><ol type="1"><li>TransR在所有关系映射类别上都取得了巨大的改进，特别是当预测“1对1”关系时，这表明 TransR 为实体和关系及其复杂关联提供了更精确的表示</li><li>预测“1-to-N”和“N-to-1”关系的1，这展现了 TransR 通过关系特定投影区分相关实体和无关实体的能力。</li></ol><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820224456357.png" alt="image-20210820224456357" style="zoom:50%;" /></p><p>表4给出了 FB15K 训练三元组中“位置包含”关系的一些聚类示例。显然，通过聚类可以学习到更精确、更细粒度的关系嵌入，这有助于进一步提高知识图谱完成的性能。</p><h3 id="triple-classification">Triple Classification</h3><p>三元组分类的目的是判断给定的三元组是否正确。这是一项二分类任务。本任务使用三个数据集WN11、FB13 和 FB15K</p><p>对于三元组分类，我们设置了一个特定于关系的阈值 <span class="math inline">\(δ_r\)</span>。对于三元组 <span class="math inline">\((h,r,t)\)</span>，如果获得的不相似性 <span class="math inline">\(f_r\)</span> 得分低于 <span class="math inline">\(δ_r\)</span>，则三元组将被归类为正，否则为负。<span class="math inline">\(δ_r\)</span> 通过最大化验证集上的分类精度进行优化.</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820224956476.png" alt="image-20210820224956476" style="zoom:50%;" /></p><p>三元组分类的评估结果如表5所示。可以看到：</p><ol type="1"><li><p>在WN11上，TransR 显著优于baseline，包括 TransE 和 TransH</p></li><li><p>TransE、TransH 和 TransR 都无法超越 FB13 上表现力最强的 NTN model。相比之下，在更大的数据集 FB15K 上，TransE、TransH 和 TransR 的表现要比 NTN 好得多。</p><p>结果可能与数据集的特征相关：FB15K 中有 1345 种关系类型，而 FB13 中只有 13 种关系类型。同时，两个数据集中的实体数量和关系事实非常接近。如（Wang等人，2014）所述，FB13 中的知识图谱比 FB15K 甚至 WN11 更密集。似乎最具表现力的模型 NTN 可以使用张量变换从 FB13 的稠密图中学习复杂的关联。相比之下，更简单的模型能够更好地处理 FB15K 的稀疏图，具有良好的泛化能力</p></li><li><p>“bern” 采样技术提高了 TransE、TransH 和 TransR 在所有三个数据集上的性能。</p></li></ol><p>如（Wang等人，2014）所示，TransE 和 TransH 的训练时间分别约为5分钟和30分钟。TransR 的计算复杂度高于 TransE 和 TransH，训练时间约为3小时。</p><h3 id="relation-extraction-from-text">Relation Extraction from Text</h3><p>关系抽取的目的是从大规模纯文本中提取关系事实，它是丰富知识图谱的重要信息源。大多数现有方法以知识图谱作为 distant supervision，在大规模文本语料库中自动标注句子作为训练实例，然后提取文本特征构建关系分类器。这些方法只使用纯文本来推理新的关系事实；同时，知识图谱嵌入只在已有知识图谱的基础上进行链接预测。</p><p>本节研究 TransR 与基于文本的关系提取模型相结合时的性能。在实验中，作者实现了（Weston et al.2013）中提出的相同的基于文本的提取模型，即 Sm2r。对于知识图谱部分，作者自己生成了一个较小的数据集 FB40K，其中包含 NYT 和 1336 种关系类型中的所有实体。并验证了此数据集的公平性。因此可以安全地使用 FB40K 来证明 TransR 的有效性。按照（Weston et al.2013）中的相同方法，作者将基于文本的关系提取模型的分数与知识图嵌入的分数相结合，对测试三元组进行排序，并得到 TransE、TransH 和 TransR 的 PR 曲线。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820225013758.png" alt="image-20210820225013758" style="zoom:50%;" /></p><p>从表中我们观察到，当召回范围 <code>[0,0.05]</code> 时，TransR 优于 TransE，与 TransH 相当，当召回范围 <code>[0.05,1]</code> 时，TransR 优于包括 TransE 和 TransH 在内的所有 baseline。最近，嵌入的思想也被广泛用于表示单词和文本，可用于基于文本的关系提取。</p><h2 id="summary">Summary</h2><p>本文提出了一种新的知识图谱嵌入模型 TransR。TransR 将实体和关系嵌入到不同的实体空间和关系空间中，并通过投影实体之间的转换来学习嵌入。此外，作者还提出了 CTransR，其目的是基于 分段线性回归 的思想对每种关系类型内部的复杂相关性进行建模。</p><p>作者认为未来的工作：</p><ul><li>利用推理信息增强图谱的表征；</li><li>可能会探索一种统一的文本和知识图嵌入模型。</li><li>基于 CTransR， 研究更复杂的模型。</li></ul><p>TransR 模型巧妙的借鉴了 TransH 模型的空间投影想法，更细致的将不同的关系作为不同的投影空间，试想一下，每个三元组中的两个实体之所以在同一个三元组，很大程度上是因为两个实体的某些特性符合当前的关系，而这些特性在这个关系所在的语义空间中满足一定的规律，亦即 <span class="math inline">\(h_{r}+r \approx t_{r}\)</span>。</p><p>TransR 还有一些缺点，例如：</p><ul><li><p>将头尾实体通过相同的转换矩阵投影到关系空间，而没有考虑到头尾实体的不同语义类型。例如，<code>(Bill Gates, founder, Microsoft)</code>。<code>'Bill Gate'</code> 是一个人，<code>'Microsoft'</code> 是一个公司，这是两个不同的类别。所以他们应该以不同的方式进行转换。</p></li><li>投影矩阵与实体和关系有关，但投影矩阵仅由关系决定。</li><li><p>TransR 的参数大于 TransE 和 TransH。引入的空间投影策略<strong>增加了计算量</strong>。通过实验可以看到，TransR 及其变体都达到了最优，但这是以巨大的计算量复杂度换来的。根据原文的说法，TransR 的训练时间约是 TransE 的 36 倍、是 TransH 的 6 倍。由于其复杂性，TransR/CTransR 难以应用于大规模知识图谱。</p></li></ul><p>TransD 模型将试图改进这些不足之处。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>TransR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConvE：Convolutional 2D Knowledge Graph Embeddings</title>
    <link href="/2021/08/20/ConvE%EF%BC%9AConvolutional%202D%20Knowledge%20Graph%20Embeddings/"/>
    <url>/2021/08/20/ConvE%EF%BC%9AConvolutional%202D%20Knowledge%20Graph%20Embeddings/</url>
    
    <content type="html"><![CDATA[<h1 id="conveconvolutional-2d-knowledge-graph-embeddings">ConvE：Convolutional 2D Knowledge Graph Embeddings</h1><p>以前关于链接预测的工作主要集中在浅层、快速的模型上，这些模型可以扩展到大型知识图谱。然而，这些模型学习的表达功能不如深层、多层模型，这可能会限制性能。在作者的工作中，提出了一个 <strong>2D 卷积链接预测模型 ConvE</strong>。该模型具有很高的参数效率，在参数减少8倍和17倍的情况下，产生与 DistMult 和 R-GCN 相同的性能。</p><h2 id="basic-idea">Basic Idea</h2><p>在大型知识图谱中，一些浅层的链接预测模型常常用来做链接预测任务，浅层的链接预测模型缺乏提取深层次特征的能力，链接预测效果也不会很好。为了增加模型提取特征的能力，可以采用增加 <strong>embedding size</strong> 的方法，但对于大型知识图谱是不合适的，参数的数量与实体以及关系的个数成正比。以前的多层知识图谱嵌入采用<strong>增加全连接层数</strong>的方法，但是这样容易造成过拟合现象。为了解决<strong>规模</strong>与<strong>过拟合</strong>的矛盾，本文设计一种参数高效的、计算快速的 <strong>2D 卷积神经网络</strong>用来做知识图谱的表示学习。</p><h2 id="background">Background</h2><h3 id="number-of-interactions-for-1d-vs-2d-convolutions">Number of Interactions for 1D vs 2D Convolutions</h3><p>为什么使用二维卷积而不是一维卷积?</p><p>使用 2D 而不是 1D 卷积通过嵌入之间的额外交互点来增加模型的表达能力。</p><p>一个填充了 3×3 滤波器大小的 2D 卷积将能够模拟整个连接线周围的相互作用(与 n 和 k 成比例的相互作用)。 一个两行的一维嵌入： <span class="math display">\[\left(\left[\begin{array}{lll}a &amp; a &amp; a\end{array}\right] ;\left[\begin{array}{lll}b &amp; b &amp; b\end{array}\right]\right)=\left[\begin{array}{llllll}a &amp; a &amp; a &amp; b &amp; b &amp; b\end{array}\right]\]</span></p><ul><li>滤波器大小为 <span class="math inline">\(\mathrm{k}=3\)</span> 的填充一维卷积将能够对这两个嵌入点周围的交互作用进行建模(相互作用的数量与k成正比)。</li></ul><p>将两行尺寸为 <span class="math inline">\(m \times n\)</span> 的二维嵌入进行串联(即堆叠)，其中 <span class="math inline">\(m =2, \mathrm{n}=3\)</span> , 得到如下结果: <span class="math display">\[\left(\left[\begin{array}{lll}a &amp; a &amp; a \\a &amp; a &amp; a\end{array}\right] ;\left[\begin{array}{lll}b &amp; b &amp; b \\b &amp; b &amp; b\end{array}\right]\right)=\left[\begin{array}{lll}a &amp; a &amp; a \\a &amp; a &amp; a \\b &amp; b &amp; b \\b &amp; b &amp; b\end{array}\right]\]</span></p><ul><li>过滤器大小为 <span class="math inline">\(3 \times 3\)</span> 的填充 2D 卷积将能够对整个串联线之间的相互作用进行建模 (相互作用的数量m与n 和 k 成正比) 。</li></ul><p>作者可以将此原理扩展为交替模式, 例如: <span class="math display">\[\left[\begin{array}{lll}a &amp; a &amp; a \\b &amp; b &amp; b \\a &amp; a &amp; a \\b &amp; b &amp; b\end{array}\right]\]</span></p><ul><li>在这种情况下，二维卷积运算能够建模a和b之间的更多交互（交互数量与m，n和k成比例）。 因此，与 1D 卷积相比，2D 卷积能够提取两个嵌入之间 的更多特征交互。</li></ul><h2 id="conve">ConvE</h2><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210811112404559.png" /></p><p>作者提出了一个神经链路预测模型，其中输入实体和关系之间的相互作用由卷积和完全连接层建模。ConvE 模型的主要特点是分数由二维形状嵌入的卷积定义。架构总结如图1所示。ConvE 的流程如下：</p><p>step1&amp;2：在前馈过程中，模型对两个嵌入矩阵执行 行矢量查找操作(<font color="orange">row-vector look-up operation</font>)，其中一个用于实体，表示为 <span class="math inline">\(\mathbf{E}^{|\mathcal{E}| \times k}\)</span>，另一用于关系式，表示为 <span class="math inline">\(\mathbf{R}^{|\mathcal{R}| \times k^{\prime}}\)</span>。其中 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(k^{\prime}\)</span> 是实体和关系嵌入维度，<span class="math inline">\(|\mathcal{E}|\)</span> 和 <span class="math inline">\(|\mathcal{R}|\)</span> 代表实体和关系的数量。然后对实体和关系嵌入进行 reshape 和 concate 堆叠。（并进行 dropout = 0.2）</p><p>step3：得到的矩阵输入到 2D 卷积层。（并进行 dropout = 0.2）。将卷积层的输出 reshape 成一个特征图张量 <span class="math inline">\(\mathcal{T} \in \mathbb{R}^{c m n}\)</span>，其中 <span class="math inline">\(c\)</span> 是尺寸为 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> 的特征图的数量。</p><p>step4：将特征图张量 <span class="math inline">\(\mathcal{T}\)</span> 向量化 <span class="math inline">\(\operatorname{vec}(\mathcal{T}) \in \mathbb{R}^{c m n}\)</span>，然后用矩阵 <span class="math inline">\(\mathbf{W} \in \mathbb{R}^{c m n \times k}\)</span> 参数化的线性变换将其投影到 <span class="math inline">\(k\)</span> 为空间中</p><p>step5：并通过内积与所有候选的目标嵌入 <span class="math inline">\(e_o\)</span> 匹配。</p><p>得分函数定义如下： <span class="math display">\[\psi_{r}\left(\mathbf{e}_{s}, \mathbf{e}_{o}\right)=f\left(\operatorname{vec}\left(f\left(\left[\overline{\mathbf{e}_{s}} ; \mathbf{r}_{r}\right] * \omega\right)\right) \mathbf{W}\right) \mathbf{e}_{o},\]</span> 其中，<span class="math inline">\(\mathbf{r}_{r} \in \mathbb{R}^{k}\)</span> 是一个取决于 <span class="math inline">\(r\)</span> 的关系参数， <span class="math inline">\(\overline{\mathbf{e}_{s}}\)</span> 和 <span class="math inline">\(\overline{\mathbf{r}_{r}}\)</span> 是 <span class="math inline">\(\mathbf{e}_{s}\)</span> 和 <span class="math inline">\(\mathbf{r}_{r}\)</span> 的 2D reshape，当 <span class="math inline">\(\mathbf{e}_{s},\mathbf{r}_{r} \in \mathbb{R}^{k}\)</span> 时，<span class="math inline">\(\overline{\mathbf{e}_{s} }, \overline{\mathbf{r}_{r} } \in \mathbb{R}^{ {k}_{w} \times k_{h} }\)</span>，其中 <span class="math inline">\(k=k_w k_h\)</span>，<span class="math inline">\(f()\)</span> 是非线性函数，这里使用了 <span class="math inline">\(sigmoid\)</span></p><p>损失函数（交叉熵损失函数）： <span class="math display">\[\mathcal{L}(p, t)=-\frac{1}{N} \sum_{i}\left(t_{i} \cdot \log \left(p_{i}\right)+\left(1-t_{i}\right) \cdot \log \left(1-p_{i}\right)\right)\]</span></p><h3 id="fast-evaluation-for-link-prediction-tasks">Fast Evaluation for Link Prediction Tasks</h3><p>卷积操作占据了计算的大部分时间，为了减少卷积操作的时间，通常会增加 batch size, 但是<strong>增加 batch size 会极大的增加内存的消耗</strong>，本文这里采用了一个小技巧，打分时候不再是1-1，而是1-N。作者采用 <strong>一个 <span class="math inline">\((h,r)\)</span> 对</strong> 对同时 <strong>所有实体 <span class="math inline">\(t\)</span></strong> 进行评分<strong>（1-N 评分）</strong>。评估时间快了300倍。</p><h2 id="experiments">Experiments</h2><h3 id="inverse-model">Inverse Model</h3><p>前人的工作指出，WN18 和 FB15k 的训练数据集有很大一部分的测试泄漏为反向关系，也就是说，这些数据集中的很大部分的三元组有与测试集相关的反向关系。例如，如果下义词是上义词的相反关系，那么测试三元组（猫科动物，下义词，猫）可以很容易地映射到训练三元组（猫，上义词，猫科动物）。这是一个很大的问题，因为在这些数据集上做得很好的链接预测<strong>可能只是了解哪些关系与其他关系相反，而不是对实际的知识图进行建模。</strong></p><blockquote><p>“上义词是对事物的概括性、抽象性说明;下义词是事物的具体表现形式或更为具体的说明”。可以理解为,上义词针对共性,而下义词针对个性。</p></blockquote><p>但是前人只是指出了问题的存在，没有验证这个问题的严重性。所以，作者构建了一个简单的、基于规则的模型，该模型只对反向关系建模。作者称这个模型为 Inverse Model。该模型自动从训练集中提取反向关系：给定两个关系对 <span class="math inline">\(r_1、r_2∈ R\)</span>、 作者检查 <span class="math inline">\((h,r_1,t)\)</span> 是否暗示 <span class="math inline">\((t,r_2,h)\)</span>，反之亦然。如果 <span class="math inline">\((h,r_1,t)\)</span> 与频率至少为 <span class="math inline">\(0.99−(f_v+f_t)\)</span> 的 <span class="math inline">\((t,r_2,h)\)</span> 共同存在，作者检测到反向关系，其中 <span class="math inline">\(f_v\)</span> 和 <span class="math inline">\(f_t\)</span> 是验证和测试集相对于数据集总大小的分数。</p><blockquote><p>还是没明白怎么算的...</p></blockquote><p>通过 Inverse model ，作者生成了新的数据集 FB15k-237、WN18RR。</p><h3 id="link-prediction">Link Prediction</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820174430327.png" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820174446696.png"/></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820174534097.png" /></p><p>Link Prediction 在 FB15k 和 WN18 上的结果如表3所示。表4显示了<u>去除反向关系的数据集</u>的结果。表5显示了 YAGO3-10 和 国家数据集的结果。可以看到：</p><ul><li>Inverse Model 在 FB15k 和 WN18 的许多不同指标上都达到了SOTA 水平。然而，它没有发现 YAGO3-10 和 FB15k-237 的反向关系。<u>前人推导 FB15k-237 数据集的过程没有删除某些对称关系</u>，例如“类似”。这些关系的存在解释了作者的 WN18RR 反向模型的良好得分。</li><li>ConvE 在 YAGO3-10 上的所有指标和 FB15k 上的一些指标上都达到了最先进的性能，并且在 WN18 上表现良好。</li></ul><h3 id="parameter-efficiency-of-conve">Parameter efficiency of ConvE</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820174657628.png" style="zoom: 40%;" /></p><p>从表2中可以看出：</p><ul><li><p>参数为 0.23M 的 ConvE 比参数为 1.89M 的 DistMult 性能更好。</p></li><li><p>参数为 0.46M 的 ConvE 在 FB15k-237上仍能达到 0.425 的最新结果Hits@10，已经比 DistMult 最好的性能还高。</p></li><li><p>与之前最好的模型是R-GCN相比，它达到了 0.417 的Hits@10 时参数超过 8M。</p></li></ul><p>总体而言，ConvE 的参数效率还是很高的。</p><h2 id="analysis">Analysis</h2><h3 id="ablation-study">Ablation Study</h3><p>表7显示了作者对比实验的结果，其中作者评估了不同的参数初始化（n=2）以计算置信区间。作者看到，Hidden dropout 是最重要的组成部分，因为它是作者的主要正则化技术。1-N 评分提高了性能。正如 Input dropout 一样，feature map dropout 的影响很小，而 label smoothing 似乎并不重要，因为没有它也可以获得好的结果。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820175133459.png" style="zoom:35%;" /></p><blockquote><p><font color="orange">我的疑问：为什么1-N 评分可以提高性能？</font></p></blockquote><h3 id="analysis-of-indegree-and-pagerank">Analysis of Indegree and PageRank</h3><p>作者的假设是：更深层次的模型，即学习多层特征的模型（如 ConvE) 相对于浅层次的模型（如 DistMult) 来说，更有优势来捕捉所有这些约束。 然而，更深层次的模型更难优化，因此作者假设，对于平均关系特征度较低的数据集（如 WN18RR 和 WN18），一个像DistMult 这样的浅模型可能足以准确地表示网络结构。</p><p>为了检验作者的两个假设，作者通过构建不同 indegree 的数据集发现：较深的模型（如 ConvE）具有对较复杂的图形进行建模的优势（例如FB15k和FB15k-237），而较浅的模型（如 DistMult）具有对较复杂的图形进行建模的优势（如 WN18 WN18RR）。</p><p>PageRank，它是节点中心性的度量。 PageRank 也可以看作是节点的递归度的度量：节点的 PageRank 值与该节点的度数，其邻居度数，其邻居-邻居度数等相对于网络中所有其他节点成比例。与标准链接预测变量 DistMult 相比，ConvE 的性能提高可以部分解释，这是因为我们能够以较高的度数对节点进行高精度建模，这可能与其深度有关。</p><p><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210820175238623.png" alt="image-20210820175238623" style="zoom:50%;" /></p><blockquote><p>看不懂这个实验....</p></blockquote><h2 id="summary">Summary</h2><p>Contributions：</p><ol type="1"><li>发明了ConvE，一个 2D 卷积链路预测模型</li><li>制定了 1-N 评分程序，将训练速度提高3倍，评估速度提高300倍</li><li><p>系统地研究报告了反向关系测试集在常用链接预测数据集上的泄露，在必要时引入数据集的鲁棒版本，使它们无法使用简单的基于规则的模型来解决。</p></li><li><p>在鲁棒数据集上将 ConvE 和先前提出的几个模型进行比较，证明 ConvE 的先进的性能。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>ConvE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TransH：Knowledge Graph Embedding by Translating on Hyperplanes</title>
    <link href="/2021/08/18/TransH%EF%BC%9AKnowledge%20Graph%20Embedding%20by%20Translating%20on%20Hyperplanes/"/>
    <url>/2021/08/18/TransH%EF%BC%9AKnowledge%20Graph%20Embedding%20by%20Translating%20on%20Hyperplanes/</url>
    
    <content type="html"><![CDATA[<h1 id="transhknowledge-graph-embedding-by-translating-on-hyperplanes">TransH：Knowledge Graph Embedding by Translating on Hyperplanes</h1><p>本文提出了 <strong>TransH，这种超平面的想法解决了同一实体的多关系问题</strong>。并且利用一个关系的一对多/多对一映射属性，<strong>提出了一个简单的技巧来降低 False Negative 标签的可能性</strong>。实验表明，与 TransE 相比，TransH 在预测精度上有显著的改进，并具有与之相当的扩展能力。</p><h2 id="basic-idea">Basic Idea</h2><p>TransE 的问题在于在处理一些关系的映射属性比如自反性、一对多、多对一和多对多这些属性嵌入方面做得并不好。</p><p>假设 <span class="math inline">\((h，r，t)∈∆\)</span> 时 <span class="math inline">\(h+ r − t = 0\)</span> 的无误差嵌入的理想情况，可以直接从 TransE 模型获得以下结果：</p><ul><li><p>如果 <span class="math inline">\((h，r，t) \in \Delta\)</span> 且 <span class="math inline">\((t，r，h) \in \Delta\)</span>，即 <span class="math inline">\(r\)</span> 是自反关系图，则 <span class="math inline">\(r = 0\)</span> 且 <span class="math inline">\(h = t\)</span>。</p></li><li><p>如果 <span class="math inline">\(\forall i \in\{0, \ldots, \mathrm{m}\}\)</span>，<span class="math inline">\((h_i，r，t) \in \Delta\)</span>, 即 <span class="math inline">\(r\)</span> 是多对一关系图, 则 <span class="math inline">\(h_0=...=h_m\)</span>。</p><p>同样地, 如果 <span class="math inline">\(\forall i (h，r，t_i) \in \Delta\)</span>，即 <span class="math inline">\(r\)</span> 是一对多关系图，则 <span class="math inline">\(t_0=...=t_m\)</span></p></li></ul><p>问题在于，<strong>在 TransE 中，当涉及任何关系时，实体的表示形式相同。而当涉及不同的关系时，则忽略实体的分布式表示形式。</strong></p><div class="note note-info">            <p>既然实际是表达同一关系不同实体最后通过 TransE 后会趋于一致，那么我直接通过一个中介来进行映射，将同一表示映射成不同向量表示，那么这些向量表示就可以代表不同的实体，就达到了不同实体拥有不同表示的目的。因为关系是不变的，所以想到了将关系作为映射平面，让实体向量向其中映射。</p>          </div><p>所以作者提出了一种称为<strong>超平面上的平移（translation on hyperplanes，TransH）</strong>的方法，该方法将关系解释为超平面上的翻译操作。在 TransH 中，每个关系由超平面上的范数向量（<span class="math inline">\(\mathbf{w}_{r}\)</span>）和超平面上的平移向量（<span class="math inline">\(\mathbf{d}_{r}\)</span>）表示。对于一个正确三元组 <span class="math inline">\((h, r, t)\)</span>，它在客观现实中是正确的，期望 <span class="math inline">\(\mathbf{h}\)</span> 和 <span class="math inline">\(\mathbf{t}\)</span> 在超平面上的<strong>投影</strong>通过平移向量 <span class="math inline">\(\mathbf{d}_{r}\)</span> 以很小的误差连接起来。这种简单的方法克服了 TransE 在处理自反/一对多/多对一/多对多关系时的缺陷，同时模型复杂度与 TransE 基本相同。</p><h2 id="transh">TransH</h2><p>TransH 允许实体在涉及不同关系时具有<strong>分布式表示</strong>。通过引入<strong>投影到关系特定超平面</strong>的机制，它可以使实体在不同关系/三元组中扮演不同角色。</p><div class="note note-info">            <p><strong>同一个实体在不同关系中的意义不同</strong>，同时<strong>不同实体，在同一关系中的意义，也可以相同</strong>。</p><p>将每个关系定义在一个独特的平面，在该平面内有符合该关系的 TransH 的表示 <span class="math inline">\((h,r,t)\)</span>，多加入的代表该平面的法向量完成了将不同实体向平面内和 <span class="math inline">\(h, t\)</span> 转化的任务，使得同一关系的不同实体拥有不同的表示，但是在关系平面内的投影相同；同一实体可以在不同的关系平面内拥有不同的含义（平面内的投影）</p>          </div><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210910222905896.png" /></p><p>对于正确的三元组来说<span class="math inline">\((h, r, t) \in \Delta\)</span>，所需满足的关系如图所示。那么对于一个实体 <span class="math inline">\(h’’\)</span> 如果满足<span class="math inline">\(\left(h&#39;&#39;, r, t\right) \in \Delta\)</span>，在 TransE 中是需要 <span class="math inline">\(h’’=h\)</span>，而在 TransH 中则将约束放宽到 <span class="math inline">\(h,h’’\)</span> 在超平面上的投影相同就可以了，也可以实现将 <span class="math inline">\(h,h’’\)</span> 区分开并且具有不同的表示。</p><p>对于关系 <span class="math inline">\(r\)</span>，<strong>TransH 将特定关系的平移向量 <span class="math inline">\(\mathbf{d}_{r}\)</span> 放置在特定关系的超平面中</strong>，而不是放置在实体嵌入的相同空间中。具体来说，对于三元组 <span class="math inline">\((h，r，t)\)</span>，首先将嵌入 <span class="math inline">\(\mathbf{h}\)</span> 和 <span class="math inline">\(\mathbf{t}\)</span> 投影到超平面。投影分别表示为 <span class="math inline">\(\mathbf{h}_{\perp}\)</span> 和 <span class="math inline">\(\mathbf{t}_{\perp}\)</span>。如果 <span class="math inline">\((h，r，t)\)</span> 是正确三元组，期望 <span class="math inline">\(\mathbf{h}_{\perp}\)</span> 和 <span class="math inline">\(\mathbf{t}_{\perp}\)</span> 可以通过平移向量 <span class="math inline">\(\mathbf{d}_{r}\)</span> 连接到超平面，并且误差越小越好。</p><p>于是定义在 TransE 中的 <span class="math inline">\(d(\mathbf{h+r},\mathbf{t})\)</span> ，在 TransH 中的得分函数定义为： <span class="math display">\[d(\mathbf{h+r},\mathbf{t}) =f_{r}(\mathbf{h}, \mathbf{t})= \left\|\mathbf{h}_{\perp}+\mathbf{d}_{r}-\mathbf{t}_{\perp}\right\|_{2}^{2}\]</span> 对于超平面，我们用法向量 <span class="math inline">\(\mathbf{w}_{r}\)</span> 来表示，并限制 <span class="math inline">\(||\mathbf{w}_{r}||_2=1\)</span> ，所以可以得到 <span class="math inline">\(\mathbf{h}\)</span> 在 法向量 <span class="math inline">\(\mathbf{w}_{r}\)</span> 上的投影为： <span class="math display">\[\begin{aligned}\mathbf{h}_{\mathbf{w}_{r}} &amp;=\frac{\mathbf{h} \cdot \mathbf{w}_{r}}{\left\|\mathbf{w}_{r}\right\|^{2}} \cdot \mathbf{w}_{r} \\&amp;=\left(\mathbf{h} \cdot \mathbf{w}_{r}\right) \cdot \mathbf{w}_{r} \\&amp;=\mathbf{w}_{r}^{\top} \mathbf{h} \mathbf{w}_{r}\end{aligned}\]</span> 所以可以得到： $$ <em>{}=-</em>{<em>{r}} =-</em>{r}^{}  _{r}</p><p>\</p><p><em>{}=-</em>{<em>{r}} =-</em>{r}^{}  _{r}</p><p>\</p><p><em>{} + r = </em>{} $$ <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820105617688.png" /></p><p>得分函数为： <span class="math display">\[\begin{aligned}f_{r}(\mathbf{h}, \mathbf{t}) &amp;=\left\|\mathbf{h}_{\perp}+\mathbf{d}_{r}-\mathbf{t}_{\perp}\right\|_{2}^{2} \\&amp;=\left\|\left(\mathbf{h}-\mathbf{w}_{r}^{\top} \mathbf{h} \mathbf{w}_{r}\right)+\mathbf{d}_{r}-\left(\mathbf{t}-\mathbf{w}_{r}^{\top} \mathbf{t} \mathbf{w}_{r}\right)\right\|_{2}^{2}\end{aligned}\]</span> 正确三元组的得分预计会更低，而错误三元组的得分将会更高。TransH 模型参数是所有实体的嵌入 <span class="math inline">\(\left\{\mathbf{e}_{i}\right\}_{i=1}^{|E|}\)</span>，所有关系的超平面和平移向量 <span class="math inline">\(\left\{\left(\mathbf{w}_{r}, \mathbf{d}_{r}\right)\right\}_{r=1}^{|R|}\)</span></p><div class="note note-primary">            <p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820105321802.png" style="zoom: 33%;" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210820105349707.png" style="zoom: 33%;" /></p>          </div><h3 id="loss-function">Loss Function</h3><p>作者引入 margin-base ranking function 作为损失函数来训练模型： <span class="math display">\[\mathcal{L}=\sum_{(h, r, t) \in \Delta} \sum_{\left(h^{\prime}, r^{\prime}, t^{\prime}\right) \in \Delta_{(h, r, t)}^{\prime}}\left[f_{r}(\mathbf{h}, \mathbf{t})+\gamma-f_{r^{\prime}}\left(\mathbf{h}^{\prime}, \mathbf{t}^{\prime}\right)\right]_{+}\]</span> 其中 <span class="math inline">\([x]_{+} \triangleq \max (0, x)\)</span>，<span class="math inline">\(\Delta\)</span> 是正（正确）三元组的集合，<span class="math inline">\(\Delta_{(h, r, t)}^{\prime}\)</span> 表示通过破坏 <span class="math inline">\((h，r，t)\)</span> 构造的错误三元组的集合，<span class="math inline">\(\gamma\)</span> 是分隔正确和错误三元组的 margin。</p><p>除此之外，在最小化 loss function 的过程中，模型还需要遵循三个软约束原则： <span class="math display">\[\begin{array}{l}\forall e \in E,\|\mathbf{e}\|_{2} \leq 1, / / \text { scale } (保证所有实体的embedding都归一化)\\\forall r \in R,\left|\mathbf{w}_{r}^{\top} \mathbf{d}_{r}\right| /\left\|\mathbf{d}_{r}\right\|_{2} \leq \epsilon, \text { //orthogonal } (保证\mathbf{w}_{r} 和 \mathbf{d}_{r} 正交垂直，保证 \mathbf{d}_{r} 在超平面上)\\\forall r \in R,\left\|\mathbf{w}_{r}\right\|_{2}=1, / / \text { unit normal vector } (保证单位法向量的模长为1)\end{array}\]</span> 为了体现上面三个约束条件，需要对 loss function 进行修改，加上对公式一和公式二的约束： <span class="math display">\[\begin{aligned}\mathcal{L} &amp;=\sum_{(h, r, t) \in \Delta} \sum_{\left(h^{\prime}, r^{\prime}, t^{\prime}\right) \in \Delta_{(h, r, t)}^{\prime}}\left[f_{r}(\mathbf{h}, \mathbf{t})+\gamma-f_{r^{\prime}}\left(\mathbf{h}^{\prime}, \mathbf{t}^{\prime}\right)\right]_{+} \\&amp;+C\left\{\sum_{e \in E}\left[\|\mathbf{e}\|_{2}^{2}-1\right]_{+}+\sum_{r \in R}\left[\frac{\left(\mathbf{w}_{r}^{\top} \mathbf{d}_{r}\right)^{2}}{\left\|\mathbf{d}_{r}\right\|_{2}^{2}}-\epsilon^{2}\right]_{+}\right\},\end{aligned}\]</span></p><p>其中 <span class="math inline">\(C\)</span> 表示软约束的权重，它也是训练过程中的一个超参数。</p><h3 id="reducing-false-negative-labels">Reducing False Negative Labels</h3><p>训练涉及为正确三元组构造负三元组。TransE 传统的 unif 方法只是通过随机破坏正确三元组来获取负三元组，但是这种随机的方式可能会在训练中引入许多 False Negative 标签。</p><blockquote><p>False Negative：被分为了负样本，但是分错了（事实上这个样本是正样本）。就是说随机产生的错误三元组可能刚好是正确三元组。</p></blockquote><p>TransH 采用不同的方法。在破坏三元组时，<strong>通过不同的关系的映射属性(一对多、多对一或多对多)来设置相应的概率来替换头或尾实体</strong>。如果关系为一对多，则倾向于更多的替换头实体，如果关系为多对一，则倾向于更多的替换尾实体。这样，减少了产生假负标签的情况。<strong>这种方法按比例生成负样本的方法称为 “bern 负采样“。</strong></p><div class="note note-info">            <p>通过这样的方式，例如 one-many 关系，替换头实体显然更不容易得到正样例（因为只有一种头实体是对的，然而替换尾实体因为对于头实体对应该关系的尾实体更多，说不定就有其他不在此many中的尾实体符合这个关系。</p>          </div><p>具体而言，在关系 <span class="math inline">\(r\)</span> 的所有三元组中，首先获得以下两个统计信息：</p><ol type="1"><li>每个头实体的平均尾实体数，表示为 <span class="math inline">\(tph\)</span> <em>(tail entities per head entity)</em>；</li><li>每个尾实体的平均头实体数，表示为 <span class="math inline">\(hpt\)</span> <em>(head entities per tail entity)</em>。</li></ol><p>然后定义了一个伯努利分布 <span class="math inline">\(\frac{tph}{tph+hpt}\)</span>。给定关系 <span class="math inline">\(r\)</span> 的正确三元组 <span class="math inline">\((h,r,t)\)</span>，通过替换头部损坏三元组时的概率为 <span class="math inline">\(\frac{tph}{tph+hpt}\)</span>，通过替换尾部损坏三元组的概率为 <span class="math inline">\(\frac{hpt}{tph+hpt}\)</span></p><p>以 FB15k 为例，在 1,345 个关系中，对于每个关系 <span class="math inline">\(r\)</span>，计算 <span class="math inline">\({tph_r}\)</span> 和 <span class="math inline">\(hpt_r\)</span>，如果：</p><ul><li><span class="math inline">\(tph_r &lt;1.5\)</span> 并且 <span class="math inline">\(hpt_r &lt;1.5\)</span>，则认为 <span class="math inline">\(r\)</span> 为一对一（一对一的比例为24％）</li><li><span class="math inline">\(tph_r≥1.5\)</span> 并且 <span class="math inline">\(hpt_r≥1.5\)</span>，则认为 <span class="math inline">\(r\)</span> 为多对多（多对多的比例为24％）</li><li><span class="math inline">\(tph_r≥1.5\)</span> 并且 <span class="math inline">\(hpt_r &lt;1.5\)</span>，则认为 <span class="math inline">\(r\)</span> 为一对多（一对多的比例为23％）</li><li><span class="math inline">\(tph_r&lt;1.5\)</span> 并且 <span class="math inline">\(hpt_r≥1.5\)</span>，则认为 <span class="math inline">\(r\)</span> 为多对一（多对一的比例为29％）</li></ul><div class="note note-primary">            <p><strong>伯努利分布</strong></p><p>假设抛硬币，正面概率为 p，反面概率为 (1-p)</p><p>伯努利实验：抛一次硬币</p><p>伯努利分布：抛一次硬币，正面概率为 p，反面概率为 (1-p)，这个就是伯努利分布</p><p>n 重伯努利实验：将伯努利实验重复 n 次，就是抛 n 次硬币。</p><p>二项分布：<strong>n重伯努利试验「成功」次数的离散概率分布</strong>，这里的「成功」假设是抛出正面。举个例子：抛硬币 n 次(n 重伯努利试验)，成功次数(抛出正面的次数)为 k 次的概率就是「一个」二项分布概率 <span class="math inline">\(P\{X=k\}=\left(\begin{array}{c} n \\ k \end{array}\right) p^{k}(1-p)^{n-k}\)</span>。</p>          </div><h2 id="experiments">Experiments</h2><p>作者对三项任务的相关方法进行了实证研究和评估：链接预测、三元组分类和关系事实提取。这三项任务都从不同的角度评估预测 unseen 三元组的准确性。</p><h3 id="link-prediction">Link Prediction</h3><p>Link Prediction 是为了补全三元组 <span class="math inline">\((h,r,t)\)</span> 中缺失的 <span class="math inline">\(h\)</span> 或 <span class="math inline">\(t\)</span>，即 给定 <span class="math inline">\((h,r)\)</span> 预测 <span class="math inline">\(t\)</span>，或给定 <span class="math inline">\((r,t)\)</span> 预测 <span class="math inline">\(h\)</span>。该任务不是要求得到最佳答案，而是着重于对知识图谱中的一组候选实体集进行排名。</p><p>数据集使用与 TransE 中相同的两个数据集：WN18(Wordnet的子集) 和 FB15k。</p><h4 id="evaluation-protocol">Evaluation protocol</h4><p>遵循与 TransE 相同的 Evaluation protocol，对于每个测试三元组 <span class="math inline">\((h,r,t)\)</span> ，用知识库中的每个实体 e 替换头实体 h 或尾实体 t，并计算错误三元组上的不相似性分数（根据评分函数 <span class="math inline">\(f_r\)</span>）。将分数按升序排列，然后得到原始正确三元组的排名。对所有测试三元组进行汇总，评估两个指标：<strong>Mean Rank </strong>和 <strong>Hits@10</strong>。每个正确三元组的能量值排序后的序号求平均，得到的值称为 Mean Rank，Mean Rank 越小越好。计算正确三元组的能量排序后的序号小于10的比例，得到的值称为 Hits@10，Hits@10 越大越好。 这称为“Raw”设置。</p><p>注意，同 TransE 一样，如果替换后的三元组仍存在于知识图谱中，因为它也是正确的，那么将其排在原始三元组之前并没有错。为了消除这个因素，在获得每个测试三元组的秩之前，删除了存在于训练集、验证集和测试集中的正确三元组。此设置称为“filter”。把上述基本评价过程得到的结果称为 <strong>Raw Mean Rank 和 Raw Hits@10</strong>，把过滤掉正确后得到的结果称为 <strong>Filtered Mean Rank 和 Filtered Hits@10</strong>。</p><h4 id="results">Results</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210818222753407.png"/></p><ul><li>在 WN18 中，<strong>简单的模型</strong>如 TransE，TransH <strong>都优于其他方法</strong>，但是 TransE 要比 TransH 更好点。可能是因为 WN18 中关系数量很少，因此可以忽略不同类型的关系。</li><li>在 FB15k 中，TransH 的指标始终优于同类方法。</li></ul><p>为了证实，与 TransE 相比，TransH 的这些改进是因为放松了几何假设(<em>relaxed geometric assumption</em>)，因此可以更好地处理自反/一对多/多对一/多对多关系。作者深入研究了不同关系映射类别的详细结果，如表 4 所示。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210818223149906.png"  /></p><ul><li>TransE 在 FB15k 中第二好。但是，它在一对多和多对一关系上的相对优势不及在一对一关系上的相对优势。</li><li>TransH 在一对多，多对一和多对多关系上为 TransE 带来了很大的改进。超出预期的是，一对一的性能也得到了显著改善（&gt; 60％）。==这可能是由于 “graph” 属性所致：实体与关系相关联，因此，更好地嵌入某些部分可以总体上带来更好的结果。==</li></ul><p>表 5 显示出 Hits@10 在一对多/多对一/多对多/自反关系上的结果。在这些关系上，TransH 对 TransE 的改进非常有效。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210818223337602.png" style="zoom: 80%;" /></p><h3 id="triplets-classification">Triplets Classification</h3><p>三元组分类是确认给定的三元组 <span class="math inline">\((h,r,t)\)</span> 是否正确，即在三元组上进行二分类。</p><p>该工作使用三个数据集。其中两个与 NTN 中的相同：WN11(WordNet的子集)； FB13(Freebase的子集)。由于 WN11 和 FB13 包含的关系数很少，因此也使用包含更多关系的 FB15k 数据集。详细信息见表2。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210819144133656.png" style="zoom: 50%;" /></p><h4 id="evaluation-protocol-1">Evaluation protocol</h4><p>遵循与 NTN 相同的 Evaluation protocol：对于三元组 <span class="math inline">\((h,r,t)\)</span>，如果不相似性得分（通过 <span class="math inline">\(f_r\)</span>）低于特定于关系的阈值 <span class="math inline">\(\sigma_{r}\)</span>，则预测为正。否则预测为负。根据（最大化）验证集上的分类准确性确定的特定于关系的阈值 <span class="math inline">\(\sigma_{r}\)</span>。</p><h4 id="results-1">Results</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210819191620143.png" style="zoom:50%;" /></p><ul><li>在 WN11 上，TransH 优于所有其他方法。</li><li>在 FB13 上，NTN 模型表现的最好。在较大的 FB15k 上，TransE 和 TransH 比 NTN 好很多。注意，当实体数接近时，FB15k 的关系数比 FB13 的关系数大得多。这说明 FB13 是一个非常密集的子图谱(大量的实体，少量的关系)，其中实体之间存在很强的相关性。在这种情况下，(NTN 模型)通过张量和非线性变换对实体之间复杂的相关性进行建模有助于嵌入。但是，在 FB15k 这个较稀疏子图谱中，似乎简单地假设在超平面上进行 translation 就足够了，而不必使用复杂的 NTN 模型。</li><li>关于运行时间，NTN 的耗时比 TransE / TransH 高得多。</li><li>在所有三个数据集上，减少 False Negative 标签（“ bern ”的结果）的技巧有助于 TransE 和 TransH。</li></ul><h3 id="relational-fact-extraction-from-text">Relational Fact Extraction from Text</h3><p>在本实验中，作者比较了 TransH 和 TransE 对改进关系事实抽取的贡献。该实验包括两个主要部分： text side extraction model 和 knowledge graph embedding.</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210818223623200.png" /></p><p>遵循将知识图谱嵌入的分数与文本侧模型的分数相结合的相同规则，可以获得 TransE 和 TransH 的 PR 曲线，如图2(a) 所示。从图中可以看出，TransH 在改进 Sm2r 方面是“先进”模型，其性能始终优于TransE。图2(a) 中的结果取决于将知识图谱嵌入的得分与文本侧模型的得分相结合的特定规则，实际上规则可能不是最佳方法。因此，图2(a) 不能清楚地展示 TransE / TransH 作为关系事实预测的独立模型的独立功能。为了清楚地展示 TransE / TransH 的独立功能，首先使用 text side model Sm2r 将每个实体对分配给具有最高置信度得分的关系，然后保留那些分配关系不是 “NA” 的事实。对于这些可信的候选事实，仅使用 TransE / TransH 的分数进行预测。结果示于图2(b)，在候选子集上，TransE 和 TransH 的性能均优于 Sm2r。当召回率高于0.6时，TransH 的性能要比 TransE 好得多。</p><blockquote><p>没看懂这个实验怎么做的...</p></blockquote><h2 id="summary">Summary</h2><p>本文两个贡献：</p><ol type="1"><li>提出了 TransH 模型，通过超平面解决了同一实体的多关系问题。</li><li>提出了减少 False Negative 标签的方法，分别统计每个头实体对应尾实体的数量（反之亦然），按占比生成负样例。</li></ol><p>TransH 存在的问题：如果两个实体本来就距离很近，那么关于一个关系向量得到的尾向量一定距离很近。然而，每个实体可以有许多属性，不同的关系关注实体的不同属性。关系和实体是完全不同的对象，在同一个语义空间中可能不足以表示它们。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>TransH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Joint Extraction of Entities and Relations Based on a Novel Tagging Scheme</title>
    <link href="/2021/08/15/Joint%20Extraction%20of%20Entities%20and%20Relations%20Based%20on%20a%20Novel%20Tagging%20Scheme/"/>
    <url>/2021/08/15/Joint%20Extraction%20of%20Entities%20and%20Relations%20Based%20on%20a%20Novel%20Tagging%20Scheme/</url>
    
    <content type="html"><![CDATA[<h1 id="Joint-Extraction-of-Entities-and-Relations-Based-on-a-Novel-Tagging-Scheme"><a href="#Joint-Extraction-of-Entities-and-Relations-Based-on-a-Novel-Tagging-Scheme" class="headerlink" title="Joint Extraction of Entities and Relations Based on a Novel Tagging Scheme"></a>Joint Extraction of Entities and Relations Based on a Novel Tagging Scheme</h1><p>这篇文章是 ACL 2017 Outstanding Paper。作者提出了一个新的标注方案，并使用神经网络进行实体和关系的联合抽取。</p><h2 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h2><p>实体与关系抽取是构建 KB 的重要步骤。两个主要框架已被广泛用于解决抽取实体及其关系的问题。一个是<strong>流水线方法</strong>，另一个是<strong>联合学习方法</strong>。</p><ul><li><p>传统方法以<strong>流水线</strong>方法将这个任务视为两个分离的任务<strong>，即命名实体识别（NER）和关系分类（RC）。</strong>先抽取实体，然后识别它们的关系。这种分离的框架使得任务易于处理，并且每个组件都可以更加灵活。但它<strong>忽略了这两个子任务之间的相关性</strong>，每个子任务都是一个独立的模型。实体识别的结果可能会影响关系分类的性能，并导致错误的传播。                            </p></li><li><p><strong>联合学习框架是使用单一模型将实体和关系一起抽取出来。它可以有效地整合实体和关系的信息</strong>，并在这项任务中取得了较好的效果。然而，大多数现有的联合方法都是基于特征的结构化系统，他们需要复杂的特征工程，并且严重依赖其他 NLP 工具包，这也可能导致错误传播。</p></li></ul><p>基于两个方法的问题，作者提出了一个新颖的标注方案，然后抽取由两个实体和这两个实体之间的一个关系组成的三元组（而不是分别抽取实体和关系），并配以端到端的模型。标注方案包含实体信息和它们的关系。基于这种标注方案，实体和关系的联合抽取可以转化为标记问题。这样，可以用神经网络来建模任务，而不需要复杂的特征工程。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>作者提出了一种<strong>新的标注方案</strong>和一个具<strong>有偏置目标函数</strong>的<strong>端到端模型</strong>来联合抽取实体及其关系。</p><h3 id="Tagging-Scheme"><a href="#Tagging-Scheme" class="headerlink" title="Tagging Scheme"></a>Tagging Scheme</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210816093540180.png" alt=""></p><p>每个单词都被分配一个标签 tags，用于抽取结果。<strong>标签“O”代表“Other”标签</strong>，这意味着相应的单词与抽取结果无关。除了“O”之外，其他标签由<strong>三部分组成</strong>：<strong>实体中的单词位置</strong>、<strong>关系类型</strong>和<strong>关系角色</strong>。<strong>使用“BIES”（Begin, Inside, End, Single）符号来表示单词在实体中的位置信息</strong>。<strong>关系类型信息是从一组预定义的关系中获得的</strong>，<strong>关系角色信息由数字“1”和“2”表示</strong>。抽取的结果由三元组表示：<code>(Entity1，RelationType，Entity2)</code>。“1”表示该词属于三元组中的第一个实体，而“2”则属于该关系类型后面的第二个实体。</p><p>图2是一个说明标注方法的例子。输入句子包含两个三元组：<code>&#123;United States, Country-President, Trump&#125;</code> 和 <code>&#123;Apple Inc, Company-Founder, Steven Paul Jobs&#125;</code>，其中 <code>“Country-President”</code> 和 <code>“Company-Founder”</code> 是预定义的关系类型。<code>”United”</code>, <code>“States”</code>, <code>“Trump”</code>, <code>“Apple”</code>, <code>“Inc”</code> , <code>“Steven”</code>, <code>“Paul”</code> 和 <code>“Jobs”</code> 等词都与最终抽取的结果有关。因此，他们根据特殊标签进行标注。例如 <code>“United”</code> 这个词是<code>“United States”</code> 实体的第一个词，与 <code>“Country-President”</code> 关系有关，所以它的标签是 <code>“B-CP-1”</code>。对应于 <code>“United States”</code> 的另一个实体 <code>“Trump”</code> 被标记为 <code>“S-CP-2”</code>。此外，与最终结果无关的其他字词标记为 <code>“O”</code>。</p><h3 id="End-to-end-Model"><a href="#End-to-end-Model" class="headerlink" title="End-to-end Model"></a>End-to-end Model</h3><p>本文采用了一个端到端的模型来生成标注序列，如图 3 所示。模型用 Bi-LSTM 来对输入句子进行编码，用具有偏置损失的 LSTM 进行解码，偏置损失可以增强实体标签的相关性。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210816095825365.png" alt=""></p><h4 id="Bi-LSTM-编码层"><a href="#Bi-LSTM-编码层" class="headerlink" title="Bi-LSTM 编码层"></a>Bi-LSTM 编码层</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210816194652396.png" style="zoom:50%;" /></p><p><strong>在序列标注问题中，Bi-LSTM 编码层已被证明有效捕获每个单词的语义信息</strong>。它包含前向 LSTM 层，后向 LSTM 层和连接层。<strong>词嵌入层将 one-hot 表示的单词转换为嵌入向量</strong>。因此，一个单词序列可以表示为 $W = {w<em>1，… w_t，w</em>{t+1} … w<em>n}$，其中 $w_t \in R_d$ 是对应于句中第 $t$ 个单词的 $d$ 维词向量，$n$ 是给定句子的长度。在词嵌入层之后，有两个平行的 LSTM 层：前向 LSTM 层 和 后向 LSTM 层。 LSTM 体系结构由一组递归连接的子网（称为 memory blocks）组成。每个时间步是一个 LSTM memory block。 Bi-LSTM 编码层中的 LSTM 记忆块用于根据上一个隐藏向量 $h</em>{t-1}$、上一个单元向量 $c_{t-1}$ 和当前输入词表示 $w_t$ 计算当前隐藏向量$h_t$。其结构图如图3（b）所示，具体操作定义如下：</p><script type="math/tex; mode=display">\begin{array}{l}f_{t}=\delta\left(W_{w f} w_{t}+W_{h f} h_{t-1}+W_{c f} c_{t-1}+b_{f}\right) \quad (遗忘门 f_t) \\i_{t}=\delta\left(W_{w i} w_{t}+W_{h i} h_{t-1}+W_{c i} c_{t-1}+b_{i}\right) \quad (输入门 i_t)  \\  z_{t}=\tanh \left(W_{w c} w_{t}+W_{h c} h_{t-1}+b_{c}\right) \\c_{t}=f_{t} c_{t-1}+i_{t} z_{t} \\o_{t}=\delta\left(W_{w o} w_{t}+W_{h o} h_{t-1}+W_{c o} c_{t}+b_{o}\right) \quad (输出门 o_t)  \\h_{t}=o_{t} \tanh \left(c_{t}\right) \quad (输出结果：当前隐藏向量h_t,作为Decoder层的其中一种输入)\end{array}</script><h5 id="Bi-LSTM"><a href="#Bi-LSTM" class="headerlink" title="Bi-LSTM"></a>Bi-LSTM</h5><p>前向的LSTM与后向的LSTM结合成BiLSTM。比如，我们对“我爱中国”这句话进行编码，模型如图所示。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210825205225012.png" style="zoom: 50%;" /></p><p>前向的 LSTML 依次输入“我”，“爱”，“中国” 得到三个向量 ${h<em>{L0}, h</em>{L1}, h<em>{L2}}$。后向的LSTMR依次输入“中国”，“爱”， “我”得到三个向量 ${h</em>{R0}, h<em>{R1}, h</em>{R2}}$。最后将前向和后向的隐向量进行拼接得到 ${[h<em>{L0}, h</em>{R2}], [h<em>{L1}, h</em>{R1}], [h<em>{L2}, h</em>{R0}] }$, 即 ${ho, h1, h2}$。</p><p> 所以这个模型图应该是这样（略草率请忽略:P）：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210919160619913.png" style="zoom: 60%;" /></p><h4 id="LSTM-解码器层"><a href="#LSTM-解码器层" class="headerlink" title="LSTM 解码器层"></a>LSTM 解码器层</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210816194348347.png" style="zoom: 50%;" /></p><p>作者也<strong>采用LSTM结构来生成标注序列</strong>。当检测到单词 $w<em>t$ 的标注时，解码层的输入为：从 Bi-LSTM 编码层获得的 $h_t$，上一个的预测标签表示 $T</em>{t-1}$，上一个单元单元值：$c<em>{t-1}$，以及解码层中的上一个隐藏向量 $h</em>{t-1}$。图3（c）显示了 LSTMd 记忆块的结构图，具体操作定义如下</p><script type="math/tex; mode=display">\begin{array}{l}f_{t}^{(2)}=\delta\left(W_{w f}^{(2)} h_{t}+W_{h f}^{(2)} h_{t-1}^{(2)}+W_{t f} T_{t-1}+b_{f}^{(2)}\right) \quad (遗忘门 f_t) \\i_{t}^{(2)}=\delta\left(W_{w i}^{(2)} h_{t}+W_{h i}^{(2)} h_{t-1}^{(2)}+W_{t i} T_{t-1}+b_{i}^{(2)}\right) \quad (输入门 i_t)  \\  z_{t}^{(2)}=\tanh \left(W_{w c}^{(2)} h_{t}+W_{h c}^{(2)} h_{t-1}^{(2)}+W_{t c} T_{t-1}+b_{c}^{(2)}\right) \\c_{t}^{(2)}=f_{t}^{(2)} c_{t-1}^{(2)}+i_{t}^{(2)} z_{t}^{(2)} \\o_{t}^{(2)}=\delta\left(W_{w o}^{(2)} h_{t}+W_{h o}^{(2)} h_{t-1}^{(2)}+W_{c o}^{(2)} c_{t}+b_{o}^{(2)}\right)\quad (输出门 o_t)  \\h_{t}^{(2)}=o_{t}^{(2)} \tanh \left(c_{t}^{(2)}\right) \\T_{t}=W_{t s} h_{t}^{(2)}+b_{t s}\end{array}</script><p>最终的 softmax 层根据标签预测向量 $T_t$ 计算归一化实体标签概率：</p><script type="math/tex; mode=display">y_{t}=W_{y} T_{t}+b_{y} \\p_{t}^{i}=\frac{\exp \left(y_{t}^{i}\right)}{\sum_{j=1}^{N_{t}} \exp \left(y_{t}^{j}\right)}</script><p>$W_y$ 是 softmax 矩阵，$N_t$ 是标签总数。由于 $T$ 与标签嵌入类似，并且 LSTM 能够学习长期相关性，所以解码方式可以对标签交互进行建模。</p><div class="note note-primary">            <p>这个标签的概率所在的索引，就是标签的 id，会有一个 id2label 字典存放的是 id:标签名称，根据字典就能得到标签名称，根据标签名称就能解码实体和关系，像前面例子中的那样</p>          </div><h4 id="偏置目标函数"><a href="#偏置目标函数" class="headerlink" title="偏置目标函数"></a>偏置目标函数</h4><p>目标函数定义为：</p><script type="math/tex; mode=display">\begin{aligned}L=& \max \sum_{j=1}^{|\mathbb{D}|} \sum_{t=1}^{L_{j}}\left(\log \left(p_{t}^{(j)}=y_{t}^{(j)} \mid x_{j}, \Theta\right) \cdot I(O)\right.\left.+\alpha \cdot \log \left(p_{t}^{(j)}=y_{t}^{(j)} \mid x_{j}, \Theta\right) \cdot(1-I(O))\right)\end{aligned}</script><p>$|D|$ 是训练集的大小，$L_j$ 是句子 $x_j$ 的长度，$y_t^{(j)}$ 是单词 $x_j$ 中词 $t$ 的 tag，$p_t^{(j)}$ 是在上面定义的归一化实体标签概率。$I(O)$ 是一个开关函数，以区分标注 <code>‘O’</code> 与可指示结果的相关 tags 间的损失。定义如下：</p><script type="math/tex; mode=display">I(O)=\left\{\begin{array}{l}1, \text { if } \operatorname{tag}={ }^{\prime} O^{\prime} \\0, \text { if } \operatorname{tag} \neq{ }^{\prime} O^{\prime}\end{array}\right.</script><p>$α$ 是偏置权重，$α$ 越大，对模型中相关 tags 的影响越大。给个 alpha 是想让模型更多关注实体类型的 token</p><p>其实合起来看就是：</p><script type="math/tex; mode=display">L = \left\{\begin{array}{l}\max \sum_{j=1}^{|\mathbb{D}|} \sum_{t=1}^{L_{j}}\left.\log \left(p_{t}^{(j)}=y_{t}^{(j)} \mid x_{j}, \Theta\right)  \right. , \text { if } \operatorname{tag}={ }^{\prime} O^{\prime} \\\max \sum_{j=1}^{|\mathbb{D}|} \sum_{t=1}^{L_{j}}\left.\alpha \cdot \log \left(p_{t}^{(j)}=y_{t}^{(j)} \mid x_{j}, \Theta\right) \right. , \text { if } \operatorname{tag} \neq{ }^{\prime} O^{\prime}\end{array}\right.</script><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>数据集使用公共数据集 NYT。大量的训练数据可以通过远程监督的方式获得，无需人工标注。测试集是手工标记以确保其质量。训练数据总共包含353k三元组，测试集包含3,880三元组。此外，关系集的大小是24。</p><div class="note note-primary">            <p>为了打破有监督学习中人工数据标注的局限性，Mintz等人提出了远程监督（Distant Supervision）算法，该算法的核心思想是将文本与大规模知识图谱进行实体对齐，利用知识图谱已有的实体间关系对文本进行标注。</p><p>远程监督基于的基本假设是：如果从知识图谱中可获取三元组R（E1，E2）（注：R代表关系，E1、E2代表两个实体），且E1和E2共现与句子S中，则S表达了E1和E2间的关系R，标注为训练正例。</p><p>远程监督算法是目前主流的关系抽取系统广泛采用的方法，也是该领域的研究热点之一。该算法很好地解决了数据标注的规模问题，但它基于的基本假设过强，会引入大量噪音数据。出现 <code>the wrong label problem</code> 的根本原因，是远程监督假设一个实体对只对应一种关系，但实际上实体对间可以同时具有多种关系.</p>          </div><h3 id="Performance-Comparison"><a href="#Performance-Comparison" class="headerlink" title="Performance Comparison"></a>Performance Comparison</h3><p>采用标准<strong>Precision（Prec）、Recall（Rec）和F1分数</strong>来评估结果。当三元组的关系类型和两个对应的实体的头部偏移都是正确的时，这个三元组被认为是正确的。从测试集中随机抽取10％的数据来创建验证集。对每个实验运行10次，然后报告平均结果和它们的标准偏差，如表1所示。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210816103031029.png" alt=""></p><p>表一：抽取两个实体及其关系的不同方法的预测结果。第一部分（从第一行到第三行）是流水线方法，第二部分（第四行到第六行）是联合抽取方法。作者的标注方法在第三部分（第7到第9行）中显示。在这一部分在准确率、召回率和F1的结果同时，还计算了它们的标准差。</p><p>从表 1 可以看出，</p><ol><li>联合抽取方法优于流水线方法，作者的标注方法优于流水线方法和大多数联合抽取方法。这也验证了标注方案对共同抽取实体和关系的任务的有效性。</li><li>与传统方法相比，<strong>端到端模型的准确率显著提高</strong>。但是<strong>只有 LSTM-LSTM-Bias 可以更好地平衡准确率和召回率</strong>（通过比较 F1 分数）。原因可能是这些端到端模型都使用 Bi-LSTM 编码输入句子和不同的神经网络来解码结果，而基于神经网络的方法可以很好地拟合数据，因此，他们可以很好地学习训练集的共同特征，并可能导致较低的可扩展性。</li><li>基于作者的标注方案，LSTM-LSTM 模型优于 LSTM-CRF 模型。因为，LSTM 能够学习长期的依赖关系，CRF 擅长捕捉整个标注序列的联合概率。相关的标签可能相距很远。因此，LSTM 解码方式比 CRF 好一些。 LSTM-LSTM-Bias 增加了一个偏置权重，以增强实体标注的效果，减弱无效标注的影响。因此，在这个标注方案中，作者的方法可以比普通的 LSTM 解码方法更好。</li></ol><div class="note note-primary">            <p><strong>有关准确率（Accuracy）、Precision（Prec）、Recall（Rec）和F1分数：</strong></p><ul><li>TP（True Positives）意思就是<strong>被分为了正样本，而且分对了</strong>。</li><li>TN（True Negatives）意思就是<strong>被分为了负样本，而且分对了</strong>。</li><li>FP（False Positives）意思就是<strong>被分为了正样本，但是分错了（事实上这个样本是负样本）</strong>。</li><li>FN（False Negatives）意思就是<strong>被分为了负样本，但是分错了（事实上这个样本是正样本）。</strong></li></ul><p><strong>准确率（Accuracy）：</strong></p><script type="math/tex; mode=display">Accuracy = \frac{TP + TN}{TP + TN+FP + FN}</script><p>准确率就是所有的预测正确（正类负类）的占总的比重。</p><p><strong>precision（精确度）：</strong></p><script type="math/tex; mode=display">Precision= \frac{TP}{TP+FP}</script><p>TP是 分类器认为是正样本而且确实是正样本的例子，FP是 分类器认为是正样本但实际上不是正样本的例子，Precision 翻译过来就是<strong>“分类器认为是正类并且确实是正类的部分占所有分类器认为是正类的比例”</strong>。</p><p><strong>recall（召回率）：</strong></p><script type="math/tex; mode=display">Recall=\frac{TP}{TP+FN}</script><p>TP是 分类器认为是正样本而且确实是正样本的例子，FN是 分类器认为是负样本但实际上不是负样本的例子，Recall 翻译过来就是“<strong>分类器认为是正类并且确实是正类的部分占所有确实真正是正类的比例</strong>”。</p><p>P 和 R 指标有时候会出现的矛盾的情况，这样就需要综合考虑他们，最常见的方法就是 <strong>F-Measure</strong> ，通过计算F值来评价一个指标</p><p>常见的 <strong>F1 计算方法</strong>：</p><script type="math/tex; mode=display">F1 = \frac{2 \cdot P \cdot R}{P + R}</script>          </div><h3 id="Predicted-Results-on-Triplet’s-Elements"><a href="#Predicted-Results-on-Triplet’s-Elements" class="headerlink" title="Predicted Results on Triplet’s Elements"></a>Predicted Results on Triplet’s Elements</h3><p>为了<u>找出影响端到端模型结果的因素</u>，作者分析了预测三元组中每个元素的性能，只有当两个相应实体的关系类型和头部偏移量都是正确的时候，它才能处理三元组。如表 2 所示。E1 和 E2 分别表示预测每个实体的性能。如果第一个实体的头部偏移是正确的，那么 E1 的实例是正确的，E2 同理。不管关系类型，如果两个对应实体的头部偏移都是正确的，则（E1，E2）的实例是正确的。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210816103433932.png" alt=""></p><ol><li><p>Compare (E1,E2) with single E：与 single E1 和 E2 相比，（E1，E2）具有更高的准确率。<strong>但其召回率低于E1和E2。这意味着一些预测的实体不会形成一对。</strong>他们只获得E1而没有找到相应的E2，或者获得E2并且没有找到相应的E1，导致更多的单个E和更少（E1，E2）对的预测。因此，实体对（E1，E2）比单个E具有更高的准确率和更低的召回率。</p></li><li><p>Compare (E1,E2) with Triplet：与表1中的预测结果相比，表2中（E1，E2）的预测结果有大约3%的改进，这意味着3%的测试数据被预测为错误，因为关系类型被预测为错误。</p></li></ol><h3 id="Analysis-of-Biased-Loss"><a href="#Analysis-of-Biased-Loss" class="headerlink" title="Analysis of Biased Loss"></a>Analysis of Biased Loss</h3><p>与 LSTM-CRF 和 LSTM-LSTM 不同的是，LSTM-LSTM-Bias 的方法偏向于通过关系标签来增强实体之间的联系。如图 4 是预测单个实体的比例可视化。<u>单个实体是指那些找不到相应实体的实体。</u>作者使用偏置目标函数的方法在单个实体上的比例相对较低。这意味着比起 LSTM-CRF 和 LSTM-LSTM 对关系标签关注不多，LSTM-LSTM-Bias 可以<strong>有效地将两个实体关联起来</strong>。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210816103719024.png" alt="image-20210816103719024" style="zoom: 67%;" /></p><p>此外，作者也将偏差参数 α 从1改变到20，预测结果如图5所示。如果 $α$ 太大，会影响预测的准确率，如果 $\alpha$ 太小，召回率会下降。当 $α= 10$ 时，LSTM-LSTM Bias 可以平衡准确率和召回率，并且可以达到最好的 F1 分数。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210816103831764.png" alt="image-20210816103831764" style="zoom:67%;" /></p><h3 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h3><p>作者选取了几个有代表性的例子来说明这些方法的优缺点，如表3所示。每个例子包含三行，第一行是黄金标准，第二行和第三行分别是模型 LSTM-LSTM 和 LSTM-LSTM-Bias 的抽取结果。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210816103917080.png" style="zoom: 50%;" /></p><p>S1 是一个两个相关实体之间的距离彼此很远的栗子，这使得更难以发现他们的关系。</p><p>S2 是一个负面的例子，表明这些方法可能错误地预测了某个实体。</p><p>S3 是模型可以预测实体头部偏移量的情况，但是关系角色是错误的。这说明 LSTM-LSTM-Bias 能够更好地预测实体对，但是在区分两个实体之间的关系方面还有待改进。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>本文的主要贡献是：</p><ol><li><strong>提出了一种新的标注方案，联合抽取实体和关系，可以很容易地将抽取问题转化为标注任务。</strong></li><li><strong>基于新的标注方案，研究了不同类型的端到端模型来解决问题。基于标记的方法比大多数现有的流水线和联合学习方法要好。</strong></li><li>此外，还开发了<strong>具有偏置损失函数的端到端模型，以适应新的标注，它可以增强相关实体之间的关联</strong>。</li></ol><p>在未来的工作中，作者<u>将用多个分类器来替换输出层中的softmax函数</u>，这样一个词可以有多个标签。这样，一个单词可以出现在多个三元组结果中，可以解决重叠关系的问题。尽管的模型可以增强实体标注的效果，但是两个相应的实体之间的关联仍然需要在接下来的工作中进行细化。</p><div class="note note-primary">            <p>作者貌似把重叠三元组都去掉了。因为无法处理重叠的情况，比如：两个三元组标注的标签一样，解码时候就会有歧义。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Relation Extraction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TransE：Translating Embeddings for Modeling Multi-relational Data</title>
    <link href="/2021/08/13/TransE%EF%BC%9ATranslating%20Embeddings%20for%20Modeling%20Multi-relational%20Data/"/>
    <url>/2021/08/13/TransE%EF%BC%9ATranslating%20Embeddings%20for%20Modeling%20Multi-relational%20Data/</url>
    
    <content type="html"><![CDATA[<h1 id="transetranslating-embeddings-for-modeling-multi-relational-data">TransE：Translating Embeddings for Modeling Multi-relational Data</h1><p><strong>本文提出了一种将实体与关系嵌入到低维向量空间中的简单模型 TransE。</strong>以前有很多种训练三元组的方法，但是参数过多，以至于模型过于复杂难以理解。本文作者提出了 TransE 模型，工作效果和以前一样，但模型简单易扩展，达到了不错的效果。</p><h2 id="basic-idea">Basic Idea</h2><p>以前的 Knowledeg Embedding 模型，参数多，模型复杂，计算成本高。作者认为简单的模型也可以有一样的表现力。</p><p>作者提出了 TransE 模型。一个基于平移的模型，用于学习实体的低维嵌入。在 TransE 中，<strong>关系表示为嵌入空间中的平移</strong>：如果 <span class="math inline">\((h, \ell, t)\)</span> 成立，则尾部实体 <span class="math inline">\(t\)</span> 的嵌入应接近头部实体 <span class="math inline">\(h\)</span> 的嵌入加上依赖于关系的向量 <span class="math inline">\(\ell\)</span>。</p><p>作者提出这个基于平移的模型的动机有两个：</p><ul><li><p>主要的动机，作者认为很多 KBs 的表示方法都含有<strong>层次关系</strong>，类似一个树结构。 树的自然表示可以看作每一个节点的 Embedding 可以用这个节点下面的子树和叶节点表示。那么节点和节点的关系，同样可以表示为实体共同的父节点。</p></li><li><p>次要动机来自于 word embedding 的思想。作者通过学习词嵌入发现，一些实体之间的一对一关系，例如“国家”和“城市”之间的“首都”关系，用模型可以表示为嵌入空间中向量的平移。</p></li></ul><p>这两个动机使作者提出了 TransE 模型。</p><h2 id="translation-based-model">Translation-based model</h2><blockquote><p>给定由两个实体 <span class="math inline">\(h,t \in E\)</span> 和一个关系 <span class="math inline">\(\ell\)</span> 组成的三元组 <span class="math inline">\((h, \ell, t)\)</span>。</p></blockquote><p>TransE 模型认为一个正确的三元组的 embedding 向量 <span class="math inline">\((h, \ell, t)\)</span> 会满足公式：<span class="math inline">\(h+\ell \approx t\)</span></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210813163920543.png" /></p><p>头实体 embedding 加上关系 embedding 会约等于尾实体 embedding。如果是一个错误的三元组，那么它们的 embedding 之间就不满足这种关系。即，如果三元组是正确的，则尾实体 embedding 应该与头实体 embedding 和关系 embedding 的加和更为接近；反之，如果三元组是错误的，则尾实体 embedding 应该与头实体 embedding 和关系 embedding 的加和更为远离。可以选择L1或者L2范数来衡量三个向量的差距。因此我们定义如下的势能函数，这里采用<u>L2范数</u>：</p><blockquote><p>势能函数原文里称“衡量三元组能量(energy)的距离函数”</p><p>以后的系列论文都会称为 “得分函数”。</p></blockquote><p><span class="math display">\[d(h+\ell,t)=f(h,\ell,t)=||h+\ell-t||_2\]</span></p><p>对于一个正确的三元组，我们希望距离(势能)越近越好，而对于一个错误的三元组，我们希望距离(势能)越远越好。基于此，TransE 模型的目标函数设计为： <span class="math display">\[\mathcal{L}=\sum_{(h, \ell, t) \in S} \sum_{\left(h^{\prime}, \ell, t^{\prime}\right) \in S_{(h, \ell, t)}^{\prime}}\left[\gamma+f(h,\ell,t)-f(h&#39;,\ell&#39;,t&#39;)\right]_{+}\]</span> 其中：</p><ul><li><p>目标函数的目标是让正例的距离最小，也就是 <span class="math inline">\(min(d(h+\ell, t))\)</span>，让负例的相反数最小也就是 <span class="math inline">\((min(−d(h′+ \ell′,t ′)))\)</span>，对于每一个正样本和负样本求和，再增加一个常数的间距，就是整体距离的最小值。也就是我们的目标函数。</p></li><li><p><span class="math inline">\([f(x)]_+\)</span> 表示为 <span class="math inline">\(max(0,f(x))\)</span>，即 f(x) 大于0为 <span class="math inline">\(f(x)+=f(x)\)</span>，小于0则为 <span class="math inline">\(f(x)+=0\)</span>。这叫做合页损失函数(hinge loss function)。</p><blockquote><p>这个地方我把 <span class="math inline">\([x]_+\)</span> 理解为 <span class="math inline">\([f(x)]_+\)</span> ，这样我就理解了为什么是两个求和符号。</p></blockquote></li><li><p>为了方便训练，避免过拟合，通常还会在上述目标函数后面增加约束条件 <span class="math inline">\(||h||\le1,||r||\le1,||t||\le1\)</span>。</p></li></ul><p>这种训练方法叫做 <strong>margin-based ranking criterion</strong>。它来自于 SVM。支持向量机也是如此，要将正和负尽可能分开，找出最大距离的支持向量。同理，TransE 也是如此，尽可能将对的和错的分开。<span class="math inline">\(\gamma\)</span> 表示的是三元组正样本和负样本的间隔 margin，margin 越大，则两个 triple 之前被修正的间隔就越大，则对于词向量的修正就越严格。<span class="math inline">\(\gamma\)</span> 为超参数。</p><h3 id="负样本错误三元组的产生">负样本（错误三元组）的产生</h3><p><span class="math display">\[S_{(h, \ell, t)}^{\prime}=\left\{\left(h^{\prime}, \ell, t\right) \mid h^{\prime} \in E\right\} \cup\left\{\left(h, \ell, t^{\prime}\right) \mid t^{\prime} \in E\right\} .\]</span></p><p>上式构造错误的三元组，头部或尾部被随机实体代替（不能同时替换，但肯定有一个是属于训练项中的实体）。</p><p>为了避免出现生成的负例其实存在于知识库中的情况，我们可以对生成的负例进行过滤，如果它是知识库中的正例，那我们就不把它作为负例，而是重新生成一个负例。</p><h3 id="algorithm">Algorithm</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210819112248295.png" /></p><p>算法1中描述了详细的过程：</p><ol start="0" type="1"><li><p>输入训练集三元组 <span class="math inline">\(S={(h, \ell, t)}\)</span>，实体集 <span class="math inline">\(E\)</span>，关系集 <span class="math inline">\(L\)</span>，嵌入维度 <span class="math inline">\(k\)</span>，超参数：margin <span class="math inline">\(\gamma\)</span>，学习率 <span class="math inline">\(\lambda\)</span></p></li><li><p>初始化：随机初始化头实体、尾实体和关系向量 <span class="math inline">\(\boldsymbol{\ell} , \boldsymbol{e}\)</span> ，并对通过 <em>Xavier</em> 初始化的向量做归一化处理</p></li><li><p>循环：采用 minibatch，一批一批的训练会加快训练速度</p><ol start="0" type="1"><li>每一次循环迭代后要对 <span class="math inline">\(e\)</span> 的 embedding 标准化</li><li>取一个b大小的 <span class="math inline">\(S_{batch}\)</span> ，<span class="math inline">\(T_{batch}\)</span> 初始化为空列表</li><li>对于每批数据 <span class="math inline">\(S_{batch}\)</span><ol type="1"><li>进行负采样（将训练集中的三元组头实体 or 尾实体随机替换掉）</li><li><span class="math inline">\(T_{batch}\)</span> 初始为一个空列表，然后向其添加由元组对（原三元组，错误三元组）组成的列表 <span class="math inline">\(T_{batch} = [ ( [h,r,t], [h&#39;,r,t&#39;] ), ([ ], [ ]), ......]\)</span></li></ol></li><li>利用 SGD 优化目标函数，进行 embedding 参数的更新</li></ol></li></ol><h2 id="experiments">Experiments</h2><p>TransE 是根据从 Wordnet 和 Freebase 中提取的数据进行评估的，与文献中的几种最新方法相比，这些方法在各种基准上实现了最佳的当前性能，并可扩展到相对较大的数据集。</p><h3 id="evaluation-protocol">Evaluation protocol</h3><p>我们得到每个实体和关系的 embedding 之后，如何评估这些学得的 embedding 的质量呢？这里用了一个评估方法/协议—Link prediction。这个方法不仅可以用于评估 TransE ，很多模型也用了这个评估方法。</p><p>假设整个知识库中一共有 n 个实体，那么基本的评估过程如下：</p><ul><li>将一个正确的三元组 a 中的<u>头实体或者尾实体</u>，依次替换为整个知识库中的所有其它实体，也就是会产生 n 个三元组。</li><li>分别对上述 n 个三元组计算其能量值，在 TransE 中，就是计算 <span class="math inline">\(h+\ell-t\)</span> 的值。这样可以得到 n 个能量值，分别对应上述 n 个三元组。</li><li>对上述 n 个能量值进行升序排序。记录三元组 a 的能量值排序后的序号。</li><li>对所有的正确的三元组重复上述过程。</li></ul><p>上述就是评估的过程，共有两个指标：<strong>Mean Rank 和 Hits@10</strong>。每个正确三元组的能量值排序后的序号求平均，得到的值称为 Mean Rank，Mean Rank 越小越好。计算正确三元组的能量排序后的序号小于10的比例，得到的值称为 Hits@10，Hits@10 越大越好。</p><p>但是上述过程存在一个不合理的地方：<u>在将一个正确的三元组a的头或者尾实体替换成其它实体之后得到的这个三元组也有可能是正确的</u>，在计算每个三元组的能量并排序之后，这类正确的三元组的能量有可能排在三元组a的前面。但是上面的基本评估过程并没有考虑这点。因此<strong>把正确的三元组从训练集、验证集、测试集中都删除掉</strong>，从而保证生成的三元组一定是错误的三元组。</p><p>把上述基本评价过程得到的结果称为 <strong>Raw Mean Rank 和 Raw Hits@10</strong>，把过滤掉正确后得到的结果称为 <strong>Filtered Mean Rank 和 Filtered Hits@10</strong>。</p><h3 id="link-prediction">Link prediction</h3><p>实验中使用的 baseline 有：RESCAL、SE、SME（linear）、SME（bilinear）和LFM。RESCAL 通过交替最小二乘法进行训练，而其他方法则通过随机梯度下降法进行训练。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210814141511752.png" /></p><ul><li><p>从链路预测结果中可以看到，TransE 在所有指标上都优于所有对手，而且有很大的差距。</p></li><li><p>有些指标在 Raw 和 Filtered 上表现有些差距，说明过滤掉正确三元组是有必要的。</p></li></ul><p>作者又将链路预测结果进行了关系的分类：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210814153225701.png" /></p><p>表4 通过关系的类型对结果进行了分类，发现： TransE <strong>在处理复杂关系上效果欠佳</strong>（复杂关系通常是指一对多、多对一，多对多三种关系模型）。</p><blockquote><p>给定两个事实（诺兰，导演，信条），（诺兰，导演，盗梦空间），那么网络的目的便是优化嵌入表达使得：诺兰+导演≈信条，诺兰+导演≈盗梦空间，这样一来会使得信条≈盗梦空间，但这两部电影是不同的实体，应该用不同的向量表示。</p></blockquote><h4 id="example-predictions">Example predictions</h4><p>作者展示了几个链路预测结果的例子。给定头实体和关系，预测尾实体。粗体是真实的尾实体，斜体表示训练集中存在的其他真实尾部。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210814175543833.png" /></p><p>即使好的答案并不总是排名靠前，这些预测也说明了TransE能够表示一些常识。</p><h4 id="learning-to-predict-new-relationships-with-few-examples">Learning to predict new relationships with few examples</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210814142644045.png" /></p><p>作者通过检查这些模型学习新关系的速度，来测试这些模型否能够很好地概括新事实。作者使用 <em>FB15k</em> 数据集，将数据集分为 <em>FB15k-40rel</em> 和 <em>Fb15k-rest</em> ，将 <em>FB15k-40rel</em> 分为 训练集(每种关系1000个样本)和测试集，将 <em>Fb15k-rest</em> 分为训练集和验证集。</p><ol type="1"><li>先在 <em>Fb15k-rest</em> 上进行通过训练集和验证集进行模型的训练和选择。</li><li>然后通过 <em>Fb15k-40rel</em> 进行训练让模型，只学习新的40种关系的相关参数。</li><li>最后，在 <em>FB15k-40rel</em> 的测试集进行链路预测评估，评估仅包含在 第1步 中没有发现的关系。</li></ol><p>结果如上图所示，从图中的 Filtered Mean Rank（越小越好） 和 Filtered Hits@10（越大越好）指标可以看到，在没有提供未知关系的样本的情况下，非结构化的性能最好，因为它不使用这些信息进行预测。但是，在提供标记关系的样本时，这种性能并没有提高。而 TransE 是学习最快的模型，只需要新关系的10个例子hits@10 就已经是18%，展现了优秀的性能。</p><h2 id="summary">Summary</h2><p>TransE 简单有效，已经成为知识表示学习的代表模型，并衍生出不同的变体：TransH ，TransR ，TransD ，CTransR ，TransA 等等。</p><p>与以往模型相比，TransE 模型参数较少， 计算复杂度低， 却能直接建立实体和关系之间的复杂语义联系。Bordes 等人在 WordNet 和 Freebase 等数据集上进行链接预测等评测任务， 实验表明 TransE 的性能较以往模型有显著提升。虽然 TransE 算法对知识图谱的表示学习提供了很好的研究思路，但是缺点也很多，比如它只能很好的解决知识图谱中1对1的关系表示，而对于1对多，多对1和多对多的关系类型就无法很好的进行表示。（还有其他的缺点我就不是很了解了...）</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>TransE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transformer：Attention Is All You Need</title>
    <link href="/2021/08/07/Transformer%EF%BC%9AAttention%20Is%20All%20You%20Need/"/>
    <url>/2021/08/07/Transformer%EF%BC%9AAttention%20Is%20All%20You%20Need/</url>
    
    <content type="html"><![CDATA[<h1 id="Transformer：Attention-Is-All-You-Need"><a href="#Transformer：Attention-Is-All-You-Need" class="headerlink" title="Transformer：Attention Is All You Need"></a>Transformer：Attention Is All You Need</h1><div class="note note-primary">            <p>实在是看不动了，留一些坑：</p><p><strong><em>位置编码还未理解。</em></strong>可以研究一下这篇  <a href="https://wmathor.com/index.php/archives/1453/">Transformer 中的 Positional Encoding</a></p><p><a href="https://www.nowcoder.com/discuss/258321">一些关于Transformer的问题整理</a></p><p><a href="http://jalammar.github.io/illustrated-transformer/">图解 Transformer</a></p>          </div><p>Transformer 是谷歌在 2017 年发表的论文 <a href="https://arxiv.org/pdf/1706.03762.pdf">attention is all you need</a> 中所提出的用于机器翻译的模型。</p><p>循环模型通常是对输入和输出序列的符号位置进行因子计算。 通过在计算期间将位置与步骤对齐，它们根据前一步的隐藏状态<em>h**t</em>-1和输入产生位置<em>t</em>的隐藏状态序列<em>h**t</em>。这种固有的顺序特性阻碍样本训练的并行化，这在更长的序列长度上变得至关重要，因为有限的内存限制样本的批次大小。在各种任务中，attention机制已经成为序列建模和转导模型不可或缺的一部分，它可以建模依赖关系而不考虑其在输入或输出序列中的距离</p><p>Transformer，这种模型架构避免循环并完全依赖于attention机制来绘制输入和输出之间的全局依赖关系。</p><h2 id="Transformer-Model"><a href="#Transformer-Model" class="headerlink" title="Transformer Model"></a>Transformer Model</h2><p>这是 Transformer 的整体结构。Transformer 模型主要分为两大部分，分别是 <strong>Encoder</strong> 和 <strong>Decoder</strong>。<strong>Encoder</strong> 负责把输入（语言序列）隐射成隐藏层，然后解码器再把隐藏层映射为自然语言序列。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210731221911908.png" style="zoom: 80%;" /></p><p>如论文中所设置的，编码器由6个编码block组成，同样解码器是6个解码block组成。与所有的生成模型相同的是，编码器的输出会作为解码器的输入，如图所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210801223702902.png" style="zoom: 67%;" /></p><p><strong>编码器：</strong>编码器由 <em>N</em> = 6 个完全相同的层堆叠而成。编码器在结构上都是相同的（但它们不共享权重）。每一层又分为两个子层： 每一层都有两个子层。 第一个子层是一个 multi-head self-attention 机制，第二个子层是一个简单的、位置完全连接的前馈网络。 我们对每个子层再采用一个<strong>残差连接</strong>，接着进行<strong>层标准化</strong>。 也就是说，每个子层的输出是 <code>LayerNorm(x + Sublayer(x))</code>，其中 <code>Sublayer(x)</code> 是由子层本身实现的函数。 为了方便这些残差连接，模型中的所有子层以及嵌入层产生的输出维度都为 $d_{model} = 512$。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210801224428779.png" style="zoom: 67%;" /></p><p><strong>解码器：</strong> 解码器同样由 <em>N</em> = 6 个完全相同的层堆叠而成。除了每个编码器层中的两个子层之外，解码器还插入第三个子层，该层对编码器堆栈的输出执行 multi-head attention。与编码器类似，我们在每个子层再采用<strong>残差连接</strong>，然后进行<strong>层标准化</strong>。此外，还修改解码器堆栈中的 self-attention 子层，以防止位置关注到后面的位置。这种掩码（<strong><em>Masked</em></strong>）结合将输出嵌入偏移一个位置，确保对位置的预测 <em>i</em> 只能依赖小于 <em>i</em> 的已知输出。解码器具有这两层，但它们之间是一个注意力层（<strong><em>Cross Attention</em></strong>），帮助解码器专注于输入句子的相关部分（类似于 seq2seq 模型中的注意力）。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210801224523731.png" alt=""></p><h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210808092314336.png" style="zoom: 67%;" /></p><h3 id="1-位置嵌入-Positional-Encoding"><a href="#1-位置嵌入-Positional-Encoding" class="headerlink" title="1. 位置嵌入 Positional Encoding"></a>1. 位置嵌入 Positional Encoding</h3><p>由于 Transformer 模型<strong>没有</strong>循环神经网络的迭代操作，所以我们必须提供每个字的位置信息给 Transformer，这样它才能识别出语言中的顺序关系。具体地说，位置嵌入会在词向量中加入了单词的位置信息，这样 Transformer 就能区分不同位置的单词了。</p><p>现在定义一个<strong>位置嵌入</strong>的概念，也就是 Positional Encoding，位置嵌入的维度为 <code>[max_sequence_length, embedding_dimension]</code>, 位置嵌入的维度与词向量的维度是相同的，都是 <code>embedding_dimension</code>。</p><p><code>max_sequence_length</code> 属于超参数，指的是限定每个句子最长由多少个词构成</p><p>注意，我们一般以<strong>字</strong>为单位训练 Transformer 模型。首先初始化字编码的大小为 <code>[vocab_size, embedding_dimension]</code>，<code>vocab_size</code> 为字库中所有字的数量，<code>embedding_dimension</code> 为字向量的维度，对应到 PyTorch 中，其实就是 <code>nn.Embedding(vocab_size, embedding_dimension)</code></p><p>论文中使用了 sin 和 cos 函数的线性变换来提供给模型位置信息:</p><script type="math/tex; mode=display">\begin{array}{c}P E(p o s, 2 i)=\sin \left(\frac{p o s}{10000^{\frac{2 i}{d_{\text {model }}}}}\right) \\P E(p o s, 2 i+1)=\cos \left(\frac{\text { pos }}{10000^{\frac{2 i}{d_{\text {model }}}}}\right)\end{array}</script><p>上式中 $pos$ 指的是一句话中某个字的位置，取值范围是 <code>[0,max_sequence_length)</code>，$i$ 指的是字向量的维度序号，取值范围是 <code>[0,embedding_dimension/2)</code>，$d_{model}$ 指的是 embedding_dimension 的值</p><p>上面有 sin 和 cos 一组公式，也就是对应着 embedding_dimension 维度的一组奇数和偶数的序号的维度，例如 0,1 一组，2,3 一组，分别用上面的 sin 和 cos 函数做处理，从而产生不同的周期性变化，而位置嵌入在  embedding_dimension 维度上随着维度序号增大，周期变化会越来越慢，最终产生一种包含位置信息的纹理，就像论文原文中第六页讲的，位置嵌入函数的周期从 $2π$ 到 $10000∗2π$ 变化，而每一个位置在 embedding_dimension 维度上都会得到不同周期的 sin 和 cos 函数的取值组合，从而产生独一的纹理位置信息，最终使得模型学到位置之间的依赖关系和自然语言的时序特性</p><div class="note note-primary">            <p>这块还是不理解，以后还需再学习！(T^T)</p>          </div><h3 id="2-Self-Attention"><a href="#2-Self-Attention" class="headerlink" title="2. Self-Attention"></a>2. Self-Attention</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210801104634603.png" /></p><p>从矩阵运算的角度表示 Self-Attention 运作的过程如下：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210801215613269.png" /></p><p>Self-Attention 的整个计算过程分为以下几步：</p><ol><li>将输入单词转化为嵌入向量 $I$（word embedding）</li><li>根据嵌入向量 $I$ 分别乘上三个权重矩阵 $W_q,W_k,W_v$,  得到 $Q,K, V $ （其中，三个权重矩阵参数是通过学习 data 得到的）</li><li><p>这三个矩阵，接下来 $Q$ 乘上 $K$ 的 $transpose$,得到 $A$，再经过 softmax 归一化（除以 $\sqrt{d_{k}}$）后的 $A’$ 叫做 Attention Matrix，<strong>生成 $Q$ 矩阵就是为了得到 Attention 的 score</strong></p></li><li><p>$A’$ 再乘上 $V$ ，（得到加权的每个输入向量的评分再求和），就得到 $O$，$O$ 就是 Self-attention 这个 layer 的输出</p></li></ol><div class="note note-info">            <h4 id="有关-Query，Key，Value"><a href="#有关-Query，Key，Value" class="headerlink" title="有关 Query，Key，Value"></a>有关 Query，Key，Value</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210920094029271.png" alt="image-20210920094029271" style="zoom:60%;" /></p><p>attention函数共有三步完成得到attention value。</p><ul><li>Q与K进行相似度计算得到权值</li><li>对上部权值归一化</li><li>用归一化的权值与V加权求和</li></ul><p>此时加权求和的结果就为注意力值。公式如下:<script type="math/tex">Attention Value = similarity(QK^T)V</script><br>在自然语言任务中，往往K和V是相同的。这时计算出的 attention value 是一个向量，代表序列元素 $x_j$ 的编码向量。此向量中包含了元素 $x_j$ 的上下文关系，即包含全局联系也拥有局部联系。全局联系是因为在求相似度的时候，序列中元素与其他所有元素的相似度计算，然后加权得到了编码向量。局部联系可以这么解释，因为它所计算出的 attention value 是属于当前输入的 $x_j$ 的。这也就是 attention 的强大优势之一，它可以灵活的捕捉长期和local依赖，而且是一步到位的。</p><p><strong>优点：</strong></p><ol><li><p>一步到位的全局联系捕捉</p><p>上文说了一些，attention机制可以灵活的捕捉全局和局部的联系，而且是一步到位的。另一方面从attention函数就可以看出来，它先是进行序列的每一个元素与其他元素的对比，在这个过程中每一个元素间的距离都是一，因此它比时间序列RNNs的一步步递推得到长期依赖关系好的多，越长的序列RNNs捕捉长期依赖关系就越弱。</p></li><li><p>并行计算减少模型训练时间</p><p>Attention机制每一步计算不依赖于上一步的计算结果，因此可以和CNN一样并行处理。但是CNN也只是每次捕捉局部信息，通过层叠来获取全局的联系增强视野。</p></li><li><p>模型复杂度小，参数少<br>模型复杂度是与CNN和RNN同条件下相比较的。</p></li></ol><p><strong>缺点：</strong></p><p>缺点很明显，attention机制不是一个”distance-aware”的，它不能捕捉语序顺序(这里是语序哦，就是元素的顺序)。这在NLP中是比较糟糕的，自然语言的语序是包含太多的信息。如果确实了这方面的信息，结果往往会是打折扣的。</p>          </div><h4 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h4><script type="math/tex; mode=display">\operatorname{Self-Attention}(Q, K, V)=\operatorname{softmax}  \left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V</script><p>两个最常用的 attention 函数是<u>加法 attention</u> (参考 Bahdanau )和<u>点积（乘法）attention</u>。 除了缩放因子 $\sqrt{d_{k}}$ 之外，点积 attention 与作者提出的 缩放点积 attention 算法相同。 加法 attention 使用具有单个隐藏层的前馈网络计算兼容性函数。 虽然两者在理论上的复杂性相似，但在实践中<strong>点积 attention 的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</strong></p><p>当 $d_k$ 的值比较小的时候，这两个机制的性能相差相近，当 $d_k$ 比较大时，加法 attention 比 不带缩放的点积attention 性能好。 作者怀疑，对于很大的 $d_k$ 值，点积大幅度增长，将 softmax 函数推向具有极小梯度的区域。 为了抵消这种影响，我们缩小点积 $d_k$ 倍。</p><h4 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210731224918618.png" style="zoom: 80%;" /></p><p>这篇论文还提出了 Multi-Head Attention 的概念。前面定义的一组权重矩阵 $W_q,W_k,W_v$, 可以找到一个的词相关的词。现在可以定义多组权重，就可以找到不同的相关性。从 $W_q,W_k,W_v$ 变为 $W_q^1,W_k^1,W_v^1$,  $W_q^2,W_k^2,W_v^2$ …</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210802194319164.png" alt=""></p><h4 id="Attention-在模型中的应用"><a href="#Attention-在模型中的应用" class="headerlink" title="Attention 在模型中的应用"></a>Attention 在模型中的应用</h4><p>Transformer使用以3种方式使用multi-head attention：</p><ul><li>在“编码器—解码器attention”层，query来自上面的解码器层，key和value来自编码器的输出。 这允许解码器中的每个位置能关注到输入序列中的所有位置。 这模仿序列到序列模型中典型的编码器—解码器的attention机制，例如。</li><li>编码器包含self-attention层。 在self-attention层中，所有的key、value和query来自同一个地方，在这里是编码器中前一层的输出。 编码器中的每个位置都可以关注编码器上一层的所有位置。</li><li>类似地，解码器中的self-attention层允许解码器中的每个位置都关注解码器中直到并包括该位置的所有位置。 我们需要防止解码器中的向左信息流来保持自回归属性。 通过屏蔽softmax的输入中所有不合法连接的值（设置为-∞），我们在缩放版的点积attention中实现。</li></ul><h3 id="3-残差连接和-Layer-Normalization"><a href="#3-残差连接和-Layer-Normalization" class="headerlink" title="3. 残差连接和 Layer Normalization"></a>3. 残差连接和 Layer Normalization</h3><p>在上一步得到了经过 Self-Attention 加权之后输出，也就是 $\operatorname{Self-Attention}(Q, K, V)$，然后把他们加起来做残差连接(residual connection)</p><script type="math/tex; mode=display">X_{embedding} + \operatorname{Self-Attention}(Q, K, V)</script><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210807172726267.png" style="zoom:80%;" /></p><p>将 residual 的结果，接着做 Layer Normalization。Layer Normalization 的作用是把神经网络中隐藏层归一为标准正态分布，也就是 $i.i.d$ 独立同分布(independent and identically distributed) ，以起到加快训练速度，加速收敛的作用.</p><p>以矩阵的列 (column) 为单位求<strong>均值</strong>:</p><script type="math/tex; mode=display">\mu_{j}=\frac{1}{m} \sum_{i=1}^{m} x_{i j}</script><p>以矩阵的列（column）为单位求<strong>方差</strong>:</p><script type="math/tex; mode=display">\sigma_{j}^{2}=\frac{1}{m} \sum_{i=1}^{m}\left(x_{i j}-\mu_{j}\right)^{2}</script><p>则 Layer Normalization，即用<strong>每一列</strong>的<strong>每一个元素</strong>减去<strong>这列的均值</strong>，再除以<strong>这列的标准差</strong>，从而得到归一化后的数值，加 $ϵ$ 是为了防止分母为 0</p><script type="math/tex; mode=display">LayerNorm(x)=\frac{x_{i j}-\mu_{j}}{\sqrt{\sigma_{j}^{2}+\epsilon}}</script><div class="note note-info">            <h5 id="batch-normalization-与-layer-normalization"><a href="#batch-normalization-与-layer-normalization" class="headerlink" title="batch normalization 与 layer normalization"></a>batch normalization 与 layer normalization</h5><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210807175718882.png" style="zoom:80%;" /></p><p><strong>batch normalization 是对不同 example,不同 feature 的同一个 dimension,去计算 mean 跟 standard deviation</strong></p><p>但 <strong>layer normalization 是对同一个 feature,同一个 example 里面,不同的 dimension ,去计算 mean 跟 standard deviation</strong></p>          </div><p>下图展示了更多细节：输入 $x_1,x_2$ 经 self-attention 层之后变成 $z_1,z_2$，然后和输入 $x_1,x_2$ 进行残差连接，经过 LayerNorm 后输出给全连接层。全连接层也有一个残差连接和一个 LayerNorm，最后再输出给下一个 Encoder（每个 Encoder Block 中的 FeedForward 层权重都是共享的）</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210807175858497.png" style="zoom:67%;" /></p><h3 id="4-Transformer-Encoder-整体结构"><a href="#4-Transformer-Encoder-整体结构" class="headerlink" title="4. Transformer Encoder 整体结构"></a>4. Transformer Encoder 整体结构</h3><p>经过上面 3 个步骤，我们已经基本了解了 <strong>Encoder</strong> 的主要构成部分，下面我们用公式把一个 Encoder block 的计算过程整理一下：</p><p>1) 字向量与位置编码:</p><script type="math/tex; mode=display">X=\text { Embedding-Lookup }(X)+\text { Positional-Encoding }</script><p>2) 自注意力机制</p><script type="math/tex; mode=display">Q=\operatorname{Linear}_{q}(X)=X W_{Q} \\K=\operatorname{Linear}_{k}(X)=X W_{K} \\V=\operatorname{Linear}_{v}(X)=X W_{V} \\X_{a t t e n t i o n}=\text { Self-Attention }(Q, K, V)</script><p>3) Self-Attention 残差连接，接着 Layer Normalization</p><script type="math/tex; mode=display">X_{\text {attention }}=X+X_{\text {attention }} \\X_{\text {attention }}=\text { LayerNorm }\left(X_{\text {attention }}\right)</script><p>4) 这 Encoder block 结构图中的<strong>第 4 部分</strong>，也就是 FeedForward，其实就是两层线性映射并用激活函数激活，比如 ReLU</p><script type="math/tex; mode=display">X_{\text {hidden }}=\text { Linear }\left(\operatorname{ReLU}\left(\operatorname{Linear}\left(X_{\text {attention }}\right)\right)\right)</script><p>5) FeedForward 残差连接与 Layer Normalization</p><script type="math/tex; mode=display">X_{\text {hidden }}=X_{\text {attention }}+X_{\text {hidden }} \\X_{\text {hidden }}=\text { LayerNorm }\left(X_{\text {hidden }}\right)</script><p>其中</p><script type="math/tex; mode=display">X_{\text {hidden }} \in \mathbb{R}^{\text {batch_size } * \text { seq_len. } * \text { embed_dim }}</script><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>先看一下整体的结构，从上至下分别是：</p><ul><li>Masked Multi-Head Self-Attention</li><li>Multi-Head Encoder-Decoder Attention</li><li>FeedForward Network</li></ul><p>Decoder 和 Encoder 一样，上面三个部分的每一个部分，都有一个残差连接，后接一个 <strong>Layer Normalization</strong>。Decoder 由于其特殊的功能，因此在训练时会涉及到一些细节。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210809113239618.png" style="zoom: 67%;" /></p><h3 id="1-Masked-Self-Attention"><a href="#1-Masked-Self-Attention" class="headerlink" title="1. Masked Self-Attention"></a>1. Masked Self-Attention</h3><p>传统 Seq2Seq 中 Decoder 使用的是 RNN 模型，因此在训练过程中输入 t 时刻的词，模型无论如何也看不到未来时刻的词，因为循环神经网络是时间驱动的，只有当 t 时刻运算结束了，才能看到 t+1 时刻的词。而 Transformer Decoder 抛弃了 RNN，改为 Self-Attention，由此就产生了一个问题，在训练过程中，整个 ground truth 都暴露在 Decoder 中，这显然是不对的，我们需要对 Decoder 的输入进行一些处理，该处理被称为 Mask.</p><p>Masked 就是输出层在计算第 i 个词与其他词的 attention 时，只考虑 i 前面的词，因为 i 后面的词我们不知道是什么，我们需要预测后面的词，如果不掩盖的话，训练的时候相当于模型能看到后面的答案，而我们要求的是， decoder 给定一个开始标志后，一步一步向后计算来预测接下来的单词，所以需要 Mask</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210807151511470.png" alt=""></p><p>举个例子，Decoder 的 ground truth 为 “&lt; start&gt; I am fine”，我们将这个句子输入到 Decoder 中，经过 WordEmbedding 和 Positional Encoding 之后，将得到的矩阵做三次线性变换（$W^q,W^k,W^v$）。然后进行 self-attention 操作，首先通过 $\frac{Q K^{T}}{\sqrt{d_{k}}}$ 得到 Scaled Scores，接下来非常关键，我们要对 Scaled Scores 进行 Mask，举个例子，当我们输入 “I” 时，模型目前仅知道包括 “I” 在内之前所有字的信息，即 “&lt; start&gt;” 和 “I” 的信息，不应该让其知道 “I” 之后词的信息。道理很简单，我们做预测的时候是按照顺序一个字一个字的预测，怎么能这个字都没预测完，就已经知道后面字的信息了呢？Mask 非常简单，首先生成一个下三角全 0，上三角全为负无穷的矩阵，然后将其与 Scaled Scores 相加即可</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210810095712339.png" alt=""></p><p>之后再做 softmax，就能将 - inf 变为 0，得到的这个矩阵即为每个字之间的权重</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210810095741605.png" alt=""></p><h3 id="2-Encoder-Decoder-Attention"><a href="#2-Encoder-Decoder-Attention" class="headerlink" title="2. Encoder-Decoder Attention"></a>2. Encoder-Decoder Attention</h3><p>首先，Encoder 输入一排向量，然后输出一排向量 $a^1,a^2,a^3$。Decoder 输入 BEGIN 这个 Special Token，经过 Masked Self-Attention 后，得到一个向量 $q$。然后 Encoder 这边的 $a^1,a^2,a^3$ 产生 $k^1,k^2,k^3$ 和 $v^1,v^2,v^3$ ，去计算 Attention 的分数，再经过 Softmax 得到 $a_1’,a_2’,a_3’$ ，乘以 $v^1,v^2,v^3$，再把它 Weighted Sum 加起来会得到 v，通过 Fully-Connected Network。这就是 Encoder-Decoder Attention(也叫 Cross Attention)。</p><p>这一部分的计算流程和前面 Masked Self-Attention 很相似，结构也一样，唯一不同的是 <strong>Encoder-Decoder Attention 里的 $K,V$ 为 Encoder 的输出，$Q$ 为 Decoder 中 Masked Self-Attention 的输出</strong></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210809122413314.png" alt=""></p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><h3 id="Transformer-为什么需要进行-Multi-head-Attention？"><a href="#Transformer-为什么需要进行-Multi-head-Attention？" class="headerlink" title="Transformer 为什么需要进行 Multi-head Attention？"></a>Transformer 为什么需要进行 Multi-head Attention？</h3><p>原论文中说到进行 Multi-head Attention 的原因是将模型分为多个头，形成多个子空间，可以让模型去关注不同方面的信息，最后再将各个方面的信息综合起来。其实直观上也可以想到，如果自己设计这样的一个模型，必然也不会只做一次 attention，多次 attention 综合的结果至少能够起到增强模型的作用，也可以类比 CNN 中同时使用<strong>多个卷积核</strong>的作用，直观上讲，多头的注意力<strong>有助于网络捕捉到更丰富的特征 / 信息</strong></p><h3 id="Transformer-相比于-RNN-LSTM，有什么优势？为什么？"><a href="#Transformer-相比于-RNN-LSTM，有什么优势？为什么？" class="headerlink" title="Transformer 相比于 RNN/LSTM，有什么优势？为什么？"></a>Transformer 相比于 RNN/LSTM，有什么优势？为什么？</h3><ol><li>RNN 系列的模型，无法并行计算，因为 T 时刻的计算依赖 T-1 时刻的隐层计算结果，而 T-1 时刻的计算依赖 T-2 时刻的隐层计算结果</li><li>Transformer 的特征抽取能力比 RNN 系列的模型要好</li></ol><h3 id="为什么说-Transformer-可以代替-seq2seq？"><a href="#为什么说-Transformer-可以代替-seq2seq？" class="headerlink" title="为什么说 Transformer 可以代替 seq2seq？"></a>为什么说 Transformer 可以代替 seq2seq？</h3><p>这里用代替这个词略显不妥当，seq2seq 虽已老，但始终还是有其用武之地，seq2seq 最大的问题在于<strong>将 Encoder 端的所有信息压缩到一个固定长度的向量中</strong>，并将其作为 Decoder 端首个隐藏状态的输入，来预测 Decoder 端第一个单词 (token) 的隐藏状态。在输入序列比较长的时候，这样做显然会损失 Encoder 端的很多信息，而且这样一股脑的把该固定向量送入 Decoder 端，<strong>Decoder 端不能够关注到其想要关注的信息</strong>。Transformer 不但对 seq2seq 模型这两点缺点有了实质性的改进 (多头交互式 attention 模块)，而且还引入了 self-attention 模块，让源序列和目标序列首先 “自关联” 起来，这样的话，源序列和目标序列自身的 embedding 表示所蕴含的信息更加丰富，而且后续的 FFN 层也增强了模型的表达能力，并且 Transformer 并行计算的能力远远超过了 seq2seq 系列模型</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote><p>来自李宏毅老师的讲解。希望未来我也可以有这样的疑惑与思考。</p></blockquote><h3 id="1-为什么-transformer-的-encoder-要这么设计？"><a href="#1-为什么-transformer-的-encoder-要这么设计？" class="headerlink" title="1. 为什么 transformer 的 encoder 要这么设计？"></a>1. 为什么 transformer 的 encoder 要这么设计？</h3><p>不一定要这样设计,这个 encoder 的 network 架构,现在设计的方式,本文是按照原始的论文讲给你听的,但<strong>原始论文的设计 不代表它是最好的,最optimal的设计</strong></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210809125324619.png" style="zoom: 67%;" /></p><ul><li>有一篇文章叫 <a href="https://arxiv.org/abs/2002.04745">on layer normalization in the transformer architecture</a>，它问的问题就是为什么 layer normalization是放在那个地方呢？为什么我们是先做 residual 再做 layer normalization，能不能够把 layer normalization 放到每一个 block 的 input？也就是说 你做 residual 以后,再做 layer normalization ,再加进去 你可以看到说左边这个图,是原始的 transformer ,右边这个图是稍微把 block 更换一下顺序以后的 transformer。更换一下顺序以后 结果是会比较好的,这就代表说,原始的 transformer 的架构,并不是一个最 optimal 的设计,你永远可以思考看看,有没有更好的设计方式</li></ul><h3 id="2-为什么是-layer-norm？-为什么是别的-不是别的？为什么不做-batch-normalization？"><a href="#2-为什么是-layer-norm？-为什么是别的-不是别的？为什么不做-batch-normalization？" class="headerlink" title="2. 为什么是 layer norm？ 为什么是别的,不是别的？为什么不做 batch normalization？"></a>2. 为什么是 layer norm？ 为什么是别的,不是别的？为什么不做 batch normalization？</h3><p>也许这篇paper可以回答你的问题,这篇paper是 <a href="https://arxiv.org/abs/2003.07845">Power Norm：,Rethinking Batch Normalization In Transformers</a>,它首先告诉你说 为什么 batch normalization不如,layer normalization. 在 Transformers 里面为什么 batch normalization 不如 layer normalization,接下来在说,它提出来一个 power normalization,一听就是很 power 的意思,都可以比 layer normalization ,还要 performance 差不多或甚至好一点</p><h3 id="3-为什么-Decoder-不管哪一层-都是拿-Encoder-的最后一层的输出？"><a href="#3-为什么-Decoder-不管哪一层-都是拿-Encoder-的最后一层的输出？" class="headerlink" title="3. 为什么 Decoder 不管哪一层,都是拿 Encoder 的最后一层的输出？"></a>3. 为什么 Decoder 不管哪一层,都是拿 Encoder 的最后一层的输出？</h3><p>原始 paper 是这么做的，但是<strong>不一定要这样</strong>。有人尝试不同的 Cross Attension 的方式</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210809125850572.png" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Attention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识图谱构建技术综述</title>
    <link href="/2021/08/01/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/"/>
    <url>/2021/08/01/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="知识图谱构建技术综述">知识图谱构建技术综述</h1><div class="note note-info">            <p>本文是对《知识图谱构建技术综述》这篇综述的略读。</p>          </div><h2 id="知识图谱的定义与架构">1. 知识图谱的定义与架构</h2><h3 id="知识图谱的定义">1.1 知识图谱的定义</h3><p><strong>知识图谱</strong>：是结构化的语义知识库，用于以符号形式描述物理世界中的概念及其相互关 系。其<strong>基本组成单位是“ 实体－关系－实体” 三元组， 以及实体及其相关属性－值对</strong>， 实体间通过关系相互联结，构成网状的知识结构。</p><ol type="1"><li>知识图谱本身是一个具有属性的实体通过关系链接而成的网状知识库。 从图的角度来看， 知识图谱在本质上是一种概念网络， 其中的节点表示物理世界的实体（ 或概念） ， 而实体间的各种语义关系则构成网络中的边。由此， 知识图谱是对物理世界的一种符号表达。</li><li>知识图谱的研究价值在于， 它是构建在当前 Web 基础之上的一层覆盖网络（overlay network），借助知识图谱， 能够在 Web 网页之上建立概念间的链接关系， 从而以最小的代价将互联网中积累的信息组织起来，成为可以被利用的知识．</li><li>知识图谱的应用价值在于， 它能够改变现有的信息检索方式， 一方面通过推理实现概念检索（ 相对于现有的字符串模糊匹配方式而言） ； 另一方面以图形化方式向用户展示经过分类整理的结构化知识， 从而使人们从人工过滤网页寻找答案的模式中解脱出来．</li></ol><h3 id="知识图谱的架构">1.2 知识图谱的架构</h3><p>知识图谱的架构， 包括知识图谱自身的逻辑结构以及构建知识图谱所采用的技术（体系）架构。</p><h4 id="知识图谱的逻辑结构">知识图谱的逻辑结构</h4><p>首先介绍知识图谱的逻辑结构，从逻辑上将知识图谱划分为2个层次：<strong>数据层和模式层</strong>．</p><p>在知识图谱的数据层， 知识以事实（fact）为单位存储在图数据库。例如谷歌的 Graphd 和微软的 Trinity 都是典型的图数据库。如果以“ 实体－关系－实体” 或者“ 实体－属性－性值” 三元组作为事实的基本表达方式，则存储在图数据库中的所有数据将构成庞大的实体关系网络， 形成知识的“图谱”。</p><p>模式层在数据层之上， 是知识图谱的核心。在模式层存储的是经过提炼的知识， 通常采用本体库来管理知识图谱的模式层， 借助本体库对公理、 规则和约束条件的支持能力来规范实体、 关系以及实体的类型和属性等对象之间的联系． 本体库在知识图谱中的地位相当于知识库的模具， 拥有本体库的知识库冗余知识较少．</p><h4 id="构建知识图谱的所采用的技术架构">构建知识图谱的所采用的技术架构</h4><p>从知识图谱构建的角度， 介绍知识图谱的一般技术架构。图1给出了知识图谱技术的整体架构， 其中虚线框内的部分为知识图谱的构建过程，同时也是知识图谱更新的过程. 如图1所示， 知识图谱的构建过程是从原始数据出发， 采用一系列自动或半自动的技术手段， 从原始数据中提取出知识要素（即事实） ， 并将其存入知识库的数据层和模式层的过程． 这是一个迭代更新的过程， 根据知识获取的逻辑， 每一轮迭代包含3个阶段： 信息抽取、 知识融合以及知识加工。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210814221531962.png" /></p><p>知识图谱有自顶向下和自底向上2种构建方式． 所谓自顶向下构建是指借助百科类网站等结构 化数据源， 从高质量数据中提取本体和模式信息， 加入到知识库中； 所谓自底向上构建， 则是借助一定的技术手段， 从公开采集的数据中提取出资源模式， 选择其中置信度较高的新模式， 经人工审核之后， 加入到知识库中．本文主要介绍自底向上的知识图谱构建技术， 按照知识获取的过程分为３个层次： 信息抽取、 知识融合以及知识加工．</p><h2 id="知识图谱的构建技术">2. 知识图谱的构建技术</h2><p>采用自底向上的方式构建知识图谱的过程是一个迭代更新的过程， 每一轮更新包括3个步骤：</p><ol type="1"><li><strong>信息抽取</strong>， 即从各种类型的数据源中提取出实体（ 概念） 、 属性以及实体间的相互关系， 在此基础上形成本体化的知识表达；</li><li><strong>知识融合</strong>， 在获得新知识之后， 需要对其进行整合， 以消除矛盾和歧义， 比如某些实体可能有多种表达， 某个特定称谓也许对应于多个不同的实体等；</li><li><strong>知识加工</strong>， 对于经过融合的新知识， 需要经过质量评估之后（部分需要人工参与甄别） ， 才能将合格的部分加入到知识库中，以确保知识库的质量． 新增数据之后， 可以进行知识推理、 拓展现有知识、 得到新知识</li></ol><h3 id="信息抽取">2.1 信息抽取</h3><p>信息抽取（information extraction） 是知识图谱构建的第1步，其中的关键问题是如何从异构数据源中自动抽取信息得到候选知识单元。信息抽取是一种自动化地从半结构化和无结构数据中抽取实体、 关系以及实体属性等结构化信息的技术。涉及的关键技术包括： <strong>实体抽取、 关系抽取和属性抽取．</strong></p><h4 id="实体抽取-ner">2.1.1 实体抽取 NER</h4><p><strong>实体抽取， 也称为命名实体识别（named entity recognition），是指从文本数据集中自动识别出命名实体。</strong>实体抽取的质量（ 准确率和召回率） 对后续的知识获取效率和质量影响极大， 因此是信息抽取中最为基础和关键的部分．</p><p>在面向开放域的实体识别和分类研究中，不需要（也不可能）为每个领域或每个实体类别建立单独的语料库作为训练集．因此，该领域面临的主要挑战是<strong>如何从给定的少量实体实例中自动发现具有区分力的模式</strong>．针对该问题，Whitelaw等人提出了一种<u>迭代扩展实体语料库的解决方案，基本思路是根据已知的实体实例进行特征建模，利用该模型对处理海量数据集得到新的命名实体列表，然后针对新实体建模，迭代地生成实体标注语料库</u>．另一种思路是<u>通过搜索引擎的服务器日志获取新出现的命名实体</u>．例如Jain等人提出了一种面向开放域的无监督学习算法，<u>即事先并不给出实体分类，而是基于实体的语义特征从搜索日志中识别出命名实体，然后采用聚类算法对识别出的实体对象进行聚类</u>，该方法已经在搜索引擎技术中得到应用，用于根据用户输入的关键字自动补全信息．</p><h4 id="关系抽取">2.1.2 关系抽取</h4><p><strong>关系抽取：文本语料经过实体抽取， 得到的是一系列离散的命名实体，为了得到语义信息，还需要从相关语料中提取出实体之间的关联关系， 通过关系将实体（ 概念） 联系起来， 才能够形成网状的知识结构。</strong> 研究关系抽取技术的目的， 就是解决如何从文本语料中抽取实体间的关系这一基本问题。</p><h4 id="属性抽取">2.1.3 属性抽取</h4><p><strong>属性抽取的目标是从不同信息源中采集特定实体的属性信息．</strong>例如针对某个公众人物，可以从网络公开信息中得到其昵称、生日、国籍、教育背景等信息。属性抽取技术能够从多种数据来源中汇集这些信息，实现对实体属性的完整勾画。</p><p>尽管可以从百科类网站获取大量实体属性数据，然而这只是人类知识的冰山一角，还有大量的实体属性数据隐藏在非结构化的公开数据中。<strong>如何从海量非结构化数据中抽取实体属性是值得关注的理论研究问题</strong>：一种解决方案是<u>基于百科类网站的半结构化数据，通过自动抽取生成训练语料，用于训练实体属性标注模型，然后将其应用于对非结构化数据的实体属性抽取</u>；另一种方案是<u>采用数据挖掘的方法直接从文本中挖掘实体属性与属性值之间的关系模式，据此实现对属性名和属性值在文本中的定位。</u>这种方法的基本假设是属性名和属性值之间有位置上的关联关系，事实上在真实语言环境中，许多实体属性值附近都存在一些用于限制和界定该属性值含义的关键词（属性名），在自然语言处理技术中将这类属性称为有名属性，因此可以利用这些关键字来定位有名属性的属性值．</p><h3 id="知识融合">2.2 知识融合</h3><p>通过信息抽取，实现了从非结构化和半结构化数据中获取实体、关系以及实体属性信息的目标，然而，这些结果中可能包含大量的冗余和错误信息，数据之间的关系也是扁平化的，缺乏层次性和逻辑性，因此有必要对其进行清理和整合．知识融合包括2部分内容：实体链接和知识合并。通过知识融合，可以消除概念的歧义，剔除冗余和错误概念，从而确保知识的质量．</p><h4 id="实体链接">2.2.1 实体链接</h4><p><strong>实体链接（entity linking）：是指对于从文本中抽取得到的实体对象，将其链接到知识库中对应的正确实体对象的操作</strong>。实体链接的基本思想是首先根据给定的实体指称项，从知识库中选出一组候选实体对象，然后通过相似度计算将指称项链接到正确的实体对象。早期的实体链接研究仅关注如何将从文本中抽取到的实体链接到知识库中，忽视了位于同一文档的实体间存在的语义联系，近年来学术界开始关注利用实体的共现关系，同时将多个实体链接到知识库中，称为集成实体链接（collective entity linking）．例如等人提出的基于图的集成实体链接方法，能够有效提高实体链接的准确性．</p><blockquote><p><strong>指称项：</strong></p><p>例如：红利小学篮球教练张三出席了会议，他在会议上分享了执教心得。</p><p>实体“张三”就有三个指称项，“红利小学篮球教练”是名词性指称项；“张平”是命名性指称项；“他”是代词性指称项。</p></blockquote><p>实体链接的一般流程是：</p><ol type="1"><li>从文本中通过实体抽取得到实体指称项；</li><li>进行实体消歧和共指消解，判断知识库中的同名实体与之是否代表不同的含义以及知识库中是否存在其他命名实体与之表示相同的含义；</li><li>在确认知识库中对应的正确实体对象之后，将该实体指称项链接到知识库中对应实体．</li></ol><h5 id="实体消歧">1. 实体消歧</h5><p><strong>实体消歧（entity disambiguation）是专门用于解决同名实体产生歧义问题的技术</strong>．在实际语言环境中，经常会遇到某个实体指称项对应于多个命名实体对象的问题，例如“李娜”这个名词（指称项）可以对应于作为歌手的李娜这个实体，也可以对应于作为网球运动员的李娜这个实体，通过实体消歧，就可以根据当前的语境，准确建立实体链接．实体消歧主要采用聚类法。聚类法是指以实体对象为聚类中心，将所有指向同一目标实体对象的指称项聚集到以该对象为中心的类别下．聚类法消歧的关键问题是如何定义实体对象与指称项之间的相似度，常用方法有4种：</p><ol type="1"><li><strong>空间向量模型（词袋模型）</strong>．典型的方法是取当前语料中实体指称项周边的词构成特征向量，然后利用向量的余弦相似度进行比较，将该指称项聚类到与之最相近的实体指称项集合中．然而该方法的缺点在于没有考虑上下文语义信息，这种信息损失会导致在某些情况下算法性能恶化，如短文本分析．</li><li><strong>语义模型．</strong> 该模型与空间向量模型类似， 区别在于特征向量的构造方法不同，语义模型的特征向量不仅包含词袋向量，而且包含一部分语义特征．例如Pedersen等人采用奇异值分解技术对文本向量空间进行分解，得到给定维度的浅层语义特征，以此与词袋模型相结合，能够得到更精确的相似度计算结果．</li><li><strong>社会网络模型</strong>．该模型的基本假设是物以类聚、人以群分，在社会化语境中，实体指称项的意义在很大程度上是由与其相关联的实体所决定的．建模时，首先利用实体间的关系将与之相关的指称项链接起来构成网络，然后利用社会网络分析技术计算该网络中节点之间的拓扑距离（网络中的节点即实体的指称项），以此来判定指称项之间的相似度．</li><li><strong>百科知识模型</strong>．百科类网站通常会为每个实体（指称项）分配一个单独页面，其中包括指向其他实体页面的超链接，百科知识模型正是利用这种链接关系来计算实体指称项之间的相似度．然而，由于百科类知识库中的实体数非常有限，此类方法的推广性较差．</li></ol><p>实体消歧技术能够帮助搜索引擎更好地理解用户的搜索意图，从而给出更好的上下文推荐结果，提高搜索服务质量．其中还有<strong>一个很重要的问题是如何对存在歧义的实体进行重要性评估，以确定推荐内容的优先级．</strong>当前的主要研究思路是为实体赋予权重，用于表示该实体出现的频率或先验概率．</p><h5 id="共指消解">2. 共指消解</h5><p><strong>共指消解（entity resolution）技术主要用于解决多个指称项对应于同一实体对象的问题．</strong>例如在一篇新闻稿中，“Barack Obama”，“president Obama”，“the president”等指称项可能指向的是同一实体对象，其中的许多代词如“he”，“him”等，也可能指向该实体对象．利用共指消解技术，可以将这些指称项关联（合并）到正确的实体对象．由于该问题在信息检索和自然语言处理等领域具有特殊的重要性，吸引了大量的研究努力，因此学术界对该问题有多种不同的表述，典型的包括：对象对齐（object alignment）、实体匹配（entity matching）以及实体同义（entity synonyms）．</p><h4 id="知识合并">2.2.2 知识合并</h4><p>在构建知识图谱时， 可以从第三方知识库产品或已有结构化数据获取知识输入</p><ol type="1"><li><p>合并外部知识库</p><p>将外部知识库融合到本地知识库需要处理2个层面的问题．①数据层的融合，包括实体的指称、属性、关系以及所属类别等，主要的问题是如何避免实例以及关系的冲突问题，造成不必要的冗余；②通过模式层的融合，将新得到的本体融入已有的本体库中</p></li><li><p>合并关系数据库</p><p>在知识图谱构建过程中，一个重要的高质量知识来源是企业或者机构自己的关系数据库．为了将这些结构化的历史数据融入到知识图谱中，可以采用资源描述框架（RDF）作为数据模型业界和学术界将这一数据转换过程形象地称为 RDB@RDF， 其实质就是将关系数据库的数据换成 RDF 的三元组数据．</p></li></ol><h3 id="知识加工">2.3 知识加工</h3><p>通过信息抽取，可以从原始语料中提取出实体、关系与属性等知识要素．再经过知识融合，可以消除实体指称项与实体对象之间的歧义，得到一系列基本的事实表达．然而，事实本身并不等于知识，要想最终获得结构化、网络化的知识体系，还需要经历知识加工的过程．<strong>知识加工主要包括3方面内容：本体构建、知识推理和质量评估．</strong></p><h4 id="本体构建">2.3.1 本体构建</h4><p>本体（ontology）是对概念进行建模的规范，是描述客观世界的抽象模型，以形式化方式对概念及其之间的联系给出明确定义．本体的最大特点在于它是共享的，本体中反映的知识是一种明确定义的共识．虽然在不同时代和领域，学者们对本体曾经给出过不同的定义，但这些定义的内涵是一致的，即：<strong>本体是同一领域内的不同主体之间进行交流的语义基础</strong>．本体是树状结构，相邻层次的节点（概念）之间具有严格的“Is A”关系，这种单纯的关系有助于知识推理，但却不利于表达概念的多样性．在知识图谱中，本体位于模式层，用于描述概念层次体系是知识库中知识的概念模板。</p><p>本体可以采用人工编辑的方式手动构建（借助 本体编辑软件），也可以采用计算机辅助，以数据驱 动的方式自动构建，然后采用算法评估和人工审核 相结合的方式加以修正和确认．对于特定领域而言， 可以采用领域专家和众包的方式人工构建本体．然 而对于跨领域的全局本体库而言，采用人工方式不 仅工作量巨 大，而且很难找到符合要求的专家．因 此，当前主流的全局本体库产品，都是从一些面向特 定领域的现有本体库出发，采用自动构建技术逐步扩展得到的．</p><h4 id="知识推理">2.3.2 知识推理</h4><p><strong>知识推理是指从知识库中已有的实体关系数据出发，经过计算机推理，建立实体间的新关联，从而拓展和丰富知识网络．知识推理是知识图谱构建的重要手段和关键环节，通过知识推理，能够从现有知识中发现新的知识</strong>．知识的推理方法可以分为２大类： 基于逻辑的推理和基于图的推理．</p><h4 id="质量评估">2.3.3 质量评估</h4><p>质量评估也是知识库构建技术的重要组成部分．</p><ol type="1"><li>受现有技术水平的限制，采用开放域信息抽取技术得到的知识元素有可能存在错误（如实体识别错误、关系抽取错误等），经过知识推理得到的知识的质量同样也是没有保障的，因此在将其加入知识库之前，需要有一个质量评估的过程；</li><li>随着开放关联数据项目的推进，各子项目所产生的知识库产品间的质量差异也在增大，数据间的冲突日益增多，如何对其质量进行评估，对于全局知识图谱的构建起着重要的作用．</li></ol><p>引入质量评估的意义在于：可以对知识的可信度进行量化，通过舍弃置信度较低的知识，可以保障知识库的质量</p><h3 id="知识更新">2.4 知识更新</h3><p>知识图谱的内容需要与时俱进，其构建过程是一个不断迭代更新的过程．从逻辑上看，知识库的更新包括概念层的更新和数据层的更新。概念层的更新是指新增数据后获得了新的概念，需要自动将新的概念添加到知识库的概念层中。数据层的更新主要是新增或更新实体、关系和属性值，对数据层进行更新需要考虑数据源的可靠性、数据的一致性（是否存在矛盾或冗余等问题）等多方面因素。</p><h2 id="跨语言知识图谱的构建">3. 跨语言知识图谱的构建</h2><p>跨语言知识图谱可以应用于跨语言的信息检索、机器翻译以及跨语言知识问答等。构建跨语言的知识图谱需要处理好３个关键问题：</p><ol type="1"><li>跨语言本体的构建</li><li>跨语言知识抽取</li><li>跨语言知识链接．</li></ol><h2 id="知识图谱的应用">4. 知识图谱的应用</h2><p>目前知识图谱技术主要用于智能语义搜索、移动个人助理以及深度问答系统等等，支撑这些应用的核心技术正是知识图谱技术...</p><blockquote><p>然后介绍了这些任务是如何实现的，我也看不懂...</p></blockquote><h2 id="问题与挑战">5. 问题与挑战</h2><p>在知识图谱构建的各关键环节都面临着一些巨大的困难和挑战．</p><ol type="1"><li>在信息抽取环节，面向开放域的信息抽取方法研究还处于起步阶段，部分研究成果虽然在特定（语种、领域、主题等）数据集上取得了较好的结果，但普遍存在算法准确性和召回率低、限制条件多、扩展性不好的问题.因此，要想建成面向全球的知识图谱，第1个挑战来自开放域信息抽取，<strong>主要的问题包括实体抽取、关系抽取以及属性抽取</strong>。其中，多语种、开放领域的纯文本信息抽取问题是当前面临的重要挑战</li><li>知识融合环节，<strong>如何实现准确的实体链接</strong>是一个主要挑战．虽然关于实体消歧和共指消解技术的研究已经有很长的历史，然而迄今为止所取得的研究成果距离实际应用还有很大距离．主要的研究问题包括开放域条件下的实体消歧、共指消解、外部知识库融合和关系数据库知识融合等问题．当前受到学术界普遍关注的问题是<strong>如何在上下文信息受限（短文本、跨语境、跨领域等）条件下，准确地将从文本中抽取得到的实体正确链接到知识库中对应的实体．</strong></li><li>知识加工是最具特色的知识图谱技术，同时也是该领域最大的挑战之所在．主要的研究问题包括：本体的自动构建、知识推理技术、知识质量评估手段以及推理技术的应用。目前，本体构建问题的研究焦点是聚类问题，对知识质量评估问题的研究则主要关注建立完善的质量评估技术标准和指标体系．<u>知识推理的方法和应用研究是当前该领域最为困难，同时也是最为吸引人的问题</u>，<strong>需要突破现有技术和思维方式的限制</strong>，知识推理技术的创新也将对知识图谱的应用产生深远影响．</li><li>知识更新环节，<strong>增量更新技术</strong>是未来的发展方向，然而现有的知识更新技术严重依赖人工干预．可以预见随着知识图谱的不断积累，依靠人工制定更新规则和逐条检视的旧模式将会逐步降低比重，自动化程度将不断提高，如何确保自动化更新的有效性，是该领域面临的又一重大挑战．</li><li>最具基础研究价值的挑战是如何解决知识的表达、存储与查询问题，这个问题将伴随知识图谱技术发展的始终，对该问题的解决将反过来影响前面提出的挑战和关键问题．<strong>当前的知识图谱主要采用图数据库进行存储，在受益于图数据库带来的查询效率的同时，也失去了关系型数据库的优点</strong>，如 SQL 语言支持和集合查询效率等．在查询方面，如何处理自然语言查询，对其进行分析推理，翻译成知识图谱可理解的查询表达式以及等价表达式等也都是知识图谱应用需解决的关键问题</li></ol><blockquote><p>知识图谱真难！自然语言处理真难！大哭😭</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS224n 01 Introduction and Word Vectors</title>
    <link href="/2021/07/29/CS224n%2001%20Introduction%20and%20Word%20Vectors/"/>
    <url>/2021/07/29/CS224n%2001%20Introduction%20and%20Word%20Vectors/</url>
    
    <content type="html"><![CDATA[<h1 id="cs224n-01-introduction-and-word-vectors">CS224n 01 Introduction and Word Vectors</h1><p>NLP——Natural Language Processing，其中Natural Language指的就是human language。Human language想一想真的很奇妙，仅仅用纸张上的抽象文字就能指代实际的物理事物以及其他抽象概念，而想让机器理解人类的语言是一项很复杂的任务，而且有很多有趣又实用的研究方向如 Machine Translation，Semantic Analysis，Question Answering 等等。</p><p>其中一个基本的问题就是我们如何表示一个单词的含义(meaning of a word)。</p><h2 id="wordnet">WordNet</h2><p>著名的WordNet，它被称为是NLP中的瑞士军刀，下图展示了通过调取wordnet工具包查询一个词的相关信息：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210811124440299.png" /></p><p>WordNet 的构建花费了很多人多年时间，是对 NLP 领域伟大的贡献。但是我们现在实际上很少使用它了，因为它有这么几个缺陷：</p><ul><li>缺乏词汇之间的差别的刻画</li><li>不能计算精确的相似度</li><li>词汇永远不会完整，且难以更新</li></ul><h2 id="one-hot-vector">one-hot vector</h2><p><strong>Representing words as discrete symbols</strong></p><p>在传统的自然语言处理中，我们把词语看作离散的符号。单词可以通过<strong>独热向量(one-hot vectors，只有一个1，其余均为0的稀疏向量) 。向量维度=词汇量</strong>。 <span class="math display">\[\begin{aligned}motel  &amp;=\left[\begin{array}{llllllllllllll}0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\end{array}\right] \\hotel  &amp;=\left[\begin{array}{llllllllllll}0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\end{array}\right]\end{aligned}\]</span> <strong>Problem with words as discrete symbols</strong></p><ul><li><p>词汇太多，用one-hot表示<strong>太稀疏</strong>，向量维度过大</p></li><li><p>所有向量是正交的。由于任意两个不同词的独热向量之间的余弦相似度为0，所以独热向量不能编码词之间的相似性。对于独热向量，<strong>没有关于相似性概念</strong>。</p></li></ul><h2 id="word-embedding">Word Embedding</h2><p>之前的 one-hot vector 是一种 sparse vector，我们想要构建的是 dense vector，即大多数元素不为零且维度较小的向量，并且希望在相似的 context 下的 word vector 也较为相似。</p><p><strong>Representing words by their context</strong></p><ul><li><u>Distributional semantics</u>：<strong>一个单词的意思是由经常出现在它附近的单词给出的</strong><ul><li><em>“You shall know a word by the company it keeps”</em> (J. R. Firth 1957: 11)</li><li>现代统计NLP最成功的理念之一</li></ul></li><li>当一个单词 <span class="math inline">\(w\)</span> 出现在文本中时，它的上下文是出现在其附近的一组单词(在一个固定大小的窗口中)。</li><li>使用 <span class="math inline">\(w\)</span> 的许多上下文来构建 <span class="math inline">\(w\)</span> 的表示</li></ul><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210729225215683.png" /></p><p>我们为每个单词构建一个 <strong>密集</strong> 的向量，使其与出现在相似上下文中的单词向量相似。</p><p>词向量 <strong><em>word vectors</em></strong> 有时被称为词嵌入 <strong><em>word embeddings</em></strong> 或词表示 <strong><em>word representations</em></strong>。它们是分布式表示 <strong><em>distributed representation</em></strong>。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210729231215648.png" style="zoom:80%;" /></p><h3 id="什么是-word-embedding">什么是 Word Embedding？</h3><p>要理解这个概念，先理解什么是 Emdedding？Embedding 在数学上表示一个 maping, f: X -&gt; Y， 也就是一个 function，其中该函数是 injective（就是我们所说的单射函数，每个 Y 只有唯一的 X 对应，反之亦然）和 structure-preserving (结构保存，比如在 X 所属的空间上X1 &lt; X2,那么映射后在 Y 所属空间上同理 Y1 &lt; Y2)。 <strong>那么对于 word embedding，就是将单词 word 映射到另外一个空间，其中这个映射具有 injective 和 structure-preserving 的特点。</strong> 通俗的翻译可以认为是单词嵌入，就是把 X 所属空间的单词映射为到 Y 空间的多维向量，那么该多维向量相当于嵌入到 Y 所属空间中，一个萝卜一个坑。word embedding，就是找到一个映射或者函数，生成在一个新的空间上的表达，该表达就是 word representation。</p><h3 id="有哪些类型的-word-embeddings">有哪些类型的 Word Embeddings？</h3><p>目前主要分为两类：</p><ul><li>Frequency based Embedding<ul><li>Count Vector</li><li>TF-IDF Vector</li><li>Co-Occurrence Vector 共现向量</li></ul></li><li>Prediction based Embedding(Word2vec)<ul><li>COBW（Continuous Bag of words）根据上下文来预测一个单词</li><li>Skip-gram 根据一个单词来预测上下文</li></ul></li></ul><p><strong>Frequency based Embedding 就是基于词频统计的映射方式，主要有以下三种：</strong></p><ul><li><p>Count Vector 这种就是最简单，最基本的词频统计算法：比如我们有N个文本（document），我们统计出所有文本中不同单词的数量，结果组成一个矩阵。那么每一列就是一个向量，表示这个单词在不同的文档中出现的次数。</p></li><li><p>TF-IDF Vector TF-IDF 方法基于前者的算法进行了一些改进，它的计算公式如下： <span class="math display">\[{\mathrm  {tfidf_{ {i,j} } } }  ={\mathrm  {tf_{ {i,j} } } } \times {\mathrm  {idf_{ {i} } } }\]</span> 其中，<span class="math inline">\(tf_{i,j}\)</span>（term-frequence）指的是第 <span class="math inline">\(i\)</span> 个单词在第 <span class="math inline">\(j\)</span> 个文档中出现的频次；而 <span class="math inline">\(idf_i\)</span> (inverse document frequency)的计算公式如下： <span class="math display">\[{\mathrm idf_{i} = \log(N/n)}\]</span> 其中，N 表示文档的总个数，n 表示包含该单词的文档的数量。这个公式是什么意思呢？其实就是一个权重，设想一下如果一个单词在各个文档里都出现过，那么 <span class="math inline">\(N/n=1\)</span>，所以 <span class="math inline">\(idf_i=0\)</span>。这就意味着这个单词并不重要。这个东西其实很简单，就是在 term-frequency 的基础上加了一个权重，从而显著降低一些不重要/无意义的单词的 frequency，比如 a,an,the 等。</p></li><li><p>Co-Occurrence Vector 共现向量 这个比较有意思，中文直译过来就是协同出现向量。在解释这个概念之前，我们先定义两个变量：</p><ul><li><p>Co-occurrence 协同出现指的是两个单词 <span class="math inline">\(w1\)</span> 和 <span class="math inline">\(w_2\)</span> 在一个 Context Window 范围内共同出现的次数</p></li><li><p>Context Window</p><p>指的是某个单词 <span class="math inline">\(w\)</span> 的上下文范围的大小，也就是前后多少个单词以内的才算是上下文？比如一个Context Window Size = 2的示意图如下：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210831141820473.png" /></p><p>比如我们有如下的语料库：<em>He is not lazy. He is intelligent. He is smart.</em>​</p><p>我们假设Context Window=2，那么我们就可以得到如下的co-occurrence matrix</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210831141913892.png" /></p><p>这个方法比之前两个都要进步一点，为什么呢？ <strong>因为它不再认为单词是独立的，而考虑了这个单词所在附近的上下文，这是一个很大的突破。</strong> 如果两个单词经常出现在同一个上下文中，那么很可能他们有相同的含义。比如vodka和brandy可能经常出现在wine的上下文里，那么在这两个单词相对于wine的co-occurrence就应该是相近的，于是我们就可以认为这两个单词的含义是相近的。</p></li></ul></li></ul><h2 id="word2vec">Word2Vec</h2><p><strong><em>Word2vec</em></strong> (Mikolov et al. 2013)是一个学习单词向量的 <strong>框架</strong></p><p><strong>IDEA</strong>：</p><ul><li>我们有大量的文本 (corpus means 'body' in Latin. 复数为corpora)</li><li>固定词汇表中的每个单词都由一个向量表示</li><li>文本中的每个位置 <span class="math inline">\(t\)</span>，其中有一个中心词 <span class="math inline">\(c\)</span> 和上下文(“外部”)单词 <span class="math inline">\(o\)</span></li><li>使用 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(o\)</span> 的 <strong>词向量的相似性</strong> 来计算给定 <span class="math inline">\(c\)</span> 的 <span class="math inline">\(o\)</span> 的 <strong>概率</strong> (反之亦然)</li><li><strong>不断调整词向量</strong> 来最大化这个概率</li></ul><p>下图为窗口大小 <span class="math inline">\(j=2\)</span> 时的 <span class="math inline">\(P(w_{t+j}|w_t)\)</span> 计算过程，center word 分别为 <span class="math inline">\(into\)</span> 和 <span class="math inline">\(banking\)</span></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210729232018361.png" /></p><h3 id="word2vec-model">word2vec model</h3><p>2013 年，Google 团队发表了 word2vec 工具。word2vec 词向量可以较好地表达不同词之间的相似度和类比关系。word2vec 是一个软件包,实际上包含：</p><ul><li><strong>两个算法模型</strong>：<strong>continuous bag-of-words（CBOW）</strong>和 <strong>skip-gram</strong>。CBOW 是根据中心词周围的上下文单词来预测该词的词向量。skip-gram 则相反，是根据中心词预测周围上下文的词的概率分布。</li><li><strong>两个训练方法</strong>：<strong>负采样（negative sampling）</strong>和<strong>层序 softmax（hierarchical softmax）</strong>。Negative sampling 通过抽取负样本来定义目标，hierarchical softmax 通过使用一个有效的树结构来计算所有词的概率来定义目标。</li></ul><p>对于在语义上有意义的表示，它们的训练依赖于条件概率，条件概率可以被看作是使用语料库中一些词来预测另一些单词。由于是不带标签的数据，因此跳字模型和连续词袋模型都是<strong>自监督模型</strong>。</p><h4 id="skip-gram-跳字模型">skip-gram 跳字模型</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210811211150440.png" style="zoom:67%;" /></p><p>在<strong>跳字模型中，我们用一个词来预测它在文本序列周围的词。</strong>例如，给定文本序列 &quot;the&quot;,&quot;man&quot;,&quot;loves&quot;,&quot;his&quot;,&quot;son&quot;。设背景窗口大小为 2， 跳字模型所关心的是，给定 &quot;loves&quot;，生成它邻近词 &quot;the&quot;,&quot;man&quot;.&quot;his&quot;,&quot;son&quot; 的概率（在这个例子中，&quot;loves&quot; 叫中心词，&quot;the&quot;,&quot;man&quot;,&quot;his&quot;,&quot;son&quot; 叫背景词），即 <span class="math display">\[P(\textrm{&quot;the&quot;},\textrm{&quot;man&quot;},\textrm{&quot;his&quot;},\textrm{&quot;son&quot;}\mid\textrm{&quot;loves&quot;}).\]</span> 假设在给定中心词的情况下，上下文词的生成是相互独立的，那么上式可以改写成 <span class="math display">\[P(\textrm{&quot;the&quot;}\mid\textrm{&quot;loves&quot;})\cdot P(\textrm{&quot;man&quot;}\mid\textrm{&quot;loves&quot;})\cdot P(\textrm{&quot;his&quot;}\mid\textrm{&quot;loves&quot;})\cdot P(\textrm{&quot;son&quot;}\mid\textrm{&quot;loves&quot;}).\]</span> 对于每个位置 <span class="math inline">\(t=1,…,T\)</span> ，在大小为 <span class="math inline">\(m\)</span> 的固定窗口内预测上下文单词，给定中心词 <span class="math inline">\(w_j\)</span></p><p><span class="math display">\[\text { Likelihood }=L(\theta)=\prod_{t=1}^{T} \prod_{-m \leq j \leq m} P\left(w_{t+j} \mid w_{t} ; \theta\right)\]</span></p><ul><li>其中，<span class="math inline">\(θ\)</span> 为所有需要优化的变量</li></ul><p><strong>跳字模型参数是词表中每个词的中心词向量和上下文词向量。</strong>在训练中，我们通过最大化似然函数(即最大似然估计)来学习模型参数。这相当于最小化以下损失函数。损失函数 <span class="math inline">\(J(\theta)\)</span> 是(平均)负对数似然函数： <span class="math display">\[J(\theta)=-\frac{1}{T} \log L(\theta)=-\frac{1}{T} \sum_{t=1}^{T} \sum_{-m \leq j \leq m \atop j \neq 0} \log P\left(w_{t+j} | w_{t} ; \theta\right)\]</span> 其中 <span class="math inline">\(log\)</span> 形式是方便将连乘转化为求和，负号是希望将 极大化似然率 转化为 极小化损失函数 的等价问题。</p><blockquote><p>在连乘之前使用 <span class="math inline">\(log\)</span> 转化为求和非常有效，特别是在做优化时 <span class="math display">\[\log \prod_{i} x_{i}=\sum_{i} \log x_{i}\]</span></p></blockquote><p>我们的目的是 <strong>最小化目标函数 ⇔ 最大化预测精度</strong>，那么如何计算 <span class="math inline">\(P(w_{t+j}|w_t;θ)\)</span> ？</p><p><strong>答</strong>：对于每个单词都是用两个向量</p><ul><li><span class="math inline">\(\boldsymbol v\)</span> 代表中心词的词向量</li><li><span class="math inline">\(\boldsymbol u\)</span> 代表上下文词的词向量</li></ul><p>换言之，对于词典中一个索引为 <span class="math inline">\(i\)</span> 的词，它本身有两个向量 <span class="math inline">\(\boldsymbol v_i\)</span> 和 <span class="math inline">\(\boldsymbol u_i\)</span> 进行表示，在计算的过程中，根据其所处的角色不同，选择不同的词向量。<strong>词典中所有词的这两种向量正是跳字模型所需要学习的参数</strong>。为了将模型参数植入损失函数，我们需要使用模型参数表达损失函数中的中心词生成上下文单词的概率。假设中心词的概率是相互独立的。给定<u>中心词 <span class="math inline">\(w_c\)</span></u> 在词典中的索引为 <span class="math inline">\(c\)</span>，<u>上下文单词 <span class="math inline">\(w_o\)</span></u> 在词典中的索引为 <span class="math inline">\(o\)</span>，损失函数中，中心词生成上下文单词的概率可以使用 softmax 函数进行定义： <span class="math display">\[P(w_o|w_c)=\frac{\exp(\boldsymbol{u}_o^T\boldsymbol {v}_c)}{\sum_{i\in V}\exp(\boldsymbol{u}_i^T\boldsymbol{v}_c)}\]</span></p><p>公式中，向量 <span class="math inline">\(\boldsymbol u_o\)</span> 和向量 <span class="math inline">\(\boldsymbol v_c\)</span> 进行点乘。<strong>用点积比较 <span class="math inline">\(w_o\)</span> 和 <span class="math inline">\(w_c\)</span> 的相似性</strong>，<span class="math inline">\(u^{T} v=u \cdot v=\sum_{i=1}^{n} u_{i} v_{i}\)</span>，向量之间越相似，点积越大，从而归一化后得到的概率值也越大。模型的训练正是为了使得具有相似上下文的单词，具有相似的向量。分母是对整个词汇表进行标准化，从而给出概率分布。</p><p>当序列长度 <span class="math inline">\(T\)</span> 较大时，我们通常随机采样一个较小的子序列来计算损失函数并使用 SGD 优化该损失函数。通过求导，我们可以计算出上式生成概率的对数关于中心词向量 <span class="math inline">\(\boldsymbol {v}_c\)</span> 的梯度为： <span class="math display">\[\begin{aligned}\frac{\partial \log P(w_o\mid w_c)}{\partial \boldsymbol{v}_c}&amp;=\frac{\partial}{\partial \boldsymbol{v}_c}\log\frac{\exp(\boldsymbol{u}_o^T\boldsymbol{v}_c)}{\sum_{i=1}^{|V|}\exp(\boldsymbol{u}_i^T\boldsymbol{v}_c)}\\&amp;=\underbrace {\frac{\partial}{\partial \boldsymbol{v}_c} \log \exp(\boldsymbol{u}_o^T\boldsymbol{v}_c)}_1-\underbrace{\frac{\partial}{\partial \boldsymbol{v}_c}\log \sum_{i=1}^{|V|}\exp(\boldsymbol{u}_i^T{\boldsymbol{v}_c})}_2\end{aligned}\]</span> 第一部分推导 <span class="math display">\[\frac { \partial} {\partial \boldsymbol{v}_c}  \color{red}{\log \exp (\boldsymbol{u}_o^T \boldsymbol{v}_c) } = \frac { \partial} {\partial \boldsymbol{v}_c}  \color{red}{\boldsymbol{u}_o^T \boldsymbol{v}_c} = \mathbf{\boldsymbol{u}_o}\]</span> 第二部分推导 <span class="math display">\[\begin{aligned} \frac { \partial} {\partial \boldsymbol{v}_c} \log \sum_{i=1}^{|V|} \exp(\boldsymbol{u}_i^T \boldsymbol{v}_c) &amp; = \frac{1}{\sum_{i=1}^{|V|} \exp(\boldsymbol{u}_i^T \boldsymbol{v}_c)}  \cdot  \color{red}{ \frac { \partial} {\partial \boldsymbol{v}_c} \sum_{x=1}^{|V|} \exp(\boldsymbol{u}_x^T  \boldsymbol{v}_c)} \\ &amp; = \frac{1}{....} \cdot \sum_{x=1}^{|V|} \color{red} {\frac { \partial} {\partial \boldsymbol{v}_c} \exp(\boldsymbol{u}_x^T  \boldsymbol{v}_c)} \\ &amp; =  \frac{1}{....} \cdot \sum_{x=1}^{|V|} \exp (\boldsymbol{u}_x^T  \boldsymbol{v}_c) \color{red} {\frac { \partial} {\partial \boldsymbol{v}_c} \boldsymbol{u}_x^T \boldsymbol{v}_c} \\ &amp; = \frac{1}{\sum_{i=1}^{|V|} \exp(\boldsymbol{u}_i^T  \boldsymbol{v}_c)}  \sum_{x=1}^{|V|} \exp (\boldsymbol{u}_x^T  \boldsymbol{v}_c)  \color{red} {\boldsymbol{u}_x} \\ &amp; = \sum_{x=1}^{|V|} \color{red} { \frac{\exp (\boldsymbol{u}_x^T  \boldsymbol{v}_c)} {\sum_{i=1}^{|V|} \exp(\boldsymbol{u}_i^T  \boldsymbol{v}_c)}} \boldsymbol{u}_x \\ &amp; = \sum_{x=1}^{|V|} \color{red} {P(w_x \mid w_c) }\boldsymbol{u}_x \end{aligned}\]</span></p><blockquote><p>公式中，这里的 log 应该是 以 e为底（即 ln），所以 (log x)’ = <span class="math inline">\(\frac 1 x\)</span></p><p>偏导数可以移进求和中(其中，<span class="math inline">\(y_i\)</span> 是有关 <span class="math inline">\(x\)</span> 的函数)： <span class="math display">\[\frac{\partial}{\partial x}\sum_iy_i = \sum_i\frac{\partial}{\partial x}y_i\]</span></p></blockquote><p>综上所述 <span class="math display">\[\frac{\partial \log P(w_o\mid w_c)}{\partial \boldsymbol{v}_c}=\boldsymbol{u}_o-\sum_{j\in V}P(w_j\mid w_c)\boldsymbol {u}_j\]</span> 通过上面计算得到梯度后，我们可以使用随机梯度下降来不断迭代模型参数 <span class="math inline">\(\boldsymbol {v}_c\)</span>。另一个模型参数 <span class="math inline">\(\boldsymbol {u}_o\)</span> 的迭代方式同理可得： <span class="math display">\[\begin{align}\frac{\partial \log P(w_o\mid w_c)}{\partial \boldsymbol{u}_o}&amp;=\frac{\partial}{\partial \boldsymbol{u}_o}\log\frac{\exp(\boldsymbol{u}_o^T\boldsymbol{v}_c)}{\sum_{i=1}^{|V|}\exp(\boldsymbol{u}_i^T\boldsymbol{v}_c)}\\&amp;=\frac{\partial}{\partial \boldsymbol{u}_o}\left(\log \exp(\boldsymbol{u}_o^T\boldsymbol{v}_c)-\log\sum_{i=1}^{|V|}\exp(\boldsymbol{u}_i^T{\boldsymbol{v}_c})\right)\\&amp;=\frac{\partial}{\partial \boldsymbol{u}_o} (\boldsymbol{u}_o^T\boldsymbol{v}_c)- \frac{\partial}{\partial \boldsymbol{u}_o} \log \sum_{i=1}^{|V|} \exp \left(\boldsymbol{u}_{i}^{T} \boldsymbol{v}_{c}\right) \\&amp;=\boldsymbol{v}_c- \frac{\partial}{\partial \boldsymbol{u}_{o}} \log \sum_{i=1}^{|V|} \exp \left(\boldsymbol{u}_{i}^{T} \boldsymbol{v}_{c}\right) \\&amp;=\boldsymbol{v}_c-\frac{\sum_{i=1}^{|V|} \frac{\partial}{\partial \boldsymbol{u}_{o}}\exp(\boldsymbol{u}_{i}^{T} \boldsymbol{v}_{c})}{\sum_{i=1}^{|V|} \exp \left(\boldsymbol{u}_{i}^{T} \boldsymbol{v}_{c}\right)}\\&amp;=\boldsymbol{v}_c - \frac{\exp(\boldsymbol{u}_o^T\boldsymbol{v}_c)\boldsymbol{v}_c}{\sum_{i=1}^{|V|} \exp \left(\boldsymbol{u}_{i}^{T} \boldsymbol{v}_{c}\right)}\\&amp;=\boldsymbol{v}_c - P(w_o|w_c)\boldsymbol{v}_c\\&amp;=(1-P(w_o|w_c))\boldsymbol{v}_c\end{align}\]</span> 最终，对于词典中任一索引为 <span class="math inline">\(i\)</span> 的词，我们均得到该词作为中心词和上下文词的两组词向量 <span class="math inline">\(\boldsymbol {v}_i\)</span> 和 <span class="math inline">\(\boldsymbol {u}_i\)</span></p><h4 id="cbow-连续词袋模型">CBOW 连续词袋模型</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210811170513754.png" style="zoom:67%;" /></p><p>连续词袋模型（Continuous Bag of Words）与跳字模型类似。与跳字模型最大的不同是，连续词袋模型是用一个中心词在文本序列<strong>周围的词 来预测中心词</strong>。例如，给定文本 &quot;the&quot;,&quot;man&quot;,&quot;hit&quot;,&quot;the&quot;,&quot;ball&quot;，连续词袋模型所关心的是，邻近词 &quot;the&quot;,&quot;man&quot;,&quot;the&quot;,&quot;ball&quot; 一起生成中心词 &quot;hit&quot; 的概率</p><p>连续词袋模型需要最大化由背景词生成任一中心词的概率： <span class="math display">\[\prod_{t=1}^TP(w^{(t)}\mid w^{(t-m)},...,w^{(t-1)},w^{(t+1)},...,w^{(t+m)})\]</span> 上式得最大似然估计与最小化以下损失函数等价 <span class="math display">\[-\sum_{t=1}^T\log P(w^{(t)}\mid w^{(t-m)},...,w^{(t-1)},w^{(t+1)},...,w^{(t+m)})\]</span> 我们可以用 <span class="math inline">\(\boldsymbol {v}\)</span> 和 <span class="math inline">\(\boldsymbol {u}\)</span> 分别代表上下文词和中心词的向量（注意符号和跳字模型刚好相反）。给定中心词 <span class="math inline">\(w_c\)</span> 在词典中的索引为 <span class="math inline">\(c\)</span>，背景词 <span class="math inline">\(w_{o_1},...,w_{o_{2m}}\)</span> 在词典中的索引为 <span class="math inline">\(o_1,...,o_{2m}\)</span></p><p>需要对上述的上下文向量求平均值：<font color='red'>(why?)</font> <span class="math display">\[\widehat{\boldsymbol{v}}=\frac{\boldsymbol{v}_{o_1}+...+\boldsymbol{v}_{o_{2m}}}{2m}\]</span> 损失函数中的上下文词生成中心词的概率可以使用 softmax 函数定义为 <span class="math display">\[P(w_c\mid w_{o_1},...,w_{o_{2m}})=\frac{\exp[\boldsymbol{u}_c^T(\boldsymbol{v}_{o_1}+...+\boldsymbol{v}_{o_{2m}})/(2m)]}{\sum_{j\in V}\exp[\boldsymbol{u}_j^T(\boldsymbol{v}_{o_1}+...+\boldsymbol{v}_{o_{2m}})/(2m)]}\]</span> 同样，当序列长度 T 较大时，我们通常随机采样一个较小的子序列来计算损失函数，并使用随机梯度下降优化该损失函数，通过微分，我们可以计算出上式生成概率的对数关于任一背景词向量 <span class="math inline">\(\boldsymbol {v}_{o_i}(i=1,...,2m)\)</span> 的梯度为： <span class="math display">\[\frac{\partial \log P(w_c\mid w_{o_1},...,w_{o_{2m}})}{\partial \boldsymbol{v}_{o_i}}=\frac{1}{2m}(\boldsymbol {u}_c-\sum_{j\in V}\frac{\exp(\boldsymbol u_j^T\boldsymbol v_c)}{\sum_{i\in V}\exp(\boldsymbol u_i^T\boldsymbol v_c)}\boldsymbol u_j)\]</span> 而上式与下式等价： <span class="math display">\[\frac{\partial \log P(w_c\mid w_{o_1},...,w_{o_{2m}})}{\partial \boldsymbol{v}_{o_i}}=\frac{1}{2m}(\boldsymbol {u}_c-\sum_{j\in V}P(w_j\mid w_c)\boldsymbol  u_j)\]</span></p><h3 id="近似训练法">近似训练法</h3><p>可以看到，无论是跳字模型还是连续词袋模型，每一步梯度计算的开销与词典 V 的大小呈正相关。显然，当词典较大时，这种训练方法的计算开销会很大。所以使用上述训练方法在实际中是由难度的。我们可以使用近似的方法来计算这些梯度，从而减小计算开销。常用的近似训练法包括<strong>负采样</strong>和<strong>层序 softmax</strong></p><h4 id="负采样-negative-sampling">负采样 negative sampling</h4><p>以跳字模型为例讨论负采样。词典 <span class="math inline">\(V\)</span> 的大小之所以会在目标函数中出现，是因为中心词 <span class="math inline">\(w_c\)</span> 生成上下文词 <span class="math inline">\(w_o\)</span> 的概率 <span class="math inline">\(P(w_o|w_c)\)</span> 使用了 softmax，而 softmax 考虑到了上下文词可能是词典中任一词，并体现在了 softmax 的分母上。</p><p>不妨换个角度，假设中心词 <span class="math inline">\(w_c\)</span> 生成上下文词 <span class="math inline">\(w_o\)</span> 由以下两个互相独立的联合事件组成来近似：</p><ol type="1"><li>中心词 <span class="math inline">\(w_c\)</span> 和上下文词 <span class="math inline">\(w_o\)</span> 同时出现在该训练数据窗口</li><li>中心词 <span class="math inline">\(w_c\)</span> 和噪声词不同时出现在该训练数据窗口<ul><li>中心词 <span class="math inline">\(w_c\)</span> 和第 1 个噪声词 <span class="math inline">\(w_1\)</span> 不同时出现在训练数据窗口（噪声词 <span class="math inline">\(w_k\)</span> 按噪声词分布 <span class="math inline">\(P(w)\)</span> 随机生成）</li><li>...</li><li>中心词 <span class="math inline">\(w_c\)</span> 和第 K 个噪声词 <span class="math inline">\(w_k\)</span> 不同时出现在训练数据窗口（噪声词 <span class="math inline">\(w_k\)</span> 按噪声词分布 <span class="math inline">\(P(w)\)</span> 随机生成）</li></ul></li></ol><p>我们可以使用 <span class="math inline">\(\sigma (x)=\frac {1}{1+\exp (-x)}\)</span> 函数来表达中心词 <span class="math inline">\(w_c\)</span> 和上下文词 <span class="math inline">\(w_o\)</span> 同时出现在训练数据窗口的概率：</p><p><span class="math display">\[P(D=1\mid w_o,w_c)=\sigma(\boldsymbol{u}_o^T,\boldsymbol{v}_c)\]</span> 那么，中心词 <span class="math inline">\(w_c\)</span> 生成上下文词 <span class="math inline">\(w_o\)</span> 的对数概率可以近似为： <span class="math display">\[\log P(w_o\mid w_c)=\log[P(D=1\mid w_o,w_c)\prod_{k=1,w_k\sim P(w)}^KP(D=0\mid w_k,w_c)]\]</span> 假设噪声词 <span class="math inline">\(w_k\)</span> 在词典中的索引为 <span class="math inline">\(i_k\)</span>，上式可改写为： <span class="math display">\[\log P(w_o\mid w_c)=\log\frac{1}{1+\exp(-\boldsymbol u_o^T\boldsymbol{v}_c)}+\sum_{k=1,w_k\sim P(w)}^K\log[1-\frac{1}{1+\exp(-\boldsymbol u_{i_k}^T\boldsymbol{v}_c)}]\]</span> 因此，有关中心词 <span class="math inline">\(w_c\)</span> 生成上下文词 <span class="math inline">\(w_o\)</span> 的损失函数是： <span class="math display">\[-\log P(w_o\mid w_c)=-\log\frac{1}{1+\exp(-\boldsymbol u_o^T\boldsymbol{v}_c)}-\sum_{k=1,w_k\sim P(w)}^K\log\frac{1}{1+\exp(\boldsymbol u_{i_k}^T\boldsymbol{v}_c)}\]</span> 现在，训练中每一步的梯度计算开销不再与词典大小相关，而与 <span class="math inline">\(K\)</span> 线性相关。当 <span class="math inline">\(K\)</span> 取较小的常数时，负采样的每一步梯度计算开销也较小</p><p>同理，也可以对连续词袋模型进行负采样。有关上下文词 <span class="math inline">\(w^{(t-m)},...,w^{(t-1)},w^{(t+1)},...,w^{(t+m)}\)</span> 生成中心词 <span class="math inline">\(w_c\)</span> 的损失函数 <span class="math display">\[-\log P(w^{(t)}\mid w^{(t-m)},...,w^{(t-1)},w^{(t+1)},...,w^{(t+m)})\]</span> 在负采样中可以近似为 <span class="math display">\[-\log\frac{1}{1+\exp[-\boldsymbol{u}_c^T(\boldsymbol{v}_{o_1}+...+\boldsymbol{v}_{o_{2m}})/(2m)]}-\sum_{k=1,w_k\sim P(w)}^K\log\frac{1}{1+\exp[\boldsymbol{u}_{i_k}^T(\boldsymbol{v}_{o_1}+...+\boldsymbol{v}_{o_{2m}})/(2m)]}\]</span></p><h4 id="层序-softmax">层序 softmax</h4><p>层序 softmax 利用了二叉树(哈夫曼树)。树的每个叶子节点代表着词典 <span class="math inline">\(V\)</span> 中的每个词。每个词 <span class="math inline">\(w_i\)</span> 对应的词向量为 <span class="math inline">\(v_i\)</span>。我们以下图为例，来描述层序 softmax 的工作机制</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210812222709840.png" style="zoom: 50%;" /></p><p>设 <span class="math inline">\(L(w)\)</span> 为从二叉树根节点到代表词 <span class="math inline">\(w\)</span> 的叶子节点的路径上的节点数，并设 $n(w,i) $ 为该路径上第 i 个节点，该节点的向量为 <span class="math inline">\(u_{n(w,j)}\)</span>。以上图为例，<span class="math inline">\(L(w_3)=4\)</span>。那么，跳字模型和连续词袋模型所需要计算的任意词 <span class="math inline">\(w_i\)</span> 生成词 <span class="math inline">\(w\)</span> 的概率为：</p><p><span class="math display">\[P(w\mid w_i)=\prod_{j=1}^{L(w)-1}\sigma([n(w,j+1)=left\_child(n(w,j))]·\boldsymbol{u}_{n(w,j)}^T\boldsymbol{v}_i)\]</span> 其中，如果 <span class="math inline">\(x\)</span> 为真，<span class="math inline">\([x]=1\)</span>；反之 <span class="math inline">\([x]=-1\)</span></p><p>由于 <span class="math inline">\(\sigma (x)+\sigma (-x)=1\)</span>，<span class="math inline">\(w_i\)</span> 生成词典中任何词的概率之和为 1： <span class="math display">\[\sum_{w=1}^VP(w\mid w_i)=1\]</span> 举个具体的例子，计算 <span class="math inline">\(w_i\)</span> 生成 <span class="math inline">\(w_3\)</span> 的概率，由于在二叉树中由根到 <span class="math inline">\(w_3\)</span> 的路径需要向左、向右、再向左地遍历，所以得到 <span class="math display">\[P(w_3\mid w_i)=\sigma(\boldsymbol{u}_{n(w_3,1)}^T\boldsymbol{v}_i)·\sigma(-\boldsymbol{u}_{n(w_3,2)}^T\boldsymbol{v}_i)·\sigma(\boldsymbol{u}_{n(w_3,3)}^T\boldsymbol{v}_i)P(w_3\mid w_i)=\sigma(\boldsymbol{u}_{n(w_3,1)}^T\boldsymbol{v}_i)·\sigma(-\boldsymbol{u}_{n(w_3,2)}^T\boldsymbol{v}_i)·\sigma(\boldsymbol{u}_{n(w_3,3)}^T\boldsymbol{v}_i)\]</span> 由此，我们就可以使用随机梯度下降在跳字模型和连续词袋模型中不断迭代计算词典中所有词向量 <span class="math inline">\(v\)</span> 和非叶子节点的向量 <span class="math inline">\(u\)</span>。每次迭代的计算开销由 <span class="math inline">\(O(|V|)\)</span> 降为二叉树的高度 <span class="math inline">\(O(log⁡|V|)\)</span></p><p>层序 softmax 的二叉树是如何建立的？</p><ul><li>这里的二叉树 Huffman 树，权重是语料库中 word 出现的频率。通过词频大小来建立哈夫曼树。</li></ul><div class="note note-primary">            <p>这块还是不太懂....留个坑吧..</p>          </div>]]></content>
    
    
    <categories>
      
      <category>CS224n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Word2vec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luong Attention：Effective Approaches to Attention-based Neural Machine Translation</title>
    <link href="/2021/07/27/Luong%20Attention%EF%BC%9AEffective%20Approaches%20to%20Attention-based%20Neural%20Machine%20Translation/"/>
    <url>/2021/07/27/Luong%20Attention%EF%BC%9AEffective%20Approaches%20to%20Attention-based%20Neural%20Machine%20Translation/</url>
    
    <content type="html"><![CDATA[<h2 id="luong-attentioneffective-approaches-to-attention-based-neural-machine-translation">【Luong Attention】：Effective Approaches to Attention-based Neural Machine Translation</h2><p>2014年 Bahdanau 首次提出 Attention机制 后，在短短一年的时间内就在 NMT 中得到了非常广泛的应用。Luong 等人 [Luong et al.2015a] 提出了在 NMT 中引入 Attention 机制两种简单且有效的实现方式：Global Attention 和 Local Attention。<strong>Global Attention 关注源句子的所有单词，而 Local Attention 只关注每个目标词对应的源句子的一个子集。</strong>Global Attention 和 Bahdanau 提出的 Attention机制 相似，但结构上更加简单，而 Local Attention 可以看作是 Hard Attention 和 Soft Attention 的结合，它在计算复杂度上比 Soft Attention 要小，并且比起 Hard Attention，Local Attention 是几乎处处可微的，因此易于实现和训练。另外，作者还提出了三种不同的<strong>对齐函数（Alignment Functions）：Dot、General、Concat</strong> 来计算 Attention。</p><h3 id="attention-based-models">Attention-based Models</h3><p>在作者的模型中，<strong>编解码器均采用层叠 LSTMs</strong>，最上层的状态作为编码的隐层表示，而 Bahdanau 的模型是单层双向编码器 和 单层单向解码器，具体的细节请看==这篇==【Attention】: Neural Machine Translation by Jointly Learning to Align and Translate。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210727142430977.png" style="zoom:80%;" /></p><p>作者使用的基于注意力的编码器解码器如上图所示。关于注意力机制，作者提出了两种：Global Attention 和 Local Attention。首先，这两种注意力机制的不同之处在于<strong>输出上下文向量 <span class="math inline">\(c_t\)</span> 的计算方法不同</strong>，其他的比如 <span class="math inline">\(h_t\)</span> 和 <span class="math inline">\(y_t\)</span> 的计算都是相同的： <span class="math display">\[\tilde{\boldsymbol{h}}_{t}=\tanh \left(\boldsymbol{W}_{c}\left[\boldsymbol{c}_{t} ; \boldsymbol{h}_{t}\right]\right)\\p\left(y_{t} \mid y_{&lt;t}, x\right)=\operatorname{softmax}\left(\boldsymbol{W}_{s} \tilde{\boldsymbol{h}}_{t}\right)\]</span></p><blockquote><p>针对 Bahdanau ‘s Attention 的公式：</p><p><span class="math inline">\(h_t\)</span> 就是 Decoder 上一个隐状态 <span class="math inline">\(z_{i-1}\)</span>, <span class="math inline">\(\tilde h_t\)</span> 就是 Decoder 当前隐状态 <span class="math inline">\(z_i\)</span></p></blockquote><p>在这里，作者引入了一个新的注意力层来生成单词，接下来介绍两种注意力机制如何计算 <span class="math inline">\(c_i\)</span>.</p><h3 id="global-attention">Global Attention</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210727091818341.png" style="zoom: 80%;" /></p><p><strong>Global Attention 的思想是在计算上下文向量 <span class="math inline">\(c_i\)</span> 时考虑编码器所有的隐藏状态。在每个时间步 <span class="math inline">\(t\)</span>，模型根据当前目标状态 <span class="math inline">\(h_t\)</span> 和所有源状态 <span class="math inline">\(\bar h_s\)</span> 推断对齐权重向量 <span class="math inline">\(a_t\)</span>。然后，根据 <span class="math inline">\(a_t\)</span>，将全局上下文向量 <span class="math inline">\(c_t\)</span> 计算为所有源状态的加权平均值。</strong></p><p>首先根据 目标词状态 <span class="math inline">\(h_t\)</span> 和 源句子所有词状态 <span class="math inline">\(\bar h_s\)</span> 计算对齐向量 <span class="math inline">\(a_t\)</span>: <span class="math display">\[\begin{aligned}\boldsymbol{a}_{t}(s) &amp;=\operatorname{align}\left(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s}\right) \\&amp;=\frac{\exp \left(\operatorname{score}\left(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s}\right)\right)}{\sum_{s^{\prime}} \exp \left(\operatorname{score}\left(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s^{\prime}}\right)\right)}\end{aligned}\]</span> <strong>score 其实就是计算当前隐层输出与源隐层输出的相似的程度</strong>，作者给出了 score 的三种 <strong>content-based function</strong>： <span class="math display">\[\operatorname{score}\left(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s}\right)=\left\{\begin{array}{l}\boldsymbol{h}_{t}^{\top} \overline{\boldsymbol{h}}_{s}, \quad \text{ dot } \\\boldsymbol{h}_{t}^{\top} \boldsymbol{W}_{\boldsymbol{a}} \overline{\boldsymbol{h}}_{s}, \quad \text { general } \\\boldsymbol{v}_{a}^{\top} \tanh \left(\boldsymbol{W}_{\boldsymbol{a}}\left[\boldsymbol{h}_{t} ; \overline{\boldsymbol{h}}_{s}\right]\right), \quad \text { concat }\end{array}\right.\]</span></p><blockquote><p>另外，为了对比，作者还给出了一个比较早期的，只和位置相关的 <strong>location-based function</strong>： <span class="math display">\[\boldsymbol{a}_{t}=\operatorname{softmax}\left(\boldsymbol{W}_{\boldsymbol{a}} \boldsymbol{h}_{t}\right), \quad \text { location }\]</span></p></blockquote><div class="note note-primary">            <p>这里我觉得因为 score 函数包括了 <span class="math inline">\(\bar h_s\)</span> ，所以叫基于内容的(content-based). 早期给出的基于位置的(location-based)就只针对 target word，而不包括源句子，所以后面实验可以看到效果不好。</p>          </div><p>得到对齐向量后，用其对 source hidden states 加权平均即可得到上下文向量 <span class="math inline">\(c_t\)</span>。</p><blockquote><p>这里很多博客说的都是加权求和，但是原论文里写的是加权平均，如果以后有时间看一下代码实现就知道了！</p><p>“Given the alignment vector as weights, the context vector <span class="math inline">\(c_t\)</span> is computed as the <u>weighted average over all the source hidden states</u>”</p></blockquote><p>一个流程更清晰的 model 如下图所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/640%20(2).jpg" /></p><h3 id="local-attention">Local Attention</h3><p>Global Attention 有缺陷：<strong>当输入的句子特别长的时候（比如输入是段落或文档），Global Attention 的计算量将会变得很大</strong>。因为我们要求源句子中所有的词都参与每一时刻的计算，所以作者才提出了Local Attention，即只注意源句子的一个小子集，而不是所有单词。Local Attention 的思想也来源于前人的工作，有关 Soft Attention 和 Hard Attention 之间的折中权衡。 <strong>不像软对齐那样注意所有的输入而导致计算量过大，也不像硬对齐那样只选择一个输入而导致过程不可微，需要加入复杂的技巧（variance reduction、reinforcement learning）来训练模型。</strong>因此 Local Attention 既可微，能训练，同时计算量小。</p><p><strong>Local Attention 的思想是只关注每个目标词的源位置的子集。该模型首先预测当前目标词的对齐位置。然后，以源位置 <span class="math inline">\(p_t\)</span> 为中心的窗口用于计算上下文向量 <span class="math inline">\(c_t\)</span>，即窗口中源隐藏状态的加权平均值。从窗口中的当前目标状态 <span class="math inline">\(h_t\)</span> 和源状态 <span class="math inline">\(\bar h_s\)</span> 推断出权重 <span class="math inline">\(a_t\)</span>。</strong></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210727091743663.png" style="zoom: 80%;" /></p><p>首先，在时间 <span class="math inline">\(t\)</span> 为每个目标词生成一个 Aligned position <span class="math inline">\(p_t\)</span>，然后计算上下文向量 <span class="math inline">\(c_i\)</span> 为窗口 <span class="math inline">\([p_t - D, p_t + D]\)</span> 内 源隐藏状态的加权平均值。<span class="math inline">\(D\)</span> 是根据经验选的窗口半径，是一个超参数。这样，对齐向量是一个定长的向量，长度便为 <span class="math inline">\(2D+1\)</span>.</p><p>如何确定 <img src="https://www.zhihu.com/equation?tex=p_t" alt="[公式]" />的值，Local Attention 给出了<strong>两种确定注意力中心的方法：</strong></p><h4 id="monotonic-alignment-local-m单调对齐">Monotonic alignment (local-m)：单调对齐</h4><p>作者假设输入和输出在很大程度是一一对应的，也就是假设输入和输出是<strong>单调对齐</strong>（Monotonic）的，简单的设置 <span class="math inline">\(p_t = t\)</span>. 对齐向量 <span class="math inline">\(a_t\)</span> 同 Global Attention 的一致。 <span class="math display">\[\begin{aligned}\boldsymbol{a}_{t}(s) &amp;=\operatorname{align}\left(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s}\right) \\&amp;=\frac{\exp \left(\operatorname{score}\left(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s}\right)\right)}{\sum_{s^{\prime}} \exp \left(\operatorname{score}\left(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s^{\prime}}\right)\right)}\end{aligned}\]</span></p><h4 id="predictive-alignment-local-p预测中心对齐">Predictive alignment (local-p)：预测中心对齐</h4><p>不像上面那样假设输入输入单调对齐，而是预测对齐中心。即针对每个目标端输出，预测他在源语言端的对齐位置： <span class="math display">\[p_{t}=S \cdot \operatorname{sigmoid}\left(\boldsymbol{v}_{p}^{\top} \tanh \left(\boldsymbol{W}_{\boldsymbol{p}} \boldsymbol{h}_{t}\right)\right)\]</span> 其中，<span class="math inline">\(\boldsymbol{W}_{\boldsymbol{p}}\)</span> 和 <span class="math inline">\(v_p\)</span> 都是用来预测位置的参数。<span class="math inline">\(S\)</span> 是源句长度，这样就有 <span class="math inline">\(p_t \in [0, S]\)</span>。另外，这里还有一个trick，作者对对齐向量的计算做了修改，在 <span class="math inline">\(p_t\)</span> 周围引入了一个服从 <span class="math inline">\(N(p_t, \frac D 2)\)</span> 的高斯分布来对齐权重，从直觉上考虑，<strong>距离目标位置越近的词理当起到更大的作用</strong>，因此对齐向量为 <span class="math display">\[\boldsymbol{a}_{t}(s)=\operatorname{align}\left(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s}\right) \exp \left(-\frac{\left(s-p_{t}\right)^{2}}{2 \sigma^{2}}\right)\]</span> 其中 <span class="math inline">\(\sigma\)</span> 也是超参数，作者凭经验选择 <span class="math inline">\(\sigma = \frac D 2\)</span>。同时也可以看到，在没有引入高斯分布之前，位置 <span class="math inline">\(p_t\)</span> 并没有直接与网络相连，虽然计算 <span class="math inline">\(p_t\)</span> 的过程可以微分，但是<strong>作为窗口中心这个操作是不可微的</strong>，因此也需要某种额外的方式（用来 <span class="math inline">\(p_t\)</span> 导出 <span class="math inline">\(a_t\)</span>)将其与网络关联起来，使得参数可以通过 <strong>backprop</strong> 训练。</p><div class="note note-info">            <p>可以想下，没有 Gassian 的引入，是学习不了计算 <span class="math inline">\(p_t\)</span> 中的 <span class="math inline">\(\boldsymbol{W}_{\boldsymbol{p}}\)</span> 和 <span class="math inline">\(v_p\)</span> 的，因为它不是直接通过某个函数和网络联系起来，而是计算出 <span class="math inline">\(p_t\)</span> 的值，然后把它当做窗口的中心。虽然计算 <span class="math inline">\(p_t\)</span> 的操作可以微分，但是当做窗口中心这个操作是没办法微分的，所以没办法BP。在 Hard Attention 中，直接取 score 最大的作为 Attention，同理，这个<strong>取max的操作无法微分</strong>，所以 Hard Attention 需要使用其他 technique 来进行优化 BP。</p>          </div><div class="note note-info">            <p><strong>关于 soft attention 和 hard attention</strong></p><ol type="1"><li><p>Soft Attention Model（与 Luong 的 Global Attention 基本相同）</p><p>所谓 Soft，意思是在求注意力分配概率分布的时候，对于输入句子X中任意一个单词都给出个概率，是个概率分布。</p><ul><li><em>优点</em>：模型平滑且可微。</li><li><em>缺点</em>：当源输入很大时很昂贵。</li></ul></li><li><p>Hard Attention Model</p><p>既然 Soft 是给每个单词都赋予一个单词对齐概率，那么如果不这样做，直接从输入句子里面找到某个特定的单词，然后把目标句子单词和这个单词对齐，而其它输入句子中的单词硬性地认为对齐概率为0，这就是 Hard Attention Model 的思想。</p><ul><li><em>优点</em>：推理时计算量较少。</li><li><em>缺点</em>：模型是不可微的，需要更复杂的技术，如方差减少或强化学习来训练。(本文 <a href="https://arxiv.org/abs/1508.04025">Luong, et al., 2015</a> )</li></ul><p>Hard AM 在图像里证明有用，但是估计在文本里面用处不大，因为这种单词一一对齐明显要求太高，如果对不齐对后续处理负面影响很大，所以在 NLP 的文献里看不到用 Hard AM，估计大家都试过了，效果不好。</p></li><li><p><strong>介于 Soft 和 Hard 之间</strong></p><p>Soft AM 要求输入句子每个单词都要赋予单词对齐概率，Hard AM 要求从输入句子中精确地找到一个单词来和输出单词对齐，那么可以放松 Hard 的条件，先找到 Hard AM 在输入句子中单词对齐的那个单词大致位置，然后以这个单词作为轴心，向左向右拓展出一个大小为D的窗口，在这个 2D+1 窗口内的单词内进行类似 Soft AM 的对齐概率计算即可。</p></li></ol><p><strong>Global Attention 和 Local Attention 各有优劣，实际中 Global 的用的更多一点，因为：</strong></p><ul><li><strong>Local Attention 当 encoder 不长时，计算量并没有减少</strong></li><li><strong>位置向量 <span class="math inline">\(p_t\)</span> 的预测并不非常准确，直接影响到 Local Attention 的准确率</strong></li></ul>          </div><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730205202489.png" /></p><h3 id="input-feeding-approach">Input-feeding approach</h3><p>在之前提到的几种Attention机制中，每个Attention决策都是独立做出的，在传统的统计机器翻译中，我们通常会保存一个 coverage set，也就是记录到目前为止源语言端已经被翻译过的词。同样，在 Attention-based NMT 中，<strong>前面计算得到的对齐信息也应该用来辅助当前的对齐决策过程</strong>。因此作者在每一步将之前的 Attention 隐层输出 <span class="math inline">\(\tilde h_t\)</span> 与输入拼接后再喂到编码器中，这样就可以使得模型能够注意到之前生成过的单词，同时这样的结构，<strong>无论在垂直方向还是水平方向，都有足够的深度</strong>，因此可以期待这样的深度网络可以有更好的表现。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210727171334525.png" style="zoom:80%;" /></p><blockquote><p>decoder 部分第二层第 t 步的状态会作为第一层第 t+1 步的输入</p></blockquote><h3 id="luong-attention-与-bahdanau-attention-区别">Luong Attention 与 Bahdanau Attention 区别</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730205552231.png" style="zoom:67%;" /></p><p>Luong Attention 与 Bahdanau 的 Soft Attention 相似，但是有一定的区别：</p><ol type="1"><li><p>Luong Attention 中，Encoder 和 Decoder 使用的是 多层 LSTM 网络。使用的是 LSTM 最顶层的hidden states</p><p>而 Bahdanau Attention 中，Encoder 使用的是 双向RNN(BiGRU)，Encoder 端的隐层状态使用前向与反向 RNN 的隐层向量 concatenate 合成，Decoder 使用 单向 RNN。(上图有点不严谨..)</p></li><li><p>注意力的计算方式不同。 通过模型和计算公式可以看出 Luong Attention 计算路径从 <span class="math inline">\(\boldsymbol{h}_{t} \rightarrow \boldsymbol{a}_{t} \rightarrow \boldsymbol{c}_{t} \rightarrow \tilde{\boldsymbol{h}}_{t}\)</span>. 作者直接由<strong>当前隐状态 <span class="math inline">\(h_t\)</span> 和每一个输入隐状态 <span class="math inline">\(\bar h_s\)</span> </strong>计算得出权重。</p><p>而 Bahdanau Attention 的计算路径从 <span class="math inline">\(\boldsymbol{h}_{t-1} \rightarrow \boldsymbol{a}_{t} \rightarrow \boldsymbol{c}_{t} \rightarrow \boldsymbol{h}_{t}\)</span>， 再将其送入深度输出网络和 Maxout 层得到预测结果。即利用<strong>过去的隐状态 <span class="math inline">\(h_{t-1}\)</span> 和每一个输入隐状态 <span class="math inline">\(\bar h_s\)</span> </strong>来预测当前的隐状态</p><blockquote><p>作者提到 Luong Attention 计算路径(computation path)更简单。</p><p>Luong attention 机制中的 decoder 在每一步使用当前步（而非前一步）的 hidden state 来计算注意力，从逻辑上更自然，但需要使用一层额外的 RNN decoder 来计算输出。</p></blockquote></li><li><p>Decoder 的输入输出不同. Luong Attention 中decoder 部分建立了一层额外的网络结构，以上下文向量 <span class="math inline">\(c_t\)</span> 与原 Decoder 第 t 步的 hidden state <span class="math inline">\(h_t\)</span> 拼接作为输入，得到第 t 步的 hidden state <span class="math inline">\(\tilde h_t\)</span> 并输出 <span class="math inline">\(\hat y_t\)</span>.</p><p>而 Bahdanau Attention , Decoder 在第 t 步时，输入是由上下文向量 <span class="math inline">\(c_t\)</span> 与前一步 hidden state <span class="math inline">\(h_{t-1}\)</span> 拼接(concatenate )得出的，得到第 t 步的 hidden state <span class="math inline">\(h_t\)</span> 并直接输出 <span class="math inline">\(\hat y_{t+1}\)</span></p></li><li><p>Luong 的 Attention 只用了一种对齐打分函数 <span class="math inline">\(concat\)</span>。而 Global Attention 给出了三种对齐方式 <span class="math inline">\(dot, general, concat\)</span>。（并且在后面验证，general 的效果更好一些）</p></li><li><p>最后，本方法使用一种 input-feeding 的方式来记录过去已经计算过的 对齐信息（即将前面得到的 attentional hidden state <span class="math inline">\(\widetilde{h}_{i-1}\)</span> 加入到当前 <span class="math inline">\(\widetilde{h}_{i}\)</span> 的计算过程中).</p><p>在机器翻译领域，都需要使用一个coverage set（覆盖集）去记录那些source words已经被翻译。在 Bahdanau 等人的工作中, 在计算 <span class="math inline">\(\boldsymbol{h}_{t}\)</span> 时引入了前一时刻的隐层状态, 虽然也类似实现了 “coverage” 的效果, 但是并没有分析这样的网络连接是否有效。Luong 等人认为该模型更 general, 可以用到各种堆叠的 RNN 结构中 (stacking recurrent architectures)</p></li></ol><h3 id="experiments">Experiments</h3><p>从训练曲线可以看到加入Local Attention和Feed Input之后优化速度和优化结果都要好过原始模型，同时训练结果也更加<strong>稳健</strong>。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210727175347854.png" style="zoom: 80%;" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210727175258520.png" alt="image-20210727175258520" style="zoom: 80%;" /></p><p>由于计算资源的限制，作者没有给出所有的 Attention机制 和对齐函数的所有可能的组合，但也可以分析出很多有价值的结论。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210727175323502.png" style="zoom: 80%;" /></p><p>从上图可以看出，location-based对齐函数比起其他对齐函数而言效果不好，<strong>当引入unk replacement之后带来的BLEU分数提升不如其他的对齐函数高</strong>，而对于content-based对齐函数，concat 表现得不好，因此作者没有列出，一个可能的原因是作者过度简化了 <span class="math inline">\(\boldsymbol{W}_{\boldsymbol{a}}\)</span>。有趣的一点是，<strong>dot更适合global attention而general更适合local attention</strong>，但综合比较来看，local-p总体效果是最好的，<strong>local-p(general)</strong>的所有指标都是最佳的。</p><h3 id="对齐质量"><strong>对齐质量</strong></h3><p>Bahdanau 在提出 Attention 时通过对样例可视化的方法表明了Attention对齐的有效性，而这里作者用<strong>AER指标（Alignment Error Rate）</strong>来衡量模型的对齐效果，不同模型的给出的AER指标如下。AER当然是越小越好，可以看到Local Attention的AER指标更低。值得注意的是，ensemble竟不比单纯的local-m(general)要好，而在BLEU中ensemble分数要高很多，这一定程度上说明了<strong>AER指标和翻译分数的相关性不是很强</strong>。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210727175310187.png" style="zoom:80%;" /></p><h3 id="summary">Summary</h3><p>本文提出了 Global Attention 和 Local Attention。<strong>Global Attention 关注源句子的所有单词，而 Local Attention 只关注每个目标词对应的源句子的一个子集。</strong>Global Attention 和 Bahdanau 提出的 Attention机制 相似，但做了简化（有关对齐函数）。另外，作者还提出了三种不同的<strong>对齐函数（Alignment Functions）：Dot、General、Concat</strong> 来计算 Attention。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Attention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bahdanau Attention：Neural Machine Translation by Jointly Learning to Align and Translate</title>
    <link href="/2021/07/26/Bahdanau%20Attention%EF%BC%9ANeural%20Machine%20Translation%20by%20Jointly%20Learning%20to%20Align%20and%20Translate/"/>
    <url>/2021/07/26/Bahdanau%20Attention%EF%BC%9ANeural%20Machine%20Translation%20by%20Jointly%20Learning%20to%20Align%20and%20Translate/</url>
    
    <content type="html"><![CDATA[<h2 id="bahdanau-attentionneural-machine-translation-by-jointly-learning-to-align-and-translate">【Bahdanau Attention】：Neural Machine Translation by Jointly Learning to Align and Translate</h2><p>这是一篇2015年发表在 ICLR 上的论文，也是 NLP 中 Attention 机制的开山之作，Attention 机制是为了解决一般的 RNN Encoder-Decoder 对长句子表现不佳的问题而设计的。从论文题目中可以看到，作者希望通过 Attention 机制将输入句子 input 和输出句子 output 进行“对齐”（SMT 中也有所谓的词对齐模型），当然，由于不同语言的句法语法结构千差万别，想将源句子与翻译句子严格的对齐是很困难的，所以这里的对齐实际上是<strong>软对齐（soft-alignment）</strong>，也就是不必将源句子显式分割，因而又被形象地称为<strong>注意力机制（Attention Mechanism）</strong>。</p><blockquote><p><strong>定义：对齐</strong></p><p>对齐是指将原文的片段与其对应的译文片段进行匹配。</p></blockquote><h3 id="background">Background</h3><p>传统的神经网络机器翻译模型属于 <em>编码器-解码器</em> 系列。编码器读取并编码源语句成一个固定长度的向量。然后解码器根据这个向量解码输出翻译。<strong>这种编码器-解码器方法的潜在问题是神经网络需要能将源语句的所有重要的信息压缩到一个固定长度向量中。</strong> 这可能使得神经网络难以处理长句子，编码器-解码器的性能会随着输入句子的长度增加而迅速下降，序列越长，信息丢失的就越厉害。</p><p>为了解决这个问题，这篇论文引入编码器-解码器模型的一种扩展，它<strong>联合学习对齐和翻译</strong>(对应了论文题目)。 提出的模型在翻译中每次生成单词时，<strong>它（软）搜索源语句中信息最相关的一组位置。 然后，模型基于与这些源位置相关联的上下文向量和先前产生的所有目标单词来预测新的目标单词。</strong>即，在翻译目标词的每一步，让 Decoder 自动抽取源句子中那些与目标词信息相关的部分，而忽略不相关的部分，<strong>这些部分的信息构成一个上下文向量（context vectors）<span class="math inline">\(c_i\)</span> 来取代传统 Encoder 中的语义表示向量 <span class="math inline">\(h_{T_x}\)</span>。</strong>也就是说，<strong>Encoder 将句子编码为一个向量序列（而不是一个向量），然后在预测翻译单词的每一步选择这些向量的子集作为注意力向量输入到Decoder中。</strong></p><blockquote><p>这是符合我们的直觉的，因为人类在翻译句子时，不会每时每刻都考虑整个句子的含义，而是在翻译特定片段时，会重点注意那个片段附近的上下文，而不会注意离我们正在翻译的片段较远的那些片段。</p></blockquote><h3 id="model-rnn-encoder-decoder">Model: RNN Encoder-Decoder</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730143319577.png" /></p><p>一个流程更清晰的图：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730153601466.png" /></p><h4 id="encoder-bidirectional-rnn-for-annotating-sequence">Encoder: Bidirectional RNN for Annotating Sequence</h4><p>基本的 RNN Encoder 是将源句子压缩成一个固定维度的向量，那么期间每个词的隐层状态只压缩了前面的词。Bahdanau 等人使用双向 RNN（bidirecitonal RNN，简记为 BiRNN），即一个词的隐层状态不仅压缩了其前面的词的信息，还压缩了后面的词</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210726190413854.png" style="zoom: 67%;" /></p><p>一个 BiRNN 包含一个前向 (forward) 和一个后向 (backward) RNN。前向 RNN 按照词序列 $ ( .x_{1}, x_{2}, , x_{T})$ 的顺序依次压缩源句子，并得到一个隐层状态 <span class="math inline">\(\left(\overrightarrow{h_{1}}, \overrightarrow{h_{2}}, \ldots, \overrightarrow{h_{T}}\right)\)</span> , 类似地，后向 RNN 按照 <span class="math inline">\(\left(x_{T}, x_{T-1}, \ldots, x_{1}\right)\)</span> 的顺序依次压缩源句子, 得到 <span class="math inline">\(\left(\overleftarrow{h_{1}}, \overleftarrow{h_{2}}, \ldots, \overleftarrow{h_{T}}\right)\)</span> 。最后对于词 <span class="math inline">\(x_{i}\)</span>, 它的隐层状态通过连接两个 RNN 的结果得到 , 即 <span class="math inline">\(h_{i}=\left[\overrightarrow{h_{i}^{T}} ; \overleftarrow{h_{i}^{T}}\right]^{T}\)</span>, 可以看到，<span class="math inline">\(h_{i}\)</span> 压缩了 前向 和 后向 的表示，并且更加关注于词 <span class="math inline">\(x_{i}\)</span> 周围的词，使得 RNN 能更好地表达当前的输入</p><h4 id="decoder-learning-to-align-and-translate">Decoder: Learning to Align and Translate</h4><p>在预测目标词时，生成对应单词的条件概率定义为： <span class="math display">\[p\left(y_{i} \mid y_{1}, \cdots, y_{i-1}, \mathbf{x}\right)=g\left(y_{i-1}, z_{i}, c_{i}\right)\]</span> <span class="math inline">\(g\)</span> 一般是多层非线性神经网络（<strong>softmax+maxout</strong>），其中 <span class="math inline">\(z_i\)</span> 为 RNN 在 <span class="math inline">\(i\)</span> 时刻的隐层状态： <span class="math display">\[z_i = f(z_{i-1}, y_{i-1}, c_i)\]</span> 可见，与简单的 Encoder-Decoder 结构不同的是，源语言端上下文向量表示由原来的 <span class="math inline">\(c\)</span> 变成了 <span class="math inline">\(c_i\)</span>，即针对每一个目标词 <span class="math inline">\(y_i\)</span>，都有一个特定的 <span class="math inline">\(c_i\)</span> 与之对应（也就是说如果固定 <span class="math inline">\(c_i=\overrightarrow{h_{T}}\)</span>，那么模型就是一个普通的 RNN Encoder-Decoder）</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210726192812405.png" style="zoom: 67%;" /></p><blockquote><p>这个图不是很清晰，看 model 的图更容易理解。</p></blockquote><p>其中，<span class="math inline">\(h_j\)</span> 是 Encoder 源句子第 j 个词的隐状态，<span class="math inline">\(z_{i-1}\)</span> 是 Decoder 第 i 个 target word 的隐状态</p><p>上下文向量 <span class="math inline">\(c_{i}\)</span> 依赖于 Encoder 得到的 <span class="math inline">\(annotations \left(h_{1}, \ldots, h_{T}\right)\)</span> , 其中每个 <span class="math inline">\(h_{j}\)</span> 压缩了源语言端的词并且 &quot;关注于&quot; <span class="math inline">\(x_{j}\)</span> 周围的词。上下文向量 <span class="math inline">\(c_{i}\)</span> 可以通过各个 <span class="math inline">\(annotations\)</span> 的加权平均得到： <span class="math display">\[c_{i}=\sum_{j=1}^{T_{x}} \alpha_{i j} h_{j}\]</span> 其中, 从 <span class="math inline">\(h_{j}\)</span> 到 <span class="math inline">\(c_{i}\)</span> 的权重 <span class="math inline">\(\alpha_{i j}\)</span> 为:</p><p><span class="math display">\[\alpha_{i j} =\frac{\exp \left(e_{i j}\right)}{\sum_{k=1}^{T} \exp \left(e_{ik} \right)}\]</span></p><p><span class="math display">\[e_{i j} = a\left(z_{i-1}, h_{j}\right) =v_{a}^{T} \tanh \left(W_{a} z_{i-1}+U_{a} h_{j}\right)\]</span></p><p>Decoder 中的 a 其实就是<strong>对齐模型/对齐函数(alignment score, Luong称为对齐函数)</strong>，一般定义为一个前馈神经网络而不是SMT中的隐含变量（Latent variable，如HMM、LDA），这使得<strong>损失函数的梯度可以反向传播</strong>，可以与 Encoder-Decoder 网络共同训练，而作者为了减少计算量，将其定义为了单层前馈神经网络（因为对于每个翻译对需要计算 <span class="math inline">\(T_x \times T_y\)</span> 个权重出来），这样，由于与 <span class="math inline">\(i\)</span> 无关，因此可以预先计算出来。</p><p>不同于传统的对齐模型：源句子端每个词明确对齐到目标句子端一个或多个词（hard alignment），而该方法计算得到得是一种 soft alignment，可以融入整个 NMT 框架，通过反向传播算法求梯度以及更新参数</p><p>上面的三个式子实际上就是 Attention机制 的全部精髓。<font color="red"><span class="math inline">\(e_{ij}\)</span> 用来衡量第 <span class="math inline">\(j\)</span> 个源句子词与目标句子第 <span class="math inline">\(i\)</span> 个词的匹配程度，其实就是在预测目标句子第 <span class="math inline">\(i\)</span> 个单词时，Attention机制 赋予源句子中第 <span class="math inline">\(j\)</span> 个单词的<strong>注意力大小</strong>，而注意力大小由源句子中的单词语义表示 <span class="math inline">\(h_j\)</span> 和 Decoder 的上一状态 <span class="math inline">\(z_{i-1}\)</span> 共同决定。然后，将源句子中所有词对第 <span class="math inline">\(i\)</span> 个预测词的注意力做一个<strong>softmax归一化</strong>处理得到和为1的权重 <span class="math inline">\(\alpha_{ij}\)</span>，将其用于对源句子的词表示向量进行加权求和，就得到了<strong>上下文注意力向量</strong> <span class="math inline">\(c_i\)</span>，其反映了源句子中对于当前预测单词而言最为重要的那部分信息。</font></p><h3 id="experiments">Experiments</h3><h4 id="定量分析">定量分析</h4><p>作者比较了原始的 RNN Encoder-Decoder 模型（RNNenc）和由 Attention 机制改进的模型（RNNsearch），让这两个模型分别在句子最大长度为 30 和 50 的训练集上训练，在测试集上翻译结果的 BLEU 分数与句子长度的关系如下图所示</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210726193814272.png" style="zoom: 67%;" /></p><p>可以看到，RNNsearch 的机器翻译结果明显好于 RNNenc。RNNSearch-50 对长句子已经相当稳健，几乎不受长句子的影响，而对于 RNNsearch-30 来说，当句子长度超过 30 时，分数还是会出现大幅下滑</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210726230605129.png" /></p><p>可以看到，虽然Moses仍旧高于神经翻译模型，但 RNNsearch-50 已经和 Moses 很接近了，其中训练时间更久的 RNNsearch-50* 在无生词的情况下性能已经超越了Moses，而对比于 RNNenc，Attention机制 的引入使得传统的 Encoder-Decoder 模型的分数提高了8个点左右，说明 Attention机制 是相当有效的。</p><h4 id="定性分析">定性分析</h4><p>为了从直观上感受Attention机制，作者随机抽取了测试集中的几个句子，将他们的注意力权重采用热图的方式展示了出来：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210726200551755.png" style="zoom: 67%;" /></p><p>通过上图我们可以清晰地看到<strong>在生成目标词时，源句中的哪些词被认为更重要</strong>。不难看出，输入句子（英语）与输出句子（法语）的词之间的关系在很大程度上是单调的，即<strong>权重矩阵近似于单位矩阵</strong>，而对于一些输入与输出语言存在的一些<strong>不对称的语法现象</strong>（如图1中英语和法语的形容词与名词的顺序不同），<strong>Attention机制 能够自动跳过一些单词，调节语法顺序，使得输入输出得到正确的软对齐。</strong></p><p>比起SMT中的硬对齐，软对齐更加灵活，不生硬，同时能<strong>自然地处理不同长度的输入和输出</strong>，而不是以一种反直觉的方式把一些词映射成NULL。这也是为什么 Attention机制 能够很好地处理长句子问题，传统的 RNNenc 在翻译长句子时，在翻译的后半段往往会漏掉许多细节，偏离句子的原意，而 RNNsearch 在翻译长句子的后半段时，不会遗漏那些重要的信息，因为这些信息是即时计算的，而不像 RNNenc 那样固定不变。</p><div class="note note-info">            <p><strong>关于 soft attention 和 hard attention</strong></p><p>两者的区别在于<strong>Hard Attention 关注一个很小的区域，而soft Attention 关注的相对要发散。hard 只注重于当下时刻，聚焦于一个point，而soft则更加general。</strong></p><p>for example：</p><blockquote><p>我是小明 --&gt; I am XiaoMing</p></blockquote><p>对于 Hard Attention而言，在第1时刻翻译时，只关注“我”这个词，我们翻译得到“I”，在第2时刻翻译时，关注“是”这个词，翻译结果为“am”，以此直到 t 时刻结束。 它是采用one-hot编码的方式对位置进行标记，比如第1时刻，编号信息就是[1,0,0...]， 第二时刻，编码信息就是 [0, 1, 0, ...]， 以此类推。</p><p>这样会带来一个缺点：<strong>无法采用常规优化方法来进行优化</strong></p><p>而对于soft attention 而言，在第一时刻翻译时， “我是小明” 都对 “I” 做出了贡献，只不过贡献有大小之分，也就是说，虽然“我”这个词很重要，但是我们也不能放过其他词所带来的信息。</p><p><strong>finally：</strong></p><p>概括来说：</p><ol type="1"><li><p>Soft Attention Model（与 Luong 的 Global Attention 基本相同）</p><p>所谓 Soft，意思是在求注意力分配概率分布的时候，对于输入句子X中任意一个单词都给出个概率，是个概率分布。</p><ul><li><em>优点</em>：模型平滑且可微。</li><li><em>缺点</em>：当源输入很大时很昂贵。</li></ul></li><li><p>Hard Attention Model</p><p>既然 Soft 是给每个单词都赋予一个单词对齐概率，那么如果不这样做，直接从输入句子里面找到某个特定的单词，然后把目标句子单词和这个单词对齐，而其它输入句子中的单词硬性地认为对齐概率为0，这就是 Hard Attention Model 的思想。</p><ul><li><em>优点</em>：推理时计算量较少。</li><li><em>缺点</em>：模型是不可微的，需要更复杂的技术，如方差减少或强化学习来训练。( <a href="https://arxiv.org/abs/1508.04025">Luong, et al., 2015</a> )</li></ul><p>Hard AM 在图像里证明有用，但是估计在文本里面用处不大，因为这种单词一一对齐明显要求太高，如果对不齐对后续处理负面影响很大，所以在NLP的文献里看不到用 Hard AM，估计大家都试过了，效果不好。</p></li></ol><p><strong>soft attention输出注意力分布的概率值，hard attention 输出 onehot 向量。</strong>比较二者而言，很显然，soft attention有很大的优势，因此，对于 NLP 领域而言，目前大多数的研究都基于 soft Attention 进行扩展。</p>          </div><h3 id="summary">Summary</h3><p>作者提出了 Attention机制 来解决一般的 RNN Encoder-Decoder 对长句子表现不好的问题。一般的 RNN Encoder-Decoder 将源语句的所有重要的信息压缩到一个固定长度的上下文向量 <span class="math inline">\(c\)</span> 中，当输入序列越长，因为压缩导致的信息丢失就越多。Attention机制 让输入和输出语句进行一种软对齐，在生成每个目标词时，（软）搜索源句子中所有词中最相关的一组位置(也就是计算注意力分数找最相关的)，该模型基于 与这些源位置相关联的上下文向量 <span class="math inline">\(c_i\)</span> 和 所有先前生成的目标词 来预测目标词。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Attention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Seq2Seq和Attention机制</title>
    <link href="/2021/07/11/Seq2Seq%E5%92%8CAttention/"/>
    <url>/2021/07/11/Seq2Seq%E5%92%8CAttention/</url>
    
    <content type="html"><![CDATA[<h2 id="seq2seq和attention机制">Seq2Seq和Attention机制</h2><div class="note note-info">            <p><strong><em>2021.07.30</em></strong>：本文是有关 Attention机制 的一个小总结。</p>          </div><h3 id="rnn">RNN</h3><p>有关RNN的介绍请看==循环神经网络 RNN==。</p><h3 id="encoder-decoder">Encoder-Decoder</h3><p>Encoder-Decoder 算是一个通用的框架(结构)，在这个框架下可以使用不同的算法来解决不同的任务。例如在 Image Caption 的应用中 Encoder-Decoder 就是 CNN-RNN 的编码 - 解码框架；在神经网络机器翻译中 Encoder-Decoder 往往就是 LSTM-LSTM 的编码 - 解码框架，在机器翻译中也被叫做 <a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf">Sequence to Sequence learning</a> 。</p><p>Encoder-Decoder 这个框架很好的诠释了机器学习的核心思路：将现实问题转化为数学问题，通过求解数学问题，从而解决现实问题。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210711215759034.png" style="zoom:90%"/></p><p>关于 Encoder-Decoder，有 2 点需要说明：</p><ol type="1"><li>不论输入和输出的长度是什么，中间的「向量 C」 长度都是固定的</li><li>根据不同任务可以选择不同的编码器和解码器（可以是一个 RNN ，但通常是 LSTM 或者 GRU ）</li></ol><p>只要是符合上面的框架，都可以统称为 Encoder-Decoder 框架(结构)。</p><h3 id="seq2seq">Seq2Seq</h3><p>Seq2seq 是 sequence to sequence 的缩写。Seq2seq 旨在将一个序列转换到另一个序列。Seq2Seq 其实就是 <strong>Encoder-Decoder </strong>结构的网络，它的输入是一个序列，输出也是一个序列。在 <strong>Seq2Seq</strong> 模型中，编码器 Encoder 把所有的输入序列都编码成一个统一的语义向量 Context，然后再由解码器 Decoder 解码。</p><blockquote><p>所谓编码，就是将输入的序列编码成一个固定长度的向量；解码，就是将之前生成的固定向量再解码成输出序列。这里的输入序列和输出序列正是机器翻译的结果和输出。</p></blockquote><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210729232411426.png" alt="image-20210729232411426" style="zoom:50%;" /></p><p>为了方便阐述，在选取 Encoder 和 Decoder 时都假设其为 RNN。在 RNN 中，当前时刻隐藏状态 <span class="math inline">\(h_t\)</span> 是由上一时刻的隐藏状态 <span class="math inline">\(h_{t−1}\)</span> 和当前时刻的输入 <span class="math inline">\(x_t\)</span> 决定的，如公式所示： <span class="math display">\[h_t=f(h_{t−1},x_t)\]</span> 在 <strong>编码阶段</strong>，获得各个时刻的隐藏层状态后，通过把这些隐藏层的状态进行汇总，可以生成最后的语义编码向量 <span class="math inline">\(C\)</span> ，如公式所示，其中 <span class="math inline">\(q\)</span> 表示某种非线性神经网络，此处表示多层 RNN 。 <span class="math display">\[C=q\left(h_{1}, h_{2}, \cdots, h_{T_{x}}\right)\]</span> 在一些应用中，也可以直接将最后的隐藏层编码状态作为最终的语义编码 <span class="math inline">\(C\)</span>，即满足： <span class="math display">\[C=q\left(h_{1}, h_{2}, \cdots, h_{T_{x}}\right) = h_{T_{x}}\]</span> 在 <strong>解码阶段</strong>，需要根据给定的语义向量 <span class="math inline">\(C\)</span> 和之前已经生成的输出序列 <span class="math inline">\(y_1,y_2,⋯,y_{t−1}\)</span> 来预测下一个输出的单词 <span class="math inline">\(y_t\)</span>，即满足公式： <span class="math display">\[y_{t}=\arg \max P\left(y_{t}\right)=\prod_{t=1}^{T} p\left(y_{t} \mid y_{1}, y_{2}, \cdots, y_{t-1}, C\right)\]</span> 由于我们此处使用的 Decoder 是 RNN ，所以当前状态的输出只与上一状态和当前的输入相关，所以可以将公式简写成如下形式： <span class="math display">\[y_t=g(y_{t−1},s_{t-1},C)\]</span> 其中，<span class="math inline">\(s_{t−1}\)</span> 表示 Decoder 中 RNN 神经元的隐藏层状态，<span class="math inline">\(y_{t−1}\)</span> 表示前一时刻的输出，<span class="math inline">\(C\)</span> 代表的是编码后的语义向量，而 <span class="math inline">\(g(⋅)\)</span> 则是一个非线性的多层神经网络，可以输出 <span class="math inline">\(y_t\)</span> 的概率，一般情况下是由多层 RNN 和 softmax 层组成。</p><p><strong>Seq2seq 的局限性</strong></p><p>Seq2Seq 的局限性在于：<strong>Encoder 和 Decoder 之间只通过一个固定长度的语义向量 C 来唯一联系。</strong>也就是说，Encoder 必须要将输入的整个序列的信息都压缩进一个固定长度的向量中，存在两个弊端：一是语义向量 C 可能无法完全表示整个序列的信息；二是先输入到网络的内容携带的信息会被后输入的信息覆盖掉，输入的序列越长，该现象就越严重。这两个弊端使得 Decoder 在解码时一开始就无法获得输入序列足够多的信息，因此导致解码的精确度不够准确。</p><p>为了弥补 Seq2Seq 的局限性，提出了 Attention 机制。</p><h3 id="attention-机制">Attention 机制</h3><p>带有 Attention 机制的 Encoder-Decoder 模型则是要从序列中学习到每一个元素的重要程度，然后按重要程度将元素合并。因此，注意力机制是编码器和解码器之间的接口，<strong>它向解码器提供来自每个编码器隐藏状态的信息</strong>。通过这个设置，<strong>模型能够选择性地关注输入序列的有用部分，从而学习它们之间的“对齐”。</strong>这有助于模型有效地处理长输入语句。这就表明，在 Encoder 将输入的序列元素进行编码时，得到的不在是一个固定的语义编码 C ，而是存在多个语义编码，且不同的语义编码由不同的序列元素以不同的权重参数组合而成。</p><blockquote><p><strong>定义：对齐</strong></p><p>对齐是指将原文的片段与其对应的译文片段进行匹配。</p></blockquote><p>以机器翻译举个例子。当使用 Seq2Seq 时，模型从头到尾开始阅读文本，阅读完成，它开始翻译。但是如果句子很长，他很可能已经忘记了前面读过的内容。当引入 Attention机制 时，模型从头到尾阅读文本，同时，他会记下关键词，在翻译时会利用刚写下的关键词。</p><p>==注意力机制就是这样，每翻译一个词时，注意力会集中在不同的位置。==</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730092045401.png" alt="image-20210730092045401" style="zoom: 50%;" /></p><p>在 Attention 机制下，语义编码 C 就不在是输入序列 <span class="math inline">\(X\)</span> 的直接编码了，而是各个元素按其重要程度加权求和得到的，即： <span class="math display">\[C_{i}=\sum_{j=0}^{T_{x}} a_{i j} f\left(x_{j}\right)\]</span> 其中, 参数 <span class="math inline">\(i\)</span> 表示时刻，<span class="math inline">\(j\)</span> 表示序列中的第 <span class="math inline">\(j\)</span> 个元素, <span class="math inline">\(T_{x}\)</span> 表示序列的长度, <span class="math inline">\(f(\cdot)\)</span> 表示对元素 <span class="math inline">\(x_{j}\)</span> 的编码。<span class="math inline">\(a_{i j}\)</span> 可以看作是一个概率, 反映了元素 <span class="math inline">\(h_{j}\)</span> 对 <span class="math inline">\(C_{i}\)</span> 的重要性，可以使用 <span class="math inline">\(\operatorname{softmax}\)</span> 来表示：</p><p><span class="math display">\[a_{i j}=\frac{\exp \left(e_{i j}\right)}{\sum_{k=1}^{T_{x}} \exp \left(e_{i k}\right)}\]</span> 这里 <span class="math inline">\(e_{ij}\)</span> 正是反映了待编码的元素和其它元素之间的匹配度，当匹配度越高时，说明该元素对其的影响越大，则 <span class="math inline">\(a_{ij}\)</span> 的值也就越大。</p><p>因此，得出 <span class="math inline">\(a_{ij}\)</span> 的过程如下图：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730092534619.png" alt="image-20210730092534619" style="zoom:50%;" /></p><p>其中，<span class="math inline">\(h_i\)</span> 表示 Encoder 的转换函数，<span class="math inline">\(F(h_j,H_i)\)</span> 表示预测与目标的匹配打分函数。将以上过程串联起来，则注意力模型的结构如下图所示：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730092637651.png" alt="image-20210730092637651" /><figcaption>image-20210730092637651</figcaption></figure><p>阅读到一篇有关 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODAzMTkyMg==&amp;mid=2247485860&amp;idx=1&amp;sn=e926a739784090b3779711164217b968&amp;chksm=c06981f9f71e08efb5f57441444f71a09f1d27fc667af656a5ad1173e32ad394201d02195a3a&amp;mpshare=1&amp;scene=1&amp;srcid=0618HMAYi4gzzwWfedLoOuSD&amp;key=cb6098335ab487a8ec84c95399379f16f975d33ce91588d73ecf857c54b543666b5927e231ad3a9b17bff0c20fff20fc49c262912dca050dee9465801de8a4cdc79e3d8f4fbc058345331fb691bcbacb&amp;ascene=1&amp;uin=MTE3NTM4MTY0NA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=ikhBXxX7PL%2Fal9hbIGXbRFA96ei74EF%2BcP8KdbP6UcV6mIpOfPWzVuju%2Bqw86q5r">动画图解Attention机制</a> 的文章，这里主要是对 Attention 层的实现做下总结，详细内容请查看原文。注意力机制可以看作是神经网络架构中的一层神经网络，注意力层的实现可以分为 6 个步骤</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210729163220982.png" alt="image-20210729163220982" style="zoom: 50%;" /></p><p><strong>Step 0: 准备隐藏状态.</strong></p><p>首先准备第一个解码器的隐藏状态(红色)和所有可用的编码器隐藏状态(绿色)。在栗子中，有4个编码器隐藏状态和当前解码器隐藏状态。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/step0.gif" alt="注意力的准备工作" /><figcaption>注意力的准备工作</figcaption></figure><p><strong>Step 1: 得到每一个编码器隐藏状态的得分.</strong></p><p>score 分数(标量)由 score 函数 (也称为对齐函数或 <em>alignment model</em>)获得。</p><p>在本例中，score函数是解码器和编码器隐藏状态之间的点积(dot product)。 <span class="math display">\[\operatorname{score}(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s})\]</span> 对齐函数是用来衡量第 <span class="math inline">\(j\)</span> 个源句子词与目标句子第 <span class="math inline">\(i\)</span> 个词的匹配程度，其实就是在预测目标句子第 <span class="math inline">\(i\)</span> 个单词时，Attention机制 赋予源句子中第 <span class="math inline">\(j\)</span> 个单词的<strong><em>注意力大小</em></strong></p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/640%20(1).gif" alt="640 (1)" /><figcaption>640 (1)</figcaption></figure><table><thead><tr class="header"><th style="text-align: left;">decoder_hidden = [10, 5, 10]</th><th style="text-align: left;">encoder_hidden</th><th>alignment score (<span class="math inline">\(e_{ij}\)</span>)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">[10, 5, 10]</td><td style="text-align: left;">[0, 1, 1]</td><td>15 (= 10×0 + 5×1 + 10×1, the dot product)</td></tr><tr class="even"><td style="text-align: left;">[10, 5, 10]</td><td style="text-align: left;">[5, 0, 1]</td><td>60</td></tr><tr class="odd"><td style="text-align: left;">[10, 5, 10]</td><td style="text-align: left;">[1, 1, 0]</td><td>15</td></tr><tr class="even"><td style="text-align: left;">[10, 5, 10]</td><td style="text-align: left;">[0, 5, 1]</td><td>35</td></tr></tbody></table><p><strong>Step 2: 把所有的得分送到softmax层跑一下.</strong></p><p>将分数送到softmax层中，这样softmax之后的分数(标量)加起来等于1。这些softmax的分数代表了<strong><em>注意力的分布</em></strong>。 <span class="math display">\[\alpha_{i j} =\frac{\exp \left(e_{i j}\right)}{\sum_{k=1}^{T} \exp \left(e_{ik} \right)}\]</span> <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/640%20(2).gif" alt="640 (2)" /></p><table><thead><tr class="header"><th>encoder_hidden</th><th>alignment score (<span class="math inline">\(e_{ij}\)</span>)</th><th><span class="math inline">\(\alpha_{i j}\)</span></th></tr></thead><tbody><tr class="odd"><td>[0, 1, 1]</td><td>15</td><td>0</td></tr><tr class="even"><td>[5, 0, 1]</td><td>60</td><td>1</td></tr><tr class="odd"><td>[1, 1, 0]</td><td>15</td><td>0</td></tr><tr class="even"><td>[0, 5, 1]</td><td>35</td><td>0</td></tr></tbody></table><blockquote><p>注意力的分配仅按预期放在了<code>[5, 0, 1]</code>上。实际上，这些数字不是二进制的，而是0到1之间的一个浮点数。</p></blockquote><p><strong>Step 3</strong>: <strong>用每个编码器的隐藏状态乘以softmax之后的得分.</strong></p><p>通过将每个编码器的隐藏状态与其softmax之后的分数(标量)相乘，我们得到<strong><em>对齐向量</em></strong> 或<strong><em>标注向量</em></strong>。这正是对齐产生的机制。 <span class="math display">\[\alpha_{i j} \cdot  h_j\]</span> <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/640%20(3).gif" alt="640 (3)" /></p><table><thead><tr class="header"><th>encoder_hidden</th><th><span class="math inline">\(\alpha_{ij}\)</span></th><th>alignment vector 对齐向量</th></tr></thead><tbody><tr class="odd"><td>[0, 1, 1]</td><td>0</td><td>[0, 0, 0]</td></tr><tr class="even"><td>[5, 0, 1]</td><td>1</td><td>[5, 0, 1]</td></tr><tr class="odd"><td>[1, 1, 0]</td><td>0</td><td>[0, 0, 0]</td></tr><tr class="even"><td>[0, 5, 1]</td><td>0</td><td>[0, 0, 0]</td></tr></tbody></table><p>在这里，我们看到除了<code>[5, 0, 1]</code>外，所有编码器隐藏状态的对齐都被降低到0，这是因为注意力得分较低。这意味着我们可以期望第一个被翻译的单词应该与输入单词使用<code>[5, 0, 1]</code>嵌入表示的单词匹配。</p><p><strong>Step 4</strong>: <strong>把所有对齐的向量加起来.</strong></p><p>对 <strong><em>对齐向量</em></strong> 进行求和，生成 <strong><em>上下文向量</em></strong> <span class="math inline">\(c_i\)</span>。上下文向量是前一步的对齐向量的聚合信息。 <span class="math display">\[c_{i}=\sum_{j=1}^{T_{x}} \alpha_{i j} h_{j}\]</span> <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/640%20(4).gif" alt="640 (4)" /></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">根据上个表格<br>context = [0<span class="hljs-string">+5</span><span class="hljs-string">+0</span><span class="hljs-string">+0</span>, 0<span class="hljs-string">+0</span><span class="hljs-string">+0</span><span class="hljs-string">+0</span>, 0<span class="hljs-string">+1</span><span class="hljs-string">+0</span><span class="hljs-string">+0</span>] = [5, 0, 1]<br></code></pre></td></tr></table></figure><p><strong>Step 5</strong>: <strong>把上下文向量送到解码器中.</strong></p><p>这取决于体系结构设计。在下面会看到架构如何使用上下文向量作为解码器。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/640%20(5).gif" alt="640 (5)" /><figcaption>640 (5)</figcaption></figure><p>Attention 机制完整的流程如下图：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/640%20(6).gif" alt="640 (6)" /><figcaption>640 (6)</figcaption></figure><p><strong>Attention 到底是怎么工作的？</strong></p><p>答案：反向传播。反向传播将尽一切努力确保输出接近基本事实。这是通过改变RNNs和score函数(如果有的话)中的权重来实现的。这些权重将影响编码器的隐藏状态和解码器的隐藏状态，从而影响注意力得分。</p><h4 id="bahdanau-attention">Bahdanau Attention</h4><p>Attention 初次提出是在 <a href="https://arxiv.org/abs/1409.0473">”Neural Machine Translation by Jointly Learning to Align and Translate (Bahdanau <em>et. al</em>, 2015)”</a> 这篇论文。标题中使用了 align 这个词，意思是在训练模型的同时调整直接负责分数的权重。</p><p>Bahdanau ‘s idea:</p><ol type="1"><li><p>编码器是一个双向(前向+后向)门控循环单元(BiGRU)。解码器是一个 GRU，其初始隐藏状态是由向后编码器GRU的最后一个隐藏状态修改而来的向量(下图中未显示)。</p></li><li><p>注意层中的score函数是 <strong>additive/concat</strong>。<strong>（<span class="math inline">\(a\)</span> 就是 alignment model​, score函数）</strong> <span class="math display">\[e_{i j} = a\left(z_{i-1}, h_{j}\right) =v_{a}^{T} \tanh \left(W_{a} z_{i-1}+U_{a} h_{j}\right)\]</span></p></li><li><p>下一个解码器时间步的输入是前一个解码器时间步(粉红色)的输出与当前时间步(深绿色)的上下文向量之间的拼接。</p></li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730153601466.png" alt="image-20210730153601466" /><figcaption>image-20210730153601466</figcaption></figure><h4 id="luong-attention">Luong Attention</h4><h5 id="global-attention">GLobal Attention</h5><p><a href="https://arxiv.org/abs/1508.04025">“Effective Approaches to Attention-based Neural Machine Translation (Luong <em>et. al</em>, 2015)”</a> 的作者提出了 Global Attention 和 Local Attention，并提出了三种对齐函数的计算方式。作者指出，简化和泛化 Bahdanau et. al 的体系结构非常重要。方法如下(这里 Luong Attention 一般均指 Global Attention)</p><ol type="1"><li><p>编码器是一个两层的长短时记忆(LSTM)网络。解码器也具有相同的结构，其初始隐藏状态是最后一个编码器的隐藏状态。</p></li><li><p>他们实验过的score函数是 (1) <strong>点积</strong>，(2) <strong>general</strong>，(3) <strong>additive/concat</strong>，和(4) <strong>location-based</strong>。</p><blockquote><p>早期的 location-based 函数</p></blockquote><p><span class="math display">\[\operatorname{score}\left(\boldsymbol{h}_{t}, \overline{\boldsymbol{h}}_{s}\right)=\left\{\begin{array}{l}\boldsymbol{h}_{t}^{\top} \overline{\boldsymbol{h}}_{s}, \quad \text{ dot } \\\boldsymbol{h}_{t}^{\top} \boldsymbol{W}_{\boldsymbol{a}} \overline{\boldsymbol{h}}_{s}, \quad \text { general } \\\boldsymbol{v}_{a}^{\top} \tanh \left(\boldsymbol{W}_{\boldsymbol{a}}\left[\boldsymbol{h}_{t} ; \overline{\boldsymbol{h}}_{s}\right]\right), \quad \text { concat }\end{array}\right.\]</span></p></li><li><p>将当前解码器时间步的输出 <span class="math inline">\(h_t\)</span> 与当前时间步的上下文向量 <span class="math inline">\(c_t\)</span> 拼接，输入前向神经网络，得到当前解码器时间步的最终输出(粉红色)。</p></li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/640%20(2).jpg" alt="640 (2)" /><figcaption>640 (2)</figcaption></figure><h5 id="local-attention">Local Attention</h5><p>Global Attention 有缺陷：<strong>当输入的句子特别长的时候（比如输入是段落或文档），Global Attention 的计算量将会变得很大</strong>。因为我们要求源句子中所有的词都参与每一时刻的计算，所以作者才提出了Local Attention，即只注意源句子的一个小子集，而不是所有单词。Local Attention 的思想也来源于前人的工作，有关 Soft Attention 和 Hard Attention 之间的折中权衡。 <strong>不像软对齐那样注意所有的输入而导致计算量过大，也不像硬对齐那样只选择一个输入而导致过程不可微，需要加入复杂的技巧（variance reduction、reinforcement learning）来训练模型。</strong>因此 Local Attention 既可微，能训练，同时计算量小。</p><p><strong>Local Attention 的思想是只关注每个目标词的源位置的子集。</strong>该模型首先预测当前目标词的对齐位置。然后，以源位置 <span class="math inline">\(p_t\)</span> 为中心的窗口用于计算上下文向量 <span class="math inline">\(c_t\)</span>，即窗口中源隐藏状态的加权平均值。从窗口中的当前目标状态 <span class="math inline">\(h_t\)</span> 和源状态 <span class="math inline">\(\bar h_s\)</span> 推断出权重 <span class="math inline">\(a_t\)</span>。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210727091743663.png" alt="image-20210727091743663" style="zoom: 67%;" /></p><h5 id="score-函数">Score 函数</h5><p>说到 Score 函数。score函数涉及点积运算(点积、余弦相似度等)，其思想是度量两个向量之间的相似度。对于前馈神经网络评分函数，其思想是让模型在变换的同时学习对齐权值。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/640.jpg" alt="640" /><figcaption>640</figcaption></figure><h3 id="attention-的本质">Attention 的本质</h3><div class="note note-primary">            <p>这块还是不懂，等再深入学习一下回来补充。</p>          </div><p>attention 是一组注意力分配系数的，attention 函数用来得到 attention value 的。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210712224747001.png" alt="image-20210712224747001" style="zoom: 50%;" /></p><p>attention value 的本质：它其实就是一个查询(query)到一系列键值(key-value)对的映射。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210712224959532.png" style="zoom: 67%;"/></p><p>attention函数共有三步完成得到 attention value。</p><ul><li>Q 与 K 进行相似度计算得到权值</li><li>对上部权值归一化</li><li>用归一化的权值与 V 加权求和</li></ul><p>此时加权求和的结果就为注意力值。 <span class="math display">\[\text { Attention }\left(\text { Query }_{j}, \text { Source }\right)=\sum_{i=1}^{N} \text { Similarity }\left(\text { Query }_{j}, \text { Key }_{i}\right) * \text { Value }_{i}\]</span></p><p>在自然语言任务中，往往 Key 和 Value 是相同的。需要注意的是，计算出来的 attention value 是一个向量，代表序列元素 <span class="math inline">\(x_j\)</span> 的编码向量，包含了元素 <span class="math inline">\(x_j\)</span> 的上下文关系，即同时包含全局联系和局部联系。全局联系很好理解，因为在计算时考虑了该元素与其他所有元素的相似度计算；而局部联系则是因为在对元素 <span class="math inline">\(x_j\)</span> 进行编码时，重点考虑与其相似度较高的局部元素，尤其是其本身。</p><h3 id="attention-机制的优劣">Attention 机制的优劣</h3><p>相比于传统的 RNN 和 CNN，attention 机制具有如下优点：</p><ul><li>一步到位的全局联系捕捉，且关注了元素的局部联系；attention 函数在计算 attention value 时，是进行序列的每一个元素和其它元素的对比，在这个过程中每一个元素间的距离都是一；而在时间序列 RNNs 中，元素的值是通过一步步递推得到的长期依赖关系获取的，而越长的序列捕捉长期依赖关系的能力就会越弱。</li><li>并行计算减少模型训练时间；Attention 机制每一步的计算都不依赖于上一步的计算结果，因此可以并行处理。</li><li>模型复杂度小，参数少</li></ul><p>但 attention 机制的缺点也比较明显，因为是对序列的所有元素并行处理的，所以无法考虑输入序列的元素顺序，这在自然语言处理任务中比较糟糕。因为在自然语言中，语言的顺序是包含了十分多的信息的，如果缺失了该部分的信息，则得到的结果往往会大大折扣。</p><h3 id="attention-总结">Attention 总结</h3><p>简而言之，<strong>Attention 机制就是对输入的每个元素考虑不同的权重参数</strong>，从而更加关注与输入的元素相似的部分，而抑制其它无用的信息。其最大的优势就是能一步到位的考虑全局联系和局部联系，且能并行化计算，这在大数据的环境下尤为重要。同时需要注意的是， Attention 机制作为一种思想，并不是只能依附在 Encoder-Decoder 框架下的，而是可以根据实际情况和多种模型进行结合。</p><p>好的教程可以看：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/37601161">深度学习中的注意力模型</a>，非常详细的讲解了 Attention机制 的形成过程。</p></li><li><a href="https://lilianweng.github.io/lil-log/2018/06/24/attention-attention.html#soft-vs-hard-attention">注意力？注意力！</a>，叙述了注意力的发明和各种注意力机制和模型，例如 Transformer 和 SNAIL。</li><li><a href="https://zhuanlan.zhihu.com/p/35571412">浅谈Attention机制的理解</a>，讲了 Attention 的本质。</li><li><p><a href="https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/">Visualizing A Neural Machine Translation Model (Mechanics of Seq2seq Models With Attention)</a>，关于 model 的可视化</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Attention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环神经网络 RNN</title>
    <link href="/2021/07/05/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%20RNN/"/>
    <url>/2021/07/05/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%20RNN/</url>
    
    <content type="html"><![CDATA[<h1 id="循环神经网络-rnn">循环神经网络 RNN</h1><p>循环神经网络（recurrent neural network）或RNN是一类用于处理<strong>序列数据</strong>的神经网络。序列数据用原始的神经网络难以建模，基于此，RNN 引入了 hidden state， 可对序列数据提取特征，接着再转换为输出。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210724085122874.png" style="zoom:60%"/></p><blockquote><p>注：图中的圆圈表示向量，箭头表示对向量做变换。</p></blockquote><p>这就是最经典的RNN结构，它的输入是 <span class="math inline">\(x_1, x_2, ...x_n\)</span>，输出为 <span class="math inline">\(y1, y2, ...yn\)</span>，也就是说，<strong>输入和输出序列必须要是等长的</strong>。再详细展开RNN。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210706192557245.png" style="zoom:90%"/></p><p><span class="math inline">\(x\)</span> 是一个向量，它表示<strong>输入层</strong>的值。<span class="math inline">\(s\)</span> 是一个向量，它表示<strong>隐藏层</strong>的值。<span class="math inline">\(U\)</span> 是输入层到隐藏层的<strong>权重矩阵</strong>。<span class="math inline">\(o\)</span> 也是一个向量，它表示<strong>输出层</strong>的值。<span class="math inline">\(V\)</span> 是隐藏层到输出层的<strong>权重矩阵</strong>。</p><p><strong>循环神经网络</strong>的<strong>隐藏层</strong>的值 <span class="math inline">\(s\)</span> 不仅仅取决于当前这次的输入 <span class="math inline">\(x\)</span>，还取决于上一次<strong>隐藏层</strong>的值 <span class="math inline">\(s\)</span>。<strong>权重矩阵</strong> <span class="math inline">\(W\)</span> 就是<strong>隐藏层</strong>上一次的值作为这一次的输入的权重。</p><p>所以，RNN这个网络在 <span class="math inline">\(t\)</span> 时刻接收到输入 <span class="math inline">\(x_{t}\)</span> 之后, 隐藏层的值是 <span class="math inline">\(s_{t}\)</span>, 输出值是 <span class="math inline">\(o_{t}\)</span> . 关键一点是, <span class="math inline">\(s_{t}\)</span> 的值不仅仅取决于 <span class="math inline">\(x_{t}\)</span>，还取决于 <span class="math inline">\(s_{t-1}\)</span> 。可以用下面的公式来表示RNN的计算方法: <span class="math display">\[\begin{array}{l}S_{t}=f\left(U \cdot X_{t}+W \cdot S_{t-1}\right) \\ O_{t}=g\left(V \cdot S_{t}\right) \\\end{array}\]</span> 这里的 <span class="math inline">\(f()\)</span> 函数表示激活函数，对于 CNN 来说，激活函数一般选取的都是 ReLU，但是 RNN 一般选用 tanh。<span class="math inline">\(S_t\)</span> 的值不仅仅取决于 <span class="math inline">\(X_t\)</span>，还取决于 <span class="math inline">\(S_{t-1}\)</span>。可以将这个过程理解为，你现在大四，你的知识是由大四学到的知识（当前输入 <span class="math inline">\(X_t\)</span>）和大三以及大三以前学到的知识（记忆 <span class="math inline">\(S_{t-1}\)</span>）的结合。</p><p><strong>RNN 的结构细节：</strong></p><ol type="1"><li>可以把 <span class="math inline">\(S_t\)</span> 当作隐状态，捕捉了之前时间点上的信息。就像你去考研一样，考的时候记住了你能记住的所有信息</li><li>可惜的是 <span class="math inline">\(S_t\)</span> 并不能捕捉之前所有时间点的信息，或者说在网络传播的过程中会 &quot;忘掉&quot; 一部分。就像你考研也记不住所有的英语单词一样</li><li>和卷积神经网络一样，RNN 中的每个节点都共享了一组参数 <span class="math inline">\((U,V,W)\)</span>，这样就能极大降低计算量</li></ol><p>由于 <strong>RNN 输入和输出序列必须是等长的</strong>，因为这个限制的存在，经典RNN的适用范围比较小，但也有一些问题适合用经典的RNN结构建模，如：</p><ul><li><p>计算视频中每一帧的分类标签。因为要对每一帧进行计算，因此输入和输出序列等长。</p></li><li><p>输入为字符，输出为下一个字符的概率。这就是著名的 <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">Char RNN</a></p></li></ul><h2 id="经典的rnn结构n-vs-n">经典的RNN结构（N vs N）</h2><h3 id="n-vs-1">N VS 1</h3><p>有的时候，要处理的问题是，输入是一个序列，输出是一个单独的值(而不是序列)，此时通常在最后的一个 序列上进行输出变换。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210724090448797.png" style="zoom:60%"/></p><p>这种 N VS 1 结构通常用来处理序列分类问题，如：</p><ul><li>输入一段文字判别它所属的类别</li><li>输入一个句子判断其情感倾向</li><li>输入一段视频并判断它的类别等等。</li></ul><h3 id="vs-n">1 VS N</h3><p>有时要处理的问题输入是一个单独的值，输出是一个序列。此时，有两种主要建模方式：</p><p>方式一：可只在其中的某一个序列进行计算，比如序列第一个进行输入计算：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210724090842023.png" style="zoom:60%"/></p><p>方式二：把输入信息X作为每个阶段的输入：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210724090926460.png" style="zoom:60%"/></p><p>这种 1 VS N 的结构可以处理的问题有：</p><ul><li>从图像生成文字（image caption），此时输入的X就是图像的特征，而输出的y序列就是一段句子</li><li>从类别生成语音或音乐等</li></ul><h3 id="n-vs-m">N vs M</h3><p>RNN最重要的一个变种：N vs M。这种结构又叫 Encoder-Decoder 模型，也可以称之为Seq2Seq模型。原始的 N vs N RNN要求序列等长，然而我们遇到的大部分问题序列都是不等长的，如机器翻译中，源语言和目标语言的句子往往并没有相同的长度。</p><p>因此，<strong>Encoder-Decoder结构先将输入数据编码成一个语义向量c，然后用另一个RNN网络对其进行解码</strong>。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210724091327947.png" /></p><p>这种 N VS M 的结构可以处理的问题有：</p><ul><li>机器翻译，输入一种语言文本序列，输出另外一种语言的文本序列</li><li>文本摘要，输入文本序列，输出这段文本序列摘要</li><li>阅读理解，输入文章，输出问题答案</li><li>语音识别，输入语音序列信息，输出文字序列</li></ul><p>详细的 Seq2Seq 介绍可以看这篇文章 ==Seq2Seq和Attention==。</p><h2 id="cnn和rnn的区别">CNN和RNN的区别</h2><table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr class="header"><th>类别</th><th>特点描述</th></tr></thead><tbody><tr class="odd"><td>相同点</td><td>1、传统神经网络的扩展。<br />2、前向计算产生结果，反向计算模型更新。<br />3、每层神经网络横向可以多个神经元共存,纵向可以有多层神经网络连接。</td></tr><tr class="even"><td>不同点</td><td>1、CNN空间扩展，神经元与特征卷积；RNN时间扩展，神经元与多个时间输出计算<br />2、RNN可以用于描述时间上连续状态的输出，有记忆功能，CNN用于静态输出</td></tr></tbody></table><h2 id="前向传播和反向传播bptt">前向传播和反向传播BPTT</h2><p>以下图为例：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210706201554377.png" style="zoom:80%"/></p><p>假设时间序列只有三段, <span class="math inline">\(S_{0}\)</span> 为给定值, 神经元没有激活函数, 则RNN最简单的前向传播过程如下: <span class="math display">\[S_{1}=W_{x} X_{1}+W_{s} S_{0}+b_{1} O_{1}=W_{o} S_{1}+b_{2} \\ S_{2}=W_{x} X_{2}+W_{s} S_{1}+b_{1} O_{2}=W_{o} S_{2}+b_{2} \\ S_{3}=W_{x} X_{3}+W_{s} S_{2}+b_{1} O_{3}=W_{o} S_{3}+b_{2} \]</span> 假设在 <span class="math inline">\(\mathrm{t}=3\)</span> 时刻，损失函数为 <span class="math inline">\(L_{3}=\frac{1}{2}\left(Y_{3}-O_{3}\right)^{2}\)</span>。则对于一次训练任务的损失函数为 <span class="math inline">\(L=\sum_{t=0}^{T} L_{t}\)</span>, 即每一时刻损失值的累加.</p><p>BPTT(back-propagation through time)算法是常用的训练RNN的方法，其本质还是BP算法，只不过RNN处理时间序列数据，所以要基于时间反向传播，故叫随时间反向传播。BPTT的中心思想和BP算法相同，沿着需要优化的参数的负梯度方向不断寻找更优的点直至收敛。使用随机梯度下降法训练RNN其实就是对 <span class="math inline">\(W_{x},W_{s},W_{o}\)</span> 以及 <span class="math inline">\(b_{1},b_{2}\)</span> 求偏导, 并不断调整它们以使L尽可能达到最小的过程。</p><p>现在假设时间序列只有三段, <span class="math inline">\(\mathrm{t} 1, \mathrm{t} 2, \mathrm{t} 3\)</span> 。只对 <span class="math inline">\(\mathrm{t} 3\)</span> 时刻的 <span class="math inline">\(W_{x},W_{s},W_{o}\)</span> 求偏导(其他时刻类似): <span class="math display">\[\frac{\partial L_{3}}{\partial W_{o}}=\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial W_{o}} \\ \frac{\partial L_{3}}{\partial W_{x}}=\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial W_{x}}+\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial S_{2}} \frac{\partial S_{2}}{\partial W_{x}}+\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial S_{2}} \frac{\partial S_{2}}{\partial S_{1}} \frac{\partial S_{1}}{\partial W_{x}} \\ \frac{\partial L_{3}}{\partial W_{s}}=\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial W_{s}}+\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial S_{2}} \frac{\partial S_{2}}{\partial W_{s}}+\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial S_{2}} \frac{\partial S_{2}}{\partial S_{1}} \frac{\partial S_{1}}{\partial W_{s}}\]</span> 可以看出对于 <span class="math inline">\(W_{0}\)</span> 求偏导并没有长期依赖, 但是对于 <span class="math inline">\(W_{x}, W_{s}\)</span> 求偏导, 会随着时间序列产生长期依赖。因为 <span class="math inline">\(S_{t}\)</span> 随着时间序列向前传播, 而 <span class="math inline">\(S_{t}\)</span> 又是 <span class="math inline">\(W_{x}, W_{s}\)</span> 的函数。 根据上述求偏导的过程可以得出任意时刻对 <span class="math inline">\(W_{x}, W_{s}\)</span> 求偏导的公式: $$ =<em>{k=0}^{t}  (</em>{j=k+1}^{t} )  \</p><p>=<em>{k=0}^{t}  (</em>{j=k+1}^{t} )  <span class="math display">\[如果加上激活函数,  $S_{j}=\tanh \left(W_{x} X_{j}+W_{s} S_{j-1}+b_{1}\right)$,则  \]</span> <em>{j=k+1}^{t} =</em>{j=k+1}^{t} ^{} W_{s} $$</p><h2 id="rnn-梯度消失和梯度爆炸">RNN 梯度消失和梯度爆炸</h2><p>激活函数tanh和它的导数图像如下。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/tanh.jpg" style="zoom:30%"/></p><p>由上图可以看出 <span class="math inline">\(\tanh ^{\prime} \leq 1\)</span>, 对于训练过程大部分情况下 <span class="math inline">\(tanh\)</span> 的导数是小于1的，因为很少情况下会出现 <span class="math inline">\(W_{x} X_{j}+W_{s} S_{j-1}+b_{1}=0\)</span> , 如果 <span class="math inline">\(W_{s}\)</span> 也是一个大于0小于1的值, 则当t很大时 <span class="math inline">\(\prod_{j=k+1}^{t} \tanh ^{\prime} \cdot W_{s}\)</span> 就会趋近于0(和 $0.01^{50} $ 趋近与0是一个道理)。同理当 <span class="math inline">\(W_{s}\)</span> 很大时 <span class="math inline">\(\prod_{j=k+1}^{t} \tanh ^{\prime} \cdot W_{s}\)</span> 就会趋近于无穷, 这就是RNN中梯度消失和爆炸的原因。</p><p>于是，为了解决这个现象，出现了LSTM.</p><h1 id="lstm">LSTM</h1><p>长时间的短期记忆网络（Long Short-Term Memory Networks），很多地方翻译为长短期记忆网络，给人一种歧义，以为是网络一会儿能记很长的内容，一会儿能记很短的内容，但其实正确的翻译应该是长时间的短期记忆网络。它的本质就是能够记住很长时期内的信息.</p><p>所有 RNN 都具有一种重复神经网络模块的链式的形式。在标准的 RNN 中，这个重复的模块只有一个非常简单的结构，例如一个 tanh 层，如下图所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM1.png" style="zoom:60%"/></p><p>LSTM 是一种 RNN 特殊的类型，可以学习长期依赖信息。LSTM 同样是这样的结构，但是重复的模块拥有一个不同的结构。不同于单一神经网络层，这里是有四个，以一种非常特殊的方式进行交互。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM2.png" style="zoom:60%"/></p><p>注：上图图标具体含义如下所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM3.png" style="zoom:80%"/></p><p>上图中，每一条黑线传输着一整个向量，从一个节点的输出到其他节点的输入。粉色的圈代表 pointwise 的操作，如向量的乘法、加法，而黄色的矩阵就是学习到的神经网络层。合在一起的线表示向量的连接（比如一个是 <span class="math inline">\(h_{t−1}\)</span>，另一个是 <span class="math inline">\(x_t\)</span>，那么合并后的输出就是 <span class="math inline">\([h_{t−1},x_t]\)</span>）。分开的线表示内容被复制，然后分发到不同的位置。</p><h2 id="lstm-核心思想">LSTM 核心思想</h2><p>LSTM 的关键就是 cell 状态，即贯穿图顶部的水平线。cell 状态的传输就像一条传送带，向量从整个 cell 中穿过，只是做了少量的线性操作，这种结构能很轻松地实现信息从整个 cell 中穿过而不做改变（这样就可以实现长时期地记忆保留）</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM4.png" style="zoom:80%"/></p><p>LSTM 也有能力向 cell 状态中添加或删除信息，这是由称为<strong>门（gates）</strong>的结构仔细控制的。<strong>门</strong>可以选择性的让信息通过，它们由 sigmoid 神经网络层和 pointwise 逐点相乘实现：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM5.png" style="zoom:80%"/></p><p>LSTM 拥有三个门，分别是忘记门，输入门和输出门，来控制信息。</p><h3 id="遗忘门">遗忘门</h3><p>LSTM 的第一步是<strong>决定要从 cell 状态中丢弃什么信息</strong>，这个决定是由一个叫做 <code>forget gate layer</code> 的 sigmoid 神经层来实现的。它的输入是 <span class="math inline">\(h_{t−1}\)</span> 和 <span class="math inline">\(x_t\)</span>，输出是一个数值都在 0~1 之间的向量（向量长度和 <span class="math inline">\(C_{t−1}\)</span> 一样），表示让 <span class="math inline">\(C_{t−1}\)</span> 的各部分信息通过的比重，0 表示不让任何信息通过，1 表示让所有信息通过</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM6.png" style="zoom:80%"/></p><h3 id="输入门">输入门</h3><p>下一步是<strong>决定要让多少新的信息加入到 cell 状态中</strong>。实现这个需要包括两个步骤：首先，一个叫做 <code>input gate layer</code> 的 sigmoid 层决定哪些信息需要更新。另一个 tanh 层创建一个新的 candidate 向量 <span class="math inline">\(\tilde{C}_t\)</span> 。最后，我们把这两个部分联合起来对 cell 状态进行更新.</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM7.png" style="zoom:80%"/></p><p>下一步是将 <span class="math inline">\(C_{t-1}\)</span> 更新为 <span class="math inline">\(C_{t}\)</span>。将旧状态与 <span class="math inline">\(f_t\)</span> 相乘，丢弃掉我们确定需要丢弃的信息。接着加上 <span class="math inline">\(i_t * \tilde{C}_t\)</span> 得到新的候选值，根据我们决定更新每个状态的程度进行变化。其示意图如下：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM8.png" style="zoom:80%"/></p><h3 id="输出门">输出门</h3><p>最后，需要决定输出什么值了。这个输出主要是依赖于 cell 状态 <span class="math inline">\(C_t\)</span>，但是是经过筛选的版本。作用对象是隐层 <span class="math inline">\(h_t\)</span> hidden state。</p><p>操作步骤：</p><ul><li><p>步骤一：通过 sigmoid 层来确定细胞状态的哪个部分将输出。</p></li><li><p>步骤二：把细胞状态 <span class="math inline">\(C_t\)</span> 通过 tanh 进行处理（把数值归一化到 - 1 和 1 之间），并将它和 sigmoid 门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。</p></li></ul><p>其示意图如下所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM9.png" style="zoom:80%"/></p><p>无论是“ 遗忘门 ”，“ 输入门 ”，“ 输出门 ”，他们都被一个 <span class="math inline">\(0\)</span> ~ <span class="math inline">\(1\)</span> 之间的值所决定，这个值与一组数据做乘积，来显示这个数据的重要性。 而这个值都是由 <span class="math inline">\(h_{t-1}\)</span> 和 <span class="math inline">\(x_t\)</span> 经过 sigmoid 函数而得出来的，他们在不同的位置，衡量的却都是 “重要性”，更好理解的说法是：他们都衡量当前这个数据往后传递的必要性（重要性）：</p><ul><li>在遗忘门中，它决定了 <span class="math inline">\(C_{t-1}\)</span> 被遗忘的程度</li><li>在输入门中，它决定了 <span class="math inline">\(\tilde C_{i}\)</span> 的记忆程度，多少加入到记忆中来更新记忆</li><li>在输出门中，它决定了 这个更新的记忆输入到下一个隐藏层的重要程度。</li></ul><p>公式总结： <span class="math display">\[\begin{aligned}\left(\begin{array}{l}i \\f \\o \\g\end{array}\right) &amp;=\left(\begin{array}{c}\sigma \\\sigma \\\sigma \\\tanh\end{array}\right) W\left(\begin{array}{c}h_{t-1} \\x_{t}\end{array}\right) \\c_{t} &amp;=f \odot c_{t-1}+i \odot g \\h_{t} &amp;=o \odot \tanh \left(c_{t}\right)\end{aligned}\]</span> <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210723162852993.png" style="zoom:80%"/></p><h1 id="gru">GRU</h1><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210710222902681.png" style="zoom:80%"/></p><p>GRU(Gate Recurrent Unit) 是 RNN 的另一类演化变种，与LSTM非常相似。GRU结构中<strong>去除了单元状态，而使用隐藏状态来传输信息。</strong>它只有两个门结构，分别是更新门和重置门。相比LSTM，使用GRU能够达到相当的效果，并且相比之下更容易进行训练，能够很大程度上提高训练效率，因此很多时候会更倾向于使用GRU。</p><h3 id="重置门">重置门</h3><p>重置门用于决定丢弃先前信息的程度。</p><h3 id="更新门">更新门</h3><p>更新门的作用类似于LSTM中的遗忘门和输入门，它能决定要丢弃哪些信息和要添加哪些新信息。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/LSTM12.png" style="zoom:80%"/></p><p>可以看到，这里的遗忘 <span class="math inline">\(z_t\)</span> 和选择 <span class="math inline">\(1-z_t\)</span>是联动的。也就是说，对于传递进来的维度信息，我们会进行选择性遗忘，则遗忘了多少权重 <span class="math inline">\(1-z_t\)</span> ，我们就会使用包含当前输入的 <span class="math inline">\(\tilde{h}_{t}\)</span> 中所对应的权重进行弥补 <span class="math inline">\(z_t\)</span> 。以保持一种”恒定“状态。</p><h2 id="birnn">BiRNN</h2><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730213648990.png" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210730213824267.png" style="zoom: 67%;" /></p><p>可以将 BiRNN 看成是两层神经网络，第一层从左边作为系列的起始输入，在文本处理上可以理解成从句子的开头开始输入，而第二层则是从右边作为系列的起始输入，在文本处理上可以理解成从句子的最后一个词语作为输入，反向做与第一层一样的处理处理。最后对得到的两个结果进行处理。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>RNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卷积神经网络 CNN</title>
    <link href="/2021/07/03/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%20CNN/"/>
    <url>/2021/07/03/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%20CNN/</url>
    
    <content type="html"><![CDATA[<h2 id="卷积神经网络-cnn">卷积神经网络 CNN</h2><p>卷积神经网络是一种用来处理局部和整体相关性的计算网络结构，被应用在图像识别、自然语言处理甚至是语音识别领域，因为图像数据具有显著的局部与整体关系，其在图像识别领域的应用获得了巨大的成功。</p><p>以图像分类任务为例，下表所示卷积神经网络中，一般包含5种类型的网络层次结构：</p><table><thead><tr class="header"><th style="text-align: center;">CNN层次结构</th><th style="text-align: center;">输出尺寸</th><th style="text-align: left;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">输入层</td><td style="text-align: center;"><span class="math inline">\(W_1\times H_1\times 3\)</span></td><td style="text-align: left;">卷积网络的原始输入，可以是原始或预处理后的像素矩阵</td></tr><tr class="even"><td style="text-align: center;">卷积层</td><td style="text-align: center;"><span class="math inline">\(W_1\times H_1\times K\)</span></td><td style="text-align: left;"><strong>参数共享、局部连接，利用平移不变性从全局特征图提取局部特征</strong></td></tr><tr class="odd"><td style="text-align: center;">激活层</td><td style="text-align: center;"><span class="math inline">\(W_1\times H_1\times K\)</span></td><td style="text-align: left;"><strong>将卷积层的输出结果进行非线性映射</strong></td></tr><tr class="even"><td style="text-align: center;">池化层</td><td style="text-align: center;"><span class="math inline">\(W_2\times H_2\times K\)</span></td><td style="text-align: left;"><strong>进一步筛选特征，可以有效减少后续网络层次所需的参数量</strong></td></tr><tr class="odd"><td style="text-align: center;">全连接层</td><td style="text-align: center;"><span class="math inline">\((W_2 \cdot H_2 \cdot K)\times C\)</span></td><td style="text-align: left;"><strong>将多维特征展平为2维特征，通常低维度特征对应任务的学习目标（类别或回归值）</strong></td></tr></tbody></table><blockquote><p><span class="math inline">\(W_1\times H_1\times 3\)</span>对应原始图像或经过预处理的像素值矩阵，3对应RGB图像的通道;<span class="math inline">\(K\)</span>表示卷积层中卷积核（滤波器）的个数;<span class="math inline">\(W_2\times H_2\)</span> 为池化后特征图的尺度，在全局池化中尺度对应<span class="math inline">\(1\times 1\)</span>;<span class="math inline">\((W_2 \cdot H_2 \cdot K)\)</span>是将多维特征压缩到1维之后的大小，<span class="math inline">\(C\)</span>对应的则是图像类别个数。</p></blockquote><h3 id="输入">输入</h3><p><strong>输入层(Input Layer)通常是输入卷积神经网络的原始数据或经过预处理的数据</strong>，可以是图像识别领域中原始三维的多彩图像，也可以是音频识别领域中经过傅利叶变换的二维波形数据，甚至是自然语言处理中一维表示的句子向量。以图像分类任务为例，输入层输入的图像一般包含RGB三个通道，是一个由长宽分别为<span class="math inline">\(H\)</span>和<span class="math inline">\(W\)</span>组成的3维像素值矩阵<span class="math inline">\(H\times W \times 3\)</span>，卷积网络会将输入层的数据传递到一系列卷积、池化等操作进行特征提取和转化，最终由全连接层对特征进行汇总和结果输出。根据计算能力、存储大小和模型结构的不同，卷积神经网络每次可以批量处理的图像个数不尽相同，若指定输入层接收到的图像个数为<span class="math inline">\(N\)</span>，则输入层的输出数据为<span class="math inline">\(N\times H\times W\times 3\)</span>。</p><h3 id="卷积">卷积</h3><p>卷积层(Convolution Layer)通常用作对输入层输入的数据进行<strong>特征提取，通过卷积核矩阵对原始数据中隐含关联性的一种抽象。</strong>卷积操作原理上其实是<strong>对两张像素矩阵进行点乘求和的数学操作</strong>，其中一个矩阵为输入的数据矩阵，另一个矩阵则为卷积核（滤波器或特征矩阵），求得的结果表示为原始图像中提取的特定局部特征。</p><blockquote><p>下图表示卷积操作过程中的不同填充策略，上半部分采用零填充(Zero padding)，下半部分采用有效卷积（舍弃不能完整运算的边缘部分）。</p></blockquote><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210704173241487.png" style="zoom:60%"/></p><h4 id="卷积层的基本参数">卷积层的基本参数</h4><p>卷积层中需要用到卷积核（滤波器或特征检测器）与图像特征矩阵进行点乘运算，利用卷积核与对应的特征感受域进行划窗式运算时，需要设定卷积核对应的大小、步长、个数以及填充的方式.</p><table><colgroup><col style="width: 17%" /><col style="width: 41%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th style="text-align: center;">参数名</th><th style="text-align: left;">作用</th><th style="text-align: left;">常见设置</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">卷积核大小 (Kernel Size)</td><td style="text-align: left;">卷积核的大小定义了卷积的感受野</td><td style="text-align: left;">在过去常设为5，如LeNet-5；现在多设为3，通过堆叠<span class="math inline">\(3\times3\)</span>的卷积核来达到更大的感受域</td></tr><tr class="even"><td style="text-align: center;">卷积核步长 (Stride)</td><td style="text-align: left;">定义了卷积核在卷积过程中的步长</td><td style="text-align: left;">常见设置为1，表示滑窗距离为1，可以覆盖所有相邻位置特征的组合；当设置为更大值时相当于对特征组合降采样</td></tr><tr class="odd"><td style="text-align: center;">填充 (Padding)</td><td style="text-align: left;">在卷积核尺寸不能完美匹配输入的图像矩阵时需要进行一定的填充策略</td><td style="text-align: left;">设置为'SAME'表示对不足卷积核大小的边界位置进行某种填充（通常零填充）以保证卷积输出维度与与输入维度一致；当设置为'VALID'时则对不足卷积尺寸的部分进行舍弃，输出维度就无法保证与输入维度一致</td></tr><tr class="even"><td style="text-align: center;">输入通道数 (In Channels)</td><td style="text-align: left;">指定卷积操作时卷积核的深度</td><td style="text-align: left;">默认与输入的特征矩阵通道数（深度）一致；在某些压缩模型中会采用通道分离的卷积方式</td></tr><tr class="odd"><td style="text-align: center;">输出通道数 (Out Channels)</td><td style="text-align: left;">指定卷积核的个数</td><td style="text-align: left;">若设置为与输入通道数一样的大小，可以保持输入输出维度的一致性；若采用比输入通道数更小的值，则可以减少整体网络的参数量</td></tr></tbody></table><div class="note note-info">            <p>卷积操作维度变换公式：</p><p><span class="math display">\[O_d =\begin{cases} \lceil \frac{(I_d - k_{size})+ 1)}{s}\rceil ,&amp; \text{padding=VALID}\\ \lceil \frac{I_d}{s}\rceil,&amp;\text{padding=SAME} \end{cases}\]</span> 其中，<span class="math inline">\(I_d\)</span>为输入维度，<span class="math inline">\(O_d\)</span>为输出维度，<span class="math inline">\(k_{size}\)</span>为卷积核大小，<span class="math inline">\(s\)</span>为步长</p>          </div><h4 id="二维卷积与三维卷积">二维卷积与三维卷积</h4><p><strong>二维卷积</strong></p><p>二维卷积操作如下图所示，为了更直观的说明，分别展示在单通道和多通道输入中，对单个通道输出的卷积操作。在单通道输入的情况下，若输入卷积核尺寸为 <span class="math inline">\((k_h, k_w, 1)\)</span>，卷积核在输入图像的空间维度上进行滑窗操作，每次滑窗和 <span class="math inline">\((k_h, k_w)\)</span>窗口内的值进行卷积操作，得到输出图像中的一个值。在多通道输入的情况下，假定输入图像特征通道数为3，卷积核尺寸则为<span class="math inline">\((k_h, k_w, 3)\)</span>，每次滑窗与3个通道上的<span class="math inline">\((k_h, k_w)\)</span>窗口内的所有值进行卷积操作，得到输出图像中的一个值。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210705083954891.png" style="zoom:80%"/></p><p><strong>三维卷积</strong></p><p>3D卷积操作如图所示，同样分为单通道和多通道，且假定只使用1个卷积核，即输出图像仅有一个通道。对于单通道输入，与2D卷积不同之处在于，输入图像多了一个深度(depth)维度，卷积核也多了一个<span class="math inline">\(k_d\)</span>维度，因此3D卷积核的尺寸为<span class="math inline">\((k_h, k_w, k_d)\)</span>，每次滑窗与<span class="math inline">\((k_h, k_w, k_d)\)</span>窗口内的值进行相关操作，得到输出3D图像中的一个值。对于多通道输入，则与2D卷积的操作一样，每次滑窗与3个channels上的<span class="math inline">\((k_h, k_w, k_d)\)</span>窗口内的所有值进行相关操作，得到输出3D图像中的一个值。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210705084053317.png" style="zoom:80%"/></p><h4 id="卷积核是否一定越大越好">卷积核是否一定越大越好？</h4><p>在早期的卷积神经网络中（如LeNet-5、AlexNet），用到了一些较大的卷积核（<span class="math inline">\(11\times11\)</span>和<span class="math inline">\(5\times 5\)</span>），受限于当时的计算能力和模型结构的设计，无法将网络叠加得很深，因此卷积网络中的卷积层需要设置较大的卷积核以获取更大的感受域。但是这种大卷积核反而会导致计算量大幅增加，不利于训练更深层的模型，相应的计算性能也会降低。后来的卷积神经网络（VGG、GoogLeNet等），发现通过堆叠2个<span class="math inline">\(3\times 3\)</span>卷积核可以获得与<span class="math inline">\(5\times 5\)</span>卷积核相同的感受视野，同时参数量会更少（<span class="math inline">\(3×3×2+1\)</span> &lt; $ 5×5×1+1$），<span class="math inline">\(3\times 3\)</span>卷积核被广泛应用在许多卷积神经网络中。因此可以认为，在大多数情况下通过堆叠较小的卷积核比直接采用单个更大的卷积核会更加有效。</p><p>但是，这并不是表示更大的卷积核就没有作用，在某些领域应用卷积神经网络时仍然可以采用较大的卷积核。譬如在自然语言处理领域，由于文本内容不像图像数据可以对特征进行很深层的抽象，往往在该领域的特征提取只需要较浅层的神经网络即可。在将卷积神经网络应用在自然语言处理领域时，通常都是较为浅层的卷积层组成，但是文本特征有时又需要有较广的感受域让模型能够组合更多的特征（如词组和字符），此时直接采用较大的卷积核将是更好的选择。</p><p>综上所述，卷积核的大小并没有绝对的优劣，需要视具体的应用场景而定，但是极大和极小的卷积核都是不合适的，单独的<span class="math inline">\(1\times 1\)</span>极小卷积核只能用作分离卷积而不能对输入的原始特征进行有效的组合，极大的卷积核通常会组合过多的无意义特征从而浪费了大量的计算资源。</p><h4 id="怎样才能减少卷积层参数量">怎样才能减少卷积层参数量？</h4><p>减少卷积层参数量的方法可以简要地归为以下几点：</p><ul><li><u>使用堆叠小卷积核代替大卷积核</u>：VGG网络中2个<span class="math inline">\(3\times 3\)</span>的卷积核可以代替1个<span class="math inline">\(5\times 5\)</span>的卷积核</li><li>使用<u>分离卷积</u>操作：将原本<span class="math inline">\(K\times K\times C\)</span>的卷积操作分离为<span class="math inline">\(K\times K\times 1\)</span>和<span class="math inline">\(1\times1\times C\)</span>的两部分操作</li><li><u>添加<span class="math inline">\(1\times 1\)</span>的卷积</u>操作：与分离卷积类似，但是通道数可变，在<span class="math inline">\(K\times K\times C_1\)</span>卷积前添加<span class="math inline">\(1\times1\times C_2\)</span>的卷积核（满足<span class="math inline">\(C_2 &lt;C_1\)</span>）</li><li><u>在卷积层前使用池化操作</u>：池化可以降低卷积层的输入特征维度</li></ul><h4 id="卷积神经网络的参数设置">卷积神经网络的参数设置</h4><p>卷积神经网络中常见的参数在其他类型的神经网络中也是类似的，但是参数的设置还得结合具体的任务才能设置在合理的范围.</p><table><colgroup><col style="width: 27%" /><col style="width: 9%" /><col style="width: 63%" /></colgroup><thead><tr class="header"><th style="text-align: center;">参数名</th><th style="text-align: center;">常见设置</th><th style="text-align: left;">参数说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">学习率(Learning Rate)</td><td style="text-align: center;"><span class="math inline">\(0-1\)</span></td><td style="text-align: left;">反向传播网络中更新权值矩阵的步长，在一些常见的网络中会在固定迭代次数或模型不再收敛后对学习率进行指数下降(如<span class="math inline">\(lr=lr\times 0.1\)</span>)。当学习率越大计算误差对权值矩阵的影响越大，容易在某个局部最优解附近震荡；越小的学习率对网络权值的更新越精细，但是需要花费更多的时间去迭代</td></tr><tr class="even"><td style="text-align: center;">批次大小(Batch Size)</td><td style="text-align: center;"><span class="math inline">\(1-N\)</span></td><td style="text-align: left;">批次大小指定一次性流入模型的数据样本个数，根据任务和计算性能限制判断实际取值，在一些图像任务中往往由于计算性能和存储容量限制只能选取较小的值。在相同迭代次数的前提下，数值越大模型越稳定，泛化能力越强，损失值曲线越平滑，模型也更快地收敛，但是每次迭代需要花费更多的时间</td></tr><tr class="odd"><td style="text-align: center;">数据轮次(Epoch)</td><td style="text-align: center;"><span class="math inline">\(1-N\)</span></td><td style="text-align: left;">数据轮次指定所有训练数据在模型中训练的次数，根据数据集规模和分布情况会设置为不同的值。当模型较为简单或训练数据规模较小时，通常轮次不宜过高，否则模型容易过拟合；模型较为复杂或训练数据规模足够大时，可适当提高数据的训练轮次。</td></tr><tr class="even"><td style="text-align: center;">权重衰减系数(Weight Decay)</td><td style="text-align: center;"><span class="math inline">\(0-0.001\)</span></td><td style="text-align: left;">模型训练过程中反向传播权值更新的权重衰减值</td></tr></tbody></table><h4 id="提高卷积神经网络的泛化能力">提高卷积神经网络的泛化能力</h4><p>卷积神经网络与其他类型的神经网络类似，在采用反向传播进行训练的过程中比较依赖输入的数据分布，当数据分布较为极端的情况下容易导致模型欠拟合或过拟合，下表记录了提高卷积网络泛化能力的方法。</p><table><colgroup><col style="width: 21%" /><col style="width: 78%" /></colgroup><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">使用<strong>更多数据</strong></td><td style="text-align: left;">在有条件的前提下，尽可能多地获取训练数据是最理想的方法，更多的数据可以让模型得到充分的学习，也更容易提高泛化能力</td></tr><tr class="even"><td style="text-align: center;">使用<strong>更大批次</strong></td><td style="text-align: left;">在相同迭代次数和学习率的条件下，每批次采用更多的数据将有助于模型更好的学习到正确的模式，模型输出结果也会更加稳定</td></tr><tr class="odd"><td style="text-align: center;"><strong>调整数据分布</strong></td><td style="text-align: left;">大多数场景下的数据分布是不均匀的，模型过多地学习某类数据容易导致其输出结果偏向于该类型的数据，此时通过调整输入的数据分布可以一定程度提高泛化能力</td></tr><tr class="even"><td style="text-align: center;"><strong>调整目标函数</strong></td><td style="text-align: left;">在某些情况下，目标函数的选择会影响模型的泛化能力，如目标函数<span class="math inline">\(f(y,y&#39;)=|y-y&#39;|\)</span>在某类样本已经识别较为准确而其他样本误差较大的侵害概况下，不同类别在计算损失结果的时候距离权重是相同的，若将目标函数改成<span class="math inline">\(f(y,y&#39;)=(y-y&#39;)^2\)</span>则可以使误差小的样本计算损失的梯度比误差大的样本更小，进而有效地平衡样本作用，提高模型泛化能力</td></tr><tr class="odd"><td style="text-align: center;"><strong>调整网络结构</strong></td><td style="text-align: left;">在浅层卷积神经网络中，参数量较少往往使模型的泛化能力不足而导致欠拟合，此时通过叠加卷积层可以有效地增加网络参数，提高模型表达能力；在深层卷积网络中，若没有充足的训练数据则容易导致模型过拟合，此时通过简化网络结构减少卷积层数可以起到提高模型泛化能力的作用</td></tr><tr class="even"><td style="text-align: center;"><strong>数据增强</strong></td><td style="text-align: left;">数据增强又叫数据增广，在有限数据的前提下通过平移、旋转、加噪声等一些列变换来增加训练数据，同类数据的表现形式也变得更多样，有助于模型提高泛化能力，需要注意的是数据变化应尽可能不破坏元数数据的主体特征(如在图像分类任务中对图像进行裁剪时不能将分类主体目标裁出边界)。</td></tr><tr class="odd"><td style="text-align: center;"><strong>权值正则化</strong></td><td style="text-align: left;">权值正则化就是通常意义上的正则化，一般是在损失函数中添加一项权重矩阵的正则项作为惩罚项，用来惩罚损失值较小时网络权重过大的情况，此时往往是网络权值过拟合了数据样本(如<span class="math inline">\(Loss=f(WX+b,y&#39;)+\frac{\lambda}{\eta}\sum{|W|}\)</span>)。</td></tr><tr class="even"><td style="text-align: center;"><strong>屏蔽网络节点</strong></td><td style="text-align: left;">该方法可以认为是网络结构上的正则化，通过随机性地屏蔽某些神经元的输出让剩余激活的神经元作用，可以使模型的容错性更强。</td></tr></tbody></table><blockquote><p>对大多数神经网络模型同样通用</p></blockquote><h4 id="卷积神经网络凸显共性的原因">卷积神经网络凸显共性的原因？</h4><p><strong>局部连接／权值共享／池化操作／多层次结构。</strong></p><p><strong>局部连接使网络可以提取数据的局部特征；权值共享大大降低了网络的训练难度，一个Filter只提取一个特征，在整个图片（或者语音／文本） 中进行卷积；池化操作与多层次结构一起，实现了数据的降维，将低层次的局部特征组合成为较高层次的特征，从而对整个图片进行表示。</strong></p><h5 id="局部连接">局部连接</h5><p><strong>感受野（Receptive Field）的定义是卷积神经网络每一层输出的特征图（feature map）上的像素点在输入图片上映射的区域大小。</strong>通俗点的解释是，特征图上的一个点对应输入图上的区域。</p><p>在图像卷积操作中，神经元在空间维度上(指同一层)是局部连接，但在深度上是全连接。局部连接的思想，是受启发于生物学里的视觉系统结构，视觉皮层的神经元就是仅用局部接受信息。对于二维图像，局部像素关联性较强。这种<strong>局部连接保证了训练后的滤波器能够对局部特征有最强的响应，使神经网络可以提取数据的局部特征.</strong></p><p>下图是一个很经典的图示，左边是全连接，右边是局部连接。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/5.27.1.png" style="zoom:100%"/></p><p>对于一个1000 × 1000的输入图像而言，如果下一个隐藏层的神经元数目为 <span class="math inline">\(10^6\)</span> 个，采用全连接则有 <span class="math inline">\(1000 × 1000 × 10^6 = 10^{12}\)</span> 个权值参数，如此巨大的参数量几乎难以训练；而采用局部连接，隐藏层的每个神经元仅与图像中 10 × 10 的局部图像相连接，那么此时的权值参数数量为 <span class="math inline">\(10 × 10 × 10^6 = 10^8\)</span>，将直接减少4个数量级。</p><h5 id="权值共享">权值共享</h5><p><strong>权值共享，即计算同一深度的神经元时采用的卷积核参数是共享的。</strong>权值共享在一定程度上讲是有意义的，<strong>是由于在神经网络中，提取的底层边缘特征与其在图中的位置无关。</strong>但是在另一些场景中是无意的，如在人脸识别任务，我们期望在不同的位置学到不同的特征。</p><p>需要注意的是，权重只是对于同一深度切片的神经元是共享的。在卷积层中，通常采用多组卷积核提取不同的特征，即对应的是不同深度切片的特征，而不同深度切片的神经元权重是不共享。相反，偏置这一权值对于同一深度切片的所有神经元都是共享的。</p><p><u>权值共享带来的好处是大大降低了网络的训练难度。</u>如下图，假设在局部连接中隐藏层的每一个神经元连接的是一个10 × 10的局部图像，因此有10 × 10个权值参数，将这10 × 10个权值参数共享给剩下的神经元，也就是说隐藏层中 <span class="math inline">\(10^6\)</span> 个神经元的权值参数相同，那么此时不管隐藏层神经元的数目是多少，需要训练的参数就是这 10 × 10个权值参数（也就是卷积核的大小）。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/5.27.2.png" style="zoom:50%"/></p><p>这里就体现了卷积神经网络的奇妙之处，使用少量的参数，却依然能有非常出色的性能。上述仅仅是提取图像一种特征的过程。如果要多提取出一些特征，可以增加多个卷积核，不同的卷积核能够得到图像不同尺度下的特征，称之为特征图（feature map）。</p><h5 id="池化操作">池化操作</h5><p>池化操作与多层次结构一起，实现了数据的降维，将低层次的局部特征组合成为较高层次的特征，从而对整个图片进行表示。如下图：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/5.27.3.png" style="zoom:50%"/></p><h3 id="池化">池化</h3><p>池化层又称为降采样层(Downsampling Layer)。池化的作用是对感受域内的特征进行筛选，<strong>提取区域内最具代表性的特征，能够有效地降低输出特征尺度，进而减少模型所需要的参数量</strong>。按操作类型通常分为最大池化(Max Pooling)、平均池化(Average Pooling)和求和池化(Sum Pooling)，它们分别提取感受域内最大、平均与总和的特征值作为输出，最常用的是最大池化。</p><table style="width:100%;"><colgroup><col style="width: 26%" /><col style="width: 36%" /><col style="width: 36%" /></colgroup><thead><tr class="header"><th style="text-align: center;">池化类型</th><th style="text-align: center;">示意图</th><th style="text-align: left;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">一般池化(General Pooling)</td><td style="text-align: center;"><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/general_pooling.png" alt="general_pooling" /></td><td style="text-align: left;">通常包括最大池化(Max Pooling)和平均池化(Mean Pooling)。以最大池化为例，池化范围<span class="math inline">\((2\times2)\)</span>和滑窗步长<span class="math inline">\((stride=2)\)</span> 相同，仅提取一次相同区域的范化特征。</td></tr><tr class="even"><td style="text-align: center;">重叠池化(Overlapping Pooling)</td><td style="text-align: center;"><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/overlap_pooling.png" alt="overlap_pooling" /></td><td style="text-align: left;">与一般池化操作相同，但是池化范围<span class="math inline">\(P_{size}\)</span>与滑窗步长<span class="math inline">\(stride\)</span>关系为<span class="math inline">\(P_{size}&gt;stride\)</span>，同一区域内的像素特征可以参与多次滑窗提取，得到的特征表达能力更强，但计算量更大。</td></tr><tr class="odd"><td style="text-align: center;">空间金字塔池化<span class="math inline">\(^*\)</span>(Spatial Pyramid Pooling)</td><td style="text-align: center;"><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/spatial_pooling.png" alt="spatial_pooling" /></td><td style="text-align: left;">在进行多尺度目标的训练时，卷积层允许输入的图像特征尺度是可变的，紧接的池化层若采用一般的池化方法会使得不同的输入特征输出相应变化尺度的特征，而卷积神经网络中最后的全连接层则无法对可变尺度进行运算，因此需要空间金字塔池化对不同输出尺度采用不同的滑窗大小和步长以确保输出尺度相同。</td></tr></tbody></table><h4 id="卷积和池化有什么区别">卷积和池化有什么区别？</h4><p>卷积和池化在结构上具有一定的相似性，都是对感受域内的特征进行提取，并且根据步长设置获取到不同维度的输出，但是其内在操作是有本质区别的，如下表所示。</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">卷积</th><th style="text-align: center;">池化</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>结构</strong></td><td style="text-align: center;">零填充时输出维度不变，而通道数改变</td><td style="text-align: center;">通常特征维度会降低，通道数不变</td></tr><tr class="even"><td style="text-align: center;"><strong>稳定性</strong></td><td style="text-align: center;">输入特征发生细微改变时，输出结果会改变</td><td style="text-align: center;">感受域内的细微变化不影响输出结果</td></tr><tr class="odd"><td style="text-align: center;"><strong>作用</strong></td><td style="text-align: center;">感受域内提取局部关联特征</td><td style="text-align: center;">感受域内提取泛化特征，降低维度</td></tr><tr class="even"><td style="text-align: center;"><strong>参数量</strong></td><td style="text-align: center;">与卷积核尺寸、卷积核个数相关</td><td style="text-align: center;">不引入额外参数</td></tr></tbody></table><h3 id="激活层">激活层</h3><p><strong>激活层(Activation Layer)负责对卷积层抽取的特征进行激活</strong>，由于卷积操作是由输入矩阵与卷积核矩阵进行相差的线性变化关系，需要<strong>激活层对其进行非线性的映射</strong>。激活层主要由激活函数组成，<u>即在卷积层输出结果的基础上嵌套一个非线性函数，让输出的特征图具有非线性关系。</u>卷积神经网络中通常采用 ReLU 来充当激活函数（还包括 tanh 和 sigmoid 等）。ReLU 的函数形式如公式所示，能够限制小于0的值为0，同时大于等于0的值保持不变。 <span class="math display">\[f(x)=\begin{cases}   0 &amp;\text{if } x&lt;0 \\   x &amp;\text{if } x\ge 0\end{cases}\]</span></p><h3 id="全连接层">全连接层</h3><p><strong>全连接层(Full Connected Layer)负责对卷积神经网络学习提取到的特征进行汇总，将多维的特征输入映射为二维的特征输出</strong>，高维表示样本批次，低位常常对应任务目标。</p><h4 id="全连接局部连接全卷积与局部卷积">全连接、局部连接、全卷积与局部卷积</h4><p>大多数神经网络中高层网络通常会采用全连接层(Full Connected Layer)，通过多对多的连接方式对特征进行全局汇总，可以有效地提取全局信息。但是全连接的方式需要大量的参数，是神经网络中最占资源的部分之一，因此就需要由局部连接(Local Connected Layer)，仅在局部区域范围内产生神经元连接，能够有效地减少参数量。根据卷积操作的作用范围可以分为全卷积(Global Convolution)和局部卷积(Local Convolution)。实际上这里所说的全卷积就是标准卷积，即在整个输入特征维度范围内采用相同的卷积核参数进行运算，全局共享参数的连接方式可以使神经元之间的连接参数大大减少;局部卷积又叫平铺卷积(Tiled Convolution)或非共享卷积(Unshared Convolution)，是局部连接与全卷积的折衷。四者的比较如下表所示。</p><table><colgroup><col style="width: 6%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th style="text-align: center;">连接方式</th><th style="text-align: center;">示意图</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">全连接</td><td style="text-align: center;"><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/full-connected.png" alt="full-connected" /></td><td style="text-align: left;">层间神经元完全连接，每个输出神经元可以获取到所有输入神经元的信息，有利于信息汇总，常置于网络末层；连接与连接之间独立参数，大量的连接大大增加模型的参数规模。</td></tr><tr class="even"><td style="text-align: center;">局部连接</td><td style="text-align: center;"><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/local-connected.png" alt="local-connected" /></td><td style="text-align: left;">层间神经元只有局部范围内的连接，在这个范围内采用全连接的方式，超过这个范围的神经元则没有连接；连接与连接之间独立参数，相比于全连接减少了感受域外的连接，有效减少参数规模</td></tr><tr class="odd"><td style="text-align: center;">全卷积</td><td style="text-align: center;"><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/conv.png" alt="conv" /></td><td style="text-align: left;">层间神经元只有局部范围内的连接，在这个范围内采用全连接的方式，连接所采用的参数在不同感受域之间共享，有利于提取特定模式的特征；相比于局部连接，共用感受域之间的参数可以进一步减少参数量。</td></tr><tr class="even"><td style="text-align: center;">局部卷积</td><td style="text-align: center;"><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/local-conv.png" alt="local-conv" /></td><td style="text-align: left;">层间神经元只有局部范围内的连接，感受域内采用全连接的方式，而感受域之间间隔采用局部连接与全卷积的连接方式；相比与全卷积成倍引入额外参数，但有更强的灵活性和表达能力；相比于局部连接，可以有效控制参数量</td></tr></tbody></table><h4 id="fc-cnn-的区别">FC &amp; CNN 的区别</h4><p>在实际使用中，全连接层可由卷积操作实现：对前层是全连接的全连接层可以转化为卷积核为 1 x 1 的卷积；而前层是卷积层的全连接层可以转化为卷积核为 h x w 的全局卷积，h 和 w 分别为前层卷积结果的高和宽</p><p><strong><em>注</em></strong>: 有关卷积操作“实现”全连接层，有必要多啰嗦几句。</p><p>以VGG-16为例，对于224x224x3的输入：</p><p>最后一层卷积可得输出为7x7x512，如后层是一层含4096个神经元的FC，则可用卷积核为7x7x512x4096的全局卷积来实现这一全连接运算过程，其中该卷积核参数设为：“filter size = 7, padding = 0, stride = 1, D_in = 512, D_out = 4096”，经过此卷积操作后可得输出为1x1x4096。</p><blockquote><p>前层是卷积层的全连接层可以转化为卷积核为 h x w 的全局卷积，h 和 w 分别为前层卷积结果的高和宽</p></blockquote><p>如需再次叠加一个2048的FC，则可设定参数为“filter size = 1, padding = 0, stride = 1, D_in = 4096, D_out = 2048”的卷积层操作。</p><blockquote><p>前层是全连接的全连接层可以转化为卷积核为 1 x 1 的卷积</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>CNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神经网络 NN</title>
    <link href="/2021/07/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%20NN/"/>
    <url>/2021/07/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%20NN/</url>
    
    <content type="html"><![CDATA[<h2 id="深度学习_神经网络-nn">深度学习_神经网络 NN</h2><h3 id="m-p-神经元">1. M-P 神经元</h3><p>M‑P 神经元（名字源于两位发明者，一个用来模拟生物行为的数学模型）：接收<u>n个输入</u>(通常是来自其他神经元)，并<u>给各个输入赋予权重计算加权和</u>，然后<u>和自身特有的阈值进行比较（作减法）</u>，最后<u>经过激活函数（模拟“抑制”和“激活”）处理得到输出</u>（通常是给下一个神经元） <span class="math display">\[y=f\left(\sum_{i=1}^{n} w_{i} x_{i}-\theta\right)=f\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b\right)\]</span> 单个 M‑P 神经元：感知机（ sign 作激活函数）、对数几率回归（ sigmoid 作激活函数）</p><p>多个 M‑P 神经元：神经网络</p><h3 id="感知机">2. 感知机</h3><h4 id="感知机模型">感知机模型</h4><p>假设有一可以被线性分类的样本集 <span class="math inline">\(\left\{\left(x_{i}, y_{i}\right)\right\}_{i=1}^{N}\)</span> , 其中 <span class="math inline">\(x_{i} \in \mathbb{R}^{p}, y_{i}\{-1,+1\}_{\circ}\)</span> 输入 <span class="math inline">\(x\in X\)</span> 表示实例的特征向量，对应于输入空间（特征空间）的点； 输出 <span class="math inline">\(y\in\)</span> 表示实例的类别。 由输入空间到输出空间的如下函数： <span class="math display">\[f(x)=\operatorname{sign}(w⋅x+b)\]</span> 称为感知机。其中，<span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 为感知机模型参数，<span class="math inline">\(w\in \R^n\)</span> 叫作权值（weight ）或权值向量（weight vector ) , <span class="math inline">\(b\in\R\)</span> 叫作偏置（bias), <span class="math inline">\(w • x\)</span> 表示 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(x\)</span> 的内积。<span class="math inline">\(\operatorname{sign}\)</span> 是符号函数， 即 <span class="math display">\[\operatorname{sign}(x)=\left\{\begin{array}{l}+1, x \geq 0 \\-1, x&lt;0\end{array}\right.\]</span> 感知机预测，就是通过学习得到的感知机模型，对于新的输入实例给出其对应的输出类别。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210703150903113.png" style="zoom:60%"/></p><h4 id="感知机学习策略">感知机学习策略</h4><p>数据集一定要线性可分。感知机学习的目标是求得一个能够将训练集正实例点和负实例点完全正确分开的分离超平面。为了找出这样的超平面，即确定感知机模型参数 <span class="math inline">\(w,b\)</span>，需要确定一个学习策略，即定义损失函数井将损失函数极小化。</p><p>选择损失函数的两种原则：</p><ul><li>误分类点的总数</li><li>误分类点到超平面 <span class="math inline">\(S\)</span> 的总距离（感知机是通过这种方法）</li></ul><p>感知机的思想是<strong>错误驱动</strong>。其模型是 <span class="math inline">\(f(x)=\operatorname{sign}(w \cdot x+b)\)</span>，<span class="math inline">\(f(x)\)</span> 输出该样本点的类别，定义集合 <span class="math inline">\(M\)</span> 为误分类点的集合。</p><p>对于误分类的数据 <span class="math inline">\((x_{i},y_{i})\)</span> 来说，，它的 <span class="math inline">\(y_i\)</span> 一定与 <span class="math inline">\(w\cdot x_i+b\)</span> 异号，即：</p><p><span class="math display">\[-y_{i}\left(w \cdot x_{i}+b\right)&gt;0\]</span> 损失函数的一个自然选择是误分类点的个数, 即 <span class="math inline">\(L(w)=\sum_{i=1}^{N} I\left\{-y_{i}\left(w\cdot x_{i}+b\right)&gt;0\right\}\)</span> , 但是这样的损失函数是不可导的，不易优化。</p><blockquote><p>因为指示函数输出非0即1. 非连续的, 无法求导.</p></blockquote><p>因此采用另一种损失函数，<strong>即误分类点到超平面的总距离</strong>。</p><p>在 <span class="math inline">\(\mathbb{R}^{p}\)</span> 空间中任一点 <span class="math inline">\(x_{0}\)</span> 到超平面的距离为： <span class="math display">\[\frac{|w\cdot x_{0}+b|}{\|w\|}\]</span></p><p><span class="math display">\[可以参考初中知识，平面中点到直线的距离:  d=\frac{|A x+B y+C|}{\sqrt{A^{2}+B^{2}}}\]</span></p><p>所以误分类点 <span class="math inline">\(x_i\)</span> 到超平面 <span class="math inline">\(S\)</span> 的距离为 <span class="math display">\[-\frac{1}{\|w\|} y_{i}\left(w \cdot x_{i}+b\right)\]</span></p><p>其中, <span class="math inline">\(|| w||\)</span> 是 <span class="math inline">\(w\)</span> 的 <span class="math inline">\(L_{2}\)</span> 范式。我们假设误分类点的集合为 <span class="math inline">\(M\)</span> ，所以误分类点到超平面的总距离为， <span class="math display">\[-\frac{1}{\|w\|} \sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)\]</span> 不考虑 <span class="math inline">\(\frac{1}{\|w\|}\)</span>，就得到感知机的损失函数： <span class="math display">\[L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot  x_{i}+b\right)\]</span> 这个损失函数就是感知机学习的经验风险函数。如果没有误分类点 ，损失函数值是0。而且， 误分类点越少，误分类点离超平面越近，损失函数值就越小。</p><h4 id="感知机学习算法">感知机学习算法</h4><p>假设误分类点集合 <span class="math inline">\(M\)</span> 是固定的，那么计算损失函数 <span class="math inline">\(L(w,b)\)</span> 的梯度： <span class="math display">\[\frac{\partial L(w, b)}{\partial w}=-\sum_{x_{i} \in M} y_{i} x_{i} \\\frac{\partial L(w, b)}{\partial b}=-\sum_{x_{i} \in M} y_{i}\]</span> 感知机的学习算法使用随机梯度下降法 (SGD)，其学习的步骤如下：</p><p>输入: 训练数据集 <span class="math inline">\(T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}\)</span> ，其中 $x_{i} =^{n}, y_{i} ={-1,+1}, i=1,2, , N $；学习率 <span class="math inline">\(\eta(0&lt;\eta \leqslant 1)\)</span></p><p>输出: <span class="math inline">\(w, b\)</span>；感知机模型 <span class="math inline">\(f(x)=\operatorname{sign}(w \cdot x+b)\)</span></p><ol type="1"><li><p>选取初值 <span class="math inline">\(w_{0}, b_{0}\)</span>;</p></li><li><p>在训练集中选取数据 $(x_{i}, y_{i}) $</p></li><li><p>如果 <span class="math inline">\(y_{i}\left(w^{T} x_{i}+b\right) \leq 0\)</span>, 则更新参数 <span class="math display">\[w \leftarrow w+\eta y_{i} x_{i} \\b \leftarrow b+\eta y_{i}\]</span></p></li><li><p>④转至②，直到训练集中没有误分类点。</p></li></ol><p>这种学习算法直观上有如下解释：当一个实例点被误分类，即位于分离超平面的错误一侧时, 则调整 <span class="math inline">\(w, b\)</span> 的值, 使分离超平面向该误分类点的一侧移动, 以减少该误分类点与超平面间的距离, 直至超平面越过该误分类点使其被正确分类。</p><div class="note note-primary">            <p><em>希望小张推算一下P40的例2.1。补上</em></p>          </div><p>由于<u>像感知机这种单个神经元分类能力有限，只能分类线性可分的数据集</u>，对于线性不可分的数据集则无能为力，<u>但是多个神经元构成的神经网络能够分类线性不可分的数据集（西瓜书上异或问题的那个例子），且有理论证明（通用近似定理）</u>：只需一个包含足够多神经元的隐层，多层前馈网络就能以任意精度逼近任意复杂度的连续函数。因此，神经网络既能做回归，也能做分类，而且不需要复杂的特征工程。</p><h4 id="非线性问题的三种解决方法">非线性问题的三种解决方法</h4><p><strong>1.（明转）Non-Transformation:</strong> 将非线性问题转化为线性问题求解，高维比低维更易线性可分。</p><p>将二维转为三维。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210703115751657.png" style="zoom:40%"/></p><p><strong>2.（暗转）Kernel Method</strong>：隐藏了一个非线性变化，<span class="math inline">\(K(x,x′)=&lt;ϕ(x),ϕ(x′)&gt;\)</span></p><p>(具体可以看<a href="https://blog.csdn.net/qq_41485273/article/details/111752155">白板推导系列笔记（七）-核方法</a>) <font color="red">留坑，学完改链接。</font></p><p><strong>3.（自转）神经网络</strong>：</p><p>XOR(异或运算): 相同为0，不同为1</p><p>OR(或运算): 有一个就是1</p><p>AND(与运算): 都为1</p><p>NOT(非): 非0才为1 <span class="math display">\[x_{1} \oplus x_{2}= \left(\neg x_{1} \wedge x_{2}\right) \vee \left(x_{1} \wedge \neg x_{2}\right) \\复合函数 \to 复合表达式\]</span> <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210703134632242.png" style="zoom:60%"/></p><div class="note note-info">            <p>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</p><p>什么是特征工程？</p><p>特征工程本质是一项工程活动，目的是最大限度地从原始数据中提取特征以供算法和模型使用。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210702201059588.png" style="zoom:100%"/></p>          </div><h3 id="神经网络">3. 神经网络</h3><p>前馈神经网络：又称多层感知机(MLP)。每层神经元与下一层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接。（隐层阈值 $_h $，输出层阈值 <span class="math inline">\(\theta_j\)</span> ）</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210702202444468.png" style="zoom:40%"/></p><p>将神经网络（记为 NN​）看作一个特征加工函数 <span class="math display">\[\boldsymbol{x} \in \mathbb{R}^{d} \rightarrow \mathrm{NN}(\boldsymbol{x}) \rightarrow \boldsymbol{y}=\boldsymbol{x}^{*} \in \mathbb{R}^{l}\]</span></p><ul><li><p>(单输出）回归：后面接一个 <span class="math inline">\(\mathbb{R}^{l} \rightarrow \mathbb{R}\)</span> (<span class="math inline">\(l\)</span> 维到1维)的神经元，例如：没有激活函数的神经元 <span class="math display">\[y=\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}^{*}+b\]</span></p></li><li><p>分类：后面接一个 <span class="math inline">\(\mathbb{R}^{l} \rightarrow[0,1]\)</span> 的神经元，例如：激活函数为sigmoid函数的神经元 <span class="math display">\[y=\frac{1}{1+e^{-\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}^{*}+b\right)}}\]</span></p></li></ul><p>在模型训练过程中，神经网络(NN)自动学习提取有用的特征。神经网络的学习过程，就是根据训练数据来调整神经元之间的“连接权”（connection weight，权重..）以及每个功能神经元的阈值（偏置bias..）；换言之，神经网络学到的东西，蕴含在连接权和阈值中。</p><p>假设多层前馈网络中的激活函数全为sigmoid函数，且当前要完成的任务为一个（多输出）回归任务，因此损失函数可以采用均方误差（分类任务则用交叉嫡）。对于某个训 练样本 <span class="math inline">\(\left(\boldsymbol{x}_{k}, \boldsymbol{y}_{k}\right)\)</span> , 其中 <span class="math inline">\(\boldsymbol{y}_{k}=\left(y_{1}^{k}, y_{2}^{k}, \ldots, y_{l}^{k}\right)\)</span> , 假定其前馈网络的输出为 <span class="math inline">\(\hat{\boldsymbol{y}}_{k}=  \left(\hat{y}_{1}^{k}, \hat{y}_{2}^{k}, \ldots, \hat{y}_{l}^{k}\right)\)</span> , 则该单个样本的均方误差（损失）为 <span class="math display">\[E_{k}=\frac{1}{2} \sum_{j=1}^{l}\left(\hat{y}_{j}^{k}-y_{j}^{k}\right)^{2}\]</span></p><blockquote><p><span class="math inline">\(\frac{1}{2}\)</span> 是为了求导加的，常数对求导无影响。</p></blockquote><h4 id="反向传播算法-backpropagation">反向传播算法 BackPropagation</h4><p>BP算法：基于随机梯度下降的参数更新算法。以目标的负梯度方向对参数进行调整。 <span class="math display">\[\begin{array}{r}w \leftarrow w+\Delta w \\\Delta w=-\eta \nabla_{w} E\end{array}\]</span> 其中只需推导出 <span class="math inline">\(\nabla_{w} E\)</span> 这个损失函数 <span class="math inline">\(E\)</span> 关于参数 <span class="math inline">\(w\)</span> 的一阶偏导数(梯度)即可(链式求导)。</p><blockquote><p>由于 NN(x) 通常是极其复杂的非凸函数，不具备像凸函数这种良好的数学性质，因此随机梯度下降不能保证一定能走到全局最小值点，更多情况下走到的都是局部极小值点(local minima)。</p></blockquote><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210702224902509.png" style="zoom:40%"/></p><p>以输入层第 <span class="math inline">\(i\)</span> 个神经元与隐层第 <span class="math inline">\(h\)</span> 个神经元之间的连接权 <span class="math inline">\(w_{hj}\)</span> 为例推导： <span class="math display">\[E_{k}=\frac{1}{2} \sum_{j=1}^{l}\left(\hat{y}_{j}^{k}-y_{j}^{k}\right)^{2}, \quad \Delta v_{i h}=-\eta \frac{\partial E_{k}}{\partial v_{i h}}\]</span></p><p><span class="math display">\[\frac{\partial E_{k}}{\partial v_{i h}}=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial b_{h}} \cdot \frac{\partial b_{h}}{\partial \alpha_{h}} \cdot \frac{\partial \alpha_{h}}{\partial v_{i h}}\]</span></p><div class="note note-primary">            <p><span class="math display">\[E_k =\hat{y}_{1}^k + \hat{y}_{2}^k +...+\hat{y}_{l}^k \\\hat{y}_{1}^k = f_1(v_{ih}),\hat{y}_{2}^k = f_2(v_{ih})... \\\frac{\partial E_{k}}{\partial v_{i h}} = \frac{\partial f_{1}}{\partial v_{i h}} +  \frac{\partial f_{2}}{\partial v_{i h}} + ... +  \frac{\partial f_{l}}{\partial v_{i h}} =  \sum_{j=1}^{l} \frac{\partial f_{j}}{\partial v_{i h}}\]</span> 对sigmoid求导为 <span class="math display">\[f&#39;(x) = f(x)(1-f(x))\]</span> 所以 <span class="math inline">\(b_h\)</span> 对 <span class="math inline">\(a_h\)</span> 求导为 <span class="math display">\[b_h  = f(a_h - \gamma_h) = sigmoid(a_h - \gamma_h)\\\frac{\partial b_{h}}{\partial \alpha_{h}}=f&#39;(b_h) = f&#39;(a_h- \gamma_h) = f(a_h- \gamma_h) \cdot (1-f(a_h- \gamma_h))=b_h(1-b_h)\]</span> <span class="math inline">\(b_h\)</span> 对 <span class="math inline">\(a_h\)</span> 求导为 <span class="math display">\[\hat{y}_{j}^k  = f(\beta_j - \theta_j) = sigmoid(\beta_j - \theta_j)\\\frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}}=f&#39;(\hat{y}_{j}^k ) = f&#39;(\beta_j - \theta_j) = f(\beta_j - \theta_j) \cdot (1-f(\beta_j - \theta_j))=\hat{y}_{j}^k (1-\hat{y}_{j}^k )\]</span> 令 <span class="math inline">\(g_j\)</span> 为 <span class="math display">\[\begin{aligned}g_{j} &amp;=-\frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \\&amp;=-\left(\hat{y}_{j}^{k}-y_{j}^{k}\right) f^{\prime}\left(\beta_{j}-\theta_{j}\right) \\&amp;=\hat{y}_{j}^{k}\left(1-\hat{y}_{j}^{k}\right)\left(y_{j}^{k}-\hat{y}_{j}^{k}\right)\end{aligned}\]</span></p>          </div><p>综上得： <span class="math display">\[\begin{aligned}\frac{\partial E_{k}}{\partial v_{i h}} &amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial b_{h}} \cdot \frac{\partial b_{h}}{\partial \alpha_{h}} \cdot \frac{\partial \alpha_{h}}{\partial v_{i h}} \\&amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial b_{h}} \cdot \frac{\partial b_{h}}{\partial \alpha_{h}} \cdot x_{i} \\&amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial b_{h}} \cdot f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \cdot x_{i} \\&amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot w_{h j} \cdot f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \cdot x_{i} \\&amp;=\sum_{j=1}^{l}\left(-g_{j}\right) \cdot w_{h j} \cdot f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \cdot x_{i} \\&amp;=-f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \cdot \sum_{j=1}^{l} g_{j} \cdot w_{h j} \cdot x_{i} \\&amp;=-b_{h}\left(1-b_{h}\right) \cdot \sum_{j=1}^{l} g_{j} \cdot w_{h j} \cdot x_{i} \\&amp;=-e_{h} \cdot x_{i}\end{aligned}\]</span> 所以 <span class="math display">\[\Delta v_{i h}=-\eta \frac{\partial E_{k}}{\partial v_{i h}}=\eta e_{h} x_{i}\]</span></p><h3 id="代码实现">代码实现</h3><p><font color='red'>能力不足，时间紧迫，日后有待补充...</font></p><h3 id="参考资料">参考资料</h3><ol type="1"><li>周志华《机器学习》(西瓜书)</li><li>谢文睿《机器学习公式详解》(南瓜书)</li><li>李航《统计学习方法》</li><li><a href="https://www.bilibili.com/video/BV1Tt411s7fK">白板推导系列(二十三)-前馈神经网络（Feedforward Neural Network）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>《统计学习方法》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>李宏毅 深度学习基础</title>
    <link href="/2021/06/09/%E6%9D%8E%E5%AE%8F%E6%AF%85%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/06/09/%E6%9D%8E%E5%AE%8F%E6%AF%85%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="general-guide">General Guide</h2><p>以下就是如何让你做得更好的攻略，它适用于前期所有的作业。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609103623679.png" style="zoom:60%"/></p><p>从最上面开始，如果你觉得结果不满意，第一件事是<strong>检查 training data 的 loss</strong>。如果发现 training data 的 loss 很大，显然它在训练集上面也没有训练好。接下来就要分析，在训练集上面没有学好的原因是什么。有两个种可能，可能是 model 的 bias，可能是 Optimization Issue。</p><h3 id="model-bias">Model bias</h3><p>model bias 就是说，model 太过简单。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609103903538.png" style="zoom:80%"/></p><p>举例，现在写了一个含有未知参数的 function，参数带入不同的数，就组成了一个 function set ，用它来表示 model。但是这个 function set 太小了，不存在可以让 loss 降低的 funciton。</p><blockquote><p>说明这个 model 比较没用，就像大海捞针，结果针不在海里...</p></blockquote><p>这个时候<strong>重新设计一个 model，给 model 更大的弹性</strong>。举例来说，可以<strong>增加输入的 features</strong> 。以上次课程的预测观影人数举栗，本来输入的 features 只有前一天的数据，要预测接下来的观看人数。用前一天的数据不够多，就用前28天、前56天的数据，那 model 的弹性就会增大。</p><p>也可以用 Deep Learning 增加更多的弹性。</p><p>所以如果 model 的弹性不够大，那可以增加更多 features，可以设一个更大的model。或者可以用 deep learning 来增加 model 的弹性。这是第一个可以的解法。</p><h3 id="optimization-issue">Optimization Issue</h3><p>training data 的 loss 大并不一定是 model bias 的问题。可能是 Optimization 做的不好。</p><p>比如卡在 local minima 的地方，没有办法找到一个真的可以让 loss 很低的参数，像下图这样。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609114342633.png" style="zoom:70%"/></p><p>蓝色部分是 model 可以表示的函式所形成的集合。你可以把 <span class="math inline">\(θ\)</span> 代入不同的数值形成不同的function，把所有的 function 通通集合在一起得到这个蓝色的 set 。这个蓝色的 set 里面确实包含了一些 function，这些 function 它的 loss 是低的，但<u>问题是 gradient descent 这个演算法，没法找出这个 loss 低的 function</u>。gradient descent 找到 <span class="math inline">\(θ^*\)</span> 然后就结束了，但这个 <span class="math inline">\(θ^*\)</span> 它的 loss 不够低。这一个 model 里面，存在着某一个 function ，它的 loss 是够低的，但是 gradient descent 没有给我们这一个 function 。</p><blockquote><p>就像大海捞针，针确实在海里，但是我们却没有办法把针捞起来。</p></blockquote><p>那么，training data 的 loss 不够低的时候，到底是 model bias 还是 optimization 的问题呢？</p><h4 id="gaining-the-insights-from-comparison">Gaining the insights from comparison</h4><p>一个有用的判断方法是，通过比较不同的模型判断你的 model 够不够大。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609143806330.png" style="zoom:90%"/></p><p>如图所示，可以看到测试数据，56层的 loss 比20层的 loss 高。但是这个不是 overfitting ，因为可以看到训练数据同样也是56层的 loss 比20层的 loss 高。这说明56层的网络 optimization 没有做好。那为什么是因为 optimization 而不是model bias，因为56层的网络一定比20层的网络弹性好。所以说出现这个问题，说明 optimization 做的不好。</p><p>如果现在经过一番努力，training data 的 loss 变小了，那接下来可以看 testing data 的loss 。如果 testing data 的 loss也小，那就结束了，没啥好做的了:P。</p><h3 id="overfitting">Overfitting</h3><p>什么是过拟合呢？</p><ul><li>如果 <strong>training data 的 loss 小，testing data 的 loss 大</strong>，那可能就遇到 overfitting 的问题。</li></ul><p>为什么会有这种情况？</p><blockquote><p>举个通俗的栗子：上学考试的时候，有的人采取题海战术，把每个题目都背下来。但是题目稍微一变，他就不会做了。因为他非常复杂的记住了每道题的做法，而没有抽象出通用的规则。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609165034992.png" alt="image-20210609165034992" /><figcaption>image-20210609165034992</figcaption></figure></blockquote><p>举个极端的栗子：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609163443384.png" style="zoom:80%"/></p><p>这个函数表明，输入为x时，看训练集里有没有对应的 <span class="math inline">\(\hat{y}\)</span>，有的话就输出，没有就随机输出一个值。那这个函数相当于啥也没干。虽然他啥也没做，但是在 training data 的 loss 可是0呢。但在 testing data 上 loss 就会很大，因为他什么都没有预测，就是随机输出...</p><p>再举普通的栗子：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609165456416.png" style="zoom:60%"/></p><p>假设一个能力很强、弹性很大的 model，只给三个点作为 trainning data。</p><p>如果只用这三个数据，没有其他训练集作为限制，那这个 model 就会 freestyle，会产生奇奇怪怪的结果。这时，你再输入 testing data，loss 就会很大。</p><p><strong><em>那如何解决过拟合的问题呢？</em></strong></p><h4 id="增加训练集">1. 增加训练集</h4><p>也许这个方向往往是最有效的方向，是<strong>增加训练集</strong></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609170651739.png" style="zoom:60%"/></p><p>如果训练集，蓝色的点变多了，那虽然 model 它的弹性可能很大，但是因为数据非常非常的多，它就可以限制住 model 不那么 freestyle。</p><p>增加数据集可以采用 <strong>data augmentation</strong> 的方式。例如可以对图像做水平翻转、截取等等。要根据你对资料的特性，对现在要处理的问题的理解，来选择合适的 data augmentation 的方式。</p><h4 id="给模型增加限制">2. 给模型增加限制</h4><p>另一个方法就是<strong>给模型增加一些限制</strong>，让它不要有那么大的弹性。</p><ol type="1"><li>给它<strong>比较少的参数</strong>。例如 DL 中，把一层的神经元数减少或者让 model 共用参数(like CNN)。</li><li>用<strong>比较少的features</strong></li><li><strong>Early stopping</strong></li><li><strong>Dropout</strong></li></ol><p>但是也不要给太多的限制，因为可能又回到了 model bias 的问题。</p><p>假设现在的模型一定设置成了 Linear Model，那它产生的 function 就一定是一条直线。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609172721431.png" style="zoom:60%"/></p><p>给出的这三个点，没有办法产生一条直线，可以同时通过这三个点。这个时候，模型的限制就太大了，测试集不会有好结果。</p><p>但这个不是 overfitting，而是又回到了 <strong>model bias</strong> 的问题，因为模型的限制太大。</p><h3 id="cross-validation">Cross Validation</h3><p>把 Training 的资料分成两部分，一部分叫作 Training Set，一部分是 Validation Set。通过 Validation Set 来衡量模型的好坏。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609213036461.png" style="zoom:80%"/></p><h3 id="n-fold-cross-validation">N-fold Cross Validation</h3><p>N-fold Cross Validation就是先<strong>把训练集切成N等份</strong>，在这个例子里面我们切成三等份，切完以后，拿其中<strong>一份当作 Validation Set</strong>，<strong>另外两份当 Training Set</strong>，然后这件事情要<strong>重复三次</strong></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609213743965.png" style="zoom:60%"/></p><p>假设有三个模型需要判断，可以在这三种训练集的设定下，每个 model 都跑三次数据集，然后这个 model 的三次结果取平均。最终，三个模型的结果进行比较看谁的更好。</p><h3 id="mismatch">Mismatch</h3><p>Mismatch：训练集和测试集的分布不同。</p><p>like this...</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609154942184.png" style="zoom:70%"/></p><h2 id="critical-point">Critical Point</h2><h3 id="training-fails-because">Training Fails because</h3><p>常常在做 Optimization 的时候，会发现<strong>随着的参数不断的update，training 的 loss 不再下降</strong>，或者有可能一开始 loss 就掉不下去。</p><p>掉不下去的原因是因为走到了一个 gradient 为0的地方，这个地方参数对 loss 的微分为0。此时，gradient descent 就没有办法再更新参数，这个时候training就会停止，loss 当然也就不会下降。</p><p>gradient 为0的点有两种情况：<strong>local minima</strong> 和 <strong>saddle point</strong>。如图，local minima 是局部的最低点。而 saddle point， 是 gradient 是零，但不是local minima，也不是 local maxima 的地方，像一个马鞍的形状，所以也翻译成鞍点。</p><ul><li>如果卡在<strong>local minima，那可能就没有路可以走了</strong></li><li>如果卡在<strong>saddle point，saddle point旁边还是有路可以走的，</strong>只要逃离saddle point，就有可能让 loss 更低</li></ul><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210609220523185.png" style="zoom:70%"/></p><p>那当 gradient 接近0时，如何判断到底是哪种类型？</p><h4 id="warning-of-math">Warning of Math</h4><div class="note note-info">            <p>（缺乏数学知识导致这一段有些难理解...）</p>          </div><h3 id="summary">Summary</h3><ul><li>Critical points have zero gradients.</li><li>Critical points can be either saddle points or local minima.<ul><li>Can be determined by the Hessian matrix.</li><li>Local minima may be rare.</li><li>It is possible to escape saddle points along the direction of eigenvectors of the Hessian matrix</li></ul></li></ul><h2 id="batch">Batch</h2><p>在算微分时，并不是对所有的 Data 算出来的 L 做微分。而是把 data 分为一个个的 batch。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210610084142724.png" style="zoom:60%"/></p><p>每一个 batch 的大小为 B，每次在更新参数的时候，<strong>是拿一个 B 的 data 出来，算个 Loss，算个 Gradient，更新参数</strong>。<strong>所有的 Batch 看过一遍，叫做一个 Epoch</strong>。通常会在每一个 Epoch 开始之前做一个 Shuffle，就是重新分 Batch，随机打乱。每一个 Epoch 的 Batch 都不一样，就是 Shuffle。</p><h3 id="small-batch-v.s.-large-batch">Small Batch v.s. Large Batch</h3><p>为什么用 Batch 呢？</p><p>举个栗子：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210610085136616.png" style="zoom:60%"/></p><ul><li><p>左边的 Case 就是没有用 Batch，即 Batch = N（Full Batch）</p><p>Batch = N 时，所有 N 笔 Examples 都看完以后，才能够计算 Loss，才能够计算 Gradient，参数才能够更新一次。</p></li><li><p>右边的 Case 就是 Batch = 1</p><p>Batch = 1 时，在每一个 Epoch 里面，参数都会更新 N 次，就是看一次更新一次，所以他的 loss 时曲曲折折的。</p></li></ul><p>那么，哪种方式好一些呢？</p><p>看起来，左边的没有用 Batch 的方式时间可能会比较长，因为要看完所有的数据才更新一次。但是优点是比较稳定。右边的时间可能比较短，但是不稳定。<strong>实际上，考虑并行运算的话,左边这个并不一定时间比较长</strong></p><h4 id="larger-batch-size-does-not-require-longer-time-to-compute-gradient">Larger batch size does not require longer time to compute gradient</h4><p>验证：比较大的 Batch Size 算 Loss，再进而算 Gradient，所需要的时间，不一定比小的 Batch Size 要花的时间长</p><p>LHY 做了一个实验来验证，发现 bs = 1 和 bs = 1000 所需时间差不多。因为GPU可以做并行计算。这些数据可以并行处理，所以 1000 笔数据所需时间不是 1 笔数据的 1000 倍。然而 GPU处理数据量也是有上限的，所以数据如果很大时，会发现时间还是会增大。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210610093102242.png" style="zoom:50%"/></p><h4 id="smaller-batch-requires-longer-time-for-one-epoch">Smaller batch requires longer time for one epoch</h4><p>更新一次 Batch 时，因为 GPU 的并行运算能力，bs = 1 和 bs = 1000 所需时间相差无几。</p><p>然而，跑完一整个 Epoch 的时间就相差很多。bs = 1 时，需要更新 60000 次 Batch 才能跑完一整个 Epoch。bs = 1000 时，更新 60 次 Batch 就能跑完。右图中可以明显看到时间上的差距，bs = 1 比 bs = 1000 慢很多。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210610093247673.png" style="zoom:50%"/></p><p>所以，直觉上觉得，大的 Batch 所需时间长，但是如果考虑到 GPU 的并行计算，一个 Batch 大的 Epoch 花的时间反而是比较少的。</p><p>那这么说，大的 Batch Size 不就没有缺点了吗？</p><h4 id="noisy-update-is-better-for-training">“Noisy” update is better for training</h4><p>LHY 的实验表明，小的 bs 反而性能更好。小的 bs 的 noisy 的 gradient 会帮助 train。大的 bs结果比较差，因为 Optimization 会有问题。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210610093320005.png" style="zoom:60%"/></p><p>假设是 Full Batch，每次更新参数都是沿着这一个 loss function 进行梯度下降，当下降到 critical point 时，可能就会卡住没法进行更新。</p><p>如果是 Small Batch，因为每次更新都是挑一个 Batch 算它的 Loss，相当于是不同的 loss function 进行梯度下降，当遇到 saddle point 时可能会卡住，但是换另一个 loss function 更新时，也许就可以继续下去了。</p><p>所以这种 Noisy 的 Update 的方式，结果反而对 Training 是有帮助的。</p><h4 id="summary-1">Summary</h4><table><thead><tr class="header"><th></th><th style="text-align: center;">Small</th><th style="text-align: center;">Large</th></tr></thead><tbody><tr class="odd"><td>Speed for one update (no parallel)</td><td style="text-align: center;">Faster</td><td style="text-align: center;">Slower</td></tr><tr class="even"><td>Speed for one update (with parallel)</td><td style="text-align: center;">Same</td><td style="text-align: center;">Same(not too large)</td></tr><tr class="odd"><td>time for one epoch</td><td style="text-align: center;">Slower</td><td style="text-align: center;"><strong>Faster</strong></td></tr><tr class="even"><td>Gradient</td><td style="text-align: center;">Noisy</td><td style="text-align: center;">Stable</td></tr><tr class="odd"><td>Optimization</td><td style="text-align: center;"><strong>Better</strong></td><td style="text-align: center;">Worse</td></tr><tr class="even"><td>Generalization</td><td style="text-align: center;"><strong>Better</strong></td><td style="text-align: center;">Worse</td></tr></tbody></table><p>bs 的大小各自都有优势。所以，<strong>Batch Size</strong>变成了一个需要去调整的 Hyperparameter。</p><p><strong>Smaller batch size help escape critical points.</strong></p><h2 id="momentum">Momentum</h2><p>在物理世界里，一个球从高处斜坡滚落，如果遇到 saddle point，因为<strong>惯性</strong>，它不会被卡住，而是继续前进，如果动量够大，甚至会翻过这个坡。Momentum 就是这样的存在。</p><h4 id="vanilla一般的-gradient-descent">Vanilla(一般的) Gradient Descent</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210610111814035.png" style="zoom:100%"/></p><p>一般的梯度下降，设置初始的参数 <span class="math inline">\(\theta^0\)</span>，计算一下它的 gradient，然后往 gradient 的反向更新参数。 <span class="math display">\[\theta^1 = \theta^0 - \eta g^0\]</span> 然后重复这个过程。</p><h4 id="gradient-descent-momentum">Gradient Descent + Momentum</h4><p>为了突破 critical point，我们在 Gradient Descent 基础上加上 Momentum。</p><p>就是我们在更新参数时，<strong>不只是 Gradient 的反方向，再加上前一步更新的方向，二者加和去更新参数。</strong></p><blockquote><p>我的理解：</p><ul><li>Movement：当前前进方向，当前的 Momentum</li><li>Momentum：Movement of the last step</li></ul></blockquote><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210610112403096.png" style="zoom:100%"/></p><p>Gradient Descent + Momentum 的 Movement 过程是这样：</p><p>同样，设置初始的参数 <span class="math inline">\(\theta^0\)</span>，然后再假设前一步的 update 量为0 <span class="math display">\[\theta^0 = 0 \\ m^0 = 0\]</span> 在 <span class="math inline">\(\theta^0\)</span> 的地方，计算 Gradient 的方向 <span class="math inline">\(g^0\)</span>。然后要计算 Movement，<u>因为是初始，所以前一步的 Momentum 是0，与 Gradient 的反方向结合</u>，Movement 方向就变成： <span class="math display">\[m^1 = \lambda m^0 - \eta g^0 = - \eta g^0\\Move\quad to: \theta ^1 = \theta ^0 + m^1\]</span> 参数现在到 <span class="math inline">\(\theta^1\)</span>，计算 Gradient 的方向 <span class="math inline">\(g^1\)</span>。然后要计算 Movement，<u>前一步的 update 方向是 <span class="math inline">\(m1\)</span>，与 Gradient 的反方向结合</u>，Movement 的方向就变成： <span class="math display">\[m^2 = \lambda m^1 - \eta g^1 \\Move\quad to: \theta ^2 = \theta ^1 + m^2\]</span> 接下来也是反复进行同样的过程，在这个位置计算出 Gradient，然后 将前一步的方向与Gradient 反方向结合，作为下一步的移动方向。</p><p>每一步的移动 Movement 我们都用 m 来表示， <span class="math display">\[m^0 = 0\\m^1 = \lambda m^0 - \eta g^0 = - \eta g^0\\m^2 = \lambda m^1 - \eta g^1 = - \lambda \eta g^0 - \eta g^1\\m^3 = \lambda m^2 - \eta g^2 = - \lambda (- \lambda \eta g^0 - \eta g^1) - \eta g^2\\...\]</span> 当前的 Momentum 是 上一步的 Movement 加上这次梯度的反方向。另一种解读是，上面的式子类推，发现，<u>当加上 Momentum 时，Update 的方向，不是只考虑现在的 Gradient，而是考虑过去所有 Gradient 的总合。</u></p><h2 id="batch-normalization">Batch Normalization</h2><p>假设有两个参数，它们对 <strong>Loss 的斜率差别非常大</strong>，在 <span class="math inline">\(w_1\)</span> 这个方向上斜率变化很小，在 <span class="math inline">\(w_2\)</span> 这个方向上斜率变化很大。如果是<strong>固定的 learning rate</strong>，可能很难得到好的结果。所以说需要 adaptive 的 learning rate、 Adam 等等比较进阶的 optimization 的方法,才能够得到好的结果。</p><p>如果从另外一个方向想，<strong>直接把难做的 error surface 把它改掉</strong>，看能不能够改得好做一点。</p><p>首先，为什么会有两个参数相差比较大的情况呢？</p><p>假设一个简单的 linear model，<span class="math inline">\(y = w_1*x_1 + w_2*x_2 + b\)</span></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210612103105451.png" /></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210612103119376.png" /></div></div></div><p>对于 <span class="math inline">\(\Delta w\)</span>，当 <span class="math inline">\(x_1\)</span> 输入很小时， <span class="math inline">\(\Delta w\)</span> 变化，<span class="math inline">\(y\)</span> 的变化就很小。当 <span class="math inline">\(x_2\)</span> 输入很大时， <span class="math inline">\(\Delta w\)</span> 即使变化可能很小，<span class="math inline">\(y\)</span> 的变化也会很大。那样 L 的变化就会很大。当 <span class="math inline">\(w\)</span> 改变一点点，那 error surface 就会有很大的变化。</p><p>既然在这个 linear model 里，当 input 的 feature，<strong>每一个 dimension 的值，它的 scale 差距很大</strong>的时候，就可能产生像这样的 error surface，就可能产生<strong>不同方向，斜率非常不同，坡度非常不同的 error surface</strong></p><p>所以有没有办法，可以给 feature 里面<strong>不同的 dimension，让它有同样的数值的范围</strong>，这样就可以有比较好的 error surface，让训练变得容易一些。</p><p>其实有很多不同的方法，这些不同的方法合起来统称为 <strong>Feature Normalization</strong></p><h3 id="feature-normalization">Feature Normalization</h3><p>举个栗子：假设 <span class="math inline">\(x^1\)</span> 到 <span class="math inline">\(x^R\)</span> ，是所有的训练资料的 feature vector。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210612165401860.png" style="zoom:100%"/></p><p>每一个 vector 里面，<span class="math inline">\(x_1\)</span> 里 <span class="math inline">\(x_1^1\)</span> 代表 <span class="math inline">\(x_1\)</span> 的第一个 element，以此类推。</p><p>把<strong>不同笔资料即不同 feature vector，同一个 dimension</strong> 里面的数值取出来，计算第 i 个 dimension 的 平均值 <span class="math inline">\(m_i\)</span>，计算第 i 个 dimension 的标准差 <span class="math inline">\(\sigma_i\)</span>，然后可以做一个 normalization，标准化，也叫 standardization <span class="math display">\[\tilde{x}_{i}^{r} \leftarrow \frac{x_{i}^{r}-m_{i}}{\sigma_{i}}\]</span> 得到新的数值 <span class="math inline">\(\tilde{x}\)</span> 以后，<strong>再将新的数值把它塞回去</strong></p><p>好处是？</p><ul><li>normalize 以后，这个 dimension 上面的数值就会平均是 0， variance就会是 1,所以<strong>这一排数值的分布就都会在 0 上下</strong></li><li>对每一个 dimension 都做一样的 normalization，就会发现所有 feature 不同 dimension 的数值都在 0 上下,那就可以<strong>制造一个比较好的 error surface</strong></li></ul><p>Feature Normalization 的方式对 training 有帮助。它可以让你在做 gradient descent 的时候，这个 gradient descent <strong>的 Loss 收敛更快一点,可以让 gradient descent 的训练更顺利一点</strong></p><h3 id="considering-deep-learning">Considering Deep Learning</h3><h4 id="training">Training</h4><p>在 deep network 中</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210612170834778.png" style="zoom:60%"/></p><p>我们对 input 做了 Feature Normalization，通过一层网络后输出，这个输出 <span class="math inline">\(z_1, z_2...\)</span> 也是下一层的输入，可能经过运算后数值分布又有了很大差异，那就也需要对类似的这些 feature 做 normalization。</p><p>以 <span class="math inline">\(z_1,z_2,z_3\)</span> 为例，算出 <span class="math inline">\(\mu\)</span> ，算出 <span class="math inline">\(\sigma\)</span> <span class="math display">\[\begin{aligned}\boldsymbol{\mu} &amp;=\frac{1}{3} \sum_{i=1}^{3} \mathbf{z}^{i} \\\boldsymbol{\sigma} &amp;=\sqrt{\frac{1}{3} \sum_{i=1}^{3}\left(\mathbf{z}^{i}-\boldsymbol{\mu}\right)^{2}}\end{aligned}\]</span> 接下来就把这边的每一个 <span class="math inline">\(z\)</span>，都去减掉 <span class="math inline">\(\mu\)</span> 除以 <span class="math inline">\(\sigma\)</span>，得到 <span class="math inline">\(\tilde{z}^{i}\)</span>。输出作为新一轮的输入，以此类推。这就是这个网络。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210612231003466.png" style="zoom:60%"/></p><p>出现一个问题，训练资料很多，不能把整个数据 load 进 GPU，所以每次只送入一个 Batch 的数据，这就是 <strong>Batch Normalization</strong>。</p><p>在做 <strong>BN</strong> 的时候，会设置两个向量 <span class="math inline">\(\gamma\)</span> 和 <span class="math inline">\(\beta\)</span>： <span class="math display">\[\hat{\mathbf{z}}^{i}=\gamma \odot \tilde{\mathbf{z}}^{i}+\boldsymbol{\beta}\]</span> 为什么这么做？</p><p>如果做 normalization 以后，<span class="math inline">\(\tilde{z}^{i}\)</span> 它的平均就一定是 0。这可能会给 network 一些限制，<strong>也许这个限制会带来什麼负面的影响</strong>，所以我们把 <span class="math inline">\(\gamma\)</span> 和 <span class="math inline">\(\beta\)</span> 加回去。</p><div class="note note-info">            <p>其实我没太明白为什么...</p>          </div><p>在训练时：</p><ul><li><span class="math inline">\(\gamma\)</span> 的初始值，都设为 1 的 one vector</li><li><span class="math inline">\(\beta\)</span> 的初始值，都设为 0 的 one vector</li></ul><p>所以让 network 在一开始训练的时候，每一个 dimension 的分布是比较接近的。也许训练到后来已经训练够长的一段时间，已经找到一个比较好的 error surface，走到一个比较好的地方以后，再把 <span class="math inline">\(\gamma\)</span> 和 <span class="math inline">\(\beta\)</span> 慢慢地加进去。加 Batch Normalization，往往对训练是有帮助的。</p><h4 id="testing">Testing</h4><p>Batch Normalization 在 training 的时候，会分 batch 进入。</p><p>但是在 testing 时，不可能等一批数据完整进入才做一次运算。而 <span class="math inline">\(\gamma\)</span> 和 <span class="math inline">\(\beta\)</span> 必须要等一个完整的 batch 才能计算。如何解决这个问题？</p><p>答：<strong>moving average</strong>.</p><p>在 training 的时候，如果在做 Batch Normalization，在 training 的时候，每取一个 batch ，就计算出来 <span class="math inline">\(\mu^i\)</span> 和 <span class="math inline">\(\sigma ^i\)</span> ，算 <strong>moving average</strong>： <span class="math display">\[\overline{\boldsymbol{\mu}} \leftarrow p \overline{\boldsymbol{\mu}}+(1-p) \boldsymbol{\mu}^{t}\quad(p 在Pytorch里通常取 0.1)\]</span> <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210612234903184.png" style="zoom:80%"/></p><p>所以在 testing 的时候，没有 batch 这个东西。就直接拿 <span class="math inline">\(\overline{\boldsymbol{\mu}}\)</span> 跟 <span class="math inline">\(\overline{\boldsymbol{\sigma}}\)</span>，也就是 <span class="math inline">\(\overline{\boldsymbol{\mu}}\)</span> 跟 <span class="math inline">\(\overline{\boldsymbol{\sigma}}\)</span> 在训练的时候得到的 moving average <span class="math inline">\(\overline{\boldsymbol{\mu}}\)</span> 跟 $ $来取代这边的 <span class="math inline">\(\mu\)</span> 跟 <span class="math inline">\(\sigma\)</span>。</p><p>这个就是 Batch Normalization 在 testing 的时候的运作方式。</p><h2 id="adaptive-learning-rate">Adaptive Learning Rate</h2><h2 id="激活函数">激活函数？</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>李宏毅 机器学习介绍</title>
    <link href="/2021/06/06/%E6%9D%8E%E5%AE%8F%E6%AF%85%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/06/06/%E6%9D%8E%E5%AE%8F%E6%AF%85%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="machine-learning">Machine Learning</h2><p><strong>机器学习就是让机器具备找一个函数的能力</strong>。本质就是寻找一个函数 function，来找到一个输入 input 与输出 output 之间的映射关系。可以是输入一段语音，输出这段语音对应的文字；也可以输入一张图，输出这张图的内容；也可以输入一场棋局，输出下一步应该走哪一格。</p><p>根据函数输出结果，机器学习有不同的类别：</p><ol type="1"><li><strong>回归任务Regression</strong>：</li><li><strong>分类任务Classification</strong>：</li><li><strong>结构化学习structured learning</strong>：</li></ol><p>举一个预测 youtube 次日观影次数的栗子。任务是：找到一个函数，输出第二天的观看次数。</p><p>ML 分为3步骤：</p><p><strong>1. 建立 model</strong>：Function with Unknown Parameters</p><p><strong>2. 定义损失函数</strong>：Define Loss from Training Data</p><p><strong>3. 优化参数</strong>：Optimization</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/MLstep.png" style="zoom:80%"/></p><h3 id="建立-model">1. 建立 model</h3><p>先设定一个带有未知参数的函数。具体选择建立什么样的函数需要一定的domain knowledge。在这里我们先建立模型： <span class="math display">\[y = b + w * x_1\]</span></p><ul><li><p><span class="math inline">\(y\)</span>：准备预测的次数</p></li><li><p><span class="math inline">\(x_1\)</span>：是前一天总共观看的次数，是已知的<strong>特征 feature</strong></p></li><li><p><span class="math inline">\(b\)</span> 跟 <span class="math inline">\(w\)</span> 是未知参数，要通过数据找出来。</p><p><span class="math inline">\(b\)</span>：<strong>偏置bias</strong></p><p><span class="math inline">\(w\)</span>：<strong>权重weight</strong></p></li></ul><p>这个带有 Unknown Parameter 的 Function 就叫做 <strong>Model</strong></p><h3 id="定义损失函数">2. 定义损失函数</h3><p>损失函数 <span class="math inline">\(L(b, w)\)</span>，<span class="math inline">\(L\)</span> 越小说明参数越好。</p><p>损失函数的计算过程：对每一个训练样本，计算其模型预测值（输出）与真实值（label）之间的<strong>误差</strong>（e），整个模型的损失函数就是全部训练样本误差的平均值。</p><p>不同的误差计算方式：MAE / MSE / Cross-entropy <span class="math display">\[e = \left| y-\hat{y} \right| \quadMAE\]</span></p><p><span class="math display">\[e = (y-\hat{y})^2\quadMSE\]</span></p><p>Error Surface：误差曲面。绘制出参数和Loss之间的映射关系的等高线图</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/error surface.png" style="zoom:80%"/></p><h3 id="优化参数">3. 优化参数</h3><p>优化参数的目的是将参数优化到使Loss值最小。</p><p>优化方法：梯度下降 gradient descend</p><h4 id="一个参数-w">3.1 一个参数 <span class="math inline">\(w\)</span></h4><p>画出其对应的 error surface</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/w_errorsurface.png" style="zoom:50%"/></p><p>先随便选个 <span class="math inline">\(w\)</span>，然后计算它的梯度。梯度，也就是斜率，当梯度为负时就应增大 <span class="math inline">\(w\)</span>，这样就可以减小 loss</p><blockquote><p>注意图片中的 error surface 是假的，因为如果以 MAE 或 MSE 来计算不会为负。</p><p>loss func 本身可以随便设置。在真实情况下 loss 确实可能非负。</p></blockquote><p>增大 x 的幅度（步长）由<strong>学习率 learning rate</strong> 和<strong>斜率</strong>决定。学习率是一个需要提前自己设定的超参数 hyperparameter（相比超参而言，<span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 这种参数是要通过数据学习的）</p><p>如此迭代多次更新 <span class="math inline">\(w\)</span>（停止条件：迭代次数达到阈值（超参）或微分趋于0）</p><p>梯度下降的问题在于只能找到局部最小值（但其实这是个假问题，将在后面课程中解释）</p><h4 id="两个参数-w-和-b">3.2 两个参数 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span></h4><p>与一个参数的计算过程类似。随机选取初始参数，计算器偏微分，使用梯度下降的方式同时更新两个参数，多次迭代直至停止。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606160045810.png" style="zoom:80%"/></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606160100428.png" style="zoom:80%"/></p><h3 id="测试">测试</h3><p>通过训练阶段得到 <span class="math inline">\(w^∗ = 0.97 , b^∗ = 0.1 k\)</span> ，训练集上的损失函数 $L(w^<em>,b^</em>)=0.48k <span class="math inline">\(，测试集上的损失函数\)</span>L'=0.58k$</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606162931084.png" style="zoom:60%"/></p><p>通过上图真实值和拟合值对比，可以看出数据有<u>明显的周期性</u>，因此修改自变量为前 <span class="math inline">\(j\)</span> 日的流量。</p><p>尝试拟合1日、7日、28日、56日的数据来预测下一日流量。可以发现随着自变量日期增加，在测试集上的结果不再变好。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606163451911.png" style="zoom:60%"/></p><h2 id="线性模型到神经网络">线性模型到神经网络</h2><p>上面的那种模型都是线性模型linear model，但是线性模型太简单，不管怎么调参数都只是一条直线（下图蓝线），无法拟合复杂的真实情况（如下图红线）</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606163853191.png" style="zoom:60%"/></p><p>这种模型本身的限制叫做 model bias（注意跟模型参数的那个bias不一样），它指的意思是说,没有办法模拟真实的状况</p><p>所以我们需要写一个更复杂的,更有弹性的,有未知参数的 Function。</p><p>如下图所示，这条红线可以用很多个这种蓝线来加总拟合。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606164438853.png" style="zoom:60%"/></p><p>事实上，可以使用分段函数去逼近任何的连续的曲线，每一个分段函数的 curve 又可以用一大堆蓝色的 Function 组合起来</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606164946779.png" style="zoom:60%"/></p><p>这种蓝线（hard sigmoid）可以用<strong>sigmoid</strong>来拟合</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606165045533.png" style="zoom:60%"/></p><p>不同的参数（<span class="math inline">\(c\)</span> <span class="math inline">\(b\)</span> <span class="math inline">\(w\)</span>） → 不同的 sigmoid function → 组合逼近出不同的piecewise linear function → 近似得到不同的 continuous function</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606165732730.png" style="zoom:60%"/></p><ul><li>改 <span class="math inline">\(w\)</span> ，就会改变<strong>斜率</strong>，就会改变斜坡的坡度</li><li>改 <span class="math inline">\(b\)</span>，就会把这一个 Sigmoid Function 左右移动</li><li>改 <span class="math inline">\(c\)</span> ，就会改变它的高度</li></ul><div class="note note-info">            <p>为什么需要非线性变化？用于拟合 hard sigmoid 为什么需要不同参数？为了得到不同的 hard sigmoid</p>          </div><p>最后合出来的红线（真实情况）就可以写成这样的公式： <span class="math display">\[y=b+\sum_{i} c_{i} \text { sigmoid }\left(b_{i}+w_{i} x_{1}\right)\]</span> <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606170202531.png" style="zoom:60%"/></p><p>这个公式是针对单独一个特征。我们刚才已经选取了更多特征作为输入。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210606195621970.png" style="zoom:60%"/></p><h3 id="back-to-ml_step1设定model">back to ML_step1：设定model</h3><p>以 <span class="math inline">\(j\)</span> 是 1 2 3 的状况举例，就是<strong>只考虑三个 Feature</strong>。</p><ul><li>所以 <span class="math inline">\(j\)</span> 等于 1 2 3，输入就是 <span class="math inline">\(x_1\)</span> 代表前一天的观看人数，<span class="math inline">\(x_2\)</span> 两天前观看人数，<span class="math inline">\(x_3\)</span> 三天前的观看人数</li><li>每一个 <strong>i 就代表了一个蓝色的 Function</strong>，只是我们现在每一个蓝色的 Function，都用一个 Sigmoid Function 来逼近似它</li></ul><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607091908138.png" style="zoom:60%"/></p><p>将三个式子简化为矩阵形式。得到 <span class="math inline">\(r=b+Wx\)</span></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607092914325.png" style="zoom:60%"/></p><p><span class="math inline">\(σ\)</span> 表示做 sigmoid</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607093111740.png" style="zoom:60%"/></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607093717450.png" style="zoom:60%"/></p><p>将这三个式子连起来</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607094028833.png" style="zoom:60%"/></p><p>就得到了模型最后的式子</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607094453684.png" style="zoom:60%"/></p><p>下面将重新定义一下参数，将未知参数排成一个向量（ <span class="math inline">\(W\)</span> 拿行和拿列是一样的）组成 <span class="math inline">\(\theta\)</span>（就是下文优化部分用的），还有两个b是不一样的。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607095355124.png" style="zoom:60%"/></p><h3 id="back-to-ml_step2定义损失函数">back to ML_step2：定义损失函数</h3><p>有了新的这个 Model 以后，定义 Loss 的方法是一样的，只是符号改了一下，直接<strong>用 θ 来统设所有的参数</strong>，所以现在的 Loss Function 就变成 <span class="math inline">\(L(\theta)\)</span></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607095812607.png" style="zoom:60%"/></p><h3 id="back-to-ml_step3优化参数">back to ML_step3：优化参数</h3><p>现在就是要<strong>找一组 θ,这个 θ 可以让 Loss 越小越好</strong>。</p><p>开始要随机选一个初始的数值 <span class="math inline">\(\theta_0\)</span>，然后对每一个未知的参数,都去计算它对 L 的微分，组成一个向量叫 gradient。算出 g 之后要 <strong>更新参数</strong>，通过迭代梯度下降更新参数。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607100406691.png" style="zoom:60%"/></p><p>在实际运行中，不会一次运行所有数据，而会用<strong>batch</strong>：将整个数据分成很多batch，每次运行一个batch，update一次参数；将所有batch运行完一次，是为一个<strong>epoch</strong>。 batch size是需要设置的超参。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607102236585.png" style="zoom:60%"/></p><h4 id="activation-function从-sigmoid-到-relu">Activation Function：从 Sigmoid 到 ReLU</h4><p>hard sigmoid 可以看作是两个ReLU 加起来，如图所示：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607102356512.png" style="zoom:60%"/></p><p>所以 Sigmoid 也可以换成 ReLU：</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607102434886.png" style="zoom:60%"/></p><p>哪一个更好点？</p><p>实验结果显示 ReLU 的效果会好一些。</p><h4 id="深度神经网络">深度神经网络</h4><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607102524196.png" style="zoom:60%"/></p><p>一个 sigmoid 或 ReLU 就是一个neuron，很多个 neuron 就组成了 neural network 神经网络。 neuron 层叫 layer，输入输出之外的层叫 hidden layer。有很多层就叫 Deep，这个技术就叫做 <strong>Deep Learning</strong>。</p><p>既然很多个 sigmoid 或 ReLU 就能拟合任意函数，那么展开一层极多的神经元不就行了吗，为什么选择把网络变深而不是变胖呢？这一问题留待以后解读。</p><p>在示例实验中，神经网络没有太深的原因是会<strong>过拟合</strong></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210607103014775.png" style="zoom:60%"/></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy 学习</title>
    <link href="/2021/06/04/Numpy%20%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/06/04/Numpy%20%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="numpy">Numpy</h1><p>本文是 Numpy 的简单学习笔记。</p><h2 id="为什么使用-numpy">为什么使用 Numpy ？</h2><p>对于同样的数值计算任务，使用 Numpy 比直接编写 Python 代码实现，<strong>优点</strong>：</p><ol type="1"><li><p><strong>代码更简洁</strong>：Numpy 直接以数组、矩阵为力度计算并且支持大量的数学函数，而 Python 需要用 for 循环从底层实现</p></li><li><p><strong>性能更高效</strong>：Numpy 的数组存储效率和输入输出计算性能，比 Python 使用 List 或者嵌套 List 好很多</p><p>注：</p><ul><li>Numpy 的数据存储和 Python 原生的 List 是不一样的</li><li>Numpy 的大部分代码都是 C 语言实现的，这是 Numpy 比纯 Python 代码高效的原因</li></ul></li></ol><p>举个栗子： 需求：实现两个数组的加法。数组A是1 ~ N数字的平方。数组B是1 ~ N数字的立方</p><ol type="1"><li>使用 Python 元素原生语法实现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">python_sum</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Python实现数组的加法</span><br><span class="hljs-string">    @param n：数组的长度</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    a = [i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    b = [i**<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    c = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        c.append(a[i] + b[i])<br>    <span class="hljs-keyword">return</span> c<br><br><br>python_sum(<span class="hljs-number">10</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">36</span>, <span class="hljs-number">80</span>, <span class="hljs-number">150</span>, <span class="hljs-number">252</span>, <span class="hljs-number">392</span>, <span class="hljs-number">576</span>, <span class="hljs-number">810</span>]<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用 Numpy 实现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numpy_sum</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Numpy实现数组的加法</span><br><span class="hljs-string">    @param n：数组的长度</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    a = np.arange(n) ** <span class="hljs-number">2</span><br>    b = np.arange(n) ** <span class="hljs-number">3</span><br>    <span class="hljs-keyword">return</span> a + b<br><br><br>numpy_sum(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 生成的不是list，是numpy array</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([  <span class="hljs-number">0</span>,   <span class="hljs-number">2</span>,  <span class="hljs-number">12</span>,  <span class="hljs-number">36</span>,  <span class="hljs-number">80</span>, <span class="hljs-number">150</span>, <span class="hljs-number">252</span>, <span class="hljs-number">392</span>, <span class="hljs-number">576</span>, <span class="hljs-number">810</span>], dtype=int32)<br></code></pre></td></tr></table></figure><p>性能对比：执行10000次(明显numpy快)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">%timeit python_sum(<span class="hljs-number">10000</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">10.6</span> ms ± <span class="hljs-number">410</span> µs per loop (mean ± std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">100</span> loops each)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">%timeit numpy_sum(<span class="hljs-number">10000</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">56.2</span> µs ± <span class="hljs-number">2.06</span> µs per loop (mean ± std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">10000</span> loops each)<br></code></pre></td></tr></table></figure><h2 id="numpy-的核心-ndarray-对象">Numpy 的核心 ndarray 对象</h2><p><strong>array对象的背景：</strong></p><ul><li>Numpy 的核心数据结构，就叫做 <strong>array，就是数组，</strong> 也叫 ndarray，array 对象可以是一维数组，也可以是多维数组；</li><li>Python 的 List 也可以实现相同的功能，但是 array 比 List 的优点在于性能好、包含数组元数据信息、大量的快捷函数；</li><li>Numpy 成为事实上的 Scipy、Pandas、Scikit-Learn、Tensorflow、PaddlePaddle 等框架的“通用底层语言”</li><li>Numpy 的 array 和 Python 的 List 的一个区别，是他元素必须都是同一种数据类型，比如都是数字 int 类型，这也是 Numpy 高性能的一个原因</li></ul><p><strong>array本身的属性：</strong></p><ul><li>shape：返回一个元组，表示 array 的维度</li><li>ndim：一个数字，表示 array 的维度的数目</li><li>size：一个数字，表示 array 中所有数据元素的数目</li><li>dtype：array 中元素的数据类型</li></ul><p><strong>创建 array 的方法：</strong></p><ul><li>从 Python 的列表 List 或 tuple 和嵌套列表创建 array</li><li>使用 predefined 函数 <code>arange</code>、<code>ones/ones_like</code>、<code>zeros/zeros_like</code>、<code>empty/empty_like</code>、<code>full/full_like</code>、<code>eye</code> 等函数创建</li><li>生成随机数的 <code>np.random</code> 模块构建</li><li>....</li></ul><p><strong>array 本身支持的大量操作和函数：</strong></p><ul><li>直接逐元素的加减乘除等算数操作</li><li>更好用的面向多维的数组索引</li><li>求 sum/mean 等聚合函数</li><li>线性代数函数，比如求解逆矩阵、求解方程组</li></ul><h3 id="创建-ndarray">1. 创建 ndarray</h3><h4 id="方法1通过-python-的-list-或-tuple-创建-ndarray">方法1：通过 Python 的 list 或 tuple 创建 ndarray</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个一维数组，也就是Python的单元素List</span><br>x = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>])<br><span class="hljs-comment"># 一种典型的错误情况：x = np.array(1,2,3,4)</span><br><br><span class="hljs-comment"># 创建一个二维数组，也就是Python的嵌套List</span><br>X = np.array(<br>    [<br>        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br>        [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>    ]<br>) <br><br><br>b = np.array([(<span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)])<br></code></pre></td></tr></table></figure><h4 id="方法2用占位符创建已知尺寸的数组">方法2：用占位符创建已知尺寸的数组</h4><p>使用 predefined 函数 <code>arange</code>、<code>ones/ones_like</code>、<code>zeros/zeros_like</code>、<code>empty/empty_like</code>、<code>full/full_like</code>、<code>eye</code> 等函数创建。不用扩张数组，因为扩张数组很耗时。默认dtype是float64</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">d = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>e = np.ones( (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), dtype=np.int16 )  <span class="hljs-comment"># 也可以自定义元素类型</span><br>f = np.empty( (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) )  <span class="hljs-comment"># 根据内存状态随机初始化数组, 注意：数据是未初始化的，里面的值可能是随机值 不要用</span><br>g = np.full((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), <span class="hljs-number">333</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-number">333</span>, <span class="hljs-number">333</span>, <span class="hljs-number">333</span>, <span class="hljs-number">333</span>],<br>       [<span class="hljs-number">333</span>, <span class="hljs-number">333</span>, <span class="hljs-number">333</span>, <span class="hljs-number">333</span>]])<br></code></pre></td></tr></table></figure><h4 id="方法3arange-创建数组">方法3：arange 创建数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># arange类似于Python内置的range</span><br>h = np.arange(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 从2开始，到10(不包括10)，步长为2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>])<br><br>i = np.arange( <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.3</span> )  <span class="hljs-comment"># 接受小数参数。由于浮点数精度的原因，可能无法知道数组最后有多少个数</span><br></code></pre></td></tr></table></figure><h4 id="方法4使用-random-模块生成随机数的数组">方法4：使用 random 模块生成随机数的数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">j = np.random.randn(<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([ <span class="hljs-number">0.53559186</span>, -<span class="hljs-number">0.99885635</span>, -<span class="hljs-number">1.54424476</span>])<br><br>k = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[ <span class="hljs-number">0.20762079</span>,  <span class="hljs-number">0.07757193</span>],<br>       [-<span class="hljs-number">1.06316427</span>,  <span class="hljs-number">1.5224711</span> ],<br>       [ <span class="hljs-number">0.88357521</span>,  <span class="hljs-number">0.05296014</span>]])<br><br>l = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># 三块，每块都是2行4列数组</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[[ <span class="hljs-number">1.19593566</span>,  <span class="hljs-number">1.3488425</span> , -<span class="hljs-number">1.170022</span>  , -<span class="hljs-number">0.61150356</span>],<br>        [-<span class="hljs-number">0.75687196</span>, -<span class="hljs-number">1.34909095</span>,  <span class="hljs-number">0.1344865</span> , -<span class="hljs-number">0.74720613</span>]],<br><br>       [[-<span class="hljs-number">0.78072672</span>,  <span class="hljs-number">1.82332708</span>,  <span class="hljs-number">0.64621885</span>, -<span class="hljs-number">0.17998274</span>],<br>        [-<span class="hljs-number">0.61729393</span>, -<span class="hljs-number">1.86046175</span>,  <span class="hljs-number">0.65815736</span>,  <span class="hljs-number">0.52321533</span>]],<br><br>       [[ <span class="hljs-number">0.3204662</span> , -<span class="hljs-number">0.6458647</span> ,  <span class="hljs-number">0.8711224</span> , -<span class="hljs-number">1.51023464</span>],<br>        [ <span class="hljs-number">1.47456684</span>,  <span class="hljs-number">0.04745808</span>,  <span class="hljs-number">0.6639226</span> , -<span class="hljs-number">1.9164821</span> ]]])<br></code></pre></td></tr></table></figure><p>创建 array 的所有方法：<code>array</code>， <code>zeros</code>， <code>zeros_like</code>， <code>ones</code>，<code>ones_like</code>，<code>empty</code>，<code>empty_like</code>，<code>arange</code>，<code>linspace</code>，<code>numpy.random.Generator.rand</code>，<code>numpy.random.Generator.randn</code>，<code>fromfunction</code>，<code>fromfile</code>。</p><h3 id="数组-array-的属性">2. 数组 array 的属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ndarray的重要属性</span><br><br>print(<span class="hljs-string">&quot;ndarray类型为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">type</span>(a)))<br>print(<span class="hljs-string">&quot;ndarray的维度ndim为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a.ndim))<br>print(<span class="hljs-string">&quot;ndarray的shape为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a.shape))<br>print(<span class="hljs-string">&quot;ndarray总的元素数size为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a.size))  <span class="hljs-comment">#a.shape元素乘积</span><br>print(<span class="hljs-string">&quot;ndarray元素类型dtype为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a.dtype))  <span class="hljs-comment">#这句是我加的</span><br>print(<span class="hljs-string">&quot;ndarray元素类型dtype.name为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a.dtype.name))  <span class="hljs-comment">#官方代码不知道为什么多出了这个name</span><br>print(<span class="hljs-string">&quot;ndarray每个元素占据的字节数itemsize为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a.itemsize))<br>print(<span class="hljs-string">&quot;ndarray元素的buffer data为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a.data))<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>ndarray类型为&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">numpy</span>.<span class="hljs-title">ndarray</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">ndarray</span>的维度<span class="hljs-title">ndim</span>为2</span><br><span class="hljs-class"><span class="hljs-title">ndarray</span>的<span class="hljs-title">shape</span>为(<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">5</span></span>)</span><br><span class="hljs-class"><span class="hljs-title">ndarray</span>总的元素数<span class="hljs-title">size</span>为15</span><br><span class="hljs-class"><span class="hljs-title">ndarray</span>元素类型<span class="hljs-title">dtype</span>为<span class="hljs-title">int32</span></span><br><span class="hljs-class"><span class="hljs-title">ndarray</span>元素类型<span class="hljs-title">dtype</span>.<span class="hljs-title">name</span>为<span class="hljs-title">int32</span></span><br><span class="hljs-class"><span class="hljs-title">ndarray</span>每个元素占据的字节数<span class="hljs-title">itemsize</span>为4</span><br><span class="hljs-class"><span class="hljs-title">ndarray</span>元素的<span class="hljs-title">buffer</span> <span class="hljs-title">data</span>为&lt;<span class="hljs-title">memory</span> <span class="hljs-title">at</span> 0<span class="hljs-title">x000002CFFE04BE48</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="基础数学运算">3. 基础数学运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array( [<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>] )<br>b = np.arange( <span class="hljs-number">4</span> )<br>print(<span class="hljs-string">&quot;a-b是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a-b))<br>print(<span class="hljs-string">&quot;a**2是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a**<span class="hljs-number">2</span>))<br>print(<span class="hljs-string">&quot;10*np.sin(a)是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">10</span>*np.sin(a)))<br>print(<span class="hljs-string">&quot;a&lt;35是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a&lt;<span class="hljs-number">35</span>))<br>print(<span class="hljs-string">&quot;a*b是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a*b))<br><br><span class="hljs-comment"># 矩阵乘法</span><br>A = np.array( [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]] )<br>B = np.array( [[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]] )<br>print(<span class="hljs-string">&quot;A*B是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(A*B))  <span class="hljs-comment"># 乘积运算符 * 在 NumPy 数组中按元素进行运算</span><br>print(<span class="hljs-string">&quot;A@B是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(A@B))  <span class="hljs-comment"># 矩阵乘积</span><br>print(<span class="hljs-string">&quot;A.dot(B)是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(A.dot(B)))  <span class="hljs-comment"># 矩阵乘积</span><br><br><span class="hljs-comment"># +=，*= 等运算符进行原地运算，即修改现有数组而不是创建新数组（需要加同类型的，如果不能强制转换就会报错）</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a-b是[<span class="hljs-number">20</span> <span class="hljs-number">29</span> <span class="hljs-number">38</span> <span class="hljs-number">47</span>]<br>a**<span class="hljs-number">2</span>是[ <span class="hljs-number">400</span> <span class="hljs-number">900</span> <span class="hljs-number">1600</span> <span class="hljs-number">2500</span>]<br>10np.sin(a)是[ <span class="hljs-number">9.12945251</span> -<span class="hljs-number">9.88031624</span> <span class="hljs-number">7.4511316</span> -<span class="hljs-number">2.62374854</span>]<br>a&lt;<span class="hljs-number">35</span>是[ <span class="hljs-literal">True</span> <span class="hljs-literal">True</span> <span class="hljs-literal">False</span> <span class="hljs-literal">False</span>]<br>ab是[ <span class="hljs-number">0</span> <span class="hljs-number">30</span> <span class="hljs-number">80</span> <span class="hljs-number">150</span>]<br><br>A*B是[[<span class="hljs-number">2</span> <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span> <span class="hljs-number">4</span>]]<br><br>A@B是[[<span class="hljs-number">5</span> <span class="hljs-number">4</span>]<br>[<span class="hljs-number">3</span> <span class="hljs-number">4</span>]]<br><br>A.dot(B)是[[<span class="hljs-number">5</span> <span class="hljs-number">4</span>]<br>[<span class="hljs-number">3</span> <span class="hljs-number">4</span>]]<br></code></pre></td></tr></table></figure><h2 id="numpy-对数组按索引查询">Numpy 对数组按索引查询</h2><p>三种索引方法：</p><ul><li>基础索引</li><li>神奇索引</li><li>布尔索引</li></ul><h3 id="基础索引">基础索引</h3><h4 id="一维数组">一维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 和 Python 的 list 一样，包括前面，不包括后面</span><br><span class="hljs-comment"># 一维向量</span><br>x = np.arange(<span class="hljs-number">10</span>)  <span class="hljs-comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br>print(x[<span class="hljs-number">2</span>], x[<span class="hljs-number">5</span>], x[-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 2 5 9</span><br>x[<span class="hljs-number">2</span>: <span class="hljs-number">4</span>]  <span class="hljs-comment"># array([2, 3])</span><br>x[-<span class="hljs-number">3</span>: ]  <span class="hljs-comment"># array([7, 8, 9])</span><br>x[: -<span class="hljs-number">3</span>]  <span class="hljs-comment"># array([0, 1, 2, 3, 4, 5, 6])</span><br></code></pre></td></tr></table></figure><h4 id="二维数组">二维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二维向量，一般用大写字母</span><br>X = np.arange(<span class="hljs-number">20</span>).reshape(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],<br>       [ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],<br>       [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],<br>       [<span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>]])<br><br>X[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]  <span class="hljs-comment"># 17</span><br><br><span class="hljs-comment"># 可以忽略后续索引值，返回的数是降低一个维度的数组</span><br><span class="hljs-comment"># 这里的2，其实是要筛选第3行</span><br>X[<span class="hljs-number">2</span>]  <span class="hljs-comment"># array([10, 11, 12, 13, 14])</span><br><span class="hljs-comment"># 筛选多行</span><br>X[: -<span class="hljs-number">1</span>]  <span class="hljs-comment"># array([[ 0,  1,  2,  3,  4],</span><br>         <span class="hljs-comment">#       [ 5,  6,  7,  8,  9],</span><br>         <span class="hljs-comment">#       [10, 11, 12, 13, 14]])</span><br>        <br><span class="hljs-comment"># 筛选所有行，然后筛选多列</span><br>X[ : , <span class="hljs-number">2</span>]  <span class="hljs-comment"># array([ 2,  7, 12, 17])</span><br><br><span class="hljs-comment"># me:筛选，比如第2行第3列</span><br>X[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]  <span class="hljs-comment"># array([7])</span><br></code></pre></td></tr></table></figure><p><strong>注意：切片的修改会修改原来的数组</strong></p><p>原因：Numpy 经常要处理大数组，避免每次都复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x[<span class="hljs-number">2</span>: <span class="hljs-number">4</span>] = <span class="hljs-number">666</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([  <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">666</span>, <span class="hljs-number">666</span>,   <span class="hljs-number">4</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">6</span>,   <span class="hljs-number">7</span>,   <span class="hljs-number">8</span>,   <span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure><h3 id="神奇索引">神奇索引</h3><p>其实就是：用整数数组进行的索引，叫神奇索引</p><h4 id="一维数组-1">一维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">10</span>)<br>x[[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]]  <span class="hljs-comment"># array([3, 4, 7])</span><br><br>indexs = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]])  <span class="hljs-comment"># 相当于换了一种索引方式</span><br>x[indexs]  <span class="hljs-comment"># array([[0, 2],</span><br>           <span class="hljs-comment">#        [1, 3]])</span><br></code></pre></td></tr></table></figure><p>栗子：获取数组中最大的前N个数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机生成1到100之间的，10个数</span><br>arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># array([ 6, 97, 1, 80, 73, 31, 16, 26, 46, 22])</span><br><br><span class="hljs-comment"># arr.argsort()会返回排序后的索引index</span><br><span class="hljs-comment"># 取最大值对应的3个下标</span><br>arr.argsort()[-<span class="hljs-number">3</span>:]  <span class="hljs-comment"># array([4, 3, 1], dtype=int64)</span><br><br>arr[arr.argsort()[-<span class="hljs-number">3</span>:]]  <span class="hljs-comment"># array([73, 80, 97])</span><br><br></code></pre></td></tr></table></figure><h4 id="二维数组-1">二维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">X = np.arange(<span class="hljs-number">20</span>).reshape(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment"># 筛选多行，列可以省略</span><br>X[[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]  <span class="hljs-comment"># 相当于 X[[0,2], :]</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],<br>           [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]])<br><br><span class="hljs-comment"># 同时执行行列-列表</span><br><span class="hljs-comment"># 返回的是[(0, 1), (2, 3), (3, 4)]位置的数字</span><br>X[[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([ <span class="hljs-number">1</span>, <span class="hljs-number">13</span>, <span class="hljs-number">19</span>])<br></code></pre></td></tr></table></figure><h3 id="布尔索引">布尔索引</h3><p>注意：布尔索引选择的数据是数组的拷贝</p><h4 id="一维数组-2">一维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">10</span>)<br>x &gt; <span class="hljs-number">5</span>  <span class="hljs-comment"># array([False, False, False, False, False, False,  True,  True,  True, True])</span><br>x[x &gt; <span class="hljs-number">5</span>]  <span class="hljs-comment"># array([6, 7, 8, 9])</span><br></code></pre></td></tr></table></figure><h4 id="二维数组-2">二维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">X = np.arange(<span class="hljs-number">20</span>).reshape(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>X &gt; <span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],<br>           [<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>],<br>           [ <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>],<br>           [ <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>,  <span class="hljs-literal">True</span>]])<br><br><span class="hljs-comment"># X &gt; 5的boolean数组，既有行，又有列</span><br><span class="hljs-comment"># 因此返回的是以（行，列）为结果</span><br>X[X &gt; <span class="hljs-number">5</span>]  <br><span class="hljs-meta">&gt;&gt;&gt; </span>array([ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>])<br></code></pre></td></tr></table></figure><p>栗子：筛选第三列大于5的行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">X[:, <span class="hljs-number">2</span>]  <span class="hljs-comment"># array([2, 7, 12, 17])</span><br>X[:, <span class="hljs-number">2</span>] &gt; <span class="hljs-number">5</span>  <span class="hljs-comment"># array([False, True, True, True])</span><br><br>X[X[:, <span class="hljs-number">2</span>] &gt; <span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],<br>           [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],<br>           [<span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>]])<br></code></pre></td></tr></table></figure><h3 id="条件的组合">条件的组合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注意，每个条件都得加小括号</span><br>condition = (x%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) | (x &gt; <span class="hljs-number">7</span>)<br>condition <br><span class="hljs-meta">&gt;&gt;&gt; </span>array([ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>])<br><br>x[condition]<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure><h2 id="常用-random-随机函数汇总">常用 random 随机函数汇总</h2><p><a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.random.html">官方文档地址</a></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/image-20210603112451290.png" /></p><h3 id="randd0-d1-...-dn">1. rand(d0, d1, ..., dn)</h3><p>返回数据在[0, 1)之间，具有均匀分布</p><p>note：括号里就是数组的 shape 吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.rand(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([<span class="hljs-number">0.6999419</span> , <span class="hljs-number">0.46259045</span>, <span class="hljs-number">0.76988761</span>, <span class="hljs-number">0.70682691</span>, <span class="hljs-number">0.07794833</span>])<br><br>np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-number">0.46748888</span>, <span class="hljs-number">0.39767725</span>, <span class="hljs-number">0.53824109</span>, <span class="hljs-number">0.32306072</span>],<br>          [<span class="hljs-number">0.32192706</span>, <span class="hljs-number">0.58147814</span>, <span class="hljs-number">0.51342599</span>, <span class="hljs-number">0.51541956</span>],<br>          [<span class="hljs-number">0.87084285</span>, <span class="hljs-number">0.32134477</span>, <span class="hljs-number">0.05494504</span>, <span class="hljs-number">0.97090779</span>]])<br></code></pre></td></tr></table></figure><h3 id="randnd0-d1-...-dn">2. randn(d0, d1, ..., dn)</h3><p>返回数据具有标准正态分布（均值0， 方差1）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.rand(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([-<span class="hljs-number">0.1719413</span> , -<span class="hljs-number">0.40536603</span>, -<span class="hljs-number">1.08071032</span>, -<span class="hljs-number">0.07730974</span>, -<span class="hljs-number">0.90159565</span>])<br><br>np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[ <span class="hljs-number">1.43158401</span>,  <span class="hljs-number">1.2062071</span> ,  <span class="hljs-number">0.3741147</span> , -<span class="hljs-number">0.82679866</span>],<br>          [ <span class="hljs-number">0.56348707</span>, -<span class="hljs-number">2.39543479</span>,  <span class="hljs-number">1.0254253</span> ,  <span class="hljs-number">1.35024282</span>],<br>           [-<span class="hljs-number">1.5868889</span> , -<span class="hljs-number">0.44797611</span>,  <span class="hljs-number">1.53968612</span>,  <span class="hljs-number">0.85347238</span>]])<br></code></pre></td></tr></table></figure><h3 id="randintlow-high-size-dtype">3. randint(low[, high, size, dtype])</h3><p>生成随机整数，包含low，不包含high。如果high不指定，则从[0, low)中生成数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.randint(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 0, 1, 2中随机抽一个</span><br>np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># 1~9 随机抽一个</span><br>np.random.randint(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, size=(<span class="hljs-number">5</span>,))  <span class="hljs-comment"># array([28, 10, 12, 29, 19])</span><br>np.random.randint(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, size=(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[[<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">27</span>, <span class="hljs-number">11</span>],<br>            [<span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">21</span>, <span class="hljs-number">29</span>],<br>            [<span class="hljs-number">29</span>, <span class="hljs-number">26</span>, <span class="hljs-number">24</span>, <span class="hljs-number">27</span>]],<br><br>           [[<span class="hljs-number">14</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">16</span>],<br>            [<span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">23</span>, <span class="hljs-number">10</span>],<br>            [<span class="hljs-number">20</span>, <span class="hljs-number">27</span>, <span class="hljs-number">19</span>, <span class="hljs-number">22</span>]]])<br></code></pre></td></tr></table></figure><h3 id="randomsize">4. random([size])</h3><p>生成 [0.0, 1.0) 的随机数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.random(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([<span class="hljs-number">0.87659215</span>, <span class="hljs-number">0.48806388</span>, <span class="hljs-number">0.31897873</span>, <span class="hljs-number">0.28465993</span>, <span class="hljs-number">0.4402444</span> ])<br><br>np.random.random(size=(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-number">0.95544107</span>, <span class="hljs-number">0.10927452</span>, <span class="hljs-number">0.33025455</span>, <span class="hljs-number">0.43884905</span>],<br>          [<span class="hljs-number">0.51232723</span>, <span class="hljs-number">0.96086108</span>, <span class="hljs-number">0.85268131</span>, <span class="hljs-number">0.80582844</span>],<br>           [<span class="hljs-number">0.36631864</span>, <span class="hljs-number">0.05322777</span>, <span class="hljs-number">0.27671375</span>, <span class="hljs-number">0.06613997</span>]])<br></code></pre></td></tr></table></figure><h3 id="choicea-size-replace-p">5. choice(a[, size, replace, p])</h3><p>a是一维数组，从它里面生成随机结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这时候，a是数字，则从range(5)中生成，size为3</span><br>np.random.choice(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># array([2, 1, 4])</span><br>np.random.choice(<span class="hljs-number">5</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># array([[4, 1, 2], [2, 4, 0]])</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这时候，a是数组，从里面随机取出数字</span><br>np.random.choice([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-number">3</span>)  <span class="hljs-comment"># array([2, 3, 4])</span><br>np.random.choice([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># array([[4, 3, 4], [5, 6, 4]])</span><br></code></pre></td></tr></table></figure><h3 id="shufflex">6. shuffle(x)</h3><p>把一个数组x进行随机排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">10</span>)<br>np.random.shuffle(a)  <span class="hljs-comment"># array([2, 0, 3, 6, 1, 4, 5, 8, 9, 7])</span><br></code></pre></td></tr></table></figure><p><strong>注：如果数组是多维的，则只会在第一维度打散数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">20</span>).reshape(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>np.random.shuffle(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],<br>          [ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],<br>           [ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],<br>           [<span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>]])<br></code></pre></td></tr></table></figure><h3 id="permutationx">7. permutation(x)</h3><p>把一个数组x进行随机排列，或者数字的全排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这时，生成range(10)的随机排列</span><br>np.random.permutation(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 其实相当于</span><br>a = np.arange(<span class="hljs-number">10</span>)<br>np.random.shuffle(a)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">9</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><span class="hljs-comment"># 这时，在第一维度进行打散</span><br>np.random.permutation(arr)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],<br>           [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>           [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])<br></code></pre></td></tr></table></figure><p><strong>注：这里不会更改原来的arr，会返回一个新的copy</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>           [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>           [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br></code></pre></td></tr></table></figure><h3 id="normalloc-scale-size">8. normal([loc, scale, size])</h3><p>按照平均值loc和方差scale生成高斯分布的数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.normal(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([  <span class="hljs-number">3.96767152</span>,  <span class="hljs-number">11.20604462</span>, -<span class="hljs-number">10.66355692</span>,   <span class="hljs-number">3.28964678</span>,<br>         <span class="hljs-number">2.5968747</span> ,   <span class="hljs-number">3.09770873</span>,   <span class="hljs-number">2.40696033</span>,  -<span class="hljs-number">2.93361133</span>,<br>        <span class="hljs-number">16.12715299</span>,  -<span class="hljs-number">5.51975866</span>])<br><br>np.random.normal(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[  <span class="hljs-number">0.59465584</span>, -<span class="hljs-number">12.56034849</span>, -<span class="hljs-number">17.21235221</span>,   <span class="hljs-number">5.86058884</span>],<br>          [  <span class="hljs-number">8.95106662</span>,  -<span class="hljs-number">4.17923506</span>, -<span class="hljs-number">11.10878236</span>,  -<span class="hljs-number">6.65145514</span>],<br>           [  <span class="hljs-number">0.17354117</span>, -<span class="hljs-number">13.12031261</span>,  -<span class="hljs-number">9.3815636</span> ,  <span class="hljs-number">12.08462607</span>]])<br></code></pre></td></tr></table></figure><h3 id="uniformlow-high-size">9. uniform([low, high, size])</h3><p>在[low, high)之间生成均匀分布的数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([<span class="hljs-number">8.94300171</span>, <span class="hljs-number">5.94501361</span>, <span class="hljs-number">9.16434763</span>, <span class="hljs-number">3.45496344</span>, <span class="hljs-number">1.74573521</span>,<br>       <span class="hljs-number">2.15601979</span>, <span class="hljs-number">2.85097589</span>, <span class="hljs-number">9.02594814</span>, <span class="hljs-number">9.38130143</span>, <span class="hljs-number">7.95087103</span>])<br><br>np.random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-number">1.87292668</span>, <span class="hljs-number">2.16985327</span>, <span class="hljs-number">5.02085781</span>, <span class="hljs-number">1.72454695</span>],<br>           [<span class="hljs-number">8.87026442</span>, <span class="hljs-number">8.82115077</span>, <span class="hljs-number">6.47268473</span>, <span class="hljs-number">6.11754421</span>],<br>           [<span class="hljs-number">4.23536288</span>, <span class="hljs-number">8.02647045</span>, <span class="hljs-number">9.87668833</span>, <span class="hljs-number">4.10706247</span>]])<br></code></pre></td></tr></table></figure><p>栗子：对数组加入随机噪声</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 绘制sin曲线</span><br>x = np.linspace(-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># -10到10平均生成100个点(点加的)</span><br>y = np.sin(x)<br>plt.plot(x, y)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/image-20210603115427686.png" alt="image-20210603115427686" /><figcaption>image-20210603115427686</figcaption></figure><p>加入噪声</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.linspace(-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br>y = np.sin(x) + np.random.rand(<span class="hljs-built_in">len</span>(x))  <span class="hljs-comment"># 生成随机数的维度和x的维度相同</span><br>plt.plot(x, y)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210603115521197.png" alt="image-20210603115521197" /><figcaption>image-20210603115521197</figcaption></figure><h2 id="numpy-的数字统计函数">Numpy 的数字统计函数</h2><h3 id="常用的数学统计函数">1. 常用的数学统计函数</h3><table><thead><tr class="header"><th>函数名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>np.sum</td><td>所有元素的和</td></tr><tr class="even"><td>np.prod</td><td>所有元素的乘积</td></tr><tr class="odd"><td>np.cumsum</td><td>元素的累积加和 cumulative sum</td></tr><tr class="even"><td>np.cumprod</td><td>所有元素的累积乘积</td></tr><tr class="odd"><td>np.min</td><td>最小值</td></tr><tr class="even"><td>np.max</td><td>最大值</td></tr><tr class="odd"><td>np.percentile</td><td>0-100百分位数</td></tr><tr class="even"><td>np.quantile</td><td>0-1分位数</td></tr><tr class="odd"><td>np.median</td><td>中位数</td></tr><tr class="even"><td>np.average</td><td>加权平均，参数可以指定weights</td></tr><tr class="odd"><td>np.mean</td><td>平均值</td></tr><tr class="even"><td>np.std</td><td>标准差</td></tr><tr class="odd"><td>np.var</td><td>方差</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment"># 没有指定轴，numpy会把数组当成一维数组</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],<br>       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],<br>       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<br><br>np.<span class="hljs-built_in">sum</span>(arr)  <span class="hljs-comment"># 66</span><br>np.prod(arr)  <span class="hljs-comment"># 0</span><br>np.cumsum(arr)  <span class="hljs-comment"># 累加  array([ 0,  1,  3,  6, 10, 15, 21, 28, 36, 45, 55, 66], dtype=int32)</span><br>np.cumprod(arr) <span class="hljs-comment"># 累积  array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=int32)</span><br>print(np.<span class="hljs-built_in">min</span>(arr), np.<span class="hljs-built_in">max</span>(arr))  <span class="hljs-comment"># 0 11</span><br><br>np.percentile(arr, [<span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">75</span>]) <span class="hljs-comment"># 等同于下面</span><br>np.quantile(arr, [<span class="hljs-number">0.25</span>, <span class="hljs-number">0.50</span>, <span class="hljs-number">0.75</span>]) <span class="hljs-comment"># 有小数是因为偶数个的话没有中间数，会把两个数加和平均</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([<span class="hljs-number">2.75</span>, <span class="hljs-number">5.5</span> , <span class="hljs-number">8.25</span>])<br><br>print(np.median(arr), np.mean(arr))  <span class="hljs-comment"># 5.5 5.5</span><br>print(np.std(arr), np.var(arr))  <span class="hljs-comment"># 3.452052529534663 11.916666666666666</span><br><br><span class="hljs-comment"># 加权平均</span><br><span class="hljs-comment"># weights的shape需要和arr一样</span><br>weights = np.random.rand(*arr.shape)  <br>np.average(arr, weights=weights)  <span class="hljs-comment"># 5.225244488519801</span><br></code></pre></td></tr></table></figure><h3 id="numpy-的-axis-参数的用途">2. Numpy 的 axis 参数的用途</h3><p><strong>axis=0 代表行，axis=1 代表列</strong></p><p>对于 sum/mean/media 等<strong>聚合函数</strong>：</p><ul><li>理解：<strong>axis=0 代表把行消解掉，axis=1 代表把列消解掉</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br>arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>)  <span class="hljs-comment"># array([12, 15, 18, 21])</span><br>arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>)  <span class="hljs-comment"># array([ 6, 22, 38])</span><br><br>arr.cumsum(axis=<span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],<br>          [ <span class="hljs-number">4</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">10</span>],<br>           [<span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>]], dtype=int32)<br>arr.cumsum(axis=<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>],<br>           [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">22</span>],<br>           [ <span class="hljs-number">8</span>, <span class="hljs-number">17</span>, <span class="hljs-number">27</span>, <span class="hljs-number">38</span>]], dtype=int32)<br></code></pre></td></tr></table></figure><p>栗子：将机器学习数据进行标准化</p><p>arr 如果对应到现实世界的一种解释：</p><ul><li>行：每一行对应一个样本数据</li><li>列：每一列代表样本的一个特征</li></ul><p>数据标准化：</p><ul><li>对于机器学习、神经网络来说，不同列的量纲应该相同，训练收敛的更快；</li><li>比如商品的价格是0到100元、销量是1万到10万个，这俩数字没有可比性，因此需要先都做标准化；</li><li>标准化一般使用 <span class="math inline">\(A = \frac{A - mean(A, axis=0)}{std(A, axis=0)}\)</span> 公式进行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, size=(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-comment"># 计算每列的均值</span><br>mean = np.mean(arr, axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 计算每列的标准差</span><br>std = np.std(arr, axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 计算分子，注意每行都会分别减去对应列的均值，这叫做numpy的广播</span><br>fenzi = arr - mean<br><br>result = fenzi / std<br></code></pre></td></tr></table></figure><h2 id="numpy-计算数组中满足条件的元素个数">Numpy 计算数组中满足条件的元素个数</h2><p>需求：有一个非常大的数组比如1亿数字，求出里面数字小于5000的数字数目</p><p>注：该栗子验证了numpy的计算速度比py快</p><p>使用 numpy 的 random 模块生成1亿个数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>, size=<span class="hljs-built_in">int</span>(<span class="hljs-number">1e8</span>))<br>arr.size  <span class="hljs-comment"># 100000000</span><br></code></pre></td></tr></table></figure><ol type="1"><li>使用 python 原生语法实现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">py_arr = <span class="hljs-built_in">list</span>(arr)<br><span class="hljs-comment"># 记一下时间</span><br>%timeit <span class="hljs-built_in">len</span>([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> py_arr <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5000</span>])<br>&gt;&gt; <span class="hljs-number">23.6</span> s ± <span class="hljs-number">4.62</span> s per loop (mean ± std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">1</span> loop each)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用 numpy 的向量化操作实现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 记一下时间</span><br>%timeit arr[arr &gt; <span class="hljs-number">5000</span>].size<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">844</span> ms ± <span class="hljs-number">49.1</span> ms per loop (mean ± std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">1</span> loop each)<br></code></pre></td></tr></table></figure><p>对比时间</p><p>23.6 * 1000 / 844 = 27.96，快了近28倍左右</p><h2 id="numpy-给数组增加维度">Numpy 给数组增加维度</h2><p><strong>背景：</strong> 很多数据计算都是二维或三维的，对于一维的数据输入为了形状匹配，经常需要升维变成二维</p><p><strong>需要：</strong> 在不改变数据的情况下，添加数组为度：（注意观察这个栗子，维度变了，但是<strong>数据没变</strong>） 原始数组：一维数组 arr=[1, 2, 3, 4]，其shape是 (4,)，取值分别为 arr[0]，arr[1]，arr[2]，arr[3] 变形数组：二维数组 arr=[[1, 2, 3, 4]]，其shape是 (1, 4)，取值分别为 arr[0, 0]，arr[0, 1]，arr[0, 2]，arr[0, 3]</p><p><strong>实操：</strong> 经常需要在纸上手绘数组的形状，来查看不同数组是否形状匹配，是否需要升降维</p><p><strong>3种方法：</strong></p><ul><li><code>np.newaxis</code>：关键字，使用索引的语法给数组添加维度</li><li><code>np.expand_dims(arr, axis)</code>：方法，和<code>np.newaxis</code>实现一样的功能，给arr在axis为位置添加维度</li><li><code>np.reshape(a, newshape)</code>：方法，给一个维度设置为1完成升维</li></ul><h3 id="np.newaxis-关键字">1. np.newaxis 关键字</h3><p><strong>注意：<code>np.newaxis</code>其实就是None的别名</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.newaxis <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># True</span><br>np.newaxis == <span class="hljs-literal">None</span>  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>即以下所有的<code>np.newaxis</code>的位置，都可以用None替代</p><h4 id="给一维向量添加一个行维度">给一维向量添加一个行维度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr[np.newaxis, :]  <span class="hljs-comment"># array([[0, 1, 2, 3, 4]])</span><br>arr[np.newaxis, :].shape  <span class="hljs-comment"># (1, 5)</span><br></code></pre></td></tr></table></figure><p>数据现在是一行*五列，数据本身没有增减，只是多了一级括号</p><h4 id="给一维向量添加一个列维度">给一维向量添加一个列维度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr[:, np.newaxis]<br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-number">0</span>],<br>           [<span class="hljs-number">1</span>],<br>           [<span class="hljs-number">2</span>],<br>           [<span class="hljs-number">3</span>],<br>           [<span class="hljs-number">4</span>]])<br>arr[:, np.newaxis].shape  <span class="hljs-comment"># (5, 1)</span><br></code></pre></td></tr></table></figure><p>数据现在是五行*一列</p><h3 id="np.expand_dims-方法">2. np.expand_dims 方法</h3><p><code>np.expand_dims</code>方法实现的效果，和 <code>np.newaxis</code> 关键字是一模一样的</p><h4 id="给一维向量添加一个行维度-1">给一维向量添加一个行维度</h4><p>相当于 <code>arr[np.newaxis, :]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.expand_dims(arr, axis=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 0代表行 array([[0, 1, 2, 3, 4]])</span><br>np.expand_dims(arr, axis=<span class="hljs-number">0</span>).shape  <span class="hljs-comment"># (1, 5)</span><br></code></pre></td></tr></table></figure><h4 id="给一维向量添加一个列维度-1">给一维向量添加一个列维度</h4><p>相当于 <code>arr[:, np.newaxis]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.expand_dims(arr, axis=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 1代表列 array([[0], [1], [2], [3], [4]]) </span><br>np.expand_dims(arr, axis=<span class="hljs-number">1</span>).shape  <span class="hljs-comment"># (5, 1)</span><br></code></pre></td></tr></table></figure><h3 id="np.reshape-方法">3. np.reshape 方法</h3><h4 id="给一维向量添加一个行维度-2">给一维向量添加一个行维度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.reshape(arr, (<span class="hljs-number">1</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># array([[0, 1, 2, 3, 4]])</span><br>np.reshape(arr, (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>))  <span class="hljs-comment"># array([[0, 1, 2, 3, 4]])</span><br></code></pre></td></tr></table></figure><h4 id="给一维向量添加一个列维度-2">给一维向量添加一个列维度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.reshape(arr, (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># array([[0], [1], [2], [3], [4]])</span><br>np.reshape(arr, (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)).shape  <span class="hljs-comment"># (5, 1)</span><br></code></pre></td></tr></table></figure><h2 id="numpy-数组合并">Numpy 数组合并</h2><p>背景：在给及学习准备数据的过程中，需要经常进行不同来源的数据合并的操作 两类场景：</p><ol type="1"><li>给已有的数据添加多行，比如添加一些样本数据进去；</li><li>给已有的数据添加多列，比如添加一些样本特征进去；</li></ol><p>以下操作均可以实现数组合并：</p><ul><li><code>np.concatenate(array_list, axis=0/1)</code>：沿着指定axis进行数组的合并</li><li><code>np.vstack</code> 或者 <code>np.row_stack(array_list)</code>：垂直地vertically、按行row wise进行数据合并</li><li><code>np.hstack</code> 或者 <code>np.column_stack(array_list)</code>：水平地horizontally、按列column wise进行数据合并</li></ul><h3 id="给数据添加新的多行">1. 给数据添加新的多行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>b = np.random.randint(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, size=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>a: [[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br> [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]]<br>b: [[<span class="hljs-number">15</span> <span class="hljs-number">19</span> <span class="hljs-number">19</span>]<br> [<span class="hljs-number">13</span> <span class="hljs-number">10</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">19</span> <span class="hljs-number">13</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">16</span> <span class="hljs-number">15</span> <span class="hljs-number">14</span>]]<br><br><span class="hljs-comment"># 方法1：</span><br>np.concatenate([a, b])<br><span class="hljs-comment"># 方法2(垂直地按行合并)</span><br>np.vstack([a, b])<br><span class="hljs-comment"># 方法3</span><br>np.row_stack([a, b])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],<br>           [ <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],<br>           [<span class="hljs-number">15</span>, <span class="hljs-number">19</span>, <span class="hljs-number">19</span>],<br>           [<span class="hljs-number">13</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>],<br>           [<span class="hljs-number">19</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>],<br>           [<span class="hljs-number">16</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>]])<br></code></pre></td></tr></table></figure><h3 id="给数据添加新的多列">2. 给数据添加新的多列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>b = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, size=(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><br>np.concatenate([a, b], axis=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 水平地 按列合并</span><br>np.hstack([a, b])<br>np.column_stack([a, b])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>],<br>          [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>],<br>           [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLAlchemy入门</title>
    <link href="/2021/04/06/SQLAlchemy%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/06/SQLAlchemy%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="sqlalchemy">SQLAlchemy</h1><h2 id="自定义orm框架">1. 自定义ORM框架</h2><ol type="a"><li><p><strong>Object-Relational Mapping：对象-关系映射</strong>。把数据转换成Python对象。进而实现数据库的操作对象化，减少或完全不用编写SQL原生语句。</p></li><li><p>数据库中的表 –&gt; Python的类。</p></li><li><p>表里面的<strong>列</strong> -&gt; 类的<strong>属性</strong>。row.username,row.userid</p></li><li><p>表里面的行 à 类的实例，字典对象表述</p></li><li><p>字典对象的Key对应列，Value对应值。</p></li><li><p>对增删改查进行封装。</p></li></ol><p>==到时候把mooc再看一遍，重新写笔记==</p><h2 id="查询select操作">查询select操作</h2><p><code>.first()</code> ：直接返回一行数据对象</p><p><code>.all()</code> ：直接返回包含多条数据对象的列表</p><p><code>.filter_by(x=y, a=b)</code> ：只适用于<strong>等值查询</strong>(等于的情况)，其参数为<strong>字典参数</strong>的传值方式</p><p><code>.filter</code> ：适用于复杂<strong>查询条件</strong>的对比，其参数为条件运算</p><p>查询过程中，可以使用 <code>db.session.query</code> 的方式进行查询（支持多表），也可以使用 <code>Model.query</code> 的方式进行查询（不支持多表），所以优先使用 <code>db.session</code>。</p><p>关于数据库的查询的基本知识，可以看《数据库的基本查询》这篇文章复习一下。</p><h3 id="基础查询">基础查询</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># select * from users</span><br>res = db.session.query(Users).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-comment"># select userid, username from users</span><br>res = db.session.query(Users.userid, Users.username).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-comment"># select * from users where userid = 1 and qq = &#x27;12345&#x27;</span><br>res = db.session.query(Users).filter_by(userid=<span class="hljs-number">1</span>, qq=<span class="hljs-string">&#x27;12345&#x27;</span>).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-comment"># &quot;,&quot;表示and //// &quot;or_()&quot;&quot; 表示or</span><br><span class="hljs-comment"># select * from users where userid &gt; 7 or nickname = &#x27;小张&#x27;</span><br>res = db.session.query(Users).<span class="hljs-built_in">filter</span>(or_(Users.userid&gt;<span class="hljs-number">7</span>, Users.nickname==<span class="hljs-string">&#x27;小张&#x27;</span>)).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-comment"># select * from users limit 3 =&gt; (0, 3)从0开始的三个</span><br>res = db.session.query(Users).limit(<span class="hljs-number">3</span>).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-comment"># select * from users limit (3,5) 从3开始的五个</span><br>res = db.session.query(Users).limit(<span class="hljs-number">5</span>).offset(<span class="hljs-number">3</span>).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-comment"># select count(*) from users where...</span><br>count = db.session.query(Users).<span class="hljs-built_in">filter</span>(Users.userid &gt; <span class="hljs-number">3</span>).count()<br><br><span class="hljs-comment"># select distinct(qq) from users</span><br>res = db.session.query(Users.qq).distinct(Users.qq).<span class="hljs-built_in">all</span>()<br>print(res)<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> result:<br>    print(row.qq)<br><br><span class="hljs-comment"># select * from users ordey_by userid desc</span><br>res = db.session.query(Users).order_by(Users.userid.desc()).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-comment"># select * from users where username like %qiang%</span><br>res = db.session.query(Users).<span class="hljs-built_in">filter</span>(Users.username.like(<span class="hljs-string">&#x27;%qiang%&#x27;</span>)).<span class="hljs-built_in">all</span>()<br><span class="hljs-comment"># filter: ==, &gt;=, &gt;, &lt;=, &lt;, !=, in, not</span><br><br><span class="hljs-comment"># select * from users group by role</span><br>res = db.session.query(Users).group_by(Users.role).<span class="hljs-built_in">all</span>()<br>res = db.session.query(Users).group_by(Users.role).having(Users.userid &gt; <span class="hljs-number">2</span>).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-comment"># 聚合函数: min, max, avg, sum</span><br><span class="hljs-comment"># select sum(credit) from users</span><br>res = db.session.query(func.<span class="hljs-built_in">sum</span>(Users.credit)).first()<br><br></code></pre></td></tr></table></figure><h3 id="多表连接查询">多表连接查询</h3><h4 id="内连接">内连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询articleid=1对应的作者信息</span><br>select * <span class="hljs-keyword">from</span> article <br>inner join users on users.userid=article.userid <br>where article.articleid=<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 多表连接查询时，返回的结果不再是单纯的[Model, model]数据结构，而是每张表的结果有独立的对象来维护</span><br>res = db.session.query(Article, Users).join(Users, Article.userid == Users.userid).<span class="hljs-built_in">filter</span>(Article.articleid==<span class="hljs-number">1</span>).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-keyword">for</span> article, user <span class="hljs-keyword">in</span> res:  <span class="hljs-comment"># 这个先后顺序取决于上面query(Article, Users)这个连接表的顺序</span><br>    print(article.articleid, article.headline, users.userid, users.username)<br>    <br>res = db.session.query(Article.articleid, Article.headline, Users.nickname).join(Users, Article.userid == Users.userid).<span class="hljs-built_in">filter</span>(Article.articled==<span class="hljs-number">1</span>).<span class="hljs-built_in">all</span>()<br><br><span class="hljs-keyword">for</span> articledid, headline, nickname <span class="hljs-keyword">in</span> res:<br>    print(articledid, headline, nickname)<br><br></code></pre></td></tr></table></figure><h4 id="外连接">外连接</h4><p><code>outerjoin()</code> 默认左外连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 外连接：查询每一个用户发表过的文章的阅读总量， outerjoin 默认左外连接</span><br>select users.userid, <span class="hljs-built_in">sum</span>(article.readcount) <span class="hljs-keyword">as</span> total <span class="hljs-keyword">from</span> users<br>left join article on users.userid = article.userid<br>group by users.userid<br><br>res = db.session.query(Users.userid, Users.nickname, func.<span class="hljs-built_in">sum</span>(Article.readcount)\<br>     .outerjoin(Article, Users.userid==Article.userid).group_by(Users.userid).<span class="hljs-built_in">all</span>()<br><br></code></pre></td></tr></table></figure><h4 id="复杂查询">复杂查询</h4><p>and、or 混用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 复杂查询: and、or 混用</span><br>select username like <span class="hljs-string">&#x27;qiang&#x27;</span> <span class="hljs-keyword">or</span> (userid &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> nickname=<span class="hljs-string">&#x27;reader3&#x27;</span>)<br><br>res = db.session.query(Users).<span class="hljs-built_in">filter</span>(or_(Users.username.like(<span class="hljs-string">&#x27;%qiang%&#x27;</span>), and_(Users.userid &gt; <span class="hljs-number">3</span>, Users.nickname==<span class="hljs-string">&#x27;reader3&#x27;</span>)))<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 三表查询</span><br>res = db.session.query(Comment, Users).join(Users, Comment.userid==Users.userid)\<br>  .join(Article, Article.articleid==Comment.articleid).<span class="hljs-built_in">all</span>()<br></code></pre></td></tr></table></figure><h3 id="利用sqlalchemy执行原生sql">利用SQLAlchemy执行原生SQL</h3><p>栗：查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">res = db.session.execute(<span class="hljs-string">&quot;select * from users where userid&gt;5&quot;</span>).fetchall()<br>print(res)<br>print(res[<span class="hljs-number">0</span>].username)<br></code></pre></td></tr></table></figure><p>栗：删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">db.session.execute(<span class="hljs-string">&quot;delete from users where userid=10&quot;</span>)<br>db.session.commit()<br></code></pre></td></tr></table></figure><h2 id="sqlalchemy-与-json">SQLAlchemy 与 JSON</h2><p>JSON：JavaScript Object Notation，是 JavaScript 的内置数据格式，由 JavaScript 的数组、对象构成。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">[&#123;&#125;, &#123;&#125;, &#123;&#125;]<br>&#123;[], [], []&#125;<br>&#123;&#123;&#125;, &#123;&#125;, &#123;&#125;&#125;<br>[&#123;[],[],[&#123;&#125;,&#123;&#125;,&#123;&#123;&#125;,&#123;&#125;&#125;]&#125;,&#123;&#125;,&#123;&#125;]<br></code></pre></td></tr></table></figure><blockquote><p><code>[]</code> 数组 <code>&#123;&#125;</code> 对象</p></blockquote><ul><li><p>JavaScript的数组：Python 列表是完全一致的定义方式</p></li><li><p>JavaScript的对象：Python的字典是完全一致的定义 <code>&#123;key:value, key:value&#125;</code></p></li></ul><p><code>jsonify</code> ：jsonify 把标准的 Python 列表或字典或组合转换为 JSON ，且响应的 content-type 也会自动设置为 application/json</p><p>栗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@user.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_demo</span>():</span><br>    users = Users()<br>    result = users.find_all_user()<br>    <span class="hljs-built_in">list</span> = model_list(result)<br>    <span class="hljs-comment"># jsonify 把标准的 Python 列表或字典或组合转换为 JSON ，且响应的 content-type 也会自动设置为 application/json</span><br>    <span class="hljs-keyword">return</span> jsonify(<span class="hljs-built_in">list</span>)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">model_list</span>(<span class="hljs-params">result</span>):</span><br>    <span class="hljs-built_in">list</span> = []<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> result:<br>        <span class="hljs-built_in">dict</span> = &#123;&#125;<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> row.__dict__.items():<br>            <span class="hljs-built_in">dict</span>[key] = value<br>        <span class="hljs-built_in">list</span>.append(<span class="hljs-built_in">dict</span>)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask入门之表单</title>
    <link href="/2021/03/22/Flask%E5%85%A5%E9%97%A8%E4%B9%8B%E8%A1%A8%E5%8D%95/"/>
    <url>/2021/03/22/Flask%E5%85%A5%E9%97%A8%E4%B9%8B%E8%A1%A8%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="flask入门之表单">Flask入门之表单</h1><h2 id="什么是表单">什么是表单？</h2><p><a href="https://baike.baidu.com/item/表单">表单</a>是一个包含表单元素的区域。表单在网页中主要负责数据采集功能。</p><p>表单元素是允许用户在表单中（比如：文本域、下拉列表、单选框、复选框等等）输入信息的元素。</p><p>表单使用表单标签 <code>&lt;form&gt;</code> 定义。</p><blockquote><p>来自百科。</p></blockquote><p>在 HTML 页面里，我们需要编写表单来获取用户输入。一个典型的表单如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 指定提交方法为 POST --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>名字<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 文本输入框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;occupation&quot;</span>&gt;</span>职业<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;occupation&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;occupation&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 文本输入框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登录&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 提交按钮 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写表单的 HTML 代码有下面几点需要注意：</p><ul><li>在 <code>&lt;form&gt;</code> 标签里使用 <code>method</code> 属性将提交表单数据的 HTTP 请求方法指定为 POST。如果不指定，则会默认使用 GET 方法，这会将表单数据通过 URL 提交，容易导致数据泄露，而且不适用于包含大量数据的情况。</li><li><code>&lt;input&gt;</code> 元素必须要指定 <code>name</code> 属性，否则无法提交数据，在服务器端，我们也需要通过这个 <code>name</code> 属性值来获取对应字段的数据。</li></ul><blockquote><p><strong>提示</strong> 填写输入框标签文字的 <code>&lt;label&gt;</code> 元素不是必须的，只是为了辅助鼠标用户。当使用鼠标点击标签文字时，会自动激活对应的输入框，这对复选框来说比较有用。<code>for</code> 属性填入要绑定的 <code>&lt;input&gt;</code> 元素的 <code>id</code> 属性值。</p></blockquote><h2 id="flask-wtf-表单介绍">flask-wtf 表单介绍</h2><p>手动验证表单数据既麻烦又不可靠。对于复杂的程序，我们一般会使用集成了 WTForms 的扩展 <a href="https://github.com/lepture/flask-wtf">Flask-WTF</a> 来简化表单处理。通过编写表单类，定义表单字段和验证器，它可以自动生成表单对应的 HTML 代码，并在表单提交时验证表单数据，返回对应的错误消息。更重要的，它还内置了 CSRF（跨站请求伪造） 保护功能。</p><h3 id="表单常用字段类型">表单常用字段类型</h3><ul><li>集成 wtforms</li><li>CSRF 保护</li><li>与 Flask-Uploads 一起支持文件上传</li></ul><h2 id="表单常用字段类型及渲染">表单常用字段类型及渲染</h2><h3 id="表单字段的常用核心参数">表单字段的常用核心参数</h3><ul><li><code>label</code> ：label标签</li><li><code>default</code>：表单默认值</li><li><code>validators</code> ：表单验证规则</li><li><code>widget</code> ：定制界面显示方法（如：文本框、选择框）</li><li><code>desciprtion</code> ：帮助文字</li></ul><h3 id="section"></h3><ul><li>文本/字符串<ul><li><code>StringField</code> ：字符串输入</li><li><code>PasswordField</code> ：密码输入</li><li><code>TextAreaField</code> ：长文本输入</li><li><code>HiddenField</code> ：隐藏表单域</li></ul></li><li>数值（整数，小数）<ul><li><code>FloatField</code> ：浮点数输入</li><li><code>IntegerField</code> ：整数输入</li><li><code>DecimalField</code> ：小数输入（要精确）</li></ul></li><li>选择<ul><li><code>RadioField</code> ：radio 单选</li><li><code>SelectField</code> ：下拉单选</li><li><code>SelectMultiple</code> ：下拉单选</li><li><code>BooleanField</code> ：勾选（复选框）</li></ul></li><li>日期/时间<ul><li><code>DateField</code> ：日期选择</li><li><code>DateTimeField</code> ：日期时间选择</li></ul></li><li>文件/文件上传<ul><li><code>FileField</code> ：文件单选</li><li><code>MultipleFileField</code> ：文件多选</li></ul></li><li>其他：<ul><li><code>SubmitField</code> ：提交按钮</li><li><code>FieldList</code> ：自定义的表单选择列表（如：选择用户对象）</li><li><code>FormField</code> ：自定义多个字段构成的选项</li></ul></li></ul><h3 id="表单渲染">表单渲染</h3><ul><li><p>使用模板语法渲染表单内容</p><p>表单输入区域：<code>&#123;&#123;form.username&#125;&#125;</code></p><p>表单 label：<code>&#123;&#123; form.username.label.text &#125;&#125;</code></p></li></ul><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/form&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">page_form</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; form 表单练习 &quot;&quot;&quot;</span><br>    form = LoginForm()<br>    <span class="hljs-keyword">if</span> form.validate_on_submit():<br>        print(<span class="hljs-string">&#x27;登陆成功&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        print(form.errors)<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;page_form.html&#x27;</span>,<br>                           form=form)<br></code></pre></td></tr></table></figure><p><em>forms.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginForm</span>(<span class="hljs-params">FlaskForm</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 登陆表单的实现 &quot;&quot;&quot;</span><br>    username = StringField(label=<span class="hljs-string">&#x27;用户名&#x27;</span>, default=<span class="hljs-string">&#x27;admin&#x27;</span>)<br>    password = PasswordField(label=<span class="hljs-string">&#x27;密码&#x27;</span>, validators=[phone_required])<br>    submit = SubmitField(<span class="hljs-string">&#x27;登录&#x27;</span>)<br></code></pre></td></tr></table></figure><p><em>page_form.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Flask Form 表单练习<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>欢迎登陆<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            &#123;&#123; form.username.label &#125;&#125;<br>            &#123;&#123; form.username &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            &#123;&#123; form.password.label &#125;&#125;<br>            &#123;&#123; form.password &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            &#123;&#123; form.submit &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/form表单练习.png"style="width:70%;"/></center><h2 id="处理表单数据">处理表单数据</h2><p>默认情况下，当表单中的提交按钮被按下，浏览器会创建一个新的请求，默认发往当前 URL（在 <code>&lt;form&gt;</code> 元素使用 <code>action</code> 属性可以自定义目标 URL）。</p><p>因为我们在模板里为表单定义了 POST 方法，当你输入数据，按下提交按钮，一个携带输入信息的 POST 请求会发往根地址。接着，你会看到一个 405 Method Not Allowed 错误提示。这是因为处理根地址请求的 <code>index</code> 视图默认只接受 GET 请求。</p><blockquote><p><strong>提示</strong> 在 HTTP 中，GET 和 POST 是两种最常见的请求方法，其中 GET 请求用来获取资源，而 POST 则用来创建 / 更新资源。我们访问一个链接时会发送 GET 请求，而提交表单通常会发送 POST 请求。</p></blockquote><p>为了能够处理 POST 请求，我们需要修改一下视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br></code></pre></td></tr></table></figure><p>在 <code>app.route()</code> 装饰器里，我们可以用 <code>methods</code> 关键字传递一个包含 HTTP 方法字符串的列表，表示这个视图函数处理哪种方法类型的请求。默认只接受 GET 请求，上面的写法表示同时接受 GET 和 POST 请求。</p><p>两种方法的请求有不同的处理逻辑：对于 GET 请求，返回渲染后的页面；对于 POST 请求，则获取提交的表单数据并保存。为了在函数内加以区分，我们添加一个 if 判断：</p><p><em>app.py：创建电影条目</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request, url_for, redirect, flash<br><br><span class="hljs-comment"># ...</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:  <span class="hljs-comment"># 判断是否是 POST 请求</span><br>        <span class="hljs-comment"># 获取表单数据</span><br>        title = request.form.get(<span class="hljs-string">&#x27;title&#x27;</span>)  <span class="hljs-comment"># 传入表单对应输入字段的 name 值</span><br>        year = request.form.get(<span class="hljs-string">&#x27;year&#x27;</span>)<br>        <span class="hljs-comment"># 验证数据</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> title <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> year <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(year) &gt; <span class="hljs-number">4</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(title) &gt; <span class="hljs-number">60</span>:<br>            flash(<span class="hljs-string">&#x27;Invalid input.&#x27;</span>)  <span class="hljs-comment"># 显示错误提示</span><br>            <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))  <span class="hljs-comment"># 重定向回主页</span><br>        <span class="hljs-comment"># 保存表单数据到数据库</span><br>        movie = Movie(title=title, year=year)  <span class="hljs-comment"># 创建记录</span><br>        db.session.add(movie)  <span class="hljs-comment"># 添加到数据库会话</span><br>        db.session.commit()  <span class="hljs-comment"># 提交数据库会话</span><br>        flash(<span class="hljs-string">&#x27;Item created.&#x27;</span>)  <span class="hljs-comment"># 显示成功创建的提示</span><br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))  <span class="hljs-comment"># 重定向回主页</span><br><br>    movies = Movie.query.<span class="hljs-built_in">all</span>()<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>, movies=movies)<br></code></pre></td></tr></table></figure><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/register&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">page_register</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 新用户注册 &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 不做 csrf 校验：csrf_enabled=False</span><br>    <span class="hljs-comment"># form = RegisterForm(csrf_enabled=False)</span><br>    form = RegisterForm()<br>    <span class="hljs-comment"># 用户在提交表单的时候，会触发validate_on_submit</span><br>    <span class="hljs-keyword">if</span> form.validate_on_submit():<br>        <span class="hljs-comment"># 表单验证通过，接下来处理业务逻辑</span><br>        <span class="hljs-comment"># 1. 获取表单数据</span><br>        username = form.username.data<br>        password = form.password.data<br>        birth_date = form.birth_date.data<br>        age = form.age.data<br>        <span class="hljs-comment"># 2. 构建用户对象</span><br>        user = User(<br>            username=username,<br>            password=password,<br>            birth_date=birth_date,<br>            age=age<br>        )<br>        <span class="hljs-comment"># 3. 提交到数据库</span><br>        db.session.add(user)<br>        db.session.commit()<br>        print(<span class="hljs-string">&#x27;添加成功&#x27;</span>)<br>        <span class="hljs-comment"># 4. 跳转到登录页面</span><br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 打印错误信息</span><br>        print(form.errors)<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;page_register.html&#x27;</span>,<br>                           form=form)<br></code></pre></td></tr></table></figure><p><em>forms.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterForm</span>(<span class="hljs-params">FlaskForm</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 用户注册表单 &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># def __init__(self, csrf_enabled, *args, **kwargs):</span><br>    <span class="hljs-comment">#     super().__init__(csrf_enabled=csrf_enabled, *args, **kwargs)</span><br><br>    username = StringField(label=<span class="hljs-string">&#x27;用户名&#x27;</span>)<br>    password = PasswordField(label=<span class="hljs-string">&#x27;密码&#x27;</span>, validators=[DataRequired(<span class="hljs-string">&#x27;请输入密码&#x27;</span>)])<br>    birth_date = DateField(label=<span class="hljs-string">&#x27;生日&#x27;</span>)<br>    age = IntegerField(label=<span class="hljs-string">&#x27;年龄&#x27;</span>)<br>    submit = SubmitField(<span class="hljs-string">&#x27;注册&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_username</span>(<span class="hljs-params">self, field</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot; 验证用户名 &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 强制验证用户名为手机号</span><br>        username = field.data<br>        pattern = <span class="hljs-string">r&#x27;^1[0-9]&#123;10&#125;&amp;&#x27;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> re.search(pattern, username):<br>            <span class="hljs-keyword">raise</span> ValidationError(<span class="hljs-string">&#x27;请输入手机号码&#x27;</span>)<br>        <span class="hljs-keyword">return</span> field<br></code></pre></td></tr></table></figure><p><em>page_register.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>用户注册<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>用户注册<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;page_register&#x27;) &#125;&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        &#123;&#123; form.csrf_token &#125;&#125;  <span class="hljs-comment">&lt;!-- 配置csrf --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            &#123;&#123; form.username.label &#125;&#125;<br>            &#123;&#123; form.username &#125;&#125;<br>            &#123;% if form.username.errors %&#125;<br>                &#123;% for err in form.username.errors %&#125;<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; err &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                &#123;% endfor %&#125;<br>            &#123;% endif %&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            &#123;&#123; form.password.label &#125;&#125;<br>            &#123;&#123; form.password &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            &#123;&#123; form.birth_date.label &#125;&#125;<br>            &#123;&#123; form.birth_date &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            &#123;&#123; form.age.label &#125;&#125;<br>            &#123;&#123; form.age &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            &#123;&#123; form.submit &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="通过表单验证数据">通过表单验证数据</h2><p>步骤：</p><ol type="1"><li><p><strong>检测表单是否已经通过验证</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">form.validate_on_submit()<br></code></pre></td></tr></table></figure></li><li><p><strong>获取表单中传递过来的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">form.field_name.data<br></code></pre></td></tr></table></figure></li><li><p><strong>业务逻辑代码编写（可结合ORM）</strong></p></li></ol><p><strong>CSRF</strong></p><p>CSRF 是一种常见的攻击手段。以我们的删除表单为例，某恶意网站的页面中内嵌了一段代码，访问时会自动发送一个删除某个电影条目的 POST 请求到我们的程序。如果我们访问了这个恶意网站，就会导致电影条目被删除，因为我们的程序没法分辨请求发自哪里。解决方法通常是在表单里添加一个包含随机字符串的隐藏字段，同时在 Cookie 中也创建一个同样的随机字符串，在提交时通过对比两个值是否一致来判断是否是用户自己发送的请求。</p><p>这里涉及了<strong>CSRF表单保护</strong>， 这个是默认开启的，我们可以选择关闭单个表单的CSRF保护：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">form = LoginForm(csrf_enabled=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>但是通常是用另一种做法，<strong>在模板中添加 csrf_token</strong></p><p>先在 <em>app.py</em> 中添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">app.config[<span class="hljs-string">&#x27;WTF_CSRF_SECRET_KEY&#x27;</span>] = <span class="hljs-string">&#x27;a random key&#x27;</span><br></code></pre></td></tr></table></figure><p>然后在模板中添加 csrf_token：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; form.csrf_token &#125;&#125;<br></code></pre></td></tr></table></figure><p>这段会直接在html中插入 csrf_token。</p><h3 id="表单验证">表单验证</h3><p><strong>表单验证为了什么？</strong></p><ul><li>更好的用户体验</li><li>更少安全隐患（比如注册手机号应该唯一）</li><li>永远不要相信用户的输入 :p</li></ul><p><strong>如何进行表单验证？</strong></p><ol type="1"><li><p>导入内置的表单验证器（或自定义）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> wtforms.validators <span class="hljs-keyword">import</span> DataRequired<br></code></pre></td></tr></table></figure></li><li><p>配置到表单字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">username = StringField(<span class="hljs-string">&#x27;用户名&#x27;</span>,<br>                      validators=[InputRequired(), my_validator])<br></code></pre></td></tr></table></figure></li></ol><p><strong>内置的表单验证器</strong></p><ul><li><code>DataRequired/InputRequires</code> ：必填</li><li><code>Email/URL/UUID</code> ：电子邮箱/URL/UUID</li><li><code>Length(min=-1, max=-1, message=None)</code> ：长度范围验证</li><li><code>EquaTo(fieldname, message=None)</code></li></ul><p><strong>自定义的表单验证器</strong></p><ul><li>只有本表单使用</li><li>多个表单使用（如：验证手机号码）</li></ul><h2 id="图片上传">图片上传</h2><p>两种方式实现文件上传</p><ol type="1"><li><strong>不使用 wtf 实现</strong></li><li><strong>使用 FileField 并添加类型验证</strong></li></ol><h3 id="不使用-wtf-实现">不使用 wtf 实现</h3><ol type="1"><li><p>设置 <code>&lt;form enctype=&quot;multipart/form-data&quot;&gt;</code></p></li><li><p>在视图函数中获取文件对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">request.files<br></code></pre></td></tr></table></figure></li><li><p>保存文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f.save(file_path)<br></code></pre></td></tr></table></figure><blockquote><p>文件名称格式化：<code>werkzeug.utils.secure_filename</code></p></blockquote></li></ol><p>栗子：</p><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义的配置扩展，表示文件上传的路径</span><br>app.config[<span class="hljs-string">&#x27;UPLOAD_PATH&#x27;</span>] = os.path.join(os.path.dirname(__file__), <span class="hljs-string">&#x27;medias&#x27;</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/img/upload&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">img_upload</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 不使用wtf实现的文件上传 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;POST&quot;</span>:<br>        <span class="hljs-comment"># 获取文件列表</span><br>        files = request.files<br>        file1 = files.get(<span class="hljs-string">&#x27;file1&#x27;</span>, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> file1:<br>            <span class="hljs-comment"># 保存文件</span><br>            <span class="hljs-comment"># 改掉文件名字（除去一些恶意字符）</span><br>            f_name = secure_filename(file1.filename)<br>            print(<span class="hljs-string">&#x27;filename:&#x27;</span>, f_name)<br>            file_name = os.path.join(app.config[<span class="hljs-string">&#x27;UPLOAD_PATH&#x27;</span>], f_name)<br>            file1.save(file_name)<br>            print(<span class="hljs-string">&#x27;&#123;&#125; 保存成功&#x27;</span>.<span class="hljs-built_in">format</span>(file_name))<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;img_upload&#x27;</span>))<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;img_upload.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p><em>img_upload.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>文件上传<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;img_upload&#x27;) &#125;&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    &#123;&#123; form.csrf_token &#125;&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;开始上传&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击”选择文件“后，上传图片，图片就会出现在既定的文件夹下面。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/form_文件上传.png"style="width:70%;"/></center><h3 id="使用-filefield-并添加类型验证">使用 FileField 并添加类型验证</h3><p>栗子：</p><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义的配置扩展，表示文件上传的路径</span><br>app.config[<span class="hljs-string">&#x27;UPLOAD_PATH&#x27;</span>] = os.path.join(os.path.dirname(__file__), <span class="hljs-string">&#x27;medias&#x27;</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/avatar/upload&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">avartar_upload</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 头像上传 &quot;&quot;&quot;</span><br>    form = UserAvatarForm()<br>    <span class="hljs-keyword">if</span> form.validate_on_submit():<br>        <span class="hljs-comment"># 获取图片对象</span><br>        img = form.avatar.data<br>        f_name = secure_filename(img.filename)<br>        file_name = os.path.join(app.config[<span class="hljs-string">&#x27;UPLOAD_PATH&#x27;</span>], f_name)<br>        img.save(file_name)<br>        print(<span class="hljs-string">&#x27;&#123;&#125; 保存成功&#x27;</span>.<span class="hljs-built_in">format</span>(f_name))<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;avartar_upload&#x27;</span>))<br>    <span class="hljs-keyword">else</span>:<br>        print(form.errors)<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;avartar_upload.html&#x27;</span>,<br>                           form=form)<br></code></pre></td></tr></table></figure><p><em>forms.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAvatarForm</span>(<span class="hljs-params">FlaskForm</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 用户头像上传 &quot;&quot;&quot;</span><br>    avatar = FileField(label=<span class="hljs-string">&#x27;上传头像&#x27;</span>, validators=[<br>        FileRequired(<span class="hljs-string">&#x27;请选择头像文件&#x27;</span>),<br>        FileAllowed([<span class="hljs-string">&#x27;png&#x27;</span>], <span class="hljs-string">&#x27;仅支持PNG图片上传&#x27;</span>)<br>    ])<br></code></pre></td></tr></table></figure><p><em>avatar_upload.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;avartar_upload&#x27;) &#125;&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    &#123;&#123; form.csrf_token &#125;&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        &#123;&#123; form.avatar.label &#125;&#125;<br>        &#123;&#123; form.avatar &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击”选择文件“后，上传图片，图片就会出现在既定的文件夹下面。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/form上传头像.png"style="width:70%;"/></center>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask入门之ORM使用</title>
    <link href="/2021/03/21/Flask%E5%85%A5%E9%97%A8%E4%B9%8BORM%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/03/21/Flask%E5%85%A5%E9%97%A8%E4%B9%8BORM%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="flask入门之orm使用">Flask入门之ORM使用</h1><h2 id="orm">ORM</h2><p>ORM，即Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。</p><p>特性：</p><ul><li>面向对象的编程思想，方便扩充</li><li>少些（几乎不写）SQL，提升开发效率</li><li>支持多种类型的数据库，方便切换</li><li>ORM技术成熟，能解决绝大部分问题</li></ul><h2 id="使用-sqlalchemy-操作数据库">使用 SQLAlchemy 操作数据库</h2><p>为了简化数据库操作，我们将使用 <a href="https://www.sqlalchemy.org/">SQLAlchemy</a>——一个 Python 数据库工具（ORM，即对象关系映射）。借助 SQLAlchemy，你可以通过定义 Python 类来表示数据库里的一张表（类属性表示表中的字段 / 列），通过对这个类进行各种操作来代替写 SQL 语句。这个类我们称之为<strong>模型类</strong>，类中的属性我们将称之为<strong>字段</strong>。</p><p>Flask 有大量的第三方扩展，这些扩展可以简化和第三方库的集成工作。我们下面将使用一个叫做 <a href="http://flask-sqlalchemy.pocoo.org/2.3/">Flask-SQLAlchemy</a> 的官方扩展来集成 SQLAlchemy。</p><p>首先安装它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install flask-sqlalchemy<br></code></pre></td></tr></table></figure><p>大部分扩展都需要执行一个“初始化”操作。你需要导入扩展类，<strong>实例化</strong>并传入 Flask 程序实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy  <span class="hljs-comment"># 导入扩展类</span><br><br>app = Flask(__name__)<br><br>db = SQLAlchemy(app)  <span class="hljs-comment"># 初始化扩展，传入程序实例 app</span><br></code></pre></td></tr></table></figure><h3 id="设置数据库-uri">设置数据库 URI</h3><p>为了设置 Flask、扩展或是我们程序本身的一些行为，我们需要设置和定义一些配置变量。Flask 提供了一个统一的接口来写入和获取这些配置变量：<code>Flask.config</code> 字典。配置变量的名称必须使用大写，写入配置的语句一般会放到扩展类实例化语句之前。</p><p>下面写入了一个 <code>SQLALCHEMY_DATABASE_URI</code> 变量来告诉 SQLAlchemy 数据库连接地址:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 配置数据库的连接参数</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="hljs-string">&#x27;mysql://root:xxxxxxxx@127.0.0.1/test_flask&#x27;</span><br></code></pre></td></tr></table></figure><p>MySQL 数据库URI 参数格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mtsql://username:password@localhost/mydatabase<br></code></pre></td></tr></table></figure><h2 id="创建数据库模型">创建数据库模型</h2><p><strong>实例化对象，即绑定到 Flask 对象：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">db = SQLAlchemy(app)<br></code></pre></td></tr></table></figure><p><strong>ORM 模型创建：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">db.Model</span>):</span>  <span class="hljs-comment"># 表名将会是 user（自动生成，小写处理）</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Interger, primary_key=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p><strong>指定表的名字：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__tablename__ = <span class="hljs-string">&#x27;weibo_user&#x27;</span><br></code></pre></td></tr></table></figure><p>模型类的编写有一些限制：</p><ul><li>模型类要声明继承 <code>db.Model</code>。</li><li>每一个类属性（字段）要实例化 <code>db.Column</code>，传入的参数为字段的类型，下面的表格列出了常用的字段类。</li><li>在 <code>db.Column()</code> 中添加额外的选项（参数）可以对字段进行设置。比如，<code>primary_key</code> 设置当前字段是否为主键。除此之外，常用的选项还有 <code>nullable</code>（布尔值，是否允许为空值）、<code>index</code>（布尔值，是否设置索引）、<code>unique</code>（布尔值，是否允许重复值）、<code>default</code>（设置默认值）等。</li></ul><p>常用的字段类型如下表所示：</p><table><thead><tr class="header"><th>字段类</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>db.Integer</td><td>整型</td></tr><tr class="even"><td>db.String (size)</td><td>字符串，size 为最大长度，比如 <code>db.String(20)</code></td></tr><tr class="odd"><td>db.Text</td><td>长文本</td></tr><tr class="even"><td>db.DateTime</td><td>时间日期，Python <code>datetime</code> 对象</td></tr><tr class="odd"><td>db.Float</td><td>浮点数</td></tr><tr class="even"><td>db.Boolean</td><td>布尔值</td></tr></tbody></table><h2 id="创建和删除表">创建和删除表</h2><p>首先需要手动创建数据库（在 Navicat 里创建就行）。</p><p><strong>创建表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> app <span class="hljs-keyword">import</span> db<br><span class="hljs-meta">&gt;&gt;&gt; </span>db.create_all()<br></code></pre></td></tr></table></figure><p><strong>删除表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">db.drop_all()<br></code></pre></td></tr></table></figure><p><strong>外键关联（一对多关系）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">addr = db.relationship(<span class="hljs-string">&#x27;UserAddress&#x27;</span>, backref=<span class="hljs-string">&#x27;address&#x27;</span>, lazy=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">db.Model</span>):</span><br>    __tablename__ = <span class="hljs-string">&#x27;weibo_user&#x27;</span>  <span class="hljs-comment"># 改名</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    username = db.Column(db.String(<span class="hljs-number">64</span>), nullable=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 不能为空</span><br>    password = db.Column(db.String(<span class="hljs-number">64</span>), nullable=<span class="hljs-literal">False</span>)<br>    birth_date = db.Column(db.Date, nullable=<span class="hljs-literal">True</span>)<br>    age = db.Column(db.Integer, default=<span class="hljs-number">0</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAddress</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 用户的地址 &quot;&quot;&quot;</span><br>    __tablename__ = <span class="hljs-string">&#x27;weibo_user_addr&#x27;</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    addr = db.Column(db.String(<span class="hljs-number">256</span>), nullable=<span class="hljs-literal">False</span>)<br>    user_id = db.Column(db.Integer, db.ForeignKey(<span class="hljs-string">&#x27;weibo_user.id&#x27;</span>), nullable=<span class="hljs-literal">False</span>)<br>    user = db.relationship(<span class="hljs-string">&#x27;User&#x27;</span>, backref=db.backref(<span class="hljs-string">&#x27;address&#x27;</span>, lazy=<span class="hljs-literal">True</span>))  <br>    <span class="hljs-comment"># 反向引用。lazy=True？查到用户对象时，不直接把地址列表显示出来？</span><br><br></code></pre></td></tr></table></figure><h2 id="orm-的-crud-操作">ORM 的 CRUD 操作</h2><p>构造ORM 模型对象，添加到 <code>db.session</code> （可添加多个对象），然后提交到数据库。</p><h3 id="添加-create">添加 Create</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">user = User(username=<span class="hljs-string">&#x27;小张&#x27;</span>, password=<span class="hljs-string">&#x27;654321&#x27;</span>, birth_date=<span class="hljs-string">&#x27;2021-12-31&#x27;</span>)<br>db.session.add(user)<br>db.session.commit()<br></code></pre></td></tr></table></figure><h3 id="删除-delete">删除 Delete</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.delete(user)<br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.commit()<br></code></pre></td></tr></table></figure><h3 id="修改-update">修改 Update</h3><p>可以这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>user.username=<span class="hljs-string">&#x27;老张&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.add(user)<br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.commit()<br></code></pre></td></tr></table></figure><p>也可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>user = User(username=<span class="hljs-string">&#x27;老张&#x27;</span>, password=<span class="hljs-string">&#x27;123456&#x27;</span>, birth_date=<span class="hljs-string">&#x27;2021-12-31&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.add(user)<br><span class="hljs-meta">&gt;&gt;&gt; </span>db.session.commit()<br></code></pre></td></tr></table></figure><h3 id="查询-retrieve">查询 Retrieve</h3><p><strong>查询所有数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">User.query.<span class="hljs-built_in">all</span>()<br></code></pre></td></tr></table></figure><p><strong>链式调用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">User.query.filter_by(username=<span class="hljs-string">&#x27;zhangsan&#x27;</span>).<span class="hljs-built_in">all</span>()<br></code></pre></td></tr></table></figure><p><strong>总共多少条记录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">User.query.filter_by(username=<span class="hljs-string">&#x27;zhangsan&#x27;</span>).count()<br></code></pre></td></tr></table></figure><p><strong>排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">User.query.order_by(User.<span class="hljs-built_in">id</span>.asc())<br>User.query.order_by(User.<span class="hljs-built_in">id</span>.desc())<br></code></pre></td></tr></table></figure><p><strong>查询TOP10</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">User.query.limit(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p><strong>filter()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">User.query.<span class="hljs-built_in">filter</span>(User.username.endswith(<span class="hljs-string">&#x27;三&#x27;</span>))<br></code></pre></td></tr></table></figure><ul><li><p>比较：<code>==</code> ，<code>&gt;</code> ，<code>&lt;</code>，<code>&gt;=</code> ，<code>&lt;=</code></p></li><li><p>模糊匹配：<code>like/ilike</code> ，<code>contains</code>，<code>startswith/endswith</code> ，<code>in_/notin_</code></p></li><li><p>且、或：<code>and_</code>，<code>or_</code></p></li></ul><p><strong>filter_by()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">User.query.filter_by(username=<span class="hljs-string">&#x27;zhangsan&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>视图函数</strong></p><ul><li><code>first() vs first_or_404()</code></li><li><code>get() vs get_or_404()</code></li></ul><p><strong>分页</strong></p><ol type="1"><li><p><code>.offset(offset).limit(limit)</code></p></li><li><p><strong>paginate</strong> 支持分页</p><p><code>.paginate(page=2,per_page=4)</code> 返回Pagination 的对象</p><ul><li><code>has_prev/has_next</code> ：是否有上一页/下一页</li><li><code>items</code> ：当前页的数据列表</li><li><code>prev_num/next_num</code> ：上一页/下一页的页码</li><li><code>total</code> ：总记录数</li><li><code>pages</code> ：总页数</li></ul></li></ol><p>举个栗子：分页步骤</p><ol type="1"><li><p>准备数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">list_user = User.query.filter_by(is_valid=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>分页</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">list_user.paginate(page=<span class="hljs-number">2</span>, per_page=<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure></li><li><p>在模板中实现分页操作</p></li></ol><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&lt;int:page&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">list_user</span>(<span class="hljs-params">page</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 用户分页&quot;&quot;&quot;</span><br>    per_page = <span class="hljs-number">10</span>  <span class="hljs-comment"># 每一页的数据大小</span><br>    <span class="hljs-comment"># 1. 查询用户信息</span><br>    user_list = User.query<br>    <span class="hljs-comment"># 2. 准备分页数据</span><br>    user_page_data = user_list.paginate(page, per_page=per_page)<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;list_user.html&#x27;</span>, user_page_data=user_page_data)    <br></code></pre></td></tr></table></figure><p><em>list_user.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>用户分页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>总共有&#123;&#123; user_page_data.total &#125;&#125;用户，当前在第&#123;&#123; user_page_data.page &#125;&#125;页, 总共&#123;&#123; user_page_data.pages &#125;&#125;页<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        用户列表：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            &#123;% for user in user_page_data.items %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; user.username &#125;&#125; - &#123;&#123; user.password &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            &#123;% endfor %&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        &#123;% if user_page_data.has_prev %&#125;  <span class="hljs-comment">&lt;!-- 如果有上一页 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;list_user&#x27;, page=user_page_data.prev_num) &#125;&#125;&quot;</span>&gt;</span>上一页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        &#123;% endif %&#125;<br>        &#123;% if user_page_data.has_next %&#125;  <span class="hljs-comment">&lt;!-- 如果有下一页 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;list_user&#x27;, page=user_page_data.next_num) &#125;&#125;&quot;</span>&gt;</span>下一页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        &#123;% endif %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如下图，在第一页和最后一页没有对应的上一页和下一页</p></blockquote><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/模板分页.png"style="width:100;"/></center>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask入门之模板</title>
    <link href="/2021/03/20/Flask%E5%85%A5%E9%97%A8%E4%B9%8B%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/03/20/Flask%E5%85%A5%E9%97%A8%E4%B9%8B%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="flask入门之模板-jinja2">Flask入门之模板 Jinja2</h1><p>思考：没有模板渲染函数怎样在浏览器展示 HTML 文件？</p><p>答：1. 从磁盘读取 html 字符串</p><p>​ 2. 将满足特定规则的内容进行替换</p><p>​ 3. 发送给浏览器展示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/show/html&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">html_show</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 理解渲染机制 &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 1. 找到磁盘上的html文件地址（全路径）</span><br>    file_name = os.path.join(os.path.dirname(__file__), <span class="hljs-string">&#x27;templates&#x27;</span>, <span class="hljs-string">&#x27;index.html&#x27;</span>)<br>    print(file_name)<br>    <span class="hljs-comment"># 2. 读取html文件中的内容</span><br>    now_time = datetime.now().strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        html = f.read()<br>        <span class="hljs-comment"># 3. 替换html中特殊字符&#123;&#123; time &#125;&#125;</span><br>        html = html.replace(<span class="hljs-string">&#x27;&#123;&#123; time &#125;&#125;&#x27;</span>, now_time)<br>        <span class="hljs-comment"># 4. 将将tml的内容发送给浏览器</span><br>        <span class="hljs-keyword">return</span> html<br>    <br></code></pre></td></tr></table></figure><p>在一般的 Web 程序里，访问一个地址通常会返回一个包含各类信息的 HTML 页面。因为我们的程序是动态的，页面中的某些信息需要根据不同的情况来进行调整，比如对登录和未登录用户显示不同的信息，所以页面需要在用户访问时根据程序逻辑动态生成。</p><p>我们把包含变量和运算逻辑的 HTML 或其他格式的文本叫做<strong>模板</strong>，执行这些变量替换和逻辑计算工作的过程被称为<strong>渲染</strong>，这个工作由我们这一章要学习使用的模板渲染引擎——Jinja2 来完成。</p><blockquote><p><strong>模板</strong>：是一个包含响应文件的<strong>文件</strong>，其中用<strong>占位符（变量）</strong>表示动态部分，告诉模板引擎其具体的值需要从使用的数据中获取。</p><p><strong>渲染</strong>：使用真实值替换变量，在返回最终得到的字符串，这个过程叫渲染。</p></blockquote><h2 id="模板引擎">模板引擎</h2><p>Flask 使用 <strong>Jinja2</strong> 作为默认模板引擎。</p><p><strong>全局对象</strong></p><ul><li><code>config</code>：Flask 的配置信息</li><li><code>request</code>：请求对象</li><li><code>session</code>：会话对象</li><li><code>g</code>：请求相关的全局变量（如：g.user）</li></ul><p><strong>全局函数</strong></p><ul><li><code>url_for()</code> ：URL 解析函数（如：静态文件地址解析、连接跳转地址解析）</li><li><code>get_flashed_messages()</code> ：会话信息</li></ul><p>栗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/mine&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mine</span>():</span><br>    print(url_for(<span class="hljs-string">&#x27;html&#x27;</span>, _external=<span class="hljs-literal">True</span>))  <span class="hljs-comment"># 全路径</span><br>    print(url_for(<span class="hljs-string">&#x27;mine&#x27;</span>, _external=<span class="hljs-literal">True</span>))<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;mine.html&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="模板变量">模板变量</h2><p>语法：<code>&#123;&#123; value &#125;&#125;</code></p><ul><li>dict 类型数据的渲染：<code>&#123;&#123; object.attribute &#125;&#125;</code> 或 <code>&#123;&#123; object['attribute'] &#125;&#125;</code></li></ul><p>举个栗子：</p><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-comment"># 1. 简单数据类型的渲染</span><br>    age = <span class="hljs-number">40</span><br>    money = <span class="hljs-number">65.89</span><br>    name = <span class="hljs-string">&#x27;张三&#x27;</span><br><br>    <span class="hljs-comment"># 2. 用户信息 dict</span><br>    user_info = &#123;<br>        <span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>        <span class="hljs-string">&#x27;nickname&#x27;</span>: <span class="hljs-string">&#x27;dog&#x27;</span>,<br>        <span class="hljs-string">&#x27;address.city&#x27;</span>: <span class="hljs-string">&#x27;liaoning&#x27;</span>,<br>        <span class="hljs-string">&#x27;address.area&#x27;</span>: <span class="hljs-string">&#x27;dalian&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment"># 3. 元组和列表</span><br>    tuple_city = (<span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;广州&#x27;</span>, <span class="hljs-string">&#x27;深圳&#x27;</span>)<br>    list_city = [<span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;广州&#x27;</span>, <span class="hljs-string">&#x27;深圳&#x27;</span>]<br><br>    <span class="hljs-comment"># 4. 复杂的数据结构</span><br>    list_user = [<br>        &#123;<br>            <span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>            <span class="hljs-string">&#x27;address&#x27;</span>: &#123;<br>                <span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;大连&#x27;</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;小李&#x27;</span>,<br>            <span class="hljs-string">&#x27;address&#x27;</span>: &#123;<br>                <span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;沈阳&#x27;</span><br>            &#125;<br>        &#125;<br>    ]<br><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>,<br>                            age=age,<br>                            money=money,<br>                            name=name,<br>                            user_info=user_info,<br>                            tuple_city=tuple_city,<br>                            list_city=list_city,<br>                            list_user=list_user)<br><br></code></pre></td></tr></table></figure><p><em>index.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>1. 简单数据类型的渲染<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我的年龄：&#123;&#123; age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我的钱：&#123;&#123; money &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我的name：&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>2. 用户信息 dict<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户名：&#123;&#123; user_info.username &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户昵称：&#123;&#123; user_info.nickname &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户地址：&#123;&#123; user_info[&#x27;address.city&#x27;] &#125;&#125;-&#123;&#123; user_info[&#x27;address.area&#x27;] &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>3. 元组和列表<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        &#123;&#123; tuple_city[0] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        &#123;&#123; tuple_city[1] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        &#123;&#123; tuple_city[2] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        &#123;&#123; tuple_city[3] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        &#123;&#123; list_city[0] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        &#123;&#123; list_city[1] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        &#123;&#123; list_city[2] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        &#123;&#123; list_city[3] &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>4. 复杂的数据结构<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        第一个同学：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        用户名：&#123;&#123; list_user[0].username &#125;&#125;; 地址：&#123;&#123; list_user[0][&#x27;address&#x27;][&#x27;city&#x27;] &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        第二个同学：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        用户名：&#123;&#123; list_user[1].username &#125;&#125;; 地址：&#123;&#123; list_user[1][&#x27;address&#x27;][&#x27;city&#x27;] &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>得到：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/模板对象.png"style="width:50%;"/></center><h2 id="模板标签">模板标签</h2><p>在模板里，你需要添加特定的定界符将 Jinja2 语句和变量标记出来，下面是三种常用的定界符：</p><p>1、<code>&#123;&#123; ... &#125;&#125;</code> 用来标记变量。</p><p>2、<code>&#123;% tag %&#125;</code> 用来标记语句，比如 if 语句，for 语句等。</p><p>3、<code>&#123;# ... #&#125;</code> 用来写注释。</p><p>模板中使用的变量需要在渲染的时候传递进去。</p><h3 id="条件表达式-if">条件表达式 if</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jinja2">&#123;% if condition_a %&#125;<br>满足了A条件<br>&#123;% elif condition_b %&#125;<br>满足了B条件<br>&#123;% else %&#125;<br>都不满足<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p>内置的判断条件：</p><ul><li><code>defined/undefined</code> ：变量是否已经定义</li><li><code>none</code> ：变量是否为 None</li><li><code>number/string</code> ：数字/字符串判断</li><li><code>even/odd</code></li><li><code>upper/lower</code></li></ul><p>举个栗子：</p><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/tag&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tag</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 模板标签的使用 &quot;&quot;&quot;</span><br>    a = <span class="hljs-number">1</span><br>    b = <span class="hljs-number">2</span><br>    list_user = [<br>        &#123;<span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;18&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>: <span class="hljs-string">&#x27;北京&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;小李&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;小王&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;18&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>: <span class="hljs-string">&#x27;北京&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;小何&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>&#125;,<br>    ]<br>    <span class="hljs-comment"># list_user = []</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;tag.html&#x27;</span>,<br>                           a=a,<br>                           b=b,<br>                           list_user=list_user)<br></code></pre></td></tr></table></figure><p><em>tag.html</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jinja2">&lt;p&gt;if 的使用：&lt;&#x2F;p&gt;<br>&#123;% if a is none %&#125;<br>&lt;p&gt;a 是 none&lt;&#x2F;p&gt;<br>&#123;% else %&#125;<br>&lt;p&gt;a 不是 none&lt;&#x2F;p&gt;<br>&#123;% endif %&#125;<br><br>&#123;% if b is defined %&#125;<br>&lt;p&gt;b 定义了&lt;&#x2F;p&gt;<br>&#123;% else %&#125;<br>&lt;p&gt;b 没有定义&lt;&#x2F;p&gt;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><blockquote><p>输出：</p><p>if 的使用：</p><p>a 不是 none</p><p>b 定义了</p></blockquote><h3 id="for-循环">for 循环</h3><p>栗子：</p><p><em>tag.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>for 循环的使用<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>&#123;% for item in list_user %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户名：&#123;&#123; item.username &#125;&#125;, 年龄：&#123;&#123; item.age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% else %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户信息为空<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% endfor %&#125;<br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>for 循环 dict <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>&#123;% for user in list_user %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&#123;&#123; loop.cycle(&#x27;odd&#x27;, &#x27;even&#x27;) &#125;&#125;&quot;</span>&gt;</span><br>    第&#123;&#123; loop.index  &#125;&#125;个同学, 总共&#123;&#123; loop.length &#125;&#125;个同学:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    &#123;% for key, value in user.items() %&#125;<br>    &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<br>    &#123;% endfor %&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% endfor %&#125;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/for循环的使用.png"style="width:70%;"/></center><h3 id="continuebreak">continue/break</h3><p>需要添加扩展来支持break/continue语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">app = Flask(__name__)<br><span class="hljs-comment"># 为模板引擎添加扩展，支持break/continue语法</span><br>app.jinja_env.add_extension(<span class="hljs-string">&#x27;jinja2.ext.loopcontrols&#x27;</span>)<br></code></pre></td></tr></table></figure><p>栗子：</p><p><em>tag.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>for 循环 dict -break<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>&#123;% for user in list_user -%&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&#123;&#123; loop.cycle(&#x27;odd&#x27;, &#x27;even&#x27;) &#125;&#125;&quot;</span>&gt;</span><br>    第&#123;&#123; loop.index  &#125;&#125;个同学, 总共&#123;&#123; loop.length &#125;&#125;个同学:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    &#123;% for key, value in user.items() -%&#125;<br>    &#123;% if loop.index &gt; 2 -%&#125;<br>    &#123;% break -%&#125;<br>    &#123;% endif -%&#125;<br>    &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<br>    &#123;% endfor -%&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% endfor -%&#125;<br></code></pre></td></tr></table></figure><p>如下图：只显示前两个标签</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/for循环 dict-break.png"style="width:70%;"/></center><h3 id="with-块级作用域">with 块级作用域</h3><ul><li><p>设置变量、赋值操作</p><p>先设置，后使用，可以通过 import 导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-built_in">set</span> key, value=(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) %&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 with 代码块，实现块级作用域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">with</span> %&#125;<br>&#123;% <span class="hljs-built_in">set</span> temp = <span class="hljs-number">42</span> %&#125;<br>    &#123;&#123; temp &#125;&#125; 只在代码块中有效<br>&#123;% endwith %&#125;<br></code></pre></td></tr></table></figure><p>栗子：</p></li></ul><p><em>tag.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>赋值的使用<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% with %&#125;<br>&#123;% set temp = 43 %&#125;<br>&#123;&#123; temp &#125;&#125;<br>&#123;% endwith %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在with块之外: &#123;&#123; temp &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>输出：</p><p>赋值的使用</p><p>43</p><p>在with块之外</p></blockquote><h3 id="转义显示">转义显示</h3><p>法一：视为字符串</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;&#123; &#x27;&#123;&#123;&#125;&#125; &#123;% %&#125;&#x27; &#125;&#125;<br></code></pre></td></tr></table></figure><p>法二：使用 raw 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% raw %&#125;<br>&#123;% for key, value in data.items %&#125;<br>&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<br>&#123;% endfor %&#125;<br>&#123;% endraw %&#125;<br></code></pre></td></tr></table></figure><h2 id="过滤器">过滤器</h2><p>为了方便对变量进行处理，Jinja2 提供了一些过滤器，语法形式如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">变量</span>|过滤器 &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>左侧是变量，右侧是过滤器名。用管道符号 <code>|</code> 分割</p><blockquote><p>我觉得过滤器类似 Python 的函数，可以用自带的一些函数，也可以自定义。(因为Jinja2不支持py语法)</p></blockquote><ul><li>可以链式调用：<code>&#123;&#123; name|striptags|title &#125;&#125;</code></li><li>可以用圆括号传递可选参数 <code>&#123;&#123; list|join(',') &#125;&#125;</code></li></ul><p>栗子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>不使用过滤器：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; welcome &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>使用过滤器：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; welcome|upper &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>标签，使用过滤器：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    &#123;% filter upper %&#125;<br>    &#123;&#123; welcome &#125;&#125;<br>    &#123;% endfilter %&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>输出：</p><p>不使用过滤器：</p><p>hello, world</p><p>使用过滤器：</p><p>HELLO, WORLD</p><p>标签，使用过滤器：</p><p>HELLO, WORLD</p></blockquote><h3 id="内置的过滤器">内置的过滤器</h3><ul><li><p>求绝对值：<code>&#123;&#123; value|labs &#125;&#125;</code></p></li><li><p>默认值显示：<code>&#123;&#123; value|default('默认值') &#125;&#125;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>默认值default过滤器的使用<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>var: &#123;&#123; var|default(&#x27;var默认值没有&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>name: &#123;&#123; name|default(&#x27;name默认值没有&#x27;, True) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>输出：</p><p>var: hello</p><p>name: name默认值没有</p></blockquote></li><li><p>html 转义：<code>&#123;&#123; value|escape &#125;&#125;</code> 或 <code>&#123;&#123; value|e &#125;&#125;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>html转义 过滤器的使用<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>&#123;% autoescape false%&#125;   <span class="hljs-comment">&lt;!-- 默认是true --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; html_value&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; html_value|e&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% endautoescape %&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="自定义过滤器">自定义过滤器</h3><p>法一：使用装饰器注册（推荐这种）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.template_filter(<span class="hljs-params"><span class="hljs-string">&#x27;reverse&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_filter</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> s[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>法二：调用函数注册</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reversr_filter</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-keyword">return</span> s[::-<span class="hljs-number">1</span>]<br>app.jinja_env.filters[<span class="hljs-string">&#x27;reverse&#x27;</span>] = reverse_filter<br></code></pre></td></tr></table></figure><p>举个栗子：</p><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/filter&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">use_filter</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 过滤器的使用 &quot;&quot;&quot;</span><br>    phone_number = <span class="hljs-string">&#x27;13312345678&#x27;</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;use_filter.html&#x27;</span>,<br>                           phone_number=phone_number)<br><br><br><span class="hljs-meta">@app.template_filter(<span class="hljs-params"><span class="hljs-string">&#x27;phone_format&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">phone_format</span>(<span class="hljs-params">phone_number</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 电话号码脱敏处理。过滤器的编写&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 13312345678 -&gt; 133****5678</span><br>    <span class="hljs-keyword">return</span> phone_number[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;****&#x27;</span> + phone_number[<span class="hljs-number">7</span>:]<br></code></pre></td></tr></table></figure><p><em>use_filter.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>自定义过滤器的使用<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我的手机号码：&#123;&#123; phone_number|phone_format &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>输出：</p><p>自定义过滤器的使用</p><p>我的手机号码：133****5678</p></blockquote><h2 id="模板全局函数">模板全局函数</h2><p>全局函数可在模板中直接使用</p><ul><li><code>range([start], stop, [, step])</code></li><li><code>cycler(*item)</code> （可用于css类名的循环）</li><li><code>joiner(sep=',')</code> （可用于字符串的拼接）</li></ul><p>栗子：</p><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/gf&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">global_func</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 模板全局函数的使用 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;global_func.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p><em>global_func.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>全局函数的使用<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;style.css&#x27;) &#125;&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.row1</span> &#123;</span><br><span class="css">            <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#f00</span>;</span><br>        &#125;<br><span class="css">        <span class="hljs-selector-class">.row2</span> &#123;</span><br><span class="css">            <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#00f</span>;</span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>range函数的使用<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    &#123;% for i in range(5) %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; i &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    &#123;% endfor %&#125;<br><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>cycler函数的使用<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    &#123;% set class_name = cycler(&#x27;row1&#x27;, &#x27;row2&#x27;) %&#125;<br>    &#123;% for i in range(8) %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&#123;&#123; class_name.next() &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; i &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    &#123;% endfor %&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>style.css</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: lightblue;<br>&#125;<br><span class="hljs-selector-tag">h3</span> &#123;<br>    <span class="hljs-attribute">color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/全局函数的使用.png"style="width:50%;"/></center><p><strong>url_for()</strong></p><p>URL 解析函数（如：静态文件地址解析、链接跳转地址解析）</p><p>栗子：</p><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/gf&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">global_func</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 模板全局函数的使用 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;global_func.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p><em>global_func.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>url_for 的使用<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;index&#x27;) &#125;&#125;&quot;</span>&gt;</span>回到首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>点击 ”回到首页”，就会跳转到 <code>url_for('index')</code> 解析的 <code>/</code> 的地址。</p></blockquote><p>小练习：实现下图</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/小练习.png"style="width:20%;"/></center><ol type="1"><li>颜色交替：<code>&#123;% set class_name = cycler('row1', 'row2') %&#125;</code></li><li>算闰年</li><li>序列自增：<code>loop.index</code></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页-慕课网<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.row1</span> &#123;</span><br>            color: red;<br>        &#125;<br><span class="css">        <span class="hljs-selector-class">.row2</span> &#123;</span><br>            color: green;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    &#123;% set class_name = cycler(&#x27;row1&#x27;, &#x27;row2&#x27;) %&#125;<br>    &#123;% for year in range(2010, 2021) %&#125;<br>        &#123;% if ((year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)) %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&#123;&#123; class_name.next() &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; loop.index &#125;&#125;. &#123;&#123; year &#125;&#125; 是闰年<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        &#123;% else %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&#123;&#123; class_name.next() &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; loop.index &#125;&#125;. &#123;&#123; year &#125;&#125; 不是闰年<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        &#123;% endif %&#125;<br>    &#123;% endfor %&#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="模板中的宏">模板中的宏</h2><p>宏：把常用功能抽取出来，实现可重用。简单理解为 宏 <span class="math inline">\(\approx\)</span> 函数。宏可以写在单独的 html 文件中。</p><p><strong>定义宏</strong>：（像书写函数一样定义宏）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% macro %&#125;<br>...<br>&#123;% endmacro%&#125;<br></code></pre></td></tr></table></figure><p><strong>使用宏</strong>：（像调用函数一样调用）</p><p>栗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; input(&#x27;username&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>文件中的宏的使用</strong></p><ol type="1"><li><p>将前面定义的宏抽出来保存为 <em>forms.html</em></p></li><li><p>导入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% from &#x27;forms.html&#x27; import input %&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">forms.input</span>(<span class="hljs-name">&#x27;username&#x27;</span>) &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>栗子：</p></li></ol><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/macro&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">marco</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 模板中的宏 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;marco.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p><em>marco.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% macro input(name, type=&#x27;text&#x27;, value=&#x27;&#x27;) %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-ctrl&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&#123;&#123; type &#125;&#125;&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&#123;&#123; name &#125;&#125;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;&#123; value &#125;&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&#123;% endmacro %&#125;<br><br>&#123;#  用户名 username  #&#125;<br>&#123;&#123; input(&#x27;username&#x27;, value=&#x27;admin&#x27;) &#125;&#125;<br>&#123;#  密码 password  #&#125;<br>&#123;&#123; input(&#x27;password&#x27;, type=&#x27;password&#x27;) &#125;&#125;<br>&#123;#  年龄 age  #&#125;<br>&#123;&#123; input(&#x27;age&#x27;, type=&#x27;number&#x27;) &#125;&#125;<br></code></pre></td></tr></table></figure><p>或者：</p><p><em>marco.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% from &#x27;forms.html&#x27; import input %&#125;<br><br>&#123;#  用户名 username  #&#125;<br>&#123;&#123; input(&#x27;username&#x27;, value=&#x27;admin&#x27;) &#125;&#125;<br>&#123;#  密码 password  #&#125;<br>&#123;&#123; input(&#x27;password&#x27;, type=&#x27;password&#x27;) &#125;&#125;<br>&#123;#  年龄 age  #&#125;<br>&#123;&#123; input(&#x27;age&#x27;, type=&#x27;number&#x27;) &#125;&#125;<br></code></pre></td></tr></table></figure><p><em>forms.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;# 定义宏 #&#125;<br>&#123;% macro input(name, type=&#x27;text&#x27;, value=&#x27;&#x27;) %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-ctrl&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&#123;&#123; type &#125;&#125;&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&#123;&#123; name &#125;&#125;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;&#123; value &#125;&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&#123;% endmacro %&#125;<br></code></pre></td></tr></table></figure><h2 id="模板的继承">模板的继承</h2><ol type="1"><li><p>将可变的部分圈出来（<em>base.html</em>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% block content%&#125;<br><span class="hljs-comment">&lt;!-- 内容区域 --&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure></li><li><p>继承父模板</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &quot;base.html&quot; %&#125;<br></code></pre></td></tr></table></figure></li><li><p>填充新的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &quot;base.html&quot; %&#125;<br>&#123;% block content %&#125;<br><span class="hljs-comment">&lt;!-- 新的内容 --&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure></li><li><p>复用父模板的内容（可选）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &quot;base.html&quot; %&#125;<br>&#123;% block header %&#125;<br>&#123;&#123; super() &#125;&#125;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我感觉就是把共用的部分抽出来，放在一个比如 <em>base.html</em> 里，其他子html继承，然后写自己的部分。</p></blockquote></li></ol><p>栗子:</p><p><em>base.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页-慕课网<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.container</span> &#123;</span><br>            width: 600px;<br>            height: 300px;<br>            margin: 0 auto;<br>        &#125;<br><br>        header &#123;<br>            background: aqua;<br>        &#125;<br><br>        article &#123;<br>            background: azure;<br>            height: 3q00px;<br>        &#125;<br><span class="css">        <span class="hljs-selector-tag">article</span> <span class="hljs-selector-class">.left</span> &#123;</span><br>            background-color: blue;<br>            width: 60%;<br>            float: left;<br>        &#125;<br><span class="css">        <span class="hljs-selector-tag">article</span> <span class="hljs-selector-class">.right</span> &#123;</span><br>            background-color: red;<br>            width: 40%;<br>            float: left;<br>        &#125;<br><br>        footer &#123;<br>            background-color: coral;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>        &#123;% block header %&#125;<br>            页面头部[首页 免费课程 实战课程 职位 专栏]<br>        &#123;% endblock %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>        &#123;% block content %&#125;<br>            课程内容<br>        &#123;% endblock %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>        页面底部<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>index.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends&#x27;base.html&#x27; %&#125;<br>&#123;% block header %&#125;<br>    首页的顶部导航<br>&#123;% endblock %&#125;<br><br>&#123;% block content %&#125;<br>    &#123;&#123; super() &#125;&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>首页课程内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/首页index.png"style="width:70%;"/></center><p><em>article.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block content %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>        左侧内容区域--手记<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>        右侧内容区域-- 手记<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/文章article.png"style="width:70%;"/></center><h2 id="模板的包含">模板的包含</h2><ol type="1"><li>将可变的部分拆出来（<em>sidebar.html</em>）</li><li>再将拆出来的部分包进你想放的位置去（<em>index.html</em>）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% include &quot;sidebar.html&quot; %&#125;<br></code></pre></td></tr></table></figure><p>栗子：</p><p><em>sidebar.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>课程推荐<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>问题：&#123;&#123; question &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>article.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block content %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>        左侧内容区域--手记<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>        右侧内容区域-- 手记<br>        &#123;% include &#x27;sidebar.html&#x27; %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/模板的include.png"style="width:70%;"/></center><h2 id="模板的复用">模板的复用</h2><p>栗子：</p><p><em>wenda.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block title_txt %&#125;<br>    牛牛牛<br>&#123;% endblock %&#125;<br><br>&#123;% block content %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    页面头部[用户登录信息]<br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>        左侧内容区域--问答<br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; self.title_txt() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>        右侧内容区域--问答<br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>问题：&#123;&#123; question &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; self.title_txt() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/模板代码复用 wenda.png"style="width:70%;"/></center><h2 id="消息闪现">消息闪现</h2><ol type="1"><li><p>先在<strong>视图</strong>中产生一个消息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">flash(msg_content, msg_type)<br></code></pre></td></tr></table></figure><ul><li><code>msg_content</code> ：消息内容</li><li><code>msg_type</code> ：消息类型</li></ul></li><li><p>在<strong>模板</strong>中展示消息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">get_flashed_messages(category_filter=[&#x27;error&#x27;])<br></code></pre></td></tr></table></figure><ul><li><code>with_categories=true</code>： 代表我们启用消息分类，之后针对消息类型，可以进行相关的过滤操作</li><li><code>category_filter</code> ：为message添加一个过滤器。对应上面 <code>flash</code> 方法的 <code>msg_type</code></li></ul></li></ol><p>举个栗子：用户登录之后，跳转到个人中心，在个人中心页面，展示一个提示：登录成功</p><p><em>app.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template, flash, redirect, request<br><br>app = Flask(__name__)<br><span class="hljs-comment"># session的安全机制，使用flash时需要设置该随机串</span><br>app.secret_key = <span class="hljs-string">&#x27;secret_keyabcdsuibiangeide&#x27;</span><br><br><span class="hljs-comment"># 功能：用户登录之后，跳转到个人中心，在个人中心页面，展示一个提示：登录成功</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;  用户登录 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        print(<span class="hljs-string">&#x27;处理了登陆的逻辑&#x27;</span>)<br>        flash(<span class="hljs-string">&#x27;登陆成功&#x27;</span>, <span class="hljs-string">&#x27;success&#x27;</span>)<br>        flash(<span class="hljs-string">&#x27;欢迎回来~&#x27;</span>, <span class="hljs-string">&#x27;success&#x27;</span>)<br>        flash(<span class="hljs-string">&#x27;错误提示&#x27;</span>, <span class="hljs-string">&#x27;error&#x27;</span>)<br>        <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;/mine&#x27;</span>)<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;login.html&#x27;</span>)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/mine&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mine</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;  个人中心 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;mine.html&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p><em>login.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>用户登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>用户登录<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&#123;&#123; url_for(&#x27;login&#x27;) &#125;&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>mine.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>个人中心<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.success</span> &#123;</span><br><span class="css">            <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#0f0</span>;</span><br>        &#125;<br><span class="css">        <span class="hljs-selector-class">.error</span> &#123;</span><br><span class="css">            <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#f00</span>;</span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>个人中心<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    &#123;% for category, message in get_flashed_messages(with_categories=true, category_filter=[&#x27;error&#x27;]) %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&#123;&#123; category &#125;&#125;&quot;</span>&gt;</span><br>        &#123;&#123; category &#125;&#125;-&#123;&#123; message &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    &#123;% endfor %&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/消息闪现成功.png"style="width:25%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/消息闪现失败.png"style="width:25%;"/></center>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask入门之Hello Flask</title>
    <link href="/2021/03/19/Flask%E5%85%A5%E9%97%A8%E4%B9%8BHello%20Flask/"/>
    <url>/2021/03/19/Flask%E5%85%A5%E9%97%A8%E4%B9%8BHello%20Flask/</url>
    
    <content type="html"><![CDATA[<h1 id="flask-入门之hello-flask">Flask 入门之Hello Flask</h1><p>追溯到最初，Flask 诞生于 Armin Ronacher 在 2010 年愚人节开的一个玩笑。后来，它逐渐发展成为一个成熟的 Python Web 框架，越来越受到开发者的喜爱。目前它在 GitHub 上是 Star 数量最多的 Python Web 框架，没有之一。</p><p>Flask 是典型的微框架，作为 Web 框架来说，它仅保留了核心功能：<strong>请求响应处理</strong>和<strong>模板渲染</strong>。这两类功能分别由 Werkzeug（WSGI 工具库）完成和 Jinja（模板渲染库）完成，因为 Flask 包装了这两个依赖，我们暂时不用深入了解它们。</p><h2 id="第一个简单的主页">第一个简单的主页</h2><p><em>app.py：程序主页</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask  <span class="hljs-comment"># 从 flask 包导入 Flask 类</span><br>app = Flask(__name__)  <span class="hljs-comment"># 通过实例化这个类，创建一个程序对象 app</span><br><br><span class="hljs-comment"># 使用 app.route() 装饰器来为这个函数绑定对应的 URL，当用户在浏览器访问这个 URL 的时候，就会触发这个函数，获取返回值，并把返回值显示到浏览器窗口</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)  </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Welcome to My Watchlist!&#x27;</span><br></code></pre></td></tr></table></figure><p>按照惯例，我们把程序保存为 app.py，确保当前目录是项目的根目录，然后在命令行窗口执行 <code>flask run</code> 命令启动程序（按下 Control + C 可以退出）：</p><p>现在打开浏览器，访问 <a href="http://localhost:8001/">http://localhost:8001</a> 即可访问我们的程序主页，并看到我们在程序里返回的问候语，如下图所示：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210319224232086.png"style="width:70%;"/></center><h3 id="解剖时间">解剖时间</h3><p>下面我们来分解这个 Flask 程序，了解它的基本构成。</p><p>首先我们从 <code>flask</code> 包导入 <code>Flask</code> 类，通过实例化这个类，创建一个程序对象 <code>app</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br></code></pre></td></tr></table></figure><p>接下来，我们要注册一个处理函数，这个函数是处理某个请求的处理函数，Flask 官方把它叫做<strong>视图函数（view funciton）</strong>，你可以理解为“<strong>请求处理函数</strong>”。</p><p>所谓的“注册”，就是给这个函数戴上一个装饰器帽子。我们使用 <code>app.route()</code> 装饰器来为这个函数绑定对应的 URL，当用户在浏览器访问这个 URL 的时候，就会触发这个函数，获取返回值，并把返回值显示到浏览器窗口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Welcome to My Watchlist!&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>提示</strong> 为了便于理解，你可以把 Web 程序看作是一堆这样的视图函数的集合：编写不同的函数处理对应 URL 的请求。</p></blockquote><p>填入 <code>app.route()</code> 装饰器的第一个参数是 URL 规则字符串，这里的 <code>/</code> 指的是根地址。</p><p>我们只需要写出相对地址，主机地址、端口号等都不需要写出。所以说，这里的 <code>/</code> 对应的是主机名后面的路径部分，完整 URL 就是 http://localhost:8001/。如果我们这里定义的 URL 规则是 <code>/hello</code>，那么完整 URL 就是 http://localhost:8001/hello。</p><p>整个请求的处理过程如下所示：</p><ol type="1"><li>当用户在浏览器地址栏访问这个地址，在这里即 <a href="http://localhost:8001/" class="uri">http://localhost:8001/</a></li><li>服务器解析请求，发现请求 URL 匹配的 URL 规则是 <code>/</code>，因此调用对应的处理函数 <code>hello()</code></li><li>获取 <code>hello()</code> 函数的返回值，处理后返回给客户端（浏览器）</li><li>浏览器接受响应，将其显示在窗口上</li></ol><h3 id="url-配置及报文显示">URL 配置及报文显示</h3><h4 id="url-及-http-基础知识">URL 及 HTTP 基础知识</h4><ul><li>什么是 URL？<ul><li>Uniformed Resource Locator，统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁表示，是互联网上标准资源的地址</li><li>互联网上的每个文件都有一个唯一的 URL</li></ul></li><li>常见的网络协议有哪些？<ul><li>http：超文本传输协议</li><li>https：用安全套接字层传送的超文本传输协议</li><li>ftp：文件传输协议</li></ul></li><li>常见的 HTTP 请求方式有哪些？有什么区别？<ul><li>GET 请求：<ul><li>可以用浏览器直接访问</li><li>请求可以携带参数，但是有长度限制</li><li>请求参数直接放在 URL 后面</li></ul></li><li>POST 请求<ul><li>不能使用浏览器直接访问</li><li>对请求参数的长度没有限制</li><li>可以用来上传文件等需求</li></ul></li></ul></li><li>不同的 HTTP 响应状态码有什么含义？<ul><li>2xx：请求成功</li><li>3xx：重定向</li><li>4xx：请求错误</li><li>5xx：服务器错误</li></ul></li></ul><p>详细的网络相关知识可以看这篇文章<a href="https://stuxiaozhang.github.io/2020/09/30/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络课堂笔记总结</a>。</p><h4 id="路由配置">路由配置</h4><h5 id="使用装饰器">1. 使用装饰器</h5><p><strong><code>@app.route(url_name, methods)</code></strong></p><ul><li>url：匹配的 URL 地址</li><li>methods：所支持的请求方式（[‘GET’, ‘POST’]）</li></ul><p>栗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br></code></pre></td></tr></table></figure><h5 id="使用-api-配置">2. 使用 API 配置</h5><p><strong><code>@app.add_url_rule(url, url_name, view_name)</code></strong></p><ul><li>url：匹配的 URL 地址</li><li>url_name：给 URL 的命名</li><li>view_name：视图函数</li></ul><p>栗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">app.add_url_rule(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-string">&#x27;home&#x27;</span>, hello)  <span class="hljs-comment"># url, url名字, 视图函数</span><br></code></pre></td></tr></table></figure><h3 id="实验时间">实验时间</h3><h4 id="修改视图函数返回值">修改视图函数返回值</h4><p>首先，可以自由修改视图函数的返回值，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">u&#x27;欢迎来到我的 Watchlist！&#x27;</span><br></code></pre></td></tr></table></figure><p>返回值作为响应的主体，默认会被浏览器作为 HTML 格式解析，所以我们可以添加一个 HTML 元素标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello Totoro!&lt;/h1&gt;&lt;img src=&quot;http://helloflask.com/totoro.gif&quot;&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>保存修改后，只需要在浏览器里刷新页面，就会看到页面上的内容也会随之变化。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/Hello Totoro.png"style="width:60%;"/></center><h4 id="修改-url-匹配规则">修改 URL 匹配规则</h4><h5 id="匹配整个文字">1. 匹配整个文字</h5><p><strong><code>@app.route('/hello')</code></strong></p><p>可以自由修改传入 <code>app.route</code> 装饰器里的 URL 规则字符串，但要注意以斜线 <code>/</code> 作为开头。访问地址也要对应改变。比如下面的视图函数对应的访问地址就应该是：http://localhost:8001/home</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/home&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Welcome to My Watchlist!&#x27;</span><br></code></pre></td></tr></table></figure><p>一个视图函数也可以绑定多个 URL，这通过附加多个装饰器实现，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/index&#x27;</span></span>)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/home&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Welcome to My Watchlist!&#x27;</span><br></code></pre></td></tr></table></figure><p>现在无论是访问 http://localhost:8001/、http://localhost:8001/home 还是 http://localhost:8001/index 都可以看到返回值。</p><h5 id="传递参数">2. 传递参数</h5><p><strong><code>@app.route('/user/&lt;username&gt;')</code></strong></p><p>在前面，我们之所以把传入 <code>app.route</code> 装饰器的参数称为 URL 规则，是因为我们也可以在 URL 里定义变量部分。比如下面这个视图函数会处理所有类似 <code>/user/&lt;username&gt;</code> 的请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&lt;username&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_page</span>(<span class="hljs-params">username</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;User page&#x27;</span><br></code></pre></td></tr></table></figure><p>不论你访问 http://localhost:8001/user/greyli，还是 http://localhost:8001/user/peter，抑或是 http://localhost:8001/user/，都会触发这个函数。通过下面的方式，我们也可以在视图函数里获取到这个变量值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> escape<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&lt;username&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_page</span>(<span class="hljs-params">username</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;User: %s&#x27;</span> % escape(username)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 用户输入的数据会包含恶意代码，所以不能直接作为响应返回，需要使用 Flask 提供的 escape() 函数对 name 变量进行转义处理，比如把 <code>&lt;</code> 转换成 <code>&amp;lt;</code>。这样在返回响应时浏览器就不会把它们当做代码执行。</p></blockquote><h5 id="指定参数类型">3. 指定参数类型</h5><p><strong><code>@app.route('/post/&lt;int:post_id&gt;')</code></strong></p><p>URL 参数类型：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/URL 参数类型.png"style="width:70%;"/></center><p>对于 URL 变量，Flask 还支持在 URL 规则字符串里对变量设置处理器，对变量进行预处理。比如 <code>/user/&lt;int:number&gt;</code> 会将 URL 中的 number 部分处理成整型，同时这个变量值接收传入数字。</p><h3 id="请求-响应及上下文对象">请求-响应及上下文对象</h3><h4 id="请求-响应">请求-响应</h4><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/请求-响应.png"style="width:80%;"/></center><p>Flask从客户端收到请求时，需让试图函数能访问一些对象，才能处理请求。请求对象是一个很好的例子，它封装了客户端发送的HTTP请求。</p><p>让视图函数能够访问请求对象最直接的方式，是将其作为参数传入视图函数。 缺点：导致应用中每个视图函数都多处一个参数。</p><blockquote><p>除了访问请求对象，如果视图函数在处理请求时还要访问其他对象，就更乱了。</p></blockquote><p>Flask使用上下文临时把某些对象变为全局可访问。</p><p>Flask的两种上下文：应用上下文和请求上下文。</p><ul><li><p>应用上下文</p><ul><li>current_app：当前应用的应用实例（指：FLask实例化的app对象）</li><li>g：处理请求时用作临时存储的对象，每次请求都会重设它。</li></ul></li><li><p>请求上下文</p><ul><li><p>request：请求对象，封装了客户端发出的HTTP请求中的内容。</p></li><li><p>session：用户会话，值为一个字典，存储请求之间(前？)需要”记住“的值</p></li></ul></li></ul><p>Flask 在分派请求之前激活（或推送）应用和请求上下文，请求处理完成后再将其删除。</p><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/index&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    print(app)<br>    print(current_app)  <span class="hljs-comment"># 应用上下文对象</span><br>    print(app == current_app)  <span class="hljs-comment"># True：里面的东西是一样的</span><br>    print(app <span class="hljs-keyword">is</span> current_app)  <span class="hljs-comment"># False：但是不是同一个引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;index&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test/req&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_request</span>():</span><br>    get_args = request.args<br>    print(get_args)<br>    <span class="hljs-comment"># 页码一定是正整数</span><br>    page = request.args.get(<span class="hljs-string">&#x27;page&#x27;</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 默认第1页</span><br>    print(page)<br><br>    <span class="hljs-comment"># 服务器所在的主机地址</span><br>    headers = request.headers<br>    print(headers)<br>    print(<span class="hljs-string">&#x27;服务器所在的主机地址&#x27;</span>, headers.get(<span class="hljs-string">&#x27;host&#x27;</span>))<br><br>    <span class="hljs-comment"># 获取ip地址</span><br>    ip = request.remote_addr<br>    print(<span class="hljs-string">&#x27;远程ip地址&#x27;</span>, ip)<br><br>    <span class="hljs-comment"># 获取 user-agent</span><br>    user_agent = request.headers.get(<span class="hljs-string">&#x27;User-Agent&#x27;</span>, <span class="hljs-literal">None</span>)<br>    print(<span class="hljs-string">&#x27;User_Agent&#x27;</span>, user_agent)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;request success&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="请求分派">请求分派</h4><p>URL 映射是 URL 和视图函数之间的对应关系。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/请求分派.png"style="width:90%;"/></center><h4 id="请求钩子">请求钩子</h4><p>在请求开始时，可能需要创建数据库连接或者验证发起请求的用户身份。为避免在每个视图函数中都重复编写代码，Flask 提供了注册通用函数功能，注册的函数可在请求被分派视图函数之前或之后调用。</p><p>请求钩子通过装饰器实现。Flask支持以下4种钩子：</p><ul><li><p><strong><code>@app.before_first_request</code></strong></p><p>注册一个函数，只在处理第一个请求之前运行。</p></li><li><p><strong><code>@app.before_request</code></strong></p><p>注册一个函数，在每次请求之前运行。</p></li><li><p><strong><code>@app.after_request</code></strong></p><p>注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。</p></li><li><p><strong><code>@app.teardown_request</code></strong></p><p>注册一个函数，即使有未处理的异常抛出，在每次请求之后运行。</p></li></ul><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.before_first_request</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">first_request</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 服务器启动后第一个请求到达 &quot;&quot;&quot;</span><br>    print(<span class="hljs-string">&#x27;first_request&#x27;</span>)<br><br><br><span class="hljs-meta">@app.before_request</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">per_request</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 每一个请求到达前 &quot;&quot;&quot;</span><br>    print(<span class="hljs-string">&#x27;before_request&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="cookie-和-session">cookie 和 session</h4><ol type="1"><li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li><li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li><li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</li></ol><p>所以，总结一下： <strong>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</strong> <strong>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</strong></p><p><strong>要处理Session，则必须为 <em>app</em> 实例设置SECRET_KEY 配置随机数生成器（Session ID），再使用session函数进行操作</strong></p><blockquote><p><code>app.config['SECRET_KEY'] = os.urandom(24)</code> #生成随机数种子，用于产生sessionID</p></blockquote><p><strong>要处理Cookie，需要使用 <em>response</em> 对象来往HTTP的响应中写入满足HTTP协议的Cookie要求的信息（key，value，Age有效期）</strong></p><p>session栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;session-func&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">session_func</span>():</span><br>    session[<span class="hljs-string">&#x27;username&#x27;</span>] = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>    session[<span class="hljs-string">&#x27;nickname&#x27;</span>] = <span class="hljs-string">&#x27;zhang&#x27;</span><br>    session[<span class="hljs-string">&#x27;role&#x27;</span>] = <span class="hljs-string">&#x27;editor&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span><br>    <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/sc/read&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scread</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;你当前的昵称为：%s&#x27;</span> % session.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>cookie栗子：</p><p>利用自定义相应的方式来往浏览器设置cookie</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/cookie&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cookie</span>():</span><br>    response = make_response(<span class="hljs-string">&quot;这是设置cookie的操作&quot;</span>)  <span class="hljs-comment"># 构建一个响应对象</span><br>    response.set_cookie(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;xiaozhang&#x27;</span>, max_age=<span class="hljs-number">60</span>)<br>    response.set_cookie(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-string">&#x27;1234&#x27;</span>, max_age=<span class="hljs-number">60</span>)<br>    <span class="hljs-keyword">return</span> response<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/sc/read&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scread</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;你当前的昵称为：%s&#x27;</span> % request.cookies.get(<span class="hljs-string">&#x27;username&#x27;</span>)  <span class="hljs-comment"># cookie从请求中来？</span><br><br></code></pre></td></tr></table></figure><p>==<strong>cookie从请求中来？</strong>==</p><h4 id="请求报文">请求报文</h4><p>Flask 通过上下文变量 request 对外开放请求对象，它包含客户端发送的 HTTP 请求的全部信息。</p><p>一些请求报文常用参数：</p><ul><li>method：请求的类型（GET/POST等）</li><li><strong>form：POST 请求的数据dict</strong></li><li><strong>args：GET 请求数据dict</strong></li><li>values：POST 请求和 GET 请求数据集合 dict</li><li>files：上传的文件数据 dict</li><li>cookies：请求中的 cookie dict</li><li>headers：HTTP 请求头</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 请求参数的问题：</span><br><span class="hljs-comment"># 1. URL地址自带的查询参数： http://127.0.0.1:5000/test?username=xz&amp;psd=xz</span><br><span class="hljs-comment"># 2. 通过flask自定义的路由规则和参数：http://127.0.0.1:5000/article/&lt;articleid&gt;  可变的部分用&lt;&gt;表示</span><br><span class="hljs-comment"># 3. POST请求的参数，通过POST正文传输。</span><br><br><span class="hljs-comment"># 查询参数：(GET用request.args)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    username = request.args.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.args.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;用户名为 %s, 密码为 %s&#x27;</span> % (username, password)<br><br><br><span class="hljs-comment"># 路由地址参数，路由地址参数必须同步定义接口函数里面作为该参数的形参</span><br><span class="hljs-comment"># 由于articleid是一个整数，所以可以在定义路由参数时，直接用int进行类型限制</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article/&lt;int:articleid&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">article</span>(<span class="hljs-params">articleid</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;你正在访问编号为： <span class="hljs-subst">&#123;articleid&#125;</span> 的文章&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    username = request.form.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.form.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&#x27;xz&#x27;</span> &amp; password == <span class="hljs-string">&#x27;xz&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success2&#x27;</span><span class="hljs-comment"># 请求参数的问题：</span><br><span class="hljs-comment"># 1. URL地址自带的查询参数： http://127.0.0.1:5000/test?username=xz&amp;psd=xz</span><br><span class="hljs-comment"># 2. 通过flask自定义的路由规则和参数：http://127.0.0.1:5000/article/&lt;articleid&gt;  可变的部分用&lt;&gt;表示</span><br><span class="hljs-comment"># 3. POST请求的参数，通过POST正文传输。</span><br><br><span class="hljs-comment"># 查询参数：(GET用request.args)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    username = request.args.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.args.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;用户名为 %s, 密码为 %s&#x27;</span> % (username, password)<br><br><br><span class="hljs-comment"># 路由地址参数，路由地址参数必须同步定义接口函数里面作为该参数的形参</span><br><span class="hljs-comment"># 由于articleid是一个整数，所以可以在定义路由参数时，直接用int进行类型限制</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article/&lt;int:articleid&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">article</span>(<span class="hljs-params">articleid</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;你正在访问编号为： <span class="hljs-subst">&#123;articleid&#125;</span> 的文章&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    username = request.form.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.form.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&#x27;xz&#x27;</span> &amp; password == <span class="hljs-string">&#x27;xz&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success2&#x27;</span><span class="hljs-comment"># 请求参数的问题：</span><br><span class="hljs-comment"># 1. URL地址自带的查询参数： http://127.0.0.1:5000/test?username=xz&amp;psd=xz</span><br><span class="hljs-comment"># 2. 通过flask自定义的路由规则和参数：http://127.0.0.1:5000/article/&lt;articleid&gt;  可变的部分用&lt;&gt;表示</span><br><span class="hljs-comment"># 3. POST请求的参数，通过POST正文传输。</span><br><br><span class="hljs-comment"># 查询参数：(GET用request.args)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    username = request.args.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.args.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;用户名为 %s, 密码为 %s&#x27;</span> % (username, password)<br><br><br><span class="hljs-comment"># 路由地址参数，路由地址参数必须同步定义接口函数里面作为该参数的形参</span><br><span class="hljs-comment"># 由于articleid是一个整数，所以可以在定义路由参数时，直接用int进行类型限制</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article/&lt;int:articleid&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">article</span>(<span class="hljs-params">articleid</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;你正在访问编号为： <span class="hljs-subst">&#123;articleid&#125;</span> 的文章&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    username = request.form.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.form.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&#x27;xz&#x27;</span> &amp; password == <span class="hljs-string">&#x27;xz&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success2&#x27;</span><span class="hljs-comment"># 请求参数的问题：</span><br><span class="hljs-comment"># 1. URL地址自带的查询参数： http://127.0.0.1:5000/test?username=xz&amp;psd=xz</span><br><span class="hljs-comment"># 2. 通过flask自定义的路由规则和参数：http://127.0.0.1:5000/article/&lt;articleid&gt;  可变的部分用&lt;&gt;表示</span><br><span class="hljs-comment"># 3. POST请求的参数，通过POST正文传输。</span><br><br><span class="hljs-comment"># 查询参数：(GET用request.args)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    username = request.args.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.args.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;用户名为 %s, 密码为 %s&#x27;</span> % (username, password)<br><br><br><span class="hljs-comment"># 路由地址参数，路由地址参数必须同步定义接口函数里面作为该参数的形参</span><br><span class="hljs-comment"># 由于articleid是一个整数，所以可以在定义路由参数时，直接用int进行类型限制</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article/&lt;int:articleid&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">article</span>(<span class="hljs-params">articleid</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;你正在访问编号为： <span class="hljs-subst">&#123;articleid&#125;</span> 的文章&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    username = request.form.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.form.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&#x27;xz&#x27;</span> &amp; password == <span class="hljs-string">&#x27;xz&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success2&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="响应报文">响应报文</h4><p>Flask 调用视图函数后，会将其返回值作为响应的内容。多数情况下，响应就是一个简单的字符串，作为 HTML 页面回送客户端。</p><p>响应对象最常使用的属性和方法表：</p><table><thead><tr class="header"><th>属性或方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>status_code</td><td>HTTP 状态码</td></tr><tr class="even"><td>headers</td><td>类似字典的对象，包含随机响应发送的所有首部</td></tr><tr class="odd"><td>set_cookie()</td><td>为响应添加一个cookie</td></tr><tr class="even"><td>delete_cookie()</td><td>删除一个cookie</td></tr><tr class="odd"><td>content_length</td><td>响应主体的长度</td></tr><tr class="even"><td>content_type</td><td>响应主体的媒体类型</td></tr><tr class="odd"><td>set_data()</td><td>使用字符串或字节值设定响应</td></tr><tr class="even"><td>get_data()</td><td>获取响应主体</td></tr></tbody></table><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test/resp&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_response</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 测试响应 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;response success&#x27;</span>, <span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;user_id&#x27;</span>: <span class="hljs-string">&#x27;my_user_id&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment">#通过 make_response 构造一个响应对象，和上面是一样的</span><br>    resp = make_response(<span class="hljs-string">&#x27;这是一个响应对象&#x27;</span>, <span class="hljs-number">403</span>, &#123;<br>        <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-string">&#x27;123&#x27;</span><br>    &#125;)<br>    <span class="hljs-comment"># 同上，添加响应头和改变状态码</span><br>    resp.headers[<span class="hljs-string">&#x27;user_id&#x27;</span>] = <span class="hljs-string">&#x27;myid_123&#x27;</span><br>    <span class="hljs-comment"># resp.status_code = 201</span><br><br>    <span class="hljs-comment"># 响应html</span><br>    html = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1 style=&#x27;color:#f00&#x27;&gt;一段文本显示&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span><br>    resp = make_response(html)<br>    <span class="hljs-keyword">return</span> resp<br><br></code></pre></td></tr></table></figure><h5 id="重定向-redirct">重定向 redirct()</h5><p>响应有一个特殊的类型，称为重定向。这种响应无页面文档，只会告诉浏览器一个URL，用以加载新页面。重定向经常在Web表单中使用。</p><p>重定向的状态码通常是302。</p><p>Flask提供了 <code>redirect()</code> 辅助函数，用于生成这种响应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> redirect<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h5 id="处理错误-abort">处理错误 abort()</h5><p>有一种特殊的响应由 <code>abort()</code> 函数生成，用于处理错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;视图函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 处理错误/触发了异常，跳转到指定的页面。不需要return</span><br>    ip_blacklist = [<span class="hljs-string">&#x27;127.0.0.2&#x27;</span>]<br>    ip = request.remote_addr<br>    <br>    <span class="hljs-keyword">if</span> ip <span class="hljs-keyword">in</span> ip_blacklist:<br>        abort(<span class="hljs-number">403</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECharts介绍</title>
    <link href="/2021/03/16/ECharts%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/03/16/ECharts%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/ECharts.png"style="width:100%;"/></center><p>ECharts，一个使用 <strong>JavaScript 实现</strong>的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。</p><h4 id="如何获取">如何获取?</h4><ul><li><p>从官网下载界面选择需要的版本下载，根据开发者功能和体积上的需求，我们提供了不同打包的下载， 如果你在体积上没有要求，可以直接下载完整版本。开发环境建议下载源代码版本，包含了常见的错误 提示和警告。</p></li><li><p>在 ECharts 的 GitHub 上下载最新的 release 版本，解压出来的文件夹里的 dist 目录里可以找到最新版本的 echarts 库。</p></li><li><p>cdn 引入，你可以在 cdnjs，npmcdn 或者国内的 bootcdn 上找到 ECharts 的最新版本。</p></li></ul><h4 id="引入-echarts">引入 ECharts</h4><p>只需要像普通的 JavaScript 库一样用 script 标签引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入 ECharts 文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;echarts4.1.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="绘制图形">绘制图形</h4><p>总结起来有三步：</p><ol type="1"><li><p><strong>初始化echarts实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myChart = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;main&#x27;</span>));<br></code></pre></td></tr></table></figure></li><li><p><strong>指定图表的配置项和数据</strong></p><p>去官网查看你想使用的实例，将其配置复制下来进行修改。</p></li><li><p><strong>使用刚指定的配置项和数据显示图表。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">myChart.setOption(option);<br></code></pre></td></tr></table></figure></li></ol><h4 id="绘制柱状图">绘制柱状图</h4><p>在绘图前需要为 ECharts 准备一个具备高宽的 DOM 容器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 600px;height:400px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后就可以通过 echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    <span class="hljs-comment">// 基于准备好的dom，初始化echarts实例</span><br>    <span class="hljs-keyword">var</span> myChart = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;main&#x27;</span>));<br>    <br><span class="hljs-comment">// 指定图表的配置项和数据</span><br>    <span class="hljs-keyword">var</span> option = &#123;<br>        title: &#123;<br>        text: <span class="hljs-string">&#x27;ECharts 入门示例&#x27;</span><br>    &#125;,<br>        tooltip: &#123;&#125;,<br>        legend: &#123;<br>            data:[<span class="hljs-string">&#x27;销量&#x27;</span>]<br>        &#125;,<br>        xAxis: &#123;<br>            data: [<span class="hljs-string">&quot;衬衫&quot;</span>,<span class="hljs-string">&quot;羊毛衫&quot;</span>,<span class="hljs-string">&quot;雪纺衫&quot;</span>,<span class="hljs-string">&quot;裤子&quot;</span>,<span class="hljs-string">&quot;高跟鞋&quot;</span>,<span class="hljs-string">&quot;袜子&quot;</span>]<br>        &#125;,<br>        yAxis: &#123;&#125;,<br>        <span class="hljs-comment">//series需要根据实际数据进行调整</span><br>        series: [&#123;<br>            name: <span class="hljs-string">&#x27;销量&#x27;</span>,<br>            type: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>            data: [<span class="hljs-number">5</span>, <span class="hljs-number">20</span>, <span class="hljs-number">36</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>]<br>        &#125;]<br>    &#125;;<br>    <br><span class="hljs-comment">// 使用刚指定的配置项和数据显示图表。</span><br>    myChart.setOption(option);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/ECharts入门实例.png"style="width:60;"/></center><h4 id="绘制南丁格尔玫瑰图">绘制南丁格尔玫瑰图</h4><p>下面给出了两种有关南丁格尔玫瑰图的配置：半径模式和面积模式。可以自行选择进行修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js">option = &#123;<br>        title: &#123;<br>            text: <span class="hljs-string">&#x27;南丁格尔玫瑰图&#x27;</span>,<br>            subtext: <span class="hljs-string">&#x27;这是副标题&#x27;</span>,<br>            left: <span class="hljs-string">&#x27;center&#x27;</span><br>        &#125;,<br>        tooltip: &#123;<br>            trigger: <span class="hljs-string">&#x27;item&#x27;</span>,<br>            formatter: <span class="hljs-string">&#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;</span><br>        &#125;,<br>        legend: &#123;<br>            left: <span class="hljs-string">&#x27;center&#x27;</span>,<br>            top: <span class="hljs-string">&#x27;bottom&#x27;</span>,<br>            data: [<span class="hljs-string">&#x27;rose1&#x27;</span>, <span class="hljs-string">&#x27;rose2&#x27;</span>, <span class="hljs-string">&#x27;rose3&#x27;</span>, <span class="hljs-string">&#x27;rose4&#x27;</span>, <span class="hljs-string">&#x27;rose5&#x27;</span>, <span class="hljs-string">&#x27;rose6&#x27;</span>, <span class="hljs-string">&#x27;rose7&#x27;</span>, <span class="hljs-string">&#x27;rose8&#x27;</span>]<br>        &#125;,<br>        toolbox: &#123;<br>            show: <span class="hljs-literal">true</span>,<br>            feature: &#123;<br>                mark: &#123;<span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>&#125;,<br>                dataView: &#123;<span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">readOnly</span>: <span class="hljs-literal">false</span>&#125;,<br>                restore: &#123;<span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>&#125;,<br>                saveAsImage: &#123;<span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>&#125;<br>            &#125;<br>        &#125;,<br>      series: [<br>          &#123;<br>              name: <span class="hljs-string">&#x27;半径模式&#x27;</span>,<br>              type: <span class="hljs-string">&#x27;pie&#x27;</span>,<br>              radius: [<span class="hljs-number">20</span>, <span class="hljs-number">140</span>],<br>              center: [<span class="hljs-string">&#x27;25%&#x27;</span>, <span class="hljs-string">&#x27;50%&#x27;</span>],<br>              roseType: <span class="hljs-string">&#x27;radius&#x27;</span>,<br>              itemStyle: &#123;<br>                  borderRadius: <span class="hljs-number">5</span><br>              &#125;,<br>              label: &#123;<br>                  show: <span class="hljs-literal">false</span><br>              &#125;,<br>              emphasis: &#123;<br>                  label: &#123;<br>                      show: <span class="hljs-literal">true</span><br>                  &#125;<br>              &#125;,<br>              data: [<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">40</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 1&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">33</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 2&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">28</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 3&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">22</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 4&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 5&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 6&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 7&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 8&#x27;</span>&#125;<br>              ]<br>          &#125;,<br>          &#123;<br>              name: <span class="hljs-string">&#x27;面积模式&#x27;</span>,<br>              type: <span class="hljs-string">&#x27;pie&#x27;</span>,<br>              radius: [<span class="hljs-number">20</span>, <span class="hljs-number">140</span>],<br>              center: [<span class="hljs-string">&#x27;75%&#x27;</span>, <span class="hljs-string">&#x27;50%&#x27;</span>],<br>              roseType: <span class="hljs-string">&#x27;area&#x27;</span>,<br>              itemStyle: &#123;<br>                  borderRadius: <span class="hljs-number">5</span><br>              &#125;,<br>              data: [<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 1&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">28</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 2&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">26</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 3&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">24</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 4&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">22</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 5&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 6&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 7&#x27;</span>&#125;,<br>                  &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose 8&#x27;</span>&#125;<br>              ]<br>          &#125;<br>      ]<br>  &#125;;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/南丁格尔玫瑰图.png"style="width:60;"/></center>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>ECharts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BootStrap入门</title>
    <link href="/2021/03/11/BootStrap%E5%85%A5%E9%97%A8/"/>
    <url>/2021/03/11/BootStrap%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="bootstrap-入门">BootStrap 入门</h1><p>Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。由Twitter 的设计师开发， 是一个CSS/HTML框架。Bootstrap提供了优雅的HTML和CSS规范，由动态CSS语言Less写成。</p><p>Bootstrap 让你的页面更美观，编写更快捷，更偏向于 CSS。就像 jQuery 于 JavaScript</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Bootstrap 101 Template<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jslearn/jquery/jquery-3.4.1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210331164028759.png" alt="image-20210331164028759" /><figcaption>image-20210331164028759</figcaption></figure><p>如下图：</p><figure><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210331164221220.png" alt="image-20210331164221220" /><figcaption>image-20210331164221220</figcaption></figure><figure><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210331164238412.png" alt="image-20210331164238412" /><figcaption>image-20210331164238412</figcaption></figure><figure><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210331164253331.png" alt="image-20210331164253331" /><figcaption>image-20210331164253331</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>BootStrap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6入门</title>
    <link href="/2021/03/06/ES6%E5%85%A5%E9%97%A8/"/>
    <url>/2021/03/06/ES6%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="es6-入门">ES6 入门</h1><h2 id="es6-介绍">ES6 介绍</h2><p>ECMAScript 6（简称ES6），又称 ECMAScript2015（ES2015）.2015年6月正式发布，是 JavaScript 语言的下一代标准。</p><p>特点：</p><ul><li>更严谨的语法，更高效的编码</li><li><p>更新的特性，更多的功能</p></li><li>主流前端框架（Vue/React/Angular等）、大肠都在用 ES6+</li><li><p>兼容性解决方案成熟（Babel）</p></li></ul><p>尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/js三部分.png"style="width:50%;"/></center><ul><li><p><strong>JavaScript 的核心 ECMAScript 描述了该语言的语法和基本对象；</strong></p></li><li><p><strong>DOM 描述了处理网页内容的方法和接口；</strong></p></li></ul><p><strong>BOM 描述了与浏览器进行交互的方法和接口。</strong></p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210313091902005.png"style="width:60%;"/></center><h2 id="变量">变量</h2><p>声明变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="let-的三大特性">let 的三大特性</h3><h4 id="let不存在变量提升必须要先声明再使用">1. let不存在变量提升，必须要先声明，再使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>变量提升：js中的变量和函数在编译过程中是会优先被提升至当前作用域的顶部。</p><p>所以相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a<br><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span><br>a = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>let不存在变量提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// let</span><br><span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">// 报错 ReferenceError</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><blockquote><p>初学let，没有深入了解，详情应该学习这篇<a href="https://www.jianshu.com/p/0f49c88cf169">有关let的文章</a>。</p></blockquote><h4 id="不能重复声明">2. 不能重复声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> b = <span class="hljs-number">100</span>; <br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;hello&#x27;</span>  <span class="hljs-comment">// 报错 SyntaxError</span><br></code></pre></td></tr></table></figure><h4 id="块级作用域变量只在代码块内有效">3. 块级作用域，变量只在代码块内有效</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// var</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">var</span> n = <span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(n);<br>&#125;<br>func();  <span class="hljs-comment">// 5</span><br><br><span class="hljs-comment">// let</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">let</span> n = <span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(n);<br>&#125;<br>func2();  <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><h2 id="常量">常量</h2><p><strong>常量</strong>：一旦声明，常量的值就不能改变</p><p>声明常量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PAGE_SIZE = <span class="hljs-number">100</span><br><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.1415926</span><br></code></pre></td></tr></table></figure><h3 id="const-的三大特征">const 的三大特征</h3><h4 id="声明必须赋值必须初始化">1. 声明必须赋值（必须初始化）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> NAME;  <span class="hljs-comment">// 报错 SyntaxError</span><br>NAME = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><h4 id="常量是只读的不能重新赋值">2. 常量是只读的，不能重新赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.1415926</span><br>PI = <span class="hljs-string">&#x27;ES6&#x27;</span>  <span class="hljs-comment">// 报错 TypeError</span><br></code></pre></td></tr></table></figure><h4 id="块级作用域只在代码块内有效">3. 块级作用域，只在代码块内有效</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.1415926</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(PI)  <span class="hljs-comment">// 报错 ReferenceError</span><br></code></pre></td></tr></table></figure><h2 id="解构赋值">解构赋值</h2><p><strong>解构赋值</strong>语法是一种 Javascript 表达式。通过<strong>解构赋值,</strong> 可以将属性/值从对象/数组中取出,赋值给其他变量。</p><h3 id="数组的解构赋值">1. 数组的解构赋值</h3><ul><li>按照顺序将值赋值给对应的变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> [a1, a2, a3] = a;<br><span class="hljs-built_in">console</span>.log(a1);  <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(a2);  <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(a3);  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ul><li><code>...</code> 表示结构运算符，将剩余的内容赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [b1, ...b] = a;<br><span class="hljs-built_in">console</span>.log(b1);  <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(b);  <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure><ul><li>解构赋值失败，变量值为undefined</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [e, f] = [<span class="hljs-number">2</span>];<br><span class="hljs-built_in">console</span>.log(e);  <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(f);  <span class="hljs-comment">// f</span><br></code></pre></td></tr></table></figure><ul><li>防止解构失败，可以给变量默认值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [g, h = <span class="hljs-number">100</span>] = [<span class="hljs-number">2</span>];<br><span class="hljs-built_in">console</span>.log(g);  <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(h);  <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><p>小练习：下列代码运行结果？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> [a, b=<span class="hljs-string">&quot;b, c, d] = arr;</span><br><span class="hljs-string">console.log(b)  </span><br></code></pre></td></tr></table></figure><blockquote><p>在只有数组中为undefined的时候，才可以取默认值。</p><p>答：2。</p></blockquote><h3 id="对象的解构赋值">2. 对象的解构赋值</h3><ul><li>按照顺序将值赋值给对应的变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;foo, bar&#125; = &#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;foo_value&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bar_value&#x27;</span>&#125;<br><span class="hljs-built_in">console</span>.log(foo)  <span class="hljs-comment">// foo_value</span><br><span class="hljs-built_in">console</span>.log(bar)  <span class="hljs-comment">// bar_value</span><br></code></pre></td></tr></table></figure><blockquote><p>在对象的解构赋值中，与顺序无关</p></blockquote><ul><li>可以解构对象中的常量、方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.PI)  <span class="hljs-comment">// 3.1415936</span><br><span class="hljs-keyword">let</span> &#123;PI, sin&#125; = <span class="hljs-built_in">Math</span><br><span class="hljs-built_in">console</span>.log(PI)  <span class="hljs-comment">// 3.1415936</span><br><span class="hljs-built_in">console</span>.log(sin(PI/<span class="hljs-number">2</span>))  <span class="hljs-comment">// sin(90°)=1</span><br></code></pre></td></tr></table></figure><ul><li>解构赋值失败，变量值为undefined，可设置默认值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;x, y = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-built_in">console</span>.log(x)  <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(y)  <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><ul><li>重新制定变量名称</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">color</span>: sky&#125; = &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>&#125;<br><span class="hljs-built_in">console</span>.log(sky)  <span class="hljs-comment">// blue</span><br></code></pre></td></tr></table></figure><p>对象的解构赋值的内部机制是先找到同名属性，然后再赋给对应的变量。</p><p>小练习：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">foo</span>:baz&#125; = &#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>:<span class="hljs-string">&#x27;bbb&#x27;</span>&#125;;<br>-----哪个能输出------<br><span class="hljs-built_in">console</span>.log(foo);  <span class="hljs-comment">// ReferenceError: foo is not defined</span><br><span class="hljs-built_in">console</span>.log(baz);<br><span class="hljs-built_in">console</span>.log(bar);  <span class="hljs-comment">// ReferenceError: bar is not defined</span><br></code></pre></td></tr></table></figure><ul><li>复杂对象的解构赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;title, <span class="hljs-attr">author</span>:&#123;name, age&#125;&#125; = &#123;<br>    title: <span class="hljs-string">&#x27;新闻标题&#x27;</span>,<br>    author:&#123;<br>        name: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        age: <span class="hljs-number">21</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(name)  <span class="hljs-comment">// 小张</span><br><span class="hljs-built_in">console</span>.log(age)  <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><ul><li>对象解构赋值的应用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$.post(url, data, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;code, objects&#125;</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (code == <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-comment">// 请求成功，执行正确的业务逻辑代码</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="字符串的解构赋值">3. 字符串的解构赋值</h3><ul><li>字符串可以看作是 “伪数组” （注：他不是真的数组）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">// h</span><br><span class="hljs-built_in">console</span>.log(b)  <span class="hljs-comment">// e</span><br><br><span class="hljs-keyword">let</span> &#123;length&#125; = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-built_in">console</span>.log(length)  <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><h3 id="设置默认值">设置默认值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">point</span>(<span class="hljs-params">x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(x);<br>    <span class="hljs-built_in">console</span>.log(y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>未设置默认值且不传对应参数时，值为undefined</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">point</span>(<span class="hljs-params">x, y = <span class="hljs-number">0</span></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// undefined</span><br>    <span class="hljs-built_in">console</span>.log(y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>带默认值的参数放最后</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">point</span>(<span class="hljs-params">x, y, z=<span class="hljs-number">0</span></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(x);<br>    <span class="hljs-built_in">console</span>.log(y);<br>    <span class="hljs-built_in">console</span>.log(z);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：<strong>参数变量（形参）不可重复声明</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">point</span>(<span class="hljs-params">x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span></span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;  <span class="hljs-comment">// SyntaxError: Identifier &#x27;x&#x27; has already been declared</span><br>    <span class="hljs-keyword">const</span> y = <span class="hljs-number">1</span>;  <span class="hljs-comment">// SyntaxError: Identifier &#x27;y&#x27; has already been declared</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当形参为对象时，可使用解构赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span>(<span class="hljs-params">url, &#123;body = <span class="hljs-string">&#x27;&#x27;</span>, method = <span class="hljs-string">&#x27;GET&#x27;</span>, headers = &#123;&#125;&#125;</span>) </span>&#123;<br>    $.ajax(&#123;<br>        url, <br>        method<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象中的函数简写">对象中的函数简写</h3><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> userA = &#123;<br>    name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    age: <span class="hljs-number">23</span>,<br>    info: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-built_in">this</span>.age;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以简写为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> userA = &#123;<br>    name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    age: <span class="hljs-number">23</span>,<br>    <span class="hljs-function"><span class="hljs-title">info</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-built_in">this</span>.age; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="箭头函数">箭头函数</h3><blockquote><p>其实不太能懂这块....</p></blockquote><ul><li><p>定义箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> f1 = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;<br>--------等同于--------<br><span class="hljs-keyword">let</span> f1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> f2 = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br>--------等同于--------<br><span class="hljs-keyword">let</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数体包含多条语句，使用 <code>&#123;&#125;</code> 包含语句块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> f3 = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(a, b);<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>箭头函数的使用场景----数组遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>arr1.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;)<br>--------等同于--------<br>arr1.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);<br></code></pre></td></tr></table></figure></li></ul><p>注意：箭头函数体内的this指向<strong>定义时所在的对象</strong>，而非实例化后的对象（在函数定义时绑定）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> userA = &#123;<br>    name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    age: <span class="hljs-number">23</span>,<br>    info:<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-built_in">this</span>.age; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数执行过程中，自动生成的一个内部对象，是指当前的对象，只在当前函数内部使用。</p><ul><li><p><strong>运行时跟运行环境绑定</strong></p><p>浏览器：this === window</p><p>Node 环境：this === global</p></li><li><p><strong>当函数被作为某个对象的方法调用时，this 指向那个对象</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> MyObj = &#123;<br>    <span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">this</span>)  <span class="hljs-comment">// MyObj</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>, <span class="hljs-built_in">this</span>)  <span class="hljs-comment">// MyObj</span><br>        &#125;, <span class="hljs-number">100</span>)<br>    &#125;,<br>    b:<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-built_in">this</span>)  <span class="hljs-comment">// window</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不太懂....</p></blockquote><h2 id="面向对象编程">面向对象编程</h2><p>ES6 中引入 class 关键字，实现面向对象编程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span>&#123;  <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">this</span>.y;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// p就是类的实例</span><br></code></pre></td></tr></table></figure><p>使用 <strong>new</strong> 关键字来实例化类。</p><h2 id="构造函数">构造函数</h2><ul><li><p>关于构造函数 constructor</p><p>构造函数是累的默认方法，通过 new 命令生成对象实例时，会自动调用该方法。</p><p>一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。</p></li><li><p>关于 this 的指向</p><p><strong>类方法</strong>中的 this 指向<strong>类的实例</strong></p><p><strong>静态方法</strong>中的 this 指向<strong>类</strong></p></li></ul><h3 id="静态方法">静态方法</h3><p>可以直接通过<strong>类</strong>来调用的方法（无法通过类的实例来调用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">staticMethod</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;I am static method&#x27;</span>;<br>    &#125;<br>&#125;<br><br>Foo.staticMethod()<br></code></pre></td></tr></table></figure><p><strong>注意：静态方法中的 this 指的是类，而不是其实例</strong></p><h2 id="类的继承">类的继承</h2><ul><li><p>ES6 中使用 <strong>extends</strong> 关键字实现类的继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Fish&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 <strong>super</strong> 关键字调用父类方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">let</span> res = <span class="hljs-built_in">super</span>.eat();  <span class="hljs-comment">// 调用父类方法</span><br>        <span class="hljs-keyword">return</span> res + <span class="hljs-string">&#x27;Fish&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">new</span> Cat().eat()<br></code></pre></td></tr></table></figure></li><li><p>属性表达式</p><p>类的属性名，可以采用表达式，使用 <strong>[]</strong> 来用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> methodName = <span class="hljs-string">&#x27;getArea&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span></span>&#123;<br>    [<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;bc&#x27;</span>]: <span class="hljs-number">123</span>;<br>    [methodName]()&#123;<br>        <span class="hljs-comment">// 业务逻辑代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> SHOW_INFO_FUNCTION_NAME = <span class="hljs-string">&#x27;showDesc&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// 吃东西</span><br>    <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;eat &#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 展示信息</span><br>    <span class="hljs-function"><span class="hljs-title">showInfo</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;动物名称: &#x27;</span> + <span class="hljs-built_in">this</span>.name + <br>        <span class="hljs-string">&#x27;, 动物年龄:&#x27;</span> + <span class="hljs-built_in">this</span>.age);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age, color</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name, age);<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-comment">// 吃东西</span><br>    <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// 调用父类的方法</span><br>        <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">super</span>.eat();<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;来自父类的方法:&#x27;</span>, result);<br>        <span class="hljs-keyword">return</span> result + <span class="hljs-string">&#x27;Fish&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 展示信息</span><br>    <span class="hljs-function"><span class="hljs-title">showInfo</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;猫的名称: &#x27;</span> + <span class="hljs-built_in">this</span>.name + <br>        <span class="hljs-string">&#x27;, 猫的年龄:&#x27;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27;, 猫的颜色:&#x27;</span> + <span class="hljs-built_in">this</span>.color);<br>    &#125;<br><br>    <span class="hljs-comment">// 属性表达式</span><br>    [SHOW_INFO_FUNCTION_NAME]()&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;自定义的方法，方法来自于属性表达式&#x27;</span>);<br>    &#125;<br><br>    [<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;bc&#x27;</span>]()&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;abc function&#x27;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;小狗&#x27;</span>, <span class="hljs-number">1</span>);<br>animal.showInfo();<br><span class="hljs-keyword">let</span> food = animal.eat();<br><span class="hljs-built_in">console</span>.log(food);<br><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;小猫&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>);<br>cat.showInfo();<br><span class="hljs-built_in">console</span>.log(cat.eat());<br><br><span class="hljs-comment">// 属性表达式的方法调用</span><br>cat[SHOW_INFO_FUNCTION_NAME]();<br>cat.abc();<br>cat[<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;bc&#x27;</span>]();<br><br><span class="hljs-keyword">let</span> MyObj = &#123;<br>    [<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;bc&#x27;</span>]: <span class="hljs-number">123</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(MyObj.abc);  <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><h2 id="模块化">模块化</h2><p>模块是对内部逻辑的<strong>封装</strong>，只对外提供<strong>接口</strong>。</p><ul><li>一个 js 文件就是一个模块</li><li>ES6 中使用 <strong>export</strong> 关键字对外暴露接口（导出）</li><li>ES6 中使用 <strong>import</strong> 关键字导入一个模块</li></ul><p>模块化的好处：</p><ul><li>增强代码的<strong>可维护性</strong></li><li>增强代码的<strong>可阅读性</strong></li><li>增强代码的<strong>可扩展性</strong></li></ul><h3 id="export-的使用">export 的使用</h3><h4 id="直接导出">1. 直接导出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NAME = <span class="hljs-string">&#x27;JavaScript&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hey, boy!&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="批量导出">2. 批量导出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 变量</span><br><span class="hljs-keyword">const</span> NAME = <span class="hljs-string">&#x27;JavaScript&#x27;</span>;  <span class="hljs-comment">// 常量</span><br><span class="hljs-comment">// 函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hey, boy!&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;a, NAME, sayHello&#125;<br></code></pre></td></tr></table></figure><ul><li>通过 <strong>as</strong> 关键字指定别名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">19</span><br><span class="hljs-keyword">export</span>&#123;a <span class="hljs-keyword">as</span> age&#125;<br></code></pre></td></tr></table></figure><h4 id="使用-export-default-默认导出">3. 使用 export default 默认导出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span><br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> b  <span class="hljs-comment">// 可以理解为赋值：default=b</span><br><br><span class="hljs-comment">//f.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;from default&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="import-的使用">import 的使用</h3><h4 id="导入需要的部分内容">1. 导入需要的部分内容</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 从myFirstModule.js导入需要的函数</span><br><span class="hljs-keyword">import</span> &#123;sayHello&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./myFirstModule.js&#x27;</span><br><br><span class="hljs-comment">// 执行函数</span><br>sayHello()<br></code></pre></td></tr></table></figure><h4 id="导入全部内容使用-as-指定别名">2. 导入全部内容，使用 <strong>as</strong> 指定别名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 从myFirstModule.js导入需要的函数</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./myFirstModule.js&#x27;</span><br><br><span class="hljs-comment">// 执行函数</span><br>myModule.sayHello()<br></code></pre></td></tr></table></figure><p>在 Node 中执行 ES6 模块</p><ul><li><p>设置package.json</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;module&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>举个栗子：</p><p>constants.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> APP_NAME = <span class="hljs-string">&#x27;在线问答系统&#x27;</span><br><span class="hljs-keyword">const</span> VERSION = <span class="hljs-string">&#x27;1.0&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;getname&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;<br>    APP_NAME,<br>    VERSION <span class="hljs-keyword">as</span> v<br>&#125;<br></code></pre></td></tr></table></figure><p>formatUsername.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 格式化用户昵称，取第一个字，后面用***代替</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>name 用户昵称</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> name.substr(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;***&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>test.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;APP_NAME <span class="hljs-keyword">as</span> name, v&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./constants.js&#x27;</span><br><span class="hljs-keyword">import</span> formatUname <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./formatUsername.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;APP_NAME:&#x27;</span>, name)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Version:&#x27;</span>, v)<br><br><span class="hljs-keyword">let</span> uname = formatUname(<span class="hljs-string">&#x27;张三&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(uname)<br></code></pre></td></tr></table></figure><blockquote><p>输出：</p><p>APP_NAME: 在线问答系统 Version: 1.0 张***</p></blockquote><h3 id="踩坑指南">踩坑指南</h3><p>1.不能块级作用域内执行导入导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>  <span class="hljs-comment">// SyntaxError</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.不能直接导出变量的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-number">3.1415926</span>  <span class="hljs-comment">// SyntaxError</span><br></code></pre></td></tr></table></figure><p>3.注意 import 的顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">import</span> b <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.js&#x27;</span>  <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><h2 id="flex-布局">Flex 布局</h2><p>Flex（Flexible Box）：弹性布局</p><p>基本概念</p><ul><li>容器（Flex Container）</li><li>元素项（Flex Item）</li><li>水平轴，横轴，主轴（main axis）</li><li>垂直轴，纵轴，交叉轴（cross axis）</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/Flex概念.png"style="width:70%;"/></center><h3 id="flex-容器-flex-container-的属性">Flex 容器 (Flex Container) 的属性</h3><ul><li><p><code>flex-diredtion</code> ：容器内元素的排列方向</p></li><li><p><code>flex-wrap</code> ：容器内元素的换行行为</p></li><li><p><code>flex-flow</code> ：direction 和 wrap 的复合属性</p></li><li><p><code>justify-content</code> ：元素在横轴上的对齐方式</p></li><li><p><code>align-items</code> ：元素在纵轴上的对齐方式</p></li><li><p><code>align-content</code> ：多行元素的对齐方向</p></li></ul><h4 id="flex-direction">flex-direction</h4><p>容器内元素的排列方向</p><ul><li><code>row(默认值)</code> ：主轴为水平方向，从左到右</li><li><code>row-reverse</code> ：主轴为水平方向，从右到左</li><li><code>column</code> ：主轴为垂直方向，从上到下</li><li><code>column-reverse</code> ：主轴为垂直方向，从下到上</li></ul><p>栗：<code>column-reverse</code></p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/column-reverse.png"style="width:40%;"/></center><h4 id="flex-wrap">flex-wrap</h4><p>容器内元素的换行行为</p><ul><li><code>nowrap(默认)</code> ：不换行</li><li><code>wrap</code> ：换行，首行在上方</li><li><code>wrap-reverse</code> ：换行，首航在底部</li></ul><p>栗：<code>wrap</code></p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/flex-wrap: wrap.png"style="width:40%;"/></center><h4 id="flex-flow">flex-flow</h4><p>direction 和 wrap 的复合属性</p><p><code>flex-flow</code> ：<code>&lt;'flex-direction'&gt;</code> || <code>&lt;'flex-wrap'&gt;</code> 默认值为 <code>row nowrap</code></p><h4 id="justify-content">justify-content</h4><p>元素在横轴(水平轴)上的对齐方式</p><ul><li><code>flex-start(默认值)</code> ：左对齐</li><li><code>flex-end</code> ：右对齐</li><li><code>center</code> ：居中对齐</li><li><code>space-between</code> ：两端对齐，item之间的间隔相等</li><li><code>space-around</code> ：每个 item 两侧的间隔相等</li></ul><p>栗：<code>center</code>（横轴）</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/justify-content.png"style="width:40%;"/></center><h4 id="align-items">align-items</h4><p>元素在纵轴(垂直轴)上的对齐方式</p><ul><li><code>stretch(默认值)</code> ：占满整个容器的高度</li><li><p><code>flex-start</code> ：与纵轴起点对齐</p></li><li><p><code>flex-end</code> ：与纵轴终点对齐</p></li><li><code>center</code> ：与纵轴中间对齐</li><li><p><code>baseline</code> ：与基线对齐</p></li></ul><p>栗：<code>center</code>（纵轴）</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/align-items: center.png"style="width:40%;"/></center><h4 id="align-content">align-content</h4><p>多行元素的对齐方向</p><ul><li><code>stretch(默认值)</code> ：占满整个容器的高度</li><li><p><code>flex-start</code> ：与纵轴起点对齐</p></li><li><p><code>flex-end</code> ：与纵轴终点对齐</p></li><li><code>center</code> ：与纵轴中间对齐</li><li><code>space-between</code> ：与纵轴两端对齐， item 之间的间隔平均分布</li><li><p><code>space-around</code> ：每根轴线两侧的间隔相等</p></li></ul><p>举个栗子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>flex布局<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.container</span>&#123;</span><br>width: 600px;<br>height: 600px;<br>margin: 0 auto;<br><span class="css"><span class="hljs-selector-tag">background-color</span><span class="hljs-selector-pseudo">:beige</span>;</span><br>display: flex;<br><span class="css"><span class="hljs-comment">/* 元素项的排列方式 */</span></span><br><span class="css"><span class="hljs-comment">/* flex-direction: column-reverse; */</span></span><br>flex-direction: row;<br><span class="css"><span class="hljs-comment">/* 内容是否换行 */</span></span><br>flex-wrap: wrap;<br><span class="css"><span class="hljs-comment">/* 纵轴终点对齐 */</span></span><br>justify-content: flex-end;<br><span class="css"><span class="hljs-comment">/* 垂直轴的对齐方式 */</span></span><br>align-items: center;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.container</span> <span class="hljs-selector-tag">div</span>&#123;</span><br>width: 250px;<br>height: 100px;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.d1</span> &#123;</span><br>background-color: red;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.d2</span> &#123;</span><br>background-color: yellow;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.d3</span> &#123;</span><br>background-color: blue;<br>&#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="flex-元素项-flex-item-的属性">Flex 元素项 (Flex Item) 的属性</h3><ul><li><code>order</code> ：排序规则，越小越靠前排列</li><li><code>flex-grow</code> ：放大（撑开）比例</li><li><code>flex-shrink</code> ：收缩比例</li><li><code>flex-basis</code> ：水平方向的大小</li><li><code>flex</code> ：grow、shrink、basis 的复合属性</li><li><code>align-self</code> ：元素在纵轴上的对齐方式</li></ul><h4 id="order">order</h4><p>排序规则，越小越靠前排列</p><p>默认为0。数值越小，排列越靠前。</p><p>栗：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.d1</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">order</span>:<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-selector-class">.d2</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>    <span class="hljs-attribute">order</span>:<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.d3</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">order</span>:<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/order: 1.png"style="width:40%;"/></center><h4 id="flex-grow">flex-grow</h4><p>放大（撑开）比例</p><ul><li><p><code>0(默认值)</code>：如果存在剩余空间，也不放大</p></li><li><p><code>1</code> ：如果存在剩余空间，均分剩余空间</p></li><li><p><code>既有 0, 也有 1</code> ：如果存在剩余空间，0 的不撑大，1 撑大</p></li><li><p><code>&gt;=1</code> ：如果存在剩余空间，按比例分配剩余空间</p></li></ul><p>栗：<code>flex-grow:1</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> <span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.d1</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">order</span>:<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-selector-class">.d2</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>    <span class="hljs-attribute">order</span>:<span class="hljs-number">1</span>;<br><br>&#125;<br><span class="hljs-selector-class">.d3</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">order</span>:<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/flex-grow: 1.png"style="width:40%;"/></center><p>既有1，又有0.（因为写在里面了，所以其他div默认为0）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> <span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.d1</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">order</span>:<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-selector-class">.d2</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>    <span class="hljs-attribute">order</span>:<span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.d3</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">order</span>:<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/flex-grow: 1/0.png"style="width:40%;"/></center><h4 id="flex-shrink">flex-shrink</h4><p>收缩比例。</p><ul><li><code>1(默认)</code> ：如果空间不足，该 item 将缩小</li></ul><h4 id="flex-basis">flex-basis</h4><p>水平方向的大小。</p><p>如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，<strong>按比率伸缩剩余空间</strong></p><ul><li><code>auto(默认值)</code> ：无特定宽度值，取决于其它属性值</li><li><code>&lt;1ength&gt;</code> ：用长度值来定义宽度，不允许负值</li><li><code>&lt;Percentage&gt;</code> ：用百分比来定义宽度，不允许负值</li><li><code>content</code> ：基于内容自动计算宽度</li></ul><h4 id="flex">flex</h4><p>grow、shrink、basis 的复合属性</p><ul><li><code>1</code> ：则其计算值为 1 1 0%</li><li><code>auto</code> ：则其计算值为 1 1 auto</li><li><code>none</code> ：则其计算值为 0 0 auto</li><li><code>0 none</code> ：则其计算值为 0 1 auto</li></ul><h4 id="align-self">align-self</h4><p>元素在纵轴上的对齐方式</p><ul><li><code>auto(默认值)</code> ：父元素的 <code>align-items</code> 值，若无，则为 <code>strech</code></li><li><code>stretch</code> ：占满整个容器的高度</li><li><p><code>flex-start</code> ：与纵轴起点对齐</p></li><li><p><code>flex-end</code> ：与纵轴终点对齐</p></li><li><code>center</code> ：与纵轴中间对齐</li><li><p><code>baseline</code> ：与基线对齐</p></li></ul><p>小练习：实现下面图形</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/骰子.png"style="width:20%;"/></center><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>flex布局<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.container</span>&#123;</span><br>width: 100px;<br>height: 100px;<br>margin: 0 auto;<br>border-radius: 10px;<br>background-color: lightgray;<br>display: flex;<br>justify-content: space-between;<br><br>&#125;<br><span class="css"><span class="hljs-selector-class">.container</span> <span class="hljs-selector-tag">div</span>&#123;</span><br>width: 20px;<br>height: 20px;<br>border-radius: 50%;<br>margin: 7px;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.d1</span> &#123;</span><br>background-color: black;<br>align-self: flex-start;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.d2</span> &#123;</span><br>background-color: black;<br>align-self: center;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.d3</span> &#123;</span><br>background-color: black;<br>align-self: flex-end;<br>&#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery入门</title>
    <link href="/2021/03/02/jQuery%E5%85%A5%E9%97%A8/"/>
    <url>/2021/03/02/jQuery%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 高级程序设计（特别是对浏览器差异的复杂处理），通常很困难也很耗时。 为了应对这些调整，许多的 JavaScript (helper) 库应运而生。 这些 JavaScript 库常被称为 JavaScript 框架。</p><p>例如：</p><ul><li>jQuery - 使用最广泛的库！</li><li>ReactJS - React是一个用来构建用户界面的 JavaScript 库，主要用于构建UI</li><li>Vue.js - Vue是构建 Web 界面的 JavaScript 库，提供数据驱动的组件，还有简单灵活的 API，使得 MVVM 更简单。。</li><li>Meteor - Meteor 是一组新的技术用于构建高质量的 Web 应用，提供很多现成的包，可直接在浏览器或者云平台中运行。</li><li>Angular2 - Angular 是一款十分流行且好用的 Web 前端框架，目前由 Google 维护。</li></ul><p>所有这些框架都提供针对常见 JavaScript 任务的函数，包括动画、DOM 操作以及 Ajax 处理。</p><h1 id="jquery">jQuery</h1><h2 id="jquery-介绍">jQuery 介绍</h2><p>jQuery 是目前最受欢迎的 JavaScript 框架。它使用 CSS 选择器来访问和操作网页上的 HTML 元素 （DOM 对象）。jQuery 同时提供 companion UI（用户界面）和插件。 许多大公司在网站上使用 jQuery：</p><ul><li>Google</li><li>Microsoft</li><li>IBM</li><li>Netflix</li></ul><p>JQuery是一个“写的更少，但做的更多”的轻量级 JavaScript 库。</p><p>JQuery极大地简化了 JavaScript 编程。</p><p>JQuery简单易学。</p><h3 id="jquery-和-dom的关系">jQuery 和 DOM的关系</h3><p>jQuery 的主要功能和 DOM 类似。但它的代码更简短、更人性化、更方便。缺点是需要导入 jQuery 库文件，增加了页面大小，耗费了网络流量。</p><p>DOM，是 JS 原生支持的，不需要导入任何文件，但是代码长、调用费时费力，但是不会增加页面体积，不会消耗额外的流量。在一些极端场合，比如手机终端，为了减少用户流量开支，可能会强制要求使用 DOM，而不允许使用 jQuery。</p><h3 id="使用-jquery-做什么">使用 jQuery 做什么？</h3><p>jQuery 库可以通过一行简单的标记被添加到网页中。</p><ul><li>查询/操作 DOM</li><li>处理 JS 事件</li><li>实现动画效果</li><li>封装/使用 jQuery 插件</li><li>使用 AJAX 发送异步请求</li></ul><p>回顾：使用原生 JS 实现查询</p><ul><li>根据 ID 查询</li><li>根据 class 查询</li><li>根据 标签 查询</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span>长沙<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beijing&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">// 根据ID查询</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> username = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;username&#x27;</span>);</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(username);</span><br><br><span class="javascript"><span class="hljs-comment">// 根据类名查询</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> areaList = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;area&#x27;</span>);</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(areaList);</span><br><br><span class="javascript"><span class="hljs-comment">// 根据标签查询</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> pList = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;p&#x27;</span>);</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(pList);</span><br><br><span class="javascript"><span class="hljs-comment">// 自己实现jQuery中的id选择器</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> $ = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.getElementById(id);</span><br>&#125;<br><span class="javascript"><span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&#x27;username&#x27;</span>));</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&#x27;beijing&#x27;</span>));</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="cdn---内容分发网络">CDN - 内容分发网络</h3><p>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络&quot;边缘&quot;，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，解决用户访问网站的响应速度慢的根本原因。</p><h2 id="jquery-语法">jQuery 语法</h2><p>基础语法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).action();<br></code></pre></td></tr></table></figure><ul><li>美元符号$定义 jQuery，也是 jQuery 的变量代号</li><li>选择器（selector）负责“查询”和“查找” HTML 元素。</li><li>action() 执行对元素的操作。Jquery具有链式调用的特性，所以action可以接action。</li></ul><p>遵循以下原则时，代码会更恰当且更易维护：</p><ul><li>把所有 jQuery 代码置于事件处理函数中</li><li>把所有事件处理函数置于文档就绪事件处理器中</li><li>把 jQuery 代码置于单独的 .js 文件中</li><li>如果存在名称冲突，则重命名 jQuery 库</li></ul><h3 id="文档就绪函数">文档就绪函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>--- jQuery functions go here ----<br>&#125;);<br></code></pre></td></tr></table></figure><p>这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。 如果在文档没有完全加载之前就运行函数，操作可能失败。</p><h3 id="jquery-选择器">jQuery 选择器</h3><p>与DOM类似，Jquery的核心也是元素选择器。JQuery允许对元素组或单个元素进行操作。</p><p><strong>Jquery采用与CSS类似的选择器语法来选择元素！</strong></p><ol start="0" type="1"><li><p><strong><font color='red'>$(this) </font></strong> ：当前 HTML 元素</p></li><li><p><strong>元素选择器</strong></p></li></ol><ul><li><code>$(&quot;p&quot;)</code> ：选取 <code>&lt;p&gt;</code> 元素</li><li><code>$(&quot;p.intro&quot;)</code> ：选取所有 <code>class=&quot;intro&quot;</code> 的元素。</li><li><code>$(&quot;p#demo&quot;)</code> ：选取所有 <code>id=&quot;demo&quot;</code> 的 <code>&lt;p&gt;</code> 元素。（有冗余）</li></ul><ol start="2" type="1"><li><strong>属性选择器</strong></li></ol><ul><li><code>$(&quot;[href]&quot;)</code> ：选取所有带有 href 属性的元素。</li><li><code>$(&quot;[href='#']&quot;)</code> ：选取所有带有 href 值等于 &quot;#&quot; 的元素。</li><li><code>$(&quot;[href!='#']&quot;)</code> ：选取所有带有 href 值不等于 &quot;#&quot; 的元素。</li><li><p><code>$(&quot;[href$='.jpg']&quot;)</code> ：选取所有 href 值以 &quot;.jpg&quot; 结尾的元素。</p></li><li><p><code>$('input[name=&quot;password&quot;]')</code></p><ul><li><p><code>=</code> ：等于/相等</p></li><li><p><code>^=</code> ：以 ** 开始</p></li><li><p><code>$=</code> ：以 ** 结束</p></li></ul></li></ul><ol start="3" type="1"><li><strong>层级选择器（父子、兄弟等）</strong></li></ol><ul><li><code>$(&quot;parent &gt; chird&quot;)</code> ：parent 元素中的指定的 child <strong>直接</strong>子元素</li><li><code>$(&quot;parent chird&quot;)</code> ：所有后代元素</li><li><code>$(&quot;prev + next&quot;)</code> ：紧贴 prev 之后的元素 <strong>(兄弟元素)</strong></li></ul><ol start="4" type="1"><li><strong>伪类选择器</strong></li></ol><ul><li><code>:first/:last</code> ：第一个/最后一个匹配的元素</li><li><code>eq(N)</code> ：匹配的索引为 N 的元素</li><li><code>:even/:odd</code> ：奇数/偶数个元素</li><li><code>:checked</code> ：表单中所有勾选的元素</li><li><code>:disabled</code> ：被禁用的元素</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/js选择器1.png"style="width:90%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/js选择器2.png"style="width:90%;"/></center><p>举个栗子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jquery/jquery-3.4.1.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">// jQuery代码的内容</span></span><br><span class="javascript">        $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">// 根据ID</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> username = $(<span class="hljs-string">&#x27;#username&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(username);</span><br><br><span class="javascript">            <span class="hljs-comment">// 根据class查询</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> areaList = $(<span class="hljs-string">&#x27;.area&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(areaList);</span><br><br><span class="javascript">            <span class="hljs-comment">// 根据 元素标签 来查询</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> pList = $(<span class="hljs-string">&#x27;p&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(pList);</span><br>            <br><span class="javascript">            <span class="hljs-comment">// 层级选择器</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> bodyList = $(<span class="hljs-string">&#x27;body *&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(bodyList);</span><br><br><span class="javascript">            <span class="hljs-comment">// body的所有后代元素p                      </span></span><br><span class="javascript">            <span class="hljs-keyword">var</span>  bodyList1 = $(<span class="hljs-string">&#x27;body p&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(bodyList1);</span><br><br><span class="javascript">            <span class="hljs-comment">// body的直接的后代元素p</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span>  bodyList2 = $(<span class="hljs-string">&#x27;body &gt; p&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(bodyList2);</span><br><br><span class="javascript">            <span class="hljs-comment">// label后紧挨着的input</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span>  bodyList2 = $(<span class="hljs-string">&#x27;label + input&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(bodyList2);</span><br><br><span class="javascript">            <span class="hljs-comment">//伪类选择器</span></span><br><span class="javascript">            <span class="hljs-comment">// 查询p标签第一个</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> pFirst = $(<span class="hljs-string">&#x27;p:first&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(pFirst);</span><br><br><span class="javascript">            <span class="hljs-comment">// 查询索引为n的元素, 索引从0开始</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> p2 = $(<span class="hljs-string">&#x27;p:eq(1)&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(p2);</span><br><br><span class="javascript">            <span class="hljs-comment">// 属性选择器</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> psw = $(<span class="hljs-string">&#x27;input[name=&quot;password&quot;]&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> psw = $(<span class="hljs-string">&#x27;input[name^=passw]&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(psw);</span><br><br><span class="javascript">            <span class="hljs-comment">// 查询input下有id属性的</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> InputList = $(<span class="hljs-string">&#x27;input[id]&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(InputList);</span><br><br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span>长沙<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beijing&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>海南<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="jquery-事件">jQuery 事件</h2><p>jQuery 是为事件处理特别设计的。jQuery 事件处理方法是 jQuery 中的核心函数。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。</p><p>栗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jquery/jquery-3.4.1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">$(<span class="hljs-string">&quot;p&quot;</span>).css(<span class="hljs-string">&quot;background-color&quot;</span>,<span class="hljs-string">&quot;red&quot;</span>);</span><br><span class="javascript">$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">$(<span class="hljs-string">&quot;p&quot;</span>).toggle();</span><br>&#125;);<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is another paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/jQuery 事件.png"style="width:30%;"/></center><h3 id="jquery-事件方法">jQuery 事件方法</h3><p>事件方法会触发匹配元素的事件，或将函数绑定到所有匹配元素的某个事件。</p><ul><li>文档加载（DOM准备就绪）</li><li>鼠标事件（点击/滑动）</li><li>键盘事件</li><li>表单事件</li></ul><h4 id="jquery-事件绑定方法">jQuery 事件绑定方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).on(events,[selector],[data],fn)<br></code></pre></td></tr></table></figure><ul><li>events:一个或多个用空格分隔的事件类型和可选的命名空间，如&quot;click&quot;或&quot;keydown.myPlugin&quot; 。</li><li>selector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择的&lt; null或省略， 当它到达选定的元素，事件总是触发。</li><li>data:当一个事件被触发时要传递event.data给事件处理函数。</li><li>fn:该事件被触发时执行的函数。 false 值也可以做一个函数的简写，返回false</li></ul><p>栗：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;p&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>alert( $(<span class="hljs-built_in">this</span>).text() );<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="jquery-事件解除绑定方法">jQuery 事件解除绑定方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).off(events,[selector],[data],fn)<br></code></pre></td></tr></table></figure><ul><li>events:一个或多个用空格分隔的事件类型和可选的命名空间，如&quot;click&quot;或&quot;keydown.myPlugin&quot; 。</li><li>selector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择的&lt; null或省略， 当它到达选定的元素，事件总是触发。</li><li>data:当一个事件被触发时要传递event.data给事件处理函数。</li><li>fn:该事件被触发时执行的函数。 false 值也可以做一个函数的简写，返回false</li></ul><h4 id="鼠标事件">鼠标事件</h4><ul><li>点击事件<ul><li><code>.click()/.dblclick()</code> ：单机/双击</li><li><code>.mousedown()/.mouseup()</code> ：按下/抬起</li></ul></li><li>移动事件<ul><li><code>.mouseenter()/.mouseleave()</code> ：进入/离开（hover）</li></ul></li></ul><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//js业务逻辑和html分离</span><br>    $(<span class="hljs-string">&#x27;div&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        alert(<span class="hljs-string">&#x27;单击弹窗&#x27;</span>);<br>    &#125;)<br>    $(<span class="hljs-string">&#x27;div&#x27;</span>).dblclick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        alert(<span class="hljs-string">&#x27;双击弹窗&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-comment">//一样的效果</span><br>    $(<span class="hljs-string">&#x27;div&#x27;</span>).on(<span class="hljs-string">&#x27;dblclick&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        alert(<span class="hljs-string">&#x27;双击弹窗&#x27;</span>);<br>    &#125;)<br><br>    <span class="hljs-comment">//相当于hover</span><br>    $(<span class="hljs-string">&#x27;div&#x27;</span>).mouseenter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// this表示事件触发的这个元素</span><br>        $(<span class="hljs-built_in">this</span>).css(&#123;<br>            <span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span><br>        &#125;)<br>    &#125;).mouseleave(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        $(<span class="hljs-built_in">this</span>).css(&#123;<br>            <span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&#x27;white&#x27;</span><br>        &#125;)<br>    &#125;)<br><br>    <span class="hljs-comment">// hover</span><br>    $(<span class="hljs-string">&#x27;div&#x27;</span>).hover(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        $(<span class="hljs-built_in">this</span>).css(&#123;<br>            <span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&#x27;blue&#x27;</span><br>        &#125;)<br>    &#125;),<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        $(<span class="hljs-built_in">this</span>).css(&#123;<br>            <span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&#x27;white&#x27;</span><br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="键盘事件">键盘事件</h4><ul><li>按下：<code>.keydown()</code></li><li>抬起：<code>.keyup()</code></li></ul><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 绑定键盘事件</span><br>$(<span class="hljs-string">&#x27;#username&#x27;</span>).keyup(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> val = $(<span class="hljs-built_in">this</span>).val();<br>    <span class="hljs-built_in">console</span>.log(val);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="表单事件">表单事件</h4><ul><li><p>焦点：<code>.focus()/.blur()</code> ：获得/失去焦点</p></li><li><p>值发生改变：<code>.change()</code></p></li><li><p>form表单提交：<code>.submit()</code></p><p>注意表单事件触发的条件：得是 <code>submit</code> ，不能是 <code>button</code></p></li></ul><h4 id="事件的行为">事件的行为</h4><ul><li><p>阻止 a 标签的默认行为：<code>event.preventDefault();</code></p></li><li><p>阻止多个事件冒泡：<code>event.stopPropagation();</code></p><p>什么是事件冒泡？</p><p>答：就是点击嵌套元素中里面的元素，外面的元素事件也被触发。</p></li></ul><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a标签的事件</span><br>$(<span class="hljs-string">&#x27;reg2&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>    <span class="hljs-comment">// 阻止a标签的默认行为</span><br>    event.preventDefault();<br>    alert(<span class="hljs-string">&#x27;a click&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 事件的冒泡</span><br>$(<span class="hljs-string">&#x27;.reg3&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-string">&quot;reg3&quot;</span>);<br>&#125;)<br>$(<span class="hljs-string">&#x27;.reg3 span&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">// 阻止事件的冒泡</span><br>    e.stopPropagation();<br>    alert(<span class="hljs-string">&quot;reg3 span&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="一些相关的事件">一些相关的事件</h4><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/jQuery 事件2.png"style="width:90%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/jQuery 事件3.png"style="width:90%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/jQuery 事件4.png"style="width:90%;"/></center><h2 id="jquery-效果">jQuery 效果</h2><h3 id="callback-函数">Callback 函数</h3><p>Callback 函数在当前动画 100% 完成之后执行。</p><p>由于 JavaScript 语句是逐一执行的 - 按照次序，动画之后的语句可能会产生错误或页面冲突，因为 动画还没有完成。为了避免这个情况，可以以参数的形式添加 Callback 函数。</p><p>下面是正确调用（有 callback）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;p&quot;</span>).hide(<span class="hljs-number">1000</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>alert(<span class="hljs-string">&quot;The paragraph is now hidden&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>下面是错误的调用（没有 callback）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;p&quot;</span>).hide(<span class="hljs-number">1000</span>);<br>alert(<span class="hljs-string">&quot;The paragraph is now hidden&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote><h3 id="隐藏和显示">1. 隐藏和显示</h3><h4 id="hide-和-show">hide() 和 show()</h4><p>使用 hide() 和 show() 方法来隐藏和显示 HTML 元素：</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).hide(speed,callback);<br>$(selector).show(speed,callback);<br></code></pre></td></tr></table></figure><ul><li>可选的 speed 参数规定隐藏/显示的速度，可以取以下值： &quot;slow&quot;、&quot;fast&quot; 或毫秒。</li><li>可选的 callback 参数是隐藏或显示完成后所执行的函数名称。</li></ul><h4 id="toggle">toggle()</h4><p>使用 toggle() 方法来切换 hide() 和 show() 方法。显示被隐藏的元素，并隐藏已显示的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).toggle(speed,callback);<br></code></pre></td></tr></table></figure><p>栗子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jquery/jquery-3.4.1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">$(<span class="hljs-string">&quot;p&quot;</span>).css(<span class="hljs-string">&quot;background-color&quot;</span>,<span class="hljs-string">&quot;red&quot;</span>);</span><br><span class="javascript">$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                $(<span class="hljs-string">&quot;#hide&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                    $(<span class="hljs-string">&quot;p&quot;</span>).hide();</span><br>                &#125;);<br><span class="javascript">                $(<span class="hljs-string">&quot;#show&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                    $(<span class="hljs-string">&quot;p&quot;</span>).show();</span><br>                &#125;);<br><br><span class="javascript"><span class="hljs-comment">//$(&quot;p&quot;).toggle();</span></span><br>&#125;);<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is another paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="淡入淡出">2. 淡入淡出</h3><p>jQuery 拥有下面四种 fade 方法：</p><ul><li>fadeIn() 用于淡入已隐藏的元素。</li><li>fadeOut() 用于淡出可见元素。</li><li>fadeToggle() 在 fadeIn() 与 fadeOut() 方法之间进行切换。</li><li>fadeTo() 允许渐变为给定的不透明度（值介于 0 与 1 之间）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).fadeIn(speed,callback);<br>$(selector).fadeOut(speed,callback);<br>$(selector).fadeToggle(speed,callback);<br>$(selector).fadeTo(speed,opacity,callback);<br></code></pre></td></tr></table></figure><ul><li>可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</li><li>可选的 callback 参数是 fading 完成后所执行的函数名称。</li><li>opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）。</li></ul><h3 id="jquery-滑动方法">3. jQuery 滑动方法</h3><p>jQuery 拥有以下滑动方法：</p><ul><li>slideDown() 用于向下滑动元素。</li><li>slideUp() 用于向上滑动元素。</li><li>slideToggle() 在 slideDown() 与 slideUp() 方法之间进行切换。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).slideDown(speed,callback);<br>$(selector).slideUp(speed,callback);<br>$(selector).slideToggle(speed,callback);<br></code></pre></td></tr></table></figure><ul><li>可选的 speed 参数规定效果的时长。它可以取以下值： &quot;slow&quot;、&quot;fast&quot; 或毫秒。</li><li>可选的 callback 参数是滑动完成后所执行的函数名称。</li></ul><h3 id="jquery-动画">4. jQuery 动画</h3><p>animate() 方法用于创建自定义动画。</p><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">$(selector).animate(&#123;params&#125;,speed,callback); <br></code></pre></td></tr></table></figure><ul><li>必需的 params 参数定义形成动画的 CSS 属性。</li><li>可选的 speed 参数规定效果的时长。它可以取以下值： &quot;slow&quot;、&quot;fast&quot; 或毫秒。</li><li>可选的 callback 参数是动画完成后所执行的函数名称。</li></ul><p>栗子：把 <code>&lt;div&gt;</code> 元素移动到左边，直到 left 属性等于 250 像素为止</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jquery/jquery-3.4.1.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> <br><span class="javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">$(<span class="hljs-string">&quot;div&quot;</span>).animate(&#123;</span><br><span class="javascript">left:<span class="hljs-string">&#x27;250px&#x27;</span></span><br>&#125;);<br>&#125;);<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>开始动画<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>默认情况下，所有 HTML 元素的位置都是静态的，并<br>且无法移动。如需对位置进行操作，记得首先把元素的 CSS <br>position 属性设置为 relative、fixed 或 absolute。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:#98bf21;</span></span><br><span class="hljs-tag"><span class="hljs-string">height:100px;</span></span><br><span class="hljs-tag"><span class="hljs-string">width:100px;position:absolute;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><u>注意：生成动画的过程中可同时使用多个属性：</u></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&quot;div&quot;</span>).animate(&#123;<br>        left:<span class="hljs-string">&#x27;250px&#x27;</span>,<br>        opacity:<span class="hljs-string">&#x27;0.5&#x27;</span>,<br>        height:<span class="hljs-string">&#x27;150px&#x27;</span>,  <span class="hljs-comment">// height:&#x27;+=150px&#x27;,  也可以用相对值</span><br>        width:<span class="hljs-string">&#x27;150px&#x27;</span>  <span class="hljs-comment">// width:&#x27;toggle&#x27;</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>可以用 animate() 方法来操作所有 CSS 属性吗？</p><p><strong>是的</strong>，几乎都可以！不过，需要记住一件重要的事情：<u>当使用 animate() 时</u>，必须使<u>用 Camel 标记法</u>书写所有的属性名，比如必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。</p><h3 id="jquery-stop-方法">jQuery stop() 方法</h3><p>用于停止动画或效果，在它们完成之前。</p><p>适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(selector).stop(stopAll,goToEnd);<br></code></pre></td></tr></table></figure><ul><li>可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入 队列的动画向后执行。</li><li>可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。</li></ul><h2 id="jquery-html操作">jQuery HTML操作</h2><h3 id="获取元素的内容和属性">1. 获取元素的内容和属性</h3><p>有几个简单实用的用于 DOM 操作的 jQuery 方法：</p><ul><li><strong>text()</strong> - 设置或返回所选元素的文本内容</li><li><strong>html()</strong> - 设置或返回所选元素的内容（包括 HTML 标记）</li><li><p><strong>val()</strong> - 设置或返回表单字段的值</p></li><li><p><strong>attr()</strong> - 用于获取属性值。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jquery/jquery-3.4.1.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-text user-input&quot;</span> <span class="hljs-attr">my-user</span>=<span class="hljs-string">&#x27;张三&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;我的用户名&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span>长沙<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beijing&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>海南<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>        查看详细<br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>内容：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>文字描述<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">// class属性</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> cls = $(<span class="hljs-string">&#x27;#username&#x27;</span>).attr(<span class="hljs-string">&#x27;class&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;class:&#x27;</span>, cls);</span><br><br><span class="javascript">            <span class="hljs-comment">// type属性</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> type = $(<span class="hljs-string">&#x27;#username&#x27;</span>).attr(<span class="hljs-string">&#x27;type&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;type:&#x27;</span>, type);</span><br><br><span class="javascript">            <span class="hljs-comment">// 自定义属性</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> user = $(<span class="hljs-string">&#x27;#username&#x27;</span>).attr(<span class="hljs-string">&#x27;my-user&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;user:&#x27;</span>, user);</span><br><br><span class="javascript">            <span class="hljs-comment">// 查询html信息</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> htmlContent = $(<span class="hljs-string">&#x27;#info&#x27;</span>).html();</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;HTML&#x27;</span>, htmlContent);</span><br><br><span class="javascript">            <span class="hljs-comment">// 查询text信息</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> textContent = $(<span class="hljs-string">&#x27;#info&#x27;</span>).text();</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;text&#x27;</span>, textContent);</span><br><br><span class="javascript">            <span class="hljs-comment">// 查看值信息</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> inputUsername = $(<span class="hljs-string">&#x27;#username&#x27;</span>).val();</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;inputusername:&#x27;</span>, inputUsername);</span><br><br><span class="javascript">            <span class="hljs-comment">//jQuery 对象转换成DOM对象</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> username = $(<span class="hljs-string">&#x27;#username&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;username jquery对象:&#x27;</span>, username);</span><br><span class="javascript">            <span class="hljs-comment">// 转换成DOM对象</span></span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;username DOM 对象:&#x27;</span>, username.get()[<span class="hljs-number">0</span>].value);</span><br><br>        &#125;)<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="设置内容和属性">2. 设置内容和属性</h3><p>同样是使用text()、html()、attr() 以及 val()方法，不过是在括号内提供要设置的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;#btn1&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&quot;#test1&quot;</span>).text(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>&#125;);<br>    <br>$(<span class="hljs-string">&quot;#btn2&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&quot;#test2&quot;</span>).html(<span class="hljs-string">&quot;&lt;b&gt;Hello world!&lt;/b&gt;&quot;</span>);<br>&#125;);<br>    <br>$(<span class="hljs-string">&quot;#btn3&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&quot;#test3&quot;</span>).val(<span class="hljs-string">&quot;Dolly Duck&quot;</span>);<br>&#125;);<br>    <br>$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&quot;#baidu&quot;</span>).attr(<span class="hljs-string">&quot;href&quot;</span>, <span class="hljs-string">&quot;http://www.baidu.com.cn/jquery&quot;</span>);<br>&#125;);<br>    <br>$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&quot;#w3s&quot;</span>).attr(&#123;<br>    <span class="hljs-string">&quot;href&quot;</span> : <span class="hljs-string">&quot;http://www.baidu.com.cn/jquery&quot;</span>,<br>    <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot; jQuery Tutorial&quot;</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="添加新的-html-内容">3. 添加新的 HTML 内容</h3><p>添加新内容的四个 jQuery 方法：</p><ul><li><strong>append()</strong> - 在被选元素的结尾插入内容，变成lastChild</li><li><strong>prepend()</strong> - 在被选元素的开头插入内容，变成firstChild</li><li><strong>after()</strong> - 在被选元素之后插入内容，变成前面的兄弟</li><li><strong>before()</strong> - 在被选元素之前插入内容，变成后面的兄弟</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn1&quot;</span>&gt;</span>显示文本<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      $(<span class="hljs-string">&quot;#btn1&quot;</span>).click(appendText);  <span class="hljs-comment">// 直接写函数名就行</span></span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendText</span>(<span class="hljs-params"></span>)</span></span><br>      &#123;<br><span class="javascript">          <span class="hljs-keyword">var</span> txt1 = <span class="hljs-string">&quot;&lt;p&gt;Text1.&lt;/p&gt;&quot;</span>; <span class="hljs-comment">// 以 HTML 创建新元素</span></span><br><span class="javascript">          <span class="hljs-keyword">var</span> txt2 = $(<span class="hljs-string">&quot;&lt;p&gt;&lt;/p&gt;&quot;</span>).text(<span class="hljs-string">&quot;Text2.&quot;</span>); <span class="hljs-comment">// 以 jQuery 创建新元素</span></span><br><span class="javascript">          <span class="hljs-keyword">var</span> txt3 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;p&quot;</span>); <span class="hljs-comment">// 以 DOM 创建新元素</span></span><br><span class="javascript">          txt3.innerHTML=<span class="hljs-string">&quot;Text3.&quot;</span>;</span><br><span class="javascript">          $(<span class="hljs-string">&quot;#test1&quot;</span>).append(txt1, txt2, txt3); <span class="hljs-comment">// 追加新元素</span></span><br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="删除元素内容">4. 删除元素/内容</h3><p>如需删除元素和内容，可使用以下两个 jQuery 方法：</p><ul><li><strong>remove()</strong> - 删除被选元素（及其子元素）</li><li><strong>empty()</strong> - 清空被选元素的子元素，被选元素依然存在</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;#div1&quot;</span>).remove();<br>$(<span class="hljs-string">&quot;#div1&quot;</span>).empty();<br></code></pre></td></tr></table></figure><p>remove() 方法也可接受一个参数，允许对被删元素进行过滤。 该参数可以是任何 jQuery 选择器的语法。 下面的例子删除 class=&quot;italic&quot; 的所有元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;p&quot;</span>).remove(<span class="hljs-string">&quot;.italic&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="jquery-操作样式">5. jQuery 操作样式</h3><ul><li><strong>addClass()</strong> - 向被选元素添加一个或多个类</li><li><strong>removeClass()</strong> - 从被选元素删除一个或多个类</li><li><strong>toggleClass()</strong> - 对被选元素进行添加/删除类的切换操作</li><li><strong>css()</strong> - 设置或返回样式属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&quot;h1,h2,p&quot;</span>).addClass(<span class="hljs-string">&quot;blue&quot;</span>);<br>    $(<span class="hljs-string">&quot;div&quot;</span>).addClass(<span class="hljs-string">&quot;important&quot;</span>);<br>&#125;);<br><br>$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;#div1&quot;</span>).addClass(<span class="hljs-string">&quot;important blue&quot;</span>);<br>&#125;);<br><br>$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;h1,h2,p&quot;</span>).removeClass(<span class="hljs-string">&quot;blue&quot;</span>);<br>&#125;);<br><br>$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;h1,h2,p&quot;</span>).toggleClass(<span class="hljs-string">&quot;blue&quot;</span>);<br>&#125;);<br><br>$(<span class="hljs-string">&quot;p&quot;</span>).css(<span class="hljs-string">&quot;background-color&quot;</span>,<span class="hljs-string">&quot;yellow&quot;</span>);<br><br>$(<span class="hljs-string">&quot;p&quot;</span>).css(&#123;<br>    <span class="hljs-string">&quot;background-color&quot;</span>:<span class="hljs-string">&quot;yellow&quot;</span>,<br>    <span class="hljs-string">&quot;font-size&quot;</span>:<span class="hljs-string">&quot;200%&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="jquery-遍历">jQuery 遍历</h2><h3 id="遍历-dom">遍历 DOM</h3><ul><li>length：对象的长度</li><li>for 循环遍历</li><li>.each() 循环遍历</li><li>.find()/ .children() 等筛选操作</li></ul><p>栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> pList = $(<span class="hljs-string">&#x27;p&#x27;</span>);  <span class="hljs-comment">// pList: jquery对象</span><br>    <span class="hljs-comment">// 第一个p元素</span><br>    <span class="hljs-keyword">var</span> p1 = pList.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">console</span>.log(p1);<br>    <span class="hljs-comment">// 第3个p元素</span><br>    <span class="hljs-keyword">var</span> p2 = pList.get(<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">console</span>.log(p2);<br><br>    <span class="hljs-built_in">console</span>.log(pList);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pList.length; i ++ )&#123;<br>        <span class="hljs-built_in">console</span>.log(pList[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// .each函数循环遍历</span><br>    pList.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, value</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(index, value);<br>    &#125;)<br>    $.each(pList, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, value</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(index, value);<br>    &#125;)<br><br>    <span class="hljs-comment">// 也可以遍历json对象数组 [&#123;&#125;&#123;&#125;]</span><br>    $.each([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;ccc&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, value</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(index, value);<br>    &#125;)<br><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="遍历---祖先">遍历 - 祖先</h3><p>祖先是父、祖父或曾祖父等等。</p><ul><li><strong>parent()</strong> 返回被选元素的直接父元素。该方法只会向上一级对 DOM 树进行遍历。</li><li><strong>parents()</strong> 返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。</li><li><strong>parentsUntil()</strong> 返回介于两个给定元素之间的所有祖先元素。</li></ul><p>栗子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-keyword">var</span> p = $(<span class="hljs-string">&#x27;span&#x27;</span>);</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(p.parent());  <span class="hljs-comment">//jQuery.fn.init [li, prevObject: jQuery.fn.init(1)]</span></span><br>      <br><span class="javascript">  <span class="hljs-built_in">console</span>.log(p.parents());<span class="hljs-comment">// jQuery.fn.init(5) [li, ul, div, body, html, prevObject: jQuery.fn.init(1)]</span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="遍历---后代">遍历 - 后代</h3><p>后代是子、孙、曾孙等等。</p><ul><li><strong>children()</strong> 返回被选元素的所有直接子元素。该方法只会向下一级对 DOM 树进行遍历。</li><li><strong>find()</strong> 返回被选元素的后代元素，一路向下直到最后一个后代。</li></ul><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 返回每个 &lt;div&gt; 元素的所有直接子元素：</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;div&quot;</span>).children();<br>&#125;);<br><br><span class="hljs-comment">// 也可以使用可选参数来过滤对子元素的搜索。</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;div&quot;</span>).children(<span class="hljs-string">&quot;p.1&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 返回属于 &lt;div&gt; 后代的所有 &lt;span&gt; 元素：</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;div&quot;</span>).find(<span class="hljs-string">&quot;span&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 返回 &lt;div&gt; 的所有后代：</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;div&quot;</span>).find(<span class="hljs-string">&quot;*&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="遍历---同胞">遍历 - 同胞</h3><p>同胞拥有相同的父元素。</p><ul><li><strong>siblings()</strong> 返回被选元素的所有同胞元素。</li><li><strong>next()</strong> 返回被选元素的下一个同胞。只返回一个元素。</li><li><strong>nextAll()</strong> 返回被选元素的所有跟随的同胞元素。</li><li><strong>nextUntil()</strong> 返回介于两个给定参数之间的所有跟随同胞元素。</li><li><strong>prev()</strong> 与next方法相反方向</li><li><strong>prevAll()</strong> 与nextAll方法相反方向</li><li><strong>prevUntil()</strong> 与nextUntil方法相反方向</li></ul><h3 id="遍历---过滤">遍历 - 过滤</h3><p>三个最基本的过滤方法是：<strong>first(), last() 和 eq()</strong>，它们允许基于其在一组元素中的位置来选择一个特定的元素。</p><p>其他过滤方法，比如 filter() 和 not() 允许选取匹配或不匹配某项指定标准的元素。</p><p><strong>first() 方法</strong></p><p>返回被选元素的首个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 选取首个 &lt;div&gt; 元素内部的第一个 &lt;p&gt; 元素</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;div p&quot;</span>).first();<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>last() 方法</strong></p><p>last() 方法返回被选元素的最后一个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 选择最后一个 &lt;div&gt; 元素中的最后一个 &lt;p&gt; </span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;div p&quot;</span>).last();<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>eq() 方法</strong></p><p>eq() 方法返回被选元素中带有指定索引号的元素。索引号从 0 开始，因此首个元素的索引号是 0 而不是 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 选取第二个 &lt;p&gt; 元素（索引号 1）：</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;p&quot;</span>).eq(<span class="hljs-number">1</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>filter() 方法</strong></p><p>规定一个标准，不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 返回带有类名 &quot;intro&quot; 的所有 &lt;p&gt; 元素</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;p&quot;</span>).filter(<span class="hljs-string">&quot;.intro&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>not() 方法</strong></p><p>not() 方法返回不匹配标准的所有元素。 not() 方法与 filter() 相反。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 返回不带有类名 &quot;intro&quot; 的所有 &lt;p&gt; 元素</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">&quot;p&quot;</span>).not(<span class="hljs-string">&quot;.intro&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="链式调用">链式调用</h3><p>jQuery 支持链接（chaining）的技术，允许在相同的元素上运行多条 jQuery 命令，一条接 着另一条这样的话，浏览器就不必多次查找相同的元素。如需链接一个动作，只需简单地把该动作 追加到之前的动作上。</p><p>举个栗子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jquery/jquery-3.4.1.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-text user-input&quot;</span> <span class="hljs-attr">my-user</span>=<span class="hljs-string">&#x27;张三&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;我的用户名&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;changsha&#x27;</span>&gt;</span>长沙<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beijing&quot;</span> <span class="hljs-attr">areaId</span>=<span class="hljs-string">&#x27;0&#x27;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>海南<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span>&gt;</span><br>        查看详细<br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>内容：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>文字描述<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">// 构建DOM对象</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> htmlDom = $(<span class="hljs-string">&#x27;&lt;p class=&quot;test&quot;/&gt;&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(htmlDom);</span><br><br><span class="javascript">            <span class="hljs-comment">// 添加到html </span></span><br><span class="javascript">            htmlDom.appendTo(<span class="hljs-string">&#x27;body&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-comment">// $.(&#x27;body&#x27;).append(htmlDom);</span></span><br><br><span class="javascript">            <span class="hljs-comment">//在Dom中添加内容</span></span><br><span class="handlebars"><span class="xml">            htmlDom.html(&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是新加的<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#x27;);</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;body&#x27;</span>).append(htmlDom);</span><br><br><span class="javascript">            <span class="hljs-comment">// 设置内容</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#beijing&#x27;</span>).html(<span class="hljs-string">&#x27;&lt;span&gt;我是新的北京&lt;/span&gt;&#x27;</span>);          </span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#beijing&#x27;</span>).attr(<span class="hljs-string">&#x27;areaId&#x27;</span>, <span class="hljs-string">&#x27;666&#x27;</span>)</span><br><br><span class="javascript">            <span class="hljs-comment">// 添加新的class</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#beijing&#x27;</span>).addClass(<span class="hljs-string">&#x27;newclass&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-comment">// 移除class</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#beijing&#x27;</span>).removeClass(<span class="hljs-string">&#x27;area&#x27;</span>);</span><br><br><span class="javascript">            <span class="hljs-comment">// 操作css样式</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#changsha&#x27;</span>).css(&#123;</span><br><span class="javascript">                <span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;yellow&#x27;</span>,</span><br><span class="javascript">                <span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&#x27;black&#x27;</span></span><br>            &#125;)<br><br><span class="javascript">            <span class="hljs-comment">// 隐藏元素</span></span><br><span class="javascript">            <span class="hljs-comment">// $(&#x27;#info&#x27;).hide();</span></span><br><span class="javascript">            <span class="hljs-comment">// 显示元素</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#info&#x27;</span>).show();</span><br><br><span class="javascript">            <span class="hljs-comment">// jQuery的链式调用</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> myDom = $(<span class="hljs-string">&#x27;&lt;p/&gt;&#x27;</span>).text(<span class="hljs-string">&#x27;你好&#x27;</span>).append(<span class="hljs-string">&#x27;&lt;span&gt;, 小张&lt;/span&gt;&#x27;</span>).appendTo(<span class="hljs-string">&#x27;body&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(myDom);</span><br>        &#125;)<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="jquery-核心">jQuery 核心</h2><h3 id="核心函数">核心函数</h3><h4 id="jqueryselectorcontext"><code>jQuery([selector,[context]])</code></h4><p>接收一个选择器字符串，然后用这个字符串去匹配一组元素。</p><p><strong>jQuery 的核心功能都是通过这个函数实现的。</strong> jQuery中的一切都基于这个函数，或者说都是在以某种方式使用这个函数。默认情况下, 如果没有指定context参数，<code>$()</code> 将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个 context 中查找。</p><h4 id="jqueryhtmlownerdocument"><code>jQuery(html,[ownerDocument])</code></h4><p>根据原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 DOM 元素。同时设置一系列的属性、事件等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;&lt;div&gt;&quot;</span>, &#123;<br>    <span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;test&quot;</span>,<br>    text: <span class="hljs-string">&quot;Click me!&quot;</span>,<br>    click: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-built_in">this</span>).toggleClass(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>&#125;).appendTo(<span class="hljs-string">&quot;body&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="循环方法eachcallback">循环方法：<code>each(callback)</code></h4><p>循环元素并执行callback函数。</p><p>函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。</p><p>如果想得到 jQuery对象，可以使用 <code>$(this)</code> 函数。 可以使用 <code>'return'</code> 来提前跳出 <code>each()</code> 循环。</p><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button&gt;Change colors&lt;/button&gt;<br>&lt;div&gt;<span class="hljs-number">0</span>&lt;/div&gt; <br>&lt;div&gt;<span class="hljs-number">1</span>&lt;/div&gt;<br>&lt;div&gt;<span class="hljs-number">2</span>&lt;/div&gt; <br>&lt;div&gt;<span class="hljs-number">3</span>&lt;/div&gt;<br>&lt;div id=<span class="hljs-string">&quot;stop&quot;</span>&gt;Stop here&lt;/div&gt; <br>&lt;div&gt;&lt;/div&gt;<br>&lt;div&gt;&lt;/div&gt;<br>&lt;div&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <br>    $(<span class="hljs-string">&quot;div&quot;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, domEle</span>) </span>&#123; <br>        <span class="hljs-comment">// domEle == this </span><br>        $(domEle).css(<span class="hljs-string">&quot;backgroundColor&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>); <br>        <span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">this</span>).is(<span class="hljs-string">&quot;#stop&quot;</span>)) &#123; <br>            $(<span class="hljs-string">&quot;span&quot;</span>).text(<span class="hljs-string">&quot;Stopped at div index #&quot;</span> + index); <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        &#125; <br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>输出：Stopped at div index #4，并且前四个 div 背景变成黄色。</p></blockquote><h3 id="jquery-对象与-dom-对象的转换">jQuery 对象与 DOM 对象的转换</h3><p><strong>什么是 jQuery 对象？</strong></p><p>答：就是通过 jQuery 包装 DOM 对象后产生的对象。jQuery 对象是 jQuery 独有的，可以使用 jQuery 里的方法。</p><p>栗：<code>$(&quot;#test&quot;).html()</code></p><p>意思是指：获取 ID 为 test 的元素内的 html 代码。其中 <code>html()</code> 是 jQuery 里的方法。 这段代码等同于用 DOM 实现代码： <code>document.getElementById(&quot;id&quot;).innerHTML;</code></p><p><strong>虽然 jQuery 对象是包装 DOM 对象后产生的，但是 jQuery 无法使用 DOM 对象的任何方法，同理 DOM 对象也不能使用 jQuery 里的方法 。</strong></p><h4 id="jquery-对象转成-dom-对象">jQuery 对象转成 DOM 对象</h4><p>由于 jQuery 对象本身是一个集合。所以如果 jQuery 对象要转换为 Dom 对象则必须取出其中的某一项， 一般可通过索引取出。</p><p>两种转换方式将一个 jQuery 对象转换成 DOM 对象：<code>[index]</code> 和 <code>.get(index)</code>。</p><ol type="1"><li><p>jQuery 对象是一个数据对象，可以通过 <code>[index]</code> 的方法，来得到相应的 DOM 对象。</p></li><li><p>jQuery 本身提供，通过 <code>.get(index)</code> 方法，得到相应的 DOM 对象</p></li></ol><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;p id=<span class="hljs-string">&quot;txt&quot;</span>&gt;This is a paragraph.&lt;/p&gt;<br>&lt;script&gt;<br>    <span class="hljs-keyword">var</span> p_jq_obj = $(<span class="hljs-string">&#x27;#txt&#x27;</span>) ;  <span class="hljs-comment">// jQuery对象</span><br>    <span class="hljs-keyword">var</span> p_dom_obj = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;txt&#x27;</span>);  <span class="hljs-comment">// DOM对象</span><br><span class="hljs-comment">// jQuery 对象转成 DOM 对象</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;jQuery:&#x27;</span>, p_jq_obj[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;jQuery:&#x27;</span>, p_jq_obj.get(<span class="hljs-number">0</span>));<br>    <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DOM:&#x27;</span>, p_dom_obj);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/jQuery 对象转成 DOM 对象.png"style="width:50%;"/></center><h4 id="dom-对象转成-jquery-对象">DOM 对象转成 jQuery 对象</h4><p>对于已经是一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jQuery对象了。</p><p>语法：<code>$(DOM对象)</code></p><p>转换后，就可以任意使用jQuery的方法了。</p><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;p id=<span class="hljs-string">&quot;txt&quot;</span>&gt;This is a paragraph.&lt;/p&gt;<br><br>    &lt;script&gt;<br>      <span class="hljs-keyword">var</span> text_jq_obj = $(<span class="hljs-string">&#x27;#txt&#x27;</span>) ;  <span class="hljs-comment">// jQuery对象</span><br>      <span class="hljs-keyword">var</span> text_dom_obj = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;txt&#x27;</span>);  <span class="hljs-comment">// DOM对象</span><br>      <span class="hljs-comment">// console.log(&#x27;jQuery:&#x27;, text_jq_obj[0]);</span><br><br>  <span class="hljs-comment">// DOM 原生方法</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DOM:&#x27;</span>, text_dom_obj.innerHTML);<br>  <span class="hljs-comment">// DOM对象转成jQuery对象后，可以使用jQuery对象的方法</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DOM:&#x27;</span>, $(text_dom_obj).text());<br></code></pre></td></tr></table></figure><p>控制台输出：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/DOM 对象转成 jQuery 对象 .png"style="width:50%;"/></center><h4 id="jquery----this-和-this-的区别">jQuery -- this 和 $(this) 的区别</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>测试 this 与 $(this)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>this是一个DOM对象，有innerHTML方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;p&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.innerHTML);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>$(this)是一个jQuery对象，有text()方法！</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;p&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log($(<span class="hljs-built_in">this</span>).text());<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="jquery-ajax">jQuery AJAX</h2><p>AJAX 是与服务器交换数据的艺术，它在不重载全部页面的情况下，实现了对部分网页的更新。</p><p><strong>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。</strong></p><p>简短地说，<strong>在不重载整个网页的情况下</strong>，AJAX 通过后台加载数据，并在网页上进行显示（更新网页）。</p><p>jQuery 提供多个与 AJAX 有关的方法，这些方法对原生ajax进行了进一步的封装，使用起来更方便 更简单。通过 jQuery AJAX 方法，使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、 HTML、XML 或 JSON - 同时能够把这些外部数据直接载入网页的被选元素中。</p><p><strong>异步请求有什么好处？</strong></p><ul><li>在不重新加载页面的情况下更新页面</li><li>页面加载完成后请求/接收数据</li><li>在后台向服务器发送数据</li></ul><h3 id="ajax-原理">AJAX 原理</h3><ol type="1"><li>创建 XMLHttpRequest/ActiveObject 对象</li><li>注册回调函数</li><li>配置请求参数</li><li>发送请求</li><li>创建回调</li></ol><h3 id="load-方法">load() 方法</h3><p>load() 方法从服务器加载数据，并把返回的数据放入被选元素中。</p><h3 id="selector.loadurldatacallback">$(selector).load(URL,data,callback);</h3><ul><li><p>必需的 URL 参数规定希望加载的 URL。</p></li><li><p>可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。</p></li><li><p>可选的 callback 参数是 load() 方法完成后所执行的函数名称。 <strong>callback</strong> 参数规定当 <code>load()</code> 方法完成后所要允许的回调函数。</p><p>回调函数可以设置不同的参数：</p><ul><li>responseTxt - 包含调用成功时的结果内容</li><li>statusTXT - 包含调用的状态</li><li>xhr - 包含 XMLHttpRequest 对象</li></ul></li></ul><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ajax的load方法使用</span><br>$(<span class="hljs-string">&#x27;#button1&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    $(<span class="hljs-string">&#x27;#test&#x27;</span>).load(<span class="hljs-string">&#x27;/static/1.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, status, xhr</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span>(status == <span class="hljs-string">&#x27;success&#x27;</span>)&#123;<br>            $(<span class="hljs-built_in">this</span>).text(data);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            $(<span class="hljs-built_in">this</span>).text(<span class="hljs-string">&#x27;load加载失败&#x27;</span>)<br>        &#125;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="jquery-ajax-方法">jQuery ajax() 方法</h3><p>该方法是 jQuery 底层 AJAX 实现。get,post 等方法都是在底层调用它。<code>$.ajax()</code> 返回其创建的 XMLHttpRequest 对象。</p><p>关于<strong>XMLHttpRequest 对象</strong></p><p>XMLHttpRequest 对象<strong>用于在后台与服务器交换数据</strong></p><p>XMLHttpRequest 对象的几种状态:</p><ul><li>0：对象没有完成初始化</li><li>1：对象开始发送请求</li><li>2：对象的请求发送完成</li><li>3：对象开始读取服务器响应</li><li>4：对象读取服务器响应结束</li></ul><p><strong>语法： <code>jQuery/$.ajax([settings])</code></strong></p><p>参数settings用于配置 Ajax 请求的键值对集合。以下是一些重要参数的解释：</p><ol type="1"><li><p><strong>context</strong></p><p>类型：Object</p><p>这个对象用于设置 Ajax 相关回调函数的上下文。也就是说，让回调函数内 this 指向这个对象（如果不设 定这个参数，那么 this 就指向调用本次 AJAX 请求时传递的 options 参数）。比如指定一个 DOM 元素 作为 context 参数，这样就设置了 success 回调函数的上下文为这个 DOM 元素。</p></li><li><p><strong>data</strong></p><p>类型：String</p><p>发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[&quot;bar1&quot;, &quot;bar2&quot;]} 转换为 '&amp;foo=bar1&amp;foo=bar2'。</p></li><li><p><strong>dataType</strong></p><p>类型：String</p><p>预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。可用值:</p><ul><li>&quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。</li><li>&quot;html&quot;: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。</li><li>&quot;script&quot;: 返回纯文本 JavaScript 代码。</li><li>&quot;json&quot;: 返回 JSON 数据 。</li><li>&quot;jsonp&quot;: JSONP 格式。</li><li>&quot;text&quot;: 返回纯文本字符串</li></ul></li><li><p><strong>type</strong></p><p>类型：String</p><p>默认值: &quot;GET&quot;。请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)， 默认为 &quot;GET&quot;。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。</p></li><li><p><strong>url</strong></p><p>类型：String</p><p>默认值: 当前页地址。发送请求的地址。</p></li><li><p><strong>username</strong></p><p>类型：String</p><p>用于响应 HTTP 访问认证请求的用户名。</p></li><li><p><strong>password</strong></p><p>类型：String</p><p>用于响应 HTTP 访问认证请求的密码</p></li><li><p><strong>error</strong></p><p>类型：Function</p><p>默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。 有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。 如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 &quot;timeout&quot;, &quot;error&quot;, &quot;notmodified&quot; 和 &quot;parsererror&quot;。 这是一个 Ajax 事件。</p></li><li><p><strong>success</strong></p><p>类型：Function</p><p>请求成功后的回调函数。</p><p>参数：由服务器返回，并根据 dataType 参数进行处理后 的数据；描述状态的字符串。 这是一个 Ajax 事件。</p></li></ol><p>栗子：</p><p>views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-comment"># Create your views here.</span><br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&quot;ajax_test.html&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">request</span>):</span><br>    ret = &#123;<br>        <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br>        <span class="hljs-string">&quot;messages&quot;</span>: <span class="hljs-literal">None</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;POST&quot;</span>:<br>    print(request.POST)<br>        <span class="hljs-keyword">if</span> request.POST.get(<span class="hljs-string">&quot;type&quot;</span>) == <span class="hljs-string">&quot;ajax&quot;</span>:<br>            ret[<span class="hljs-string">&quot;messages&quot;</span>] = <span class="hljs-string">&quot;ajax()方法是核心方法！&quot;</span><br>        <span class="hljs-keyword">elif</span> request.POST.get(<span class="hljs-string">&quot;type&quot;</span>) == <span class="hljs-string">&quot;load&quot;</span>:<br>            ret[<span class="hljs-string">&quot;messages&quot;</span>] = <span class="hljs-string">&quot;load()方法将返回值载入标签内！&quot;</span><br>        <span class="hljs-keyword">elif</span> request.POST.get(<span class="hljs-string">&quot;type&quot;</span>) == <span class="hljs-string">&quot;post&quot;</span>:<br>            ret[<span class="hljs-string">&quot;messages&quot;</span>] = <span class="hljs-string">&quot;post()方法将返回值载入标签内！&quot;</span><br>    <br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;GET&quot;</span>:<br>    print(request.GET)<br>    ret[<span class="hljs-string">&quot;messages&quot;</span>] = <span class="hljs-string">&quot;get()方法返回服务器信息！&quot;</span><br>    <br>    <span class="hljs-keyword">return</span> HttpResponse(json.dumps(ret))<br></code></pre></td></tr></table></figure><p>页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>ajax_test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/static/jquery/jquery-3.4.1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>请点击下面按钮，通过jQuery ajax改变这段文本<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button1&quot;</span>&gt;</span>发送load请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button2&quot;</span>&gt;</span>发送get请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button3&quot;</span>&gt;</span>发送post请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button4&quot;</span>&gt;</span>发送ajax请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">// ajax的load方法使用</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#button1&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                $(<span class="hljs-string">&#x27;#test&#x27;</span>).load(<span class="hljs-string">&#x27;/static/1.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, status, xhr</span>) </span>&#123;</span><br><span class="javascript">                    <span class="hljs-keyword">if</span>(status == <span class="hljs-string">&#x27;success&#x27;</span>)&#123;</span><br><span class="javascript">                        $(<span class="hljs-built_in">this</span>).text(data);</span><br><span class="javascript">                    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript">                        $(<span class="hljs-built_in">this</span>).text(<span class="hljs-string">&#x27;load加载失败&#x27;</span>)</span><br>                    &#125;<br>                &#125;);<br>            &#125;);<br><br><span class="javascript">            <span class="hljs-comment">// 使用get方式</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#button2&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                $.get(</span><br><span class="javascript">                    <span class="hljs-string">&#x27;/ajax/&#x27;</span>,</span><br><span class="javascript">                    &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;get&#x27;</span>&#125;,</span><br><span class="javascript">                    <span class="hljs-comment">// 回调函数</span></span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, status</span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-keyword">if</span>(status == <span class="hljs-string">&#x27;success&#x27;</span>)&#123;</span><br><span class="javascript">                            <span class="hljs-comment">// 由于收到的data是个字符串格式，需要用json转换为object格式</span></span><br><span class="javascript">                            $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-built_in">JSON</span>.parse(data).messages);</span><br><span class="javascript">                        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript">                            $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-string">&#x27;get请求失败&#x27;</span>);</span><br>                        &#125;<br>                    &#125;<br>                );<br>            &#125;);<br><br><span class="javascript">            <span class="hljs-comment">// 使用post方式</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#button3&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                <span class="hljs-keyword">var</span> data = $(<span class="hljs-string">&#x27;input&#x27;</span>).val();</span><br>                alert(data);<br><span class="javascript">                $.post(</span><br><span class="javascript">                    <span class="hljs-string">&#x27;/ajax/&#x27;</span>,</span><br><span class="javascript">                    &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: data&#125;,</span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, status</span>) </span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">if</span>(status == <span class="hljs-string">&#x27;success&#x27;</span>)&#123;</span><br><span class="javascript">                            <span class="hljs-comment">// 由于收到的data是个字符串格式，需要用json转换为object格式</span></span><br><span class="javascript">                            $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-built_in">JSON</span>.parse(data).messages);</span><br><span class="javascript">                        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript">                            $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-string">&#x27;get请求失败&#x27;</span>);</span><br>                        &#125;<br>                    &#125;<br>                );<br>            &#125;);<br><br><span class="javascript">            <span class="hljs-comment">// 使用ajax方式</span></span><br><span class="javascript">            $(<span class="hljs-string">&#x27;#button4&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                $.ajax(&#123;</span><br><span class="javascript">                    url: <span class="hljs-string">&#x27;/ajax/&#x27;</span>,</span><br><span class="javascript">                    data: &#123;<span class="hljs-string">&#x27;username&#x27;</span>:<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>&#125;,</span><br><span class="javascript">                    type: <span class="hljs-string">&#x27;POST&#x27;</span>,  <span class="hljs-comment">// 写method: &#x27;POST&#x27; 也行</span></span><br><span class="javascript">                    dataType: <span class="hljs-string">&#x27;json&#x27;</span>,</span><br><span class="javascript">                    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="javascript">                        <span class="hljs-comment">// 由于收到的data是个字符串格式，需要用json转换为object格式</span></span><br><span class="javascript">                        $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-built_in">JSON</span>.parse(data).mesg);</span><br>                    &#125;,<br><span class="javascript">                    error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                        $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-string">&#x27;ajax请求失败&#x27;</span>);</span><br>                    &#125;<br>                &#125;);<br>            &#125;);<br><br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一些 jQuery Ajax 的快捷函数：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/一些 jQuery Ajax 的操作函数.png"style="width:90%;"/></center><h3 id="jquery---ajax-get-和-post-方法">jQuery - AJAX get() 和 post() 方法</h3><p>jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。 两种在客户端和服务器端进行请求-响应的常用方法是：GET 和 POST。</p><ul><li>GET - 从指定的资源请求数据</li><li>POST - 向指定的资源提交要处理的数据</li></ul><h4 id="get-方法"><code>$.get()</code> 方法</h4><p><code>$.get(URL,callback);</code> 方法通过 HTTP GET 请求从服务器上请求数据。</p><ul><li>必需的 URL 参数规定希望请求的 URL。</li><li>可选的 callback 参数是请求成功后所执行的函数名。<strong>第一个回调参数存有被请求页面的内容</strong>，第二个回调参数存有请求的状态。</li></ul><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用get方式</span><br>$(<span class="hljs-string">&#x27;#button2&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    $.get(<br>        <span class="hljs-string">&#x27;/ajax/&#x27;</span>,<br>        &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;get&#x27;</span>&#125;,<br>        <span class="hljs-comment">// 回调函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, status</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span>(status == <span class="hljs-string">&#x27;success&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 由于收到的data是个字符串格式，需要用json转换为object格式</span><br>                $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-built_in">JSON</span>.parse(data).messages);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-string">&#x27;get请求失败&#x27;</span>);<br>            &#125;<br>        &#125;<br>    );<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="post-方法"><code>$.post()</code> 方法</h4><p><code>$.get(URL,data,callback);</code> 方法通过 HTTP POST请求从服务器上请求数据。</p><ul><li>必需的 URL 参数规定希望请求的 URL 。</li><li>可选的 data 参数规定连同请求发送的数据，要求object格式。</li><li>可选的 callback 参数是请求成功后所执行的函数名。</li></ul><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用post方式</span><br>$(<span class="hljs-string">&#x27;#button3&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> data = $(<span class="hljs-string">&#x27;input&#x27;</span>).val();<br>    alert(data);<br>    $.post(<br>        <span class="hljs-string">&#x27;/ajax/&#x27;</span>,<br>        &#123;<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: data&#125;,<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, status</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span>(status == <span class="hljs-string">&#x27;success&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 由于收到的data是个字符串格式，需要用json转换为object格式</span><br>                $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-built_in">JSON</span>.parse(data).messages);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                $(<span class="hljs-string">&#x27;#test&#x27;</span>).text(<span class="hljs-string">&#x27;get请求失败&#x27;</span>);<br>            &#125;<br>        &#125;<br>    );<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>什么是接口？</strong></p><p>接口也叫API，在获取数据或提取表单时，做前后端分离时，会把前端的数据给到后台。</p><p>接口是对内部业务逻辑的封装。</p><p>步骤：</p><ol type="1"><li>在后端（视图层）编写数据接口</li><li>给前端（模板层）通过 ajax 调用数据接口</li><li>渲染页面、绑定功能</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOM</title>
    <link href="/2021/03/01/BOM/"/>
    <url>/2021/03/01/BOM/</url>
    
    <content type="html"><![CDATA[<h1 id="bom">BOM</h1><p><strong>BOM</strong>：浏览器对象模型（Browser Object Model）</p><p>浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器“对话”。尚无正式标准，但基本通用。</p><h2 id="browser-对象">Browser 对象</h2><h3 id="window-对象">Window 对象</h3><p><strong>Window 对象表示浏览器中打开的窗口。</strong></p><ul><li>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</li><li>全局变量是 window 对象的属性。</li><li>全局函数是 window 对象的方法。</li></ul><p><u>HTML DOM 的 document 也是 window 对象的属性之一</u>：</p><p><code>window.document.getElementById(&quot;header&quot;);</code> 等同于 <code>document.getElementById(&quot;header&quot;);</code></p><h3 id="screen-对象">Screen 对象</h3><p>Screen 对象包含有关客户端显示屏幕的信息。</p><blockquote><p>window.screen 对象在编写时可以不使用 window 这个前缀。</p></blockquote><p>Screen 对象一些属性：</p><ul><li><p><code>screen.availWidth</code> ：可用的屏幕宽度</p><p>属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如窗口任务栏。</p></li><li><p><code>screen.availHeight</code> ：可用的屏幕宽度</p><p>属性返回访问者屏幕的高度，以像素计，减去界面特性，比如窗口任务栏。</p></li></ul><h3 id="location-对象">Location 对象</h3><p>window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。</p><blockquote><p>window.location 对象在编写时可不使用 window 这个前缀。</p></blockquote><p>Location 对象一些属性：</p><ul><li><p><code>location.hostname</code> 返回 web 主机的域名</p></li><li><code>location.pathname</code> 返回当前页面的路径和文件名</li><li><code>location.port</code> 返回 web 主机的端口 （80 或 443）</li><li><code>location.protocol</code> 返回所使用的 web 协议（http:// 或 https://）</li><li><code>location.href</code> 返回当前页面的 URL</li><li><p><code>location.assign()</code> 该方法加载新的文档。</p></li></ul><h3 id="history-对象">History 对象</h3><p>window.history 对象包含浏览器的历史。</p><blockquote><p>在编写时可不使用 window 这个前缀。</p></blockquote><p>为了保护用户隐私，对 JavaScript 访问该对象的方法做出了限制。</p><p>history 对象一些属性：</p><ul><li><code>history.back()</code> - 与在浏览器点击后退按钮相同</li><li><code>history.forward()</code> - 与在浏览器中点击按钮向前相同</li></ul><h3 id="navigator-对象">Navigator 对象</h3><p><strong>window.navigator 对象包含有关访问者浏览器的信息。</strong></p><p>navigator 对象一些属性：</p><ul><li><code>appCodeName</code> ：返回浏览器的代码名。</li><li><code>appMinorVersion</code> ：返回浏览器的次级版本。</li><li><code>appName</code> ：返回浏览器的名称</li><li><code>appVersion</code> ：返回浏览器的平台和版本信息。</li><li><code>browserLanguage</code> ：返回当前浏览器的语言。</li><li><code>cookieEnabled</code> ：返回指明浏览器中是否启用 cookie 的布尔值。</li><li><code>userAgent</code> ：返回由客户机发送服务器的 user-agent 头部的值。</li><li><code>systemLanguage</code> ：返回 OS 使用的默认语言。</li></ul><h2 id="javascript-消息框">JavaScript 消息框</h2><p>可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框。</p><h3 id="警告框">1. 警告框</h3><p>警告框经常用于确保用户可以得到某些信息。当警告框出现后，用户需要点击确定按钮才能继续进行操作。</p><p>语法： <code>alert(&quot;文本&quot;)</code></p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/alert-1.png" alt="" style="width:70%;"/></center><h3 id="确认框">2. 确认框</h3><p>用于使用户可以验证或者接受某些信息。当确认框出现后，用户需要点击确定或者取消按钮才能继续进行 操作。如果用户点击确认，那么返回值为 true。如果用户点击取消，那么返回值为 false。</p><p>语法： <code>confirm(&quot;文本&quot;)</code></p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/confirm-1.png" alt="" style="width:70%;"/></center><p>点击确认后，控制台输出：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/confirm-3.png" alt="" style="width:100%;"/></center><h3 id="提示框">3. 提示框</h3><p>提示框经常用于提示用户在进入页面前输入某个值。 当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。 如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。</p><p>语法： <code>prompt(&quot;文本&quot;,&quot;默认值&quot;)</code></p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/prompt-1.png" alt="" style="width:70%;"/></center><p>点击确认后，控制台输出：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/prompt-2.png" alt="image-20210312201254083" /><figcaption>image-20210312201254083</figcaption></figure><h2 id="javascript-计时">JavaScript 计时</h2><p>在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。称之为计时事件。</p><p>两个关键方法是:</p><ul><li><code>setTimeout()</code> ：未来的某时执行代码</li><li><code>clearTimeout()</code> ：取消 setTimeout()</li></ul><h3 id="settimeout">1. setTimeout()</h3><p>语法：<code>var t = setTimeout(&quot;javascript语句&quot;,毫秒)</code></p><p>setTimeout() 方法会返回某个值。在上面的语句中，值被储存在名为 t 的变量中。假如你希望取消这个 setTimeout()，你可以使用这个变量名来指定它。 - -</p><ul><li><p>setTimeout() 的第一个参数是含有 JavaScript 语句的字符串。这个语句可能诸如 &quot;alert('5 seconds!')&quot;，或者对函数的调用，诸如 alertMsg()&quot;。</p></li><li><p>第二个参数指示从当前起多少毫秒后执行第一个参数。 1000 毫秒等于一秒</p></li></ul><p>栗子：这个例子的按钮被点击时，一个警告框会在2秒钟后弹出。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按钮&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;f()&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;alert(&#x27;2s弹出警告框&#x27;)&quot;</span>, <span class="hljs-number">2000</span>);</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>栗子2：无穷循环</p><p>要创建一个运行于无穷循环中的计时器，需要编写一个函数来调用其自身。在下面的例子中，当按钮被点击后，输入域便从 0 开始计数。</p><h3 id="cleartimeout">2. clearTimeout()</h3><p>语法：<code>clearTimeout(setTimeout_variable)</code></p><p>栗子：在上面的计时器其中加入一个停止按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;开始计时&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;f()&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;停止计时&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;f2()&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span>等待开始计时...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> time;  <span class="hljs-comment">// 作为计时器</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> sec = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;time&#x27;</span>);</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        sec.innerHTML = i + <span class="hljs-string">&#x27;秒&#x27;</span>;</span><br>        i ++ ;<br><span class="javascript">        time = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;f()&quot;</span>, <span class="hljs-number">1000</span>);</span><br>    &#125;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">clearTimeout</span>(time);</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/clearTimeout.png" alt="" style="width:25%;"/></center><h3 id="小练习实现动态显示的钟">小练习：实现动态显示的钟！</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;f()&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> time;  <span class="hljs-comment">// 作为计时器</span></span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br><span class="javascript"><span class="hljs-keyword">var</span> hour = today.getHours();</span><br><span class="javascript"><span class="hljs-keyword">var</span> min = today.getMinutes();</span><br><span class="javascript"><span class="hljs-keyword">var</span> sec = today.getSeconds();</span><br><br>sec = checktime(sec);<br>min = checktime(min);<br><br><span class="javascript"><span class="hljs-keyword">var</span> t = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;time&#x27;</span>);</span><br><span class="javascript">t.innerHTML = hour + <span class="hljs-string">&quot;:&quot;</span> + min + <span class="hljs-string">&quot;:&quot;</span> + sec;</span><br><br><span class="javascript">time = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;f()&quot;</span>, <span class="hljs-number">1000</span>);</span><br>&#125;<br><span class="javascript"><span class="hljs-comment">// 当数字小于10时为数字前面添加0</span></span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checktime</span>(<span class="hljs-params">i</span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>) &#123;</span><br><span class="javascript">i = <span class="hljs-string">&#x27;0&#x27;</span> + i;</span><br>&#125;<br><span class="javascript"><span class="hljs-keyword">return</span> i;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="javascript-cookies">JavaScript Cookies</h2><h3 id="什么是-cookie">什么是 cookie ?</h3><p><strong>cookie 是存储于访问者的计算机中的变量。</strong>每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。可以使用 JavaScript 来创建和取回 cookie 的值。</p><h3 id="有关-cookie-的例子">有关 cookie 的例子：</h3><ol type="1"><li><p>名字 cookie</p><p>当访问者首次访问页面时，也许会填写名字。名字会存储于 cookie 中。当访问者再次访问网站时，会收到类似 “Welcome John!” 的欢迎词。这个名字就是从 cookie 中取到的。</p></li><li><p>密码 cookie</p><p>当访问者首次访问页面时，也许会输入密码。密码也可被存储于 cookie 中。当再次访问网站时，密码就会从 cookie 中取回。</p></li><li><p>日期 cookie</p><p>当访问者首次访问网站时，访问的日期可存储于 cookie 中。当再次访问网站时，可能会收到类似这样 的一条消息：&quot;Your last visit was on Tuesday August 11, 2017!&quot;。日期也是从 cookie 中取回的。</p></li></ol><h3 id="创建和存储-cookie">创建和存储 cookie</h3><p>下例创建一个存储访问者名字的 cookie。当访问者首次访问网站时，会被要求填写姓名。名字会存储于 cookie 中。当访问者再次访问网站时，就会收到欢迎词。</p><p>1.首先，创建一个可在 cookie 变量中存储访问者姓名的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCookie</span>(<span class="hljs-params">c_name,value,expiredays</span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">var</span> exdate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>exdate.setDate(exdate.getDate() + expiredays);<br><span class="hljs-built_in">document</span>.cookie = c_name + <span class="hljs-string">&quot;=&quot;</span> + <span class="hljs-built_in">escape</span>(value) + ((expiredays==<span class="hljs-literal">null</span>) ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;;expires=&quot;</span> + exdate.toGMTString());<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个函数中的参数存有 cookie 的名称、值以及过期天数。首先将天数转换为有效的日期，然后， 将 cookie 名称、值及其过期日期存入 document.cookie 对象。</p><p>2.之后，要创建另一个函数来检查是否已设置 cookie：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCookie</span>(<span class="hljs-params">c_name</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.cookie.length &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>    c_start = <span class="hljs-built_in">document</span>.cookie.indexOf(c_name + <span class="hljs-string">&quot;=&quot;</span>);<br>    <span class="hljs-keyword">if</span> (c_start != -<span class="hljs-number">1</span>)<br>    &#123; <br>    c_start = c_start + c_name.length + <span class="hljs-number">1</span> ;<br>    c_end = <span class="hljs-built_in">document</span>.cookie.indexOf(<span class="hljs-string">&quot;;&quot;</span>,c_start);<br>    <br>            <span class="hljs-keyword">if</span> (c_end == -<span class="hljs-number">1</span>) c_end = <span class="hljs-built_in">document</span>.cookie.length;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">unescape</span>(<span class="hljs-built_in">document</span>.cookie.substring(c_start, c_end));<br>    &#125; <br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>函数首先会检查 document.cookie 对象中是否存有 cookie。假如 document.cookie 对象存有某些 cookie，那么会继续检查我们指定的 cookie 是否已储存。如果找到了我们要的 cookie，就返回值，否则 返回空字符串。</p><p>3.最后，要创建一个函数，这个函数的作用是：如果 cookie 已设置，则显示欢迎词，否则显示提示框 来要求用户输入名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkCookie</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    username = getCookie(<span class="hljs-string">&#x27;username&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (username != <span class="hljs-literal">null</span> &amp;&amp; username != <span class="hljs-string">&quot;&quot;</span>)&#123;<br>        alert(<span class="hljs-string">&#x27;Welcome again &#x27;</span> + username + <span class="hljs-string">&#x27;!&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    username = prompt(<span class="hljs-string">&#x27;Please enter your name:&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">if</span> (username != <span class="hljs-literal">null</span> &amp;&amp; username != <span class="hljs-string">&quot;&quot;</span>)<br>    &#123;<br>    setCookie(<span class="hljs-string">&#x27;username&#x27;</span>, username, <span class="hljs-number">365</span>);<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM</title>
    <link href="/2021/02/28/DOM/"/>
    <url>/2021/02/28/DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="dom">DOM</h1><h2 id="dom-介绍">DOM 介绍</h2><p><strong>DOM</strong>：<u>将文档（页面）表现为结构化的表示方法</u>，使每一个页面元素都是可操控，DOM将网页和脚本以及其他的编程语言联系了起来。通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。不同于 jQuery，DOM 是 JS 原生的， 可直接使用。</p><h3 id="html-dom-文档对象模型">HTML DOM （文档对象模型）</h3><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。</p><p>HTML DOM 模型被构造为对象的树。</p><ul><li>特点：利用 js 控制页面中的所有元素，使页面更加“聪明”。</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210301102139442.png" alt="" style="width:100%;"/></center><h3 id="dom-节点">DOM 节点</h3><p>在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML 。</p><ul><li>整个文档是一个文档节点</li><li>每个元素是元素节点</li><li>元素内的文本是文本节点</li><li>每个元素的属性是属性节点</li><li>注释是注释节点</li></ul><p>节点父、子和同胞</p><p>节点树中的节点彼此拥有层级关系。</p><p>父（parent）、子（child）和同胞（sibling）等术语用于描 述这些关系。父节点拥有子节点。同级的子节点被称为同胞。 在节点树中，顶端节点被称为根（root ）</p><ul><li>每个节点都有父节点、除了根（它没有父节点）</li><li>一个节点可拥有任意数量的子</li><li>同胞是拥有相同父节点的节点</li></ul><p>图片展示了节点树的一部分，以及节点之间的关系：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/dom tree.png" alt="" style="width:50%;"/></center><p>分析下面的 HTML 片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM 教程<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>DOM 第一课<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的 HTML 中：</p><ul><li><code>&lt;html&gt;</code> 节点没有父节点；它是根节点</li><li><code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 的父节点是 <code>&lt;html&gt;</code> 节点</li><li>文本节点 &quot;Hello world!&quot; 的父节点是 <code>&lt;p&gt;</code> 节点</li></ul><p>并且：</p><ul><li><code>&lt;html&gt;</code> 节点拥有两个子节点：<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code></li><li><code>&lt;head&gt;</code> 节点拥有一个子节点：<code>&lt;title&gt;</code> 节点</li><li><u><code>&lt;title&gt;</code> 节点也拥有一个子节点：文本节点 &quot;DOM 教程&quot;</u></li><li><code>&lt;h1&gt;</code> 和 <code>&lt;p&gt;</code> 节点是同胞节点，同时也是 <code>&lt;body&gt;</code> 的子节点</li></ul><p>并且：</p><ul><li><code>&lt;head&gt;</code> 元素是 <code>&lt;html&gt;</code> 元素的首个子节点</li><li><code>&lt;body&gt;</code> 元素是 <code>&lt;html&gt;</code> 元素的最后一个子节点</li><li><code>&lt;h1&gt;</code> 元素是 <code>&lt;body&gt;</code> 元素的首个子节点</li><li><code>&lt;p&gt;</code> 元素是 <code>&lt;body&gt;</code> 元素的最后一个子节点</li></ul><h2 id="html-dom-document-对象">HTML DOM Document 对象</h2><p>每个载入浏览器的 HTML 文档都会成为 Document 对象。</p><p><strong>Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。</strong></p><blockquote><p>提示：Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。</p></blockquote><h3 id="常用-dom-对象方法">常用 DOM 对象方法</h3><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/常用DOM对象方法.png" alt="" style="width:100%;"/></center><p>:chestnut:<a href="#para">栗子可以点击查看本文的这里</a></p><h3 id="查找-html-元素">查找 HTML 元素</h3><p>为了操作 HTML 元素，必须首先找到该元素。</p><ul><li><p>通过 <strong>id</strong> 找到 HTML 元素</p><p><strong>getElementById()</strong> ：返回带有指定 ID 的元素</p></li><li><p>通过 <strong>标签名</strong> 找到 HTML 元素</p><p><strong>getElementsByTagName()</strong>：返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。</p></li><li><p>通过 <strong>类名</strong> 找到 HTML 元素</p><p><strong>getElementsByClassName()</strong>：返回包含带有指定类名的所有元素的节点列表。</p></li></ul><p>举个栗子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>222<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>133<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>141<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>15511<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;p&#x27;</span>);</span><br><span class="javascript"><span class="hljs-comment">// console.log(arr[1].innerHTML);</span></span><br><span class="javascript">colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];</span><br><span class="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i ++ )&#123;</span><br>arr[i].style.color = colors[i];<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个例子，获取了所有 <code>&lt;p&gt;</code> 元素节点，然后给每个 <code>&lt;p&gt;</code> 元素赋对应数组的值。</p><h2 id="dom-的节点属性">DOM 的节点属性</h2><h3 id="innerhtml-属性">innerHTML 属性</h3><p>innerHTML 属性用于获取或替换 HTML 元素的内容。</p><p>栗子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>一个link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> tag = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;area&quot;</span>);</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(tag.innerHTML);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>控制台上打印：<code>广州&lt;a href=&quot;#&quot;&gt;一个link&lt;/a&gt;</code></p><p><code>getElementById</code> 方法获得了 p 标签，而 innerHTML 是属性。 innerHTML 属性可用于获取或改变任意 HTML 元素，包括 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 。</p><h3 id="nodename-属性">nodeName 属性</h3><p>nodeName 属性指的是节点的名称。</p><ul><li>nodeName 是只读的</li><li>元素节点的 nodeName 与标签名相同</li><li>属性节点的 nodeName 与属性名相同</li><li>文本节点的 nodeName 始终是 #text</li><li>文档节点的 nodeName 始终是 #document</li></ul><h3 id="nodevalue-属性">nodeValue 属性</h3><p>nodeValue 属性规定节点的值。</p><ul><li>nodeValue 属性规定节点的值。</li><li>nodeValue 属性规定节点的值。</li><li>nodeValue 属性规定节点的值。</li></ul><h3 id="nodetype-属性">nodeType 属性</h3><p>nodeType 属性返回节点的类型。</p><p>nodeType 是只读的。</p><p>比较重要的节点类型有：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/nodeType.png" alt="" style="width:30%;"/></center><p>举个栗子：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/innerHTML 属性.png" alt="" style="width:100%;"/></center><h2 id="dom-的节点操作"><a name="para">DOM 的节点操作</a></h2><p>DOM的应用场景</p><ul><li>改变 HTML 内容</li><li>改变 CSS 样式</li><li>改变 HTML 属性</li><li>创建新的 HTML 元素</li><li>删除已有的 HTML 元素</li><li>改变事件（处理程序）</li></ul><h3 id="修改-html-内容">1. 修改 HTML 内容</h3><p>改变元素内容的最简答的方法是使用 innerHTML 属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;p1&quot;</span>).innerHTML=<span class="hljs-string">&quot;New text!&quot;</span>;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="改变-html-样式">2. 改变 HTML 样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;p2&quot;</span>).style.color=<span class="hljs-string">&quot;blue&quot;</span>;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="创建新的-html-元素">3. 创建新的 HTML 元素</h3><p>如需向 HTML DOM 添加新元素，<strong>首先必须创建该元素（元素节点），然后把它追加到已有的 元素上。</strong></p><ul><li><code>createElement()</code></li><li><code>createTextNode()</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;d1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>This is one paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>This is another paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="handlebars"><span class="xml">// <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段新创建的段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript"><span class="hljs-keyword">var</span> para = <span class="hljs-built_in">document</span>.createNode(<span class="hljs-string">&#x27;p&#x27;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">var</span> node = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&#x27;这是一段新创建的段落&#x27;</span>);</span><br>   para.appendChild(node);<br>        <br><span class="javascript"><span class="hljs-comment">// 把新创建的加入到div标签里，先找到，再加入</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> parent = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;d1&#x27;</span>);</span><br>parent.appendChild(para);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="改变-html-属性">4. 改变 HTML 属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;link&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;link&quot;</span>).href=<span class="hljs-string">&quot;http://www.sina.com.cn&quot;</span>;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="删除已有的-html-元素">5. 删除已有的 HTML 元素</h3><p>使用 <code>removeChild()</code> 方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>This is another paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> parent = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div1&quot;</span>);</span><br><span class="javascript"><span class="hljs-keyword">var</span> child = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;p1&quot;</span>);</span><br>parent.removeChild(child);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="替换-html-元素">6. 替换 HTML 元素</h3><p>使用 <code>replaceChild()</code> 方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>This is another paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">// 创建一个新的段落</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> para = <span class="hljs-built_in">document</span>.createNode(<span class="hljs-string">&#x27;p&#x27;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">var</span> node = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&#x27;一个新的段落&#x27;</span>);</span><br>    para.appendChild(node);<br><span class="javascript">    <span class="hljs-comment">// 用新的段落替换p1</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> parent = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div1&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">var</span> child = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;p1&quot;</span>);</span><br>    parent.replaceChild(node, child);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <br></code></pre></td></tr></table></figure><h3 id="追加子元素">7. 追加子元素</h3><p>使用 <code>appendChild()</code></p><p>如需向 HTML DOM 添加新元素，首先必须创建该元素，然后把它追加到已有的元素上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>This is another paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> para=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;p&quot;</span>);</span><br><span class="javascript"><span class="hljs-keyword">var</span> node=<span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&quot;This is new.&quot;</span>);</span><br>para.appendChild(node);<br><br><span class="javascript">    <span class="hljs-keyword">var</span> element=<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div1&quot;</span>);</span><br>element.appendChild(para);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="响应事件">响应事件</h2><p><strong>事件</strong>：事件是指被程序发现的行为或发生的事情，而且它可能会被程序处理</p><p>特点：js 的事件，都是以 <strong>on</strong> 开头，有 <strong>onclick、onload、onchange...</strong></p><p>分类：表单事件、鼠标事件、键盘事件...</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210301095843316.png" alt="" style="width:100%;"/></center><h3 id="onload-和-onunload-事件">onload 和 onunload 事件</h3><p><strong>当用户进入或离开页面时，会触发 onload 和 onunload 事件。</strong></p><p>onload 事件可用于检查访客的浏览器类型和版本，以便基于这些信息来加载不同版本的网页。</p><p>onload 和 onunload 事件可用于处理 cookies。</p><p>例：<code>&lt;body onload=&quot;checkCookies()&quot;&gt;</code></p><h3 id="onchange-事件">onchange 事件</h3><p><strong>onchange 事件常用于输入字段的验证。</strong></p><p>例：当用户改变输入字段的内容时，将调用 changeColor () 函数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fname&quot;</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">&quot;changeColor(this)&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span> (<span class="hljs-params">text</span>) </span>&#123;</span><br><span class="javascript">        text.style.color = <span class="hljs-string">&#x27;red&#x27;</span>;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="onmouseover-和-onmouseout-事件">onmouseover 和 onmouseout 事件</h3><p>onmouseover 和 onmouseout 事件可用于在鼠标指针移动到或离开元素时触发函数。</p><p>举个栗子：这个例子是区域内红色写有”Mouse Over Me“，当鼠标移动到区域内变为绿色背景的”Thank You“，鼠标离开区域变回原来的红底”Mouse Over Me“</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">&quot;mOver(this)&quot;</span> <span class="hljs-attr">onmouseout</span>=<span class="hljs-string">&quot;mOut(this)&quot;</span> </span><br><span class="hljs-tag">     <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:red;width:120px;height:20px;padding:40px;&quot;</span>&gt;</span>Mouse Over Me<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mOver</span>(<span class="hljs-params">obj</span>)</span>&#123;</span><br><span class="javascript">        obj.innerHTML=<span class="hljs-string">&quot;Thank You&quot;</span>;</span><br><span class="javascript">        obj.style.backgroundColor = <span class="hljs-string">&quot;green&quot;</span>;</span><br>    &#125;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mOut</span>(<span class="hljs-params">obj</span>)</span>&#123;</span><br><span class="javascript">        obj.innerHTML=<span class="hljs-string">&quot;Mouse Over Me&quot;</span>;</span><br><span class="javascript">        obj.style.backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS练习</title>
    <link href="/2021/02/26/JS%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/02/26/JS%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="js练习">JS练习</h1><h2 id="练习1仿-windows-计算器">练习1：仿 Windows 计算器</h2><h3 id="功能">功能</h3><ol type="1"><li>实现按钮录入实现</li><li>实现基础四则运算功能，并添加必要的异常处理，例如除数为零，不能输入非数字等等</li><li>实现小数点功能能并添加异常处理：小数点只能出现一次</li><li>实现正负号功能</li><li>实现退位功能，已经是最后一位时，显示框显示为0</li></ol><h3 id="使用的知识点">使用的知识点</h3><ol type="1"><li>利用大量的自定义函数实现业务逻辑</li><li>灵活运用事件及事件处理</li><li>培养异常处理的编程方法</li><li>培养并实践利用不同思路实现编程</li></ol><h3 id="code">code</h3><p><strong>html：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>仿计算器<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;c1.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;j1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/mooc.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;init(), init_mooc()  &quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!--页面初始化/加载/刷新--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;num&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div3&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;c&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;←&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;+/-&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;n1&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;6&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;7&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;8&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;9&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;+&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;=&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;m&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mooc&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>js：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*初始化*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;num&quot;</span>);<br>    num.value = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 文本框里面的值</span><br>    num.disabled=<span class="hljs-string">&quot;disabled&quot;</span>;  <span class="hljs-comment">// 不允许输入。光标失效。</span><br>    <span class="hljs-comment">// var n1 = document.getElementById(&quot;n1&quot;);</span><br>    <span class="hljs-comment">// n1.onclick() = function()&#123;</span><br>    <span class="hljs-comment">//     alert(&quot;123&quot;);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <br>    <span class="hljs-comment">/*给每一个按钮添加事件*/</span><br>    <span class="hljs-keyword">var</span> oButton = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;input&quot;</span>);<br>    <span class="hljs-keyword">var</span> btn_num1;  <span class="hljs-comment">// 做运算时第一个数值存入变量里</span><br>    <span class="hljs-keyword">var</span> notion;  <span class="hljs-comment">// 符号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; oButton.length; i ++ )&#123;<br>        oButton[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// 匿名事件</span><br>            <span class="hljs-comment">/*单击的是数字*/</span><br>            <span class="hljs-keyword">if</span>(isNumber(<span class="hljs-built_in">this</span>.value)) &#123;  <span class="hljs-comment">// 直接写 if(!isNan(this.value)) 也可以                </span><br>                <span class="hljs-comment">// num.value = (num.value + this.value) * 1;</span><br>                <span class="hljs-keyword">if</span>(isNull(num.value))&#123;<br>                    num.value = <span class="hljs-built_in">this</span>.value;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    num.value = num.value + <span class="hljs-built_in">this</span>.value;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">/*单击的是非数字*/</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">var</span> btn_num = <span class="hljs-built_in">this</span>.value;<br>                <span class="hljs-keyword">switch</span>(btn_num)&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                        btn_num1 = <span class="hljs-built_in">Number</span>(num.value);  <span class="hljs-comment">// 做运算时第一个数值存入变量里</span><br>                        num.value = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 文本框内数值清0</span><br>                        notion = <span class="hljs-string">&quot;+&quot;</span>;  <br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                        btn_num1 = <span class="hljs-built_in">Number</span>(num.value);  <span class="hljs-comment">// 做运算时第一个数值存入变量里</span><br>                        num.value = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 文本框内数值清0</span><br>                        notion = <span class="hljs-string">&quot;-&quot;</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                        btn_num1 = <span class="hljs-built_in">Number</span>(num.value);  <span class="hljs-comment">// 做运算时第一个数值存入变量里</span><br>                        num.value = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 文本框内数值清0</span><br>                        notion = <span class="hljs-string">&quot;*&quot;</span>;<br>                        <span class="hljs-keyword">break</span>;    <br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                        btn_num1 = <span class="hljs-built_in">Number</span>(num.value);  <span class="hljs-comment">// 做运算时第一个数值存入变量里</span><br>                        num.value = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 文本框内数值清0</span><br>                        notion = <span class="hljs-string">&quot;/&quot;</span>;<br>                        <span class="hljs-keyword">break</span>; <br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.&quot;</span>:<br>                        num.value = dec_number(num.value);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;←&quot;</span>:<br>                        num.value = back_number(num.value);<br>                        <span class="hljs-built_in">console</span>.log(num.value);<br>                        <span class="hljs-keyword">break</span>;  <br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+/-&quot;</span>:<br>                        num.value = sign(num.value);<br>                        <span class="hljs-keyword">break</span>;    <br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;c&quot;</span>:<br>                        num.value = <span class="hljs-string">&quot;0&quot;</span>;<br>                        <span class="hljs-keyword">break</span>;  <br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;=&quot;</span>:<br>                        <span class="hljs-keyword">switch</span>(notion)&#123;<br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                                num.value = btn_num1 + <span class="hljs-built_in">Number</span>(num.value);<br>                                <span class="hljs-keyword">break</span>;<br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                                num.value = btn_num1 - <span class="hljs-built_in">Number</span>(num.value);<br>                                <span class="hljs-keyword">break</span>;<br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                                num.value = btn_num1 * <span class="hljs-built_in">Number</span>(num.value);<br>                                <span class="hljs-keyword">break</span>;   <br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                                <span class="hljs-comment">// 如果除数为0</span><br>                                <span class="hljs-keyword">if</span> (num.value == <span class="hljs-number">0</span>)&#123;<br>                                    alert(<span class="hljs-string">&quot;除数不能为0！&quot;</span>);<br>                                    num.value = <span class="hljs-number">0</span>;<br>                                &#125;<br>                                <span class="hljs-keyword">else</span> &#123;<br>                                    num.value = btn_num1 / <span class="hljs-built_in">Number</span>(num.value);<br>                                &#125;<br>                                <br>                                <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                           <br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// isNaN：检查参数是否是 非数字值. 是非数字值：true；不是非数字值：false</span><br><span class="hljs-comment">/*判断是否为数字*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-comment">// if(!isNaN(n))&#123;</span><br>    <span class="hljs-comment">//     return true;  // 参数n是数字</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// else &#123;</span><br>    <span class="hljs-comment">//     return false;  // 参数n不是数字</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">isNaN</span>(n);<br>&#125;<br><br><br><span class="hljs-comment">/*验证文本框里的值是0还是空*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-string">&quot;0&quot;</span> || n.length == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*点击添加小数点*/</span><br><span class="hljs-comment">// 注意：只剩下一个数字时，再退位应该直接归0</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dec_number</span>(<span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (n.indexOf(<span class="hljs-string">&quot;.&quot;</span>) == -<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// 不包含小数点</span><br>        n = n + <span class="hljs-string">&quot;.&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-comment">/*退位键*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">back_number</span>(<span class="hljs-params">n</span>)</span>&#123;<br>    n = n.substr(<span class="hljs-number">0</span>, n.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (isNull(n))&#123;<br>        n = <span class="hljs-string">&quot;0&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-comment">/*正负符号+/-*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sign</span>(<span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-comment">// if(n.indexOf(&quot;-&quot;) == -1)&#123;</span><br>    <span class="hljs-comment">//     n = &quot;-&quot; + n;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// else &#123;</span><br>    <span class="hljs-comment">//     n = n.substr(1, n.length);</span><br>    <span class="hljs-comment">// &#125;</span><br>    n = <span class="hljs-built_in">Number</span>(n) * (-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>附：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  文本框前导0去除方法</span><br><span class="hljs-comment">  1. if判断，如果是&quot;0&quot;, n=&quot;1&quot;, 否则n=n+&quot;1&quot;</span><br><span class="hljs-comment">  2. if判断，如果是&quot;0&quot;, 直接n=&quot;&quot;, 否则n=n+&quot;1&quot;</span><br><span class="hljs-comment">  3. n=n*1 隐式转换，自动将字符串变为数值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">num_1_click</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;num&quot;</span>);<br>    <span class="hljs-keyword">var</span> n = num.value;<br>    n = n + <span class="hljs-string">&quot;1&quot;</span>;<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;num&quot;</span>).value = n * <span class="hljs-number">1</span>;  <span class="hljs-comment">// 隐式转换，自动将字符串变为数值</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>css：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">170px</span>;<br>&#125;<br><br><span class="hljs-selector-id">#div1</span> &#123;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">60px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;button&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">32px</span>;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">158px</span>;<br>    <span class="hljs-attribute">text-align</span>: right;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;<br>    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">5px</span>; <br>    <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;button&quot;</span>]</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">156</span>, <span class="hljs-number">156</span>, <span class="hljs-number">156</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习2前端油画商城">练习2：前端油画商城</h2><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210302120345892.png" alt="" style="width:95%;"/></center><p>整体设计：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210302232833663.png" alt="" style="width:65%;"/></center><p>实现思路：</p><ol type="1"><li><p>制作左上方的logo，注意上边距、左边距的距离</p></li><li>制作菜单：注意菜单的位置、间距、打开效果</li><li>右侧的用户交互区：注意右边距的位置、水平位置</li><li><p>页眉区的尺寸和距离，注意要和下方banner区域的大小、位置相应一致</p></li></ol><h3 id="页眉设计">页眉设计</h3><p>设计样式如下：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210302233348250.png" alt="" style="width:95%;"/></center><p><strong>重点：</strong></p><ul><li>菜单的制作：要注意菜单的位置；利用 js 实现的弹出效果、菜单的外观样式。</li><li>位置、对齐方式等细节设置。</li></ul><p><strong>html：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;logo&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/logo.png&quot;</span>  <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu&quot;</span> <span class="hljs-attr">onmouseleave</span>=<span class="hljs-string">&quot;show_menu1()&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu_title&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;show_menu()&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>内容分类<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;menu1&quot;</span> &gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>现实主义<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>抽象主义<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;auth&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>css：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">25px</span> auto;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1200px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.logo</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.menu</span>&#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">12px</span>;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">16px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.menu</span> <span class="hljs-selector-class">.menu_title</span>&#123;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid black;<br>    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.menu</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;<br>    <span class="hljs-attribute">background-color</span>: white;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.menu</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span>&#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.auth</span> &#123;<br>    <span class="hljs-attribute">float</span>: right;<br>    <span class="hljs-attribute">position</span>: right;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.auth</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span>&#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">70px</span>;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">12px</span>;<br>    <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><br><span class="hljs-comment">/*菜单显示、折叠*/</span><br><span class="hljs-comment">/* .header .menu:hover ul&#123;</span><br><span class="hljs-comment">    display: block;   </span><br><span class="hljs-comment">&#125; */</span><br></code></pre></td></tr></table></figure><p><strong>js：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全局变量。like a 菜单栏开关.</span><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 我自己设置：开关时闭合状态，点击开关打开。</span><br><span class="hljs-comment">/*单机菜单栏展开*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show_menu</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> menu1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;menu1&quot;</span>);<br>    flag = !flag;  <span class="hljs-comment">// 点击后开关变为相反状态</span><br>    <span class="hljs-keyword">if</span> (flag)&#123;<br>        menu1.style.display = <span class="hljs-string">&quot;block&quot;</span>;  <span class="hljs-comment">// 展开</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        menu1.style.display = <span class="hljs-string">&quot;none&quot;</span>;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">/*鼠标离开时菜单栏隐藏*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show_menu1</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> menu1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;menu1&quot;</span>);<br>    menu1.style.display = <span class="hljs-string">&quot;none&quot;</span>;<br>    flag = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 注意这，离开后开关变为false闭合，用于下一次点击。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小总结">小总结</h4><ol type="1"><li>可以在设置页面区域的同时。将banner图进行设置，方便进行位置参照</li><li>div逐层设置。仔细观察样式所选择的对象以及实现的效果</li><li>js 菜单效果设置。一般都是 js + css 结合实现。</li></ol><h3 id="正文设计">正文设计</h3><p><strong>重点：</strong></p><ul><li>商品展示区两行三列的排列方式</li><li>商品展示区两端对齐</li><li>正文区三部分布局的统一：banner区、商品展示区、页码区</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210302223019883.png" alt="" style="width:95%;"/></center><h4 id="banner区">banner区</h4><p>设计样式如下：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210302225717930.png" alt="" style="width:85%;"/></center><p><strong>html：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;banner&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/welcome.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;banner-img&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-content&quot;</span>&gt;</span>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-nav&quot;</span>&gt;</span>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>css：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1200px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">25px</span> auto;<br>&#125;<br><br><span class="hljs-selector-class">.content</span> <span class="hljs-selector-class">.banner</span> <span class="hljs-selector-class">.banner-img</span> &#123;    <br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="商品展示区">商品展示区</h4><p>设计样式如下：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210302225645070.png" alt="" style="width:85%;"/></center><p><strong>html：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;banner&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/welcome.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;banner-img&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 一块 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/wumingnvlang.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-li&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>无名女郎<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一张无名女郎图片。这是一张无名女郎图片。这是一张无名女郎图片。这是一张无名女郎图片。这是一张无名女郎图片。这是一张无名女郎图片。这是一张无名女郎图片。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-cart_btn&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;price&quot;</span>&gt;</span>$5800<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart_btn&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/cart.svg&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  /* 同样的代码x6 */<br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-nav&quot;</span>&gt;</span>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>css：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-class">.content</span> <span class="hljs-selector-class">.img-content</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1260px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设置整体li */</span><br><span class="hljs-selector-class">.content</span> <span class="hljs-selector-class">.img-content</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">360px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">60px</span> <span class="hljs-number">60px</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 设置边框等格式 */</span><br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3px</span> <span class="hljs-number">3px</span> <span class="hljs-number">#ccc</span>;  <span class="hljs-comment">/*阴影的位置? 模糊的距离 阴影的尺寸 阴影颜色*/</span><br>    <span class="hljs-attribute">-webkit-box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3px</span> <span class="hljs-number">3px</span> <span class="hljs-number">#ccc</span>;  <span class="hljs-comment">/* 谷歌浏览器 */</span><br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设置li下的info */</span><br><span class="hljs-selector-class">.img-content</span>&gt;<span class="hljs-selector-tag">ul</span>&gt;<span class="hljs-selector-tag">li</span> <span class="hljs-selector-class">.info</span> &#123;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">30px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设置标题 */</span><br><span class="hljs-selector-class">.img-content</span>&gt;<span class="hljs-selector-tag">ul</span>&gt;<span class="hljs-selector-tag">li</span> <span class="hljs-selector-class">.info</span> <span class="hljs-selector-tag">h3</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设置段落行间距 */</span><br><span class="hljs-selector-class">.img-content</span>&gt;<span class="hljs-selector-tag">ul</span>&gt;<span class="hljs-selector-tag">li</span> <span class="hljs-selector-class">.info</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 购物车按钮整体 */</span><br><span class="hljs-selector-class">.img-content</span> <span class="hljs-selector-class">.info</span> <span class="hljs-selector-class">.img-cart_btn</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 购物车外面的红色背景底框 */</span><br><span class="hljs-selector-class">.img-content</span> <span class="hljs-selector-class">.info</span> <span class="hljs-selector-class">.img-cart_btn</span> <span class="hljs-selector-class">.cart_btn</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">60px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br><br><span class="hljs-comment">/* 购物车里面的白色cart图片 */</span><br><span class="hljs-selector-class">.img-content</span> <span class="hljs-selector-class">.info</span> <span class="hljs-selector-class">.img-cart_btn</span> <span class="hljs-selector-class">.cart_btn</span> <span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">5px</span>;<br><br>&#125;<br><br><span class="hljs-comment">/* 价格price */</span><br><span class="hljs-selector-class">.img-content</span>&gt;<span class="hljs-selector-tag">ul</span>&gt;<span class="hljs-selector-tag">li</span> <span class="hljs-selector-class">.price</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">float</span>:left;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="页码区">页码区</h4><p>设计样式如下：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210302223259807.png" alt="" style="width:85%;"/></center><p><strong>html：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;banner&quot;</span>&gt;</span>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-content&quot;</span>&gt;</span>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-nav&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>上一页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;first-page&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>98<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>下一页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>尾页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>css：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*----------------page-nav-----------------*/</span><br><span class="hljs-comment">/* 尾页导航整体设置 */</span><br><span class="hljs-selector-class">.page-nav</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">60px</span>;  <span class="hljs-comment">/*高度等于行高实现垂直居中*/</span><br>    <span class="hljs-comment">/* border: 1px solid black;  设置一个边框方便看 */</span><br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-class">.page-nav</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">margin</span>: auto;  <span class="hljs-comment">/*实现水平居中*/</span><br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-class">.page-nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span>&#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><br><span class="hljs-comment">/* 第一页的小灰圆背景 */</span><br><span class="hljs-selector-class">.first-page</span> &#123;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#c5c5c5</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">3px</span> <span class="hljs-number">9px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小总结-1">小总结</h4><ul><li><p><strong>位置：</strong>在进行页面布局时，<strong>位置和对齐</strong>，是最重要的基础工作。</p></li><li><p>什么时候出现 div ？<strong>有改变即添加 div </strong>。</p></li></ul><h3 id="页脚设计">页脚设计</h3><p>设计样式如下：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210302230733993.png" alt="" style="width:85%;"/></center><p><strong>html：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>M-GALLARY<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>@2021 POWERED BY MYSELF<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>css：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*----------------footer-----------------*/</span><br><span class="hljs-selector-class">.footer</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">60px</span> auto;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-class">.footer</span> <span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">80px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.footer</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">span</span>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><ul><li>整体布局时，各个对象的位置、对齐方式、间距等设置要注意细节，<strong>要通过计算的方式获取相互位置的对应关系</strong></li><li><p><code>&lt;ul&gt;</code> 和 <code>&lt;li&gt;</code> 的使用频率较高，<strong>非常适合于规律性显示</strong> 的页面效果，例如案例中，多次使用到 <code>&lt;ul&gt;</code> 和 <code>&lt;li&gt;</code> 的场景。</p></li><li><p><code>overflow: hidden</code> 、height、float直接的关系</p><p><code>overflow: hidden</code> ：隐藏溢出。超出的部分就被隐藏起来了。它还可以清除浮动。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210302231758597.png" alt="image-20210302231758597" /><figcaption>image-20210302231758597</figcaption></figure></li><li>实现水平居中、垂直居中的方法：<ul><li>水平居中：<strong>margin: 20px auto;</strong></li><li>垂直居中：<strong>line-height</strong>: 60px; <strong>height</strong>: 60px;</li></ul></li><li><p>找准层级关系，活学活用div</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript入门</title>
    <link href="/2021/02/24/JavaScript%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/24/JavaScript%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript-入门">JavaScript 入门</h1><h2 id="javascript-简介">JavaScript 简介</h2><ul><li>JavaScript 是一种<u>脚本语言</u></li><li>JavaScript 是一种轻量级的语言。</li><li>JavaScript 是可插入 HTML 页面的编程代码。</li><li>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li></ul><p>完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型 DOM ，浏览器对象模型 BOM。</p><p><strong>JavaScript 没有任何打印或者输出的函数。</strong></p><p>JavaScript 可以通过不同的方式来输出数据：</p><ul><li>使用 window.alert() 弹出警告框。</li><li>使用 document.write() 方法将内容写到 HTML 文档中。</li><li>使用 innerHTML 写入到 HTML 元素。</li><li>使用 console.log() 写入到浏览器的控制台。</li></ul><h2 id="js-语法">JS 语法</h2><h3 id="javascript-注释">JavaScript 注释</h3><p>单行注释以 <code>//</code> 开头。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 输出标题：</span><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;myH1&quot;</span>).innerHTML=<span class="hljs-string">&quot;Welcome to my Homepage&quot;</span>;<br></code></pre></td></tr></table></figure><p>多行注释以 <code>/*</code> 开始，以 <code>*/</code> 结尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">下面的代码会输出</span><br><span class="hljs-comment">一个标题</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;myH1&quot;</span>).innerHTML=<span class="hljs-string">&quot;Welcome to my Homepage&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="javascript-变量">JavaScript 变量</h3><ul><li><p>变量名是大小写英文、数字、$和_的组合，且不能用数字开头。</p></li><li><p>申明一个变量用 <strong>var</strong> 关键字，该变量默认为局部变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> carname=<span class="hljs-string">&quot;benz&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>如果第一次申明变量是未添加var关键字，则为全局变量。</p></li><li><p>strict模式：强制使用var申明变量，未使用将导致运行错误。使用方法：js代码的第一行添加'use strict';</p></li></ul><h3 id="javascript-数据类型">JavaScript 数据类型</h3><p>包括<strong>字符串、数字、布尔、数组、对象、Null 、Undefined</strong></p><p>JavaScript 拥有动态类型，相同的变量可用作不同的类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x;  <span class="hljs-comment">// x为 undefined</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">6</span>;  <span class="hljs-comment">// x 为数字</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;Bill&quot;</span>;  <span class="hljs-comment">// x 为字符串</span><br></code></pre></td></tr></table></figure><p>举几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;John&quot;</span> <span class="hljs-comment">// 返回 string</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">3.14</span> <span class="hljs-comment">// 返回 number</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 返回 boolean</span><br><span class="hljs-keyword">typeof</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] <span class="hljs-comment">// 返回 object</span><br><span class="hljs-keyword">typeof</span> &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">34</span>&#125; <span class="hljs-comment">// 返回 object</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-comment">// 返回 object</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125; <span class="hljs-comment">// 返回 function</span><br><span class="hljs-keyword">typeof</span> myCar <span class="hljs-comment">// 返回 undefined (如果 myCar 没有声明)</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// 返回 object</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// object</span><br><span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="字符串">字符串</h4><p>字符串是存储字符（比如 &quot;Bill Gates&quot;）的变量。可以使用单引号或双引号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> carname=<span class="hljs-string">&quot;Bill Gates&quot;</span>;<br><span class="hljs-keyword">var</span> carname=<span class="hljs-string">&#x27;Bill Gates&#x27;</span>;<br><br><span class="hljs-comment">// 可以在字符串中使用引号，只要不匹配包围字符串的引号即可：</span><br><span class="hljs-keyword">var</span> answer=<span class="hljs-string">&quot;He is called &#x27;Bill&#x27;&quot;</span>;<br><span class="hljs-keyword">var</span> answer=<span class="hljs-string">&#x27;He is called &quot;Bill&quot;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>关于字符串：</p><ul><li><p><strong>字符串是不可变的</strong>，如果对字符串的某个索引赋值，不会有任何错误，但也没有任何效果</p></li><li><p>拼接字符串使用+号</p></li><li><p>格式化字符串的方式：注意要用反引号，不能是单引号或双引号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;小明&#x27;</span>;<br><span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>;<br>alert(<span class="hljs-string">`你好, <span class="hljs-subst">$&#123;name&#125;</span>, 你今年<span class="hljs-subst">$&#123;age&#125;</span>岁了!`</span>);<br></code></pre></td></tr></table></figure><blockquote><p>，，\表示，##形式为十六进制，\u##表示一个Unicode字符</p></blockquote></li></ul><h4 id="数字">数字</h4><p>JavaScript 只有一种数字类型。数字可以带小数点，也可以不带：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x1=<span class="hljs-number">34.00</span>; <span class="hljs-comment">//使用小数点来写</span><br><span class="hljs-keyword">var</span> x2=<span class="hljs-number">34</span>; <span class="hljs-comment">//不使用小数点来写</span><br><span class="hljs-keyword">var</span> y=<span class="hljs-number">123e5</span>; <span class="hljs-comment">// 12300000</span><br><span class="hljs-keyword">var</span> z=<span class="hljs-number">123e-5</span>; <span class="hljs-comment">// 0.00123</span><br></code></pre></td></tr></table></figure><h4 id="布尔">布尔</h4><p>布尔（逻辑）只有两个值：true 或 false。注意和Python大小写的区别！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> y = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>关于 布尔运算符：</p><p>Boolean 运算符有三种：<code>!、&amp;&amp; 和 ||</code>。</p><p>抽象操作 ToBoolean 将其参数按照下表中的规则转换为逻辑值：</p><table><thead><tr class="header"><th>参数类型</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>Undefined</td><td>false</td></tr><tr class="even"><td>Null</td><td>false</td></tr><tr class="odd"><td>Boolean</td><td>结果等于输入的参数（不转换）</td></tr><tr class="even"><td>Number</td><td>如果参数为 +0，-0 或 NaN，则结果为false；否则为 true</td></tr><tr class="odd"><td>String</td><td>如果参数为空字符串，则结果为false；否则为true</td></tr><tr class="even"><td>Object</td><td>true</td></tr></tbody></table><h4 id="数组">数组</h4><p>类似Python的列表。例如创建名为 cars 的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> cars=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br>cars[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;Audi&quot;</span>;<br>cars[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;BMW&quot;</span>;<br>cars[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;Volvo&quot;</span>;<br></code></pre></td></tr></table></figure><p>or:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> cars=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&quot;Audi&quot;</span>,<span class="hljs-string">&quot;BMW&quot;</span>,<span class="hljs-string">&quot;Volvo&quot;</span>);<br></code></pre></td></tr></table></figure><p>or:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> cars=[<span class="hljs-string">&quot;Audi&quot;</span>,<span class="hljs-string">&quot;BMW&quot;</span>,<span class="hljs-string">&quot;Volvo&quot;</span>];<br></code></pre></td></tr></table></figure><blockquote><p>数组下标也是基于零的，所以第一个项目是 [0]，第二个是 [1]，以此类推。</p></blockquote><p>关于数组：</p><ul><li>直接给Array的length赋一个新的值会<u>导致Array大小的变化</u>。</li><li>通过索引赋值时，如果索引超过了范围，<u>同样会引起Array大小的变化</u>，这点和python不一样， python会弹出异常。</li><li>js对数组的索引没有较强的保护，容易出现问题，请一定注意。</li></ul><p>数组常用的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.indexOf() 返回某个指定的字符串值在字符串中首次出现的位置。<br>obj.length 数组的大小<br>obj.push(ele) 尾部追加元素<br>obj.pop() 尾部获取一个元素<br>obj.unshift(ele) 头部插入元素<br>obj.shift() 头部移除元素<br>obj.splice(start, deleteCount, value, ...) 插入、删除或替换数组的元素<br>obj.splice(n,<span class="hljs-number">0</span>,val) 指定位置插入元素<br>obj.splice(n,<span class="hljs-number">1</span>,val) 指定位置替换元素<br>obj.splice(n,<span class="hljs-number">1</span>) 指定位置删除元素<br>obj.slice( ) 切片<br>obj.reverse( ) 反转<br>obj.join(sep) 将数组元素连接起来以构建一个字符串<br>obj.concat(val,..) 连接数组<br>obj.sort( ) 对数组元素进行排序<br></code></pre></td></tr></table></figure><p>练习：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arrayObj=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br><span class="hljs-comment">// 指定长度为5</span><br><span class="hljs-keyword">var</span> arrayObj=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 创建带有默认值的数组</span><br><span class="hljs-keyword">var</span> arrayObj=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">8</span>);<br><span class="hljs-comment">// 隐式创建</span><br><span class="hljs-keyword">var</span> arrayObj=[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">8</span>];<br><br><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-built_in">console</span>.log(arrayObj[<span class="hljs-number">0</span>]);输出数组的第一个数<br><span class="hljs-built_in">console</span>.log(arrayObj[<span class="hljs-number">5</span>]);----<span class="hljs-literal">undefined</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arrayObj)&#123;<br><span class="hljs-built_in">console</span>.log(arrayObj[i]); <br>&#125;<br><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> n = arrayObj.length;<br><span class="hljs-keyword">for</span> (i; i&lt;n; i++) &#123;<br><span class="hljs-built_in">console</span>.log(arrayObj[i])<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对象-object">对象 object</h4><p><strong>这里的对象不是指面向对象编程中的对象，而是类似Python的字典数据结构</strong></p><p>JS的对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>firstname : <span class="hljs-string">&quot;Bill&quot;</span>,<br>lastname : <span class="hljs-string">&quot;Gates&quot;</span>,<br>id : <span class="hljs-number">5566</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对象属性有两种寻址方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">name = person.lastname;<br>name = person[<span class="hljs-string">&quot;lastname&quot;</span>];<br></code></pre></td></tr></table></figure><p>关于对象：</p><ul><li>对象是一种无序的集合数据类型，它由若干键值对组成。<ul><li>访问属性是通过 <strong><code>.</code></strong> 操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就 必须用 <strong><code>''</code></strong> 括起来，并以 <strong>方括号</strong> 访问。</li></ul></li><li>访问不存在的属性不报错，而是返回 undefined</li><li>可以自由地随时给一个对象添加或删除属性，就像python一样</li><li>要检测对象是否拥有某一属性，可以用 in 操作符。但这个属性有可能是对象继承得来的。例如 ”tostring“ 就是所有对象的属性，因为 toString 定义在 object 对象中，而所有对象最终都会在原型链上指向 object 。</li><li>要判断一个属性是否是对象自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法。</li></ul><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xiaoming = &#123;<br>name: <span class="hljs-string">&#x27;小明&#x27;</span><br>&#125;;<br>xiaoming.age; <span class="hljs-comment">// undefined</span><br>xiaoming.age = <span class="hljs-number">18</span>; <span class="hljs-comment">// 新增一个age属性</span><br>xiaoming.age; <span class="hljs-comment">// 18</span><br><span class="hljs-keyword">delete</span> xiaoming.age; <span class="hljs-comment">// 删除age属性</span><br>xiaoming.age; <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">delete</span> xiaoming[<span class="hljs-string">&#x27;name&#x27;</span>]; <span class="hljs-comment">// 删除name属性</span><br>xiaoming.name; <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">delete</span> xiaoming.school; <span class="hljs-comment">// 删除一个不存在的school属性也不会报错</span><br><span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> xiaoming; <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;grade&#x27;</span> <span class="hljs-keyword">in</span> xiaoming; <span class="hljs-comment">// false</span><br><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> xiaoming; <span class="hljs-comment">// true</span><br>xiaoming.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// true</span><br>xiaoming.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="undefined-和-null">Undefined 和 Null</h4><p>Undefined 这个值表示变量不含有值。 可以通过将变量的值设置为 null 来清空变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">cars=<span class="hljs-literal">null</span>;<br>person=<span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h4 id="声明变量类型">声明变量类型</h4><p>当声明新变量时，可以使用关键词 &quot;new&quot; 来声明其类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> carname=<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>;<br><span class="hljs-keyword">var</span> x= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>;<br><span class="hljs-keyword">var</span> y= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>;<br><span class="hljs-keyword">var</span> cars= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>;<br><span class="hljs-keyword">var</span> person= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;<br></code></pre></td></tr></table></figure><h3 id="数据类型的转换">数据类型的转换</h3><ul><li>String() 转换为字符串</li><li>Number() 将字符串转换为数字</li><li>number.tostring() 例如：(123).toString()</li><li>toExponential() 把对象的值转换为指数计数法。</li><li>toFixed() 保留小数。把数字转换为字符串，结果的小数点后有指定位数的数字。</li><li>toPrecision() 把数字格式化为指定的长度。</li><li>parseInt(..) 将某值转换成数字，不成功则NaN</li><li>parseFloat(..) 将某值转换成浮点数，不成功则NaN</li></ul><h3 id="等号和非等号">等号和非等号</h3><p>等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。非等号由 感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。</p><p><strong>为确定两个运算数是否相等， 这两个运算符都会进行类型转换。</strong></p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210227113231915.png" alt="pokeman-parameters" style="width:95%;"/></center><h4 id="nan">NaN</h4><ul><li><p>NaN虽然表示是一个非数字 , 但是一般是算术运算执行的结果，因此NaN 仍然是 数值类型</p></li><li><p>JavaScript的规定, NaN表示的是非数字, 但是这个非数字也是不同的。因此 NaN 不等于 NaN 即 两个NaN永远不可能相等。</p></li><li><p>执行运算时 ：</p><ul><li>非加法运算 ,只要有NaN参与,执行结果都是NaN<br /></li><li>加法运算 , 有 NaN 执行 字符串拼接操作 ，都是数值执行 加法运算</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span> );   ---&gt;<span class="hljs-literal">false</span><br><span class="hljs-built_in">console</span>.log ( <span class="hljs-string">&#x27;北京&#x27;</span> - <span class="hljs-number">100</span> == <span class="hljs-string">&#x27;北京&#x27;</span> - <span class="hljs-number">100</span> );   ---&gt;<span class="hljs-literal">false</span><br>比较的不是 <span class="hljs-string">&#x27;北京&#x27;</span>-<span class="hljs-number">100</span> , 这个表达式 而是 <span class="hljs-string">&#x27;北京&#x27;</span>-<span class="hljs-number">100</span> 的结果<br>左侧 <span class="hljs-string">&#x27;北京&#x27;</span>-<span class="hljs-number">100</span> 结果是 <span class="hljs-literal">NaN</span>    <br>右侧 <span class="hljs-string">&#x27;北京&#x27;</span>-<span class="hljs-number">100</span> 结果是 <span class="hljs-literal">NaN</span><br>但是 <span class="hljs-literal">NaN</span> 不等于 <span class="hljs-literal">NaN</span> ,执行结果为<span class="hljs-literal">false</span><br><br><span class="hljs-built_in">console</span>.log ( <span class="hljs-string">&#x27;北京&#x27;</span> + <span class="hljs-number">100</span> == <span class="hljs-string">&#x27;北京&#x27;</span> + <span class="hljs-number">100</span> );<br>如果是加号,执行字符串拼接,结果就是 <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="全等号和非全等号">全等号和非全等号</h3><p>等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。</p><p>全等号由三个等号表示 <strong><code>===</code></strong> ，只有在无需类型转换运算数就相等的情况下，才返回 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sNum = <span class="hljs-string">&quot;66&quot;</span>;<br><span class="hljs-keyword">var</span> iNum = <span class="hljs-number">66</span>;<br>alert(sNum == iNum); <span class="hljs-comment">//输出 &quot;true&quot;</span><br>alert(sNum === iNum); <span class="hljs-comment">//输出 &quot;false&quot;</span><br></code></pre></td></tr></table></figure><h3 id="条件运算符">条件运算符</h3><p>也叫三目运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">variable = boolean_expression ? true_value : false_value;<br></code></pre></td></tr></table></figure><p>该表达式主要是根据 boolean_expression 的计算结果有条件地为变量赋值。如果 Boolean_expression 为 true，就把 true_value 赋给变量；如果它是 false，就把 false_value 赋 给变量。</p><h3 id="javascript-函数">JavaScript 函数</h3><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。 函数是包裹在花括号中的代码块，前面使用关键词 <strong>function</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionname</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>这里是要执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="局部变量">局部变量</h4><p>在 JavaScript 函数内部声明的变量（使用 var）是局部变量，只能在函数内部访问它。</p><p>可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。 只要函数运行完毕，局部变量就会被删除。</p><h4 id="全局变量">全局变量</h4><p>在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它</p><h4 id="变量的生存期">变量的生存期</h4><p>JavaScript 变量的生命期从它们被声明的时间开始。</p><p>局部变量会在函数运行以后被删除。</p><p>全局变量会在页面关闭后被删除。</p><h4 id="向未声明的变量分配值">向未声明的变量分配值</h4><p>如果值赋给尚未声明的变量，该变量将被自动作为全局变量声明。</p><p>这条语句： <code>carname=&quot;Volvo&quot;;</code> 将声明一个全局变量 carname，即使它在函数内执行。</p><p><strong>var关键字很重要！</strong></p><h4 id="内置函数">内置函数</h4><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210227223423974.png" alt="" style="width:95%;"/></center><p>练习：</p><p>1、定义字符串hello，imooc！</p><p>2、取出子串imooc并输出</p><p>3、定义日期，值为2019-5-1</p><p>4、分别输出年月的值</p><p>5、求一组数20，41，15，8的最大值和最小值并输出</p><p>运行效果如下：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210227223457438.png" alt="pokeman-parameters" style="width:35%;"/></center><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>运算符<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">//定义字符串hello，imooc！</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello,imooc!&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-comment">//取出子串imooc并输出</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> sub = str.substring(<span class="hljs-number">6</span>, <span class="hljs-number">12</span>);</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(sub);</span><br><br><span class="javascript"><span class="hljs-comment">//定义日期，值为2019-5-1</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-5-1&quot;</span>);</span><br><br><span class="javascript"><span class="hljs-comment">//分别输出年月日的值</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(date.getFullYear());</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(date.getMonth()+<span class="hljs-number">1</span>);</span><br><br><span class="javascript"><span class="hljs-comment">//求一组数20，41，15，8的最大值和最小值并输出</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">20</span>, <span class="hljs-number">41</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>));</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.min(<span class="hljs-number">20</span>, <span class="hljs-number">41</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>));</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="delete">delete</h3><p>delete 运算符删除对以前定义的对象属性或方法的引用。</p><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;<br>o.name = <span class="hljs-string">&quot;David&quot;</span>;<br>alert(o.name); <span class="hljs-comment">//输出 &quot;David&quot;</span><br><span class="hljs-keyword">delete</span> o.name;<br>alert(o.name); <span class="hljs-comment">//输出 &quot;undefined“</span><br></code></pre></td></tr></table></figure><p>在这个例子中，删除了 name 属性，意味着强制解除对它的引用，将其设置为 undefined（即创建的 未初始化的变量的值）。</p><ul><li><p>delete 运算符不能删除开发者未定义的属性和方法。</p><p><code>delete o.toString;</code> 即使 toString 是有效的方法名，这行代码也会引发错误，因为 toString() 方法是原始的 ECMAScript 方法，不是开发者定义的。</p></li></ul><h3 id="if...else-语句">if...else 语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (条件) &#123;<br>当条件为 <span class="hljs-literal">true</span> 时执行的代码<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>当条件不为 <span class="hljs-literal">true</span> 时执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch-语句">switch 语句</h3><p>用于基于不同的条件来执行不同的动作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span>(n) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    执行代码块<span class="hljs-number">1</span><br>    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    执行代码块<span class="hljs-number">2</span><br>    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        n 与 <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> 和 <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> 不同时执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环">循环</h3><p>JavaScript 支持不同类型的循环：</p><ul><li>for - 循环代码块一定的次数</li><li>for/in - 循环遍历对象的属性</li><li>while - 当指定的条件为 true 时循环指定的代码块</li><li>do/while - 同样当指定的条件为 true 时循环指定的代码块</li></ul><h3 id="break-和-continue-语句">Break 和 Continue 语句</h3><p>break 语句用于跳出循环。</p><p>continue 用于跳过循环中的一个迭代 。</p><h3 id="异常处理---throwtry-和-catch">异常处理 - Throw、Try 和 Catch</h3><ul><li>try 测试代码块的错误。</li><li>catch 处理错误。</li><li>throw 创建自定义错误。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//在这里运行代码</span><br>&#125;<br><span class="hljs-keyword">catch</span>(err)&#123;<br><span class="hljs-comment">//在这里处理错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="throw-语句">Throw 语句</h4><p>throw 语句允许我们创建自定义错误。 如果把 throw 与 try 和 catch 一起使用， 就能够控制程序流，并生成自定义的错误消息。</p><p>语法：<strong>throw exception</strong> 抛出的异常可 以是 JavaScript 字符串、数字、逻辑值或 对象。</p><p>小栗子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Throw功能测试<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>请输入一个介于5和10之间的数字:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myFunc()&quot;</span>&gt;</span>测试输入<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> tag = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;message&#x27;</span>);</span><br><span class="javascript">        <span class="hljs-keyword">try</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> x = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;demo&#x27;</span>).value;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (x == <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;输入为空&#x27;</span>;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(x)) <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;输入的不是数字&#x27;</span>;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;值大于10&#x27;</span>;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">5</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;值小于5&#x27;</span>;</span><br><span class="javascript">            tag.innerHTML = <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="javascript">        &#125;<span class="hljs-keyword">catch</span> (err)&#123;</span><br><span class="javascript">        tag.innerHTML = <span class="hljs-string">&#x27;输入不合法，原因是：&#x27;</span> + err;</span><br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="时间对象">时间对象</h3><p>在JavaScript中，Date对象用来表示日期和时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>now;<br>now.getFullYear(); <span class="hljs-comment">// 年份</span><br>now.getMonth(); <span class="hljs-comment">// 5, 月份，注意月份范围是0~11，5表示六月</span><br>now.getDate(); <span class="hljs-comment">// 24, 表示24号</span><br>now.getDay(); <span class="hljs-comment">// 3, 表示星期三</span><br>now.getHours(); <span class="hljs-comment">// 19, 24小时制</span><br>now.getMinutes(); <span class="hljs-comment">// 49, 分钟</span><br>now.getSeconds(); <span class="hljs-comment">// 22, 秒</span><br>now.getMilliseconds(); <span class="hljs-comment">// 875, 毫秒数</span><br>now.getTime(); <span class="hljs-comment">// 1435146562875, 以number形式表示的时间戳</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。</p></blockquote><h4 id="创建日期">创建日期</h4><p>如果要创建一个指定日期和时间的Date对象，可以用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2017</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">123</span>); <br>d; <span class="hljs-comment">// Fri Jun 19 2017 20:15:30 GMT+0800 (CST) </span><br></code></pre></td></tr></table></figure><p>第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> d = <span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;2015-06-24T19:49:22.875+08:00&#x27;</span>); <br>d; <span class="hljs-comment">// 1435146562875 但它返回的不是Date对象，而是一个时间戳。</span><br></code></pre></td></tr></table></figure><p>不过有时间戳就可以很容易地把它转换为一个Date：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1435146562875</span>); <br>d; <span class="hljs-comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><h4 id="操作日期">操作日期</h4><p>为日期对象设置一个特定的日期 (2017 年 9 月 9 日)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myDate=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <br>myDate.setFullYear(<span class="hljs-number">2017</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>) ;<br></code></pre></td></tr></table></figure><p>注意：<strong>表示月份的参数介于 0 到 11 之间</strong>。也就是说，如果希望把月设置为 9 月，则参数应该是 8。 将日期对象设置为 5 天后的日期：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myDate=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>myDate.setDate(myDate.getDate()+<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>注意：如果增加天数会改变月份或者年份，那么日期对象会自动完成这种转换。</p><h4 id="比较日期">比较日期</h4><p>日期对象也可用于比较两个日期。 下面的代码将当前日期与 2019 年 9 月 9 日做了比较 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>myDate.setFullYear(<span class="hljs-number">2019</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>);<br><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-keyword">if</span> (myDate&gt;today) &#123;<br>alert(<span class="hljs-string">&quot;Today is before &quot;</span>); <br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>alert(<span class="hljs-string">&quot;Today is after &quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="json">JSON</h2><p>JSON：JavaScript Object Notation，JavaScript 对象表示法。</p><ul><li>JSON 是存储和交换文本信息的语法。类似 XML。</li><li>JSON 比 XML 更小、更快，更易解析。</li><li>JSON 是<strong>轻量级的文本数据交换格式</strong></li><li><strong>JSON 使用 JavaScript 语法来描述数据对象</strong>，但是 JSON 仍然独立于语言和平台。</li><li>JSON 解析器和 JSON 库支持许多不同的编程语言。</li><li>JSON 更易理解</li><li>JSON 具有层级结构（值中存在值）</li><li><p>JSON 数据可使用 AJAX 进行传输</p></li><li>JSON 语法是 JavaScript 语法的子集。<ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">JSON的 &quot;firstName&quot; : &quot;John“<br>等价于这条 JavaScript 语句：<br>firstName = &quot;John“<br></code></pre></td></tr></table></figure><p>JSON 值可以是：</p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在方括号中）</li><li>对象（在花括号中）</li><li>null</li></ul><h3 id="json.parse">JSON.parse()</h3><p>JSON 通常用于与服务端交换数据。在接收服务器数据时一般是字符串。</p><p>可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p><p><strong>JSON.parse()：将JSON格式转换成js对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">JSON</span>.parse(text[, reviver])<br></code></pre></td></tr></table></figure><ul><li>text:必需， 一个有效的 JSON 字符串。</li><li>reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。</li></ul><p>举个栗子：</p><p>例如假设从服务器接收了以下数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;&#123; &quot;name&quot;:&quot;jack&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.liujiangblog.com&quot; &#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123; &quot;name&quot;:&quot;jack&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.liujiangblog.com&quot; &#125;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可以得到 obj：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;alexa&quot;</span>:<span class="hljs-number">10000</span>, <span class="hljs-string">&quot;site&quot;</span>:<span class="hljs-string">&quot;www.liujiangblog.com&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="json.stringify">JSON.stringify()</h3><p><strong>JSON.stringify() ：将 JavaScript 对象转换为字符串。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">JSON</span>.stringify(value[, replacer[, space]])<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>value: 必需， JavaScript 对象。</li><li><p>replacer: 可选。用于转换结果的函数或数组。 如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：&quot;&quot;。</p></li><li><p>space: 可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数 目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 有可以使用非数字，如：。</p></li></ul><p>举个栗子：</p><p>例如向服务器发送以下数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;initDate&quot;</span>:<span class="hljs-string">&quot;2013-12-14&quot;</span>, <span class="hljs-string">&quot;site&quot;</span>:<span class="hljs-string">&quot;www.liujiangblog.com&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>使用 JSON.stringify() 方法处理以上数据，将其转换为字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myJSON = <span class="hljs-built_in">JSON</span>.stringify(obj);<br>得到myJSON：<span class="hljs-string">&#x27;&quot;name&quot;:&quot;jack&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.liujiangblog.com&quot;&#x27;</span><br></code></pre></td></tr></table></figure><p>也可以将 JavaScript 数组转换为 JSON 字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&quot;Google&quot;</span>, “baidu<span class="hljs-string">&quot;, &quot;</span>Taobao<span class="hljs-string">&quot;, &quot;</span>Facebook<span class="hljs-string">&quot; ];</span><br><span class="hljs-string">var myJSON = JSON.stringify(arr);</span><br><span class="hljs-string">得到myJSON：&#x27;[ &quot;</span>Google<span class="hljs-string">&quot;, “baidu&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>, <span class="hljs-string">&quot;Facebook&quot;</span> ]<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="json-不能存储-date-对象">JSON 不能存储 Date 对象</h3><p>如果需要存储 Date 对象，需要将其转换为字符串。之后再将字符串转换为 Date 对象。</p><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myJSON = <span class="hljs-string">&#x27;&#123; &quot;name&quot;:&quot;jack&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.liujiangblog.com&quot;&#125;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>then</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse(myJSON)<br>得到obj：&#123; <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;initDate&quot;</span>:<span class="hljs-string">&quot;2013-12-14&quot;</span>, <span class="hljs-string">&quot;site&quot;</span>:<span class="hljs-string">&quot;www.liujiangblog.com&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>这里的 &quot;initDate&quot; ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> obj[<span class="hljs-string">&quot;initDate&quot;</span>]<br>&lt; <span class="hljs-string">&quot;string&quot;</span><br></code></pre></td></tr></table></figure><p>发现这个时间字符串类型，给他改成日期类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">obj[<span class="hljs-string">&quot;initDate&quot;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj[<span class="hljs-string">&quot;initDate&quot;</span>])<br>&lt; Sat Dec <span class="hljs-number">14</span> <span class="hljs-number">2013</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMT+<span class="hljs-number">0800</span> (中国标准时间)<br></code></pre></td></tr></table></figure><p>这回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">obj<br>&lt; &#123; <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;initDate&quot;</span>:Sat Dec <span class="hljs-number">14</span> <span class="hljs-number">2013</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMT+<span class="hljs-number">0800</span> (中国标准时间), <span class="hljs-string">&quot;site&quot;</span>:<span class="hljs-string">&quot;www.liujiangblog.com&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用 JSON.parse() 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> text = <span class="hljs-string">&#x27;&#123; &quot;name&quot;:“JACK&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.liujiangblog.com&quot;&#125;&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse(text, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;initDate&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="js-对表单元素进行设置">JS 对表单元素进行设置</h2><p><strong>表单</strong>：在客户端接收用户信息，然后将数据传给后台 input</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210228180224911.png" alt="" style="width:90%;"/></center><ul><li>onclick</li></ul><p>onclick 事件会在对象被点击时发生。</p><ul><li>onload</li></ul><p>onload()：页面加载事件，刷新body ，在页面刷新的时候<strong>首先执行</strong></p><ul><li>onchange</li></ul><p>onchange 事件会在域的内容改变时发生。</p><p>onchange 事件也可用于单选框与复选框改变后触发的事件。</p><h3 id="text">text</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    Field1: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;field1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Hello World!&quot;</span>&gt;</span><br>    Field2: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;field2&quot;</span>&gt;</span><br>    点击按钮，把 Field1 的内容拷贝到 Field2 中：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;document.getElementById(&#x27;field2&#x27;).value=</span></span><br><span class="hljs-tag"><span class="hljs-string">    document.getElementById(&#x27;field1&#x27;).value&quot;</span>&gt;</span>Copy Text<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="button">button</h3><p>点击按钮，改变文本框里的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show1</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">// alert(&quot;12345&quot;);</span></span><br><span class="javascript">            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;userName&quot;</span>).value=<span class="hljs-string">&quot;999&quot;</span>;</span><br><span class="javascript">            <span class="hljs-comment">// 按照元素id获取该元素</span></span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;show1()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;show1()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="radio">radio</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show1</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> sex = <span class="hljs-built_in">document</span>.getElementsByName(<span class="hljs-string">&quot;sex&quot;</span>);  <span class="hljs-comment">// 获取到一个数组</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> sexText;</span><br><span class="javascript">            <span class="hljs-keyword">if</span>(sex[<span class="hljs-number">0</span>].checked) &#123;</span><br>                sexText = sex[0].value;<br>            &#125;<br><span class="javascript">            <span class="hljs-keyword">else</span> &#123;</span><br>                sexText = sex[1].value;<br>            &#125;<br>            alert(sexText);<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;man&quot;</span> <span class="hljs-attr">checked</span>&gt;</span>男<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;woman&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;show1()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="select">select</h3><p><strong>练习：年、月、日三级联动</strong></p><p>根据年和月改变天数列表框的天数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ymd</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> yyyy = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;yyyy&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> mm = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;mm&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> dd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;dd&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br><span class="javascript">            <span class="hljs-keyword">var</span> year = <span class="hljs-built_in">parseInt</span>(date.getFullYear());</span><br>            initSelect(yyyy, 1999, year);<br>            initSelect(mm, 1, 12);<br>            initSelect(dd, 1, 31);<br><span class="javascript">            <span class="hljs-comment">// 获取列表框长度</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> n = yyyy.length;</span><br><span class="javascript">            <span class="hljs-comment">// alert(n);</span></span><br><span class="javascript">            <span class="hljs-comment">// 列表框选中一个条目</span></span><br><span class="javascript">            yyyy.selectedIndex = <span class="hljs-built_in">Math</span>.round(n/<span class="hljs-number">2</span>);</span><br><span class="javascript">            <span class="hljs-comment">// 将某个列表框的条目数设置为0，效果是删除</span></span><br><span class="javascript">            <span class="hljs-comment">// dd.options.length=0;</span></span><br><br>        &#125;<br><span class="javascript">        <span class="hljs-comment">/*给列表框复制，传递三个参数：表单元素，开始值，结束值*/</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initSelect</span>(<span class="hljs-params">obj, start, end</span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start; i &lt;= end; i ++ )&#123;</span><br><span class="javascript">                obj.options.add(<span class="hljs-keyword">new</span> Option(i, i));</span><br>            &#125;<br>        &#125;<br><span class="javascript">        <span class="hljs-comment">/*根据年、月改变对应的月份天数*/</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectYmd</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> yyyy = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;yyyy&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> mm = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;mm&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> dd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;dd&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> y = <span class="hljs-built_in">parseInt</span>(yyyy.value);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">parseInt</span>(mm.value);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">parseInt</span>(dd.value);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> dayEnd;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (m == <span class="hljs-number">4</span> || m == <span class="hljs-number">6</span> || m == <span class="hljs-number">9</span> || m == <span class="hljs-number">11</span> )&#123;</span><br>                dayEnd = 30;<br>            &#125;<br><span class="javascript">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">2</span>)&#123;</span><br>                dayEnd = 28;<br><span class="javascript">                <span class="hljs-keyword">if</span> ((y % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; y % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>)|| y % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>)</span><br>                &#123;<br>                    dayEnd = 29;<br>                &#125;<br>            &#125;<br><span class="javascript">            <span class="hljs-keyword">else</span> &#123;</span><br>                dayEnd = 31;<br>            &#125;<br>            dd.options.length = 0;<br>            initSelect(dd, 1, dayEnd);<br>        &#125;<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;ymd()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;yyyy&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;yyyy&quot;</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">&quot;selectYmd()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>年<br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mm&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mm&quot;</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">&quot;selectYmd()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>月<br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dd&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dd&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>日<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>练习：删除列表框里的某一个条目。即：按索引号删除。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteSelect</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> dd = <span class="hljs-built_in">document</span>.getElementByid(<span class="hljs-string">&quot;dd&quot;</span>);<br><span class="hljs-comment">// dd.options.remove(1);  // 删除索引号为1的条目</span><br>    <span class="hljs-keyword">for</span> (i = dd.length; i &gt;= <span class="hljs-number">0</span>; i -- )&#123;<br>        dd.options.remove(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 删掉所有条目</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习：实现省市的二级联动</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">/*添加省份*/</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">address</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> provinces = [<span class="hljs-string">&quot;北京市&quot;</span>, <span class="hljs-string">&quot;天津市&quot;</span>, <span class="hljs-string">&quot;河北省&quot;</span>, <span class="hljs-string">&quot;河南省&quot;</span>];</span><br><span class="javascript">            <span class="hljs-keyword">var</span> prov = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;prov&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> sec = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;sec&quot;</span>);</span><br>            selectAdd(prov, provinces, 0, 3);<br>        &#125;<br><span class="javascript">        <span class="hljs-comment">/*添加列表框*/</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectAdd</span>(<span class="hljs-params">obj, arr, start, end</span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start; i &lt;= end; i ++ )&#123;</span><br><span class="javascript">                obj.options.add(<span class="hljs-keyword">new</span> Option(arr[i], arr[i]));</span><br>            &#125;<br>        &#125;<br><span class="javascript">        <span class="hljs-comment">/*实现省市的二级联动：根据得到的省份输出市*/</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">linkage</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">var</span> sections = [<span class="hljs-string">&quot;朝阳区&quot;</span>, <span class="hljs-string">&quot;西城区&quot;</span>, <span class="hljs-string">&quot;西青区&quot;</span>, <span class="hljs-string">&quot;武清区&quot;</span>, <span class="hljs-string">&quot;石家庄&quot;</span>, <span class="hljs-string">&quot;邯郸市&quot;</span>, <span class="hljs-string">&quot;郑州市&quot;</span>, <span class="hljs-string">&quot;开封市&quot;</span>];</span><br><span class="javascript"><span class="hljs-keyword">var</span> prov = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;prov&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">var</span> sec = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;sec&quot;</span>);</span><br><span class="javascript"><span class="hljs-keyword">var</span> n = prov.value;</span><br><span class="javascript"><span class="hljs-keyword">if</span> (n == <span class="hljs-string">&quot;北京市&quot;</span>) &#123;</span><br>sec.options.length = 0;<br>selectAdd(sec, sections, 0, 1);<br>&#125;<br><span class="javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-string">&quot;天津市&quot;</span>)&#123;</span><br>sec.options.length = 0;<br>selectAdd(sec, sections, 2, 3);<br>&#125;<br><span class="javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-string">&quot;河北省&quot;</span>)&#123;</span><br>sec.options.length = 0;<br>selectAdd(sec, sections, 4, 5);<br>&#125;<br><span class="javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-string">&quot;河南省&quot;</span>)&#123;</span><br>sec.options.length = 0;<br>selectAdd(sec, sections, 6, 7);<br>&#125;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;address()&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br> 省份：<br> <span class="hljs-comment">&lt;!--  请在此补充代码 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prov&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;prov&quot;</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">&quot;linkage()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br> 市/区：<br> <span class="hljs-comment">&lt;!--  请在此补充代码 --&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sec&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sec&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="image">image</h3><p><strong>练习：根据列表框选择的数字呈现图片</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">html部分：<br>&lt;img id=<span class="hljs-string">&quot;loadImg&quot;</span> src=<span class="hljs-string">&quot;image/head/Load/1.gif&quot;</span>&gt;<br>&lt;select id=<span class="hljs-string">&quot;logo&quot;</span> onchange=<span class="hljs-string">&quot;selectLogo&quot;</span>&gt;&lt;/select&gt;<br><br>js部分：<br><span class="hljs-comment">// 初始化列表框条目</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initLogo</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> load = <span class="hljs-built_in">document</span>.getElementByid(<span class="hljs-string">&quot;load&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">15</span>; i ++ )&#123;<br>        logo.options.add(<span class="hljs-keyword">new</span> Option(i, i));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 根据列表框选择的数字呈现图片</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectLogo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 获取列表框的值</span><br>    <span class="hljs-keyword">var</span> load = <span class="hljs-built_in">document</span>.getElementByid(<span class="hljs-string">&quot;load&quot;</span>);<br>    <span class="hljs-keyword">var</span> n = load.value;<br>    <span class="hljs-keyword">var</span> loadImg = <span class="hljs-built_in">document</span>.getElementByid(<span class="hljs-string">&quot;logoImg&quot;</span>);<br>    loadImg.src = <span class="hljs-string">&quot;image/headLogo/&quot;</span> + n + <span class="hljs-string">&quot;.gif&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="checkbox">checkbox</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> flag=<span class="hljs-literal">true</span>;  <span class="hljs-comment">// 全局变量</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkInterest</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> interest = <span class="hljs-built_in">document</span>.getElementsByName(<span class="hljs-string">&quot;interest&quot;</span>);  <span class="hljs-comment">// 提取出数组</span></span><br><span class="javascript">            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; interest.length; i ++ )&#123;</span><br>                interest[i].checked=flag;<br>            &#125;<br><span class="javascript">            <span class="hljs-keyword">if</span> (flag)&#123;</span><br><span class="javascript">                <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn1&quot;</span>).value=<span class="hljs-string">&quot;全不选&quot;</span>;</span><br>            &#125;<br><span class="javascript">            <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn1&quot;</span>).value=<span class="hljs-string">&quot;全选&quot;</span>;</span><br>            &#125;<br><span class="javascript">            <span class="hljs-comment">// 开关变量</span></span><br><span class="javascript">            flag = !flag;  <span class="hljs-comment">// 将flag取反，以便于下次全不选。</span></span><br>        &#125;<br><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fancheckInterest</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> interest = <span class="hljs-built_in">document</span>.getElementsByName(<span class="hljs-string">&quot;interest&quot;</span>);  <span class="hljs-comment">// 提取出数组</span></span><br><span class="javascript">            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; interest.length; i ++ )&#123;</span><br>                interest[i].checked= !interest[i].checked;<br><span class="javascript">                <span class="hljs-built_in">console</span>.log(interest[i].value);  <span class="hljs-comment">// 获取复选框里的值</span></span><br>            &#125;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>游泳<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>爬山<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>看书<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;全选&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;checkInterest()&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;反选&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fancheckInterest()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS入门</title>
    <link href="/2021/02/21/CSS%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/21/CSS%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="css-入门">CSS 入门</h1><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210224100506933.png" alt="image-20210224100506933" /><figcaption>image-20210224100506933</figcaption></figure><h2 id="css-简介">CSS 简介</h2><ul><li>CSS：层叠样式表 (Cascading Style Sheets)</li><li>样式定义如何显示 HTML 元素</li><li>样式可以解决内容与表现分离的问题</li><li>外部样式表可以极大提高工作效率</li><li>外部样式表通常存储在 CSS 文件中</li><li>多个样式定义可层叠为一</li></ul><p>所有的主流浏览器均支持层叠样式表。样式表允许以多种方式规定样式信息，可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中，甚至可以在同一个 HTML 文档内部引用多个外部样式表。</p><h3 id="层叠次序">层叠次序</h3><p>当同一个 HTML 元素被不止一个样式定义时，会使用哪个样式呢？</p><p><strong>答：</strong>一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，优先级降序排列。如果是相同优先级，在下面的代码会覆盖上面的。</p><ol type="1"><li>内联样式（在 HTML 元素内部）有最高优先级</li><li>内部样式表（位于 标签内部）</li><li>外部样式表</li><li>浏览器缺省设置</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>css_test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--3rd: 外部样式表--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;my_css&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--2nd: 内部样式表--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>        p &#123;<br>        color: green;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--1st: 内联样式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>内联样式在这里！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="css-语法">CSS 语法</h3><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">selector</span> &#123;<br>    declaration1; <br>    <span class="hljs-selector-tag">declaration2</span>; <br>    ... <br>    <span class="hljs-selector-tag">declarationN</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>选择器是需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性（property）是希望设置的样式属性（style attribute）。每个属性有一个值。属性和值用冒号分开</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">selector</span> &#123;<br>    property1: value1; <br>    <span class="hljs-selector-tag">property2</span>: <span class="hljs-selector-tag">value2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何插入样式表">如何插入样式表</h3><h4 id="外部样式表">1. 外部样式表</h4><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，可以通过改 变一个文件来改变整个站点的外观。每个页面使用 标签链接到样式表。 标签在（文档的）头部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">head</span>&gt;<br>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot; /&gt;<br>&lt;/<span class="hljs-selector-tag">head</span>&gt;<br></code></pre></td></tr></table></figure><p>浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档。</p><blockquote><p>注意：不要在属性值与单位之间留有空格。</p><p>“margin-left: 20 px” 与“margin-left: 20px” 是有区别的！</p></blockquote><h4 id="内部样式表">2. 内部样式表</h4><p>当单个文档需要特殊的样式时，就应该使用内部样式表。使用 <code>&lt;style&gt;</code> 标签在文档头部定义内部样式表，就像这样:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">head</span>&gt;<br>    &lt;style type=&quot;text/css&quot;&gt;<br>    <span class="hljs-selector-tag">hr</span> &#123;<span class="hljs-attribute">color</span>: sienna;&#125;<br>    <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-left</span>: <span class="hljs-number">20px</span>;&#125;<br>    <span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;images/back40.gif&quot;</span>);&#125;<br>    &lt;/<span class="hljs-selector-tag">style</span>&gt;<br>&lt;/<span class="hljs-selector-tag">head</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="内联样式">3. 内联样式</h4><p>要使用内联样式，只需要在标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。下例 展示如何改变段落的颜色和左外边距：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;p style=&quot;color: blue; margin-left: 50px&quot;&gt;<br><span class="hljs-selector-tag">This</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">paragraph</span><br>&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure><p style="color: blue; margin-left: 50px">This is a paragraph</p><blockquote><p>尽量不要使用内联样式！保持内容和样式的分离解耦！</p></blockquote><h2 id="css-选择器">CSS 选择器</h2><h3 id="元素选择器-标签">1. 元素选择器: 标签</h3><p>最常见的 CSS 选择器是元素选择器，又称为类型选择器（type selector）。文档的元素就是最基本的选择器，也就是根据标签类型来选择</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">color</span>:black;<br>&#125;<br><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">color</span>:blue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分组选择器-逗号">2. 分组选择器: 逗号</h3><p>将多种选择器用逗号分隔，同时进行CSS设置，则称为分组选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>:gray;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通配符选择器">3. 通配符选择器: *</h3><p>通配选择器（universal selector）：一个星号（*）。该选择器可以与任何元素匹配，就像是一个通配符。</p><p>例如，下面的规则可以使文档中的每个元素都为红色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类选择器-圆点-.">4. 类选择器: 圆点 .</h3><p>使用标签所设置的class类属性来选择元素。只有适当地标记文档后，才能使用这些选择器。 为了将类选择器的样式与元素关联，必须将 class 指定为一个适当的值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;h1 class=&quot;important&quot;&gt;<br><span class="hljs-selector-tag">This</span> <span class="hljs-selector-tag">heading</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">very</span> <span class="hljs-selector-tag">important</span>.<br>&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>&lt;p class=&quot;important&quot;&gt;<br><span class="hljs-selector-tag">This</span> <span class="hljs-selector-tag">paragraph</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">very</span> <span class="hljs-selector-tag">important</span>.<br>&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure><p>类选择器通过圆点来实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.important</span> &#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：样式的效果是可以叠加的。</p></blockquote><h3 id="id-选择器">5. ID 选择器:</h3><p>可以为每个标签设置一个在整个文档内独一无二的ID，然后利用这个ID选择这个标签！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;p id=&quot;intro&quot;&gt;This is a paragraph of introduction.&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>id选择器的语法是：<strong>#</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#intro</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>:bold;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<strong>类选择器和 ID 选择器可是区分大小写的。</strong></p><h3 id="属性选择器">6. 属性选择器：[]</h3><p>属性选择器可以根据元素的属性及属性值来选择元素。</p><p>下面的例子为带有 title 属性的所有元素设置样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[title]</span> &#123;<br><span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><p>属性和值选择器：还可以为属性=指定值的元素设置样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[title=hello]</span> &#123;<br><span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：属性与属性值必须完全匹配</p></blockquote><p>下列是更多的属性匹配方法：（有点像正则表达式）</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210222150542698.png" alt="pokeman-parameters" style="width:95%;"/></center><h3 id="后代选择器-空格">7. 后代选择器: 空格</h3><p><u>利用祖先与后代关系</u>，逐渐缩小查找范围的上下文选择器。</p><p>例如对 h1 元素中的 em 元素应用样式，可以这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> <span class="hljs-selector-tag">em</span> &#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个规则会把作为 h1 元素后代的 em 元素的文本变为 红色。</p><p>注：对于后代选择器，<strong>两个元素之间的层次间隔可以是无限的</strong>。也就是祖先与后代不用是父子这种直接后代关系，可以跨越多个层级。</p><p>举个栗子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 1<br>        <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 1-1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 1-2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 1-3<br>                <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 1-3-1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>1-3-2<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 1-3-3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 1-4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>比如，如果写作 ul em，这个语法就会选择从 ul 元素继承的所有 em 元素，而不论 em 的嵌套层次多深。</p><p>再比如，如果我写 ul li ol li ol ，就是选中 1-3-1/2/3 。如果我改成 ul li li ol ，结果不变。</p><h3 id="子元素选择器">8. 子元素选择器: &gt;</h3><p>如果不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素的子元素，也就是<strong>直接的父子关系</strong>，可以使用子元素选择器（Child selector）。</p><p>例如，如果希望选择只作为 h1 元素子元素的 strong 元素，可以这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &gt; <span class="hljs-selector-tag">strong</span> &#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个规则会把第一个 h1 下面的两个 strong 元素变为红色，但是第二个 h1 中的 strong 不受影响：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is <br>    <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>very<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>very<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> <br>    important.<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is <br>    <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>really <br>        <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>very<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span> <br>    important.<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>小练习：看下面这个选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span><span class="hljs-selector-class">.company</span> <span class="hljs-selector-tag">td</span> &gt; <span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>答：选择作为 td 元素子元素的所有 p 元素，这个 td 元素本身从 table 元素继承，该 table 元素有 一个包含 company 的 class 属性。</p></blockquote><h3 id="相邻兄弟选择器">9. 相邻兄弟选择器: +</h3><p>相邻兄弟选择器（Adjacent sibling selector）选择<strong>紧接在元素后的同级元素</strong>，二者有相同父元素。</p><p>例如，如果要增加紧接在 h1 元素后出现的段落的上边距，可以这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个选择器读作：“选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素”</p></blockquote><p>栗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>List item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>选择器为：<code>li + li &#123;font-weight:bold;&#125;</code></p><p>想象一下应该是什么样？</p><blockquote><p>答：无序列表和有序列表的2nd，3rd都被选中。</p></blockquote><h3 id="伪类选择器-冒号">10. 伪类选择器 冒号 :</h3><p>有一些标签具有不同的状态，被称为伪类。例如<u>超级链接a标签</u>！链接的不同状态都可以不同的方式显 示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF0000</span>&#125;    <span class="hljs-comment">/* 未访问的链接 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#00FF00</span>&#125; <span class="hljs-comment">/* 已访问的链接 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF00FF</span>&#125;   <span class="hljs-comment">/* 鼠标移动到链接上 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#0000FF</span>&#125;  <span class="hljs-comment">/* 选定的链接 */</span><br></code></pre></td></tr></table></figure><p>通过伪类选择器可以对a标签的不同状态设置不同的css样式</p><p>注：</p><ol type="1"><li>在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。</li><li>在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。</li></ol><p>其他伪类：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210222210155451.png" alt="pokeman-parameters" style="width:95%;"/></center><h3 id="伪元素选择器">11. 伪元素选择器 ::</h3><table><thead><tr class="header"><th>属性</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>::selection</td><td>选择指定元素中被用户选中的内容</td></tr><tr class="even"><td>::before</td><td>可以在内容之前插入新内容</td></tr><tr class="odd"><td>::after</td><td>可以在内容之后插入新内容</td></tr><tr class="even"><td>::first-line</td><td>选择指定选择器的首行</td></tr><tr class="odd"><td>::first-letter</td><td>选择文本的第一个字符</td></tr></tbody></table><p>举个栗子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">        <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;</span><br>            content: &quot;《&quot;;<br>        &#125;<br><span class="css">        <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span> &#123;</span><br>            content: &quot;》&quot;;<br>        &#125;<br><span class="css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::selection</span> &#123;</span><br>    background-color: yellow;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>图书名称<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Java程序设计<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Java编程思想<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Java核心技术<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="css-常用样式">CSS 常用样式</h2><h3 id="背景色-background-color">1. 背景色 background-color</h3><p>可以使用 <strong>background-color</strong> 属性为元素<strong>设置背景色</strong>。这个属性接受任何合法的颜色值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背景图像-background-image">2. 背景图像 background-image</h3><p>要<strong>把图像放入背景</strong>，需要使用 <strong>background-image</strong> 属性，其默认值是 none，表示背景上没有放置任 何图像。如果需要设置一个背景图像，必须为这个属性设置一个 URL 值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(avatar.jpg);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缩进文本-text-indent">3. 缩进文本 text-indent</h3><p>CSS 提供了 <strong>text-indent</strong> 属性，该属性可以方便地实现<strong>文本缩进</strong>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">2em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="水平对齐方式-text-align">4. 水平对齐方式 text-align</h3><p><strong>text-align</strong> 是一个基本的属性，它会影响一个元素中的文本行互相之间的<strong>对齐方式</strong>。值 left、right 和 center 会导致元素中的文本分别左对齐、右对齐和居中。默认值是 left。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字间隔-word-spacing">5. 字间隔 word-spacing</h3><p><strong>word-spacing</strong> 属性可以改变<strong>字（单词）之间的标准间隔</strong>。其默认值 normal 与设置值为 0 是一样的。 word-spacing 属性接受一个正长度值或负长度值。如果提供一个正长度值，那么字之间的间隔就会增 加。为 word-spacing 设置一个负值，会把它拉近</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">word-spacing</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字母间隔-letter-spacing">6. 字母间隔 letter-spacing</h3><p><strong>letter-spacing</strong> 属性与 word-spacing 的区别在于，字母间隔修改的是<strong>字符或字母之间的间隔</strong>。 与 word-spacing 属性一样，letter-spacing 属性的可取值包括所有长度。默认关键字是 normal。 输入的长度值会使字母之间的间隔增加或减少指定的量：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">letter-spacing</span>: -<span class="hljs-number">0.5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符转换-text-transform">7. 字符转换 text-transform</h3><p><strong>text-transform</strong> 属性处理文本的<strong>大小写</strong>。</p><p>这个属性有 4 个值：</p><ul><li>none ：将使用源文档中的原有大小写。</li><li>uppercase ：全大写字符</li><li>lowercase ：全小写字符</li><li>capitalize ：只对每个单词的首字母大写。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">text-transform</span>: capitalize;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文本装饰-text-decoration">8. 文本装饰 text-decoration</h3><p><strong>text-decoration</strong> 属性用来给文本进行一些<strong>特殊装饰</strong>。</p><p>text-decoration 可取值：</p><ul><li>none ：关闭原本应用到一个元素上的所有装饰。</li><li>underline ：对元素加下划线。</li><li>overline ：在文本的顶端画一个上划线。</li><li>line-through ：在文本中间画一个贯穿线。</li></ul><blockquote><p>通常，无装饰的文本是默认外观，但也不总是这样。例如，链接默认地会有下划线。如果想去掉超链接的下划线，可以使用以下 CSS 来做到这一点：<code>a &#123;text-decoration: none;&#125;</code></p></blockquote><ul><li>CSS 文本更多属性</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210222212440346.png" alt="pokeman-parameters" style="width:95%;"/></center><h3 id="css-字体">9. CSS 字体</h3><p>CSS 字体属性定义文本的字体系列、大小、加粗、风格（如斜体）和变形（如小型大写字母）。</p><p>在 CSS 中，有两种不同类型的字体系列名称：</p><ul><li>通用字体系列 - 拥有相似外观的字体系统组合（比如 &quot;Serif&quot; 或 &quot;Monospace&quot;）</li><li>特定字体系列 - 具体的字体系列（比如 &quot;Times&quot; 或 &quot;Courier&quot;）</li></ul><h4 id="通用字体系列">通用字体系列</h4><p>如果希望文档使用一种 sans-serif 字体，但是并不关心是哪一种字体，以下就是一个合适的声明：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样用户代理就会从 sans-serif 字体系列中选择一个字体（如 Helvetica），并将其应用到 body 元素。因为 有继承，这种字体选择还将应用到 body 元素包含的所有元素，除非有一种更特定的选择器将其覆盖。</p><h4 id="指定字体系列">指定字体系列</h4><p>除了使用通用的字体系列，还可以通过 font-family 属性设置更具体的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br><span class="hljs-attribute">font-family</span>: Georgia;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的规则有可能会产生一个问题，如果用户没有安装 Georgia 字体，就只能使用用户的默认字体来 显示 h1 元素，而不是你想要的字体。可以通过结合特定字体名和通用字体系列来解决这个问题：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-family</span>: Georgia, serif;&#125;<br></code></pre></td></tr></table></figure><h4 id="字体大小">字体大小</h4><p><strong>font-size</strong> 属性设置文本的大小。font-size 值可以是绝对或相对值。</p><ul><li>绝对值：将文本设置为指定的大小。不允许用户在所有浏览器中改变文本大小（不利于可用性）</li><li>相对大小：相对于周围的元素来设置大小。允许用户在浏览器改变文本大小</li></ul><blockquote><p>注意：如果没有规定字体大小，普通文本（比如段落）的默认大小是 16 像素 (16px=1em)。</p></blockquote><h5 id="使用像素来设置字体大小">使用像素来设置字体大小</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">60px</span>;&#125;<br><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">40px</span>;&#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>;&#125;<br></code></pre></td></tr></table></figure><p>虽然可以通过浏览器的缩放工具调整文本大小，但是这实际上是对整个页面的调整，而不仅限于文本。</p><h5 id="使用-em-来设置字体大小">使用 em 来设置字体大小</h5><p>如果要避免在 IE中无法调整文本的问题，许多开发者使用 em 单位代替 pixels。在设置字体大小时，em 的值会相对于父元素的字体大小改变。浏览器中默认的文本大小是 16 像素。因此 1em 的默认尺寸是 16 像素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">3.75em</span>;&#125; <span class="hljs-comment">/* 60px/16=3.75em */</span><br><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">2.5em</span>;&#125; <span class="hljs-comment">/* 40px/16=2.5em */</span><br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">0.875em</span>;&#125; <span class="hljs-comment">/* 14px/16=0.875em */</span><br></code></pre></td></tr></table></figure><h5 id="结合使用百分比和-em">结合使用百分比和 EM</h5><p>在所有浏览器中均有效的方案是为 body 元素（父元素）以百分比设置默认的 font-size 值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">100%</span>;&#125;<br><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">3.75em</span>;&#125;<br><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">2.5em</span>;&#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">0.875em</span>;&#125;<br></code></pre></td></tr></table></figure><p>这样，在所有浏览器中，可以显示相同的文本大小，并允许所有浏览器缩放文本的大小。</p><h3 id="超级链接-a-标签的样式">10. 超级链接 <code>&lt;a&gt;</code> 标签的样式</h3><p>链接的四种状态：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;  <span class="hljs-comment">/* 未被访问的链接 */</span><br>    <span class="hljs-attribute">color</span>:<span class="hljs-number">#FF0000</span>;<br>    <span class="hljs-attribute">a</span>:link &#123;text-decoration:none;&#125; <span class="hljs-comment">/*text-decoration 属性大多用于去掉链接中的下划线：*/</span><br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#B2FF99</span>;&#125;<br>&#125; <br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#00FF00</span>;&#125; <span class="hljs-comment">/* 已被访问的链接 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#FF00FF</span>;&#125; <span class="hljs-comment">/* 鼠标指针移动到链接上 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#0000FF</span>;&#125; <span class="hljs-comment">/* 正在被点击的链接 */</span><br></code></pre></td></tr></table></figure><p>当为链接的不同状态设置样式时，必须按照以下次序规则：</p><ul><li>a:hover 必须位于 a:link 和 a:visited 之后</li><li>a:active 必须位于 a:hover 之后</li></ul><h3 id="列表样式">11. 列表样式</h3><p>CSS 列表属性可以放置、改变列表项标志，或者将图像作为列表项标志</p><h4 id="列表类型">列表类型</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style-type </span>: square/circle/disc/none; <span class="hljs-comment">/*none可以去掉列表的标志*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="列表项图像">列表项图像</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">list-style-image </span>: <span class="hljs-built_in">url</span>(xxx.gif);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表格样式">12. 表格样式</h3><h4 id="表格边框">表格边框</h4><p>设置表格边框，使用 border 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> &#123; <br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="折叠边框">折叠边框</h4><p>border-collapse 属性设置是否将表格边框折叠为单一边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span> &#123; <span class="hljs-attribute">border-collapse</span>:collapse; &#125;<br><span class="hljs-selector-tag">table</span>,<span class="hljs-selector-tag">th</span>,<span class="hljs-selector-tag">td</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black; &#125;<br></code></pre></td></tr></table></figure><h4 id="表格宽度和高度">表格宽度和高度</h4><p>通过 width 和 height 属性定义表格的宽度和高度。</p><p>下面的例子将表格宽度设置为 100%，同时将 th 元素的高度设置为 50px：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span> &#123; <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>; &#125;<br><span class="hljs-selector-tag">th</span> &#123; <span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>tr元素定义表格行</li><li>th元素定义表头</li><li>td元素定义表格单元格。</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210224082357174.png" alt="pokeman-parameters" style="width:75%;"/></center><h4 id="表格文本对齐">表格文本对齐</h4><p><strong>text-align</strong> 属性设置<strong>水平对齐</strong>方式，比如左对齐、右对齐或者居中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">td</span> &#123; <span class="hljs-attribute">text-align</span>:right; &#125;<br></code></pre></td></tr></table></figure><p><strong>vertical-align</strong> 属性设置<strong>垂直对齐</strong>方式，比如顶部对齐、底部对齐或居中对齐：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">td</span> &#123; <span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>; <span class="hljs-attribute">vertical-align</span>:bottom; &#125;<br></code></pre></td></tr></table></figure><h4 id="表格内边距">表格内边距</h4><p>如需控制表格中内容与边框的距离，请为 td 和 th 元素设置 padding 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">td</span> &#123; <br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">15px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="css-盒子模型">CSS 盒子模型</h2><h3 id="块级元素-和-内联行级元素">块级元素 和 内联(行级)元素</h3><p>HTML 元素可分为块级元素或内联元素。</p><ul><li><p>“块级元素”译为 block level element。 块级元素在显示时通常会以新行来开始（和结束）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>“内联元素”译为 inline element。内联元素在显示时通常不会以新行开始，都是在同一行的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="div-标签"><code>&lt;div&gt;</code> 标签</h4><ul><li><p>DIV是层叠样式表中的定位技术，全称DIVision</p></li><li><p><code>&lt;div&gt;</code> 是最重要的块级元素，它是可用于<strong>组合其他 HTML 元素的容器</strong>。</p></li><li><p><code>&lt;div&gt;</code> 没有特定的含义。如果与 CSS 一同使用，<code>&lt;div&gt;</code> 可用于对大的内容块设置样式属性。<code>&lt;div&gt;</code> 常见的用途是<strong>布局文档</strong>。</p></li></ul><h4 id="span-标签"><code>&lt;span&gt;</code> 标签</h4><p><code>&lt;span&gt;</code> 是内联元素，可用作<strong>文本的容器</strong>。它也没有特定的含义。<code>&lt;span&gt;</code> 当与 CSS 一同使用时，<code>&lt;span&gt;</code> 可用于<strong>为部分文本设置样式属性</strong>。</p><h3 id="盒子模型">盒子模型</h3><p>CSS 盒子模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。</p><ul><li>外边距（margin）：是元素与元素之间的距离，或者是元素外面留出的一段空白</li><li>内边距（padding）：元素里的内容与元素边框之间的距离</li><li>边框（border）：元素本身</li><li>内容（content）：元素中放置的东西</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210223152055404.png" alt="pokeman-parameters" style="width:55%;"/></center><p>在 CSS 中，width 和 height 指的是内容区域(也就是元素)的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p><p>栗：假设框的每个边上有 10 个像素的外边距和 5 个像素的内边距。如果希望这个元素框达到 100 个像素， 就需要将内容的宽度设置为 70 像素，请看下图：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210224083420930.png" alt="pokeman-parameters" style="width:50%;"/></center><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">70px</span>;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br><span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内边距">1. 内边距</h4><p>元素的<strong>内边距</strong>在边框和内容区之间。控制该区域的属性是 <strong>padding</strong> 属性。</p><p>栗：可以按照上、右、下、左的顺序分别设置各边的内边距，各边均可以使用不同的单位或百分比值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">0.25em</span> <span class="hljs-number">2ex</span> <span class="hljs-number">20%</span>;&#125;<br></code></pre></td></tr></table></figure><p>或者写成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br><span class="hljs-attribute">padding-top</span>: <span class="hljs-number">10px</span>;<br><span class="hljs-attribute">padding-right</span>: <span class="hljs-number">0.25em</span>;<br><span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">2ex</span>;<br><span class="hljs-attribute">padding-left</span>: <span class="hljs-number">20%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>百分数值是相对于其父元素的 width 计算的，这一点与外边距一样。</p></blockquote><h5 id="box-sizing">box-sizing</h5><p>box-sizing ：padding 的距离由哪里产生。</p><ul><li>content-box：在宽度和高度之外绘制元素的内边距和边框</li><li>border-box：已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</li></ul><h4 id="边框-border">2. 边框 (border)</h4><p>围绕元素内容和内边距的一条或多条线。可以设置元素边框的样式、宽度和颜色。</p><h5 id="边框的宽度-border-width">边框的宽度 border-width</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">P</span> &#123;<br>    <span class="hljs-attribute">border-style</span>: solid; <br>    <span class="hljs-attribute">border-width</span>: <span class="hljs-number">5px</span>/thin/medium/thick;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以按照 top-right-bottom-left 的顺序设置元素的各边边框：</p><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">border-style</span>: solid; <br>    <span class="hljs-attribute">border-width</span>: <span class="hljs-number">15px</span> <span class="hljs-number">5px</span> <span class="hljs-number">15px</span> <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 还可以设置边框单边的宽度：</p><ul><li>border-top-width</li><li>border-right-width</li><li>border-bottom-width</li><li>border-left-width</li></ul><h5 id="边框的颜色-border-color">边框的颜色 border-color</h5><p>border-color 属性，它一次可以接受最多 4 个颜色值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123; <br>    <span class="hljs-attribute">border-style</span>: solid; <br>    <span class="hljs-attribute">border-color</span>: blue <span class="hljs-built_in">rgb</span>(<span class="hljs-number">25%</span>,<span class="hljs-number">35%</span>,<span class="hljs-number">45%</span>) <span class="hljs-number">#909090</span> red; <br>&#125;<br></code></pre></td></tr></table></figure><p>还可以设置边框单边的颜色：</p><ul><li>border-top-color</li><li>border-right-color</li><li>border-bottom-color</li><li>border-left-color</li></ul><h5 id="没有边框">没有边框</h5><p>如果把 border-style 设置为 none 会出现什么情况：</p><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">border-style</span>: none; <br>    <span class="hljs-attribute">border-width</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 尽管边框的宽度是 50px，但是边框样式设置为 none。在这种情况下，不仅边框的样式没有了，其宽度也会变成 0。是因为如果边框样式为 none，即边框根本不存在，那么边框就不可能有宽度，因此边框宽度自动设置 为 0，而不论原先定义的是什么。</p><p>由于 border-style 的默认值是 none，如果没有声明样式，就相当于 border-style: none。因此，<u>如果希望边框出现，就必须声明一个边框样式</u>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">border-width</span>: <span class="hljs-number">20px</span>;&#125; <br></code></pre></td></tr></table></figure><blockquote><p>忘记声明边框样式是一个常犯的错误 :x: 。</p></blockquote><h4 id="外边距-margin">3. 外边距 margin</h4><p>围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。</p><p>设置外边距的方法是使用 <strong>margin</strong> 属性，这个属性接受任何长度单位、百分数值甚至负值。顺时针：上、右、下、左</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">margin </span>: <span class="hljs-number">10px</span> <span class="hljs-number">0px</span> <span class="hljs-number">15px</span> <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以设置单边的外边距：</p><ul><li>margin-top</li><li>margin-right</li><li>margin-bottom</li><li>margin-left</li></ul><h5 id="外边距合并">外边距合并</h5><p>外边距合并指的是，<u>当两个垂直外边距相遇时，它们将合并成一个外边距</u>。合并后的外边距的高度等于两个发生合并的外边距的高度中的<u>较大者</u>。</p><h4 id="元素居中">4. 元素居中</h4><p>这里记录一个有关属性：居中。</p><ul><li><p>文字居中：常作用于文本或图片等内联元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center/left/right;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对象居中：常作用于块元素，且需要配合宽度使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 auto 时要注意，对象必须有宽度。</p></li><li><p>垂直居中：垂直居中可以将行高设置成div宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: (width...or...); <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>水平垂直居中</strong>：<strong>translate()函数</strong>是css3的新特性.在不知道自身宽高的情况下，可以利用它来进行<strong>水平垂直居中</strong>.。</p><p>当使用：<code>top: 50%; left: 50%;</code>， 是以左上角为原点，故不处于中心位置</p><p><strong>translate(-50%,-50%)</strong> 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。</p></li></ul><h2 id="css-定位">CSS 定位</h2><p>CSS 有三种基本的定位机制：普通流、浮动和绝对定位。</p><h3 id="position-属性">position 属性</h3><p>通过使用 position 属性，可以选择 4 种不同类型的定位，这会影响元素框生成的方式。 position 属性值的含义：</p><ul><li><p>static：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框， 置于其父元素中。默认设置</p></li><li><p>relative：元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。</p></li><li><p>absolute：元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含 块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块 级框，而不论原来它在正常流中生成何种类型的框。</p></li><li><p>fixed：元素框的表现类似于将 position 设置为 absolute，不过其包含块是<strong>视窗本身。</strong></p></li></ul><h4 id="相对定位-relative">相对定位 relative</h4><p><strong>设置为相对定位的元素框会偏移某个距离。元素仍然保持其未定位前的形状，它原本所占的空间仍保留。</strong></p><p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然 后，可以通过设置垂直或水平位置，<strong>让这个元素“相对于”它的起点进行移动</strong>。</p><p>栗：将 top 设置为 20px，那么框将在原位置顶部下面 20 像素的地方。如果 left 设置为 30 像素，那么会在元素左边创建 30 像素的空间，也就是将元素向右移动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box_relative</span> &#123;<br><span class="hljs-attribute">position</span>: relative;<br><span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如图：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210224082517679.png" alt="pokeman-parameters" style="width:80%;"/></center><p>注意，在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会<u>导致它覆盖其它框</u>。</p><h4 id="绝对定位-absolute">绝对定位 absolute</h4><p>设置为绝对定位的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</p><blockquote><p>绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看 作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box_relative</span> &#123;<br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如图：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210224084804913.png" alt="pokeman-parameters" style="width:80%;"/></center><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box_relative</span> &#123;<br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置 相对于最初的包含块。</p><p>注意：</p><ol type="1"><li>根据用户代理的不同，最初的包含块可能是画布或 HTML 元素</li><li>因为绝对定位的框与文档流无关，可能会覆盖页面上的其它元素。可以通过设置 z-index 属性 来控制这些框的堆放次序。</li></ol><h4 id="窗口固定-fixed">窗口固定 Fixed</h4><p>fixed 属性值将元素在窗口或html页面内固定，其表现的就像脱离文档， 位置永远不变！常用作“返回顶部”，侧边工具栏等不随着滚动条变化的按钮。</p><h4 id="定位小总结">定位小总结</h4><ol type="1"><li>相对定位和绝对定位的用处？定位的参照物是谁？</li></ol><p>相对定位的参照物是它自己，而绝对定位的参照物是父级元素。</p><p>相对定位不会破坏文档流，而绝对定位会破坏文档流。</p><p>通常，相对定位作为父级单位，绝对定位作为子一级单位。相对定位作为父级单位时可以不设定 top left 这些属性，仅仅供绝对定位有个参照物，这样当一个整体进行移动时，对相对元素的父元素进行整体移动。</p><blockquote><p>一般父元素用相对定位，子元素用绝对定位。</p></blockquote><h3 id="overflow-属性">overflow 属性</h3><p>设置当元素的内容溢出其区域时发生的事情。</p><ul><li>scroll：内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</li><li>auto：如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</li><li>hidden：内容会被修剪，并且其余内容是不可见的。</li></ul><h3 id="z-index-属性">z-index 属性</h3><p>Z-index可用于将一个元素放置于另一元素之后。类似于PPT的置于顶层或底层或下移上移层次的功能</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">DOCTYPE</span> <span class="hljs-selector-tag">html</span>&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;<span class="hljs-selector-tag">head</span>&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>&lt;<span class="hljs-selector-tag">title</span>&gt;<span class="hljs-selector-tag">Demo</span>&lt;/<span class="hljs-selector-tag">title</span>&gt;<br>&lt;style type=&quot;text/css&quot;&gt;<br>    <span class="hljs-selector-id">#b</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">450px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>        <span class="hljs-attribute">background-color</span>: aquamarine;<br>        <span class="hljs-attribute">display</span>: inline-block;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-selector-id">#c</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">background-color</span>: cadetblue;<br>        <span class="hljs-attribute">display</span>: inline-block;<br>    &#125;<br>&lt;/<span class="hljs-selector-tag">style</span>&gt;<br>&lt;/<span class="hljs-selector-tag">head</span>&gt;<br>&lt;<span class="hljs-selector-tag">body</span>&gt;<br><br>        &lt;div id=&quot;b&quot;&gt;&lt;/div&gt;<br>        &lt;div id=&quot;c&quot;&gt;默认的 z-index 是 0。z-index=-1 拥有更低的优先级&lt;/div&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br>&lt;/<span class="hljs-selector-tag">html</span>&gt;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210224090429775.png" alt="pokeman-parameters" style="width:80%;"/></center><h2 id="css-浮动">CSS 浮动</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210224105759767.png" alt="image-20210224105759767" /><figcaption>image-20210224105759767</figcaption></figure><p><strong>浮动，就是让元素跳出正常的布局流，浮动在上层的一个框内。</strong></p><p>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</p><p>首先要知道，div是块级元素，在页面中独占一行，自上而下排列，也就是传说中的<strong>流</strong>。</p><p>如下图：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226222655852.png" alt="pokeman-parameters" style="width:50%;"/></center><p>可以看出，即使div1的宽度很小，页面中一行可以容下div1和div2，div2也不会排在div1后边，因为div元素是独占一行的。</p><p>注意，以上这些理论，是指标准流中的div。</p><h3 id="float-浮动">float 浮动</h3><p><strong>浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。</strong></p><p>float 属性定义元素在哪个方向浮动。在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框， 而不论它本身是何种元素。</p><p>例如，假设上图中的div2浮动，那么它将脱离标准流，但div1、div3、div4仍然在标准流当中，所以div3会自动向上移动，占据div2的位置，重新组成一个流。如图：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226223000071.png" alt="pokeman-parameters" style="width:50%;"/></center><p>图中可以看出，由于对div2设置浮动，因此它不再属于标准流，div3自动上移<strong>顶替</strong>div2的位置，div1、div3、div4依次排列，成为一个新的流。又因为浮动是漂浮在标准流之上的，因此div2挡住了一部分div3，div3看起来变“矮”了。</p><p>这里div2用的是左浮动(float:left;)，可以理解为漂浮起来后靠左排列，右浮动(float:right;)当然就是靠右排列。这里的靠左、靠右是说页面的左、右边缘。</p><p>如果我们把div2采用右浮动，会是如下效果：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226225530133.png" alt="image-20210226225530133" /><figcaption>image-20210226225530133</figcaption></figure><p>此时div2靠页面右边缘排列，不再遮挡div3，读者可以清晰的看到上面所讲的div1、div3、div4组成的流。</p><p>目前为止我们只浮动了一个div元素，多个呢？</p><p>下面我们把div2和div3都加上左浮动，效果如图：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226225550434.png" alt="pokeman-parameters" style="width:60%;"/></center><p>同理，由于div2、div3浮动，它们不再属于标准流，因此div4会自动上移，与div1组成一个“新”标准流，而浮动是漂浮在标准流之上，因此div2又挡住了div4。</p><p>咳咳，到重点了，当同时对div2、div3设置浮动之后，div3会跟随在div2之后。所以说一直到现在，div2在每个例子中都是浮动的，但并没有跟随到div1之后。因此，我们可以得出一个重要结论：</p><p><strong>假如某个 div 元素A是浮动的，如果 A 元素上一个元素也是浮动的，那么 A 元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。</strong></p><p><strong>div的顺序是HTML代码中div的顺序决定的。</strong></p><p><strong>靠近页面边缘的一端是前，远离页面边缘的一端是后。</strong></p><p>举个栗子：假如我们把div2、div4左浮动，效果图如下：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226230430720.png" alt="pokeman-parameters" style="width:50%;"/></center><p>然是根据结论，div2、div4浮动，脱离了标准流，因此div3将会自动上移，与div1组成标准流。div2发现上一个元素div1是标准流中的 元素，因此div2相对垂直位置不变，与div1底部对齐。div4发现上一个元素div3是标准流中的元素，因此div4的顶部和div3的底部对齐， 并且总是成立的，因为从图中可以看出，div3上移后，div4也跟着上移，<strong>div4总是保证自己的顶部和上一个元素div3(标准流中的元素)的底部对齐</strong>。</p><blockquote><p>元素浮动之前，也就是在标准流中，是竖向排列的，而浮动之后可以理解为横向排列。</p></blockquote><p>练习：水平布置的菜单</p><p>在例子中，我们把 ul 元素和 a 元素浮向左浮动。li 元素显示为行内元 素（元素前后没有换行）。这样就可以使列表排列成一行。ul 元素的宽度是 100%，列表中的每个超链接的宽度是 7em（当前字体尺寸的 7 倍）。我们 添加了颜色和边框，以使其更漂亮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br>    ul &#123;<br><span class="css">        <span class="hljs-selector-tag">float</span>: <span class="hljs-selector-tag">left</span>;                    <span class="hljs-comment">/*向左浮动*/</span></span><br>    &#125;<br><br>    a &#123;<br>        color: white;<br>        background-color: darkmagenta;<br><span class="css">        <span class="hljs-selector-tag">float</span>: <span class="hljs-selector-tag">left</span>;                    <span class="hljs-comment">/*向左浮动*/</span></span><br>        width: 7em;<br><span class="css">        <span class="hljs-selector-tag">text-decoration</span>: <span class="hljs-selector-tag">none</span>;          <span class="hljs-comment">/*取消下划线*/</span></span><br><span class="css">        <span class="hljs-selector-tag">border-right</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">white</span>;  <span class="hljs-comment">/*设置边框宽度样式颜色*/</span></span><br><span class="css">        <span class="hljs-selector-tag">padding</span>: 0.2<span class="hljs-selector-tag">em</span> 0.6<span class="hljs-selector-tag">em</span>;           <span class="hljs-comment">/*设置内边距*/</span></span><br>    &#125;<br><br>    li &#123;<br><span class="css">        <span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">inline</span>;                 <span class="hljs-comment">/*设置为行内元素,使列表排成一排*/</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Link one<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Link two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Link three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Link four<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="css-高度塌陷">CSS 高度塌陷</h3><p>什么是高度塌陷？</p><p>在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当子元素设置浮动之后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。</p><p>举个栗子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">DOCTYPE</span> <span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">head</span>&gt;<br>    &lt;<span class="hljs-selector-tag">style</span>&gt;<br>        <span class="hljs-selector-id">#div1</span>&#123;<br>            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>            <span class="hljs-attribute">background-color</span>: red;<br>        &#125;<br>    &lt;/<span class="hljs-selector-tag">style</span>&gt;<br>&lt;/<span class="hljs-selector-tag">head</span>&gt;<br>&lt;<span class="hljs-selector-tag">body</span>&gt;<br>    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br>&lt;/<span class="hljs-selector-tag">html</span>&gt;<br></code></pre></td></tr></table></figure><p>如图：是一个有4条黑色边框组成的框。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226110235556.png" alt="" style="width:80%;"/></center><p>在 div1 父元素下添加两个子元素 div2，div3.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">DOCTYPE</span> <span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">head</span>&gt;<br>    &lt;<span class="hljs-selector-tag">style</span>&gt;<br>        <span class="hljs-selector-id">#div1</span>&#123;<br>            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>            <span class="hljs-attribute">background-color</span>: red;<br>        &#125;<br><br>        <span class="hljs-selector-id">#div2</span> &#123;<br>            <span class="hljs-attribute">background-color</span>: yellow;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>        &#125;<br><br>        <span class="hljs-selector-id">#div3</span> &#123;<br>            <span class="hljs-attribute">background-color</span>: blue;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>        &#125;<br>    &lt;/<span class="hljs-selector-tag">style</span>&gt;<br>&lt;/<span class="hljs-selector-tag">head</span>&gt;<br>&lt;<span class="hljs-selector-tag">body</span>&gt;<br>    &lt;div id=&quot;div1&quot;&gt;<br>        &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;<br>        &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;<br>    &lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br>&lt;/<span class="hljs-selector-tag">html</span>&gt;<br><br></code></pre></td></tr></table></figure><p>如图可以看到：父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226110927113.png" alt="" style="width:80%;"/></center><p>当子元素设置浮动之后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">DOCTYPE</span> <span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">head</span>&gt;<br>    &lt;<span class="hljs-selector-tag">style</span>&gt;<br>        <span class="hljs-selector-id">#div1</span>&#123;<br>            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>            <span class="hljs-attribute">background-color</span>: red;<br>        &#125;<br><br>        <span class="hljs-selector-id">#div2</span> &#123;<br>            <span class="hljs-attribute">background-color</span>: yellow;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>            <span class="hljs-attribute">float</span>: left;<br>        &#125;<br><br>        <span class="hljs-selector-id">#div3</span> &#123;<br>            <span class="hljs-attribute">background-color</span>: blue;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>            <span class="hljs-attribute">float</span>: left;<br>        &#125;<br>    &lt;/<span class="hljs-selector-tag">style</span>&gt;<br>&lt;/<span class="hljs-selector-tag">head</span>&gt;<br>&lt;<span class="hljs-selector-tag">body</span>&gt;<br>    &lt;div id=&quot;div1&quot;&gt;<br>        &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;<br>        &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;<br>    &lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br>&lt;/<span class="hljs-selector-tag">html</span>&gt;<br></code></pre></td></tr></table></figure><p>如图：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226111444913.png" alt="" style="width:80%;"/></center><h3 id="clear-清除">clear 清除</h3><p><strong>清除浮动可以理解为打破横向排列。</strong></p><p><u>为了父元素不会出现“高度崩塌”</u> 。</p><p>如果强制规定外层容器的尺寸，则显得就不那么灵活了，高度就不能自动适应了。比如通常情况下不给父层元素设定高度，让其自适应。</p><p>语法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">clear : none | left | right | both<br></code></pre></td></tr></table></figure><p>取值：</p><ul><li><p>none : 默认值。允许两边都可以有浮动对象</p></li><li><p>left : 不允许左边有浮动对象</p></li><li><p>right : 不允许右边有浮动对象</p></li><li><p>both : 不允许有浮动对象</p></li></ul><p>举个栗子：假如页面中只有两个元素div1、div2，它们都是左浮动，场景如下：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226233406831.png" alt="" style="width:70%;"/></center><p>此时div1、div2都浮动，根据规则，div2会跟随在div1后边，但我们仍然希望div2能排列在div1下边，就像div1没有浮动，div2左浮动那样，这时候就要用到清除浮动（clear）。</p><p><strong>对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。</strong></p><p>拿上边的例子来说，我们是想让div2移动，就必须在div2的CSS样式中使用浮动。本例中div2的左边有浮动元素div1，因此只要在div2的CSS样式中使用clear:left;来指定div2元素左边不允许出现浮动元素，这样div2就被迫下移一行。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210226233710941.png" alt="" style="width:70%;"/></center>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML入门</title>
    <link href="/2021/02/19/HTML%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/19/HTML%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="html-入门">HTML 入门</h1><blockquote><p>学习 HTML 时注意：</p><ol type="1"><li><strong>重理解</strong>：了解标签语法的用法</li><li>页面<strong>先构思</strong>，然后写出来初稿之后，在慢慢调试</li><li>不建议使用过于智能化的工具，<strong>打好基础先</strong>！</li><li>熟能生巧，注重渲染效果</li></ol></blockquote><h2 id="什么是-html">什么是 HTML ?</h2><p>HTML 是用来描述网页的一种标记语言。</p><ul><li><p>HTML 指的是超文本标记语言： <strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</p></li><li><p>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</p></li><li><p>标记语言是一套 <strong>标记标签</strong> (markup tag)</p></li><li><p>HTML 使用标记标签来<strong>描述</strong>网页</p></li><li><p>HTML 文档包含了 HTML <strong>标签</strong>及<strong>文本</strong>内容</p></li><li><p>HTML 文档也叫做 <strong>web 页面</strong></p><p>Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容</p></li></ul><h2 id="html-基础">HTML 基础</h2><h3 id="html-标签">HTML 标签</h3><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。<u>HTML 标签是由尖括号包围的关键词</u>，比如 <code>&lt;html&gt;</code></p><ul><li>HTML 标签通常是成对出现的，比如 <code>&lt;b&gt;</code> 和 <code>&lt;/b&gt;</code> (也有不成对的，例 <code>&lt;hr/&gt;</code> )</li><li>标签对 中的第一个标签是开始标签，第二个标签是结束标签</li><li>开始和结束标签也被称为开放标签和闭合标签</li></ul><p>常用标签：</p><ul><li><p><code>&lt;html&gt;</code> 与 <code>&lt;/html&gt;</code> 之间的文本描述网页</p></li><li><code>&lt;body&gt;</code> 与 <code>&lt;/body&gt;</code> 之间的文本是可见的页面内容</li><li><p><code>&lt;!--这是一条注释--&gt;</code> 注释</p></li></ul><h3 id="html-元素">HTML 元素</h3><p>HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p><ul><li>HTML 元素以开始标签起始，以结束标签终止</li><li>元素的内容是开始标签与结束标签之间的内容</li></ul><h3 id="html-属性">HTML 属性</h3><p>HTML 标签可以拥有属性。属性可以包含元素的更多的信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>常用属性：</p><table><thead><tr class="header"><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>class</code></td><td>classname</td><td>规定元素的类名（classname）</td></tr><tr class="even"><td><code>id</code></td><td>id</td><td>规定元素唯一的 id （相当于元素的身份证，找到元素的方式）</td></tr><tr class="odd"><td><code>style</code></td><td>style_defination</td><td>规定元素的行内样式（inline style）</td></tr><tr class="even"><td><code>title</code></td><td>text</td><td>规定元素的额外信息（可在工具提示中显示）</td></tr></tbody></table><h2 id="html-头部元素head">HTML 头部元素（head）</h2><h3 id="head-元素"><code>&lt;head&gt;</code> 元素</h3><p><code>&lt;head&gt;</code> 元素是所有头部元素的容器。这些标签都可以添加到 head 部分：<code>&lt;title&gt;</code> 、<code>&lt;base&gt;</code> 、<code>&lt;link&gt;</code> 、<code>&lt;meta&gt;</code> 、<code>&lt;script&gt;</code> 、<code>&lt;style&gt;</code></p><h3 id="title-元素"><code>&lt;title&gt;</code> 元素</h3><p><code>&lt;title&gt;</code> 标签定义文档的标题。title 元素在所有 HTML/XHTML 文档中都是必需的。</p><ul><li>定义浏览器工具栏中的标题</li><li>提供页面被添加到收藏夹时显示的标题</li><li>显示在搜索引擎结果中的页面标题</li></ul><h3 id="meta-元素"><code>&lt;meta&gt;</code> 元素</h3><p><code>&lt;meta&gt;</code> 标签提供关于 HTML 文档的元数据。元数据（metadata）是关于数据的信息，元数据不会显示在页面上。</p><p><code>&lt;meta&gt;</code> 元素常被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。 标签始终位于 head 元素中。</p><ul><li>关于 <code>&lt;meta&gt;</code> 元素的属性：</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210220213819035.png" alt="pokeman-parameters" style="width:100%;"/></center><h4 id="content-属性">content 属性</h4><p>content 属性提供了 <u>名称/值对 中的 <strong>值</strong></u>。该值可以是任何有效的字符串。 content 属性始终要和 name 属性或 http-equiv 属性一起使用。</p><h4 id="name-属性">name 属性</h4><p>name 属性提供了 <u>名称/值对 中的 <strong>名称</strong></u>。&quot;keywords&quot; 是一个经常被用到的名称。它为文档定义了 一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。类似这样的 meta 标签可能对于进入搜索引擎的索引有帮助，栗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Free Web tutorials on HTML, CSS, XML&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML, PHP, SQL&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--keywords:HTML, PHP, SQL--&gt;</span><br># name相当于键，content相当于值<br></code></pre></td></tr></table></figure><h4 id="http-equiv-属性">http-equiv 属性</h4><p>http-equiv 属性为 <u>名称/值对提供了 名称，并指示服务器在发送实际的文档之前先在要传送给浏览器 的 MIME 文档头部包含名称/值对。</u></p><p>使用带有 http-equiv 属性的 标签时，服务器将把 <u>名称/值对</u> 添加到发送给浏览器的内容头部。</p><p>栗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;charset&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;iso-8859-1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;expires&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;31 Dec 2008&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样发送到浏览器的头部就应该包含：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">content</span>-type: text/html<br><span class="hljs-attribute">charset</span>:iso-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span><br><span class="hljs-attribute">expires</span>:<span class="hljs-number">31</span> Dec <span class="hljs-number">2008</span><br></code></pre></td></tr></table></figure><blockquote><p>当服务器向浏览器发送文档时，会先发送许多 名称/值对。虽然有些服务器会发送许多这种 名称/值对， 但是所有服务器都至少要发送一个：<code>content-type:text/html</code>。这将告诉浏览器准备接受一个 HTML 文档。</p></blockquote><p>当然，只有浏览器可以接受这些附加的头部字段，并能以适当的方式使用它们时，这些字段才有意义。</p><p>常用的有关 http-equiv 的用法：</p><h5 id="设置网页语言文字">1. 设置网页语言文字</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;content-language&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li>content-language为 http-equiv 属性值，用以标记页面语言</li><li>content取值为语言代码，格式为“语言代码-国家代码”，“zh-CN”表示中文-中国</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;content-type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html;charset=gb2312&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li>content-type用于定义文件的类型和网页的编码。常见编码类型有ASCII, ISO8859-1, GB2312, GBK, UTF-8, UTF-16等。</li></ul><h5 id="定时跳转页面">2. 定时跳转页面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;5;url=http://www.baidu.com&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li>refresh用于刷新与跳转页面</li><li>content属性记录多少秒后跳转和跳转的网址。 也可以刷新本页面，如5秒后刷新本页面</li></ul><h5 id="设置网页缓存过期时间">3. 设置网页缓存过期时间</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;expires&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Sunday 20 March 2021 12:00 GMT&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li>时间必须使用GMT格式，content设置具体的时间值。</li></ul><h3 id="link-元素"><code>&lt;link&gt;</code> 元素</h3><p><code>&lt;link&gt;</code> 标签定义文档与外部资源之间的连接。<code>&lt;link&gt;</code> 标签最常用于连接样式表（css文件）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>href 是样式文件的路径</li></ul><blockquote><p>通过 <code>&lt;link&gt;</code> 导入web的样式文件</p></blockquote><h3 id="style-元素"><code>&lt;style&gt;</code> 元素</h3><p><code>&lt;style&gt;</code> 标签用于为 HTML 文档定义样式信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-color</span>:yellow&#125;</span><br><span class="css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue&#125;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="script-元素"><code>&lt;script&gt;</code> 元素</h3><p><code>&lt;script&gt;</code> 标签用于设置 JavaScript 内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>或者<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;hhh&quot;</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="html-常用标签body">HTML 常用标签（body）</h2><h3 id="标题-hx">标题 <code>&lt;hx&gt;</code></h3><p>HTML 标题（Heading）是通过 <code>&lt;h1&gt;-&lt;h6&gt;</code> 等标签进行定义的。</p><p><code>&lt;h1&gt;</code> 定义最大的标题。<code>&lt;h6&gt;</code> 定义最小的标题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后。</p></blockquote><h3 id="水平线-hr">水平线 <code>&lt;hr/&gt;</code></h3><p><code>&lt;hr/&gt;</code> 标签在 HTML 页面中创建水平线。hr 元素可用于分隔内容。</p><hr/><h3 id="段落-p">段落 <code>&lt;p&gt;</code></h3><p>段落是通过 <code>&lt;p&gt;</code> 标签定义的。浏览器会自动地在段落的前后添加空行。（<code>&lt;p&gt;</code> 是块级元素）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is another paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>This is a paragraph</p><p>This is another paragraph</p><h3 id="换行-br">换行 <code>&lt;br/&gt;</code></h3><p>如果想要在不产生一个新段落的情况下进行换行（新行），可以使用 <code>&lt;br/&gt;</code> 标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>a para<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>graph with line breaks<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>This is<br />a para<br />graph with line breaks</p><h3 id="空白字符-nbsp">空白字符 <code>&amp;nbsp</code></h3><p>当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。</p><h3 id="超链接-a">超链接 <code>&lt;a&gt;</code></h3><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，可以点击这些内容来跳转到新的文档 或者当前文档中的某个部分。</p><p>通过使用 <code>&lt;a&gt;</code> 标签在 HTML 中创建链接。有两种使用 <code>&lt;a&gt;</code> 标签的方式：</p><ol type="1"><li><p>使用 href 属性：创建指向另一个文档的链接</p><ul><li><p>href 属性规定链接的目标。开始标签和结束标签之间的文字被作为超级链接来显示。</p><blockquote><p>协议名不能省：<code>https://</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“https://www.baidu.com/”</span>&gt;</span>百度首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://www.baidu.com/">百度首页</a></p></li><li><p>Target 属性可以定义被链接的文档在何处显示。</p><ul><li>_self 在当前窗口打开；</li><li>_blank 在新窗口打开；</li><li><p>_parent 在父窗口打开；</p></li><li><p>_top 在框架中打开;</p></li></ul><p>下面的这行会在新窗口打开文档：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“https://www.baidu.com/”</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>百度首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://www.baidu.com/" target="_blank">百度首页</a></p></li></ul></li><li><p>使用 name 属性：规定<a name="last_para"><strong>锚（anchor）的名称</strong></a>，创建文档内的书签</p><p>name 属性规定<strong>锚（anchor）的名称</strong>，用于创建 HTML 页面中的书签。<u>当使用命名锚（named anchors）时，可以创建直接跳至该命名锚（比如页面中某个小节）的链接</u>， 这样就无需不停地滚动页面来寻找需要的信息了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;label&quot;</span>&gt;</span>锚（显示在页面上的文本）<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>锚的名称可以是自定义的名字。 可以使用 id 属性来替代 name 属性，命名锚同样有效。</li><li>HTML 页面中的书签不会以任何特殊方式显示，它对读者是不可见的。</li></ul></blockquote><p>栗：首先，在 HTML 文档中对锚进行命名（创建一个书签）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tips&quot;</span>&gt;</span>基本的注意事项 - 有用的提示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后，在同一个文档中创建指向该锚的链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#tips&quot;</span>&gt;</span>有用的提示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>或者也可以在其他页面中创建指向该锚的链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“http://www.xxx.com.cn/xxx.html#tips</span>&quot;&gt;</span>有用的提示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><u>在代码中，将 <strong>#</strong> 符号和<strong>锚名称</strong>添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。</u></p></li></ol><blockquote><p>注：我自己实验是这样的：先给出超链接，再将锚放到想到跳转的位置前。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#last_para&quot;</span>&gt;</span>跳转到最后一段<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>balabala...<br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;last_para&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    这里是最后一段。<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后点击<a href="#last_para">跳转到最后一段</a>，就跳转到<strong>锚</strong>所在的位置。</p></blockquote><h3 id="图像-img">图像 <code>&lt;img/&gt;</code></h3><p>在 HTML 中，图像由 <code>&lt;img/&gt;</code> 标签定义。定义图像的语法是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xx&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;xx&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;xx&quot;</span> <span class="hljs-attr">bala..</span>&gt;</span><br></code></pre></td></tr></table></figure><p>栗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sea.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;sea&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>alt</code> ：在浏览器无法载入图像时，将显示这个替代性的文本</p></blockquote><h3 id="表格-table">表格 <code>&lt;table&gt;</code></h3><p>表格由 <code>&lt;table&gt;</code> 标签来定义。每个表格均有若干行（由 <code>&lt;tr&gt;</code> 标签定义），每行被分割为若干单元格 （由 <code>&lt;td&gt;</code> 标签定义）。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>第1列<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>第2列<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>第3列<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1.3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3.2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3.3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>表底1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>表底2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>表底3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span>   <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示出来：</p><table border="3"><thead><tr><th>第1列</th><th>第2列</th><th>第3列</th></tr></thead><tbody><tr><td>1.1</td><td>1.2</td><td>1.3</td></tr><tr><td>2.1</td><td>2.2</td><td>2.3</td></tr><tr><td>3.1</td><td>3.2</td><td>3.3</td></tr></tbody><tfoot><tr><td>表底1</td><td>表底2</td><td>表底3</td></tr></tfoot></table><h3 id="列表">列表</h3><h4 id="无序列表-li">1. 无序列表 <code>&lt;li&gt;</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>one<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>two<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>two.one<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>two.one<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>three<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>one</li><li>two</li><ul><li>two.one</li><li>two.one</li></ul><li>three</li></ul><h4 id="有序列表-ol">2. 有序列表 <code>&lt;ol&gt;</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>one<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>two<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>two.one<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>two.one<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>three<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>one</li><li>two</li><ol><li>two.one</li><li>two.one</li></ol><li>three</li></ol><h4 id="自定义列表">3. 自定义列表</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Black hot drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>White cold drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><dl><dt>Coffee</dt><dd>Black hot drink</dd><dt>Milk</dt><dd>White cold drink</dd></dl><h3 id="div-和-span"><code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code></h3><p>可以通过 <code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code> 将 HTML 元素组合起来。</p><h4 id="块级元素-和-内联元素">块级元素 和 内联元素</h4><p>HTML 元素可分为块级元素或内联元素。</p><ul><li><p>“块级元素”译为 block level element。 块级元素在显示时通常会以新行来开始（和结束）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>“内联元素”译为 inline element。内联元素在显示时通常不会以新行开始，都是在同一行的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="div-标签"><code>&lt;div&gt;</code> 标签</h4><p><code>&lt;div&gt;</code> 是最重要的块级元素，它是可用于<strong>组合其他 HTML 元素的容器</strong>。</p><p><code>&lt;div&gt;</code> 没有特定的含义。如果与 CSS 一同使用，<code>&lt;div&gt;</code> 可用于对大的内容块设置样式属性。<code>&lt;div&gt;</code> 常见的用途是<strong>布局文档</strong>。</p><p>栗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>City Gallery<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span><br>        London<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        Paris<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        Tokyo<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;section&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>London<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            London is the capital city of England. It is the<br>            most populous city in the United Kingdom,<br>            with a metropolitan area of over 13 million<br>            inhabitants.<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            Standing on the River Thames, London has<br>            been a major settlement for two millennia,<br>            its history going back to its founding by the<br>            Romans, who named it Londinium.<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><br>        Copyright W3School.com.cn<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210221132246024.png" alt="pokeman-parameters" style="width:80%;"/></center><h4 id="span-标签"><code>&lt;span&gt;</code> 标签</h4><p><code>&lt;span&gt;</code> 是内联元素，可用作<strong>文本的容器</strong>。它也没有特定的含义。<code>&lt;span&gt;</code> 当与 CSS 一同使用时，<code>&lt;span&gt;</code> 可用于<strong>为部分文本设置样式属性</strong>。</p><p>栗：在头部中添加 <code>&lt;style&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-id">#header</span> &#123;</span><br><span class="css">            <span class="hljs-selector-tag">background-color</span><span class="hljs-selector-pseudo">:black</span>;</span><br><span class="css">            <span class="hljs-selector-tag">color</span><span class="hljs-selector-pseudo">:white</span>;</span><br><span class="css">            <span class="hljs-selector-tag">text-align</span><span class="hljs-selector-pseudo">:center</span>;</span><br><span class="css">            <span class="hljs-selector-tag">padding</span><span class="hljs-selector-pseudo">:5px</span>;</span><br>        &#125;<br><span class="css">        <span class="hljs-selector-id">#nav</span> &#123;</span><br><span class="css">            <span class="hljs-selector-tag">line-height</span><span class="hljs-selector-pseudo">:30px</span>;</span><br><span class="css">            <span class="hljs-selector-tag">background-color</span>:<span class="hljs-selector-id">#eeeeee</span>;</span><br><span class="css">            <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:300px</span>;</span><br><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:100px</span>;</span><br><span class="css">            <span class="hljs-selector-tag">float</span><span class="hljs-selector-pseudo">:left</span>;</span><br><span class="css">            <span class="hljs-selector-tag">padding</span><span class="hljs-selector-pseudo">:5px</span>;</span><br>        &#125;<br><span class="css">        <span class="hljs-selector-id">#section</span> &#123;</span><br><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:350px</span>;</span><br><span class="css">            <span class="hljs-selector-tag">float</span><span class="hljs-selector-pseudo">:left</span>;</span><br><span class="css">            <span class="hljs-selector-tag">padding</span><span class="hljs-selector-pseudo">:10px</span>;</span><br>        &#125;<br><span class="css">        <span class="hljs-selector-id">#footer</span> &#123;</span><br><span class="css">            <span class="hljs-selector-tag">background-color</span><span class="hljs-selector-pseudo">:black</span>;</span><br><span class="css">            <span class="hljs-selector-tag">color</span><span class="hljs-selector-pseudo">:white</span>;</span><br><span class="css">            <span class="hljs-selector-tag">clear</span><span class="hljs-selector-pseudo">:both</span>;</span><br><span class="css">            <span class="hljs-selector-tag">text-align</span><span class="hljs-selector-pseudo">:center</span>;</span><br><span class="css">            <span class="hljs-selector-tag">padding</span><span class="hljs-selector-pseudo">:5px</span>;</span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>加了 CSS 样式之后就变成了：</p><center><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210221132436371.png" alt="pokeman-parameters" style="width:80%;"/></center><h2 id="html-表单">HTML 表单</h2><h3 id="form-元素"><code>&lt;form&gt;</code> 元素</h3><p><code>&lt;form&gt;</code> 元素定义表单。表单用于收集用户输入，表单元素指的是不同类型的 input 元素、复选框、单选按钮、提交按钮等等。</p><p><code>&lt;form&gt;</code> 标签框定了表单的整体架构。</p><h4 id="action-属性">Action 属性</h4><p>Action 属性定义在提交表单时执行的动作，<u>就是提交表单的地址</u>。向服务器提交表单的通常做法是使用提交按钮。通常，表单会被提交到 web 服务器上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;test1.html&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果省略 action 属性，则 action 会被设置为当前页面。</p><h4 id="method-属性">Method 属性</h4><p>method 属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;action_page.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;GET&quot;</span>&gt;</span><br>或   <br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;action_page.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;GET&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="何时使用-get">何时使用 GET？</h5><p>GET（默认方法），如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息的时候何 以使用GET。</p><p>使用 GET 时，表单数据在页面地址栏中是可见的，栗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">action_page.php?firstname=Mickey&amp;lastname=Mouse<br></code></pre></td></tr></table></figure><p>注释：GET 适合少量不敏感数据的提交。浏览器会设定容量限制。</p><h5 id="何时使用-post">何时使用 POST？</h5><p>如果表单正在更新数据，或者包含敏感信息（例如密码）。</p><p>POST 的安全性更好，因为在页面地址栏中被提交的数据是不可见的。</p><h4 id="name-属性-1">Name 属性</h4><p>如果要正确地被提交，每个输入字段必须设置一个 name 属性。</p><h3 id="input-元素"><code>&lt;input&gt;</code> 元素</h3><p><code>&lt;input&gt;</code> 元素是最重要的表单元素。</p><p><code>&lt;input&gt;</code> 元素有很多形态，根据不同的 type 属性。例如，text、radio、checkbox等等。</p><ul><li><code>&lt;input type=&quot;text&quot;&gt;</code> <strong>文本框</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>First name:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstname&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>Last name:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastname&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure><form>First name:<br> <input type="text" name="firstname"> <br> Last name:<br> <input type="text" name="lastname"></form><ul><li><code>&lt;input type=&quot;radion&quot;&gt;</code> <strong>单选按钮</strong></li></ul><blockquote><p>注意这里的默认选择是：<code>checked</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">checked</span>&gt;</span> 男人<br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span> 女人<br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yifei&quot;</span>&gt;</span> 胡一菲<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure><blockquote><p>相同的 <code>name</code> 表示他们是一组的</p></blockquote><form><input type="radio" name="sex" value="male" checked> 男人 <br/> <input type="radio" name="sex" value="female"> 女人 <br/> <input type="radio" name="sex" value="yifei"> 胡一菲</form><ul><li><code>&lt;input type=&quot;checkbox&quot;&gt;</code> <strong>复选框</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;vehicle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Bike&quot;</span>&gt;</span> I have a bike<br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;vehicle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Car&quot;</span>&gt;</span> I have a car<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure><form><input type="checkbox" name="vehicle" value="Bike"> I have a bike <br> <input type="checkbox" name="vehicle" value="Car"> I have a car</form><ul><li><code>&lt;input type=&quot;submit&quot;&gt;</code> <strong>提交按钮</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://www.baidu.com/s&quot;</span>&gt;</span><br>        关键字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wd&quot;</span> /&gt;</span>  <br>        <span class="hljs-comment">&lt;!--这里写wd是因为百度搜索时的url后的关键字是wd=--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;搜索&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>&lt;!DOCTYPE html&gt;<html lang="en"><head><meta charset="UTF-8"></head><body><form action="http://www.baidu.com/s">关键字：<input type="text" name="wd" /> <input type="submit" value="搜索" /></form></body></html><ul><li><code>&lt;input type=&quot;reset&quot;&gt;</code> <strong>重置</strong></li></ul><p>重置form表单内的所有输入。表单外的无影响。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;重置&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;input type=&quot;pasword&quot;&gt;</code> <strong>密码</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    User name:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    User password:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;psw&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure><form>User name:<br> <input type="text" name="username"> <br> User password:<br> <input type="password" name="psw"></form><ul><li><code>&lt;input type=&quot;file&quot;&gt;</code> <strong>上传文件</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;upload&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>用于向服务器传送文件。需要在 <code>&lt;form&gt;</code> 标签 里添加 <code>enctype=“multipart/form-data”</code> 属性。</p><form><input type="file" name="upload" /></form><ul><li><code>&lt;input type=&quot;email&quot;&gt;</code> <strong>邮件地址</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><form>邮箱地址：<input type="email" name="email" /></form><h3 id="select-元素"><code>&lt;select&gt;</code> 元素</h3><p><code>&lt;select&gt;</code> 元素定义下拉列表。</p><blockquote><p>注意这里的默认选择是：<code>selected</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cars&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;data science&quot;</span>&gt;</span>Data Science<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;natural language processing&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>Natural Language Processing<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;computer vision&quot;</span>&gt;</span>Computer Vision<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;recommender system&quot;</span>&gt;</span>Recommender System<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><select name="cars"> <option value="data science">Data Science</option> <option value="natural language processing" selected>Natural Language Processing</option> <option value="computer vision">Computer Vision</option> <option value="recommender system">Recommender System</option> </select></p><h3 id="textarea-元素"><code>&lt;textarea&gt;</code> 元素</h3><p><code>&lt;textarea&gt;</code> 元素定义多行输入字段（文本域）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;80&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span> 元素定义多行输入字段<br><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><textarea name="message" rows="3" cols="80"><textarea>元素定义多行输入字段</textarea><h3 id="输入限制">输入限制</h3><p>下面是一些常用的输入限制（其中一些是 HTML5 中新增的）：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210221171050875.png" alt="pokeman-parameters" style="width:80%;"/></center><h2 id="字符实体">字符实体</h2><p>在 HTML 中，某些字符是预留的。HTML 中的预留字符必须被替换为字符实体。</p><p>栗：在 HTML 中不能使用小于号 <code>&lt;</code> 和大于号 <code>&gt;</code> ，这是因为浏览器会误认为它们是标签。就得换成 <code>&amp;lt;</code> 和 <code>gt;</code></p><blockquote><p>转义字符必须以 <code>;</code> 结束</p></blockquote><p>常用的字符实体：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210221171808422.png" alt="pokeman-parameters" style="width:100%;"/></center><h2 id="小练习">小练习</h2><ol type="1"><li>实现下列图片</li></ol><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210221175901800.png" alt="pokeman-parameters" style="width:60%;"/></center><p>实现代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;700px&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200px&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>小木课程表<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;#0DBBD0&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期一<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期二<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期三<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期四<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期五<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期六<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期日<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>偏微分方程<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>实变函数<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>泛函分析<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>常微分方程<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>解析几何<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>体育活动<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>高等代数<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>数学分析<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>解析几何<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>实变函数<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>泛函分析<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>HTML<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;7&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>午休<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>班会<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>泛函分析<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>偏微分方程<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>解析几何<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>常微分方程<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>社团活动<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>常微分方程<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>数学分析<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>泛函分析<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>实变函数<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>MySQL<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>From:小张同学<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示效果如下：</p><table border="1" width="300px" height="100px" align="center" cellspacing="0"><caption>小木课程表</caption><tr bgcolor="#0DBBD0" align="center"><th>星期一</th><th>星期二</th><th>星期三</th><th>星期四</th><th>星期五</th><th>星期六</th><th>星期日</th></tr><tr align="center"><td>偏微分方程</td><td>实变函数</td><td>泛函分析</td><td>常微分方程</td><td>解析几何</td><td rowspan="2">体育活动</td><td>Python</td></tr><tr align="center"><td>高等代数</td><td>数学分析</td><td>解析几何</td><td>实变函数</td><td>泛函分析</td><td>HTML</td></tr><tr><td colspan="7" align="center">午休</td></tr><tr align="center"><td rowspan="2">班会</td><td>泛函分析</td><td>偏微分方程</td><td>解析几何</td><td>常微分方程</td><td>Python</td><td rowspan="2">社团活动</td></tr><tr align="center"><td>常微分方程</td><td>数学分析</td><td>泛函分析</td><td>实变函数</td><td>MySQL</td></tr></table><ol start="2" type="1"><li>实现一个注册页面</li></ol><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210221232505372.png" alt="pokeman-parameters" style="width:40%;"/></center><p>实现代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>注册页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;350px&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>请输入用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>请输入密码：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>再次输入密码：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>性别：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">checked</span>&gt;</span>男<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>兴趣爱好：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;swim&quot;</span>&gt;</span>游泳<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;read&quot;</span>&gt;</span>看书<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;climb&quot;</span>&gt;</span>爬山<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;think&quot;</span>&gt;</span>思考<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>生日：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1998&quot;</span>&gt;</span>1998<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1999&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>1999<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2000&quot;</span>&gt;</span>2000<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>年<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>月<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>日<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>头像：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;avatar.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;not found~&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;50px&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;40px&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交按钮&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red"><strong>注意：一定要将 <code>&lt;table&gt;</code> 写入 <code>&lt;form&gt;</code> 里，要把前端输入的数据提交到后台！ </strong></font></p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2021/02/17/MySQL%20&amp;%20Python/"/>
    <url>/2021/02/17/MySQL%20&amp;%20Python/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-sqlalchemy">MySQL &amp; SQLAlchemy</h1><h2 id="游标">游标</h2><p>游标提供了在逐行的基础上操作表中数据的方法。是对查询出来的结果集作为一个单元，每次从中提取一条记录的机制。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p><p>游标的一个常见用途就是 <strong>保存sql语句查询结果</strong>，以便以后使用。游标的结果集是由SELECT语句产生，如果处理过程需要重复使用一个记录集，那么创建一次游标而重复使用若干次，比重复查询数据库要快的多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cursor=con.cursor()<br>cursor.exectue(sql语句)<br></code></pre></td></tr></table></figure><h2 id="创建连接">创建连接</h2><p>创建 Python 和 MySQL之间的连接：</p><h3 id="方法一">方法一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mysql.connector<br>con = mysql.connector.connect(<br>host=<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-string">&quot;3306&quot;</span>,<br>    user=<span class="hljs-string">&quot;root&quot;</span>, password=<span class="hljs-string">&quot;abc123456&quot;</span>,<br>    database=<span class="hljs-string">&quot;demo&quot;</span><br>);<br></code></pre></td></tr></table></figure><h3 id="方法二">方法二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mysql.connector<br>config=&#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3306</span>,<br>    <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;root&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;abc123456&quot;</span>,<br>    <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;demo&quot;</span><br>&#125;<br>con = mysql.connector.connect(**config)<br></code></pre></td></tr></table></figure><h3 id="基本步骤">基本步骤</h3><p>所有的I/O操作：文件，数据库，网络等，均有如下三个基本步骤</p><ol type="1"><li><p>连接到MySQL数据库</p></li><li><p>执行SQL语句</p><p>2.1 实例化一个游标对象</p><p>2.2 定义一个SQL语句</p><p>2.3 通过游标执行SQL语句</p></li><li><p>关闭数据库</p></li></ol><h2 id="执行-sql-语句">执行 SQL 语句</h2><p>在 Python 中 执行 SQL 语句。</p><p>建议使用Key-Value来获取数据(Key=&gt;列名, Value=&gt;单元格的值)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pymysql.cursors <span class="hljs-keyword">import</span> DictCursor<br>cursor = conn.cursor(DictCursor)<br></code></pre></td></tr></table></figure><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-comment"># 所有的I/O操作：文件，数据库，网络等，均有如下三个基本步骤</span><br><span class="hljs-comment"># 1. 连接到MySQL数据库</span><br><span class="hljs-keyword">from</span> pymysql.cursors <span class="hljs-keyword">import</span> DictCursor<br><br>conn = pymysql.connect(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-string">&#x27;3306&#x27;</span>, user=<span class="hljs-string">&#x27;root&#x27;</span>, password=<span class="hljs-string">&#x27;1234qwer&#x27;</span>,<br>                       charset=<span class="hljs-string">&#x27;utf-8&#x27;</span>, database=<span class="hljs-string">&#x27;woniunote&#x27;</span>)<br><span class="hljs-comment"># 2. 执行SQL语句</span><br><span class="hljs-comment"># 2.1 实例化一个游标对象</span><br><span class="hljs-comment"># 2.2 定义一个SQL语句</span><br><span class="hljs-comment"># 2.3 通过游标执行SQL语句</span><br>cursor = conn.cursor()<br>sql = <span class="hljs-string">&quot;select * from users&quot;</span><br>cursor.execute(sql)<br><br>result = cursor.fetchall()<br>print(result)<br><br><span class="hljs-comment"># 一般情况下，不建议使用下标获取列的值</span><br><span class="hljs-comment"># print(result[2][6])</span><br><br><span class="hljs-comment"># 建议使用Key-Value来获取数据(Key=&gt;列名, Value=&gt;单元格的值)</span><br><span class="hljs-comment"># 代码可读性更强，代码维护起来更加高效</span><br><span class="hljs-comment"># 建议面对一些复杂的SQL语句，先在Navicat上调试完成后再整合到代码中</span><br>cursor = conn.cursor(DictCursor)<br>sql = <span class="hljs-string">&quot;select * from users&quot;</span><br>cursor.execute(sql)<br><br>result = cursor.fetchall()<br>print(result[<span class="hljs-number">2</span>][<span class="hljs-string">&#x27;username&#x27;</span>])  <span class="hljs-comment"># 代码可读性更强</span><br><br><span class="hljs-comment"># 3. 关闭数据库</span><br>cursor.close()  <span class="hljs-comment"># 关闭游标</span><br>conn.close()  <span class="hljs-comment"># 关闭数据库</span><br><br></code></pre></td></tr></table></figure><h2 id="sql-注入攻击">SQL 注入攻击</h2><p>SQL 注入是一种将 SQL 代码添加到输入参数中，传递到 SQL 服务器解析并执行的一种攻击手法。</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">username=<span class="hljs-string">&quot;1 OR 1=1&quot;</span>;<br>password=<span class="hljs-string">&quot;1 OR 1=1&quot;</span>;<br>sql=<span class="hljs-string">&quot;SELECT COUNT(*) FROM t_user WHERE username=&quot;</span>+username<br>+<span class="hljs-string">&quot; AND AES_DECRYPT(UNHEX(password),&#x27;HelloWorld&#x27;) =&quot;</span> + password;<br>cursor.execute(sql);<br>print(cursor.fetchone()[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><blockquote><p><code>username</code> 和 <code>password</code> 这2个变量在 SQL 语句中做了一个拼接，变成=&gt; <code>username=1 OR 1=1 AND ...=1 OR 1=1</code> ，这样后面的 <code>1=1</code> 一定成立，所以结果一定为真。</p><p>注：SQL 中 AND 优先级高于 OR</p></blockquote><p>由于 SQL 语句是解释型语言，所以在拼接 SQL 语句的时候，容易被注入恶意的 SQL 语句。SQL注入攻击，出现在登录和操作数据库等语句中，攻击者将诸如 “1 OR 1=1” 的值传入 SQL 语句，使得判断条件一直为真。就可以绕过登入验证或者删除、修改数据。</p><p>预防 SQL 注入攻击的方法，就要提到 <strong>SQL 的预编译机制</strong>：</p><h3 id="sql-的预编译机制">SQL 的预编译机制</h3><p>数据库接受到 SQL 语句之后，<u>需要词法和语义解析，优化sql语句</u>，制定执行计划。这需要花费一些时间。但是很多情况，我们的一条 SQL 语句可能会反复执行，或者 每次执行的时候只有个别的值不同。（比如query的where子句值不同，update的set子句值不同,insert的values值不同）。</p><p>如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。为了解决上面的问题，于是就有了<strong>预编译</strong>，预编译语句就是将这类语句中的 <strong>值</strong> 用 <strong>占位符 %s 替代</strong>，后续传入的数据，均被认为是一个普通的字符串。这样，据库在执行 SQL 语句时，就不再分析词法，传入的参数中的 OR 等关键字也会被认为是普通的字符串，于是注入攻击就失效了。</p><p>可以把 <strong>SQL 的预编译机制</strong>视为将 <strong>SQL 语句模板化或者说参数化</strong>。<strong>一次编译、多次运行，省去了解析优化等过程，提升了效率。</strong></p><h4 id="预编译的作用">预编译的作用？</h4><ul><li><p>预编译阶段可以优化 SQL 的执行</p><p>预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的sql，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。可以提升性能。</p></li><li><p>防止 SQL 注入 使用预编译，而其后注入的参数将不会再进行 SQL 编译。也就是说其后注入进来的参数系统将不会认为它会是一条 SQL 语句，而默认其是 <strong>一个参数</strong>，参数中的 OR 或者 AND 等就不是SQL 语法保留字了。</p></li></ul><h4 id="sql-的预编译预防-sql-注入攻击">SQL 的预编译预防 SQL 注入攻击</h4><p>SQL 语句编译的过程中，关键字已经被解析过了，所以向编译后的 SQL 语句传入参数，都被当作字符串处理，数据库不会解析其中注入的 SQL 语句。</p><p>栗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">id &#x3D; &quot;1 OR 1&#x3D;1&quot;<br>sql &#x3D; &quot;DELETE FROM t_news WHERE id&#x3D;%s&quot;;<br></code></pre></td></tr></table></figure><blockquote><p>这里的%s直接传入参数id，此时的 &quot;1 OR 1=1&quot; 直接作为字符串处理。</p></blockquote><p><strong>预防 SQL 注入攻击</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">cursor.execute(sql, (参数1, ...))<br></code></pre></td></tr></table></figure><ul><li>第一个参数：SQL 语句</li><li>第二个参数：元组（元组单个值后跟逗号）</li></ul><p>栗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">username&#x3D;&quot;1 OR 1&#x3D;1&quot;;<br>password&#x3D;&quot;1 OR 1&#x3D;1&quot;;<br>sql&#x3D;&quot;SELECT COUNT(*) FROM t_user WHERE username %s AND AES_DECRYPT(UNHEX(password),&#39;HelloWorld&#39;) &#x3D;%s&quot;;<br>cursor.execute(sql, (username, password));<br>print(cursor.fetchone()[0]);<br></code></pre></td></tr></table></figure><blockquote><p><code>cursor.execute(sql, (username, password));</code> 中间没有 <strong>%</strong>。后面的数据是以参数的形式传入给<strong>已经编译好的</strong> SQL 语句，这样数据库就以为传入的数据是普通的字符串，不会进行词法分析。</p></blockquote><h2 id="事务控制">事务控制</h2><p>执行 CRUD 操作需要引入事务机制。<code>Connector</code> 提供了事务控制函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">con.start_transaction([事务隔离级别])<br>con.commit()<br>con.rollback()<br></code></pre></td></tr></table></figure><h3 id="异常处理">异常处理</h3><p>对数据库的正常操作都可以写在 try 语句里面。try 语句如果出现异常，except 语句进行捕获，回滚事务，打印异常信息，finally 语句关闭连接，在关闭之前，应该判断一下 con 变量是否存在，即 连接是否创立。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    con = mysql.connector.connect(......)<br>    [ con = start_transaction() ]<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;con&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>():<br>    [ con.rollback() ]<br>    print(e)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;con&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>():<br>        con.close()<br></code></pre></td></tr></table></figure><p>举个栗子：给员工表插入一条小刘的记录<strong>（增加）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> mysql.connector<br><br><br><span class="hljs-keyword">try</span>:<br>    con = mysql.connector.connect(<br>        host=<span class="hljs-string">&quot;localhost&quot;</span>,<br>        port=<span class="hljs-number">3306</span>,<br>        user=<span class="hljs-string">&quot;root&quot;</span>,<br>        password=<span class="hljs-string">&quot;1234qwer&quot;</span>,<br>        database=<span class="hljs-string">&quot;test2&quot;</span><br>    )<br>    con.start_transaction()  <span class="hljs-comment"># 开启事务</span><br>    cursor = con.cursor()  <span class="hljs-comment"># 建立游标</span><br>    sql = <span class="hljs-string">&quot;INSERT INTO t_emp(empno, ename, job, mgr, hiredate, sal, comm, deptno) &quot;</span> \<br>          <span class="hljs-string">&quot;VALUES(%s, %s, %s, %s, %s, %s, %s, %s)&quot;</span><br>    cursor.execute(sql, (<span class="hljs-number">9600</span>, <span class="hljs-string">&quot;小刘&quot;</span>, <span class="hljs-string">&quot;SALESMAN&quot;</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">&quot;1985-12-1&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">10</span>))<br>    con.commit()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;con&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>():<br>        con.rollback()<br>    print(e)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;con&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>():<br>        con.close()<br></code></pre></td></tr></table></figure><blockquote><p>去数据库的表查看，小刘这条数据已经写入。</p></blockquote><h2 id="数据库连接池">数据库连接池</h2><p>数据库连接是一种关键的有限的昂贵的资源。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p><p>数据库连接池（Connection Pool）预先创建出一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接昂贵代价。</p><p>数据库连接池的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mysql.connector.pooling<br><br>config = &#123;......&#125;<br>pool = mysql.connnecotr.pooling.MySQLConnectionPool(<br>  **config,<br>      pool_size=<span class="hljs-number">10</span><br>)<br>con = pool.get_connection()  <span class="hljs-comment"># 可以不用关闭</span><br></code></pre></td></tr></table></figure><p>举个栗子：</p><ol type="1"><li>给员工表dept=20的底薪涨两块<strong>（修改）</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> mysql.connector.pooling<br><br>config = &#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3306</span>,<br>    <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;root&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234qwer&quot;</span>,<br>    <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;test2&quot;</span><br>&#125;<br><br><span class="hljs-keyword">try</span>:<br>    pool = mysql.connector.pooling.MySQLConnectionPool(<br>        **config,<br>        pool_size=<span class="hljs-number">10</span><br>    )<br><br>    con = pool.get_connection()<br>    con.start_transaction()<br>    cursor = con.cursor()<br>    sql = <span class="hljs-string">&quot;UPDATE t_emp SET sal=sal+%s WHERE deptno=%s;&quot;</span><br>    cursor.execute(sql, (<span class="hljs-number">2</span>, <span class="hljs-number">20</span>))<br>    con.commit()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;con&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>():<br>        con.rollback()<br>    print(e)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>删除20部门和20部门的员工<strong>（删除）</strong></li></ol><p>这个是用 DELETE 实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> mysql.connector.pooling<br><br>config = &#123;<br>        <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>        <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3306</span>,<br>        <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;root&quot;</span>,<br>        <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234qwer&quot;</span>,<br>        <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;test2&quot;</span><br>    &#125;<br><br><span class="hljs-keyword">try</span>:<br>    pool = mysql.connector.pooling.MySQLConnectionPool(<br>        **config,<br>        pool_size=<span class="hljs-number">10</span><br>    )<br>    con = pool.get_connection()<br>    con.start_transaction()<br>    cursor = con.cursor()<br>    sql = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        DELETE e, d FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno</span><br><span class="hljs-string">        WHERE d.deptno=20 </span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    cursor.execute(sql)<br>    con.commit()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;con&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>():<br>        con.rollback()<br>    print(e)<br><br></code></pre></td></tr></table></figure><p>也可以用 TRANCATE 实现。TRANCATE 语句在执行时不依赖于事务，在事务之外快速清空数据。所以不需要事务的相关操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    pool = mysql.connector.pooling.MySQLConnectionPool(<br>        **config,<br>        pool_size=<span class="hljs-number">10</span><br>    )<br>    con = pool.get_connection()<br>    cursor = con.cursor()<br>    sql = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        TRUNCATE TABLE t_emp</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    cursor.execute(sql)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    print(e)<br><br></code></pre></td></tr></table></figure><h2 id="循环执行-sql-语句">循环执行 SQL 语句</h2><p>游标对象中的 <code>executeMany()</code> 函数可以反复执行一条 SQL语句</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">sql = <span class="hljs-string">&quot;INSERT INTO t_deot(deptno, danme, loc) VALUES(%s, %s, %s)&quot;</span><br>data = [[<span class="hljs-number">100</span>, <span class="hljs-string">&quot;A部门&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>], [<span class="hljs-number">110</span>, <span class="hljs-string">&quot;B部门&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>]]<br>cursor.executeMany(sql, data)<br></code></pre></td></tr></table></figure><p>举个栗子：增加上面例子的两条数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> mysql.connector.pooling<br><br>config = &#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3306</span>,<br>    <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;root&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234qwer&quot;</span>,<br>    <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;test2&quot;</span><br>&#125;<br><br><span class="hljs-keyword">try</span>:<br>    pool = mysql.connector.pooling.MySQLConnectionPool(<br>        **config,<br>        pool_size=<span class="hljs-number">10</span><br>    )<br>    con = pool.get_connection()<br>    con.start_transaction()<br>    cursor = con.cursor()<br>    sql = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        INSERT INTO t_dept(deptno, dname, loc) </span><br><span class="hljs-string">        VALUES (%s, %s, %s)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    data = [[<span class="hljs-number">100</span>, <span class="hljs-string">&quot;A部门&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>], [<span class="hljs-number">110</span>, <span class="hljs-string">&quot;B部门&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>]]<br>    cursor.executeMany(sql, data)<br>    con.commit()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;con&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>():<br>        con.rollback()<br>    print(e)<br></code></pre></td></tr></table></figure><h2 id="综合练习">综合练习</h2><p>知识点：</p><ol type="1"><li><p><strong>create table as 与create table like 的区别</strong></p><ul><li><p>create table <strong>as</strong> 只是<strong>复制原数据</strong>，其实就是把查询的结果建一个表</p></li><li><p>create table <strong>like</strong> <strong>产生与源表相同的表结构</strong>，包括索引和主键，数据需要用insert into 语句复制进去。</p></li></ul></li><li><p><code>fetchall(self)</code> ：接收全部的返回结果行.</p></li></ol><p><code>fetchone(self)</code> ：返回一条结果行.</p><ol start="3" type="1"><li>执行流程</li></ol><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210218233126312.png" alt="numberfunction" style="width40%;"/></center><p>练习</p><p>1.使用 INSERT 语句把所在部门平均工资超过公司平均工资的员工信息导入到 t_emp_new 表里面，并且让这些员工隶属于 sales 部门</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> mysql.connector.pooling<br><br>config = &#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3306</span>,<br>    <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;root&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234qwer&quot;</span>,<br>    <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;test2&quot;</span><br>&#125;<br><br><span class="hljs-keyword">try</span>:<br>    pool = mysql.connector.pooling.MySQLConnectionPool(<br>        **config,<br>        pool_size=<span class="hljs-number">10</span><br>    )<br>    con = pool.get_connection()<br>    con.start_transaction()<br>    cursor = con.cursor()<br>    sql = <span class="hljs-string">&quot;CREATE TABLE t_emp_new LIKE t_emp&quot;</span><br>    cursor.execute(sql)<br>    sql = <span class="hljs-string">&quot;SELECT AVG(sal) AS avg FROM t_emp&quot;</span>  <span class="hljs-comment"># 算出公司平均底薪</span><br>    cursor.execute(sql)<br>    avg = cursor.fetchone()[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 取出公司平均底薪</span><br>    print(avg)<br>    sql = <span class="hljs-string">&quot;SELECT deptno FROM t_emp GROUP BY deptno HAVING AVG(sal) &gt;= %s&quot;</span>  <span class="hljs-comment"># 找到部门平均工资超过公司平均工资的编号</span><br>    cursor.execute(sql, (avg,))<br>    temp=cursor.fetchall()  <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># print(temp)</span><br>    sql = <span class="hljs-string">&quot;INSERT INTO t_emp_new SELECT * FROM t_emp WHERE deptno IN (&quot;</span><br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(temp)):<br>        one = temp[index][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-built_in">len</span>(temp) - <span class="hljs-number">1</span>:  <span class="hljs-comment"># 因为中间得有逗号</span><br>            sql += <span class="hljs-built_in">str</span>(one) +<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-comment"># 因为sql是字符串拼接</span><br>        <span class="hljs-keyword">else</span>:<br>            sql += <span class="hljs-built_in">str</span>(one)<br>    sql += <span class="hljs-string">&quot;)&quot;</span><br>    print(sql)  <span class="hljs-comment"># INSERT INTO t_emp_new SELECT * FROM t_emp WHERE deptno IN (10, 20)</span><br>    cursor.execute(sql)<br><br>    <span class="hljs-comment"># 还得将原表里面符合的数据删除</span><br>    sql = <span class="hljs-string">&quot;DELETE FROM t_emp WHERE deptno IN (&quot;</span><br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(temp)):<br>        one = temp[index][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-built_in">len</span>(temp) - <span class="hljs-number">1</span>:<br>            sql += <span class="hljs-built_in">str</span>(one) + <span class="hljs-string">&quot;,&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            sql += <span class="hljs-built_in">str</span>(one)<br>    sql += <span class="hljs-string">&quot;)&quot;</span><br>    cursor.execute(sql)<br><br>    <span class="hljs-comment"># 让这些员工隶属于 sales 部门</span><br>    <span class="hljs-comment"># 首先要知道 sales 部门的编号</span><br>    sql = <span class="hljs-string">&quot;SELECT deptno FROM t_dept WHERE dname = %s&quot;</span><br>    cursor.execute(sql, (<span class="hljs-string">&#x27;SALES&#x27;</span>,))<br>    deptno = cursor.fetchone()[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 员工隶属于 sales 部门</span><br>    sql = <span class="hljs-string">&quot;UPDATE t_emp_new SET deptno = %s&quot;</span><br>    cursor.execute(sql, (deptno,))<br>    con.commit()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;con&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>():<br>        con.rollback()<br>    print(e)<br></code></pre></td></tr></table></figure><p>2.编写一个 INSERT 语句向 dept 表插入两条记录，每条记录都在 dept 原有最大主键值的基础上 + 10</p><p>首先 SQL 语句的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO t_dept<br>(SELECT MAX(deptno)+10 , &quot;A部门&quot;, &quot;北京&quot; FROM t_dept UNION<br>SELECT MAX(deptno)+20 , &quot;B部门&quot;, &quot;上海&quot; FROM t_dept)<br></code></pre></td></tr></table></figure><p>Python里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> mysql.connector.pooling<br><br>config = &#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3306</span>,<br>    <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;root&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234qwer&quot;</span>,<br>    <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;test2&quot;</span><br>&#125;<br><br><span class="hljs-keyword">try</span>:<br>    pool = mysql.connector.pooling.MySQLConnectionPool(<br>        **config,<br>        pool_size=<span class="hljs-number">10</span><br>    )<br>    con = pool.get_connection()<br>    con.start_transaction()<br>    cursor = con.cursor()<br>    sql = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        INSERT INTO t_dept</span><br><span class="hljs-string">        (SELECT MAX(deptno) + 10, %s, %s FROM t_dept UNION </span><br><span class="hljs-string">        SELECT MAX(deptno) + 20, %s, %s FROM t_dept)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    cursor.execute(sql, ( <span class="hljs-string">&quot;A部门&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;B部门&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>))<br>    con.commit()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;con&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>():<br>        con.rollback()<br>    print(e)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL的事务机制</title>
    <link href="/2021/02/09/SQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/09/SQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了有关 SQL 的事务机制。</p><p><em><a id="more"></a></em></p><hr /><h1 id="sql-的事务机制">SQL 的事务机制</h1><p>如果数据的写入直接操作数据文件是非常危险的事情。</p><p>MySQL 总共有5种日志，其中只有redo日志和undo日志与事务有关。</p><h2 id="什么是事务">什么是事务？</h2><p>事务是<strong>一个不可分割的数据库操作序列，也是数据库并发控制的基本单位</strong>，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p><blockquote><p>事务就是被绑定在一起作为一个逻辑工作单元的 SQL 语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过 ACID 测试，即原子性，一致性，隔离性和持久性。</p></blockquote><h2 id="事务机制transaction">事务机制（Transaction）</h2><p>RDBMS = SQL 语句 + 事务（ACID）</p><p>事务是一个或者多个 SQL语句组成的整体，要么全部执行成功，要么全部执行失败。</p><h3 id="管理事务">管理事务</h3><p>默认情况下，MySQL 执行每条语句 SQL 语句都会自动开启和提交事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">START TRASACTION;<br>SQL语句<br>[COMMIT|ROLLBACK];<br></code></pre></td></tr></table></figure><blockquote><p>在没有 COMMIT 之前，SQL语句的执行都是记录在在 REDO 日志里，没有同步之前数据是没有发生变化的。</p><p>COMMIT 直接同步结果，不是中间同步的状态。</p><p>ROLLBACK 是直接全部回滚。</p></blockquote><h3 id="事务的-acid-属性">事务的 ACID 属性</h3><p>ACID：原子性(Atomicity)，一致性(Consistency)，隔离性(Isolation)，持久性(Durability)</p><p>涉及四种操作：</p><ul><li><strong>REDO：重做</strong>，正向扫描日志文件，对每个REDO事务重新执行日志文件登记的操作</li><li><strong>UNDO：撤销</strong>，反向扫描日志文件，对每个UNDO事务的更新操作执行逆操作</li><li><strong>COMMIT：提交</strong>，将事务中所有对数据库的更新写回到磁盘上的物理数据库中，事务正常结束</li><li><strong>ROLLBACK：回滚</strong>，事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成操作全部撤销，回滚到事务开始时的状态</li></ul><h4 id="原子性atomicity">原子性(Atomicity)</h4><p><strong>原子性(Atomicity)：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。</strong>事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><h4 id="一致性consistency">一致性(Consistency)</h4><p><strong>一致性(Consistency)：数据库在事务执行前后都保持一致性状态。</strong>在一致性状态下，<u>所有事务对一个数据的读取结果都是相同的</u>。</p><blockquote><p>所谓的一致性状态时指数据库中的数据满足完整性约束，它是一种以一致性规则为基础的逻辑属性。</p></blockquote><h4 id="隔离性isolation">隔离性(Isolation)</h4><p><strong>隔离性(Isolation)：一个事务的执行不能被其他事务干扰。</strong>即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p>不同的隔离级别：</p><table><thead><tr class="header"><th style="text-align: left;">隔离级别</th><th>功能</th><th style="text-align: center;">脏读可能性</th><th style="text-align: center;">不可重复读可能性</th><th style="text-align: center;">幻读可能性</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">READ UNCOMMITTED</td><td>读取未提交数据</td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: center;">是</td></tr><tr class="even"><td style="text-align: left;">READ COMMITTED</td><td>读取已提交数据</td><td style="text-align: center;">否</td><td style="text-align: center;">是</td><td style="text-align: center;">是</td></tr><tr class="odd"><td style="text-align: left;">REPEATABLE READ</td><td>重复读取</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td style="text-align: center;">是</td></tr><tr class="even"><td style="text-align: left;">SERIALIZABLE</td><td>序列化</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td></tr></tbody></table><h5 id="read-uncommitted读取未提交">Read Uncommitted（读取未提交）</h5><p><strong>Read Uncommitted（读取未提交）：所有事务都可以看到其他未提交事务的执行结果。</strong>本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br></code></pre></td></tr></table></figure><blockquote><p>Read Uncommitted 会产生”脏读”问题：</p><p><strong>A：</strong>启动事务，此时数据为初始状态</p><p><strong>B：</strong>启动事务，更新数据，但不提交</p><p><strong>A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读”</strong></p><p><strong>B：</strong>回滚事务</p><p><strong>A：</strong>再次读数据，发现数据变回初始状态</p></blockquote><h5 id="read-committed读取提交内容">Read Committed（读取提交内容）</h5><p><strong>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。</strong><u>可以解决脏读问题</u>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br></code></pre></td></tr></table></figure><blockquote><p>Read Committed 会产生“不可重复读”问题：</p><p><strong>A：</strong>启动事务，此时数据为初始状态</p><p><strong>B：</strong>启动事务，更新数据，但不提交</p><p><strong>A：</strong>再次读数据，发现数据未被修改</p><p><strong>B：</strong>提交事务</p><p><strong>A：再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”</strong></p></blockquote><blockquote><p>一个事务读的信息都是已经commited了的，读不到没有commited的，这样在读取一次时，不会造成脏读，但是这个有个问题，就是如果我在读取一次呢，这个时候如果有另外一个事务，这个时候对读取的数据进行了一些操作，并且提交了，那么就很可能造成，第一次读和第二次读的数据不一致的情况，这就是所谓的，不可重复读，但是这个级别至少是可以保证它不会脏读。读取的交易不会阻止其它的交易，一个未COMMIT的交易会阻止其它所有的交易。</p></blockquote><h5 id="repeatable-read可重复读">Repeatable Read（可重复读）</h5><p><strong>Repeatable Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，不会受其他事务影响</strong>，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。<u>可以解决脏读、不可重复读</u>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></td></tr></table></figure><blockquote><p>Repeatable Read 会产生“幻读”问题：</p><p><strong>A：</strong>启动事务，此时数据为初始状态</p><p><strong>B：</strong>启动事务，更新数据，但不提交</p><p><strong>A：</strong>再次读取数据，发现数据未被修改</p><p><strong>B：</strong>提交事务</p><p><strong>A：</strong>再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了</p><p><strong>B：</strong>插入一条新的数据，并提交</p><p><strong>A：再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”</strong></p><p><strong>A：</strong>提交本次事务，再次读取数据，发现读取正常了</p></blockquote><blockquote><p>可重复读，这种的隔离级别要求，在读取数据的时候，不允许在有对读取数据进行写入。比如事务A启动一个事务，事务B开启一个新事务(那么这两个事务交叉了)，在事务B中更新数据，并提交。这时候即使事务B已经提交了,但A不能看到数据变化。只有当事务A也提交了，它才能够看到数据变化。那这个时候，Repeatable Read 就可以避免重复读，读取的交易不会阻止其它读取的交易，但会阻止其它写入的交易，而写入的交易会阻止所有其它的交易。但是这个时候，我可以对这条数据进行删除，那么这个时候，就可能产生幻读，我实际上是读对了，但是由于后续的一些操作，导致我读出来的数据有问题，就是幻读。</p></blockquote><h5 id="serialization可串行化">Serialization（可串行化）</h5><p><strong>Serialization（可串行化）：事务串行化执行，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</strong>隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题，脏读，重复读，幻读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br></code></pre></td></tr></table></figure><blockquote><p><strong>A：</strong>启动事务，此时数据为初始状态</p><p><strong>B：</strong>发现B此时进入了等待状态，原因是因为A的事务尚未提交，只能等待（此时，B可能会发生等待超时）</p><p><strong>A：</strong>提交事务</p><p><strong>B：发现插入成功</strong></p></blockquote><blockquote><p>串行化，也就是说，每一个事务的开始，都必须在前一个事务结束后执行，他们是串行的，不是并行的，那么这个时候，上面所有的问题都可以解决，不会造成脏读，重复读，幻读</p></blockquote><h4 id="持久性durability">持久性(Durability)</h4><ul><li><strong>持久性(Durability)：事务一旦提交，对数据库中数据的改变是永久性的，持久的保存在数据库之中。</strong>即使数据库发生故障也不应该对其有任何影响。</li></ul><h1 id="数据的导入与导出">数据的导入与导出</h1><ul><li>数据导出，导出的纯粹是业务数据<ul><li>分为 SQL 文档、文本文档。</li></ul></li><li>数据备份，备份的是数据文件、日志文件、索引文件等等</li></ul><p><strong>导出 SQL 文件</strong></p><p><code>mysqldump</code> 用来把业务数据导出成 SQL 文件，其中也包括了表结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqldump -uroot -p [--no-data] 逻辑库 &gt; 路径<br></code></pre></td></tr></table></figure><p>如果业务数据非常多，建议只导出表结构，然后用 <code>SELECT INTO OUTFILE</code> 把数据导出成文本文档</p><blockquote><p>用 Navicat 直接转储比较方便，”转储 SQL 文件“。</p></blockquote><p><strong>导入 SQL 文件</strong></p><p><code>source</code> 命令用于导入 SQL 文件，包括创建数据表，写入记录等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">sql&gt; USE demo;<br>sql&gt; SOURCE backup.sql;<br></code></pre></td></tr></table></figure><blockquote><p>用 Navicat 导入比较方便，先导入表结构，再导入数据。</p><ol type="1"><li>”运行 SQL 文件“导入 SQL 文件；</li><li>”导入向导“导入数据，注意其中：”第一行导入数据“，仔细看数据文件，如果第一行就是数据记录，那么”第一行导入数据“就设置为1。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL基本函数的使用</title>
    <link href="/2021/02/08/MYSQL%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/02/08/MYSQL%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了有关MYSQL基本函数的使用，包括：数字函数，字符函数，日期函数，条件函数等等。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210221233339809.png" alt="image-20210221233339809" /><figcaption>image-20210221233339809</figcaption></figure><p><em><a id="more"></a></em></p><hr /><h1 id="mysql基本函数">MYSQL基本函数</h1><p>MYSQL基本函数有四类：</p><ul><li>数字函数</li><li>字符函数</li><li>日期函数</li><li>条件函数</li></ul><h2 id="数字函数">1. 数字函数</h2><p>常用的数字函数：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210210213415020.png" alt="numberfunction" style="width80%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210210213914207.png" alt="numberfunction" style="width80%;"/></center><h2 id="时间函数">2. 时间函数</h2><h3 id="获取系统时间函数">获取系统时间函数</h3><ul><li><code>NOW()</code> 函数能获得系统日期和时间，格式 yyyy-MM-dd hh:mm:ss</li><li><code>CURDATE()</code> 函数能获得当前系统日期，格式 yyyy-MM-dd</li><li><code>CURTIME()</code> 函数能获得当前系统时间，格式 hh:mm:ss</li></ul><h3 id="日期格式化函数">日期格式化函数</h3><ol type="1"><li><p><code>DATE_FORMAT()</code> 函数用于格式化日期，返回用户想要的日期格式</p><p><code>DATE_FORMAT(日期, 表达式)</code></p></li></ol><ul><li><p>常用表达式占位符</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210210214828140.png" alt="numberfunction" style="width80%;"/></center></li></ul><p>练习：</p><ol type="1"><li><p>利用日期函数查询你的生日是星期几？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE_FORMAT(&quot;2021-01-01&quot;, &quot;%w&quot;);<br></code></pre></td></tr></table></figure></li><li><p>利用日期函数查询1981年上半年入职的员工有多少人？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) FROM t_emp<br>WHERE DATE_FORMAT(hiredate, &quot;%Y&quot;)&#x3D;1981<br>AND DATE_FORMAT(hiredate, &quot;%m&quot;)&lt;&#x3D;6;<br></code></pre></td></tr></table></figure></li></ol><h3 id="日期计算">日期计算</h3><p>日期计算的注意事项：</p><p>MYSQL里，两个日期不能直接加减，日期也不能与数字加减。</p><ul><li><p>日期偏移计算 <code>DATE_ADD()</code></p><p><code>DATE_ADD()</code> 函数可以实现日期的偏移计算，而且时间单位很灵活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DATE_ADD(日期, INTERVAL 偏移量 时间单位)<br></code></pre></td></tr></table></figure><p>栗：<code>SELECT DATE_ADD(DATE_ADD(NOW(), INTERVAL -6 MONTH), INTERVAL -3 DAY);</code></p></li><li><p>计算日期之间相隔的天数 <code>DATEDIFF()</code></p><p><code>DATEDIFF()</code> 函数用来计算两个日期之间相差的天数</p><p><code>DATEDIFF(日期, 日期)</code></p></li></ul><h2 id="字符函数">3. 字符函数</h2><p>常见的字符函数</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210210220813820.png" alt="numberfunction" style="width80%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210210220856674.png" alt="numberfunction" style="width80%;"/></center><blockquote><p><code>INSERT(s1,x,len,s2)</code> ：字符串 s2 替换 s1 的 x 位置开始长度为 len 的字</p></blockquote><h2 id="条件函数">4. 条件函数</h2><p>SQL 语句中可以利用条件函数来实现编程语言的条件判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IFNULL(表达式, 值)<br>IF(表达式, 值1, 值2)  # 接近三元运算符<br></code></pre></td></tr></table></figure><p>练习：</p><ol type="1"><li><p>中秋节公司发放礼品，SALES部门发放礼品A，其余部门发放礼品B，打印每名员工获得的礼品</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>  e.empno, e.ename, d.dname,<br>  IF(d.dname&#x3D;&quot;SALES&quot;, &quot;礼品A&quot;, &quot;礼品B&quot;)<br>FROM t_emp e JOIN t_dept d ON e.deptno&#x3D;d.deptno;<br></code></pre></td></tr></table></figure></li></ol><p><strong>条件语句</strong></p><p>复杂的条件可以用条件语句来实现，比IF语句功能更加强大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CASE<br>  WHEN 表达式 THEN 值1<br>  WHEN 表达式 THEN 值2<br>  ......<br>  ELSE 值N<br>END<br></code></pre></td></tr></table></figure><p>练习：</p><ol type="1"><li><p>SALES部门去P1地点，ACCOUNTING部门去P2地点，RESEARCH部门去P3地点，查询每名员工的旅行地点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>  e.empno, e.ename,<br>  CASE<br>    WHEN d.dname&#x3D;&quot;SALES&quot; THEN &quot;P1&quot;<br>    WHEN d.dname&#x3D;&quot;ACCOUNTING&quot; THEN &quot;P2&quot;<br>    WHEN d.dname&#x3D;&quot;RESEARCH&quot; THEN &quot;P3&quot;<br>  END<br>SELECT FROM t_emp e JOIN t_dept d ON e.deptno&#x3D;d.deptno;<br></code></pre></td></tr></table></figure></li><li><p>调整工资</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210212192325196.png" alt="numberfunction" style="width80%;"/></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno&#x3D;d.deptno<br>LEFT JOIN (select deptno, AVG(sal) AS avg FROM t_emp GROUP BY deptno) t<br>ON e.deptno&#x3D;t.deptno<br>SET e.sal&#x3D;(<br>  CASE<br>    WHEN d.dname&#x3D;&quot;SALES&quot; AND DATEDIFF(NOW(), e.hiredate)&#x2F;365&gt;&#x3D;20 <br>    THEN e.sal*1.1<br>    WHEN d.dname&#x3D;&quot;SALES&quot; AND DATEDIFF(NOW(), e.hiredate)&#x2F;365&lt;20 <br>    THEN e.sal*1.05<br>    WHEN d.dname&#x3D;&quot;ACCOUNTING&quot; THEN e.sal&#x3D;e.sal+300<br>    WHEN d.dname&#x3D;&quot;RESEARCH&quot; AND e.sal&lt;t.avg THEN e.sal&#x3D;e.sal+200<br>    WHEN e.deptno IS NULL THEN e.sal+100<br>);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL的数据操作语言DML</title>
    <link href="/2021/02/07/SQL%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80DML/"/>
    <url>/2021/02/07/SQL%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80DML/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了有关数据库的 Data Manipulation Language 数据操作语言的相关操作，包括：INSERT，UPDATE 和 DELETE 等等。</p><p><em><a id="more"></a></em></p><hr /><h1 id="dml数据查询语言">DML：数据查询语言</h1><h2 id="insert-语句">INSERT 语句</h2><p>INSERT 语句可以向数据表写入记录，可以是一条记录，也可以是多条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 表名 (字段1, 字段2, ……) VALUES (值1, 值2, ……);<br>INSERT INTO 表名 (字段1, 字段2, ……) VALUES (值1, 值2, ……), (值1, 值2, ……);<br></code></pre></td></tr></table></figure><ul><li>IGNORE 关键字</li></ul><p>IGNORE关键字会让INSERT只插入数据库不存在的记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT [ IGNORE ] INTO 表名 …… ;<br></code></pre></td></tr></table></figure><ul><li><p>INSERT 语句中可以包含子查询语句，代表把子查询的内容写入到数 据表</p><p>栗：向技术部添加一条员工记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO t_emp<br>(empno, ename, job, mgr, hiredate, sal, comm, deptno)<br>VALUES(8001, &quot;小明&quot;, &quot;SALESMAN&quot;, 8000, &quot;1988-12-02&quot;, 2000, NULL, (SELECT deptno FROM t_dept WHERE dname&#x3D;&quot;技术部&quot;));<br></code></pre></td></tr></table></figure></li></ul><h2 id="update-语句">UPDATE 语句</h2><p>UPDATE 语句用于修改表的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE [ IGNORE ] 表名<br>SET 字段1&#x3D;值1, 字段2&#x3D;值2, ……<br>[ WHERE 条件1, 条件2, …… ]  <br>[ ORDER BY …… ]<br>[ LIMIT …… ] ;<br></code></pre></td></tr></table></figure><p>练习：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208231842179.png" alt="pokeman-parameters" style="width:55%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208231932372.png" alt="pokeman-parameters" style="width:55%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210209154049652.png" alt="pokeman-parameters" style="width:100%;"/></center><ol type="1"><li><p>把每个员工的编号和上司的编号+1，用 ORDER BY 子句完成降序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE t_emp SET empno&#x3D;empno+1, mgr&#x3D;mgr+1<br>ORDER BY empno DESC;<br></code></pre></td></tr></table></figure></li><li><p>把月收入前三名的员工底薪减100元，用LIMIT子句完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE t_emp SET sal&#x3D;sal-100<br>ORDER BY sal+IFNULL(comm, 0)<br>LIMIT 3;<br></code></pre></td></tr></table></figure></li></ol><h3 id="update-语句的表连接">UPDATE 语句的表连接</h3><p>表连接的UPDATE语句可以修改多张表的记录</p><p><strong>1.第一种表连接方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE 表1 JOIN 表2 ON 条件<br>SET 字段1 &#x3D; 值1 , 字段2 &#x3D; 值2 , …… ;<br></code></pre></td></tr></table></figure><p>练习：把底薪低于公司平均底薪的员工，底薪增加150元</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE t_emp e JOIN<br>(SELECT AVG(sal) AS avg FROM t_emp) t<br>ON e.sal&lt;t.avg<br>SET e.sal&#x3D;e.sal+150;<br></code></pre></td></tr></table></figure><p><strong>2.第二种表连接方式：内连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE 表1 , 表2<br>SET 字段1 &#x3D; 值1 , 字段2 &#x3D; 值2 , ……<br>WHERE 连接条件 ;<br></code></pre></td></tr></table></figure><p>练习：把 ALLEN 调往 RESEARCH 部门，职务调整为 ANALYST</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE t_emp e JOIN t_dept d<br>SET e.deptno&#x3D;d.deptno, e.job&#x3D;&quot;ANALYST&quot;<br>WHERE e.ename&#x3D;&quot;ALLEN&quot; AND d.dname&#x3D;&quot;RESEARCH&quot;;<br></code></pre></td></tr></table></figure><p><strong>3.第三种表连接方式：UPDATE 语句的表连接既可以是内连接，又可以是外连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE 表1 [ LEFT | RIGHT ] JOIN 表2 ON 条件<br>SET 字段1 &#x3D; 值1 , 字段2 &#x3D; 值2 , …… ;<br></code></pre></td></tr></table></figure><p>练习：把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门(陈浩没有部门，所以要用左外连接)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno&#x3D;d.deptno<br>SET e.deptno&#x3D;20<br>WHERE e.deptno IS NULL OR (d.dname&#x3D;&quot;SALES&quot; AND e.sal&lt;2000);<br></code></pre></td></tr></table></figure><h2 id="delete-语句">DELETE 语句</h2><p>DELETE语句用于删除记录，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE [ IGNORE ] FROM 表名<br>[ WHERE 条件1, 条件2, …… ]<br>[ ORDER BY …… ]<br>[ LIMIT …… ] ;<br></code></pre></td></tr></table></figure><p>练习：</p><ol type="1"><li><p>删除10部门中，工龄超过20年的员工记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t_emp<br>WHERE deptno&#x3D;10 AND DATEDIFF(NOW(), hiredate)&#x2F;365 &gt;&#x3D; 20;<br></code></pre></td></tr></table></figure></li><li><p>删除20部门中工资最高的员工记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t_emp<br>WHERE deptno&#x3D;20 <br>ORDER BY sal+IF NULL(comm, 0) DESC<br>LIMIT 1;<br></code></pre></td></tr></table></figure></li></ol><h3 id="delete-语句的表连接">DELETE 语句的表连接</h3><p><strong>1.内连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE 表1 , …… FROM 表1 JOIN 表2 ON 条件<br>[ WHERE 条件1 , 条件2 , …… ]<br>[ ORDER BY …… ]<br>[ LIMIT …… ] ;<br></code></pre></td></tr></table></figure><p>练习：</p><ol type="1"><li><p>删除SALES部门和该部门的全部员工记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE e, d<br>FROM t_emp e JOIN t_dept d ON e.deptno&#x3D;d.deptno<br>WHERE d.dname&#x3D;&quot;SALES&quot;;<br></code></pre></td></tr></table></figure></li><li><p>删除每个低于部门平均底薪的员工记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE e<br>FROM t_emp e JOIN <br>(SELECT deptno, AVG(sal) AS avg FROM t_emp GROUP BY deptno) t<br>ON e.deptno&#x3D;t.deptno AND e.sal&lt;t.avg;<br></code></pre></td></tr></table></figure></li><li><p>删除员工KING和他的直接下属的员工记录，用表连接实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE e<br>FROM t_emp e JOIN<br>(SELECT empno FROM t_emp WHERE ename&#x3D;&quot;KING&quot;) t<br>ON e.mgr&#x3D;t.empno OR e.empno&#x3D;t.empno;<br></code></pre></td></tr></table></figure><blockquote><p>不能直接删掉 t 因为这个表是临时表。可以换成其他写法：<code>ON e.mgr=t.empno OR e.empno=t.empno;</code></p></blockquote></li></ol><p><strong>2.外连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE 表1 , …… FROM 表1 [ LEFT | RIGHT ] JOIN 表2<br>ON 条件 …… ;<br></code></pre></td></tr></table></figure><p>练习：</p><ol type="1"><li><p>删除SALES部门的员工，以及没有部门的员工。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE e<br>FROM t_emp e LEFT JOIN t_dept d ON e.deptno&#x3D;d.deptno<br>WHERE d.dname&#x3D;&quot;SALES&quot; OR e.deptno IS NULL;<br></code></pre></td></tr></table></figure></li></ol><h2 id="truncate-快速删除数据表全部记录">TRUNCATE 快速删除数据表全部记录</h2><p>DELETE语句是在事务机制下删除记录，删除记录之前，先把将要删除的记录保存到日志文件里，然后再删除记录。</p><p>TRUNCATE语句在事务机制之外删除记录，速度远超过DELETE语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TRUNCATE TABLE 表名 ;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL的数据查询语言DQL</title>
    <link href="/2021/02/06/SQL%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL/"/>
    <url>/2021/02/06/SQL%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了有关数据库的 Data Query Language 数据查询语言的相关操作，包括：SELECT，WHERE，ORDER BY，GROUP BY 和 HAVING 等等。</p><p><em><a id="more"></a></em></p><hr /><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208073436724.png" alt="pokeman-parameters" style="width:100%;"/></center><h1 id="dql数据查询语言">DQL：数据查询语言</h1><h2 id="普通查询">普通查询</h2><h3 id="记录查询-select-from">记录查询 SELECT FROM</h3><p>最基本的查询语句是由 SELECT 和 FROM 关键字组成的。</p><blockquote><p>SELECT 语句屏蔽了物理层的操作，用户不必关心数据的真实存储，交由数据库高效的查找数据</p></blockquote><p>栗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp;<br>SELECT id, nme FROM t_student;<br></code></pre></td></tr></table></figure><h3 id="使用列别名-as">使用列别名 AS</h3><p>通常情况下， SELECT 子句中使用了表达式，那么这列的名字就默认为表达式，因此需要一种对列名重命名的机制 AS 。</p><blockquote><p>重命名只在显示输出的时候使用，数据表列名不会真的改变</p></blockquote><p>栗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>  ename,<br>  sal*12 AS &quot;annual_salary&quot;<br>FROM <br>  t_emp;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210207003518847.png" alt="pokeman-parameters" style="width:50%;"/></center><h3 id="数据分页-limit">数据分页 LIMIT</h3><p>LIMIT 关键字限定结果集数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... FROM ... LIMIT 起始位置, 偏移量;  # 注意是偏移量，而不是结束位置<br></code></pre></td></tr></table></figure><p>如果只有一个参数，他表示表示的是偏移量，起始值默认为0。</p><h3 id="排序-order-by">排序 ORDER BY</h3><p>如果想让结果集按照某种顺序排列，就必须使用 ORDER BY 子句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT …… FROM …… ORDER BY 列名 [ ASC | DESC ];<br></code></pre></td></tr></table></figure><h4 id="排序关键字">排序关键字</h4><p>ASC 代表升序（默认）， DESC 代表降序</p><ul><li><p>如果排序列是数字类型，数据库就按照数字大小排序；如果是日期类型就按照日期大小排序，如果是字符串就按照字符集序号排序。</p></li><li><p>可以使用 ORDER BY 规定首要排序条件和次要排序条件。放前面的先排序。</p></li></ul><blockquote><p>注：ORDER BY 子句书写的时候放在 LIMIT 子句的前面 执行顺序：FROM--&gt; SELECT --&gt; ORDER BY --&gt; LIMIT</p></blockquote><h3 id="去重-distinct">去重 DISTINCT</h3><p>如果需要去除重复的数据，可以使用 DISTINCT 关键字来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT 字段 FROM …… ;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ol type="1"><li><p>使用 DISTINCT 的 SELECT 子句中只能查询一列数据，如果查询多列，去除重复记录就会失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT job, ename FROM t_emp;  # 不可以查询多列<br></code></pre></td></tr></table></figure></li><li><p>DISTINCT 关键字只能在 SELECT 子句中使用一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT job, DISTINCT ename FROM t_emp;  # 错<br>SELECT job, DISTINCT ename FROM t_emp;  # 错<br></code></pre></td></tr></table></figure></li></ol></blockquote><h3 id="条件查询-where">条件查询 WHERE</h3><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT …… FROM …… WHERE 条件 [ AND OR ] 条件 ……;<br></code></pre></td></tr></table></figure><ul><li><p>WHERE 语句中的条件运算会用 到以下 四种运算符：</p><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>运算符</th><th>栗子</th></tr></thead><tbody><tr class="odd"><td>数学运算符</td><td><code>+, -, *, /, %</code></td></tr><tr class="even"><td>比较运算符</td><td><code>&gt;, &gt;=, &lt;, &lt;=, =, !=, IN</code>； <code>IS NULL, IS NOY NULL, BETWEEN AND, LIKE, REGEXP</code></td></tr><tr class="odd"><td>逻辑运算符</td><td><code>AND, OR, NOT, XOR(异或：相同为0，不同为1)</code></td></tr><tr class="even"><td>按位运算符</td><td><code>&amp;, |, ~(位取反), ^(位异或), &lt;&lt;(左移), &gt;&gt;(右移)</code></td></tr></tbody></table></li></ul><blockquote><p>注：WHERE 子句中，条件执行的顺序是从左到右的。所以我们应该把<strong>索引条件</strong>，或者<strong>筛选掉记录最多的条件</strong>写在最左侧。</p></blockquote><blockquote><p>条件查询中， WHERE 子句应该是第几个执行？ 执行顺序：FROM--&gt; WHERE --&gt; SELECT --&gt; ORDER BY --&gt; LIMIT</p><p>(WHERE 排在 SELECT 前是因为 WHERE先筛选符合条件的记录，SELECT 才能从中挑出结果集中显示的字段)</p></blockquote><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT empno, ename, sal, hiredate<br>FROM t_emp<br>WHERE deptno&#x3D;10 AND (sal+IFNULL(comm, 0))*12&gt;&#x3D;15000 # IFNULL(expr1,expr2) 判断expr1是否NULL，是就expr2<br>AND DATEDIFF(NOW(),hiredate)&#x2F;365 &gt;&#x3D; 20;  # DATEDIFF(expr1,expr2)算两个日期的天数<br>IFNULL(expr1,expr2)<br></code></pre></td></tr></table></figure><h2 id="高级查询">高级查询</h2><h3 id="聚合函数">聚合函数</h3><p>聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对数据求和、求最大值和最小值、求平均值等等。</p><ul><li><p><strong>SUM 函数</strong>用于求和，<u>只能用于数字类型</u>，字符类型的统计结果为0 ，日期类型统计结果是毫秒数相加。</p></li><li><p><strong>MAX 函数</strong>用于获得非空值的最大值。</p></li><li><p><strong>MIN 函数</strong>用于获得非空值的最小值。</p></li><li><p><strong>AVG 函数</strong>用于获得非空值的平均值，非数字数据统计结果为0。</p></li><li><p>**COUNT(*)** 用于获得所有的(包含空值)的记录数</p><p><strong>COUNT(列名)</strong> 用于获得所有的(不包含空值)的记录数。</p></li></ul><p>栗子：查询10和20部门中，底薪超过2000元并且工龄超过15年的员工人数？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(ename)<br>FROM t_emp<br>WHERE deptno IN(10, 20) AND sal&gt;&#x3D;2000 <br>AND DATEDIFF(NOW(), hiredate)&#x2F;365 &gt;&#x3D; 15;<br></code></pre></td></tr></table></figure><h3 id="分组查询-group-by">分组查询 GROUP BY</h3><p>默认情况下汇总函数是对全表范围内的数据做统计。</p><p>GROUP BY 子句的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对每个小区域分别进行数据汇总处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... FROM ...<br>GROUP BY ...;<br></code></pre></td></tr></table></figure><ul><li><p>数据库支持多列分组条件，执行的时候逐级分组。</p><p>栗：查询每个部门里，每种职位的人员数量和平均底薪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno, job, COUNT(*), ROUND(AVG(sal))<br>FROM t_emp<br>GROUP BY deptno, job<br>ORDER BY deptno;<br></code></pre></td></tr></table></figure><p>注意：查询语句中如果含有 GROUP BY 子句，那么 SELECT 子句中的内容就必须要遵守规定：<strong>SELECT 子句中可以包括聚合函数，或者 GROUP BY 子句的分组列，其余内容均不可以出现在 SELECT 子句中</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT deptno, COUNT(*), AVG(sal)  # correct<br>FROM t_emp GROUP BY deptno;<br><br>SELECT deptno, COUNT(*), AVG(sal), sal  # wrong<br>FROM t_emp GROUP BY deptno;<br></code></pre></td></tr></table></figure><h4 id="with-rollup">WITH ROLLUP</h4><p>对分组结果集再次做汇总计算 WITH ROLLUP</p><p>栗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno, COUNT(*), AVG(sal), MAX(sal), MIN(sal)<br>FROM t_emp<br>GROUP BY deptno WITH ROLLUP;<br></code></pre></td></tr></table></figure><h4 id="group_concat-函数">GROUP_CONCAT 函数</h4><p>GROUP_CONCAT 函数可以把分组查询中的某个字段拼接成一个字符串。</p><p>栗：查询每个部门内底薪超过2000元的人数和员工姓名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno, COUNT(*), GROUP_CONCAT(ename)<br>FROM t_emp<br>WHERE sal &gt;&#x3D; 2000<br>GROUP BY deptno;<br></code></pre></td></tr></table></figure><blockquote><p>查询语句中，GROUP BY子句应该第几个执行？</p><p>执行顺序：FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p></blockquote><h3 id="having-子句">HAVING 子句</h3><p>栗：查询部门平均底薪超过2000元的部门编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno FROM t_emp  # WRONG<br>WHERE AVG(sal) &gt;&#x3D; 2000<br>GROUP BY deptno;<br></code></pre></td></tr></table></figure><p><strong>因为 WHERE 子句先于 GROUP BY 执行，一旦 WHERE 子句中出现了聚合函数，数据库根本不知道按照什么范围计算汇总值。</strong></p><p>所以：</p><ul><li><p>WHERE 子句的作用是对查询结果进行分组前，将不符合 WHERE 条件的行去掉，即<strong>在分组之前过滤数据，WHERE 条件中不能包含聚组函数</strong>，使用 WHERE 条件过滤出特定的行。</p></li><li><p>HAVING 子句的作用是筛选满足条件的组，即<strong>在分组之后过滤数据</strong>，<strong>条件中经常包含聚组函数</strong>，使用 HAVING 条件过滤出特定的组，也可以使用多个分组标准进行分组。</p></li></ul><p>栗：查询每个部门中，1982年以后入职的员工超过2个人的部门编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno FROM t_emp<br>WHERE hiredate &gt;&#x3D; &quot;1982-01-01&quot;<br>GROUP BY deptno HAVING COUNT(*) &gt;&#x3D; 2<br>ORDER BY deptno ASC;<br></code></pre></td></tr></table></figure><blockquote><p>HAVING子句的特殊用法</p><p>按照数字1分组，MySQL 会依据 SELECT 子句中的列进行分组， HAVING 子句也可以正常使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno, COUNT(*) FROM t_emp<br>GROUP BY 1;  # 1 相当于 deptno <br></code></pre></td></tr></table></figure></blockquote><h2 id="表连接查询">表连接查询</h2><p><strong>连接方式：</strong></p><ul><li>外连接：左连接，右连接，全外连接</li><li>内连接：等值连接，非等值连接，自然连接</li><li>交叉连接：笛卡尔积</li></ul><blockquote><p><strong>自然连接与等值连接的异同？</strong></p><ul><li><p>自然连接和等值连接的相同之处是<strong>二者都是根据属性值相等进行连接。</strong></p><blockquote><p>只返回两个表中连接字段相等的行</p></blockquote></li><li><p>二者的不同之处是：<strong>自然连接中相等的分量必须是相同的属性组，并且要在结果中去掉重复的属性。而等值连接不必。</strong></p></li></ul></blockquote><p><strong>连接方式说明：</strong></p><ul><li>内连接：只有两个元素表相匹配的才能在结果集中显示。只保留符合连接条件的记录</li><li>外连接：不管符不符合连接条件，记录都要保留在结果集中<ul><li>左外连接：左边表的数据全部显示，右边表的数据只显示共有的数据部分，不匹配的不会显示。</li><li>右外连接：右边表的数据全部显示，左边表的数据只显示共有的数据部分，不匹配的不会显示。</li><li>全外连接：连接的表中不匹配的数据全部会显示出来。</li></ul></li><li>交叉连接： 笛卡尔积，显示的结果是链接表数的乘积。</li></ul><h3 id="内连接">内连接</h3><p>内连接：只有两个元素表相匹配的才能在结果集中显示。只保留符合连接条件的记录</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208222855455.png" alt="pokeman-parameters" style="width:50%;"/></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT …… FROM 表1 <br>[INNER] JOIN 表2 WHERE 连接条件 ;<br></code></pre></td></tr></table></figure><ul><li><strong>内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以</strong></li><li><strong>相同数据表也可以做表连接。</strong></li><li><strong>可以把查询的结果集当作一张表进行连接。</strong></li></ul><p>练习：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208231842179.png" alt="pokeman-parameters" style="width:55%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208231932372.png" alt="pokeman-parameters" style="width:55%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210209154049652.png" alt="pokeman-parameters" style="width:100%;"/></center><p>练习：</p><ol type="1"><li><p>查询每个员工的工号、姓名、部门名称、底薪、职位、工资等级？</p><blockquote><p>sal 两个表没有同名的字段，但是<strong>内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, d.dname, e.job, s.grade <br>FROM t_emp e JOIN t_dept d ON e.deptno&#x3D;d.deptno<br>JOIN t_salgrade s ON e.sal BETWEEN s.losal AND s.hisal<br></code></pre></td></tr></table></figure></li><li><p>查询与SCOTT相同部门的员工都有谁？</p><p><strong>相同数据表也可以做表连接。</strong></p><p>写子查询语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ename<br>FROM t_emp <br>WHERE deptno&#x3D;(SELECT deptno FROM t_dept WHERE ename&#x3D;&quot;SCOTT&quot;)<br>AND ename!&#x3D;&quot;SCOTT&quot;<br></code></pre></td></tr></table></figure><p>改成内连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e2.ename<br>FROM t_emp e1 JOIN t_emp e2 ON e1.deptno&#x3D;e2.deptno<br>WHERE e1.ename&#x3D;&quot;SCOTT&quot; AND e2.ename!&#x3D;&quot;SCOTT&quot;;<br></code></pre></td></tr></table></figure></li><li><p>查询月薪超过公司平均月薪的员工信息？</p><p><strong>可以把查询的结果集当作一张表进行连接。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, e.sal<br>FROM t_emp e <br>JOIN (SELECT AVG(sal) avg FROM t_emp) t;<br>ON e.sal&gt;&#x3D;t.avg;<br></code></pre></td></tr></table></figure></li><li><p>查询RESEARCH部门的人数、最高底薪、最低底薪、平均底薪、平均工龄？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*), MAX(e.sal), MIN(e.sal), FLOOR(AVG(DATEDIFF(NOW(), e.hiredate)&#x2F;365))<br>FROM t_emp e JOIN t_dept d<br>ON e.deptno&#x3D;d.deptno<br>WHERE d.dname&#x3D;&quot;RESEARCH&quot;;<br></code></pre></td></tr></table></figure></li><li><p>查询每种职业的最高工资、最低工资、平均工资、最高工资等级和 最低工资等级？</p><blockquote><p>工资：<code>e.sal + ISFULL(e.comm, 0)</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.job, <br>MAX(e.sal+IFNULL(e.comm, 0)), <br>MIN(e.sal+IFNULL(e.comm, 0)),<br>AVG(e.sal+IFNULL(e.comm, 0)),<br>MAX(s.grade), <br>MIN(s.grade)<br>FROM t_emp e JOIN t_salgrade s<br>ON (e.sal+IFNULL(e.comm, 0)) BETWEEN s.losal AND s.hisal<br>GROUP BY e.job;<br></code></pre></td></tr></table></figure></li><li><p>查询每个<u>底薪</u>超过<u>部门</u> <u>平均底薪</u>的员工信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>e.empno,<br>e.ename,<br>e.sal <br>FROM<br>t_emp e<br>JOIN ( SELECT deptno, AVG( SAL ) AS avg FROM t_emp GROUP BY deptno ) t ON e.deptno &#x3D; t.deptno <br>AND e.sal &gt;&#x3D; t.avg;<br></code></pre></td></tr></table></figure></li></ol><h3 id="外连接">外连接</h3><p>外连接：不管符不符合连接条件，记录都要保留在结果集中</p><p>外连接包括：左(外)连接，右(外)连接，全外连接</p><ul><li>左外连接：左边表的数据全部显示，右边表的数据只显示共有的数据部分，不匹配的不会显示。</li><li>右外连接：右边表的数据全部显示，左边表的数据只显示共有的数据部分，不匹配的不会显示。</li><li>全外连接：连接的表中不匹配的数据全部会显示出来。</li></ul><p>注意：<strong>UNION关键字可以将多个查询语句的结果集进行合并</strong></p><p>栗子：列出员工的工号，姓名和部门名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, d.dname<br>FROM t_emp e JOIN t_dept d<br>ON e.deptno&#x3D;d.deptno;<br></code></pre></td></tr></table></figure><blockquote><p>如果使用内连接，有空值的员工就显示不出来。</p></blockquote><p>所以得改成左连接，如果有空值，就出NULL值来匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, d.dname<br>FROM t_emp e LEFT JOIN t_dept d<br>ON e.deptno&#x3D;d.deptno;<br></code></pre></td></tr></table></figure><p>或者由右外连接反着写也行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, d.dname<br>FROM t_dept d RIGHT JOIN t_emp e<br>ON e.deptno&#x3D;d.deptno;<br></code></pre></td></tr></table></figure><p>练习：</p><ol type="1"><li>查询每个部门的名称和部门的人数？</li></ol><blockquote><p>deptno=40的部门，有这个部门，没有员工。但是这个部门是存在的，所以要以部门：0的形式存在。</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT d.deptno, d.dname, COUNT(e.deptno)<br>FROM t_dept d<br>LEFT JOIN t_emp e <br>ON d.deptno&#x3D;e.deptno<br>GROUP BY d.deptno;<br></code></pre></td></tr></table></figure> 注意：不能再写 <code>COUNT(*)</code>，这样会把NULL值也算成一。所以要改成 <code>e.deptno</code> ，注意不是 <code>d.deptno</code> ，要忽略掉右表的NULL值。</p><ol start="2" type="1"><li><p>查询每个部门的名称和部门的人数？如果没有部门的员工，部门名 称用NULL代替。(指陈浩，没有部门号，也就没有部门)</p><blockquote><p>首先，上一题的左外连接就是把陈浩这条排除掉了因为右表的陈浩deptno是NULL。那么又想到了右外连接把他算进来。但是这时，又把本来的deptno=40的部门给排除掉了因为没有人是这个部门。所以这时，需要把两个结果并起来。使用关键字<strong>UNION</strong></p></blockquote><p><strong>UNION关键字可以将多个查询语句的结果集进行合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">(<br>SELECT d.deptno, d.dname, COUNT(e.deptno)<br>FROM t_dept d LEFT JOIN t_emp e <br>ON d.deptno&#x3D;e.deptno<br>GROUP BY d.deptno<br>) UNION<br>(<br>SELECT d.deptno, d.dname, COUNT(*)<br>FROM t_dept d RIGHT JOIN t_emp e <br>ON d.deptno&#x3D;e.deptno<br>GROUP BY d.deptno<br>);<br></code></pre></td></tr></table></figure><blockquote><p>左连接中要改成 <code>e.deptno</code> ，而不是 <code>d.deptno</code> ，因为要忽略掉右表的NULL值， <code>COUNT(*)</code> 会把NULL值也算成一。</p><p>而右连接中要改成 <code>COUNT(*)</code> ，而不是 <code>e.deptno</code> 或 <code>d.deptno</code> 。因为以右表看左表的话，陈浩是空部门但是也是有一个人。写成 <code>d.deptno</code> 的话陈浩的deptno=NULL直接就算成0了。</p></blockquote></li><li><p>查询每名员工的编号、姓名、部门、月薪、工资等级、工龄、上司编号、上司姓名、上司部门？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select e.empno, e.ename, d.dname, <br>e.sal+IFNULL(comm, 0) as &#39;月薪&#39;, s.grade,  <br>FLOOR(DATEDIFF(NOW(),e.hiredate)&#x2F;365) as &#39;工龄&#39;,<br>t.empno as mgr_no, t.ename as mgr_name, t.dname as mgr_dname<br>from t_emp e <br>left join t_dept d ON e.deptno&#x3D;d.deptno<br>left join t_salgrade s ON e.sal between s.losal and hisal<br>left join <br>(select e1.empno, e1.ename, d1.dname <br>from t_emp e1 join t_dept d1<br>on e1.deptno&#x3D;d1.deptno<br>) t<br>on e.mgr&#x3D;t.empno ;<br></code></pre></td></tr></table></figure></li></ol><p>外连接注意事项： 内连接只保留符合条件的记录，所以查询条件写在 ON 子句和 WHERE 子句中的效果是相同的。但是外连接里，条件写在 WHERE 子句里，不合符条件的记录是会被过滤掉的，而如果写 ON ，即使不符合条件也会被左外连接保留下来。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210209165346348.png" alt="pokeman-parameters" style="width:75%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210209165408866.png" alt="pokeman-parameters" style="width:75%;"/></center><h2 id="子查询">子查询</h2><p>子查询是一种查询中嵌套查询的语句，可以写在三个地方：WHERE子句、FROM子句、SELECT子句。</p><p>查询语句执行的时候要多次的依赖于子查询的结果，这类子查询被称作相关子查询：WHERE 子查询和 SELECT 子查询都属于相关子查询 。因为相关子查询要反复多次执行，所以应该避免使用。所以只有FROM子句子查询是最可取的。</p><p>栗： 查询底薪超过公司平均底薪的员工的信息</p><ul><li><p>WHERE 子查询：最简单，最容易理解，但是却是效率很低的子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT empno, ename, sal<br>FROM t_emp<br>WHERE sal&gt;&#x3D;(SELECT AVG(sal) FROM t_emp)<br></code></pre></td></tr></table></figure></li><li><p>FROM子查询：只会执行一次，所以查询效率很高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, e.sal, t.avg<br>FROM t_emp e<br>JOIN(<br>  SELECT deptno, AVG(sal) as avg<br>  FROM t_emp GROUP BY deptno) t<br>ON e.deptno&#x3D;t.deptno AND e.sal&gt;&#x3D;t.avg<br></code></pre></td></tr></table></figure></li><li><p>SELECT子查询：每输出一条记录的时候都要执行一次，查询效率很低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename<br>  (SELECT dname FROM t_dept WHERE deptno&#x3D;e.deptno)<br>FROM t_emp e;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL的数据查询语言DQL</title>
    <link href="/2021/02/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2/"/>
    <url>/2021/02/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了有关数据库的 Data Query Language 数据查询语言的相关操作，包括：SELECT，WHERE，ORDER BY，GROUP BY 和 HAVING 等等。</p><p><em><a id="more"></a></em></p><hr /><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208073436724.png" alt="pokeman-parameters" style="width:100%;"/></center><h1 id="dql数据查询语言">DQL：数据查询语言</h1><h2 id="普通查询">普通查询</h2><h3 id="记录查询-select-from">记录查询 SELECT FROM</h3><p>最基本的查询语句是由 SELECT 和 FROM 关键字组成的。</p><blockquote><p>SELECT 语句屏蔽了物理层的操作，用户不必关心数据的真实存储，交由数据库高效的查找数据</p></blockquote><p>栗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp;<br>SELECT id, nme FROM t_student;<br></code></pre></td></tr></table></figure><h3 id="使用列别名-as">使用列别名 AS</h3><p>通常情况下， SELECT 子句中使用了表达式，那么这列的名字就默认为表达式，因此需要一种对列名重命名的机制 AS 。</p><blockquote><p>重命名只在显示输出的时候使用，数据表列名不会真的改变</p></blockquote><p>栗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>  ename,<br>  sal*12 AS &quot;annual_salary&quot;<br>FROM <br>  t_emp;<br></code></pre></td></tr></table></figure><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210207003518847.png" alt="pokeman-parameters" style="width:50%;"/></center><h3 id="数据分页-limit">数据分页 LIMIT</h3><p>LIMIT 关键字限定结果集数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... FROM ... LIMIT 起始位置, 偏移量;  # 注意是偏移量，而不是结束位置<br></code></pre></td></tr></table></figure><p>如果只有一个参数，他表示表示的是偏移量，起始值默认为0。</p><h3 id="排序-order-by">排序 ORDER BY</h3><p>如果想让结果集按照某种顺序排列，就必须使用 ORDER BY 子句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT …… FROM …… ORDER BY 列名 [ ASC | DESC ];<br></code></pre></td></tr></table></figure><h4 id="排序关键字">排序关键字</h4><p>ASC 代表升序（默认）， DESC 代表降序</p><ul><li><p>如果排序列是数字类型，数据库就按照数字大小排序；如果是日期类型就按照日期大小排序，如果是字符串就按照字符集序号排序。</p></li><li><p>可以使用 ORDER BY 规定首要排序条件和次要排序条件。放前面的先排序。</p></li></ul><blockquote><p>注：ORDER BY 子句书写的时候放在 LIMIT 子句的前面 执行顺序：FROM--&gt; SELECT --&gt; ORDER BY --&gt; LIMIT</p></blockquote><h3 id="去重-distinct">去重 DISTINCT</h3><p>如果需要去除重复的数据，可以使用 DISTINCT 关键字来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT 字段 FROM …… ;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ol type="1"><li><p>使用 DISTINCT 的 SELECT 子句中只能查询一列数据，如果查询多列，去除重复记录就会失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT job, ename FROM t_emp;  # 不可以查询多列<br></code></pre></td></tr></table></figure></li><li><p>DISTINCT 关键字只能在 SELECT 子句中使用一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT job, DISTINCT ename FROM t_emp;  # 错<br>SELECT job, DISTINCT ename FROM t_emp;  # 错<br></code></pre></td></tr></table></figure></li></ol></blockquote><h3 id="条件查询-where">条件查询 WHERE</h3><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT …… FROM …… WHERE 条件 [ AND OR ] 条件 ……;<br></code></pre></td></tr></table></figure><ul><li><p>WHERE 语句中的条件运算会用 到以下 四种运算符：</p><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>运算符</th><th>栗子</th></tr></thead><tbody><tr class="odd"><td>数学运算符</td><td><code>+, -, *, /, %</code></td></tr><tr class="even"><td>比较运算符</td><td><code>&gt;, &gt;=, &lt;, &lt;=, =, !=, IN</code>； <code>IS NULL, IS NOY NULL, BETWEEN AND, LIKE, REGEXP</code></td></tr><tr class="odd"><td>逻辑运算符</td><td><code>AND, OR, NOT, XOR(异或：相同为0，不同为1)</code></td></tr><tr class="even"><td>按位运算符</td><td><code>&amp;, |, ~(位取反), ^(位异或), &lt;&lt;(左移), &gt;&gt;(右移)</code></td></tr></tbody></table></li></ul><blockquote><p>注：WHERE 子句中，条件执行的顺序是从左到右的。所以我们应该把<strong>索引条件</strong>，或者<strong>筛选掉记录最多的条件</strong>写在最左侧。</p></blockquote><blockquote><p>条件查询中， WHERE 子句应该是第几个执行？ 执行顺序：FROM--&gt; WHERE --&gt; SELECT --&gt; ORDER BY --&gt; LIMIT</p><p>(WHERE 排在 SELECT 前是因为 WHERE先筛选符合条件的记录，SELECT 才能从中挑出结果集中显示的字段)</p></blockquote><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT empno, ename, sal, hiredate<br>FROM t_emp<br>WHERE deptno&#x3D;10 AND (sal+IFNULL(comm, 0))*12&gt;&#x3D;15000 # IFNULL(expr1,expr2) 判断expr1是否NULL，是就expr2<br>AND DATEDIFF(NOW(),hiredate)&#x2F;365 &gt;&#x3D; 20;  # DATEDIFF(expr1,expr2)算两个日期的天数<br>IFNULL(expr1,expr2)<br></code></pre></td></tr></table></figure><h2 id="高级查询">高级查询</h2><h3 id="聚合函数">聚合函数</h3><p>聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对数据求和、求最大值和最小值、求平均值等等。</p><ul><li><p><strong>SUM 函数</strong>用于求和，<u>只能用于数字类型</u>，字符类型的统计结果为0 ，日期类型统计结果是毫秒数相加。</p></li><li><p><strong>MAX 函数</strong>用于获得非空值的最大值。</p></li><li><p><strong>MIN 函数</strong>用于获得非空值的最小值。</p></li><li><p><strong>AVG 函数</strong>用于获得非空值的平均值，非数字数据统计结果为0。</p></li><li><p>**COUNT(*)** 用于获得所有的(包含空值)的记录数</p><p><strong>COUNT(列名)</strong> 用于获得所有的(不包含空值)的记录数。</p></li></ul><p>栗子：查询10和20部门中，底薪超过2000元并且工龄超过15年的员工人数？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(ename)<br>FROM t_emp<br>WHERE deptno IN(10, 20) AND sal&gt;&#x3D;2000 <br>AND DATEDIFF(NOW(), hiredate)&#x2F;365 &gt;&#x3D; 15;<br></code></pre></td></tr></table></figure><h3 id="分组查询-group-by">分组查询 GROUP BY</h3><p>默认情况下汇总函数是对全表范围内的数据做统计。</p><p>GROUP BY 子句的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对每个小区域分别进行数据汇总处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... FROM ...<br>GROUP BY ...;<br></code></pre></td></tr></table></figure><ul><li><p>数据库支持多列分组条件，执行的时候逐级分组。</p><p>栗：查询每个部门里，每种职位的人员数量和平均底薪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno, job, COUNT(*), ROUND(AVG(sal))<br>FROM t_emp<br>GROUP BY deptno, job<br>ORDER BY deptno;<br></code></pre></td></tr></table></figure><p>注意：查询语句中如果含有 GROUP BY 子句，那么 SELECT 子句中的内容就必须要遵守规定：<strong>SELECT 子句中可以包括聚合函数，或者 GROUP BY 子句的分组列，其余内容均不可以出现在 SELECT 子句中</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT deptno, COUNT(*), AVG(sal)  # correct<br>FROM t_emp GROUP BY deptno;<br><br>SELECT deptno, COUNT(*), AVG(sal), sal  # wrong<br>FROM t_emp GROUP BY deptno;<br></code></pre></td></tr></table></figure><h4 id="with-rollup">WITH ROLLUP</h4><p>对分组结果集再次做汇总计算 WITH ROLLUP</p><p>栗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno, COUNT(*), AVG(sal), MAX(sal), MIN(sal)<br>FROM t_emp<br>GROUP BY deptno WITH ROLLUP;<br></code></pre></td></tr></table></figure><h4 id="group_concat-函数">GROUP_CONCAT 函数</h4><p>GROUP_CONCAT 函数可以把分组查询中的某个字段拼接成一个字符串。</p><p>栗：查询每个部门内底薪超过2000元的人数和员工姓名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno, COUNT(*), GROUP_CONCAT(ename)<br>FROM t_emp<br>WHERE sal &gt;&#x3D; 2000<br>GROUP BY deptno;<br></code></pre></td></tr></table></figure><blockquote><p>查询语句中，GROUP BY子句应该第几个执行？</p><p>执行顺序：FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p></blockquote><h3 id="having-子句">HAVING 子句</h3><p>栗：查询部门平均底薪超过2000元的部门编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno FROM t_emp  # WRONG<br>WHERE AVG(sal) &gt;&#x3D; 2000<br>GROUP BY deptno;<br></code></pre></td></tr></table></figure><p><strong>因为 WHERE 子句先于 GROUP BY 执行，一旦 WHERE 子句中出现了聚合函数，数据库根本不知道按照什么范围计算汇总值。</strong></p><p>所以：</p><ul><li><p>WHERE 子句的作用是对查询结果进行分组前，将不符合 WHERE 条件的行去掉，即<strong>在分组之前过滤数据，WHERE 条件中不能包含聚组函数</strong>，使用 WHERE 条件过滤出特定的行。</p></li><li><p>HAVING 子句的作用是筛选满足条件的组，即<strong>在分组之后过滤数据</strong>，<strong>条件中经常包含聚组函数</strong>，使用 HAVING 条件过滤出特定的组，也可以使用多个分组标准进行分组。</p></li></ul><p>栗：查询每个部门中，1982年以后入职的员工超过2个人的部门编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno FROM t_emp<br>WHERE hiredate &gt;&#x3D; &quot;1982-01-01&quot;<br>GROUP BY deptno HAVING COUNT(*) &gt;&#x3D; 2<br>ORDER BY deptno ASC;<br></code></pre></td></tr></table></figure><blockquote><p>HAVING子句的特殊用法</p><p>按照数字1分组，MySQL 会依据 SELECT 子句中的列进行分组， HAVING 子句也可以正常使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT deptno, COUNT(*) FROM t_emp<br>GROUP BY 1;  # 1 相当于 deptno <br></code></pre></td></tr></table></figure></blockquote><h2 id="表连接查询">表连接查询</h2><p><strong>连接方式：</strong></p><ul><li>外连接：左连接，右连接，全外连接</li><li>内连接：等值连接，非等值连接，自然连接</li><li>交叉连接：笛卡尔积</li></ul><blockquote><p><strong>自然连接与等值连接的异同？</strong></p><ul><li><p>自然连接和等值连接的相同之处是<strong>二者都是根据属性值相等进行连接。</strong></p><blockquote><p>只返回两个表中连接字段相等的行</p></blockquote></li><li><p>二者的不同之处是：<strong>自然连接中相等的分量必须是相同的属性组，并且要在结果中去掉重复的属性。而等值连接不必。</strong></p></li></ul></blockquote><p><strong>连接方式说明：</strong></p><ul><li>内连接：只有两个元素表相匹配的才能在结果集中显示。只保留符合连接条件的记录</li><li>外连接：不管符不符合连接条件，记录都要保留在结果集中<ul><li>左外连接：左边表的数据全部显示，右边表的数据只显示共有的数据部分，不匹配的不会显示。</li><li>右外连接：右边表的数据全部显示，左边表的数据只显示共有的数据部分，不匹配的不会显示。</li><li>全外连接：连接的表中不匹配的数据全部会显示出来。</li></ul></li><li>交叉连接： 笛卡尔积，显示的结果是链接表数的乘积。</li></ul><h3 id="内连接">内连接</h3><p>内连接：只有两个元素表相匹配的才能在结果集中显示。只保留符合连接条件的记录</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208222855455.png" alt="pokeman-parameters" style="width:50%;"/></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT …… FROM 表1 <br>[INNER] JOIN 表2 WHERE 连接条件 ;<br></code></pre></td></tr></table></figure><ul><li><strong>内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以</strong></li><li><strong>相同数据表也可以做表连接。</strong></li><li><strong>可以把查询的结果集当作一张表进行连接。</strong></li></ul><p>练习：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208231842179.png" alt="pokeman-parameters" style="width:55%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210208231932372.png" alt="pokeman-parameters" style="width:55%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210209154049652.png" alt="pokeman-parameters" style="width:100%;"/></center><p>练习：</p><ol type="1"><li><p>查询每个员工的工号、姓名、部门名称、底薪、职位、工资等级？</p><blockquote><p>sal 两个表没有同名的字段，但是<strong>内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, d.dname, e.job, s.grade <br>FROM t_emp e JOIN t_dept d ON e.deptno&#x3D;d.deptno<br>JOIN t_salgrade s ON e.sal BETWEEN s.losal AND s.hisal<br></code></pre></td></tr></table></figure></li><li><p>查询与SCOTT相同部门的员工都有谁？</p><p><strong>相同数据表也可以做表连接。</strong></p><p>写子查询语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ename<br>FROM t_emp <br>WHERE deptno&#x3D;(SELECT deptno FROM t_dept WHERE ename&#x3D;&quot;SCOTT&quot;)<br>AND ename!&#x3D;&quot;SCOTT&quot;<br></code></pre></td></tr></table></figure><p>改成内连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e2.ename<br>FROM t_emp e1 JOIN t_emp e2 ON e1.deptno&#x3D;e2.deptno<br>WHERE e1.ename&#x3D;&quot;SCOTT&quot; AND e2.ename!&#x3D;&quot;SCOTT&quot;;<br></code></pre></td></tr></table></figure></li><li><p>查询月薪超过公司平均月薪的员工信息？</p><p><strong>可以把查询的结果集当作一张表进行连接。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, e.sal<br>FROM t_emp e <br>JOIN (SELECT AVG(sal) avg FROM t_emp) t;<br>ON e.sal&gt;&#x3D;t.avg;<br></code></pre></td></tr></table></figure></li><li><p>查询RESEARCH部门的人数、最高底薪、最低底薪、平均底薪、平均工龄？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*), MAX(e.sal), MIN(e.sal), FLOOR(AVG(DATEDIFF(NOW(), e.hiredate)&#x2F;365))<br>FROM t_emp e JOIN t_dept d<br>ON e.deptno&#x3D;d.deptno<br>WHERE d.dname&#x3D;&quot;RESEARCH&quot;;<br></code></pre></td></tr></table></figure></li><li><p>查询每种职业的最高工资、最低工资、平均工资、最高工资等级和 最低工资等级？</p><blockquote><p>工资：<code>e.sal + ISFULL(e.comm, 0)</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.job, <br>MAX(e.sal+IFNULL(e.comm, 0)), <br>MIN(e.sal+IFNULL(e.comm, 0)),<br>AVG(e.sal+IFNULL(e.comm, 0)),<br>MAX(s.grade), <br>MIN(s.grade)<br>FROM t_emp e JOIN t_salgrade s<br>ON (e.sal+IFNULL(e.comm, 0)) BETWEEN s.losal AND s.hisal<br>GROUP BY e.job;<br></code></pre></td></tr></table></figure></li><li><p>查询每个<u>底薪</u>超过<u>部门</u> <u>平均底薪</u>的员工信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>e.empno,<br>e.ename,<br>e.sal <br>FROM<br>t_emp e<br>JOIN ( SELECT deptno, AVG( SAL ) AS avg FROM t_emp GROUP BY deptno ) t ON e.deptno &#x3D; t.deptno <br>AND e.sal &gt;&#x3D; t.avg;<br></code></pre></td></tr></table></figure></li></ol><h3 id="外连接">外连接</h3><p>外连接：不管符不符合连接条件，记录都要保留在结果集中</p><p>外连接包括：左(外)连接，右(外)连接，全外连接</p><ul><li>左外连接：左边表的数据全部显示，右边表的数据只显示共有的数据部分，不匹配的不会显示。</li><li>右外连接：右边表的数据全部显示，左边表的数据只显示共有的数据部分，不匹配的不会显示。</li><li>全外连接：连接的表中不匹配的数据全部会显示出来。</li></ul><p>注意：<strong>UNION关键字可以将多个查询语句的结果集进行合并</strong></p><p>栗子：列出员工的工号，姓名和部门名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, d.dname<br>FROM t_emp e JOIN t_dept d<br>ON e.deptno&#x3D;d.deptno;<br></code></pre></td></tr></table></figure><blockquote><p>如果使用内连接，有空值的员工就显示不出来。</p></blockquote><p>所以得改成左连接，如果有空值，就出NULL值来匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, d.dname<br>FROM t_emp e LEFT JOIN t_dept d<br>ON e.deptno&#x3D;d.deptno;<br></code></pre></td></tr></table></figure><p>或者由右外连接反着写也行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, d.dname<br>FROM t_dept d RIGHT JOIN t_emp e<br>ON e.deptno&#x3D;d.deptno;<br></code></pre></td></tr></table></figure><p>练习：</p><ol type="1"><li>查询每个部门的名称和部门的人数？</li></ol><blockquote><p>deptno=40的部门，有这个部门，没有员工。但是这个部门是存在的，所以要以部门：0的形式存在。</p></blockquote><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT d.deptno, d.dname, COUNT(e.deptno)<br>FROM t_dept d<br>LEFT JOIN t_emp e <br>ON d.deptno&#x3D;e.deptno<br>GROUP BY d.deptno;<br></code></pre></td></tr></table></figure> 注意：不能再写 <code>COUNT(*)</code>，这样会把NULL值也算成一。所以要改成 <code>e.deptno</code> ，注意不是 <code>d.deptno</code> ，要忽略掉右表的NULL值。</p><ol start="2" type="1"><li><p>查询每个部门的名称和部门的人数？如果没有部门的员工，部门名 称用NULL代替。(指陈浩，没有部门号，也就没有部门)</p><blockquote><p>首先，上一题的左外连接就是把陈浩这条排除掉了因为右表的陈浩deptno是NULL。那么又想到了右外连接把他算进来。但是这时，又把本来的deptno=40的部门给排除掉了因为没有人是这个部门。所以这时，需要把两个结果并起来。使用关键字<strong>UNION</strong></p></blockquote><p><strong>UNION关键字可以将多个查询语句的结果集进行合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">(<br>SELECT d.deptno, d.dname, COUNT(e.deptno)<br>FROM t_dept d LEFT JOIN t_emp e <br>ON d.deptno&#x3D;e.deptno<br>GROUP BY d.deptno<br>) UNION<br>(<br>SELECT d.deptno, d.dname, COUNT(*)<br>FROM t_dept d RIGHT JOIN t_emp e <br>ON d.deptno&#x3D;e.deptno<br>GROUP BY d.deptno<br>);<br></code></pre></td></tr></table></figure><blockquote><p>左连接中要改成 <code>e.deptno</code> ，而不是 <code>d.deptno</code> ，因为要忽略掉右表的NULL值， <code>COUNT(*)</code> 会把NULL值也算成一。</p><p>而右连接中要改成 <code>COUNT(*)</code> ，而不是 <code>e.deptno</code> 或 <code>d.deptno</code> 。因为以右表看左表的话，陈浩是空部门但是也是有一个人。写成 <code>d.deptno</code> 的话陈浩的deptno=NULL直接就算成0了。</p></blockquote></li><li><p>查询每名员工的编号、姓名、部门、月薪、工资等级、工龄、上司编号、上司姓名、上司部门？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select e.empno, e.ename, d.dname, <br>e.sal+IFNULL(comm, 0) as &#39;月薪&#39;, s.grade,  <br>FLOOR(DATEDIFF(NOW(),e.hiredate)&#x2F;365) as &#39;工龄&#39;,<br>t.empno as mgr_no, t.ename as mgr_name, t.dname as mgr_dname<br>from t_emp e <br>left join t_dept d ON e.deptno&#x3D;d.deptno<br>left join t_salgrade s ON e.sal between s.losal and hisal<br>left join <br>(select e1.empno, e1.ename, d1.dname <br>from t_emp e1 join t_dept d1<br>on e1.deptno&#x3D;d1.deptno<br>) t<br>on e.mgr&#x3D;t.empno ;<br></code></pre></td></tr></table></figure></li></ol><p>外连接注意事项： 内连接只保留符合条件的记录，所以查询条件写在 ON 子句和 WHERE 子句中的效果是相同的。但是外连接里，条件写在 WHERE 子句里，不合符条件的记录是会被过滤掉的，而如果写 ON ，即使不符合条件也会被左外连接保留下来。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210209165346348.png" alt="pokeman-parameters" style="width:75%;"/></center><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210209165408866.png" alt="pokeman-parameters" style="width:75%;"/></center><h2 id="子查询">子查询</h2><p>子查询是一种查询中嵌套查询的语句，可以写在三个地方：WHERE子句、FROM子句、SELECT子句。</p><p>查询语句执行的时候要多次的依赖于子查询的结果，这类子查询被称作相关子查询：WHERE 子查询和 SELECT 子查询都属于相关子查询 。因为相关子查询要反复多次执行，所以应该避免使用。所以只有FROM子句子查询是最可取的。</p><p>栗： 查询底薪超过公司平均底薪的员工的信息</p><ul><li><p>WHERE 子查询：最简单，最容易理解，但是却是效率很低的子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT empno, ename, sal<br>FROM t_emp<br>WHERE sal&gt;&#x3D;(SELECT AVG(sal) FROM t_emp)<br></code></pre></td></tr></table></figure></li><li><p>FROM子查询：只会执行一次，所以查询效率很高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename, e.sal, t.avg<br>FROM t_emp e<br>JOIN(<br>  SELECT deptno, AVG(sal) as avg<br>  FROM t_emp GROUP BY deptno) t<br>ON e.deptno&#x3D;t.deptno AND e.sal&gt;&#x3D;t.avg<br></code></pre></td></tr></table></figure></li><li><p>SELECT子查询：每输出一条记录的时候都要执行一次，查询效率很低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT e.empno, e.ename<br>  (SELECT dname FROM t_dept WHERE deptno&#x3D;e.deptno)<br>FROM t_emp e;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库表的相关操作</title>
    <link href="/2021/02/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/02/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了有关数据库表的 Data Defination Language (修改表结构)相关操作。</p><p><em><a id="more"></a></em></p><hr /><h2 id="关于数据库的一些设置">关于数据库的一些设置</h2><h3 id="重设-root-密码">重设 root 密码</h3><p>步骤1. 创建一个 txt 文件，定义修改密码的 SQL 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;<br></code></pre></td></tr></table></figure><p>步骤2.</p><ol type="1"><li>打开 PowerShell（管理员）窗口</li><li>执行 <code>net stop mysql</code></li><li>执行 <code>mysqld --defaults-file=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\my.ini&quot; --init-file=&quot;上面的txt文件所在位置&quot; --console</code></li></ol><h3 id="mysql-配置文件">MySQL 配置文件</h3><p>MySQL 配置文件叫做 <code>my.ini</code> ，在这个文件中可以设置各种 MySQL 的配置，例如字符集、端口号、目录地址等等。</p><p>列出一些重点参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[client]<br>port&#x3D;3306  # 默认端口<br><br>[mysql]<br>no-beep  # clinet出错时不要发出蜂鸣器的报警声<br><br>[mysqld]<br>port&#x3D;3306  # 端口号，如果要改先关掉 MySQL，改完配置文件再打开<br>datadir&#x3D;C:&#x2F;ProgramData&#x2F;MySQL&#x2F;MySQL Server 8.0&#x2F;Data  # 数据目录<br>default_authentication_plugin&#x3D;mysql_native_password  # 密码认证插件<br>default-storage-engine&#x3D;INNODB  # 默认存储引擎<br>sql-mode&#x3D;&quot;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION&quot;  # 开启严格模式，<br>log-output&#x3D;FILE  # 用文件记录日志<br>general-log&#x3D;0  # 关闭日志输出<br>general_log_file&#x3D;&quot;DESKTOP-VOLMMUF.log&quot;  # 日志文件名称<br>slow-query-log&#x3D;1  # 开启慢查询日志<br>slow_query_log_file&#x3D;&quot;DESKTOP-VOLMMUF-slow.log&quot;  # 慢查询日志名称<br>long_query_time&#x3D;10  # 大于多少秒的执行SQL被记录在慢查询日志里<br>log-error&#x3D;&quot;DESKTOP-VOLMMUF.err&quot;  # 错误日志名称<br>server-id&#x3D;1  # 数据库id。数据库集群的时候才会用到它。<br>lower_case_table_names&#x3D;1  # 把表名转换成小写<br>secure-file-priv&#x3D;&quot;C:&#x2F;ProgramData&#x2F;MySQL&#x2F;MySQL Server 8.0&#x2F;Uploads&quot;  # 导入导出数据的目录地址<br>max_connections&#x3D;151  # 最大连接客户端数量<br>thread_cache_size&#x3D;10  # 线程数量<br>......<br>暂时列出这么多<br></code></pre></td></tr></table></figure><h2 id="数据库表的创建">数据库表的创建</h2><h3 id="什么是-sql-语言">什么是 SQL 语言？</h3><ul><li>SQL 结构化查询语言(Structured Query Language)，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。</li></ul><h3 id="sql-语言分类">SQL 语言分类</h3><ul><li><p><strong>DML</strong>：添加，修改，删除，查询</p></li><li><strong>DCL</strong>：用户，权限，十五</li><li><p><strong>DDL</strong>：逻辑库，数据表，视图，索引</p></li></ul><h3 id="sql-语句注意事项">SQL 语句注意事项</h3><ul><li>SQL 语句不区分大小写，但是字符串区分大小写</li><li>SQL 语句必须以分号结尾</li><li>SQL 语句中的空白和换行没有限制，但是不能破坏语法</li></ul><h3 id="sql-语句的注释">SQL 语句的注释</h3><p>SQL 语句的注释有两种：</p><ul><li><code># 这是一句注释文字</code></li><li><code>/*这是一段注释文字*/</code></li></ul><h3 id="创建数据库">创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABSE 数据库名称;  # 创建库，最好用英文名称<br>SHOW DATABASES;  # 查看<br>DROP DATABASE 数据库名称;  # 删除<br></code></pre></td></tr></table></figure><h3 id="创建数据表">创建数据表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 数据表(<br>列名1 数据类型 [约束] [COMMENT 注释],<br>列名2 数据类型 [约束] [COMMENT 注释],<br>......<br>)[COMMENT &#x3D; 注释];<br></code></pre></td></tr></table></figure><blockquote><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE student(<br>id INT UNSIGNED PRIMARY KEY,<br>name VARCHAR(20) NOT NULL,  # 不定长度<br>    sex CHAR(1) NOT NULL,  # 定长<br>    birthday DATE NOT NULL,  <br>    tel CHAR(11) NOT NULL,<br>    remark VARCHAR(200)<br>);<br></code></pre></td></tr></table></figure></blockquote><h3 id="数据表的其他操作">数据表的其他操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW tables;  # 查看数据表<br>DESC student;  # (Descirbe)查看 student 表情况<br>SHOW CREATE TABLE student;  # 查询建表的sql语句<br>DROP TABLE student;  # 删除这张表(不是这个表内数据)<br></code></pre></td></tr></table></figure><h2 id="不同的数据类型">不同的数据类型</h2><h3 id="数字类型">数字类型</h3><table><thead><tr class="header"><th>类型</th><th>大小</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>TINYINT</td><td>1字节</td><td>小整数</td></tr><tr class="even"><td>SMALLINT</td><td>2字节</td><td>普通整数</td></tr><tr class="odd"><td>MEDIUMINT</td><td>3字节</td><td>普通整数</td></tr><tr class="even"><td>INT</td><td>4字节</td><td>较大整数</td></tr><tr class="odd"><td>BIGINT</td><td>8字节</td><td>大整数</td></tr><tr class="even"><td>FLOAT</td><td>4字节</td><td>单精度浮点数</td></tr><tr class="odd"><td>DOUBLE</td><td>8字节</td><td>双精度浮点数</td></tr><tr class="even"><td>DECIMAL</td><td>------</td><td>（ 精确的数）DECIMAL(10, 2)（总的位数，精确到小数点后几位）</td></tr></tbody></table><blockquote><ul><li>十进制的浮点数无法在计算机中用二进制精确表达。</li></ul><p>因为整数位的数可以用二进制表达， <span class="math inline">\(1, 2, 4, 8...\)</span>，奇数和偶数都可以用二进制表示。但是小数位不行。如下图所示，小数位是 <span class="math inline">\(\frac{1}{2},\frac{1}{4},\frac{1}{8}...\)</span> ，无法组成想要的小数，只能说是无限逼近。所以浮点数会丢失精度。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210206165425849.png" alt="pokeman-parameters" style="width:30%;"/></center><p>所以有了 DECIMAL ，它原理是转成字符串存储，所以不会有精度丢失的问题。</p></blockquote><h3 id="字符串类型">字符串类型</h3><table><thead><tr class="header"><th>类型</th><th>大小</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>CHAR</td><td>1-255字符</td><td>固定长度字符串</td></tr><tr class="even"><td>VARCHAR</td><td>1-65535字符</td><td>不固定长度字符串</td></tr><tr class="odd"><td>TEXT</td><td>1-65535字符</td><td>不确定长度字符串</td></tr><tr class="even"><td>MEDIUMTEXT</td><td>1-16,000,000字符</td><td>不确定长度字符串</td></tr><tr class="odd"><td>LONGTEXT</td><td>1-42亿字符</td><td>不确定长度字符串</td></tr></tbody></table><blockquote><p>1、 char长度固定， 即每条数据占用等长字节空间；适合用在身份证号码、手机号码等定。</p><p>2、 varchar可变长度，可以设置最大长度；适合用在长度可变的属性。</p><p>3、 text不设置长度， 当不知道属性的最大长度时，适合用text。</p><p>按照查询速度： char最快， varchar次之，text最慢。</p></blockquote><h3 id="日期类型">日期类型</h3><table><thead><tr class="header"><th>类型</th><th>大小</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>DATE</td><td>3字节</td><td>日期</td></tr><tr class="even"><td>TIME</td><td>3字节</td><td>时间</td></tr><tr class="odd"><td>YEAR</td><td>1字节</td><td>年份</td></tr><tr class="even"><td>DATETIME</td><td>8字节</td><td>时间日期</td></tr><tr class="odd"><td>TIMESTAMP</td><td>4字节</td><td>时间戳</td></tr></tbody></table><h2 id="ddl数据定义语言修改表结构">DDL：数据定义语言(修改表结构)</h2><p>DDL 语句包括动词 CREATE 和 DROP。在数据库中创建新表或删除表（CREATE TABLE 或 DROP TABLE）；为表加入索引等。DDL 包括许多与人数据库目录中获得数据有关的保留字。</p><h3 id="添加字段">添加字段</h3><p><code>ADD</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名称<br>ADD 列1 数据类型 [约束] [COMMENT 注释],<br>ADD 列2 数据类型 [约束] [COMMENT 注释],<br>......;<br></code></pre></td></tr></table></figure><h3 id="修改字段">修改字段</h3><p><code>MODIFY</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名称<br>MODIFY 列1 数据类型 [约束] [COMMENT 注释],<br>MODIFY 列2 数据类型 [约束] [COMMENT 注释],<br>......;<br></code></pre></td></tr></table></figure><h3 id="修改字段名称">修改字段名称</h3><p><code>CHANGE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名称<br>CHANGE 列1 新列1 数据类型 [约束] [COMMENT 注释],<br>CHANGE 列2 新列2 数据类型 [约束] [COMMENT 注释],<br>......;<br></code></pre></td></tr></table></figure><h3 id="删除字段">删除字段</h3><p><code>DROP</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名称<br>DROP 列1,<br>DROP 列2,<br>......;<br></code></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE student<br>ADD address VARCHAR(200) NOT NULL,<br>ADD home_tel CHAR(11) NOT NULL;<br><br>ALTER TABLE student<br>MODIFY home_tel VARCHAR(20) NOT NULL;<br><br>ALTER TABLE student<br>CHANGE address home_address VARCHAR(200) NOT NULL;<br><br>ALTER TABLE student<br>DROP home_address,<br>DROP home_tel;<br><br>DESC student;<br></code></pre></td></tr></table></figure><blockquote><p>注意分号和逗号是英文的，不要写成中文的，仔细检查。</p></blockquote><h3 id="数据库的范式">数据库的范式</h3><ul><li><p>在数据库设计中，不合理的设计会导致数据冗余、操作异常，比如更新异常、插入异常、删除异常。这些都是由于不合理的数据依赖导致的，范式理论的出现为了解决不合理的数据依赖，是数据库设计规范化。</p><p>在设计数据库时，为了使其冗余较小、结构合理，设计数据库时必须遵循一定的规则。在关系型数据库中，这种规则被称为范式。范数是符合某一设计规则的总结。</p></li><li><p>目前关系数据库一共有6种范式，一般情况下，只满足第三范式即可。</p></li></ul><p>先总结一些关系数据库术语：</p><ul><li><strong>关系&lt;---&gt;表</strong></li><li><strong>元组&lt;---&gt;行</strong></li><li><strong>属性&lt;---&gt;列：</strong>一个实体的多种方面的信息，称为属性</li><li>域：每一个属性有一定的取值范围，称为域；原子数据【不可再分】</li><li><strong>关系模式</strong>：关系名（属性1，属性2，...，属性n）。</li><li><strong>候选键</strong>：如果一个属性组能<u>唯一标识元组，且又不含有多余的属性</u>，那么这个属性组成为关系的候选键。</li><li><strong>主键</strong>：当一个关系有多个候选键时，可以选出一个作为主键。</li><li><strong>主属性</strong>：包含在任意候选键中的属性</li><li><strong>非主属性</strong>：不包含在候选键中的属性</li><li><strong>外键</strong>：如果关系模式R中的属性K是其他关系模式的主键，则说K是关系模式R的外键</li></ul><h4 id="第一范式">第一范式</h4><ul><li>1NF：<strong>数据库的每一列都是不可分割的基本数据项</strong>，同一列中不能有多个值，也不能存在重复的属性。</li><li>第一范式是数据库的基本要求，不满足这一点就不是关系数据库</li></ul><p>例：</p><p>这个就不符合第一范式。</p><table><thead><tr class="header"><th>学号</th><th>姓名</th><th>班级</th></tr></thead><tbody><tr class="odd"><td>1000</td><td>小明</td><td>高三年级2班</td></tr></tbody></table><p>这个就符合第一范式。</p><table><thead><tr class="header"><th>学号</th><th>姓名</th><th>年级</th><th>班级</th></tr></thead><tbody><tr class="odd"><td>1000</td><td>小明</td><td>高三年级</td><td>2班</td></tr></tbody></table><h4 id="第二范式">第二范式</h4><ul><li>2NF：<strong>在1NF的基础上消除了非主属性对候选键的部分依赖</strong>（每一个非主属性都完全依赖于候选键）</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210206215652460.png" alt="pokeman-parameters" style="width:60%;"/></center><h4 id="第三范式">第三范式</h4><ul><li>3NF：<strong>在2NF的基础上消除了非主属性对候选键的传递依赖</strong></li><li>每列都与主键有直接关系，符合第二范式，且<strong>不存在传递依赖</strong>。</li></ul><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210206215821731.png" alt="pokeman-parameters" style="width:60%;"/></center><p>例：</p><p>这样就不符合第三范式。</p><table><thead><tr class="header"><th>爸爸</th><th>儿子</th><th>女儿</th><th>女儿的玩具</th><th>女儿的衣服</th></tr></thead><tbody><tr class="odd"><td>夏东海</td><td>小雨</td><td>小雪</td><td>天文望远镜</td><td>校服</td></tr></tbody></table><p>改成这样就符合第三范式。</p><table><thead><tr class="header"><th>爸爸</th><th>儿子</th><th>女儿</th></tr></thead><tbody><tr class="odd"><td>夏东海</td><td>小雨</td><td>小雪</td></tr></tbody></table><table><thead><tr class="header"><th>女儿</th><th>女儿的玩具</th><th>女儿的衣服</th></tr></thead><tbody><tr class="odd"><td>小雪</td><td>天文望远镜</td><td>校服</td></tr></tbody></table><blockquote><p><strong>BCNF</strong>：在3NF的基础上消除了<strong>主属性</strong>对候选键的部分依赖和传递依赖。</p></blockquote><h3 id="mysql-中的字段约束">MySQL 中的字段约束</h3><p>MySQL 中的字段约束共有4种：</p><table><thead><tr class="header"><th>约束名称</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>主键约束</td><td>PRIMARY KEY</td><td>字段值唯一，且不能为NULL</td></tr><tr class="even"><td>非空约束</td><td>NOT NULL</td><td>字段值不能为NULL</td></tr><tr class="odd"><td>唯一约束</td><td>UNIQUE</td><td>字段值唯一，且可以为NULL</td></tr><tr class="even"><td>外键约束</td><td>FOREIGN KEY</td><td>保持关联数据的逻辑性</td></tr></tbody></table><h4 id="主键约束-primary-key">主键约束 PRIMARY KEY</h4><ul><li><p>主键约束要求字段的值在全表必须唯一，而且不能为NULL值。</p></li><li><p>建议主键一定要使用数字类型，因为数字的检索速度会非常快</p><ul><li><p>如果主键是数字类型，还可以设置自动增长</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t_teacher(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>    ......<br>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="非空约束-not-null">非空约束 NOT NULL</h4><ul><li>非空约束要求字段的值不能为NULL值</li><li>NULL值以为没有值，而不是 “” 空字符串。(给默认值)</li></ul><h4 id="唯一约束-unique">唯一约束 UNIQUE</h4><ul><li>唯一约束要求字段的值如果不为NULL，那么在全表必须唯一</li></ul><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t_teacher(<br>id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,<br>name VARCHAR(20) NOT NULL,<br>tel CHAR(11) NOT NULL UNIQUE,<br>married BOOLEAN NOT NULL DEFAULT FALSE<br>);<br></code></pre></td></tr></table></figure><h4 id="外键约束-foreign-key">外键约束 FOREIGN KEY</h4><ul><li>外键约束的定义是写在子表上的</li></ul><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t_dept(<br>deptno INT UNSIGNED PRIMARY KEY,<br>dname VARCHAR(20) NOT NULL UNIQUE,<br>tel CHAR(4) UNIQUE<br>);<br><br>CREATE TABLE t_emp(<br>empno INT UNSIGNED PRIMARY KEY,<br>ename VARCHAR(20) NOT NULL,<br>sex ENUM(&quot;男&quot;,&quot;女&quot;) NOT NULL,<br>deptno INT UNSIGNED NOT NULL,<br>hiredate DATE NOT NULL,<br>FOREIGN KEY (deptno) REFERENCES t_dept(deptno)<br>);<br></code></pre></td></tr></table></figure><blockquote><p>外键约束的闭环问题：如果形成外键闭环，我们将无法删除任何一张表的记录。所以一般情况下，不用外键约束。</p></blockquote><h3 id="索引">索引</h3><p>MYSQL 利用二叉树结构，对数据表的记录排序，从而加速数据的检索速度。</p><p>什么时候使用索引？</p><ul><li>数据量很大，而且经常被查询的数据表可以设置索引</li><li>索引只添加在经常被用作索引条件的字段上</li><li>不要在长度较长的字段上创建索引（比如很长的字符串，索引还要排序）</li></ul><h4 id="创建索引">创建索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE (<br>  ......,  # 声明字段<br>  INDEX [索引名称] (字段)，<br>  ......<br>);<br></code></pre></td></tr></table></figure><h4 id="已存在的表添加与删除索引">(已存在的表)添加与删除索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX 索引名称 ON 表名(字段);<br>ALTER TABLE 表名称 ADD INDEX [索引名](字段);<br>SHOW INDEX FROM 表名;  # 查看数据表设置的索引<br>DROP INDEX 索引名称 ON 表名;  # 删掉索引<br></code></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t_message(<br>id INT UNSIGNED PRIMARY KEY,<br>content VARCHAR(200) NOT NULL,<br>type ENUM(&quot;公告&quot;, &quot;通告&quot;, &quot;个人通知&quot;) NOT NULL,<br>create_time TIMESTAMP NOT NULL,<br>INDEX idx_type(type) <br>);<br><br>DROP INDEX idx_type ON t_message;<br><br>CREATE INDEX idx_type ON t_message(type);<br>SHOW INDEX FROM t_message;<br><br>ALTER TABLE t_message ADD INDEX idx_type(type);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python正则表达式</title>
    <link href="/2021/01/31/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/01/31/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了有关 Python 正则表达式的相关操作。</p><p><em><a id="more"></a></em></p><hr /><h2 id="正则表达式">正则表达式</h2><p>正则表达式：是一个特殊的字符序列，便于检查一个字符串是否与某种模式匹配。</p><p>匹配字符串的需要条件：</p><ul><li>正则表达式模块：<code>re</code></li><li>匹配字符串的规则</li><li>字符串</li></ul><h2 id="匹配字符">匹配字符</h2><p>在此列出一些正则表达式中的常见的特殊字符</p><table><thead><tr class="header"><th>特殊字符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>.</code></td><td>通配符。匹配任意字符（不包括换行符）</td></tr><tr class="even"><td><code>^</code></td><td>匹配开始位置，多行模式下匹配每一行的开始</td></tr><tr class="odd"><td><code>\A</code></td><td>匹配字符串开始位置，忽略多行模式</td></tr><tr class="even"><td><code>\Z</code></td><td>匹配字符串结束位置，忽略多行模式</td></tr><tr class="odd"><td><code>\d</code></td><td>匹配一个数字， 相当于 [0-9]</td></tr><tr class="even"><td><code>\D</code></td><td>匹配非数字,相当于 [^0-9]</td></tr><tr class="odd"><td><code>\w</code></td><td>匹配数字、字母、下划线中任意一个字符， 相当于 [a-zA-Z0-9_]</td></tr><tr class="even"><td><code>\W</code></td><td>匹配非数字、字母、下划线中的任意字符，相当于 [^a-zA-Z0-9_]</td></tr><tr class="odd"><td><code>\s</code></td><td>匹配任意空白字符， 相当于 [ </td></tr><tr class="even"><td><code>\S</code></td><td>匹配非空白字符，相当于 [^ </td></tr></tbody></table><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">had_number</span>(<span class="hljs-params">data</span>):</span><br>    result = re.findall(<span class="hljs-string">&#x27;\d&#x27;</span>, data)<br>    print(result)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:  <span class="hljs-comment"># 如果有数字，列表就不为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_number</span>(<span class="hljs-params">data</span>):</span><br>    result = re.findall(<span class="hljs-string">&#x27;\D&#x27;</span>, data)  <span class="hljs-comment"># \D 匹配非数字</span><br>    print(result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(result)  <span class="hljs-comment"># 将列表转为字符串</span><br><br><span class="hljs-comment"># 判断data是否以sub开头</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startswith</span>(<span class="hljs-params">sub, data</span>):</span><br>    _sub = <span class="hljs-string">&#x27;\A%s&#x27;</span> % sub<br>    result = re.findall(_sub, data)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 判断data是否以sub结尾</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">endswith</span>(<span class="hljs-params">sub, data</span>):</span><br>    _sub = <span class="hljs-string">&#x27;%s\Z&#x27;</span> % sub<br>    result = re.findall(_sub, data)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 判断真实字符长度</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">real_len</span>(<span class="hljs-params">data</span>):</span>  <br>    result = re.findall(<span class="hljs-string">&#x27;\S&#x27;</span>, data)<br>    print(result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(result)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    data = <span class="hljs-string">&#x27;i am xiaoming, i am 21&#x27;</span><br>    result = had_number(data)<br>    print(result)<br>    result = remove_number(data)<br>    print(result)<br><br>    data = <span class="hljs-string">&#x27;hello xiaoming, i am xiaohong, i am 22 year\&#x27;s old&#x27;</span><br>    print(re.findall(<span class="hljs-string">&#x27;\W&#x27;</span>, data))<br><br>    result = startswith(<span class="hljs-string">&#x27;shell&#x27;</span>, data)<br>    print(result)<br><br>    result = endswith(<span class="hljs-string">&#x27; old&#x27;</span>, data)<br>    print(result)<br>    print(<span class="hljs-built_in">len</span>(data))<br><br>    result = real_len(data)<br>    print(result)<br>    <br>-------------------------------------------------------------------<br>[<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>]<br><span class="hljs-literal">True</span><br>[<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>]<br>i am xiaoming, i am <br>[<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27; &#x27;</span>]<br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-number">49</span><br>[<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><h2 id="量词符号与组">量词符号与组</h2><h3 id="正则表达式中的符号">正则表达式中的符号</h3><table><thead><tr class="header"><th>特殊字符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>re1|re2</code></td><td>匹配正则表达式 re1 或 re2</td></tr><tr class="even"><td><code>^</code></td><td>匹配字符串起始部分</td></tr><tr class="odd"><td><code>$</code></td><td>匹配字符串终止部分</td></tr><tr class="even"><td><code>*</code></td><td>匹配 0 次 或者多次前面出现的正则表达式</td></tr><tr class="odd"><td><code>+</code></td><td>匹配 1 次 或者多次前面出现的正则表达式</td></tr><tr class="even"><td><code>&#123;n&#125;</code></td><td>匹配 n 次 前面出现的正则表达式</td></tr><tr class="odd"><td><code>&#123;m,n&#125;</code></td><td>匹配 m—n 次 前面出现的正则表达式</td></tr><tr class="even"><td><code>[...]</code></td><td>匹配 来自字符集的任意单一字符，<u>{n,m}中间逗号不可以有空格</u></td></tr><tr class="odd"><td><code>[..x-y..]</code></td><td>匹配 x-y范围中的任意单一字符</td></tr><tr class="even"><td><code>[^...]</code></td><td>不匹配此字符集中出现的任何一个字符，包括某一范围的字符（如果在此字符集中出现）</td></tr><tr class="odd"><td><code>\</code></td><td>将特殊字符无效化</td></tr></tbody></table><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">data = <span class="hljs-string">&#x27;xiao@ming.com&#x27;</span><br>print(re.findall(<span class="hljs-string">&#x27;\w*&#x27;</span>, data))  <span class="hljs-comment"># [&#x27;xiao&#x27;, &#x27;&#x27;, &#x27;ming&#x27;, &#x27;&#x27;,com&#x27;]  w* 匹配0次或多次数字字母</span><br>print(re.findall(<span class="hljs-string">&#x27;\w+&#x27;</span>, data))  <span class="hljs-comment"># [&#x27;xiao&#x27;, &#x27;ming&#x27;, &#x27;com&#x27;]        w+ 匹配1次或多次数字字母</span><br>print(re.findall(<span class="hljs-string">&#x27;\w&#123;3&#125;&#x27;</span>, data))  <span class="hljs-comment"># [&#x27;xia&#x27;, &#x27;min&#x27;, &#x27;com&#x27;]</span><br>print(re.findall(<span class="hljs-string">&#x27;\w&#123;1,5&#125;&#x27;</span>, data))  <span class="hljs-comment"># [&#x27;xiao&#x27;, &#x27;ming&#x27;, &#x27;com&#x27;]</span><br>print(re.findall(<span class="hljs-string">&#x27;\w&#123;1, 5&#125;&#x27;</span>, data))  <span class="hljs-comment"># []  &#123;n,m&#125;中间逗号不可以有空格 </span><br>print(re.findall(<span class="hljs-string">&#x27;[^xiao]&#x27;</span>, data))  <span class="hljs-comment"># [&#x27;@&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;g&#x27;, &#x27;.&#x27;, &#x27;c&#x27;, &#x27;m&#x27;]  字符集中的^现在是过滤[]中的字符</span><br></code></pre></td></tr></table></figure><blockquote><p><code>\w = [a-zA-Z0-9_]</code></p></blockquote><h3 id="组">组</h3><table><thead><tr class="header"><th>符号</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>()</code></td><td>在匹配规则中获取指定的数据</td></tr></tbody></table><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = re.search(<span class="hljs-string">&#x27;hello (.*) name is (.*)&#x27;</span>, test)<br>  <br>result.groups()  <span class="hljs-comment"># (&#x27;my&#x27;, &#x27;xiaoming&#x27;)</span><br>result.group(<span class="hljs-number">1</span>)  <span class="hljs-comment"># &#x27;my&#x27;</span><br>result.group(<span class="hljs-number">2</span>)  <span class="hljs-comment"># &#x27;xiaoming&#x27;</span><br></code></pre></td></tr></table></figure><p>小练习：</p><ol type="1"><li><p><code>str = 'i wanna say &quot;*^$^%#@#$%^&quot;'</code> 要匹配 <code>&quot;*^$^%#@#$%^&quot;</code> ，包括两端的双引号，应该怎么写？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">substr = re.search(<span class="hljs-string">&#x27;\&quot;(.*)\&quot;&#x27;</span>, <span class="hljs-built_in">str</span>)<br>substr.groups()<br></code></pre></td></tr></table></figure></li><li><p>匹配 <code>3.1415 9265 3598</code> 小数点后每四位一组，每组建有一个空格，怎么写？</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">^[<span class="hljs-number">3</span>]\.(\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;\s)&#123;<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="贪婪与非贪婪">贪婪与非贪婪</h3><p>在整个表达式匹配成功的前提下，<strong>贪婪模式是尽可能多的匹配</strong>，<strong>非贪婪模式是以最少的匹配字符</strong>，默认情况是<strong>贪婪模式</strong></p><ul><li>0 次 或者多次属于贪婪模式</li><li>通过 <strong>？</strong>组合变成非贪婪模式 （例如：<code>\d+？</code>）</li></ul><p>举个好栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_url</span>(<span class="hljs-params">url</span>):</span><br>    result = re.findall(<span class="hljs-string">&#x27;[a-zA-Z]&#123;4,5&#125;://\w+\.\w+\.\w+&#x27;</span>, url)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_url</span>(<span class="hljs-params">url</span>):</span><br>    result = re.findall(<span class="hljs-string">&#x27;[https://|http://](\w+\.\w+\.\w+)&#x27;</span>, url)  <span class="hljs-comment"># 加[]表示字符集</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) != <span class="hljs-number">0</span> :<br>        <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_email</span>(<span class="hljs-params">email</span>):</span><br>    result = re.findall(<span class="hljs-string">&#x27;.+@[0-9a-zA-Z]+\.[a-zA-Z]+&#x27;</span>, email)  <span class="hljs-comment"># &#x27;[0-9a-zA-Z_]+@[0-9a-zA-Z]+\.[a-zA-Z]+&#x27;</span><br>    <span class="hljs-keyword">return</span> result<br><br><br>html = (<span class="hljs-string">&#x27;&lt;div class=&quot;s-top-nav&quot; style=&quot;display:none;&quot;&gt;&#x27;</span><br>        <span class="hljs-string">&#x27;&lt;/div&gt;&lt;div class=&quot;s-center-box&quot;&lt;/div&gt;&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_html_data</span>(<span class="hljs-params">data</span>):</span><br>    result = re.findall(<span class="hljs-string">&#x27;style=&quot;(.*?)&quot;&#x27;</span>, html)  <span class="hljs-comment"># .* 贪婪模式，加个问号改成非贪婪模式</span><br>    <span class="hljs-keyword">return</span> result<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_data_html</span>(<span class="hljs-params">html</span>):</span><br>    result = re.findall(<span class="hljs-string">&#x27;=&quot;(.*?)&quot;&#x27;</span>, html)<br>    <span class="hljs-keyword">return</span> result<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    result = check_url(<span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>)<br>    print(result)<br>    result = get_url(<span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>)<br>    print(result)<br>    result = get_url(<span class="hljs-string">&#x27;http://www.baidu.com/&#x27;</span>)<br>    print(result)<br>    result = get_email(<span class="hljs-string">&#x27;xiao@ming.com&#x27;</span>)<br>    print(result)<br>    result = get_html_data(html)<br>    print(result)<br>    result = get_all_data_html(html)<br>    print(result)<br>    <br>-----------------------------------------------------------------<br><span class="hljs-literal">True</span><br>www.baidu.com<br>www.baidu.com<br>[<span class="hljs-string">&#x27;xiao@ming.com&#x27;</span>]<br>[<span class="hljs-string">&#x27;display:none;&#x27;</span>]<br>[<span class="hljs-string">&#x27;s-top-nav&#x27;</span>, <span class="hljs-string">&#x27;display:none;&#x27;</span>, <span class="hljs-string">&#x27;s-center-box&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="re-模块的常用函数"><code>re</code> 模块的常用函数</h2><h4 id="findall"><code>findall()</code></h4><p><code>findall(pattern, string, [, flags])</code> ：查找字符串中所有（非重复）出现的正则表达式模式，并返回一个匹配列表</p><ul><li><code>pattern</code> ：匹配规则</li><li><code>string</code> ：要匹配的字符串</li></ul><h4 id="search"><code>search()</code></h4><p><code>search(pattern, string, flags=0)</code> ：使用可选标记<strong>搜索字符串中第一次出现的正则表达式</strong>。成功，返回<strong>匹配对象，可以用 <code>groups()</code> 获取数据</strong>；失败，返回 None</p><blockquote><p><code>search( )</code> 在 string 中进行搜索，成功返回 Match object , 失败返回 None</p></blockquote><ul><li><code>pattern</code> ：匹配规则</li><li><code>string</code> ：要匹配的字符串</li></ul><h4 id="group-与-groups"><code>group()</code> 与 <code>groups()</code></h4><p><code>group(num)</code> ：返回整个匹配对象，或者编号为num的特定子组</p><p><code>groups(num)</code> ：返回一个包含所有匹配子组的元组（匹配失败则返回空元组）</p><h4 id="split"><code>split()</code></h4><p><code>split(pattern, string, max=0)</code> ：根据正则表达式的模式格式符，<code>split</code> 函数将字符串分割为列表，然后返回成功匹配的列表，分割最多操作 max 次（默认分割所有匹配成功的位置）</p><ul><li><code>max=0</code> ：默认为0，匹配到所有能匹配的信息</li></ul><p>栗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">data = <span class="hljs-string">&#x27;hello world&#x27;</span><br>print(re.split(<span class="hljs-string">&#x27;\W&#x27;</span>, data))  <span class="hljs-comment"># [&#x27;hello&#x27;, &#x27;world&#x27;]</span><br></code></pre></td></tr></table></figure><h4 id="match"><code>match()</code></h4><p><code>match(pattern, string, flags=0)</code> ：尝试使用带有可选的标记的正则表达式的模式<strong>从头匹配字符串</strong>。成功，返回匹配对象；失败，就返回 None。</p><blockquote><p><code>match()</code> 用来匹配 string 开头，成功返回 Match object , 失败返回 None</p></blockquote><p>栗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">data = <span class="hljs-string">&#x27;hello world&#x27;</span><br>result = re.match(<span class="hljs-string">&#x27;hello&#x27;</span>, data)<br>result.group()  <span class="hljs-comment"># &#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><p>小练习：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;OH&quot;</span>, re.I)<br>rest = pattern.match(<span class="hljs-string">&#x27;oh,ye&#x27;</span>)<br>print(rest.string)<br></code></pre></td></tr></table></figure><blockquote><p>本题考查的是匹配成功对象的 string 属性的用法，匹配成功对象的 string 属性得到的是匹配时使用的字符串，即 oh,ye</p></blockquote><h4 id="compile"><code>compile</code></h4><p><code>compile(pattern, string, flags=0)</code> ：定义一个匹配规则的对象</p><p>栗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">data = <span class="hljs-string">&#x27;hello my email is xiao@ming.com i like python very much yeah yeah&#x27;</span><br>re_obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;email is (.*?) i&#x27;</span>)<br>result = re_obj.findall(data)<br><br>print(result)  <span class="hljs-comment"># [&#x27;xiao@ming.com&#x27;]</span><br></code></pre></td></tr></table></figure><p>举个栗子：对上面的例子用 <code>compile</code> 优化</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_url</span>(<span class="hljs-params">url</span>):</span><br>    re_g = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;[a-zA-Z]&#123;4,5&#125;://\w+\.\w+\.\w+&#x27;</span>)<br>    result = re_g.findall(url)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_url</span>(<span class="hljs-params">url</span>):</span><br>    re_g = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;[https://|http://](\w+\.\w+\.\w+)&#x27;</span>)<br>    result = re_g.findall(url)  <span class="hljs-comment"># 加[]表示字符集</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) != <span class="hljs-number">0</span> :<br>        <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_email</span>(<span class="hljs-params">email</span>):</span><br>    re_g = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;.+@[0-9a-zA-Z]+\.[a-zA-Z]+&#x27;</span>)<br>    result = re_g.findall(email)  <span class="hljs-comment"># &#x27;[0-9a-zA-Z_]+@[0-9a-zA-Z]+\.[a-zA-Z]+&#x27;</span><br>    <span class="hljs-keyword">return</span> result<br><br><br>html = (<span class="hljs-string">&#x27;&lt;div class=&quot;s-top-nav&quot; style=&quot;display:none;&quot;&gt;&#x27;</span><br>        <span class="hljs-string">&#x27;&lt;/div&gt;&lt;div class=&quot;s-center-box&quot;&lt;/div&gt;&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_html_data</span>(<span class="hljs-params">data</span>):</span><br>    re_g = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;style=&quot;(.*?)&quot;&#x27;</span>)<br>    result = re_g.findall(html)  <span class="hljs-comment"># .* 贪婪模式，加个问号改成非贪婪模式</span><br>    <span class="hljs-keyword">return</span> result<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_data_html</span>(<span class="hljs-params">html</span>):</span><br>    re_g = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;=&quot;(.*?)&quot;&#x27;</span>)<br>    result = re_g.findall(html)<br>    <span class="hljs-keyword">return</span> result<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    re_g = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;&lt;div class=&quot;(.*?)&quot; style=&quot;(.*?)&quot;&gt;&#x27;</span><br>        <span class="hljs-string">&#x27;&lt;/div&gt;&lt;div class=&quot;(.*?)&quot;&lt;/div&gt;&#x27;</span>)<br>    result = re_g.search(html)<br>    print(result.groups())<br>    print(result.group(<span class="hljs-number">1</span>))  <span class="hljs-comment"># 角标从1开始，但是内部还是从0数</span><br>    print(result.group(<span class="hljs-number">2</span>))<br>    print(result.group(<span class="hljs-number">3</span>))<br>    <span class="hljs-comment"># print(result.group(4))  # IndexError: no such group</span><br><br>    re_g = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;\W&#x27;</span>)<br>    result = re_g.split(html)<br>    print(result)<br><br>    re_g = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;class=&quot;(.*?)&quot;&#x27;</span>)<br>    result1 = re_g.match(html)<br>    print(result1)  <span class="hljs-comment"># None</span><br><br>    re_g = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;&lt;div class=&quot;(.*?)&quot;&#x27;</span>)<br>    result = re_g.match(html)<br>    print(result)  <span class="hljs-comment"># &lt;re.Match object; span=(0, 22), match=&#x27;&lt;div class=&quot;s-top-nav&quot;&#x27;&gt;</span><br>    print(result.group())  <span class="hljs-comment"># &lt;div class=&quot;s-top-nav&quot;</span><br><br>    print(result.span())  <span class="hljs-comment"># (0, 22)</span><br>    print(html[<span class="hljs-number">0</span>:<span class="hljs-number">22</span>])  <span class="hljs-comment"># &lt;div class=&quot;s-top-nav&quot;</span><br>    <br>-----------------------------------------------------------------<br>(<span class="hljs-string">&#x27;s-top-nav&#x27;</span>, <span class="hljs-string">&#x27;display:none;&#x27;</span>, <span class="hljs-string">&#x27;s-center-box&#x27;</span>)<br>s-top-nav<br>display:none;<br>s-center-box<br>[<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;top&#x27;</span>, <span class="hljs-string">&#x27;nav&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;display&#x27;</span>, <span class="hljs-string">&#x27;none&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;center&#x27;</span>, <span class="hljs-string">&#x27;box&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><span class="hljs-literal">None</span><br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">0</span>, <span class="hljs-number">22</span>), match=<span class="hljs-string">&#x27;&lt;div class=&quot;s-top-nav&quot;&#x27;</span>&gt;<br>&lt;div class=&quot;s-top-nav&quot;<br>(<span class="hljs-number">0</span>, <span class="hljs-number">22</span>)<br>&lt;div class=&quot;s-top-nav&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python多线程编程</title>
    <link href="/2021/01/29/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/01/29/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了 Python 进程与线程编程。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210131020349787.png" alt="pokeman-parameters" style="width:60%;"/></center><p><em><a id="more"></a></em></p><hr /><h1 id="进程">进程</h1><h2 id="进程与多进程">1. 进程与多进程</h2><p>进程是一个“执行中的程序”。进程是系统进行资源分配和调度的基本单位，是操作系统结构的基础。并且进程是线程的容器。</p><p>（动态的，代码加所需的资源 = 进程）</p><blockquote><ul><li>进程是动态的，程序是静态的</li><li>进程是暂时的，进程是永久的</li><li>进程与程序的组成不同<ul><li>进程是竞争计算机资源的基本单位</li><li>程序是一组有序的指令集合</li></ul></li></ul></blockquote><p>进程的状态有：</p><ul><li>就绪态：运行的条件都满足，就等CPU执行<br /></li><li>执行态：CPU正在执行的<br /></li><li>等待态：等待某些条件满足，例如等待消息回复，等待同步锁等</li></ul><blockquote><p>多进程类似程序的多开，比如qq的多开。</p></blockquote><h2 id="进程的创建">2. 进程的创建</h2><h3 id="进程的模块-multiprocessing">进程的模块 <code>multiprocessing</code></h3><p>进程的创建方法一：</p><p>1.通过multiprocessing模块创建子进程</p><ol type="1"><li>导入模块multiprocessing<br /></li><li>准备任务函数（用来编写进程代码）<br /></li><li>由multiprocessing模块的Process创建子进程<br /></li><li>执行子进程</li></ol><ul><li>创建进程的函数：</li></ul><table><thead><tr class="header"><th>函数名</th><th>介绍</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>Process(target, args)</code></td><td>创建一个进程</td><td><code>target, args</code></td><td>进程对象</td></tr></tbody></table><ul><li>执行进程的相关函数：</li></ul><table><thead><tr class="header"><th>函数名</th><th>介绍</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>start</code></td><td>执行进程</td><td>无</td><td>无</td></tr><tr class="even"><td><code>join</code></td><td>阻塞进程</td><td>无</td><td>无</td></tr><tr class="odd"><td><code>kill</code></td><td>杀死进程</td><td>无</td><td>无</td></tr><tr class="even"><td><code>is_alive</code></td><td>进程是否存活</td><td>无</td><td>bool</td></tr></tbody></table><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> multiprocessing<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work_a</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        print(i, <span class="hljs-string">&#x27;a&#x27;</span>, os.getpid())<br>        time.sleep(<span class="hljs-number">0.5</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work_b</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        print(i, <span class="hljs-string">&#x27;b&#x27;</span>, os.getpid())<br>        time.sleep(<span class="hljs-number">0.5</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    start = time.time()  <span class="hljs-comment"># 主进程</span><br>    a_p = multiprocessing.Process(target=work_a)  <span class="hljs-comment"># 子进程1</span><br>    <span class="hljs-comment"># a_p.start()  # 子进程1执行</span><br>    b_p = multiprocessing.Process(target=work_b)  <span class="hljs-comment"># 子进程2</span><br>    <span class="hljs-comment"># b_p.start()  # 子进程2执行</span><br><br>    <span class="hljs-comment"># 多进程的执行</span><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (a_p, b_p):<br>        p.start()<br><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (a_p, b_p):<br>        p.join()<br><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> (a_p, b_p):<br>        print(p.is_alive())<br><br>    end = time.time()  <span class="hljs-comment"># 主进程</span><br>    print(<span class="hljs-string">&#x27;时间的消耗是:&#x27;</span>, end-start)<br>    print(<span class="hljs-string">&#x27;parent pid i %s&#x27;</span> % os.getpid())<br></code></pre></td></tr></table></figure><p><strong>多进程的问题</strong></p><ul><li>通过进程模块执行的函数无法获取返回值----<u>进程间如何通信</u>：<strong>通过队列</strong></li><li><p>多个进程同时修改文件可能会出现错误----<u>进程间如何避免资源抢占</u>：<strong>创建进程锁</strong></p></li><li><p>进程数量太多可能会造成资源不足，甚至死机等情况----<u>如何避免创建进程数量过多</u>：<strong>创建进程池</strong></p></li></ul><h2 id="进程池与进程锁">3. 进程池与进程锁</h2><h3 id="进程池">进程池</h3><ul><li>什么是池？</li></ul><p>答：由于服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其运行效率。这就是池的概念。</p><p>池是一组资源的集合，这组资源在服务器启动之初就完全被创建并初始化，这称为静态资源分配。当服务器进入正是运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无需动态分配。很显然，直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的系统调用都是很耗时的。</p><p>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用来释放资源。从最终效果来看，池相当于服务器管理系统资源的应用设施，它避免了服务器对内核的频繁访问。</p><ul><li>进程池</li></ul><p>进程池指当需要在创建多个子进程时，创建一个进程池用来构建更多的子进程。进程池可以控制进程的数量，重复利用进程对象，减少创建和销毁过程的开销。</p><blockquote><p>进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、 PGID 等。当有新的任务来到时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在的子进程的代价显得小得多。</p></blockquote><p>至于主进程选择哪个子进程来为新任务服务，则有两种方法：</p><ol type="1"><li><p>主进程使用某种算法来主动选择子进程。 最简单、最常用的算法是随机算法和 Round Robin （轮流算法）。</p></li><li><p>主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠在工作队列上。</p></li></ol><p>当选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方式是，在父进程和子进程之间预先建立好一条管道，然后通过管道来实现所有的进程间通信。在父线程和子线程之间传递数据就要简单得多，因为我们可以把这些数据定义为全局，那么它们本身就是被所有线程共享的。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210129210616113.png" alt="进程池模型" /><figcaption>进程池模型</figcaption></figure><p>进程的创建方法二-进程池POOL：</p><p>​</p><h4 id="进程池的创建-multiprocessing">进程池的创建 <code>multiprocessing</code></h4><ul><li>创建进程池</li></ul><table><thead><tr class="header"><th>函数名</th><th>介绍</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>Pool(Processcount)</code></td><td>创建进程池</td><td><code>Processcount</code></td><td>进程对象</td></tr></tbody></table><ul><li>执行进程池的相关函数：</li></ul><table><thead><tr class="header"><th>函数名</th><th>介绍</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>apply_async(func, args)</code></td><td>任务加入进程池（异步）</td><td><code>func, args</code></td><td>无</td></tr><tr class="even"><td><code>close</code></td><td>关闭进程池，不再接收新的任务请求</td><td>无</td><td>无</td></tr><tr class="odd"><td><code>join</code></td><td>阻塞主进程，直到进程池中的子进程执行完毕</td><td>无</td><td>无</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> multiprocessing<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">count</span>):</span><br>    print(count, os.getpid())<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is %s, pid is %s&#x27;</span> % (count, os.getpid())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = multiprocessing.Pool(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 主进程1</span><br><br>    results = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        result = pool.apply_async(func=work, args=(i, ))  <span class="hljs-comment"># 主进程2</span><br>        results.append(result)<br><br>    <span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> results:<br>        print(res.get())<br><br>    print(<span class="hljs-string">&#x27;end&#x27;</span>)<br>    <span class="hljs-comment"># time.sleep(20)  # 主进程。写阻塞是因为主进程2完成太快了</span><br><br>    <span class="hljs-comment"># 保证进程池中的任务都完成，再结束</span><br>    pool.close()<br>    pool.join()<br></code></pre></td></tr></table></figure><h3 id="进程锁">进程锁</h3><p>锁，保证一个线程或进程在对共享对象进行修改时，其他的线程或进程无法访问这个对象，直至获取锁的线程的操作执行完毕后释放锁。所以，锁在多线程和多进程中起到一个同步的作用，以保护每个线程和进程必要操作的完整执行。</p><h4 id="进程锁的加锁与解锁">进程锁的加锁与解锁</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Manager<br>manage = Manage()<br>lock = manage.Lock()<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>函数名</th><th>介绍</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>acquire</code></td><td>上锁</td><td>无</td><td>无v</td></tr><tr class="even"><td><code>release</code></td><td>解锁</td><td>无</td><td>无</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> multiprocessing<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">count, lock</span>):</span><br>    lock.acquire()  <span class="hljs-comment"># 上锁</span><br>    print(count, os.getpid())<br>    time.sleep(<span class="hljs-number">2</span>)<br>    lock.release()  <span class="hljs-comment"># 开锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is %s, pid is %s&#x27;</span> % (count, os.getpid())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = multiprocessing.Pool(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 主进程1</span><br>    manager = multiprocessing.Manager()<br>    lock = manager.Lock()<br><br>    results = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        result = pool.apply_async(func=work, args=(i, lock))  <span class="hljs-comment"># 主进程2</span><br>        <br>    pool.close()<br>    pool.join()<br><br></code></pre></td></tr></table></figure><blockquote><p>就变成一个进程一个进程执行。</p></blockquote><h2 id="进程间的通信">4. 进程间的通信</h2><p>python提供了多种进程通信的方式，主要 Queue 和 Pipe 这两种方式，Queue 用于多个进程间实现通信，Pipe 是两个进程的通信</p><h3 id="队列的创建-multiprocessing">队列的创建 <code>multiprocessing</code></h3><table><thead><tr class="header"><th>函数名</th><th>介绍</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>Queue(mac_count)</code></td><td>创建队列</td><td><code>mac_count</code></td><td>队列对象</td></tr></tbody></table><ul><li>执行队列的相关函数：</li></ul><table><thead><tr class="header"><th>函数名</th><th>介绍</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>put</code></td><td>信息放入队列</td><td>message</td><td>无</td></tr><tr class="even"><td><code>get</code></td><td>获取队列信息</td><td>无</td><td>str</td></tr></tbody></table><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> multiprocessing<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, q</span>):</span><br>        self.q = q<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, message</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(message, <span class="hljs-built_in">str</span>):<br>            message = json.dumps(message)  <span class="hljs-comment"># json序列化</span><br>        self.q.put(message)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_all</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>            self.q.put(i)<br>            time.sleep(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            result = self.q.get()<br>            <span class="hljs-keyword">try</span>:<br>                res = json.loads(result)<br>            <span class="hljs-comment"># 如果不是json类型字符串</span><br>            <span class="hljs-keyword">except</span>:<br>                res = result  <span class="hljs-comment"># &#x27;abc..&#x27;</span><br>            print(<span class="hljs-string">&#x27;recv is %s &#x27;</span> % res)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    q = multiprocessing.Queue()<br>    work = Work(q)<br>    send = multiprocessing.Process(target=work.send, args=(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>&#125;,) )<br>    recv = multiprocessing.Process(target=work.receive)<br>    send_all_p = multiprocessing.Process(target=work.send_all)<br><br>    send_all_p.start()<br>    send.start()<br>    recv.start()<br><br>    send_all_p.join()  <span class="hljs-comment"># recv.join() receive是无限循环，程序会永远执行没有结束，造成程序一直阻塞。所以程序不会终止</span><br>    recv.terminate()<br></code></pre></td></tr></table></figure><h1 id="线程">线程</h1><h2 id="线程与多线程">1. 线程与多线程</h2><p>线程：“轻量级进程”。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p><ul><li><p>线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p></li><li><p>一个线程可以创建和撤消另一个线程。</p></li><li><p>同一进程中的多个线程之间可以并发执行。</p></li><li><p>进程之间不能共享内存，但线程之间可以共享内存。</p></li></ul><blockquote><p>引自操作系统笔记。</p></blockquote><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828095244971.png" alt="image-20200828095244971" /><figcaption>image-20200828095244971</figcaption></figure><h2 id="线程的创建">2. 线程的创建</h2><h3 id="线程的模块-threading">线程的模块 <code>threading</code></h3><table><thead><tr class="header"><th>函数名</th><th>说明</th><th>用法</th></tr></thead><tbody><tr class="odd"><td><code>start</code></td><td>启动线程</td><td><code>mac_count</code></td></tr><tr class="even"><td><code>join</code></td><td>阻塞直到线程执行结束</td><td><code>join(timeout=None)</code></td></tr><tr class="odd"><td><code>getName</code></td><td>获取线程的名称</td><td><code>getName()</code></td></tr><tr class="even"><td><code>setName</code></td><td>设置线程的名称</td><td><code>setName(name)</code></td></tr><tr class="odd"><td><code>is_alive</code></td><td>判断线程是否存活</td><td><code>is_alive()</code></td></tr><tr class="even"><td><code>setDaemon</code></td><td>守护线程</td><td><code>setDaemon(True)</code></td></tr></tbody></table><blockquote><ul><li>什么是守护进程？ .</li></ul><p>主要做与业务无关的任务，无关紧要的任务，比如内存垃圾回收，计时等。也就说当子进程是守护进程时，主进程结束后会发送一个消息给子进程，子进程收到后立即结束，主进程不会等待守护进程执行完在结束，因为守护进程是无关紧要的一些进程。一般情况下，主进程创建的是非守护进程</p></blockquote><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> threading<br><br>lists = [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;flask&#x27;</span>, <span class="hljs-string">&#x27;django&#x27;</span>, <span class="hljs-string">&#x27;requests&#x27;</span>,<br>         <span class="hljs-string">&#x27;tornado&#x27;</span>, <span class="hljs-string">&#x27;bs5&#x27;</span>, <span class="hljs-string">&#x27;uvloop&#x27;</span>]<br><br>new_lists = []<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>():</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lists) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br>    data = random.choice(lists)  <span class="hljs-comment"># 随机获取列表元素</span><br>    lists.remove(data)<br>    new_data = <span class="hljs-string">&#x27;%s_new&#x27;</span> % data<br>    new_lists.append(new_data)<br>    print(<span class="hljs-string">&#x27;%s已经被添加至new_lists中...&#x27;</span> % new_data)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    start = time.time()<br>    print(<span class="hljs-string">&#x27;old lists len:&#x27;</span>, <span class="hljs-built_in">len</span>(lists))<br>    t_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lists)):<br>        t = threading.Thread(target=work)<br>        t_list.append(t)<br>        t.start()<br><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> t_list:<br>        t.join()<br><br>    print(<span class="hljs-string">&#x27;old lists:&#x27;</span>, lists )<br>    print(<span class="hljs-string">&#x27;new lists %s , len is %s&#x27;</span> % (new_lists, <span class="hljs-built_in">len</span>(new_lists)))<br>    end = time.time()<br>    print(<span class="hljs-string">&#x27;time is&#x27;</span>, end - start)<br>    <br>------------------------------------------------------------------------<br>old lists <span class="hljs-built_in">len</span>: <span class="hljs-number">7</span><br>flask_new已经被添加至new_lists中...<br>requests_new已经被添加至new_lists中...<br>django_new已经被添加至new_lists中...<br>uvloop_new已经被添加至new_lists中...<br>tornado_new已经被添加至new_lists中...<br>bs5_new已经被添加至new_lists中...<br>python_new已经被添加至new_lists中...<br>old lists: []<br>new lists [<span class="hljs-string">&#x27;flask_new&#x27;</span>, <span class="hljs-string">&#x27;requests_new&#x27;</span>, <span class="hljs-string">&#x27;django_new&#x27;</span>, <span class="hljs-string">&#x27;uvloop_new&#x27;</span>, <span class="hljs-string">&#x27;tornado_new&#x27;</span>, <span class="hljs-string">&#x27;bs5_new&#x27;</span>, <span class="hljs-string">&#x27;python_new&#x27;</span>] , <span class="hljs-built_in">len</span> <span class="hljs-keyword">is</span> <span class="hljs-number">7</span><br>time <span class="hljs-keyword">is</span> <span class="hljs-number">1.0029313564300537</span><br></code></pre></td></tr></table></figure><p><strong>线程的问题：</strong></p><ol type="1"><li>通过线程执行的函数无法获取返回值----线程间如何通信：<strong>通过队列</strong></li><li>多个线程同时修改文件可能造成数据错乱----线程间如何避免资源抢占：<strong>创建线程锁</strong></li><li>线程数量太多可能会造成资源不足，甚至死机等情况----如何避免创建线程数量过多：<strong>创建线程池</strong></li></ol><h2 id="线程池的创建">3. 线程池的创建</h2><h3 id="线程池的创建-concurrent">线程池的创建 <code>concurrent</code></h3><ul><li>创建线程池</li></ul><p>导入 <code>from concurrent.futures import ThreadPoolExecutor</code></p><table><thead><tr class="header"><th>函数名</th><th>说明</th><th>举例</th></tr></thead><tbody><tr class="odd"><td><code>futures.ThreadPoolExecutor</code></td><td>创建线程池</td><td><code>tpool = ThreadPoolExecutor(max_workers)</code></td></tr></tbody></table><ul><li>执行线程池的相关函数：</li></ul><table><thead><tr class="header"><th>函数名</th><th>说明</th><th>举例</th></tr></thead><tbody><tr class="odd"><td><code>submit</code></td><td>往线程池中加入任务</td><td><code>submit(target, args)</code></td></tr><tr class="even"><td><code>done</code></td><td>线程池中的某个线程是否完成了任务</td><td><code>done()</code></td></tr><tr class="odd"><td><code>result</code></td><td>获取当前线程执行任务的结果</td><td><code>result()</code></td></tr></tbody></table><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br>lock = threading.Lock() <span class="hljs-comment"># 使用线程锁只需要在全局定义一个锁，并不需要把它传入到函数中作为参数进行加锁</span><br>                        <span class="hljs-comment"># 而进程需要这么做。这是区别</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">i</span>):</span><br>    <span class="hljs-comment"># lock.acquire()</span><br>    print(i, os.getpid())<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># lock.release()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is %s&#x27;</span> % i<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    print(os.getpid())<br>    t = ThreadPoolExecutor(<span class="hljs-number">2</span>)<br>    result = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        t_result = t.submit(work, (i, ))<br>        result.append(t_result)<br><br>    <span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> result:<br>        print(res.result())<br><br>------------------------------------------------------------------------<br><span class="hljs-number">28708</span><br>(<span class="hljs-number">0</span>,) <span class="hljs-number">28708</span><br>(<span class="hljs-number">1</span>,) <span class="hljs-number">28708</span><br>(<span class="hljs-number">2</span>,) <span class="hljs-number">28708</span><br>result <span class="hljs-keyword">is</span> <span class="hljs-number">0</span><br>(<span class="hljs-number">3</span>,) <span class="hljs-number">28708</span><br>result <span class="hljs-keyword">is</span> <span class="hljs-number">1</span><br>(<span class="hljs-number">4</span>,) <span class="hljs-number">28708</span><br>result <span class="hljs-keyword">is</span> <span class="hljs-number">2</span><br>result <span class="hljs-keyword">is</span> <span class="hljs-number">3</span><br>result <span class="hljs-keyword">is</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><blockquote><p>操作系统中对于任务数量不断增加的程序，每有一个任务就生成一个线程，最终会导致线程数量的失控，所以对于任务数量不断增加的程序，固定线程数量的线程池是必要的。每一个线程从生成到消亡是需要时间和资源的，太多的线程会占用过多的系统资源（内存开销，cpu开销等），而且生成太多的线程时间也是可观的，很可能会得不偿失，所以线程不是不占用资源，也并非线程数量越多越好</p></blockquote><p><strong>GIL 全局解释锁</strong></p><ul><li><p>定义：解释器通过这种机制获取全局解释锁来限制同一个时间点只允许一个线程执行,即使在多核环境下.</p></li><li>当初设计的原因：<ol type="1"><li>解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。于是有了GIL这把超级大锁,而当越来越多的代码库开发者接受了这种设定后,他们开始大量依赖这种特性（即默认python内部对象是thread-safe的,无需在实现时考虑额外的内存锁和同步操作）。</li><li>多核处理器当初还没盛行,96年第一款来自IBM</li></ol></li><li>现在存在的原因：<ul><li>量库代码开发者已经重度依赖GIL而非常难以去除了</li></ul></li><li>优点<ul><li>提高单线程程序的执行速度</li><li>更易于集成c拓展模块</li></ul></li><li>缺点<ul><li>无法充分利用多核,无法很好计算密集型上发挥优势</li></ul></li><li><p>解决方案</p><ol type="1"><li><p>利用多进程 进程池会在另外一个进程中启动一个单独的Python解释器来工作。 当线程等待结果的时候会释放GIL</p></li><li><p>使用C拓展编程技术(cpython的ctypes库,ctypes在调用c时会自动释放GIL)</p></li><li><p>多解释器pypy,jpython</p></li></ol></li><li>任务类型<ul><li><p>IO输出型:网络IO,磁盘交互等,所以使用多线程就很合适, 因为它们大部分时间都在等待</p></li><li><p>计算密集型:计算圆周率、对视频进行高清解码等等,一个CPU依赖型程序可能会使用线程来管理一个图形用户界面、一个网络连接或其他服务。 这时候,GIL会产生一些问题,因为如果一个线程长期持有GIL的话会导致其他非CPU型线程一直等待.</p></li></ul></li></ul><h1 id="异步">异步</h1><p>异步：为了完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式。</p><ul><li>异步：轻量级的线程。协程</li><li><p>可以获取异步函数的返回值</p></li><li><p>主进程需要异步才行</p></li></ul><h2 id="async-与-await-关键字">1. <code>async</code> 与 <code>await</code> 关键字</h2><ul><li><p><code>async</code> ：定义异步</p></li><li><code>await</code> ：执行异步</li><li><p><code>asyncio</code> ：调用异步函数的模块</p></li></ul><h3 id="asyncio-调用-async-函数"><code>asyncio</code> 调用 <code>async</code> 函数</h3><table><thead><tr class="header"><th>函数名</th><th>介绍</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>gather(asyncfunc...)</code></td><td>将异步函数批量执行</td><td>list；函数的返回结果</td></tr><tr class="even"><td><code>run([task])</code></td><td>执行主异步函数</td><td>执行函数的返回结果</td></tr></tbody></table><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        print(i, <span class="hljs-string">&#x27;a&#x27;</span>, os.getpid())<br>        <span class="hljs-comment"># time.sleep(random.random() * 2)  # time.sleep() 是CPU级别的阻塞</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(random.random() * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a function&#x27;</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        print(i, <span class="hljs-string">&#x27;b&#x27;</span>, os.getpid())<br>        <span class="hljs-comment"># time.sleep(random.random() * 2)</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(random.random() * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;b function&#x27;</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    result = <span class="hljs-keyword">await</span> asyncio.gather(<br>        a(),<br>        b()<br>    )<br>    print(result[<span class="hljs-number">0</span>] , result[<span class="hljs-number">1</span>])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    start = time.time()<br>    asyncio.run(main())<br>    end = time.time()<br>    print(end - start)<br>    print(<span class="hljs-string">&#x27;parent is %s&#x27;</span> % os.getpid())<br><br>------------------------------------------------------------------------    <br><span class="hljs-number">0</span> a <span class="hljs-number">24028</span><br><span class="hljs-number">0</span> b <span class="hljs-number">24028</span><br><span class="hljs-number">1</span> a <span class="hljs-number">24028</span><br><span class="hljs-number">1</span> b <span class="hljs-number">24028</span><br>a function b function<br><span class="hljs-number">3.244096517562866</span><br>parent <span class="hljs-keyword">is</span> <span class="hljs-number">24028</span>    <br></code></pre></td></tr></table></figure><h2 id="gevent-关键字">2. <code>gevent</code> 关键字</h2><ul><li><code>gevent</code> 常用方法</li></ul><table><thead><tr class="header"><th>函数名</th><th>介绍</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>spawn(func, args)</code></td><td>创建协程对象</td><td>协程对象</td></tr><tr class="even"><td><code>joinall([spawnonj])</code></td><td>批量处理协程对象</td><td><code>[spawnobj]</code></td></tr></tbody></table><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> gevent<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gevent_a</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        print(i, <span class="hljs-string">&#x27;a gevent&#x27;</span>, os.getpid())<br>        gevent.sleep(random.random() * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a gevent result&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gevent_b</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        print(i, <span class="hljs-string">&#x27;b gevent&#x27;</span>, os.getpid())<br>        gevent.sleep(random.random() * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;b gevent result&#x27;</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    start = time.time()<br><br>    g_a = gevent.spawn(gevent_a)<br>    g_b = gevent.spawn(gevent_b)<br>    gevent_list = [g_a, g_b]<br>    result = gevent.joinall(gevent_list)  <span class="hljs-comment"># asyncio.run(main())</span><br>    print(result[<span class="hljs-number">0</span>].value)<br>    print(result[<span class="hljs-number">1</span>].value)<br>    <br>    end = time.time()<br>    print(end - start)<br>    print(<span class="hljs-string">&#x27;parent is %s&#x27;</span> % os.getpid())<br>    <br>------------------------------------------------------------------------    <br><span class="hljs-number">0</span> a gevent <span class="hljs-number">25876</span><br><span class="hljs-number">0</span> b gevent <span class="hljs-number">25876</span><br><span class="hljs-number">1</span> b gevent <span class="hljs-number">25876</span><br><span class="hljs-number">1</span> a gevent <span class="hljs-number">25876</span><br>b gevent result<br>a gevent result<br><span class="hljs-number">3.4319839477539062</span><br>parent <span class="hljs-keyword">is</span> <span class="hljs-number">25876</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常用函数与高阶函数</title>
    <link href="/2021/01/19/Python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2021/01/19/Python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了Python的常用函数与高阶函数。</p><p><em><a id="more"></a></em></p><hr /><h1 id="python中的加密工具">1. Python中的加密工具</h1><h2 id="hashlib-模块">1.1 <code>hashlib</code> 模块</h2><p>特点：</p><ul><li><u>难破解</u></li><li><u>不可逆</u></li></ul><p><code>hashlib</code> 常用加密方法</p><table><thead><tr class="header"><th>函数名</th><th>参数</th><th>介绍</th><th>举例</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>md5</code></td><td>byte</td><td>md5算法加密</td><td><code>hashlib.md5(b'hello')</code></td><td>hash对象</td></tr><tr class="even"><td><code>sha1</code></td><td>byte</td><td>sha1算法加密</td><td><code>hashlib.sha1(b'hello')</code></td><td>hash对象</td></tr><tr class="odd"><td><code>sha256</code></td><td>byte</td><td>sha256算法加密</td><td><code>hashlib.sha256(b'hello')</code></td><td>hash对象</td></tr><tr class="even"><td><code>sha512</code></td><td>byte</td><td>sha512算法加密</td><td><code>hashlib.sha512(b'hello')</code></td><td>hash对象</td></tr></tbody></table><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> hashlib<br><br>base_sign = <span class="hljs-string">&#x27;xiaoming&#x27;</span><br><br><span class="hljs-comment"># a服务</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">custom</span>():</span><br>    a_timestamp = <span class="hljs-built_in">int</span>(time.time())  <span class="hljs-comment"># 时间戳</span><br>    _token = <span class="hljs-string">&#x27;%s%s&#x27;</span> % (base_sign, a_timestamp)<br>    hashobj = hashlib.sha1(_token.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    a_token = hashobj.hexdigest()  <span class="hljs-comment"># 返回十六进制加密串</span><br>    <span class="hljs-keyword">return</span> a_token, a_timestamp  <span class="hljs-comment"># return 支持多个值返回</span><br><br><span class="hljs-comment"># b服务进行验证</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b_service_check</span>(<span class="hljs-params">token, timestamp</span>):</span><br>    _token = <span class="hljs-string">&#x27;%s%s&#x27;</span> % (base_sign, timestamp)<br>    b_token = hashlib.sha1(_token.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).hexdigest()<br>    <span class="hljs-keyword">if</span> token == b_token:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    need_help_token, timestamp = custom()<br>    <span class="hljs-comment"># result = b_service_check(need_help_token, timestamp)</span><br>    time.sleep(<span class="hljs-number">1</span>)<br>    result = b_service_check(need_help_token, <span class="hljs-built_in">int</span>(time.time()))<br>    <span class="hljs-keyword">if</span> result == <span class="hljs-literal">True</span>:<br>        print(<span class="hljs-string">&#x27;a合法，b服务可以进行帮助&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;a不合法，b不可以进行帮助&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="base64-模块">1.2 <code>base64</code> 模块</h2><p>特点：</p><ul><li><u>通用型</u></li><li><u>可解密</u></li></ul><p><code>base64</code> 包常用方法：</p><table><thead><tr class="header"><th>函数名</th><th>参数</th><th>介绍</th><th>举例</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>encodestring</code></td><td>byte</td><td>进行base64加密</td><td><code>base64.encodestring(b'py')</code></td><td>byte</td></tr><tr class="even"><td><code>decodingstring</code></td><td>byte</td><td>对base64解密</td><td><code>base64.decoding(b'eGlhb211\n')</code></td><td>byte</td></tr><tr class="odd"><td><strong><code>encodebytes</code></strong></td><td>byte</td><td>进行base64加密</td><td><code>base64.encodebytes(b'py')</code></td><td>byte</td></tr><tr class="even"><td><strong><code>decodingbytes</code></strong></td><td>byte</td><td>对base64解密</td><td><code>base64.decodingbytes(b'eGlhb211\n')</code></td><td>byte</td></tr></tbody></table><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span>(<span class="hljs-params">data</span>):</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">str</span>):<br>        data = data.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">bytes</span>):<br>        data = data<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;data shoude be str or bytes&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> base64.encodebytes(data).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">bytes</span>):  <span class="hljs-comment"># 不是byte类型抛出异常，逻辑不要弄反了</span><br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;data should be bytes&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> base64.decodebytes(data).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 变成字符串</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    result = encode(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br>    print(result)<br>    new_result = decode(result.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)) <span class="hljs-comment"># 因为result是str类型, 所以要转成byte类型</span><br>    print(new_result)<br></code></pre></td></tr></table></figure><p>因为我们都知道base64的加密和解密方式，那咋办？其实可以二次转换一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-keyword">import</span> base64<br><br>replace_one = <span class="hljs-string">&#x27;%&#x27;</span><br>replace_two = <span class="hljs-string">&#x27;$&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">str</span>):<br>        data = data.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">bytes</span>):<br>        data = data<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;data shoude be str or bytes&#x27;</span>)<br><br>    _data =  base64.encodebytes(data).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    new_data = _data.replace(<span class="hljs-string">&#x27;a&#x27;</span>, replace_one).replace(<span class="hljs-string">&#x27;2&#x27;</span>, replace_two)<br>    <span class="hljs-keyword">return</span> new_data<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">bytes</span>):  <span class="hljs-comment"># 不是byte类型抛出异常，逻辑不要弄反了</span><br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;data should be bytes&#x27;</span>)<br>    replace_one_b = replace_one.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># bytes -&gt; str</span><br>    replace_two_b = replace_two.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    data = data.replace(replace_one_b, <span class="hljs-string">b&#x27;a&#x27;</span>).replace(replace_two_b, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>    <span class="hljs-keyword">return</span> base64.decodebytes(data).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 变成字符串</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    result = encode(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br>    print(result)<br>    new_result = decode(result.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)) <span class="hljs-comment"># 因为result是str类型, 所以要转成byte类型</span><br>    print(new_result)<br></code></pre></td></tr></table></figure><h1 id="python中的内置函数总结">2. Python中的内置函数总结</h1><p>以下是Python中的一些内置函数总结：</p><table><thead><tr class="header"><th>函数名</th><th>参数</th><th>介绍</th><th>返回值</th><th>举例</th></tr></thead><tbody><tr class="odd"><td><code>abs</code></td><td>number</td><td>返回数字绝对值</td><td>正数字</td><td><code>abs(-10)</code></td></tr><tr class="even"><td><code>all</code></td><td>list</td><td>判断列表内容是否全是true</td><td>bool</td><td><code>all(['', '123'])</code></td></tr><tr class="odd"><td><code>help</code></td><td>object</td><td>打印对象的用法</td><td>无</td><td><code>help(list)</code></td></tr><tr class="even"><td><code>enumerate</code></td><td>iterable</td><td>迭代时记录索引</td><td>无</td><td><code>for index, item in enumerate(list)</code></td></tr><tr class="odd"><td><code>input</code></td><td>str</td><td>命令行输入消息</td><td>str</td><td><code>input('请输出信息：')</code></td></tr><tr class="even"><td><code>isinstance</code></td><td>object, type</td><td>判断对象是否是某种类型</td><td>bool</td><td><code>isinstance('a', str)</code></td></tr><tr class="odd"><td><code>type</code></td><td>object</td><td>判断对象的类型</td><td>str</td><td><code>type(10)</code></td></tr><tr class="even"><td><code>vars</code></td><td>instance</td><td>返回实例化的字典信息</td><td>dict</td><td></td></tr><tr class="odd"><td><code>dir</code></td><td>object</td><td>返回对象中所有可用方法和属性</td><td>list</td><td><code>dir('asd')</code></td></tr><tr class="even"><td><code>hasattr</code></td><td>obj, key</td><td>判断对象中是否有某个属性</td><td>bool</td><td><code>hasatr('1', 'upper')</code></td></tr><tr class="odd"><td><code>setattr</code></td><td>obj, key, val, ue</td><td>为实例化对象添加属性与值</td><td>无</td><td><code>setattr(instance, 'run', go)</code></td></tr><tr class="even"><td><code>getattr</code></td><td>obj, key</td><td>通过对象获取属性</td><td>任何类型</td><td><code>getattr(obj, key)</code></td></tr><tr class="odd"><td><code>any</code></td><td>iterable</td><td>判断内容是否有true值</td><td>bool</td><td><code>any([1, 0, ' '])</code></td></tr></tbody></table><h1 id="random-模块">3. <code>random</code> 模块</h1><ul><li><p><code>random.random</code> ：随机返回0~1之间的浮点数（模块.函数）</p></li><li><p><code>random.uniform</code> ：产生一个[a, b]区间的随机浮点数</p></li><li><p><code>random.randint</code> ：产生一个[a, b]区间的随机整数</p></li><li><p><code>random.choice</code> ：返回对象中的一个随机元素</p></li><li><p><code>random.sample</code> ：随机返回对象中指定数量的元素(以列表形式返回)</p></li><li><p><code>random.randrange</code> ：获取区间内的一个随机数。(类似 <code>random.choice</code>)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br>gitfs = [<span class="hljs-string">&#x27;iphone&#x27;</span>, <span class="hljs-string">&#x27;apple watch&#x27;</span>, <span class="hljs-string">&#x27;car&#x27;</span>, <span class="hljs-string">&#x27;house&#x27;</span>, <span class="hljs-string">&#x27;money&#x27;</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">choice_gifts</span>():</span><br>    data = random.choice(gitfs)<br>    print(<span class="hljs-string">&#x27;你得到了%s&#x27;</span> % data)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">choice_gifts_new</span>():</span><br>    count = random.randrange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 0~100 随机返回一个数字</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= count &lt;= <span class="hljs-number">50</span>:<br>        print(<span class="hljs-string">&#x27;你中了一个apple watch&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-number">50</span> &lt; count &lt;= <span class="hljs-number">75</span>:<br>        print(<span class="hljs-string">&#x27;你中了一个iphone&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-number">75</span> &lt; count &lt;= <span class="hljs-number">90</span>:<br>        print(<span class="hljs-string">&#x27;你中了一个money&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-number">90</span> &lt; count &lt;= <span class="hljs-number">98</span>:<br>        print(<span class="hljs-string">&#x27;你中了一个car&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> count &gt; <span class="hljs-number">98</span>:<br>        print(<span class="hljs-string">&#x27;你中了一个house&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    choice_gifts()<br>    choice_gifts_new()<br></code></pre></td></tr></table></figure><h1 id="python中的迭代器iterator">4. Python中的迭代器（iterator）</h1><p><strong>1、什么是可迭代对象（iterable）？</strong></p><p><strong>可迭代对象可以直接作用于 for 循环。</strong>可迭代对象有以下几种：</p><ul><li>一类是<strong>集合数据类型</strong>，如 <code>str</code> 、 <code>tuple</code> 、<code>list</code> 、 <code>dict</code> 、 <code>set</code>等；</li><li>一类是 <strong>generator</strong> ，包括生成器和带 yield 的 generator function。</li></ul><p><strong>可迭代对象 <code>Iterable</code> 有 <code>__iter__</code> 内置方法， <code>obj.__iter__</code> 就是可迭代对象</strong>，如下:</p><ul><li><code>'world'.__iter__</code></li><li><code>(4,5,6).__iter__</code></li><li><code>[1,2,3].__iter</code>__</li><li><code>&#123;'a':1&#125;.__iter__</code></li><li><code>&#123;'a','b'&#125;.__iter__</code></li><li><code>open('a.txt').__iter__</code> （文件类型是迭代器对象）</li></ul><blockquote><p>如何判断对象是不是可迭代对象？</p><ul><li>可以使用 <code>isinstance()</code> 判断一个对象是否是 Iterable 对象：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-built_in">isinstance</span>(&#123;&#125;, Iterable)  <span class="hljs-comment"># True</span><br><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">100</span>, Iterable)  <span class="hljs-comment"># False　</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>2、什么是迭代器？</strong></p><p>对于序列类型：字符串、列表、元组，我们可以使用索引的方式迭代取出其包含的元素。</p><p>但对于字典、集合、文件等类型是没有索引的，若还想取出其内部包含的元素，则必须找出一种不依赖于索引的迭代方式，这就是迭代器。迭代器是一个可以记住遍历的位置的对象。</p><p><strong>3、迭代器有两个基本的方法</strong></p><ol type="1"><li><p><code>iter(iterable)</code> ：生成一个迭代器对象</p></li><li><p><code>next(iterator)</code> ：返回迭代器中的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>)    <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))   <span class="hljs-comment"># 输出迭代器的下一个元素:1</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>4、总结</strong>：</p><ol type="1"><li><p><strong>凡是可作用于 <code>for</code> 循环的对象都是 Iterable 类型。</strong></p></li><li><p><strong>凡是可作用于 <code>next()</code> 函数的对象都是 Iterator 类型。</strong></p></li><li><p>集合数据类型如 <code>list</code> 、 <code>dict</code> 、 <code>str</code> 等<strong>是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数转化成 Iterator 对象</strong>；</p><blockquote><p><code>list</code> 是可迭代对象， <code>it = next(list)</code> 中的 <code>it</code> 是迭代器对象。</p></blockquote></li><li><strong>可迭代对象包含迭代器。</strong></li><li>如果一个对象拥有 <code>__iter__</code> 方法，其是可迭代对象；如果一个对象拥有 <code>next()</code> 方法，其是迭代器。</li><li><p>定义可迭代对象，必须实现 <code>__iter__</code> 方法；定义迭代器，必须实现 <code>__iter__</code> 和 <code>next()</code> 方法。</p></li></ol><blockquote><p>一个对象拥有了next方法就是迭代器，那为什么迭代器必须同时实现 <code>__iter__</code> 和 <code>next()</code> 两种方法呢？</p><p><strong>答：迭代器也是可迭代对象，因此迭代器必须也实现 <code>__iter__</code> 方法。</strong></p></blockquote><p>小练习：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.container = []<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, item</span>):</span><br>        self.container.append(item)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br>    <br>myList = MyList()<br></code></pre></td></tr></table></figure><blockquote><p>本题考查的是关于迭代器和可迭代对象的理解及应用。此段代码中，只定义了 <code>__iter__</code> 方法，所以说<code>myList</code> 是一个可迭代对象，可迭代对象可以通过for循环取值；将类作为迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code></p><p>所以，myList是一个迭代器，可以通过next()方法取值</p></blockquote><p>如何定义可迭代对象和迭代器呢？</p><p>1）<code>__iter__()</code></p><p><strong>该方法返回的是当前对象的迭代器类的实例</strong>。因为可迭代对象与迭代器都要实现这个方法，因此有以下两种写法。</p><ol type="1"><li><p>用于可迭代对象类的写法，返回该可迭代对象的迭代器类的实例。</p></li><li><p>用于迭代器类的写法，直接返回self（即自己本身），表示自身即是自己的迭代器。</p></li></ol><p>也许有点晕，没关系，下面会给出两写法的例子，我们结合具体例子看。</p><p>2）<code>next()</code></p><p>返回迭代的每一步，实现该方法时注意要最后超出边界要抛出StopIteration异常。</p><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>            <span class="hljs-comment"># 定义可迭代对象类</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, num</span>):</span><br>        self.data = num          <span class="hljs-comment"># 上边界</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> MyListIterator(self.data)  <span class="hljs-comment"># 返回该可迭代对象的迭代器类的实例</span><br> <br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListIterator</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-comment"># 定义迭代器类，其是MyList可迭代对象的迭代器类</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data</span>):</span><br>        self.data = data         <span class="hljs-comment"># 上边界</span><br>        self.now = <span class="hljs-number">0</span>             <span class="hljs-comment"># 当前迭代值，初始为0</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self              <span class="hljs-comment"># 返回该对象的迭代器类的实例；因为自己就是迭代器，所以返回self</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next</span>(<span class="hljs-params">self</span>):</span>              <span class="hljs-comment"># 迭代器类必须实现的方法</span><br>        <span class="hljs-keyword">while</span> self.now &lt; self.data:<br>            self.now += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> self.now - <span class="hljs-number">1</span>  <span class="hljs-comment"># 返回当前迭代值</span><br>        <span class="hljs-keyword">raise</span> StopIteration      <span class="hljs-comment"># 超出边界要抛出StopIteration异常。</span><br> <br> <br>my_list = MyList(<span class="hljs-number">5</span>)              <span class="hljs-comment"># 得到一个可迭代对象</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">type</span>(my_list)              <span class="hljs-comment"># 返回该对象的类型</span><br> <br>my_list_iter = <span class="hljs-built_in">iter</span>(my_list)     <span class="hljs-comment"># 得到该对象的迭代器实例，iter函数在下面会详细解释</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">type</span>(my_list_iter)<br> <br> <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> my_list:                <span class="hljs-comment"># 迭代</span><br>    <span class="hljs-built_in">print</span> i<br></code></pre></td></tr></table></figure><h1 id="python中的高级函数">5. Python中的高级函数</h1><h2 id="filter">5.1 <code>filter</code></h2><p><code>filter(func, list)</code> ：是把传入的函数依次作用与列表中的每个元素，根据返回的是True还是False决定是否保留该元素（对循环根据过滤条件<strong>进行过滤</strong>）。</p><ul><li><p><code>func</code> ：对 list 的每个 item 进行条件过滤的定义</p></li><li><p><code>list</code> ：需要过滤的列表</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>]<br>result = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-string">&#x27;e&#x27;</span> <span class="hljs-keyword">in</span> x, fruits)<br>print(<span class="hljs-built_in">list</span>(result))  <span class="hljs-comment"># [&#x27;apple&#x27;, &#x27;orange&#x27;]</span><br>print(fruits)  <span class="hljs-comment"># [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;]</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fruit_func</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;e&#x27;</span> <span class="hljs-keyword">in</span> x:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>fruit_result = <span class="hljs-built_in">filter</span>(fruit_func, fruits)<br>print(<span class="hljs-built_in">list</span>(fruit_result))  <span class="hljs-comment"># [&#x27;apple&#x27;, &#x27;orange&#x27;]</span><br></code></pre></td></tr></table></figure><p>小练习：使用filter函数，求0-50以内（包括50）的偶数</p><p>[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50]</p><p>任务</p><p>1、定义use_filter函数</p><p>2、函数体内：实现过滤偶数值的功能</p><p>任务提示</p><p>使用变量data接收0-50（包含50）的数字，即list(range(51))</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">use_filter</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 使用result接收filter过滤偶数值的功能</span><br>    result = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> , data)<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 使用data接收0-50的数值</span><br>    data = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">51</span>))<br>    <br>    <span class="hljs-comment"># 调用use_filter函数传入data,使用result变量接收</span><br>    result = use_filter(data)<br>    print(<span class="hljs-built_in">list</span>(result))<br></code></pre></td></tr></table></figure><h2 id="map">5.2 <code>map</code></h2><p><code>map(func, list)</code> ：将传入的函数依次作用于序列中的每一个元素，<strong>返回执行指定函数的返回值</strong>（对列表中的每个成员是否满足条件返回对应的True与False）</p><ul><li><p><code>func</code> ：对 list 的每个 item 进行条件过滤的定义</p></li><li><p><code>list</code> ：需要过滤的列表</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">map_result = <span class="hljs-built_in">map</span>(fruit_func, fruits)<br>print(<span class="hljs-built_in">list</span>(map_result))  <span class="hljs-comment"># [True, None, True]</span><br></code></pre></td></tr></table></figure><p>小练习：使用map函数，求元组 (2,4,6,8,10,12)中各个元素的5次方</p><p>任务</p><p>1、pow_five函数体内：计算元素的5次方</p><p>2、调用pow_five函数传入data，使用result接收</p><p>任务提示</p><p>1、pow(x,y) 方法返回 x的y次方的值</p><p>2、计算结果：(32, 1024, 7776, 32768, 100000, 248832)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pow_five</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 计算元素的5次方</span><br>    result = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">pow</span>(x, <span class="hljs-number">5</span>), data)<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    data = (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>)<br>    <span class="hljs-comment"># 调用pow_five函数传入data，使用result接收</span><br>    result = pow_five(data)<br>    print(<span class="hljs-built_in">tuple</span>(result))<br></code></pre></td></tr></table></figure><h2 id="reduce">5.3 <code>reduce</code></h2><p><code>reduce(func, list)</code> ：对循环前后两个数据进行累加</p><ul><li><p><code>func</code> ：对 数据累加的函数</p></li><li><p><code>list</code> ：需要处理的列表</p></li></ul><blockquote><p>需要导入：from functools import reduce</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>reduce_result = reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>])<br>print(reduce_result)  <span class="hljs-comment"># 7</span><br><br>reduce_result = reduce(<span class="hljs-keyword">lambda</span> x, y: x * y, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>])<br>print(reduce_result)  <span class="hljs-comment"># 8</span><br><br>reduce_result = reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, fruits)<br>print(reduce_result)  <span class="hljs-comment"># applebananaorange</span><br><br>reduce_result = reduce(<span class="hljs-keyword">lambda</span> x, y: x * y, fruits)<br>print(reduce_result)  <span class="hljs-comment"># TypeError: can&#x27;t multiply sequence by non-int of type &#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><p>小练习：</p><p>1、请运用reduce函数，计算20的阶乘，并于终端打印计算结果：2432902008176640000</p><p>任务</p><p>1、定义use_reduce函数</p><p>2、函数体内：实现某个数值的阶乘</p><p>任务提示</p><p>1、结合list和range函数实现1-20(包含20）的数值即list(range(1,21))</p><p>2、20的阶乘为 <span class="math inline">\(1*2*3*4*5*...*20\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从functools 中导入reduce函数</span><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">use_reduce</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 使用result接收两个数的乘积</span><br>    result = reduce(<span class="hljs-keyword">lambda</span> x, y : x * y, data )<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 使用data接收一个1-20的数值</span><br>    data = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>))<br>    <span class="hljs-comment"># 调用use_reduce函数传入data</span><br>    result = use_reduce(data)<br>    print(result)<br></code></pre></td></tr></table></figure><p>2、下列代码运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x, y</span>):</span><br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">charToNum</span>(<span class="hljs-params">s</span>):</span><br>    <span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-number">4</span>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>[s]<br><br>r1 = reduce(fn, <span class="hljs-built_in">map</span>(charToNum, <span class="hljs-string">&quot;23443&quot;</span>))<br>print(r1)<br>print(<span class="hljs-built_in">type</span>(r1))<br></code></pre></td></tr></table></figure><blockquote><p>首先，执行 <code>map(charToNum, &quot;23443&quot;)</code> ，将 <code>&quot;23443&quot;</code> 输入 <code>charToNum</code> 返回值 <code>23443</code> 相当于将字符串转换为数字类型，再代入 <code>reduce(fn, 23443)</code> 求各元素累积和，即<span class="math inline">\((((2*10+3)*10+4)*10+4)）*10+3=23443\)</span>，类型为int型</p></blockquote><h1 id="日志模块">6. 日志模块</h1><p>日志：记录程序的行为。记录一些重要信息。</p><p>日志的等级：(等级降序)</p><ul><li><code>debug</code></li><li><code>info</code></li><li><code>warning</code></li><li><code>error</code></li><li><code>critical</code></li></ul><h2 id="logging-模块的使用"><code>logging</code> 模块的使用</h2><ul><li><code>logging.basicConfig</code></li></ul><table><thead><tr class="header"><th>参数名</th><th>作用</th><th>举例</th></tr></thead><tbody><tr class="odd"><td><code>level</code></td><td>日志输出等级</td><td><code>level=logging.DEBUG</code></td></tr><tr class="even"><td><code>format</code></td><td>日志输出格式</td><td></td></tr><tr class="odd"><td><code>filename</code></td><td>存储位置</td><td><code>filename='d://back.log'</code></td></tr><tr class="even"><td><code>filemode</code></td><td>输入模式</td><td><code>filemode=&quot;w&quot;</code></td></tr></tbody></table><ul><li><code>format</code> 具体格式</li></ul><table><thead><tr class="header"><th>格式符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>%(levelname)s</code></td><td>日志级别名称</td></tr><tr class="even"><td><code>%(pathname)s</code></td><td>执行程序的路径</td></tr><tr class="odd"><td><code>%(filename)s</code></td><td>执行程序名</td></tr><tr class="even"><td><code>%(lineno)d</code></td><td>日志的当前行号</td></tr><tr class="odd"><td><code>%(asctime)s</code></td><td>打印日志的时间</td></tr><tr class="even"><td><code>%(message)s</code></td><td>日志信息</td></tr></tbody></table><blockquote><p>括号外面是参数格式，例：s就是str，d就是数字类型</p></blockquote><p><strong>常用的 <code>format</code> 格式：<code>%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</code></strong></p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_log</span>(<span class="hljs-params">path</span>):</span><br>    <span class="hljs-keyword">if</span> os.path.exists(path):<br>        mode = <span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        mode = <span class="hljs-string">&#x27;w&#x27;</span><br><br>    logging.basicConfig(<br>        level=logging.INFO,  <span class="hljs-comment"># 表示INFO以下的等级不会被记录</span><br>        <span class="hljs-built_in">format</span> = <span class="hljs-string">&#x27;%(asctime)s %(filename)s %(lineno)d %(levelname)s %(message)s&#x27;</span>,<br>        filename= path,<br>        filemode= mode<br>    )<br>    <span class="hljs-keyword">return</span> logging<br><br>current_path = os.getcwd()<br>path = os.path.join(current_path, <span class="hljs-string">&#x27;back.log&#x27;</span>)<br>log = init_log(path)<br><br>log.info(<span class="hljs-string">&#x27;这是第一个记录的日志信息&#x27;</span>)<br>log.warning(<span class="hljs-string">&#x27;这是一个警告&#x27;</span>)<br>log.error(<span class="hljs-string">&#x27;这是一个重大错误信息&#x27;</span>)<br>log.debug(<span class="hljs-string">&#x27;这是一个debug&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>2021-01-28 22:03:30,303 t2.py 12 INFO 这是第一个记录的日志信息 2021-01-28 22:03:30,303 t2.py 13 WARNING 这是一个警告 2021-01-28 22:07:58,890 t2.py 12 INFO 这是第一个记录的日志信息 2021-01-28 22:07:58,890 t2.py 13 WARNING 这是一个警告 2021-01-28 22:07:58,890 t2.py 14 ERROR 这是一个重大错误信息 2021-01-28 22:11:56,225 t2.py 24 INFO 这是第一个记录的日志信息 2021-01-28 22:11:56,225 t2.py 25 WARNING 这是一个警告 2021-01-28 22:11:56,225 t2.py 26 ERROR 这是一个重大错误信息</p></blockquote><h1 id="编程练习">编程练习</h1><p>学生信息库 1: 将学生信息存入一个json文件中，添加 读与写 json 的函数 2: 我们要将用户添加修改和删除的行为记录到日志中，添加与修改都用info代表 而delete将要用warn警告来提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    学生信息库</span><br><span class="hljs-string">    1: 将学生信息存入一个json文件中，添加 读与写 json 的函数</span><br><span class="hljs-string">    2: 我们要将用户添加修改和删除的行为记录到日志中，添加与修改都用info代表</span><br><span class="hljs-string">       而delete将要用warn警告来提示</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>students = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小鱼&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小何&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">5</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小安&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 缺少参数的错误，定义一个基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotArgError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-comment"># 定义一个异常：没有相关文件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MissPathError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-comment"># 定义一个不是以json结尾的格式错误</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FormatError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentInfo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, students_path, log_path</span>):</span><br>        self.students_path = students_path<br>        self.log_path = log_path<br><br>        self.__log()<br>        self.__init_path()  <span class="hljs-comment"># 直接在初始化时验证文件是否存在; 判断结尾是否是json</span><br>        self.__read()  <span class="hljs-comment"># 初始化读写</span><br><br><br>    <span class="hljs-comment"># 日志</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__log</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> os.path.exists(self.log_path):<br>            mode = <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            mode = <span class="hljs-string">&#x27;w&#x27;</span><br>        logging.basicConfig(<br>            level = logging.DEBUG,<br>            <span class="hljs-built_in">format</span> = <span class="hljs-string">&#x27;%(asctime)s-%(filename)s %(lineno)d: %(levelname)s %(message)s&#x27;</span>,<br>            filename = self.log_path,<br>            filemode = mode<br>        )<br>        self.log = logging<br><br>    <span class="hljs-comment"># 判断输入进来的文件是否存在; 判断结尾是否是json</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init_path</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 判断输入进来的文件是否存在</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(self.students_path):<br>            <span class="hljs-keyword">raise</span> MissPathError(<span class="hljs-string">&#x27;没有相关的地址文件 %s&#x27;</span> % self.students_path )<br><br>        <span class="hljs-comment"># 判断 以json结尾的是否是一个文件(有可能是文件夹..)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isfile(self.students_path):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;当前的studentspath不是一个文件&#x27;</span>)<br><br>        <span class="hljs-comment"># 判断结尾是否是json</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.students_path.endswith(<span class="hljs-string">&#x27;.json&#x27;</span>):<br>            <span class="hljs-keyword">raise</span> FormatError(<span class="hljs-string">&#x27;当前不是一个json文件&#x27;</span>)<br><br>    <span class="hljs-comment"># 定义一个读取文件</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__read</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.students_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-keyword">try</span>:<br>                data = f.read()<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-keyword">raise</span> e<br>        self.students = json.loads(data)<br><br>    <span class="hljs-comment"># 往json文件里面保存（添加，直接‘w’覆盖即可）</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__save</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.students_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            json_data = json.dumps(self.students)<br>            f.write(json_data)<br><br>        print(<span class="hljs-string">&#x27;成功写入&#x27;</span>)<br><br><br>    <span class="hljs-comment"># 查找，通过学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_id</span>(<span class="hljs-params">self, student_id</span>):</span><br>        <span class="hljs-keyword">return</span> self.students.get(student_id)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_students</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># get_all_students</span><br>        <span class="hljs-keyword">for</span> id_, value <span class="hljs-keyword">in</span> self.students.items():<br>            print(<span class="hljs-string">&#x27;学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                id_, value[<span class="hljs-string">&#x27;name&#x27;</span>], value[<span class="hljs-string">&#x27;age&#x27;</span>], value[<span class="hljs-string">&#x27;sex&#x27;</span>], value[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>            ))<br>        <span class="hljs-keyword">return</span> self.students<br><br>    <span class="hljs-comment"># 添加单个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, **student</span>):</span>  <span class="hljs-comment"># add_student</span><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.__add(**student)<br>        self.__save()<br>        self.__read()<br><br>    <span class="hljs-comment"># 添加多个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adds</span>(<span class="hljs-params">self, new_students</span>):</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> new_students:<br>            <span class="hljs-keyword">try</span>:<br>                self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                print(e, student.get(<span class="hljs-string">&#x27;name&#x27;</span>))<br>                <span class="hljs-keyword">continue</span><br>            self.__add(**student)<br>        self.__save()<br>        self.__read()<br><br>    <span class="hljs-comment"># 添加新的学号；并将新的学生入库</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add</span>(<span class="hljs-params">self, **student</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.students) == <span class="hljs-number">0</span>:<br>            new_id = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            keys = <span class="hljs-built_in">list</span>(self.students.keys())<br>            _keys = []<br>            <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> keys:<br>                _keys.append(<span class="hljs-built_in">int</span>(item))  <span class="hljs-comment"># 把字典里的key值由str改为int</span><br>            new_id = <span class="hljs-built_in">max</span>(_keys) + <span class="hljs-number">1</span><br>        self.students[new_id] = student<br>        self.log.info(<span class="hljs-string">&#x27;学生%s被注册了&#x27;</span> % student[<span class="hljs-string">&#x27;name&#x27;</span>])<br><br><br>    <span class="hljs-comment"># 删除</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, student_id</span>):</span>  <span class="hljs-comment"># delete_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;号的同学的信息不存在&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br>        <span class="hljs-keyword">else</span>:<br>            user_info = self.students.pop(student_id)<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br>            self.log.warning(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br>        self.__save()<br>        self.__read()<br><br>    <span class="hljs-comment"># 批量删除，删除学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deletes</span>(<span class="hljs-params">self, ids</span>):</span><br>        <span class="hljs-keyword">for</span> id_ <span class="hljs-keyword">in</span> ids:  <span class="hljs-comment"># id_防止和函数id()冲突</span><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;id_&#125;</span> 不存在学生库中&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br>            student_info = students.pop(id_)<br>            print(<span class="hljs-string">f&#x27;学号<span class="hljs-subst">&#123;id_&#125;</span> 学生<span class="hljs-subst">&#123;student_info[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span> 已被移除&#x27;</span>)<br>            self.log.warning(<span class="hljs-string">f&#x27;学号<span class="hljs-subst">&#123;id_&#125;</span> 学生<span class="hljs-subst">&#123;student_info[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span> 已被移除&#x27;</span>)<br>        self.__save()<br>        self.__read()<br><br><br>    <span class="hljs-comment"># 修改</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, student_id, **kwargs</span>):</span>  <span class="hljs-comment"># update_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;不存在学号：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**kwargs)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.students[student_id] = kwargs<br>        self.__save()<br>        self.__read()<br>        print(<span class="hljs-string">&#x27;&#123;&#125;同学信息更新完毕&#x27;</span>.<span class="hljs-built_in">format</span>(kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br><br><br>    <span class="hljs-comment"># 批量更新，key是学号，value是信息  # todo:添加异常捕获 17&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updates</span>(<span class="hljs-params">self, update_students</span>):</span>  <span class="hljs-comment"># update_students是一个列表</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> update_students:<br>            <span class="hljs-keyword">try</span>:<br>                id_ = <span class="hljs-built_in">list</span>(student.keys())[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 不加list()是假列表  # todo：添加异常捕获  # list可能没有0索引</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续循环列表</span><br><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;学号 <span class="hljs-subst">&#123;id_&#125;</span> 不存在&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br><br>            user_info = student[id_]<br>            <span class="hljs-keyword">try</span>:<br>                check = self.check_user_info(**user_info)  <span class="hljs-comment"># todo：添加异常捕获</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span><br>            self.students[id_] = user_info<br>        print(<span class="hljs-string">&#x27;所有信息更新完成&#x27;</span>)<br>        self.__save()<br>        self.__read()<br><br><br>    <span class="hljs-comment"># 查询</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_users</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;参数数量传递错误&#x27;</span>  <span class="hljs-comment"># 参数不能为空，长度必须是1</span><br><br>        values = <span class="hljs-built_in">list</span>(self.students.values())<br>        key = <span class="hljs-literal">None</span><br>        value = <span class="hljs-literal">None</span><br>        result = []<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;name&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;age&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;sex&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;class_number&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;没有发现搜索的关键字&#x27;</span>)<br><br>        <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> values:  <span class="hljs-comment"># 吐过想用年龄字段模糊查询，需要把年龄改成str类型</span><br>            <span class="hljs-comment"># print(user[key])</span><br>            <span class="hljs-comment"># print(value)</span><br>            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">in</span> user[key]:  <span class="hljs-comment"># in 替代 = 实现模糊查找</span><br>                result.append(user)<br><br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-comment"># 验证参数是否合法，检查位置参数的判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_info</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-comment"># 判断长度是否为4；判断是否我们要的四个参数；判断参数类型是否正确</span><br>        <span class="hljs-comment"># 判断长度是否为4</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;参数必须是4个&#x27;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生姓名参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生年龄参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生性别参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生班级参数&#x27;</span>)<br><br>        <span class="hljs-comment"># 确认四个参数是不是想要的数据类型</span><br>        <span class="hljs-comment"># 先取出数据</span><br>        name_value = kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]<br>        age_value = kwargs[<span class="hljs-string">&#x27;age&#x27;</span>]<br>        sex_value = kwargs[<span class="hljs-string">&#x27;sex&#x27;</span>]<br>        class_number_value = kwargs[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br><br>        <span class="hljs-comment"># isinstance(对比的数据, 数据类型) isinstance(1, str)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(name_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;name 应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age_value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;age应该是整型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(sex_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;sex应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(class_number_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;class_number应该是字符串类型&#x27;</span>)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    student_info = StudentInfo(<span class="hljs-string">&#x27;students.json&#x27;</span>, <span class="hljs-string">&#x27;students.log&#x27;</span>)<br>    user = student_info.get_user_by_id(<span class="hljs-number">1</span>)<br>    student_info.add(name=<span class="hljs-string">&#x27;小绿&#x27;</span>, age=<span class="hljs-number">34</span>, class_number=<span class="hljs-string">&#x27;A&#x27;</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>    print(student_info.students)<br><br>    users = [<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小橙&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小黄&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>    ]<br>    student_info.adds(users)<br>    student_info.get_all_students()<br><br>    student_info.deletes([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>])<br>    student_info.get_all_students()<br><br>    student_info.updates([<br>        &#123;<span class="hljs-number">2</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;何同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span>&#125;&#125;,<br>        &#123;<span class="hljs-number">4</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span>&#125;&#125;<br>    ])<br>    student_info.get_all_students()<br><br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;小&#x27;</span>)<br>    print(result)<br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 会把所有的都打印出来</span><br>    print(result)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python文件操作</title>
    <link href="/2021/01/18/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/01/18/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了Python相关的文件操作：文件的读写，序列化等等。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/python文件操作.png" alt="img" /><figcaption>img</figcaption></figure><p><em><a id="more"></a></em></p><hr /><h1 id="文件的创建与写入">1. 文件的创建与写入</h1><h2 id="open-函数获取文件对象">1.1 <code>open</code> 函数获取文件对象</h2><p>内置函数 <code>open</code> 函数：生成文件对象，进行创建、读写操作。</p><p>语法：<code>open(path, mode)</code> ，返回一个文件对象</p><blockquote><ul><li><code>path</code> ：文件路径</li><li><code>mode</code> ：操作模式</li></ul></blockquote><h2 id="文件的创建与写入-1">1.2 文件的创建与写入</h2><p>常见的写入模式</p><table><thead><tr class="header"><th>模式</th><th>可做操作</th><th>介绍</th><th>是否覆盖</th></tr></thead><tbody><tr class="odd"><td>w</td><td>只能写</td><td>若没有这个文件，则<u>创建</u>文件。若有这个文件，则<u>覆盖</u>文件中的内容。</td><td>是</td></tr><tr class="even"><td>w+</td><td>可读可写</td><td>打开一个文件用于读写。</td><td>是</td></tr><tr class="odd"><td>wb</td><td>可读可写</td><td><u>二进制形式。</u>若没有这个文件，则<u>创建</u>文件。若有这个文件，则<u>覆盖</u>文件中的内容。</td><td>是</td></tr><tr class="even"><td>wb+</td><td>可读可写</td><td><u>二进制形式</u>创建或追加内容（若无则创建，若有则继续以比特类型写入内容）。</td><td>是</td></tr><tr class="odd"><td>a</td><td>可读可写</td><td>在已存在的文件中追加内容。</td><td>否，追加写</td></tr><tr class="even"><td>a+</td><td>可读可写</td><td>同上。多了可以读取的功能。</td><td>否，追加写</td></tr><tr class="odd"><td>ab+</td><td>可读可写</td><td>二进制形式追加读取内容。</td><td>否，追加写</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br>current_path = os.getcwd()<br><br>f = <span class="hljs-built_in">open</span>(current_path + <span class="hljs-string">&#x27;/a.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br>path = os.path.join(current_path, <span class="hljs-string">&#x27;a.txt&#x27;</span>)<br><br>f = <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;你好 小张\n&#x27;</span>)  <span class="hljs-comment"># 因为是“w”模式，所以会覆盖之前的内容</span><br><span class="hljs-comment"># f.read()  # io.UnsupportedOperation: not readable</span><br><br>f = <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;w+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;你好 xiaozhu\n&#x27;</span>)<br>f.read()  <span class="hljs-comment"># “w+”模式就不会报错了</span><br><br>f = <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;ab&#x27;</span>)<br>message = <span class="hljs-string">&#x27;python很有意思&#x27;</span><br>_message = message.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>f.write(_message)  <span class="hljs-comment"># TypeError: a bytes-like object is required, not &#x27;str&#x27;</span><br><br>f = <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;a+&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;1\n&#x27;</span>)<br><br>l = [<span class="hljs-string">&#x27;今天天气很好\n&#x27;</span>, <span class="hljs-string">&#x27;很适合学习python\n&#x27;</span>, <span class="hljs-string">&#x27;我最爱学习了\n&#x27;</span>]<br>f = <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>f.writelines(l)<br><br>f.close()<br></code></pre></td></tr></table></figure><h2 id="文件对象的写入保存">1.3 文件对象的写入保存</h2><p>常见的文件对象操作方法</p><table><thead><tr class="header"><th>方法名</th><th>参数</th><th>介绍</th><th>举例</th></tr></thead><tbody><tr class="odd"><td><code>write</code></td><td>message</td><td>写入信息</td><td><code>f.write(‘hello\n’)</code></td></tr><tr class="even"><td><code>writelines</code></td><td>message_list</td><td>批量写入</td><td><code>f.writelines(['hello\n', 'world\n'])</code></td></tr><tr class="odd"><td><code>close</code></td><td>无</td><td>关闭并保存文件。<strong>操作完必须用close方法！</strong></td><td><code>f.close()</code></td></tr></tbody></table><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_package</span>(<span class="hljs-params">path</span>):</span><br>    <span class="hljs-keyword">if</span> os.path.exists(path):<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;%s 已经存在不可创建&#x27;</span> % path )<br>    os.makedirs(path)<br>    init_path = os.path.join(path, <span class="hljs-string">&#x27;__init__.py&#x27;</span>)<br>    f = <span class="hljs-built_in">open</span>(init_path, <span class="hljs-string">&#x27;w&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;# coding:utf-8\n&#x27;</span>)<br>    f.close()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Open</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, path, mode=<span class="hljs-string">&#x27;w&#x27;</span>, is_return=<span class="hljs-literal">True</span></span>):</span><br>        self.path = path<br>        self.mode = mode<br>        self.is_return = is_return  <span class="hljs-comment"># 换行符</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">self, message</span>):</span><br>        <span class="hljs-keyword">try</span>: <span class="hljs-comment"># 写入出现异常，不能让close无法关闭</span><br>            f = <span class="hljs-built_in">open</span>(self.path, mode=self.mode)<br>            <span class="hljs-keyword">if</span> self.is_return == <span class="hljs-literal">True</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> message.endswith(<span class="hljs-string">&#x27;\n&#x27;</span>):<br>                    message = <span class="hljs-string">&#x27;%s \n&#x27;</span> % message<br>            f.write(message)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            print(e)<br>        <span class="hljs-keyword">finally</span>:<br>            f.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    current_path = os.getcwd()<br>    <span class="hljs-comment"># path = os.path.join(current_path, &#x27;test1&#x27;)</span><br>    <span class="hljs-comment"># create_package(path)</span><br>    open_path = os.path.join(current_path, <span class="hljs-string">&#x27;b.txt&#x27;</span>)<br>    o = Open(open_path)<br>    o.write(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="文件的读取">1.4 文件的读取</h2><table><thead><tr class="header"><th>模式</th><th>介绍</th></tr></thead><tbody><tr class="odd"><td><code>r</code></td><td>读取文件</td></tr><tr class="even"><td><code>rb</code></td><td>二进制形式读取文件</td></tr></tbody></table><h2 id="文件对象的读取">1.5 文件对象的读取</h2><p>常用的文件对象的读取</p><table><thead><tr class="header"><th>方法名</th><th>参数</th><th>介绍</th><th>举例</th></tr></thead><tbody><tr class="odd"><td><code>read</code></td><td>无</td><td>返回整个文件字符串</td><td><code>f.read()</code></td></tr><tr class="even"><td><code>readlines</code></td><td>无</td><td>返回文件列表</td><td><code>f.readlines()</code></td></tr><tr class="odd"><td><code>readline</code></td><td>无</td><td>返回文件中的一行</td><td><code>f.readline()</code></td></tr><tr class="even"><td><code>mode</code></td><td>无</td><td>文件模式</td><td><code>f.mode</code></td></tr><tr class="odd"><td><code>name</code></td><td>无</td><td>返回文件名称</td><td><code>f.name</code></td></tr><tr class="even"><td><code>closed</code></td><td>无</td><td>文件是否关闭</td><td><code>f.closed</code></td></tr></tbody></table><blockquote><p>操作完成后，必须使用 <code>close</code> 方法。</p></blockquote><p>接上一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_package</span>(<span class="hljs-params">path</span>):</span><br>    <span class="hljs-keyword">if</span> os.path.exists(path):<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;%s 已经存在不可创建&#x27;</span> % path )<br>    os.makedirs(path)<br>    init_path = os.path.join(path, <span class="hljs-string">&#x27;__init__.py&#x27;</span>)<br>    f = <span class="hljs-built_in">open</span>(init_path, <span class="hljs-string">&#x27;w&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;# coding:utf-8\n&#x27;</span>)<br>    f.close()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Open</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, path, mode=<span class="hljs-string">&#x27;w&#x27;</span>, is_return=<span class="hljs-literal">True</span></span>):</span><br>        self.path = path<br>        self.mode = mode<br>        self.is_return = is_return  <span class="hljs-comment"># 换行符</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">self, message</span>):</span><br>        <span class="hljs-keyword">try</span>: <span class="hljs-comment"># 写入出现异常，不能让close无法关闭</span><br>            f = <span class="hljs-built_in">open</span>(self.path, mode=self.mode)<br>            <span class="hljs-keyword">if</span> self.is_return == <span class="hljs-literal">True</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> message.endswith(<span class="hljs-string">&#x27;\n&#x27;</span>):<br>                    message = <span class="hljs-string">&#x27;%s \n&#x27;</span> % message<br>            f.write(message)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            print(e)<br>        <span class="hljs-keyword">finally</span>:<br>            f.close()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">self, is_strip=<span class="hljs-literal">True</span></span>):</span><br>        result = []<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.path, mode=self.mode) <span class="hljs-keyword">as</span> f:<br>            data = f.readlines()<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data:<br>            <span class="hljs-keyword">if</span> is_strip == <span class="hljs-literal">True</span>:<br>                temp = line.strip()<br>                <span class="hljs-keyword">if</span> temp != <span class="hljs-string">&quot;&quot;</span>:<br>                    result.append(temp)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> line != <span class="hljs-string">&#x27;&#x27;</span>:<br>                    result.append(line)<br>        <span class="hljs-keyword">return</span> result<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    current_path = os.getcwd()<br>    <span class="hljs-comment"># path = os.path.join(current_path, &#x27;test1&#x27;)</span><br>    <span class="hljs-comment"># create_package(path)</span><br>    <span class="hljs-comment"># open_path = os.path.join(&#x27;current_path&#x27;, &#x27;b.txt&#x27;)</span><br>    o = Open(<span class="hljs-string">&#x27;t1.py&#x27;</span>, mode=<span class="hljs-string">&#x27;r&#x27;</span>)<br>    <span class="hljs-comment"># o.write(&#x27;&#x27;)</span><br>    data = o.read()<br>    print(data)<br></code></pre></td></tr></table></figure><h1 id="序列化">2. 序列化</h1><p>序列化就是：将对象信息或者数据结构信息通过一定规则进行转换进行文件存储或者网络传输。</p><p>可序列化的数据类型：</p><ul><li>number</li><li>str</li><li>list</li><li>tuple</li><li><strong>dict</strong>（最常用）</li></ul><h2 id="python的-json-模块">2.1 Python的 <code>json</code> 模块</h2><table><thead><tr class="header"><th>方法名</th><th>参数</th><th>介绍</th><th>举例</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><strong><code>dumps</code></strong></td><td>obj</td><td>对象序列化</td><td><code>json.dumps([1, 2])</code></td><td>字符串**</td></tr><tr class="even"><td><strong><code>loads</code></strong></td><td>str</td><td>反序列化</td><td><code>json.loads('[1, 2, 3]')</code></td><td>原始数据类型</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">path</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = f.read()<br><br>    <span class="hljs-keyword">return</span> json.loads(data)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">path, data</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">dict</span>):<br>            _data = json.dumps(data)<br>            f.write(_data)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;data should be list&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;top&#x27;</span>: <span class="hljs-number">182</span>&#125;<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    write(<span class="hljs-string">&#x27;test.json&#x27;</span>, data)<br>    result = read(<span class="hljs-string">&#x27;test.json&#x27;</span>)<br>    print(result, <span class="hljs-built_in">type</span>(result))<br>    result[<span class="hljs-string">&#x27;sex&#x27;</span>] = <span class="hljs-string">&#x27;boy&#x27;</span><br>    write(<span class="hljs-string">&#x27;test.json&#x27;</span>, result)<br></code></pre></td></tr></table></figure><h2 id="python的-pickle-模块">2.2 Python的 <code>pickle</code> 模块</h2><p><code>pickle</code> 模块没有 <code>json</code> 模块那么通用，不一定适用于其他语言。</p><table><thead><tr class="header"><th>方法名</th><th>参数</th><th>介绍</th><th>举例</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><strong><code>dumps</code></strong></td><td>obj</td><td>对象序列化</td><td><code>pickle.dumps([1, 2])</code></td><td>比特</td></tr><tr class="even"><td><strong><code>loads</code></strong></td><td>byte</td><td>反序列化</td><td><code>pickle.loads('[1, 2, 3]')</code></td><td>原始数据类型</td></tr></tbody></table><h2 id="yaml文件">2.3 yaml文件</h2><p>yaml文件：一种文本文件。一般用于配置文件。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210119094007079.png" width="60%" height="60%"></p><p>读取yaml文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yaml<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">path</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = f.read()<br>    result = yaml.load(data, Loader=yaml.FullLoader)<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    result = read(<span class="hljs-string">&#x27;test.yaml&#x27;</span>)<br>    print(result)<br>    <br>----------------------------------------------------<br>&#123;<span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>, <span class="hljs-string">&#x27;types&#x27;</span>: [<span class="hljs-string">&#x27;前端&#x27;</span>, <span class="hljs-string">&#x27;后端&#x27;</span>, <span class="hljs-string">&#x27;移动端&#x27;</span>], <span class="hljs-string">&#x27;python&#x27;</span>: &#123;<span class="hljs-string">&#x27;web&#x27;</span>: <span class="hljs-string">&#x27;django&#x27;</span>, <span class="hljs-string">&#x27;spider&#x27;</span>: <span class="hljs-string">&#x27;bs5&#x27;</span>&#125;, <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]&#125;<br></code></pre></td></tr></table></figure><p>yaml类型的文件在读取后得到的是字典类型的数据。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python模块和包</title>
    <link href="/2021/01/17/Python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
    <url>/2021/01/17/Python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>这篇文章整理了Python的模块和包的相关操作。</p><p><em><a id="more"></a></em></p><hr /><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/python模块和包.png" alt="pokeman-parameters" style="width:80%;"/></center><h1 id="python中的包">1. Python中的包</h1><ul><li><p>包就是文件夹，包中还可以有包，也就是子文件夹。</p></li><li><p>包里要有 <code>__init__.py</code> 文件才会被认为是python包。(相当于身份证；<code>__init__.py</code>文件里可以什么都没有)</p></li></ul><p>如何创建一个包？</p><ul><li>要有一个主题，明确功能，方便使用</li><li>层次分明，调用清晰</li></ul><h2 id="包的导入-import">1.1 包的导入 <code>import</code></h2><p>功能：<code>import package</code> 将python中的某个包(或模块)，导入到当前的py文件中</p><ul><li>package：被导入的包的名字。只会拿到对应包下 <code>__init__</code> 中的功能或当前模块下的功能。</li></ul><h1 id="python中的模块">2. Python中的模块</h1><p>一个python文件就是模块。</p><h2 id="模块的导入-from...import...">2.1 模块的导入 <code>from...import...</code></h2><p>功能：<code>from package import module</code> 通过从某个包中找到对应的模块。</p><ul><li><p><code>package</code> ：来源的包名</p></li><li><p><code>module</code> ：包中的目标模块</p></li></ul><p>举个栗子：</p><blockquote><p>----animal</p><p>|----dog</p><p>|----__ init__.py</p><p>​ |----action.py</p><p>|----cat</p><p>​ |----__ init__.py</p><p>​ |----action.py</p><p>|----t2.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> animal<br><span class="hljs-keyword">from</span> animal.dog <span class="hljs-keyword">import</span> action<br>action.run()  <span class="hljs-comment"># dog run</span><br><br><span class="hljs-keyword">from</span> animal.cat <span class="hljs-keyword">import</span> action<br>action.run()  <span class="hljs-comment"># cat run</span><br></code></pre></td></tr></table></figure><p><strong>我们发现两个包里有同名的函数，那怎么分别调用呢？</strong></p><p>答：<code>... as name</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> animal<br><span class="hljs-keyword">from</span> animal.dog <span class="hljs-keyword">import</span> action <span class="hljs-keyword">as</span> dog_action<br><span class="hljs-keyword">from</span> animal.cat <span class="hljs-keyword">import</span> action <span class="hljs-keyword">as</span> cat_action<br><br>dog_action.run()  <span class="hljs-comment"># dog run</span><br>cat_action.run()  <span class="hljs-comment"># cat run</span><br><br></code></pre></td></tr></table></figure><p><strong>如果是导入模块中的函数呢？</strong></p><p>在 <code>animal.__init__()</code> 文件里面写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .dog.action <span class="hljs-keyword">import</span> run <span class="hljs-keyword">as</span> dog_run<br><span class="hljs-keyword">from</span> .cat.action <span class="hljs-keyword">import</span> run <span class="hljs-keyword">as</span> cat_run<br></code></pre></td></tr></table></figure><blockquote><p><code>.</code> 代表当前目录。</p></blockquote><p>然后在同级别下的 <code>t2.py</code> 里写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> animal <span class="hljs-keyword">import</span> dog_run, cat_run<br><br>dog_run_result = dog_run()<br>cat_run_result = cat_run()<br> <br>print(dog_run_result)  <span class="hljs-comment"># dog run</span><br>print(cat_run_result)  <span class="hljs-comment"># cat run</span><br></code></pre></td></tr></table></figure><h1 id="python的-datatime-与-time">3. Python的 <code>datatime</code> 与 <code>time</code></h1><h2 id="datatime">3.1 <code>datatime</code></h2><p><code>datatime</code> ：日期与时间的结合体 -date and time</p><h3 id="获取当前时间">1. 获取当前时间</h3><p>返回当前年月日时分秒的datetime对象 <code>from datetime import datetime</code></p><h3 id="获取时间间隔">2. 获取时间间隔</h3><p>返回时间间隔的datetime对象 <code>from datetime import datetime</code> &amp; <code>from datetime import timedelta</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> timedelta<br><br>now = datetime.now()<br>print(now, <span class="hljs-built_in">type</span>(now))  <span class="hljs-comment"># 2021-01-17 13:28:58.455511 &lt;class &#x27;datetime.datetime&#x27;&gt;</span><br><br>three_days = timedelta(days=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 定义一个3天的时间间隔</span><br>after_three_days = now + three_days<br>print(after_three_days)  <span class="hljs-comment"># 2021-01-20 13:28:58.455511</span><br><br>before_three_days = now - three_days<br>print(before_three_days)  <span class="hljs-comment"># 2021-01-14 13:28:58.455511</span><br><br>one_hour = timedelta(hours=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 定义1个小时的时间间隔</span><br>before_one_hour = now - one_hour<br>print(before_one_hour)  <span class="hljs-comment"># 2021-01-17 12:28:58.455511</span><br></code></pre></td></tr></table></figure><h3 id="将时间对象转成时间字符串-strftime">3. 将时间对象转成时间字符串 <code>strftime</code></h3><p>获取时间对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br>now = datetime.now()<br></code></pre></td></tr></table></figure><p>时间转字符串：</p><p><code>data_str = now.strftime(format)</code></p><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> timedelta<br><br>now = datetime.now()<br>now_str = now.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)  <span class="hljs-comment"># 注意大小写</span><br>print(now_str, <span class="hljs-built_in">type</span>(now_str))  <span class="hljs-comment"># 2021-01-17 16:05:05 &lt;class &#x27;str&#x27;&gt;</span><br><br>three_days = timedelta(days=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 定义一个3天的时间间隔</span><br>after_three_days = now + three_days<br>after_three_days_str = after_three_days.strftime(<span class="hljs-string">&#x27;%Y/%m/%d %H:%M:%S&#x27;</span>)<br>print(after_three_days_str, <span class="hljs-built_in">type</span>(after_three_days_str))  <span class="hljs-comment"># 2021/01/20 16:05:05 &lt;class &#x27;str&#x27;&gt;</span><br><br>before_three_days = now - three_days<br>before_three_days_str = before_three_days.strftime(<span class="hljs-string">&#x27;%Y%m%d&#x27;</span>)<br>print(before_three_days_str, <span class="hljs-built_in">type</span>(before_three_days_str))  <span class="hljs-comment"># 20210114 &lt;class &#x27;str&#x27;&gt;</span><br><br>one_hour = timedelta(hours=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 定义1个小时的时间间隔</span><br>before_one_hour = now - one_hour<br>before_one_hour_str = before_three_days.strftime(<span class="hljs-string">&#x27;%H:%M:%S&#x27;</span>)<br>print(before_one_hour_str, <span class="hljs-built_in">type</span>(before_one_hour_str))  <span class="hljs-comment"># 16:08:14 &lt;class &#x27;str&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h3 id="将字符串转成时间类型-strptime">4. 将字符串转成时间类型 <code>strptime</code></h3><p>获取时间模块：<code>from datetime import datetime</code></p><p>时间字符串转时间类型：<code>datetime.strptime(tt, format)</code></p><ul><li><code>tt</code> ：符合时间格式的字符串</li><li><code>format</code> ：tt时间字符串匹配规则</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> timedelta<br><br>now = datetime.now()<br>print(now, <span class="hljs-built_in">type</span>(now))<br>now_str = now.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)  <span class="hljs-comment"># 注意大小写</span><br>print(now_str, <span class="hljs-built_in">type</span>(now_str))  <span class="hljs-comment"># 2021-01-17 16:05:05 &lt;class &#x27;str&#x27;&gt;</span><br>now_obj = datetime.strptime(now_str, <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<br>print(now_obj, <span class="hljs-built_in">type</span>(now_obj), <span class="hljs-string">&#x27;---&#x27;</span>)  <span class="hljs-comment"># 2021-01-17 16:25:33 &lt;class &#x27;datetime.datetime&#x27;&gt;</span><br><br>three_days = timedelta(days=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 定义一个3天的时间间隔</span><br>after_three_days = now + three_days<br>after_three_days_str = after_three_days.strftime(<span class="hljs-string">&#x27;%Y/%m/%d %H:%M:%S&#x27;</span>)<br>print(after_three_days_str, <span class="hljs-built_in">type</span>(after_three_days_str))  <span class="hljs-comment"># 2021/01/20 16:05:05 &lt;class &#x27;str&#x27;&gt;</span><br>after_three_days_obj = datetime.strptime(after_three_days_str, <span class="hljs-string">&#x27;%Y/%m/%d %H:%M:%S&#x27;</span>)  <span class="hljs-comment"># 必须与after_three_days_str的年月日时分秒一一对应</span><br>print(after_three_days_obj, <span class="hljs-built_in">type</span>(after_three_days_obj), <span class="hljs-string">&#x27;---&#x27;</span>)  <span class="hljs-comment"># 2021-01-20 16:29:38 &lt;class &#x27;datetime.datetime&#x27;&gt;</span><br><br>before_three_days = now - three_days<br>print(before_three_days)<br>before_three_days_str = before_three_days.strftime(<span class="hljs-string">&#x27;%Y%m%d&#x27;</span>)<br>print(before_three_days_str, <span class="hljs-built_in">type</span>(before_three_days_str))  <span class="hljs-comment"># 20210114 &lt;class &#x27;str&#x27;&gt;</span><br>before_three_days_obj = datetime.strptime(before_three_days_str, <span class="hljs-string">&#x27;%Y%m%d&#x27;</span>)<br>print(before_three_days_obj, <span class="hljs-built_in">type</span>(before_three_days_obj), <span class="hljs-string">&#x27;---&#x27;</span>)  <span class="hljs-comment"># 2021-01-14 00:00:00 &lt;class &#x27;datetime.datetime&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>注：记一些常用的时间格式字符</p><table><thead><tr class="header"><th>字符</th><th>介绍</th></tr></thead><tbody><tr class="odd"><td>%Y</td><td>完整的年份，如2021</td></tr><tr class="even"><td>%m</td><td>月份，1-12</td></tr><tr class="odd"><td>%d</td><td>月份中的一天，1-31</td></tr><tr class="even"><td>%H</td><td>一天中的第几个小时(24h)，00-23</td></tr><tr class="odd"><td>%I</td><td>一天中的第几个小时(12h)，01-12</td></tr><tr class="even"><td>%M</td><td>当前的第几分(00-59)</td></tr><tr class="odd"><td>%S</td><td>当前分的第几秒(00-61)(多出来的两秒是闰年的)</td></tr><tr class="even"><td>%f</td><td>当前秒的第几毫秒</td></tr><tr class="odd"><td>%a</td><td>简化的星期，如星期三 Wed</td></tr><tr class="even"><td>%A</td><td>完整的星期，如星期三 Wedensday</td></tr><tr class="odd"><td>%b</td><td>简化的月份，如二月 Feb</td></tr><tr class="even"><td>%B</td><td>完整的月份，如二月 February</td></tr><tr class="odd"><td>%c</td><td>本地日期和时间，如 Sun Jan 17 19:04:01 2021</td></tr></tbody></table><h2 id="time">3.2 <code>time</code></h2><p>时间戳 <code>timestamp</code>：1070年1月1日0时0分0秒至今的总毫秒(秒)数。是一个 <code>float</code> 类型</p><h3 id="生成时间戳函数-time">1. 生成时间戳函数 <code>time</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>time.time()  <span class="hljs-comment"># 返回秒级别的浮点类型</span><br></code></pre></td></tr></table></figure><p><strong><code>datetime</code> 包生成时间戳与时间戳转时间类型的方法</strong>：</p><p>1.<code>datetime</code> 时间对象也可以生成时间戳，只不过是<u>先生成时间戳函数</u>，再赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>now = datetime.datetime.now()<br>now_tomestamp = datetime.datetime.timestamp(now)<br></code></pre></td></tr></table></figure><blockquote><ul><li>now：datetime时间对象</li></ul></blockquote><p>2.<code>datetime</code> 时间戳也可以转回时间对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br>datetime.datetime.fromtimestamp(timestamp)<br></code></pre></td></tr></table></figure><blockquote><ul><li>timestamp：时间戳</li></ul><p>这个函数会返回一个时间戳对象</p></blockquote><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br>datetime_now = datetime.datetime.now()<br>datetime_timestamp = datetime.datetime.timestamp(datetime_now)<br>print(<span class="hljs-string">&#x27;datetime生成的时间戳 %s&#x27;</span> % datetime_timestamp)<br><br>datetime_obj = datetime.datetime.fromtimestamp(datetime_timestamp)  <span class="hljs-comment"># 时间戳转为时间对象</span><br>print(datetime_obj)<br><br>--------------------------------------<br>datetime生成的时间戳 <span class="hljs-number">1610885937.031843</span><br><span class="hljs-number">2021</span>-01-<span class="hljs-number">17</span> <span class="hljs-number">20</span>:<span class="hljs-number">18</span>:<span class="hljs-number">57.031843</span><br></code></pre></td></tr></table></figure><h3 id="获取本地时间函数-localtime">2. 获取本地时间函数 <code>localtime</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>time.localtime(timestamp)  <span class="hljs-comment"># 时间戳参数可以不传</span><br></code></pre></td></tr></table></figure><h3 id="暂停函数-sleep">3. 暂停函数 <code>sleep</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>time.sleep(second)  <span class="hljs-comment"># second: 希望被暂停的秒数</span><br></code></pre></td></tr></table></figure><h3 id="time-中的-strftime-时间转字符串">4. <code>time</code> 中的 <code>strftime</code> (时间转字符串)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>time.strftime(<span class="hljs-built_in">format</span>, t)  <br></code></pre></td></tr></table></figure><blockquote><p>参数：</p><ul><li><code>format</code>：格式化规范</li><li><code>t</code>：<code>time.localtime</code> 对应的时间类型</li></ul><p>与<code>datetime</code> 中的 <code>strftime()</code> 完全一致，只不过这里对应的应该是 <code>time</code> 对象</p></blockquote><h3 id="time-中的-strptime-字符串转时间">5. <code>time</code> 中的 <code>strptime</code> (字符串转时间)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>time.strptime(time_str, <span class="hljs-built_in">format</span>)  <br></code></pre></td></tr></table></figure><blockquote><p>参数：</p><ul><li><code>time_str</code> ：符合<u>时间格式标准</u>的字符串</li><li><code>format</code>：确保与 <code>time_str</code> 完全一致的格式化标准</li></ul><p>与<code>datetime</code> 中的 <code>strftime()</code> 完全一致，只不过这里对应的应该是 <code>time</code> 对象</p></blockquote><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br>now = time.time()<br>print(now, <span class="hljs-built_in">type</span>(now))  <span class="hljs-comment"># 1610884104.6186714 &lt;class &#x27;float&#x27;&gt;</span><br><br>time_obj = time.localtime(now)<br>print(time_obj, <span class="hljs-built_in">type</span>(time_obj))<br><span class="hljs-comment"># time.struct_time(tm_year=2021, tm_mon=1, tm_mday=17, tm_hour=20, tm_min=22, tm_sec=25, tm_wday=6, tm_yday=17, tm_isdst=0) &lt;class &#x27;time.struct_time&#x27;&gt;</span><br><br><span class="hljs-comment"># time.sleep(3)</span><br>current_time_obj = time.localtime()<br>print(current_time_obj)<br><span class="hljs-comment"># time.struct_time(tm_year=2021, tm_mon=1, tm_mday=17, tm_hour=20, tm_min=22, tm_sec=28, tm_wday=6, tm_yday=17, tm_isdst=0)</span><br><br>before = now - <span class="hljs-number">1e5</span>  <span class="hljs-comment"># 减去十万秒</span><br>before_time_obj = time.localtime(before)<br>print(before_time_obj)<br><span class="hljs-comment"># time.struct_time(tm_year=2021, tm_mon=1, tm_mday=16, tm_hour=16, tm_min=35, tm_sec=45, tm_wday=5, tm_yday=16, tm_isdst=0)</span><br><br>print(time.time() * <span class="hljs-number">1000</span> )  <span class="hljs-comment"># 毫秒级别</span><br>print(time.time())<br></code></pre></td></tr></table></figure><h1 id="python内置库-os-模块">4. Python内置库 <code>os</code> 模块</h1><h2 id="os文件与目录函数">4.1 os文件与目录函数</h2><p>常见的os文件与目录函数介绍</p><table><thead><tr class="header"><th>函数名</th><th>参数</th><th>介绍</th><th>举例</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>getcwd()</code></td><td>无</td><td>返回当前的路径</td><td><code>os.getcwd()</code></td><td>字符串</td></tr><tr class="even"><td><code>listdir()</code></td><td>path</td><td>返回制定路径下所有的文件或文件夹</td><td><code>os.listdir('c://Windows')</code></td><td>返回一个列表</td></tr><tr class="odd"><td><code>makedirs()</code></td><td>path</td><td>创建多级文件夹</td><td><code>os.makedirs('d://code/py')</code></td><td>无</td></tr><tr class="even"><td><code>removedirs()</code></td><td>path（可以写相对路径）</td><td>删除多级文件夹</td><td><code>os.removedirs('d://code/py')</code></td><td>无</td></tr><tr class="odd"><td><code>rename()</code></td><td>Oldname, newname</td><td>给文件或文件夹改名</td><td><code>os.rename('d://code', 'd://co')</code></td><td>无</td></tr><tr class="even"><td><code>rmdirs()</code></td><td>path</td><td>只能删除空文件夹</td><td><code>os.makedirs('d://code')</code></td><td>无</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">current_path = os.getcwd()<br>print(current_path)  <span class="hljs-comment"># D:\mycode\myPythonTest</span><br><br><br>new_path = <span class="hljs-string">&#x27;%s/test1&#x27;</span> % current_path<br><span class="hljs-comment"># os.makedirs(new_path)</span><br><br>data = os.listdir(current_path)<br>print(data)  <span class="hljs-comment"># [&#x27;.idea&#x27;, &#x27;animal&#x27;, &#x27;Currency_Exchange.py&#x27;, &#x27;t1.py&#x27;, &#x27;t2.py&#x27;, &#x27;test1&#x27;, &#x27;time.py&#x27;, &#x27;__pycache__&#x27;]</span><br><br>new_path2 = <span class="hljs-string">&#x27;%s/test2/abc&#x27;</span> % current_path<br>os.makedirs(new_path2)<br></code></pre></td></tr></table></figure><h2 id="os.path-模块">4.2 <code>os.path</code> 模块</h2><p><code>os.path</code> 模块常用的方法。</p><table><thead><tr class="header"><th>函数名</th><th>参数</th><th>介绍</th><th>举例</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>exists</code></td><td>Path</td><td>文件或路径是否存在</td><td>os.path.exists(‘d://’)</td><td>bool类型</td></tr><tr class="even"><td><code>isdir</code></td><td>Path</td><td>是否是路径</td><td>os.path.isdir(‘d://’)</td><td>bool类型</td></tr><tr class="odd"><td><code>isabs</code></td><td>Path</td><td>是否是绝对路径</td><td>os.path.isabs(‘test’)</td><td>bool类型</td></tr><tr class="even"><td><code>isfile</code></td><td>Path</td><td>是否是文件</td><td>os.path.isfile(‘d://a.py’)</td><td>bool类型</td></tr><tr class="odd"><td><code>join</code></td><td>Path, path*</td><td>路径字符串合并</td><td>os.path.join(‘d://’, ‘test’)</td><td>字符串</td></tr><tr class="even"><td><code>split</code></td><td>Path</td><td>以<strong>最后一层路径为基准切割</strong></td><td>os.path.split(‘d://test’)</td><td>列表</td></tr></tbody></table><h1 id="python的-sys-模块">5. Python的 <code>sys</code> 模块</h1><p><code>sys</code> 模块中的常用方法</p><table><thead><tr class="header"><th>函数名</th><th>参数</th><th>介绍</th><th>举例</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td><code>modules</code></td><td>无</td><td>py启动时加载的模块</td><td>sys.modules</td><td>列表</td></tr><tr class="even"><td><code>path</code></td><td>无</td><td>返回当前py的环境路径</td><td>sys.path</td><td>列表</td></tr><tr class="odd"><td><code>exit</code></td><td>arg</td><td>退出程序</td><td>sys.exit(0)</td><td>无</td></tr><tr class="even"><td><code>getdefaultencoding</code></td><td>无</td><td>获取系统编码</td><td>sys.getdefaultencoding()</td><td>字符串</td></tr><tr class="odd"><td><code>platform</code></td><td>无</td><td>获取当前系统平台</td><td>sys.platform</td><td>字符串</td></tr><tr class="even"><td><code>version</code></td><td>无</td><td>获取python版本</td><td>sys.version</td><td>字符串</td></tr><tr class="odd"><td><code>argv</code></td><td>*arg</td><td>程序外部获取参数</td><td>sys.argv</td><td>列表</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序与快速选择算法</title>
    <link href="/2021/01/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>第一次是在数据结构课学的快速排序。基本思路是：令 <code>i = l; j = r</code> ，选最左边的数为pivot。<code>j --</code>从后向前找比它小的数，找到后与pivot交换。再 <code>i ++</code> 从前往后找比它大的数，找到后与pivot交换。再重复执行这一过程，直到 <code>i == j</code> 时，就找到了pivot的位置。再分别递归直至顺序。学了y总的方法感觉更聪明，是一种双指针快排的思路。</p><p>快速选择算法是快速排序的一种变形。通常用在未排序的数组中寻找第k小/第k大的元素。快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 <span class="math inline">\(O(n logn)\)</span> 至 <span class="math inline">\(O(n)\)</span> ，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span> 。</p><p><em><a id="more"></a></em></p><h1 id="快速排序算法双指针排序">快速排序算法(双指针排序)</h1><h2 id="思路">思路</h2><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/快速排序/quick_sort.jpg" style="zoom: 67%;" /></p><ol start="0" type="1"><li><strong>注意递归要退出！记得写退出条件！<code>if(l &gt;= r)</code> 时退出</strong></li><li><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</li><li><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</li><li><strong>递归处理左右两端</strong> (又回到0)</li></ol><h2 id="时间复杂度">时间复杂度</h2><p>平均时间复杂度 <span class="math inline">\(O(nlogn)\)</span>，最坏情况下 <span class="math inline">\(O(n^2)\)</span>，在数组已排好序的情况下出现，可以通过随机化或者取中点来避免最差情况。</p><blockquote><p>数学推导证明过程挺复杂的。算法导论上有，用主定理证明的，很详细。但是没法简化</p></blockquote><h2 id="快排模板">快排模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 循环退出条件</span><br><br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意值和下角标的区别。</span><br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);  <span class="hljs-comment">// 边界不要写错</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="注意">注意</h2><h3 id="边界情况分析">1、边界情况分析。</h3><p>快排属于<strong>分治算法</strong>，最怕的就是 <code>n分成0和n</code>，或 <code>n分成n和0</code>，这会造成<strong>无限划分</strong>(死循环)</p><ol type="1"><li><p><strong>以 <code>j</code> 为划分时，<code>x</code> 不能选 <code>q[r]</code> (若以 <code>i</code> 为划分,则 <code>x</code> 不能选 <code>q[l]</code> )</strong></p><p>假设 <code>x = q[r]</code>：关键句子 <code>quick_sort(q, l, j), quick_sort(q, j + 1, r)</code></p><p>因为 <code>j</code> 的最小值是 <code>l</code>，所以 <code>[j + 1, r]</code> 不会造成无限划分，</p><p>但<code>[l..j]</code>(即 <code>quick_sort(q, l, j)</code> )却可能造成无限划分，因为 <code>j</code> 可能为 <code>r</code></p><p>举例来说，若 <code>x</code> 选为 <code>q[r]</code> ，数组中 <code>q[l..r-1] &lt; x</code> ，</p><p>那么这一轮循环结束时 <code>i = r, j = r</code>，这就造成了无限划分。</p><p>以 <code>0, 1</code> 这组数据为例，<code>x = q[r] = 1</code>，<code>do i ++ ; while(q[i] &lt; x)</code> ，</p><p>则 <code>i = 1 = r</code> ，<code>do j -- ; while(q[j] &gt; x)</code> ，则 <code>j = 1 = r</code> 。</p><p>则 <code>[0, 1]</code> 被划分成 <code>[0, 1]</code> 和 <code>[2, 1]</code> ，这就造成无限划分，即死循环。</p><blockquote><p>边界情况复杂，建议 <code>x = q[l + r &gt;&gt; 1]</code> 。</p></blockquote></li><li><p><strong><code>do i++; while(q[i] &lt; x)</code> 和 <code>do j--; while(q[j] &gt; x)</code> 不能用 <code>q[i] &lt;= x</code> 和 <code>q[j] &gt;= x</code>。</strong></p><p>举个栗子，比如 取的 <code>x</code> 刚好是数据里的最大值，执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>i+1</code>，交换的时候就是 <code>q[i + 1]</code> 和 <code>q[j]</code> 交换了，这显然不对。</p><p>或者举个极端情况，假设 <code>q[l..r]</code> 全相等，则执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>r+1</code>，然后继续执行 <code>q[i] &lt;= x</code> 判断条件，造成数组下标越界(但这貌似不会报错)。</p><p>并且如果之后的 <code>q[i] &lt;= x</code> (此时 <code>i &gt; r</code> ) 条件也不幸成立，就会造成一直循环下去(亲身实验)，造成内存超限 <code>(Memory Limit Exceeded)</code></p></li><li><p><code>if(i &lt; j) swap(q[i], q[j])</code> 能否使用 <code>i &lt;= j</code> ？</p><p><strong>可以使用 <code>if(i &lt;= j) swap(q[i], q[j]);</code></strong></p><p>因为 i = j 时，交换一下 <code>q[i],q[j]</code> 也就是交换自己，无影响，马上就会跳出循环了</p></li><li><p>最后一句能否改用 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 作为划分(用 <code>i</code> 做划分时也是同样的道理,)</p><p><strong>不能</strong>。根据之前的证明，最后一轮循环可以得到这些结论</p><ul><li><code>q[l..i-1] &lt;= x, q[i...r] &gt;= x</code></li><li><code>q[l...j] &lt;= x, q[j+1..r] &gt;= x</code></li><li><code>j &lt;= i</code></li></ul><p>所以，<code>q[l..j-1] &lt;= x</code> 是显然成立的，</p><p>但 <code>quick_sort(q, j, r)</code> 中的 <code>q[j]</code> 却是 <code>q[j] &lt;= x</code> ，这不符合快排的要求</p><p>另外一点，注意 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 可能会造成无线划分</p><p>当 <code>x</code> 选为 <code>q[l]</code> 时会造成无限划分，报错为(MLE),</p><p>如果手动改为 <code>x = q[r]</code>，可以避免无限划分。</p><p>但是上面所说的 <code>q[j] &lt;= x</code> 的问题依然不能解决，这会造成 <code>WA (Wrong Answer)</code></p></li><li><p><strong><code>j</code> 的取值范围为 <code>[l..r-1]</code></strong> (这块还是不太懂....)</p><p>证明：<strong>反证法</strong></p><p>假设 <code>j</code> 最终的值为 <code>r</code> ,说明只有一轮循环(两轮的话 <code>j</code> 至少会自减两次)</p><p>说明 <code>q[r] &lt;= x</code> (因为要跳出 <code>do-while</code> 循环)</p><p>说明 <code>i &gt;= r</code>( <code>while</code> 循环的结束条件), <code>i</code> 为 <code>r</code> 或 <code>r + 1</code>(必不可能成立)</p><p>说明 <code>i</code> 自增到了 <code>r</code> , 说明 <code>q[r] &gt;= x</code> 和 <code>q[l..r-1] &lt; x</code>，</p><p>得出 <code>q[r] = x</code> 和 <code>q[l..r-1] &lt; x</code> 的结论，但这与 <code>x = q[l + r &gt;&gt; 1]</code> 矛盾</p><p><strong>反证法</strong>得出 <code>j &lt; r</code></p><p>假设 <code>j</code> 可能小于 <code>l</code> 说明 <code>q[l..r] &gt; x</code> ,矛盾</p><p><strong>反证法</strong>得出 <code>j &gt;= l</code></p><p>所以 <code>j</code> 的取值范围为 <code>[l..r-1]</code> ，不会造成无限划分和数组越界</p></li></ol><p>顺带一提用 <code>i</code> 做划分时的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];  <span class="hljs-comment">// 注意是向上取整,因为向下取整可能使得x取到q[l]</span><br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    quick_sort(q, l, i - <span class="hljs-number">1</span>), quick_sort(q, i, r);  <span class="hljs-comment">// 不用q[l..i],q[i+1..r]划分的道理和分析4中j的情况一样</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还有从大到小排序的模板(仅仅改两个地方的判断符号)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &gt; x);  <span class="hljs-comment">// 这里和下面</span><br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &lt; x);  <span class="hljs-comment">// 这行的判断条件改一下</span><br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);<br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="元素值-和-q角标-的区别">2、<code>元素值</code> 和 <code>q[角标]</code> 的区别</h3><p>我之前一直搞错了角标的问题。正确写法是 <code>x = q[l + r &gt;&gt; 1]</code> ，我总是写成 <code>x = l + r &gt;&gt; 1; ...q[i] &lt; q[x]</code>。好蠢，一直没弄清楚 <strong><code>元素值</code> 和 <code>q[角标]</code> 的区别</strong>。<code>元素值</code> 就是一个数字，而 <code>q[角标]</code> 表示角标所在位置的值，相当于一个坑。快排在交换元素时，可能这个坑里的元素会有变化，而快排想要的仅仅是一个作为比较的值，模板里选了中间位置的元素值，而不是这个位置的数。之前一直没想通这个问题，直到模拟了一个错误样例才想明白。</p><blockquote><p>错误样例为：49，59，88，37，98，97，68，54，31，3</p></blockquote><p>以后遇到错误也要<u>多模拟样例</u>，自己想明白才是真的明白，不然也不会背了四五遍模板也记不清楚。</p><hr /><h2 id="例题">例题</h2><h3 id="acwing-785.-快速排序">1. <a href="https://www.acwing.com/problem/content/787/">AcWing 785. 快速排序</a></h3><p>给定你一个长度为n的整数数列。</p><p>请你使用快速排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><p><strong>输入格式</strong></p><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(10^9\)</span> 范围内），表示整个数列。</p><p><strong>输出格式</strong></p><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(1≤n≤100000\)</span></p><p><strong>输入样例</strong>：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><blockquote><p>模板题</p></blockquote><p><strong>code</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j ) swap(q[i], q[j]);<br>    &#125;    <br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ;i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    quick_sort(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><h1 id="快速选择算法">快速选择算法</h1><p>快速选择算法是快速排序的一种变形。通常用在未排序的数组中寻找第k小/第k大的元素。</p><h2 id="思路-1">思路</h2><p>快速选择的总体思路与快速排序一致。</p><ol type="1"><li><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</li><li><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</li><li><strong>递归处理k在的一端</strong>：快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。直至 <code>if (l &gt;= r) return q[l];</code> 。其中 <code>q[l]</code> 或者 <code>q[r]</code> 都可以，因为最后一次递归数组里只有一个数，就是要找的数。</li></ol><h2 id="时间复杂度-1">时间复杂度</h2><p>快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 <span class="math inline">\(O(n logn)\)</span> 至 <span class="math inline">\(O(n)\)</span> ，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span> 。</p><p>第一层：<span class="math inline">\(O(n)\)</span></p><p>第二层：<span class="math inline">\(O(n/2)\)</span></p><p>第三层：<span class="math inline">\(O(n/4)\)</span></p><p>...</p><p>所以：<span class="math inline">\(O(n·(1 + \frac{1}{2}+ \frac{1}{4} + ... + \frac{1}{n})) &lt;= O(2n) = O(n)\)</span></p><h2 id="快速选择模板">快速选择模板</h2><blockquote><p>快速选择算法：类似快排+二分，k在哪半部分，就递归哪个部分。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quick_xuan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];  <span class="hljs-comment">// q[l]/q[r]都可以，因为最后一次递归数组里只有一个数</span><br>    <br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> left_num = j - l + <span class="hljs-number">1</span>;  <span class="hljs-comment">// left_num: 左边的数有多少个</span><br>    <br>    <span class="hljs-keyword">if</span> (k &lt;= left_num) quick_xuan(q, l, j, k);  <span class="hljs-comment">// 递归左半边</span><br>    <span class="hljs-keyword">else</span> quick_xuan(q, j + <span class="hljs-number">1</span>, r, k - (j - l + <span class="hljs-number">1</span>));  <span class="hljs-comment">// 递归右半边</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题-1">例题</h2><h3 id="acwing-786.-第k个数">1. <a href="https://www.acwing.com/problem/content/788/">AcWing 786. 第k个数</a></h3><p>给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span>。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个整数（所有整数均在 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(10^9\)</span>范围内），表示整数数列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示数列的第k小数。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(1≤n≤100000\)</span>, <span class="math inline">\(1≤k≤n\)</span></p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><blockquote><p>模板题</p></blockquote><p><strong>code</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;algorithm&gt;</span><br><br>using namespace std;<br><br>const <span class="hljs-built_in">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">int</span> q[N];<br><span class="hljs-built_in">int</span> n, k;<br><br><span class="hljs-built_in">int</span> quick_xuan(<span class="hljs-built_in">int</span> q[], <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r, <span class="hljs-built_in">int</span> k)<br>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];  // q[l]/q[r]都可以，因为最后一次递归数组里只有一个数<br>    <br>    <span class="hljs-built_in">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        do i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        do j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">int</span> left_num = j - l + <span class="hljs-number">1</span>;  // left_num: 左边的数有多少个<br>    <br>    <span class="hljs-keyword">if</span> (k &lt;= left_num) quick_xuan(q, l, j, k);  // 递归左半边<br>    <span class="hljs-keyword">else</span> quick_xuan(q, j + <span class="hljs-number">1</span>, r, k - (j - l + <span class="hljs-number">1</span>));  // 递归右半边<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];<br>    <br>    cout &lt;&lt; quick_xuan(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acwing-104.-货仓选址">2. <a href="https://www.acwing.com/problem/content/106/">AcWing 104. 货仓选址</a></h3><blockquote><p>此题需要贪心算法。我还不会，留个坑以后填。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>快速排序</tag>
      
      <tag>快速选择</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小张同学的2020年度总结</title>
    <link href="/2020/12/31/%E5%B0%8F%E5%BC%A0%E2%80%98s2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/31/%E5%B0%8F%E5%BC%A0%E2%80%98s2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Emmm....感觉没啥可写的，又觉得有好多话想说。</p><p>其实2020年对我而言是蛮重要的一年，是我的保研之路最后冲刺阶段。相较于其他人而言，我缺少了也许是最后一次大战命运的机会，第一次是高考，我已经错过了，而且现在想来十分后悔，当初的幼稚与不自律，让所有人都看不起我，走错了一步就改变了一生。第二次，也许就是最后一次，就是考研。既遗憾又稍有一点的开心，遗憾是因为我总有一点不甘心，总觉着我能凭借自己的努力去更好的地方，而又庆幸自己没有选择考研，因为不可控的因素实在是太多，我怕坚持不下来。</p><p>也许是上天的惩罚，又也许是上天的赏赐，我最后还是去了东北大学。我以为我可以有其他的选择，可是我还是和其他人一样。我曾经在很丧的时候写过一篇很倔强的日记，希望得到结果的那一天可以扬眉吐气的发出来，结果还是没有那一天。那句”趁着年轻，我偏要勉强“，我还是没做到，想起来还蛮讽刺的。反思这三年，做的最对的就是为了自己的目标一直努力的前进着，做的最错的就是太封闭自我，丝毫不了解这个专业到底需要什么，也就是没有方向的努力，方向的偏离导致了很多时候都是事倍功半。</p><p>看了今年写的日记，概括起来也是我这三年的总结：<strong>“你配不上自己的野心，也辜负了曾经的苦难。”</strong>。</p><p>今年的关键字写在了日记的第一大页，<strong>“不服输”</strong>。今年的日记基本上都是关于小二的，诸如”为什么他行，我不行“之类的。直到后来我才发现，每当我觉得我快要追上他的时候，他总是会更加牛逼的出现在我面前，像是在对我说”放弃吧小辣鸡，你永远不如我“。其实我也是这么想的，每当我以为，你行我也行的时候，就发现，我还是差了十万八千里。后来我发现我不仅欠缺的太多，而且我总是在追赶他的步伐。在这个过程中，我像是杀红了眼，只顾着追赶，忘记了我的目标我的方向。再后来，慢慢的，我不知道是因为自己明知道自己追不上他了，还是累了懒惰了，我觉得这两种都有，我开始放弃了。最后，我彻底放弃了，一定有前两种原因在里面，我告诉自己，每个人都有自己的目标和方向，你何必追逐别人呢，你为什么要走他的路呢。而且，你有思考过你的方向吗。终于停下了追赶他人的脚步，虽然每次看到他有更好的成绩我依旧不甘心，可是我也做不了什么，我也就不打算做什么了。看着自己一年的日记全都是不服输，真的是......一言难尽。</p><p>说到今年的保研，就是另一个关键词，<strong>“不甘心”</strong>。今年的遗憾也蛮多的。院校真的看了很多，也换了很多。因为心气高，所以不敢相信，但我知道，那些真的也是我力不能及。最开始的王恺老师，到魏乐义老师，到后来的王巍老师，到最后的王鹏飞老师。尤其是王鹏飞老师，我是真的不甘心。王老师人是真的好，电话聊了那么多，真的感觉特别合得来，这是我非常喜欢的亦师亦友的感觉。可惜今年连尝试的机会都没有，不然也许都不会这么感觉遗憾。很难过错过了王鹏飞老师，都是命中注定，每个努力的瞬间，每个懒惰的瞬间，种种无数的叠加造成了今天的遗憾， 说后悔早已来不及。以后我会将王老师设立为自己的标杆，一切靠自己，如果我未来也想成为老师的话，他就是我的榜样。最后到了马老师，我跟马老师的接触并不多，但了解到他是一位为人不错的老师，看未来的日子了，来日方长，希望一切顺利吧。还记得和温可瑞学长的那通电话，整个电话的核心思想就是他告诉我：“<strong>做想清楚自己的底线，做好心理建设；然后就去拼吧！</strong>想清楚自己的底线，也就是最差结果会到什么程度，然后就没什么可怕的了，拼吧！不顾一切地拼就好了！“。我会受教，并用之于未来的路。感谢一路上所有帮助我的人，谢谢你们。</p><p>写着写着想起了一些事。想起了我有多么渴望得奖，证明给别人看，我也行，最后也水到了比赛得的奖。想起了我刚开始多么想去王恺那里，结果因为没有能力也没有好好准备，搞砸了我人生的第一场面试，每次想起来都觉得都丢人。想起了我今年用过的乱七八糟的壁纸。想起来一个从未谋面只因为一封邮件，就给我打电话的学长讲述了他的很多感悟的那一通电话。想起来和王鹏飞老师打电话的那个下午。想起来得到结果的那一晚哭了一整夜。想起了我的家人丢了身份证银行卡，我惊慌失措不知道怎么办只能干着急。好多画面涌现出来......2020对我来说真的是糟糕的一年，烦心事很多，真的很丧。这糟糕的一年终于要结束了......GoodBye!</p><p>写完这些话，伴随着一首温暖的不知名曲子，刚好是2021年了，词穷的我依然想不出什么美好的句子告别过去。刚好换了一首曲子，那就迎新吧：<strong>Tomorrow will be fine.</strong></p><p>放几张对于我的2020有纪念性意义的照片吧。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/NK_0.jpg" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/NK_4.jpg" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/NK_1.jpg" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/talk.png" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/tower.jpg" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/mont.jpg" /></p><p><strong>置身于这样的环境去学习 和 在这样的环境下依旧能学进去习 都是能力的体现。</strong></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/room.jpg" /></p><hr /><p>希望明年加以改进的地方：</p><ul><li><strong>沉下心来。</strong>觉得自己在学习的时候很浮躁，而且学东西很浮很浅很表面，看了别人写的文章感觉就是有自己的思考在里面，而我是一味的照搬或者翻译，缺少思考在里面。希望以后能沉下来学东西。</li><li><strong>学会思考。</strong><ul><li>做事之前三思，这件事做了会有什么影响，我应该做好哪些准备，做事的顺序，会出现什么样的结果，我该如何应对之类的...</li><li>说话之前三思，这句话该不该说，会有什么后果。</li></ul></li><li><strong>提高情商。</strong>做一个情商高，但又不会是过于精明的让人不舒服的人。</li><li><strong>学会总结</strong>。不论学习还是做事，一定要复盘总结，学完就扔掉，跟没学一样。整理整个学习的过程！</li></ul><p>希望明年达成的目标：</p><ul><li><p>[ ] 毕业前决定好短期未来的路和方向。</p></li><li><p>[ ] 毕业前瘦10斤并将体重维持在115.</p></li><li><p>[x] 毕业设计拿优。</p></li><li><p>[ ] 毕业前学完前端课程。</p></li><li><p>[ ] 刷完基础算法题。</p></li><li><p>[ ] 总结完机器学习算法。</p></li><li><p>[ ] 学习PyTorch</p></li><li><p>[ ] 看完35篇论文并总结。</p></li><li><p>[ ] 参加一次数据科学竞赛并认真总结。</p><div>            <input type="checkbox" disabled >普通示例          </div></li></ul>]]></content>
    
    
    <categories>
      
      <category>小张日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小张日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记</title>
    <link href="/2020/11/14/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/14/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这里记录了Python的一些基本知识点。</p><p><em><a id="more"></a></em></p><h1 id="基础知识">1. 基础知识</h1><h2 id="编译器与解释器">1.1 编译器与解释器</h2><p>编译器/解释器：<strong>高级语言与机器之间的翻译官</strong></p><p>都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程有不同而已。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201028172837820.png" alt="image-20201028172837820" /><figcaption>image-20201028172837820</figcaption></figure><p>用一个通俗的例子进行比喻：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201028172917342.png" alt="image-20201028172917342" /><figcaption>image-20201028172917342</figcaption></figure><ul><li>程序入口的编写：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    print(<span class="hljs-string">&quot;hello world&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="标识符就是变量名">1.2 标识符(就是变量名)</h2><p>所谓的标识符就是对变量、常量、函数、类等对象起的名字，变量名。</p><p>Python对于标识符的命名有如下规定：</p><ul><li><p>第一个字符必须是字母表中的字母或下划线 **‘_’** ，标识符的其他的部分由字母、数字和下划线组成</p></li><li>标识符对大小写敏感，严格区分大小写！</li><li><p>变量的命名不要用关键字和内置函数的名字</p></li></ul><p>一些代码规范：</p><ul><li>变量名全部小写，常量名全部大写</li><li>函数和方法名用小写加下划线， <code>count_star</code></li><li>类名用大写驼峰，每个单词的首字母大写， <code>ThreadMixIn</code></li><li>模块和包的名字用小写</li></ul><h2 id="变量与常量">1.3 变量与常量</h2><ul><li><p>Python 中的变量不需要声明类型。变量可以直接使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">4</span><br>b = <span class="hljs-string">&quot;xiaozhang&quot;</span><br>c = []<br>d = <span class="hljs-number">9</span>-<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li><p>用“=”号来给变量赋值，从右往左的计算顺序。</p></li><li><p>每个变量在使用前都必须赋值，变量赋值以后才会被创建。</p></li><li><p>在Python中，变量本身没有数据类型的概念，通常所说的“变量类型”是变量所引用的对象的类型，或者说是变量的值的类型。</p></li><li><p>Python允许同时为多个变量赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = b = c = <span class="hljs-number">1</span>，最终大家都是<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure></li><li><p>也可以同时为多个变量赋值，用逗号分隔，逐一对应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>，最后a是<span class="hljs-number">1</span>，b是<span class="hljs-number">2</span>，c是<span class="hljs-number">3.</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Python中，一切事物都是对象，变量引用的是对象或者说是对象在内存中的地址。</strong></p><ul><li><p>栗子：a = 'ABC'时，Python解释器干了两件事情：</p><ul><li>在内存中创建了一个‘ABC’的字符串对象；</li><li>在内存中创建了一个名为a的变量，并把它指向'ABC'。</li></ul></li><li><p>栗子：a和b是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;Jack&#x27;</span><br>b = a<br>a = <span class="hljs-string">&#x27;Tom&#x27;</span><br>print(b)<br>print(a)<br></code></pre></td></tr></table></figure><ul><li>执行a = ‘Jack’，解释器创建字符串‘Jack’对象和变量a，并把a指向‘Jack’对象；</li><li>执行b = a,解释器创建变量b，并且将其指向变量a指向的字符串‘Jack’对象。</li><li>执行a = ‘Tom’,解释器创建字符串‘Tom’对象，并把a改为指向‘Tom’对象，与b无关。</li></ul><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/image-20201028163331835.png" /></p></li></ul></li></ul><h2 id="输入输出">1.4 输入输出</h2><h3 id="input输入函数">1.4.1 input输入函数</h3><p>input函数：获取用户输入，保存成一个<strong>字符串</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>inp  = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input your name: &quot;</span>)<br>please <span class="hljs-built_in">input</span> your name: jack<br><span class="hljs-meta">&gt;&gt;&gt; </span>inp<br><span class="hljs-string">&#x27;jack&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(inp)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><span class="hljs-class"></span><br>&gt;&gt;&gt; age  = input(&quot;please input your age: &quot;)<br>please <span class="hljs-built_in">input</span> your age: <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age<br><span class="hljs-string">&#x27;18&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(age)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><span class="hljs-class"></span><br>&gt;&gt;&gt; a = input(&quot;请输入一个字符：&quot;)<br>请输入一个字符：<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>)<br>请输入一个字符：   前后带有空白   <br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;   前后带有空白   &#x27;</span><br></code></pre></td></tr></table></figure><h3 id="print-输出函数">==1.4.2 print 输出函数==</h3><p>普通的输出没啥可说的。</p><p>说一下 <code>print</code> 格式化输出。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201028174609959.png" alt="image-20201028174609959" /><figcaption>image-20201028174609959</figcaption></figure><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201028174632071.png" alt="image-20201028174632071" /><figcaption>image-20201028174632071</figcaption></figure><p>下面是一些经典的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;i am %s&quot;</span> % <span class="hljs-string">&quot;jack&quot;</span><br><span class="hljs-comment">#i am jack</span><br>s = <span class="hljs-string">&quot;i am %s age %d&quot;</span> % (<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-comment">#i am jack age 18</span><br>s = <span class="hljs-string">&quot;i am %(name)s age %(age)d&quot;</span> % &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;<br><span class="hljs-comment">#i am jack age 18</span><br>s = <span class="hljs-string">&quot;percent %.2f&quot;</span> % <span class="hljs-number">99.97623</span><br><span class="hljs-comment">#percent 99.98</span><br>s = <span class="hljs-string">&quot;i am %(pp).2f&quot;</span> % &#123;<span class="hljs-string">&quot;pp&quot;</span>: <span class="hljs-number">123.425556</span>, &#125;<br><span class="hljs-comment">#i am 123.43</span><br>s = <span class="hljs-string">&quot;i am %.2f %%&quot;</span> % <span class="hljs-number">123.425556</span><br><span class="hljs-comment">#i am 123.43 %</span><br></code></pre></td></tr></table></figure><blockquote><p>注：如果你想在print中打印一个%百分符号本身，那么你需要使用%%，两个百分符转义出一个百分符，也就是print(&quot;%%&quot;)。</p></blockquote><h1 id="数据类型">2. 数据类型</h1><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201114232511659.png" alt="image-20201114232511659" /><figcaption>image-20201114232511659</figcaption></figure><h2 id="数字类型">2.1 数字类型</h2><p>数字类型用于存储数学意义上的数值。</p><p>数字类型是不可变类型。所谓的不可变类型，指的是类型的值一旦有不同了，那么它就是一个全新的对象。数字1和2分别代表两个不同的对象，对变量重新赋值一个数字类型，会新建一个数字对象。</p><p>还是要强调一下Python的变量和数据类型的关系，变量只是对某个对象的引用或者说代号、名字、调用等等，变量本身没有数据类型的概念。类似1，[2, 3, 4]，“haha”这一类对象才具有数据类型的概念。</p><blockquote><p>例如：</p><p>a = 1 # 创建数字对象1</p><p>a = 2 # 创建数字对象2，并将2赋值给变量a，a不再指向数字对象1</p><p>这里，发生了变化的是变量a的指向，而不是数字对象1变成了数字对象2。</p></blockquote><p>Python 支持三种不同的数字类型：整数、浮点数和复数。</p><h2 id="字符串">2.2 字符串</h2><p><strong>字符串是不可变的序列数据类型</strong>，不能直接修改字符串本身，和数字类型一样</p><blockquote><p>注：中文符号 &gt; 字母 &gt; 数字 &gt;英文符号</p><p>例: <code>print(min('今天是个好日子！'))</code> 返回 ”！“</p></blockquote><ul><li>字符串的拼接，用 ”+“ 这个符号</li></ul><h3 id="常用函数">常用函数</h3><table><colgroup><col style="width: 34%" /><col style="width: 65%" /></colgroup><thead><tr class="header"><th>函数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>upper()</td><td>函数的作用是将字符串中所有的字母大写，只针对字母。</td></tr><tr class="even"><td>lower()</td><td>函数的作用是将字符串中所有的字母小写，只针对字母。</td></tr><tr class="odd"><td>capitalize()</td><td>将字符串的第一个字母变成大写，其它字母变小写。</td></tr><tr class="even"><td>swapcase()</td><td>将字符串的小写变大写，大写变小写。</td></tr><tr class="odd"><td>zfill(参数=新字符串希望的宽度)</td><td>返回指定长度的字符串，原字符串右对齐，前面填充0。</td></tr><tr class="even"><td>count(参数=查询某个元素的元素)</td><td>返回当前字符串中某个元素的个数。</td></tr><tr class="odd"><td>startswith(参数=字符串)</td><td>判断字符串开始位是否为某个元素，返回布尔值</td></tr><tr class="even"><td>endswith(参数=字符串)</td><td>判断字符串结尾为是否为某个元素，返回布尔值</td></tr><tr class="odd"><td>find(参数=查询某个元素的元素)</td><td>用于获取子字符串出现的位置，如果存在则返回子字符串中<u>第一个字符</u>的索引值，如果没有找到则返回-1</td></tr><tr class="even"><td>index(参数=查询某个元素的元素 )</td><td>用于获取子字符串出现的位置，如果存在则返回子字符串中<u>第一个字符</u>的索引值，如果index找不到元素，会导致程序报错</td></tr><tr class="odd"><td>strip(参数=想去掉的某个元素)</td><td>去掉字符串开头与结尾指定元素，默认是空格</td></tr><tr class="even"><td>lstrip()</td><td>仅去掉字符串开头指定元素或空格</td></tr><tr class="odd"><td>rstrip()</td><td>仅去掉字符串结尾指定元素或空格</td></tr><tr class="even"><td>replace()</td><td>用于将字符串中旧元素替换成新元素，并能指定替换的数量</td></tr><tr class="odd"><td>isspace()</td><td>判断字符串是否是只由空格组成的字符串</td></tr><tr class="even"><td>istitle()</td><td>判断字符串是否是一个标题类型,所有单词的首字母大写才属于标题</td></tr><tr class="odd"><td>isupper()/islower()</td><td>判断字符串的所有字母是否都是大写或者小写</td></tr><tr class="even"><td>split()</td><td>连接字符串</td></tr><tr class="odd"><td>join()</td><td>拆分字符串</td></tr></tbody></table><ul><li><code>spilt(str=&quot;&quot;, num=string.count(str))</code><ul><li>str -- 分隔符，默认为所有的空字符，包括空格、换行()、制表符()等。</li><li>num -- 分割次数。默认为 -1, 即分隔所有。</li></ul></li><li><code>str.join(sequence)</code><ul><li>sequence -- 要连接的元素序列。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">li = [<span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>]<br>print(<span class="hljs-string">&#x27; &#x27;</span>.join(li))<br><br>b = <span class="hljs-string">&#x27;my job is a teacher&#x27;</span><br>print(b.split())<br><br>b = <span class="hljs-string">&#x27;my_name_is_bob&#x27;</span><br>print(b.split(<span class="hljs-string">&#x27;_&#x27;</span>))<br>print(b.split(<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>字符串和bytes转换：</p><ul><li><code>encode(encoding='UTF-8,errors='strict')</code> ：将字符串内容转换为bytes类型的数据</li><li><code>decode(encoding='UTF-8,errors='strict')</code> ：以 <em>encoding</em> 指定的编码格式解码字符串。</li></ul><h3 id="编码格式">编码格式</h3><p>对语言的解析识别/标准</p><ul><li>gbk中文编码</li><li>ASCII英文编码</li><li>utf-8国际通用编码</li></ul><h3 id="格式化输出">格式化（输出）</h3><ol type="1"><li>字符符串格式化用操作符 <code>%</code> 来实现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;my name is %s&#x27;</span><br>name = <span class="hljs-string">&#x27;xz&#x27;</span><br>print(info % name)<br></code></pre></td></tr></table></figure><ul><li>格式化符</li></ul><table><thead><tr class="header"><th>符号</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>%s</td><td>格式化字符串，通用类型</td></tr><tr class="even"><td>%d</td><td>格式化整型</td></tr><tr class="odd"><td>%f</td><td>格式化浮点型</td></tr><tr class="even"><td>%u</td><td>格式化无符号整型（正整型）</td></tr><tr class="odd"><td>%c</td><td>格式化字符</td></tr><tr class="even"><td>%o</td><td>格式化无符号八进制数</td></tr><tr class="odd"><td>%x</td><td>格式化无符号16进制数</td></tr><tr class="even"><td>%e</td><td>科学计数法格式化浮点数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&#x27;%u&#x27;</span> % -<span class="hljs-number">1</span>)  <span class="hljs-comment"># -1</span><br>print(<span class="hljs-string">&#x27;%f&#x27;</span> % <span class="hljs-number">3.14</span>)  <span class="hljs-comment"># 3.140000</span><br>print(<span class="hljs-string">&#x27;%d&#x27;</span> % <span class="hljs-number">10</span>)  <span class="hljs-comment"># 10</span><br>print(<span class="hljs-string">&#x27;%d&#x27;</span> % <span class="hljs-number">1.2</span>)  <span class="hljs-comment">#1</span><br>print(<span class="hljs-string">&#x27;%s&#x27;</span> % <span class="hljs-string">&#x27;123&#x27;</span> )  <span class="hljs-comment"># 123</span><br><br>print(<span class="hljs-string">&#x27;&#123;:f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1.2</span>))  <span class="hljs-comment"># 1.200000</span><br><br>print(<span class="hljs-string">&#x27;%o&#x27;</span> % <span class="hljs-number">8</span>)  <span class="hljs-comment"># 10</span><br>print(<span class="hljs-string">&#x27;%x&#x27;</span> % <span class="hljs-number">32</span>)  <span class="hljs-comment"># 20</span><br><span class="hljs-comment"># print(&#x27;%x&#x27; % &#x27;123ab&#x27;)</span><br>number = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;123ab&#x27;</span>, <span class="hljs-number">16</span>)<br>print(number)<br>print(<span class="hljs-string">&#x27;%x&#x27;</span> % number)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>字符串格式化函数 - <code>format</code></li></ol><ul><li>使用 format的字符串主体使用 <code>&#123;&#125; 大括号</code> 来代替格式符，可以不取下标，取的话从0开始</li><li><code>string.format(data, data...)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;my name is &#123;&#125;&#x27;</span><br>name = <span class="hljs-string">&#x27;xz&#x27;</span><br>print(info.<span class="hljs-built_in">format</span>(name))<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>f-strings</code> <em>新方法</em></li></ol><ul><li>定义一个变量</li><li>字符串前加 f 符号</li><li>需要格式化的位置使用 <code>&#123;变量名&#125;</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;xz&#x27;</span>  <span class="hljs-comment"># 一定要先定义变量名</span><br>info = <span class="hljs-string">f&#x27;my name is <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span><br>print(info)<br></code></pre></td></tr></table></figure><ul><li>转义字符</li></ul><table><thead><tr class="header"><th>符号</th><th>说明</th></tr></thead><tbody><tr class="odd"><td></td><td>换行，一般用于末尾，strip对其也有效</td></tr><tr class="even"><td></td><td>横向制表符</td></tr><tr class="odd"><td></td><td>响铃</td></tr><tr class="even"><td></td><td>退格符，光标前移，覆盖（删除前一个）</td></tr><tr class="odd"><td></td><td>回车</td></tr><tr class="even"><td> '</td><td>转义字符串中的单引号</td></tr><tr class="odd"><td> '‘</td><td>转义字符串中的双引号</td></tr><tr class="even"><td>\</td><td>转移斜杠</td></tr></tbody></table><ul><li>在字符串前加 r 来将当前字符串的转义字符无效化</li></ul><h2 id="布尔类型">2.3 布尔类型</h2><ul><li><p><code>0、0.0、-0.0、空字符串、空列表、空元组、空字典</code>，这些都被判定为False。而<code>-1、&quot;False&quot;</code>也被判断为True。</p></li><li><p><code>None</code> 也不是布尔类型，而是<code>NoneType</code>。</p></li></ul><blockquote><p>平时最容易犯的错误就是获得了一个None值，却对它进行各种方法调用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-literal">None</span>]<br><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> list1:<br>    print(char.join(<span class="hljs-string">&quot;A&quot;</span>))<br><br>    <br>AttributeError: <span class="hljs-string">&#x27;NoneType&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;join&#x27;</span>        <br></code></pre></td></tr></table></figure></blockquote><h2 id="列表-list">2.4 列表 List</h2><p>Python的列表是一个有序可重复的元素集合，可嵌套、迭代、修改、分片、追加、删除，成员判断。</p><p>从数据结构角度看，Python的列表是一个可变长度的顺序存储结构，每一个位置存放的都是对象的指针。</p><p>比如，对于这个列表 <code>alist = [1, “a”, [11,22], &#123;“k1”:”v1”&#125;]</code>，其在内存内的存储方式是这样的：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201028230652247.png" alt="image-20201028230652247" /><figcaption>image-20201028230652247</figcaption></figure><h3 id="索引">索引</h3><p>索引是最左边记录的位置。用数字表示，从0开始，<code>len(list)-1</code> 结束。</p><ul><li>创建</li></ul><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表内的元素，可以是其它任意类型的数据，可多层嵌套列表，元素个数无限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = []        <span class="hljs-comment"># 创建一个空列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>], &#123;<span class="hljs-string">&#x27;k1&#x27;</span>:<span class="hljs-string">&#x27;v1&#x27;</span>&#125;]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><ul><li>访问</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;b&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;c&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">3</span>]<br><span class="hljs-comment">###########</span><br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><ul><li>修改：直接对元素进行重新赋值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;d&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>字符串不可以通过索引修改或删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;comprehensive&quot;</span><br>a[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;a&#x27;</span><br><br><span class="hljs-comment">############</span><br>TypeError: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br></code></pre></td></tr></table></figure></blockquote><ul><li>删除：使用 <code>del</code> 语句或者 <code>remove()</code> ，<code>pop()</code> 方法删除指定的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> lis[<span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis.remove(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[<span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis.pop()<br><span class="hljs-string">&#x27;c&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[]<br></code></pre></td></tr></table></figure><ul><li>常用函数</li></ul><table><thead><tr class="header"><th>函数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>len(list)</td><td>返回列表元素个数，也就是获取列表长度</td></tr><tr class="even"><td>max(list)</td><td>返回列表元素最大值</td></tr><tr class="odd"><td>min(list)</td><td>返回列表元素最小值</td></tr><tr class="even"><td>list(seq)</td><td>将序列转换为列表</td></tr><tr class="odd"><td>in/not in</td><td>判断某个元素是否在列表中</td></tr></tbody></table><h3 id="切片">切片</h3><p>切片指的是对序列进行截取，选取序列中的某一段。</p><p>切片的语法是： <code>list[start:end]</code>，注意，<strong>区间是左闭右开的</strong>！</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201031085919878.png" alt="image-20201031085919878" /><figcaption>image-20201031085919878</figcaption></figure><ul><li>如果下标是负数，从后往前数，是 <code>-1 ~ -len(list)</code></li></ul><h3 id="列表的常见方法">列表的常见方法</h3><table><colgroup><col style="width: 39%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>函数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>append(item)</td><td>将一个元素添加到当前原有列表的末尾</td></tr><tr class="even"><td>insert(index, new_item)</td><td>插入新的元素，在什么位置。如果插入位置不存在，则加在结尾。如果插入位置存在元素，则该元素往后移，将插入元素放入该位置。</td></tr><tr class="odd"><td>count(item)</td><td>返回当前列表中某个元素的个数</td></tr><tr class="even"><td>remove(item)</td><td>删除列表的指定元素。如不存在，会报错。如有多个，只删第一个。</td></tr><tr class="odd"><td>del item</td><td>删掉整个列表</td></tr><tr class="even"><td>reverse()</td><td>反转当前列表</td></tr><tr class="odd"><td>sort(cmp=None, key=None, reverse=False)</td><td>对当前列表按照一定规律进行排序且list中的元素必须是统一类型，否则程序就会报错。</td></tr><tr class="even"><td>clear()</td><td>将list中的元素都清除，将其变成一个空列表即[]</td></tr><tr class="odd"><td>copy()/deepcopy()</td><td><strong>浅拷贝/深拷贝</strong></td></tr><tr class="even"><td>extend()</td><td>将其他list中的元素导入到当前的list</td></tr></tbody></table><blockquote><p>例：append()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">books = [<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>]<br>book = [<span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>]<br>books.append(book)<br>print(books)<br><br>---------------------------------<br>[<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, [<span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>]]<br></code></pre></td></tr></table></figure><ul><li>extend()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&quot;name&quot;</span>]<br>tuplee=(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>)<br><br>list1.extend(tuplee)<br>print(list1)<br><br>---------------------------------<br>[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>]<br></code></pre></td></tr></table></figure></blockquote><p>注意：</p><ol type="1"><li><p>其中的类似 append，insert, remove 等方法会修改列表本身，并且没有返回值（严格的说是返回None）。</p></li><li><p>==浅拷贝与深拷贝==</p><p>使用浅拷贝，当原容器对象中可变对象中有元素发生变化，拷贝得到的对象也会变化。而使用深拷贝时，不会有这种问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>]<br>list2 = list1.copy()<br><br>print(<span class="hljs-built_in">id</span>(list1), <span class="hljs-built_in">id</span>(list2))<br>list2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">123</span><br>list2[<span class="hljs-number">2</span>] = <span class="hljs-number">77</span><br>print(list1, list2)<br><br>---------------------------------<br><span class="hljs-number">1904206959560</span> <span class="hljs-number">1904227747656</span><br>[[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>] [[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>   <br>list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>]<br>list2 = copy.deepcopy(list1)<br>   <br>print(<span class="hljs-built_in">id</span>(list1), <span class="hljs-built_in">id</span>(list2))<br>list2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">123</span><br>list2[<span class="hljs-number">2</span>] = <span class="hljs-number">77</span><br>print(list1, list2)<br>   <br>---------------------------------<br><span class="hljs-number">1563824640968</span> <span class="hljs-number">1563844713928</span><br>[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>] [[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure><blockquote><p>可以理解为：浅拷贝对于一个复杂对象的子对象并不会完全复制，复杂对象的子对象是指比如序列中的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，python会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。</p></blockquote></li></ol><blockquote><p>例题：使用给定的整数n，编写一个程序生成一个包含(i, i*i)的字典，该字典包含1到n之间的整数(两者都包含)。然后程序应该打印字典。 假设向程序提供以下输入:8，则输出为:{1:1，2:4，3:9，4:16，5:25，6:36，,7:49，8:64}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">8</span><br>d = <span class="hljs-built_in">dict</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    d[i] = i * i<br>print(d)<br></code></pre></td></tr></table></figure></blockquote><h2 id="元组-tuple">2.5 元组 Tuple</h2><p>用圆括号括起来的是元组。</p><p>元组也是序列结构，但是是一种<strong>不可变序列</strong>，可以<strong>简单的理解为内容不可变的列表。除了在内部元素不可修改的区别外</strong>，元组和列表的用法差不多。</p><blockquote><p>因为元组是不可变的，所以不能在原来的数据基础上再添加数据，因此元组占用的资源会比列表更小。</p></blockquote><p><strong>元组与列表相同的操作</strong>：</p><ul><li>使用方括号加下标访问元素</li><li>切片（形成新元组对象）</li><li>count()/index()</li><li>len()/max()/min()/tuple()</li></ul><p><strong>元组中不允许的操作，确切的说是元组没有的功能</strong>：</p><ul><li><p>修改、新增元素</p><blockquote><p><strong>元组只保证它的一级子元素不可变，对于嵌套的元素内部，不保证不可变！</strong>所以，在使用元组的时候，请尽量使用数字、字符串和元组这种不可变的数据类型作为元组的元素，这样就能确保元组不发生变化。</p></blockquote></li><li><p>删除某个元素（但可以删除整个元组）</p></li><li><p>所有会对元组内部元素发生修改动作的方法。例如，元组没有remove，append，pop等方法。</p></li></ul><h2 id="字典-dic">2.6 字典 Dic</h2><p>字典可精确描述为<strong>不定长、可变、散列的集合类型</strong>。</p><p>字典数据类型是基于hash散列算法实现的，采用<strong>键值对(key:value)</strong>的形式，根据key的值计算value的地址，具有非常快的查取和插入速度。</p><p>字典包含的元素个数不限，值的类型可以是任何数据类型！但是字典的key必须是不可变的对象，例如数字、字符串、bytes和元组，最常见的还是将字符串作为key。列表、字典、集合等就不可以作为key。同时，同一个字典内的key必须是唯一的，但值则不必。</p><blockquote><p>字典类型的数据不支持累乘。</p></blockquote><ul><li>创建</li></ul><ol type="1"><li><code>dic = &#123;&#125;</code> # 创建空字典</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;&#125;    <span class="hljs-comment"># 创建空字典</span><br>dic = &#123;<span class="hljs-string">&#x27;Alice&#x27;</span>: <span class="hljs-string">&#x27;2341&#x27;</span>, <span class="hljs-string">&#x27;Beth&#x27;</span>: <span class="hljs-string">&#x27;9102&#x27;</span>, <span class="hljs-string">&#x27;Cecil&#x27;</span>: <span class="hljs-string">&#x27;3258&#x27;</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>([(<span class="hljs-string">&#x27;sape&#x27;</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">4098</span>)])<br>&#123;<span class="hljs-string">&#x27;sape&#x27;</span>: <span class="hljs-number">4139</span>, <span class="hljs-string">&#x27;jack&#x27;</span>: <span class="hljs-number">4098</span>, <span class="hljs-string">&#x27;guido&#x27;</span>: <span class="hljs-number">4127</span>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p><code>update()</code> ：在update函数里传入一个新的字典key和value就可以。存在就覆盖。</p></li><li><p><code>setdefault()</code>：传入一个字典key和value，如果键不存在于字典中，将会添加见并键值设为默认值，如果字典中包含有给定键，则返回该键对应的值，若不包含则返回为该键设置的值。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;&#125;<br>dic.setdefault(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;haha&#x27;</span>)<br>dic.setdefault(<span class="hljs-string">&#x27;sex&#x27;</span>)<br>print(dic)<br><br>---------------------------------<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>访问</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;Name&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;Name&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;Age&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;Age&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;address&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;address&#x27;</span>])<br><br>---------------------------------<br>KeyError: <span class="hljs-string">&#x27;address&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>增加和修改</li></ul><p>增加就是往字典插入新的键值对，修改就是给原有的键赋予新的值。由于一个key只能对应一个值，所以，多次对一个key赋值，后面的值会把前面的值冲掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;Shanghai&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;Beijing&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;Age&quot;</span>] = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic<br>&#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>删除字典元素、清空字典和删除字典</li></ul><p>使用 <code>del</code> 关键字删除字典元素或者字典本身，使用字典的 <code>clear()</code> 方法清空字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-keyword">del</span> dic[<span class="hljs-string">&#x27;Name&#x27;</span>]<br>print(dic)<br>a = dic.pop(<span class="hljs-string">&#x27;Class&#x27;</span>)  <span class="hljs-comment"># 弹出并返回指定键对应的值。必须提供参数！</span><br>print(a)<br>dic.clear()<br>print(dic)<br><span class="hljs-keyword">del</span> dic<br>print(dic)<br><br>---------------------------------<br>NameError: name <span class="hljs-string">&#x27;dic&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br>&#123;<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>First<br>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="字典的常见方法">字典的常见方法</h3><table><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><strong>get(key)</strong></td><td><strong>返回指定键的值，如果键不在字典中，则返回default值</strong></td></tr><tr class="even"><td><strong>items()</strong></td><td><strong>以列表返回可遍历的(键, 值) 元组对</strong></td></tr><tr class="odd"><td><strong>keys()</strong></td><td><strong>以列表返回字典所有的键，假列表，不可对其操作，可以通过list(dict.keys())变为真列表</strong></td></tr><tr class="even"><td><strong>values()</strong></td><td><strong>以列表返回字典所有的值，同上</strong></td></tr><tr class="odd"><td>pop(key)</td><td>删除并返回指定key的值</td></tr><tr class="even"><td>popitem()</td><td>删除并返回字典的最后一个键值对的(key,value)形式，不接受参数。且字典如果是空则直接报错</td></tr><tr class="odd"><td>setdefault(key, default=None)</td><td>和get()类似,但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr class="even"><td>update(dict2)</td><td>把字典dict2的键/值对更新到dict里</td></tr><tr class="odd"><td>copy()</td><td>将当前字典复制到一个新的字典</td></tr></tbody></table><p>注：</p><ol type="1"><li><code>get()</code> 和 <code>[]</code> 的区别</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>values = []<br>values.append(dic[<span class="hljs-string">&#x27;Name&#x27;</span>])<br>values.append(dic[<span class="hljs-string">&#x27;Age&#x27;</span>])<br>print(values)<br><span class="hljs-comment"># values.append(dic[&#x27;grade&#x27;])  # KeyError: &#x27;grade&#x27;</span><br>values.append(dic.get(<span class="hljs-string">&#x27;grade&#x27;</span>))<br>print(values)<br><br>---------------------------------<br>[<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;20&#x27;</span>]<br>[<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-literal">None</span>]<br></code></pre></td></tr></table></figure><blockquote><p>字典中获取key的方法[]如果获取不到key会直接报错，而get如果获取不到key会返回默认值，在开发中优先考虑get方法来获取key</p></blockquote><ol start="2" type="1"><li><code>get()</code> 与 <code>in</code> 判断的区别</li></ol><p>字典中的成员判断 in 和not in是判断是否有value，有对、无错，并不判断value是不是空。</p><p>而get判断值的结果，如果value是None就会返回False</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_1 = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-literal">None</span>&#125;  <br>bool(dict_1.get(&quot;name&quot;)) --&gt; False<br></code></pre></td></tr></table></figure><h3 id="遍历字典">遍历字典</h3><p><strong>遍历字典获得的键值对是有序的！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><br><span class="hljs-comment"># 1  直接遍历字典获取键，根据键取值</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic:<br>    print(key, dic[key])<br><br><span class="hljs-comment"># 2  利用items方法获取键值，速度很慢，少用！</span><br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> dic.items():<br>    print(key,value)<br><br><span class="hljs-comment">#3  利用keys方法获取键</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic.keys():<br>    print(key, dic[key])<br><br><span class="hljs-comment">#4  利用values方法获取值，但无法获取对应的键。</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> dic.values():<br>    print(value)<br></code></pre></td></tr></table></figure><h2 id="集合-set">2.7 集合 set</h2><p><strong>集合是一个无序不重复元素的集</strong>，基本功能包括关系测试和消除重复元素。集合使用大括号 <code>&#123;&#125;</code> 框定元素，并以逗号进行分隔。成员是不可变类型。</p><p>但是注意：<u>如果要创建一个空集合，必须用 set() 而不是 {} ，因为后者创建的是一个空字典</u>。集合除了在形式上最外层用的也是花括号外，其它的和字典没有一毛钱关系。</p><p>集合数据类型的核心在于<strong>自动去重</strong>。很多时候能省不少事。</p><ul><li>增加</li></ul><ol type="1"><li>通过add(key)方法可以添加一个元素到set中，可以重复添加，但不会有效果</li><li>可以通过update()方法，将另一个对象更新到已有的集合中，这一过程同样会进行去重。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>s.add(<span class="hljs-number">5</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5&#125;</span><br><br>s.update(<span class="hljs-string">&quot;hello&quot;</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>删除</li></ul><p>通过remove(key)方法删除指定元素，或者使用pop()方法。注意，集合的pop方法无法设置参数，删除指定的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br>s.remove(<span class="hljs-string">&#x27;l&#x27;</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br>s.pop(<span class="hljs-number">3</span>)  <span class="hljs-comment"># TypeError: pop() takes no arguments (1 given)</span><br></code></pre></td></tr></table></figure><p><strong>不能从集合取某个元素。因为集合既不支持下标索引也不支持字典那样的通过键获取值。</strong></p><h3 id="集合的常用方法">集合的常用方法</h3><table><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>difference() / -</td><td>返回集合的差集</td></tr><tr class="even"><td>intersection()</td><td>返回集合的交集</td></tr><tr class="odd"><td>union()</td><td>返回集合的并集</td></tr><tr class="even"><td>isdisjoint()</td><td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr class="odd"><td>issubset()</td><td>判断指定集合是否为该方法参数集合的子集。</td></tr><tr class="even"><td>add()</td><td>为集合添加一个元素</td></tr><tr class="odd"><td>update()</td><td>给集合添加元素</td></tr><tr class="even"><td>pop()</td><td>移除元素</td></tr><tr class="odd"><td>remove()</td><td>移除指定元素</td></tr></tbody></table><h1 id="函数">3. 函数</h1><p>总结函数的传参方式，有以下四种：</p><ul><li>位置参数</li><li>默认参数</li><li>关键参数</li><li>非固定参数<ul><li><code>*args</code></li><li><code>**kwargs</code></li></ul></li></ul><h2 id="位置参数">3.1 位置参数</h2><p>位置参数就是调用函数时穿的实参与形参位置上一一对应的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country</span>):</span><br>print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;CN&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="默认参数">3.2 默认参数</h2><p>默认参数就是在函数形参中定义好的，当是惨重未穿对应的参数时，参数就会以默认值为准。</p><p>注：默认参数必须放在位置参数之后，否则会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country = <span class="hljs-string">&#x27;CN&#x27;</span></span>):</span><br>print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="关键参数">3.3 关键参数</h2><p>正常情况下，给函数传参数要按照顺序，如果不按顺序就可以用关键参数，只需指定参数名即可（指定参数名的参数叫关键参数）</p><p>注：关键参数必须放在位置参数（以位置顺序确定对应关系的参数）之后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country = <span class="hljs-string">&#x27;CN&#x27;</span></span>):</span><br>print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, country = <span class="hljs-string">&#x27;UK&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="非固定参数">3.4 非固定参数</h2><p><code>*args</code>与 <code>**kwargs</code> 是可变类型且 <code>*args</code> 将参数封装成元组类型给函数体调用，<code>**kwargs</code> 将参数封装成字典类型给函数体调用</p><blockquote><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">seq</span>(<span class="hljs-params">num, num1, num2</span>):</span><br>    <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">88</span> :<br>        print(num1 * num2)<br>    <span class="hljs-keyword">else</span>:<br>        print(num1 + num2)<br>        <br><span class="hljs-comment"># 定义变量tuple1的值为(5,2,1)</span><br>tuple1 = (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 调用函数，传入参数tuple1，并打印函数返回值</span><br>seq(*tuple1)  <span class="hljs-comment"># *tuple1可实现对元组tuple1的解包</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="args">3.4.1 <code>*args</code></h3><p>可同时指定多个用户，传过来的所有参数打包成元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_args</span>(<span class="hljs-params">first, *args</span>):</span><br>    print(<span class="hljs-string">&#x27;Required argument: &#x27;</span>, first)<br>    print(<span class="hljs-built_in">type</span>(args))<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> args:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument: &#x27;</span>, v)<br><br>test_args(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>第一个参数是必须要传入的参数，所以使用了第一个形参，而后面三个参数则作为可变参数列表传入了实参，并且是作为元组tuple来使用的。代码的运行结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Required argument:  <span class="hljs-number">1</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">tuple</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">Optional</span> <span class="hljs-title">argument</span>:</span>  <span class="hljs-number">2</span><br>Optional argument:  <span class="hljs-number">3</span><br>Optional argument:  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="kwargs">3.4.2 <code>**kwargs</code></h3><p>可同时指定多个用户，传过来的所有参数打包成元组或字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_kwargs</span>(<span class="hljs-params">first, *args, **kwargs</span>):</span><br>   print(<span class="hljs-string">&#x27;Required argument: &#x27;</span>, first)<br>   print(<span class="hljs-built_in">type</span>(kwargs))<br>   <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> args:<br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument (args): &#x27;</span>, v)<br>   <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items():<br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument %s (kwargs): %s&#x27;</span> % (k, v))<br><br>test_kwargs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, k1=<span class="hljs-number">5</span>, k2=<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>正如前面所说的，<code>args</code> 类型是一个tuple，而 <code>kwargs</code> 则是一个字典 <code>dict</code>，并且 <code>args</code> 只能位于 <code>kwargs</code> 的前面。代码的运行结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Required argument:  <span class="hljs-number">1</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">dict</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">Optional</span> <span class="hljs-title">argument</span> (<span class="hljs-params">args</span>):</span>  <span class="hljs-number">2</span><br>Optional argument (args):  <span class="hljs-number">3</span><br>Optional argument (args):  <span class="hljs-number">4</span><br>Optional argument k1 (kwargs): <span class="hljs-number">5</span><br>Optional argument k2 (kwargs): <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="综合练习函数的使用">综合练习：函数的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    学生信息库</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>students = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;dewei&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小木&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">5</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小安&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 检查位置参数的判断</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_info</span>(<span class="hljs-params">**kwargs</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生姓名&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生年龄&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生性别&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生班级&#x27;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_students</span>():</span><br>    <span class="hljs-keyword">for</span> id_, value <span class="hljs-keyword">in</span> students.items():<br>        print(<span class="hljs-string">&#x27;学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>            id_, value[<span class="hljs-string">&#x27;name&#x27;</span>], value[<span class="hljs-string">&#x27;age&#x27;</span>], value[<span class="hljs-string">&#x27;sex&#x27;</span>], value[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>        ))<br>    <span class="hljs-keyword">return</span> students<br><br><span class="hljs-comment"># result = get_all_students()</span><br><span class="hljs-comment"># print(&#x27;---&#x27;, result)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_student</span>(<span class="hljs-params">**kwargs</span>):</span><br>    check = check_user_info(**kwargs)<br>    <span class="hljs-keyword">if</span> check != <span class="hljs-literal">True</span>:<br>        print(check)<br>        <span class="hljs-keyword">return</span><br><br>    id_ = <span class="hljs-built_in">max</span>(students) + <span class="hljs-number">1</span>  <span class="hljs-comment"># 不在长度上加1，会覆盖以前删掉的号码</span><br><br>    students[id_] = &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: kwargs[<span class="hljs-string">&#x27;name&#x27;</span>],<br>        <span class="hljs-string">&#x27;age&#x27;</span>: kwargs[<span class="hljs-string">&#x27;age&#x27;</span>],<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: kwargs[<span class="hljs-string">&#x27;sex&#x27;</span>],<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: kwargs[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>    &#125;<br><br><span class="hljs-comment"># add_student(name=&#x27;小章鱼&#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span><br><span class="hljs-comment"># get_all_students()</span><br><br><span class="hljs-comment"># 删除</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_student</span>(<span class="hljs-params">student_id</span>):</span><br>    <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> students:<br>        print(<span class="hljs-string">&#x27;学号是&#123;&#125;号的同学的信息不存在&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br>    <span class="hljs-keyword">else</span>:<br>        user_info = students.pop(student_id)<br>        print(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br><span class="hljs-comment"># delete_student(2)</span><br><span class="hljs-comment"># add_student(name=&#x27;小章鱼&#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span><br><span class="hljs-comment"># get_all_students()</span><br><br><span class="hljs-comment"># 修改</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_student</span>(<span class="hljs-params">student_id, **kwargs</span>):</span><br>    <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> students:<br>        print(<span class="hljs-string">&#x27;不存在学号：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br><br>    check = check_user_info(**kwargs)<br>    <span class="hljs-keyword">if</span> check != <span class="hljs-literal">True</span>:<br>        print(check)<br>        <span class="hljs-keyword">return</span><br><br>    students[student_id] = kwargs<br>    print(<span class="hljs-string">&#x27;&#123;&#125;同学信息更新完毕&#x27;</span>.<span class="hljs-built_in">format</span>(kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>update_student(<span class="hljs-number">2</span>, name=<span class="hljs-string">&#x27;2小木&#x27;</span>, age=<span class="hljs-number">11</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>,class_number=<span class="hljs-string">&#x27;B&#x27;</span>)<br>get_all_students()<br><br><span class="hljs-comment"># 查找，通过学号</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_id</span>(<span class="hljs-params">student_id</span>):</span><br>    <span class="hljs-keyword">return</span> students.get(student_id)<br><br>print(get_user_by_id(<span class="hljs-number">3</span>))<br><br><span class="hljs-comment">#</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_users</span>(<span class="hljs-params">**kwargs</span>):</span><br>    values = <span class="hljs-built_in">list</span>(students.values())<br>    key = <span class="hljs-literal">None</span><br>    value = <span class="hljs-literal">None</span><br>    result = []<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;name&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;age&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;sex&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;class_number&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;没有发现搜索的关键字&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> values:<br>        <span class="hljs-keyword">if</span> user[key] == value:<br>            result.append(user)<br><br>    <span class="hljs-keyword">return</span> result<br><br>print(<span class="hljs-string">&#x27;--------------------&#x27;</span>)<br>users = search_users(sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>print(users)<br></code></pre></td></tr></table></figure><h1 id="面向对象编程">4. 面向对象编程</h1><p>基本概念：</p><ul><li>面向对象：是一种以对象为核心的编程思想。主要是找出问题中的共性问题，作为对象进行操作。</li><li>类：类可以创建实例。</li><li>对象：类不能直接使用。通过类创建实例，也就是对象，才能使用。</li><li>属性：类中的所有变量都称为属性。</li><li>方法：类中的所有函数都成为方法。不过，和函数有所不同的是，类方法至少要包含一个 <code>self</code> 参数。类方法不能单独使用，需要和类的对象一起使用。创建对象后就可以直接调用类中的方法和属性。</li></ul><h2 id="类的-self-参数">4.1 类的 self 参数</h2><ul><li><code>self</code> 是类函数中的必传参数，且必须定义在第一个参数位置</li><li><code>self</code> 是一个对象，他代表实例化的变量自身</li><li><code>self</code> 可以直接通过点 <strong><code>.</code></strong> 来定义一个类变量</li></ul><p><code>self</code> 的举例说明：</p><p><strong>1、属性</strong></p><ol type="1"><li>如果变量定义在类下面而不是类的方法下面，那这个变量既是类的属性也是类实例的属性。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    name = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>    age = <span class="hljs-string">&#x27;21&#x27;</span><br><br>ps = Person()<br>print(ps.name)<br><br>---------------------<br>xiaozhang<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>如果变量定义在类的方法下面，如果加了 <code>self</code> ，那这个变量就是<u>类实例</u>的属性，而不是类的属性；如果没加 <code>self</code> ，那这个变量就是这个方法的局部变量，既不是类的属性也不是类实例的属性。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.name = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>        age = <span class="hljs-string">&#x27;21&#x27;</span><br><br>ps = Person()<br>print(ps.name)<br>print(ps.age)<br><br>---------------------------------<br>xiaozhang<br>Traceback (most recent call last):<br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;age&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>2、方法</strong></p><ol type="1"><li>如果在类中定义函数时<u>加了</u> <code>self</code> ，那这个函数就是类实例的方法，而不是类的方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小张爱跑步&#x27;</span>)<br><br><br>ps = Person()<br>ps.run()<br><span class="hljs-comment"># Person.run()</span><br><br>---------------------------------<br>小张爱跑步<br><span class="hljs-comment"># TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>如果在类中定义函数时<u>没加</u> <code>self</code> ，那这个函数就只是类的方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>        print(<span class="hljs-string">&#x27;小张爱跑步&#x27;</span>)<br><br><br>ps = Person()<br><span class="hljs-comment"># ps.run()</span><br>Person.run()<br><br>---------------------------------<br><span class="hljs-comment"># TypeError: run() takes 0 positional arguments but 1 was given</span><br>小张爱跑步<br><br></code></pre></td></tr></table></figure><h2 id="私有函数与私有变量">4.2 私有函数与私有变量</h2><ul><li>只希望类内部业务调用使用，不希望被使用者调用</li><li>私有函数与变量无法被实例化后的对象所调用</li><li><p>而类内部可以调用私有函数与变量</p></li><li><p>在变量或者函数前添加两个下横线 <code>__</code></p></li></ul><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __cat_type = <span class="hljs-string">&#x27;cat&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, sex</span>):</span><br>        self.name = name<br>        self.__sex = sex<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        tmp = self.__run()<br>        print(tmp)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="hljs-subst">&#123;self.name&#125;</span> <span class="hljs-subst">&#123;self.__sex&#125;</span> 开心的奔跑着&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span>(<span class="hljs-params">self</span>):</span><br>        tmp = self.__jump()<br>        print(tmp)                                        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__jump</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="hljs-subst">&#123;self.name&#125;</span> <span class="hljs-subst">&#123;self.__sex&#125;</span> 开心的跳着&#x27;</span><br><br>cat = Cat(name = <span class="hljs-string">&#x27;米粒&#x27;</span>, sex = <span class="hljs-string">&#x27;boy&#x27;</span>)<br>cat.run()<br>cat.jump()<br><span class="hljs-comment"># cat.__run()</span><br>print(<span class="hljs-built_in">dir</span>(cat))  <span class="hljs-comment"># dir() 可以查看实例化对象有哪些方法</span><br>print(cat._Cat__jump())  <span class="hljs-comment"># 实例化对象调用私有函数也可以行得通，但是最好不要这样做</span><br>print(cat._Cat__cat_type)<br><br>---------------------------------<br>cat, 小猫 米粒 boy 开心的奔跑着<br>cat, 小猫 米粒 boy 开心的跳着<br>[<span class="hljs-string">&#x27;_Cat__cat_type&#x27;</span>, <span class="hljs-string">&#x27;_Cat__jump&#x27;</span>, <span class="hljs-string">&#x27;_Cat__run&#x27;</span>, <span class="hljs-string">&#x27;_Cat__sex&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;jump&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;run&#x27;</span>]<br>cat, 小猫 米粒 boy 开心的跳着<br>cat<br><br></code></pre></td></tr></table></figure><h3 id="举个栗子----编程练习">举个栗子----编程练习：</h3><p>自定义一个交通工具类(Vehicle)，并根据提示对该类进行进一步封装，使其拥有工具类型、速度、体积等属性值。通过自定义实例方法实现交通工具的前移、速度设置、获取当前速度、加速行驶、减速行驶、实例信息展示、实例类型判别等功能。</p><p>任务 1、自定义一个交通工具类(Vehicle) 2、设置类属性trans_type（固定值为'SUV'）和实例属性速度speed（int 类型，单位为 km/h）、体积size（tuple类型，单位为米。） 3、自定义方法 show_info( )，打印实例的所属类型和速度、体积的值； 4、自定义实例方法如下： （1）定义move( )方法，实现打印“我已向前移动了50米” （2）定义set_speed(new_speed)方法，设置对应实例的速度为new_speed km/h （3）定义get_speed()方法，如果（2）中设置了速度值则打印出来，打印格式为'我的时速为：设置的速度值 km/h' （4）定义speed_up()方法，设置每次调用时实例的速度都增加10km/h，并打印“我的速度由xx km/提升到了xx km/h” （5）定义speed_down()方法，设置每次调用时实例的速度都降低15km/h，并打印“我的速度由xx km/下降到了xx km/h” 5、自定义方法 transport_identify( )，判断实例是否为Vehicle类型。若是则打印‘类型匹配’，反之则打印‘类型不匹配’ 6、初始化实例对象tool_1</p><p>任务提示 类的初始化方法中所传参数size是元组类型，直接传入实例的长，宽，高即可，如size=(10,10,10)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 自定义Vehicle类属性</span><br>    trans_type = <span class="hljs-string">&#x27;SUV&#x27;</span><br><br>    <span class="hljs-comment"># 自定义实例的初始化方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, speed, size</span>):</span><br>        self.speed = speed<br>        self.size = size<br><br>    <span class="hljs-comment"># 自定义实例方法show_info，打印实例的速度和体积</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我的所属类型为: &#123;&#125;, 我的速度: &#123;&#125; km/h, 我的体积: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.trans_type, self.speed, self.size))<br><br>    <span class="hljs-comment"># 自定义实例方法move,打印“我已向前移动了50米”</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我已向前移动了50米&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义实例方法set_speed，设置对应的速度值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_speed</span>(<span class="hljs-params">self, new_speed</span>):</span><br>        self.speed = new_speed  <span class="hljs-comment"># 在这里将旧速度与新设置的速度进行统一。</span><br><br>    <span class="hljs-comment"># 自定义实例方法get_speed，打印当前的速度值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_speed</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我的时速为 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(self.speed))<br><br>    <span class="hljs-comment"># 自定义实例方法speed_up，实现对实例的加速</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speed_up</span>(<span class="hljs-params">self</span>):</span><br>        old_speed = self.speed<br>        self.speed += <span class="hljs-number">10</span><br>        print(<span class="hljs-string">&quot;我的时速由 &#123;&#125; km/h 提升到了 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(old_speed, self.speed))<br><br><span class="hljs-comment"># 自定义实例方法speed_down，实现对实例的减速</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speed_down</span>(<span class="hljs-params">self</span>):</span><br>        old_speed = self.speed<br>        self.speed -= <span class="hljs-number">15</span><br>        print(<span class="hljs-string">&quot;我的时速由 &#123;&#125; km/h 下降到了 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(old_speed, self.speed))<br><br><span class="hljs-comment"># 自定义实例方法transport_identify，实现对实例所属类型的判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transport_identify</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.trans_type == <span class="hljs-string">&#x27;SUV&#x27;</span>:<br>            print(<span class="hljs-string">&quot;类型匹配&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;类型不匹配&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    tool_1 = Vehicle(<span class="hljs-number">20</span>, (<span class="hljs-number">3.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">1.75</span>))<br><br>    <span class="hljs-comment"># 调用实例方法 打印实例的速度和体积</span><br>    tool_1.show_info()<br><br>    <span class="hljs-comment"># 调用实例方法 实现实例的前移</span><br>    tool_1.move()<br><br>    tool_1.set_speed(<span class="hljs-number">40</span>)<br>    <span class="hljs-comment"># 调用实例方法 打印当前速度</span><br>    tool_1.get_speed()<br><br>    <span class="hljs-comment"># 调用实例方法 对实例进行加速</span><br>    tool_1.speed_up()<br><br>    <span class="hljs-comment"># 调用实例方法 对实例进行减速</span><br>    tool_1.speed_down()<br><br>    <span class="hljs-comment"># 调用实例方法 判断当前实例的类型</span><br>    tool_1.transport_identify()<br>    <br>---------------------------------------------    <br>我的所属类型为: SUV, 我的速度: <span class="hljs-number">20</span> km/h, 我的体积: (<span class="hljs-number">3.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">1.75</span>)<br>我已向前移动了<span class="hljs-number">50</span>米<br>我的时速为 <span class="hljs-number">40</span> km/h<br>我的时速由 <span class="hljs-number">40</span> km/h 提升到了 <span class="hljs-number">50</span> km/h<br>我的时速由 <span class="hljs-number">50</span> km/h 下降到了 <span class="hljs-number">35</span> km/h<br>类型匹配<br></code></pre></td></tr></table></figure><h2 id="类的封装">4.3 类的封装</h2><p><strong>封装</strong>：将<u>不对外的私有属性或方法</u>通过<u>可对外使用的函数</u>而使用（类中定义私有的，只有类内部使用，外部无法访问）</p><ul><li>这样做的原因：保护隐私，明确区分内外</li></ul><blockquote><p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。 对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者self间接获取被封装的内容。</p></blockquote><h2 id="装饰器">4.4 装饰器</h2><p><strong>装饰器</strong>：装饰器本质上就是一个python函数，他可以让其他函数在<strong>不需要做任何代码变动的前提下，增加额外的功能</strong>，装饰器的<strong>返回值也是一个函数对象</strong>。他们有助于让代码更简短，也更Pythonic（Python范儿）。装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等等场景。有了装饰器，我们可以抽离出大量与函数功能本身无关的雷同代码。</p><p>我们知道，在python中，我们可以像使用变量一样使用函数，这主要依赖于以下几点：</p><ul><li>函数可以被赋值给其他变量</li><li>函数可以被删除</li><li>可以在函数里面再定义函数，函数嵌套。</li><li><strong>函数可以作为参数传递给另外一个函数</strong></li><li>函数可以作为另一个函数的返回值</li></ul><p>为了更好的理解装饰器，先从对一个简单的函数进行装饰，假设有下面这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world!&quot;</span><br></code></pre></td></tr></table></figure><p>现在我们的需求是要增强 <code>hello()</code> 函数的功能，希望给返回加上HTML标签，比如<code>&lt;i&gt;he不得改变</code>hello()` 函数原来的定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span>+fun()+<span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个函数 <code>makeitalic</code>，该函数有一个参数 <code>fun</code>，它是一个函数；在 <code>makeitalic</code> 函数里面我们又定义了一个内部函数 <code>wrapped</code> ，并将该函数作为返回。</p><p>现在我们就达到了我们的需求，不改变 <code>hello()</code> 函数的定义，但实现了我们想要的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>          <span class="hljs-keyword">return</span> wrapped<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br>hello = makeitalic(hello)<br>print(hello()) <span class="hljs-comment"># &lt;i&gt;hello world&lt;/i&gt;</span><br></code></pre></td></tr></table></figure><p>在上面，我们将 <code>hello</code> 函数传入 <code>makeitalic</code> ，再将返回赋值给 <code>hello</code> ，此时，调用 <code>hello()</code> 函数就可以得到我们想要的结果。 不过需要注意的是，由于我们将 <code>makeitalic</code> 的返回赋值给 <code>hello</code> ，此时，<code>hello()</code> 函数仍然存在，但它已不在指向原来定义的 <code>hello()</code> 函数了，而是指向了 <code>wrapped</code>。</p><p>现在我们来总结一下，上面例子为了增强原函数 <code>hello</code> 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，在这个返回的函数中，执行了原函数，并对原函数的功能进行了增强。完整的代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>          <span class="hljs-keyword">return</span> wrapped<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br>hello = makeitalic(hello)<br>print(hello())<br>print(hello.__name__)<span class="hljs-number">123456789101112</span><br></code></pre></td></tr></table></figure><p>事实上，<code>makeitalic</code> 就是一个装饰器（<code>decorator</code>），它封装了原函数 <code>hello</code>，并返回了一个新函数，用于增强原函数的功能，并将其赋值给 <code>hello</code>。</p><p>一般情况下，我们使用装饰器提供的<strong><span class="citation" data-cites="语法糖">@语法糖</span>（Syntactic Sugar）</strong>，来简化上面的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-meta">@makeitalic</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><p>这种做法是我们在平时写程序时，常见的操作，但前面例子中的讲解才是内部的实现原理。</p><p>像上面的情况，可以动态的修改函数（或类的）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 <code>hello</code>）为参数，并返回一个包装后的函数（比如上面的 <code>wrapped</code>）给被修饰函数（<code>hello</code>）。</p><blockquote><p>之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，<strong>糖在不改变其所在位置的语法结构的前提下，实现了运行时等价</strong>。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。</p><p>之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：<strong>代码更简洁流畅，代码更语义自然</strong>... 写得爽，看着爽，就像吃了糖hhh。据说还有语法盐hhh反人类的代码</p></blockquote><p>举个简单的栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_str</span>(<span class="hljs-params">func</span>):</span><br>    print(<span class="hljs-string">&#x27;func:&#x27;</span>, func)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        print(<span class="hljs-string">&#x27;args:&#x27;</span>, args, kwargs)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-keyword">if</span> result == <span class="hljs-string">&#x27;okk&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is %s&#x27;</span> % result<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is failed:%s &#x27;</span> % result<br><br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@check_str</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">return</span> data<br><br>result = test(<span class="hljs-string">&#x27;no&#x27;</span>)<br>print(result)<br><br>result = test(<span class="hljs-string">&#x27;okk&#x27;</span>)<br>print(result)<br><br>-------------------------------------<br>func: &lt;function test at <span class="hljs-number">0x00000191FC0A9168</span>&gt;<br>args: (<span class="hljs-string">&#x27;no&#x27;</span>,) &#123;&#125;<br>result <span class="hljs-keyword">is</span> failed:no <br>args: (<span class="hljs-string">&#x27;okk&#x27;</span>,) &#123;&#125;<br>result <span class="hljs-keyword">is</span> okk<br></code></pre></td></tr></table></figure><blockquote><p>小练习：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201231201524698.png" alt="image-20201231201524698" /><figcaption>image-20201231201524698</figcaption></figure><p>输出：</p><p>​ 2018-11-27</p><p>​ call hello()</p><p>​ hello world</p><p>​ 本题考查的是装饰器的应用。代码中函数的执行顺序为先执行now函数再执行hello函数，执行now函数时输出2018-11-27，当执行hello函数时，发现了装饰器log函数，因此要先执行装饰器，输出call hello(): ，然后执行传入的hello函数，输出hello world</p></blockquote><h2 id="常用的装饰器">4.5 常用的装饰器</h2><ul><li><code>classmethod</code></li><li><code>staticmethod</code></li><li><code>property</code></li></ul><h3 id="classmethod-的功能">4.5.1 <code>classmethod</code> 的功能</h3><p><code>classmethod</code> ：将类函数可以不经过实例化而直接被调用。</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, a</span>):</span><br>        self.a = a<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;run&#x27;</span>)<br>        self.jump()  <span class="hljs-comment"># # &gt;&gt;&gt; run/n jump 证明普通的self函数可以调用带有classmethod装饰器的类函数</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span>(<span class="hljs-params">cls</span>):</span><br>        print(<span class="hljs-string">&#x27;jump&#x27;</span>)<br>        <span class="hljs-comment"># cls.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br>                   <span class="hljs-comment"># 证明带有classmethod装饰器的类函数无法调用self函数</span><br><br>t = Test(<span class="hljs-string">&#x27;aa&#x27;</span>)<br><span class="hljs-comment"># t.run()</span><br><span class="hljs-comment"># Test.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br>            <span class="hljs-comment"># 因为没有实例化！(这时就可以用classmethod)</span><br><span class="hljs-comment"># Test.jump()  # &gt;&gt;&gt; jump</span><br>t.run()   <span class="hljs-comment"># &gt;&gt;&gt; run/n jump</span><br></code></pre></td></tr></table></figure><h3 id="staticmethod-的功能">4.5.2 <code>staticmethod</code> 的功能</h3><p><code>staticmethod</code> ：可以将类函数不经过实例化而直接被调用，被该装饰器调用的函数<strong>不许传递 <code>self</code> 或 <code>cls</code> 参数</strong>，且无法在该函数内调用其它类函数或类变量。</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, a</span>):</span><br>        self.a = a<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;run&#x27;</span>)<br>        self.sleep()  <span class="hljs-comment"># 证明普通的self函数可以调用带有staticmethod装饰器的类函数</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span>():</span><br>        print(<span class="hljs-string">&#x27;i wanna sleep&#x27;</span>)<br>        self....  <span class="hljs-comment"># 直接报错，都没有self参数</span><br><br>t = Test(<span class="hljs-string">&#x27;aa&#x27;</span>)<br>Test.sleep()  <span class="hljs-comment"># &gt;&gt;&gt; i wanna sleep</span><br>t.sleep()  <span class="hljs-comment"># &gt;&gt;&gt; i wanna sleep</span><br>t.run()  <span class="hljs-comment"># &gt;&gt;&gt; run\n i wanna sleep</span><br><br></code></pre></td></tr></table></figure><h3 id="property-的功能">4.5.3 <code>property</code> 的功能</h3><p><code>property</code> ：将类含糊的执行免去括弧，类似于调用属性(变量)</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.__name = name<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__name<br><br><span class="hljs-meta">    @name.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self, value</span>):</span><br>        self.__name = value<br><br>t = Test(name=<span class="hljs-string">&#x27;xiaozhang&#x27;</span>)<br>print(t.name)<br><br>t.name = <span class="hljs-string">&#x27;xiaohong&#x27;</span>  <span class="hljs-comment"># AttributeError: can&#x27;t set attribute</span><br>print(t.name)<br></code></pre></td></tr></table></figure><h2 id="类的继承">4.6 类的继承</h2><p>1、什么是继承？</p><ul><li>通过继承基类来得到基类的功能</li><li>被继承的类称作父类或基类，继承者称作子类</li><li><strong>代码重用</strong></li></ul><p>2、父类和子类的关系？</p><ul><li>子类拥有父类的<strong>所有属性和方法</strong></li><li>父类不具备子类<strong>自有</strong>的属性和方法</li></ul><p>3、继承的用法：</p><ul><li>定义子类时，将父类传入子类参数内</li><li>子类实例化可以调用自己与父类的函数与变量</li><li>父类无法调用子类的函数与变量</li></ul><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, sex</span>):</span><br>        self.name = name<br>        self.sex = sex<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is talking&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_sex</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.sex == <span class="hljs-string">&#x27;boy&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is a boy&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is a girl&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildOne</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play_football</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is playing football&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildTwo</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play_pingpong</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is playing pingpong&#x27;</span><br><br>c_one = ChildOne(name=<span class="hljs-string">&#x27;小张&#x27;</span>, sex=<span class="hljs-string">&#x27;girl&#x27;</span>)<br>result = c_one.play_football()<br>print(result)<br>result = c_one.talk()<br>print(result)<br><br>c_two = ChildTwo(name=<span class="hljs-string">&#x27;小红&#x27;</span>, sex=<span class="hljs-string">&#x27;girl&#x27;</span>)<br>result = c_two.play_pingpong()<br>print(result)<br>result = c_two.talk()<br>print(result)<br><br>p = Parent(name=<span class="hljs-string">&#x27;父亲&#x27;</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>result = p.talk()<br>print(result)<br>result = p.is_sex()<br>print(result)<br>result = p.playing()  <span class="hljs-comment"># AttributeError: &#x27;Parent&#x27; object has no attribute &#x27;playing&#x27;</span><br><br></code></pre></td></tr></table></figure><p>4、<strong><code>super</code> 函数</strong>的作用 (<strong>单继承</strong>)</p><p><code>super</code> ：是python子类继承父类的方法而使用的关键字，当子类继承父类后，就可以使用父类的方法。</p><blockquote><p>注：一般适用于<strong>单继承</strong>。</p></blockquote><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, p</span>):</span><br>        print(<span class="hljs-string">&#x27;hello i am parent %s&#x27;</span> % p)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, c, p</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(p)<br>        print(<span class="hljs-string">&#x27;hello i am child %s&#x27;</span> % c)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    c = Child(c=<span class="hljs-string">&#x27;小张&#x27;</span>, p=<span class="hljs-string">&#x27;老张&#x27;</span>)<br>    <br>----------------------------------------------------<br>hello i am parent 老张<br>hello i am child 小张<br></code></pre></td></tr></table></figure><h3 id="举个栗子----编程练习-1">举个栗子----编程练习：</h3><p>自定义两个类Person和Student，且Student继承自Person。Person类主要描述人的姓名和性别两大基本特征。Student类除了保持父类的基本属性之外还具有分数、主修两个公有属以及一个私有属性（学号）。请根据上述的基本说明，对stu和stu_2两个对象的信息进行综 合展示。</p><p>任务 1、自定义Person类，并重写其构造（初始化）方法<code>__init__( )</code>，将name和gender参数赋值给实例对象的属性 2、自定义实例方法<code>speak( )</code>，功能：打印“hello ! 我是xxx”。<code>relaton( )</code>方法主要是占位作用，无其他实质性功能 3、自定义Student类，继承自Person类，并重写其构造（初始化）方法<code>__init__( )</code>，name、gender参数通过调用父类的构造函数进行赋值，score和major通过子类重写的<code>__init__( )</code>进行赋值。 4、自定义实例方法<code>speak( )</code>，功能：打印 '我的学号为xxxxxxxxxx，很高兴认识大家'; 5、自定义实例方法<code>identify_stu( )</code>，功能：判断Student对象的学号。若学号为2018014002，则打印‘我的分组已经完成’，反之则打印‘请稍后，马上为你自动分组’； 6、自定义实例方法<code>set_num( new_num)</code>，功能：将学号重写设置为new_num； 7、自定义实例方法<code>relation( )</code>，功能：判断Student是否为Person的子类。若成立，则打印‘我的父类是Person’，反之则打印‘父类在查询中······’ 8、初始化实例对象stu和stu_2，并根据上述效果图调用对应方法</p><p>任务提示 Person类中的实例方法<code>relation( )</code>为占位功能时，其方法体可用pass语句代替</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 重写实例对象的构造（初始化）方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, gender</span>):</span><br>        self.name = name<br>        self.gender = gender<br><br>    <span class="hljs-comment"># 自定义实例方法，格式化打印实例属性name的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;hello! 我是 %s 。&quot;</span> % self.name)<br><br>    <span class="hljs-comment"># 自定义实例方法，占位作用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relation</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">Person</span>):</span><br>    <span class="hljs-comment"># 重写实例对象的构造（初始化）方法，并调用父类构造方法，实现对实例属性的赋值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, gender, score, major, __stu_num = <span class="hljs-string">&#x27;2018014002&#x27;</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__( name, gender)<br>        self.score = score<br>        self.major = major<br>        self.__stu_num = __stu_num<br><br>    <span class="hljs-comment"># 自定义实例方法，格式化打印实例属性stu_num的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;我的学号为 %s，很高兴认识大家&#x27;</span> % self.__stu_num)<br><br>    <span class="hljs-comment"># 自定义实例方法，判断学号是否为既定值，并根据判断结构 进行分类打印</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identify_stu</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.__stu_num == <span class="hljs-string">&#x27;2018014002&#x27;</span>:<br>            print(<span class="hljs-string">&quot;我的分组已经完成&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;请稍后，马上为你自动分组&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义实例方法，设置实例对象的学号为传入的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_num</span>(<span class="hljs-params">self, new_num</span>):</span><br>        self.__stu_num = new_num<br><br>    <span class="hljs-comment"># 自定义实例方法，判断该类是否为Person类的子类，并进行分类打印</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relation</span>(<span class="hljs-params">self, cls_son, cls_fa</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(cls_son, cls_fa):<br>            print(<span class="hljs-string">&quot;我的父类是Person&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;父类正在查询中....&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    stu = Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;数学&#x27;</span>)<br>    <span class="hljs-comment"># 调用speak方法 打印stu对应的值</span><br>    stu.speak()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别学号是否为指定值</span><br>    stu.identify_stu()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别实例对象所属的类的父类是否为Person</span><br>    stu.relation(Student, Person)<br><br>    print(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">12</span>)<br><br>    stu_2 = Student(<span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>)<br>    <span class="hljs-comment"># 调用实例方法 设置stu_2的学号为&#x27;2018040625&#x27;</span><br>    stu_2.set_num(<span class="hljs-string">&#x27;2018040625&#x27;</span>)<br><br>    <span class="hljs-comment"># 调用实例方法 打印stu_2对应的值</span><br>    stu_2.speak()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别学号是否为指定值</span><br>    stu_2.identify_stu()<br><br>---------------------------------------------------------<br>我的学号为 <span class="hljs-number">2018014002</span>，很高兴认识大家<br>我的分组已经完成<br>我的父类是Person<br>------------------------------------<br>我的学号为 <span class="hljs-number">2018040625</span>，很高兴认识大家<br>请稍后，马上为你自动分组<br><br></code></pre></td></tr></table></figure><h2 id="类的多态">4.7 类的多态</h2><p>1、什么是多态？</p><p>多态是指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承）</p><blockquote><p>注：多态和多态性不是同一概念。</p><p>什么是多态性？</p><ul><li><p>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。<strong>子类继承父类；子类重写父类方法</strong></p></li><li><p>多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的爸爸说了一句话&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brother</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的哥哥在奔跑...&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的哥哥在说话...&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明也说话&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    b = Brother()<br>    b.run()<br>    b.talk()<br><br>    p = Parent()<br>    p.talk()<br><br>    c = Child()<br>    c.talk()<br>    <br>----------------------------------------------------<br>小明的哥哥在奔跑...<br>小明的哥哥在说话...<br>小明的爸爸说了一句话<br>小明也说话<br></code></pre></td></tr></table></figure><p>2、为什么要使用多态？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">metaclass=abc.ABCMeta</span>):</span> <span class="hljs-comment">#同一类事物:动物</span><br><span class="hljs-meta">    @abc.abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之一:猫</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say miaomiao&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之二:狗</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say wangwang&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之三:猪</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say aoao&#x27;</span>)<br><br>c = Cat()<br>d = Dog()<br>p = Pig()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">obj</span>):</span><br>    obj.talk()<br><br>func(c)<br>func(d)<br>func(p)<br><br>------------------------------<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>say miaomiao<br><span class="hljs-meta">&gt;&gt;&gt; </span>say wangwang<br><span class="hljs-meta">&gt;&gt;&gt; </span>say aoao<br></code></pre></td></tr></table></figure><p>仅仅是用了一个 <code>func(obj)</code> 函数，不同的对象就实现了不同的功能。综上可以说，多态性是 : <strong>一个接口，多种实现</strong></p><p><strong>多态性的好处:</strong></p><ul><li>增加了程序的<strong>灵活性</strong>，以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如 <code>func(obj)</code></li><li>增加了程序额<strong>可扩展性</strong>，通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用 <code>func(obj)</code> 去调用</li></ul><h2 id="类的多重继承">4.8 类的多重继承</h2><p>1、什么是多重继承？</p><p>我理解为一个子类可以继承多个父类。</p><p>2、多重继承的方法？</p><p><code>class Child(Parent1, Parent 2, Parent 3...)</code>，从左往右依次继承</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tool</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;tool work&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;car will run&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;food work&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cake</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;i like cake&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">Tool, Food</span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Person()<br>    print(p.car(), <span class="hljs-string">&#x27; &#x27;</span>, p.cake())<br>    print(p.work())  <span class="hljs-comment"># 继承的第一个类</span><br>    print(Person.__mro__)  <span class="hljs-comment"># 得到类的继承顺序</span><br><br>------------------------------<br>car will run   i like cake<br>tool work<br>(&lt;class &#x27;__main__.Person&#x27;&gt;, &lt;class &#x27;__main__.Tool&#x27;&gt;, &lt;class &#x27;__main__.Food&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)<br><br></code></pre></td></tr></table></figure><blockquote><p>注：继承关系可以延续。例，孙子继承父亲，父亲继承爷爷，则孙子也继承爷爷。</p></blockquote><h3 id="举个栗子----编程练习-2">举个栗子----编程练习：</h3><p>圆形、长方形除了是几何学科中的基本图形之外，也还是我们日常生活中最常见的平面图形。请根据面向对象的相关知识，将上述两种平面图形用Python语言进行表示，使得我们的程序可以正常对其使用。</p><p>任务 1、自定义Point类，并重写其构造（初始化）方法 <code>__init__( )</code>，将参数x和y赋值给实例对象的属性 2、自定义该类实例方法<code>string( )</code>，功能：打印“{X：xx, Y：xx}” 3、自定义Circle类，继承自Point类，并重写其构造（初始化）方法<code>__init__( )</code>，x、y参数通过调用父类的构造函数进行赋值，radius通过子类重写的<code>__init__( )</code>进行赋值。 4、自定义该类实例方法<code>string( )</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; {半径为：xx}” 5、自定义Size类，并重写其构造（初始化）方法<code>__init__( )</code>，将参数width和height赋值给实例对象的属性 6、自定义该类实例方法<code>string( )</code>，功能：打印“{Width：xx, Height：xx}” 7、自定义Rectangle类，继承自Point类和Size类，并重写其构造（初始化）方法<code>__init__( )</code>，x、y、width、height 4个参数全部通过调用父类的构造函数进行赋值 8、自定义该类实例方法<code>string( )</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; 长宽分别为：{Width：xx, Height：xx} 9、初始化Circle类的对象c，并调用其格式化输出函数<code>string( )</code> 10、初始化Rectangle类的对象r1、r2,并分别调用其格式化输出函数<code>string( )</code></p><p>任务提示 1、在自定义Rectangle类的构造方法时，调用父类方法必须按照<code>类名.__init__(参数列表)</code>的方式进行调用，如<code>Point.__init__(self, x, y)</code> 2、自定义Rectangle类格式化输出方法时，调用父类的格式化输出函数<code>string()</code>时，应按照<code>类名.string(参数)</code>的方式进行调用，如<code>Point.string(self)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    x = <span class="hljs-number">1.0</span><br>    y = <span class="hljs-number">1.0</span><br><br>    <span class="hljs-comment"># 自定义Point类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y</span>):</span><br>        self.x = x<br>        self.y = y<br>        print(<span class="hljs-string">&quot;Point 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Point类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;X: %s, Y: %s&#125;&quot;</span>  % (self.x, self.y))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">Point</span>):</span><br>    <span class="hljs-comment"># 自定义Circle类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, radius</span>):</span><br>        Point.__init__(self, x, y)<br>        self.radius = radius<br>        print(<span class="hljs-string">&quot;Circle 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Circle类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;该图形初始化点为: &#123;X: &quot;</span> + <span class="hljs-built_in">str</span>(self.x) + <span class="hljs-string">&quot;, Y: &quot;</span> + <span class="hljs-built_in">str</span>(self.y) \<br>               + <span class="hljs-string">&quot;&#125;, &#123;半径为: &quot;</span> + <span class="hljs-built_in">str</span>(self.radius) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 自定义Size类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br>        print(<span class="hljs-string">&quot;Size 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Size类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;Height: &quot;</span> + <span class="hljs-built_in">str</span>(self.width) + <span class="hljs-string">&quot;, Width: &quot;</span> + <span class="hljs-built_in">str</span>(self.height) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">Point, Size</span>):</span><br>    <span class="hljs-comment"># 自定义Rectangle类的构造(初始化)方法，并在方法中调用父类的初始化方法以完成初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, width, height</span>):</span><br>        Point.__init__(self, x, y)<br>        Size.__init__(self, width, height)<br><br>    <span class="hljs-comment"># 自定义Rectangle类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;该图形初始化点为: &#123;X: &quot;</span> + <span class="hljs-built_in">str</span>(self.x) + <span class="hljs-string">&quot;, Y: &quot;</span> + <span class="hljs-built_in">str</span>(self.y) + <span class="hljs-string">&quot;&#125;&quot;</span> + \<br>              <span class="hljs-string">&quot;, 长宽分别为: &#123;Height: &quot;</span> + <span class="hljs-built_in">str</span>(self.width) + <span class="hljs-string">&quot;, Width: &quot;</span> + <span class="hljs-built_in">str</span>(self.height) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 实例化Point对象，点位置为（3, 3）</span><br>    p = Point(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>    p.string()<br><br>    <span class="hljs-comment"># 实例化Circle对象，圆心为（5,5），半径为8</span><br>    c = Circle(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br>    c.string()<br><br>    <span class="hljs-comment"># 实例化Rectangle对象，顶点位置（15,30），长和宽分别为20和10</span><br>    r = Rectangle(<span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)<br>    r.string()<br><br>------------------------------------------------------------------------------------------------------<br>Point 构造函数被调用...<br>&#123;X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">3</span>&#125;<br><br>Point 构造函数被调用...<br>Circle 构造函数被调用...<br>该图形初始化点为: &#123;X: <span class="hljs-number">5</span>, Y: <span class="hljs-number">5</span>&#125;, &#123;半径为: <span class="hljs-number">8</span>&#125;<br><br>Point 构造函数被调用...<br>Size 构造函数被调用...<br>该图形初始化点为: &#123;X: <span class="hljs-number">15</span>, Y: <span class="hljs-number">30</span>&#125;, 长宽分别为: &#123;Height: <span class="hljs-number">20</span>, Width: <span class="hljs-number">10</span>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>该案例如果用super()调用拥有同名方法的父类，就只会调用最靠前的拥有同名方法的类，后面的类中同名方法也就无法被调用。</strong></p><p><strong>因此本案例多继承中进行父类调用时采用“<code>类名.__init__</code>”的形式。</strong></p></blockquote><h2 id="类的高级函数">4.9 类的高级函数</h2><ul><li><code>__str__</code> 函数</li><li><code>__gtrattr()__</code> 函数</li><li><code>__setattr__</code> 函数</li><li><code>__call__</code> 函数</li></ul><h3 id="str__-函数">4.9.1 <code>__str__</code> 函数</h3><p>如果定义了该函数，当print当前实例化对象时候，会返回该函数的 return信息。</p><ul><li>通常会返回一个字符串作为类的描述信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 一般会定义一些类的描述信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;this is a test class&#x27;</span><br><br>t = Test()<br>print(t)<br></code></pre></td></tr></table></figure><h3 id="gtrattr__-函数">4.9.2 <code>__gtrattr__</code> 函数</h3><p>当调用的属性或者方法不存在时，会返回该方法定义的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这个key: &#123;&#125; 并不存在&#x27;</span>.<span class="hljs-built_in">format</span>(key)<br><br><span class="hljs-comment"># print(t.a)  # AttributeError: &#x27;Test&#x27; object has no attribute &#x27;a&#x27;</span><br>print(t.a )  <span class="hljs-comment"># &gt;&gt;&gt; 这个key: a 并不存在</span><br></code></pre></td></tr></table></figure><h3 id="setattr__.-函数">4.9.3 <code>__setattr__.</code> 函数</h3><p>拦截当前类中不存在的属性与值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span>(<span class="hljs-params">self, key, value</span>):</span><br>        <span class="hljs-comment"># print(key, value)</span><br>        self.__dict__[key] = value<br>        print(self.__dict__)<br><br>t = Test()<br>t.name = <span class="hljs-string">&#x27;小明&#x27;</span><br>print(t.name)<br><br>-----------------------------------------------<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小明&#x27;</span>&#125;<br>小明<br></code></pre></td></tr></table></figure><h3 id="call__-函数">4.9.4 <code>__call__</code> 函数</h3><p>本质是将一个类变成一个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, a</span>):</span><br>        print(<span class="hljs-string">&#x27;call func will start&#x27;</span>)<br>        print(a)<br><br>t = Test()<br>t(<span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br>-----------------------------------------------<br>call func will start<br>xiaoming<br></code></pre></td></tr></table></figure><h1 id="异常">5. 异常</h1><ul><li>异常就是错误</li><li><p>异常会导致程序崩溃并停止运行</p></li><li><p>python中的异常机制能监控并捕获异常，将异常部位的程序进行修理使得程序继续正常运行</p></li></ul><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    &lt;代码块<span class="hljs-number">1</span>&gt; 被<span class="hljs-keyword">try</span>关键字检查并保护的业务代码<br><span class="hljs-keyword">except</span> &lt;异常的类型&gt;:<br>    &lt;代码块<span class="hljs-number">2</span>&gt; <span class="hljs-comment"># 代码块1出现错误后执行的代码块</span><br></code></pre></td></tr></table></figure><p>1、捕获通用异常</p><ul><li>无法确定是在哪种异常情况下使用的捕获方法</li></ul><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    &lt;代码块&gt; <br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    &lt;异常代码块&gt; <br></code></pre></td></tr></table></figure><p>2、捕获具体异常</p><ul><li><p>确定是哪种异常的情况下使用的捕获方法</p></li><li><p><code>exceppt &lt;具体的异常类型&gt; as e</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">UPPER</span>(<span class="hljs-params">str_data</span>):</span><br>    new_str = <span class="hljs-string">&#x27;None&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        new_str = str_data.upper()<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e :<br>        print(<span class="hljs-string">&#x27;程序出错了:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(e))<br>    <span class="hljs-keyword">return</span> new_str<br><br>result = UPPER(<span class="hljs-string">&#x27;xiaohong&#x27;</span>)<br>result1 = UPPER(<span class="hljs-number">1</span>)<br>print(<span class="hljs-string">&#x27;result1 is&#x27;</span>, result1)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>        print(<span class="hljs-string">&#x27;hello&#x27;</span>)  <span class="hljs-comment"># 遇到错误立刻进入except，所以错误后的代码全都不会执行</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><br>test()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        print(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>        print(name)  <span class="hljs-comment"># except 里没有对应的异常类型，所以报错了</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><br>test1()<br></code></pre></td></tr></table></figure><p>3、捕获多个异常</p><ol type="1"><li>可以有多个except并列。但当第一个异常捕获到之后，不会再继续往下捕获。</li><li>写一个 <code>except (异常类型1, 异常类型2) as e</code> 。当except代码后边的异常类型使用<strong>元组</strong>包裹起来，捕获到哪种就抛哪种</li></ol><h2 id="常用异常类型">5.1 常用异常类型</h2><table><thead><tr class="header"><th style="text-align: left;">异常名称</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Exception</td><td style="text-align: left;">通用异常类型（基类）</td></tr><tr class="even"><td style="text-align: left;">ZeroDivisionError</td><td style="text-align: left;">不能整除0</td></tr><tr class="odd"><td style="text-align: left;">AttributeError</td><td style="text-align: left;">对象没有这个属性</td></tr><tr class="even"><td style="text-align: left;">IOError</td><td style="text-align: left;">输入输出操作失败</td></tr><tr class="odd"><td style="text-align: left;">IndexError</td><td style="text-align: left;">没有当前的索引</td></tr><tr class="even"><td style="text-align: left;">KeyError</td><td style="text-align: left;">没有这个键值（key）</td></tr><tr class="odd"><td style="text-align: left;">NameError</td><td style="text-align: left;">没有这个变量（未初始化对象）</td></tr><tr class="even"><td style="text-align: left;">SyntaxError</td><td style="text-align: left;">Python语法错误</td></tr><tr class="odd"><td style="text-align: left;">SystemError</td><td style="text-align: left;">解释器的系统错误</td></tr><tr class="even"><td style="text-align: left;">ValueError</td><td style="text-align: left;">传入的参数错误</td></tr></tbody></table><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br>t = Test()<br><span class="hljs-keyword">try</span>:<br>    t.name<br><span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># &#x27;Test&#x27; object has no attribute &#x27;name&#x27;</span><br><br>d = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小明&#x27;</span>&#125;<br><span class="hljs-keyword">try</span>:<br>    d[<span class="hljs-string">&#x27;age&#x27;</span>]<br><span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>    print(<span class="hljs-string">&#x27;没有对应的键: &#x27;</span>, e)  <span class="hljs-comment"># 没有对应的键:  &#x27;age&#x27;</span><br><br>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">try</span>:<br>    l[<span class="hljs-number">5</span>]<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># list index out of range</span><br><br>name = <span class="hljs-string">&#x27;ssss&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(name)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># invalid literal for int() with base 10: &#x27;ssss&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-keyword">return</span> a<br><span class="hljs-keyword">try</span>:<br>    test()<br><span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># test() missing 1 required positional argument: &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="异常中的finally">5.2 异常中的finally</h2><ul><li>无论是否发生异常，只要定义了 <code>finally</code>，就一定会执行其中的代码块。</li><li>在函数中，即便在 <code>try</code> 或 <code>except</code> 中进行了 return 也依然会执行 <code>finally</code> 语法块</li><li><code>try</code> 语法至少要伴随 <code>except</code> 或 <code>finally</code> 中的一个来使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(e)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;finally&#x27;</span><br>t = test1()<br>print(t)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&#x27;1&#x27;</span>)<br>        <span class="hljs-keyword">return</span> e<br>    <span class="hljs-keyword">finally</span>:<br>        print(<span class="hljs-string">&#x27;2&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;finally&#x27;</span>  <span class="hljs-comment"># 即使在try和except中进行return，也依然会执行finally</span><br>    <br>--------------------------------------------------<br>division by zero<br><span class="hljs-keyword">finally</span><br><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span><br></code></pre></td></tr></table></figure><h2 id="自定义异常类型与抛出异常">5.3 自定义异常类型与抛出异常</h2><h3 id="自定义抛出异常-raise">5.3.1 自定义抛出异常 <code>raise</code></h3><p>将信息以报错的形式抛出。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20210113161932209.png" alt="image-20210113161932209" /><figcaption>image-20210113161932209</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">if</span> number == <span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;number不可以是100&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> number<br><br>print(test(<span class="hljs-number">50</span>))<br>t = test(<span class="hljs-number">100</span>)  <span class="hljs-comment"># ValueError: number不可以是100</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> test(number)<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> e<br>    <br>t2 = test2(<span class="hljs-number">100</span>)<br>print(t2)<br><br>--------------------------------------------------<br><span class="hljs-number">50</span><br>number不可以是<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="自定义异常类">5.3.2 自定义异常类</h3><ul><li><strong>定义一个基类</strong>，然后继承基类----<code>Exception</code></li><li><strong>在构造函数中定义错误信息</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberLimitError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameLimitError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&#x27;小明&#x27;</span>:<br>        <span class="hljs-keyword">raise</span> NameLimitError(<span class="hljs-string">&#x27;小明不可以被填写&#x27;</span>)<br>    <span class="hljs-keyword">return</span> name<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test0</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">if</span> number &gt; <span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">raise</span> NumberLimitError(<span class="hljs-string">&#x27;数字不可以大于100&#x27;</span>)<br>    <span class="hljs-keyword">return</span> number<br><br><br><span class="hljs-keyword">try</span>:<br>    test(<span class="hljs-string">&#x27;小明&#x27;</span>)<br><span class="hljs-keyword">except</span> NameLimitError <span class="hljs-keyword">as</span> e:<br>    print(e)<br><br><span class="hljs-keyword">try</span>:<br>    test0(<span class="hljs-number">101</span>)<br><span class="hljs-keyword">except</span> NumberLimitError <span class="hljs-keyword">as</span> e:<br>    print(e)<br> <br>--------------------------------------------------<br>小明不可以被填写<br>数字不可以大于<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="断言">5.4 断言</h2><p>断言：用于判断一个表达式，在表达式条件为false的时候触发异常(为true不会触发异常，继续执行)。</p><p><code>assert expression, message</code></p><ul><li><code>expression</code> ：表达式，一般是判断相等，或者判断是某种数据类型的 <code>bool</code> 判断的语句</li><li><code>message</code> ：具体的错误信息</li><li>无返回值</li></ul><h3 id="使用断言对综合案例进行改进">使用断言对综合案例进行改进</h3><p>很好的案例。一定要吃透！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    学生信息库</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>students = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小鱼&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小何&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">5</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小安&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 缺少参数的错误，定义一个基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotArgError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentInfo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, students</span>):</span><br>        self.students = students<br><br>    <span class="hljs-comment"># 查找，通过学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_id</span>(<span class="hljs-params">self, student_id</span>):</span><br>        <span class="hljs-keyword">return</span> self.students.get(student_id)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_students</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># get_all_students</span><br>        <span class="hljs-keyword">for</span> id_, value <span class="hljs-keyword">in</span> self.students.items():<br>            print(<span class="hljs-string">&#x27;学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                id_, value[<span class="hljs-string">&#x27;name&#x27;</span>], value[<span class="hljs-string">&#x27;age&#x27;</span>], value[<span class="hljs-string">&#x27;sex&#x27;</span>], value[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>            ))<br>        <span class="hljs-keyword">return</span> self.students<br><br>    <span class="hljs-comment"># 添加单个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, **student</span>):</span>  <span class="hljs-comment"># add_student</span><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.__add(**student)<br><br>    <span class="hljs-comment"># 添加多个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adds</span>(<span class="hljs-params">self, new_students</span>):</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> new_students:<br>            <span class="hljs-keyword">try</span>:<br>                self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                print(e, student.get(<span class="hljs-string">&#x27;name&#x27;</span>))<br>                <span class="hljs-keyword">continue</span><br>            self.__add(**student)<br><br>    <span class="hljs-comment"># 添加新的学号；并将新的学生入库</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add</span>(<span class="hljs-params">self, **student</span>):</span><br>        new_id = <span class="hljs-built_in">max</span>(self.students) + <span class="hljs-number">1</span><br>        self.students[new_id] = student<br><br>    <span class="hljs-comment"># 删除</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, student_id</span>):</span>  <span class="hljs-comment"># delete_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;号的同学的信息不存在&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br>        <span class="hljs-keyword">else</span>:<br>            user_info = self.students.pop(student_id)<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>    <span class="hljs-comment"># 批量删除，删除学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deletes</span>(<span class="hljs-params">self, ids</span>):</span><br>        <span class="hljs-keyword">for</span> id_ <span class="hljs-keyword">in</span> ids:  <span class="hljs-comment"># id_防止和函数id()冲突</span><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;id_&#125;</span> 不存在学生库中&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br>            student_info = students.pop(id_)<br>            print(<span class="hljs-string">f&#x27;学号<span class="hljs-subst">&#123;id_&#125;</span> 学生<span class="hljs-subst">&#123;student_info[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span> 已被移除&#x27;</span>)<br><br><br>    <span class="hljs-comment"># 修改</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, student_id, **kwargs</span>):</span>  <span class="hljs-comment"># update_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;不存在学号：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**kwargs)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.students[student_id] = kwargs<br>        print(<span class="hljs-string">&#x27;&#123;&#125;同学信息更新完毕&#x27;</span>.<span class="hljs-built_in">format</span>(kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>    <span class="hljs-comment"># 批量更新，key是学号，value是信息  # todo:添加异常捕获 17&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updates</span>(<span class="hljs-params">self, update_students</span>):</span>  <span class="hljs-comment"># update_students是一个列表</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> update_students:<br>            <span class="hljs-keyword">try</span>:<br>                id_ = <span class="hljs-built_in">list</span>(student.keys())[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 不加list()是假列表  # todo：添加异常捕获  # list可能没有0索引</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续循环列表</span><br><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;学号 <span class="hljs-subst">&#123;id_&#125;</span> 不存在&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br><br>            user_info = student[id_]<br>            <span class="hljs-keyword">try</span>:<br>                check = self.check_user_info(**user_info)  <span class="hljs-comment"># todo：添加异常捕获</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span><br>            self.students[id_] = user_info<br>        print(<span class="hljs-string">&#x27;所有信息更新完成&#x27;</span>)<br><br>    <span class="hljs-comment"># 查询</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_users</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;参数数量传递错误&#x27;</span>  <span class="hljs-comment"># 参数不能为空，长度必须是1</span><br><br>        values = <span class="hljs-built_in">list</span>(self.students.values())<br>        key = <span class="hljs-literal">None</span><br>        value = <span class="hljs-literal">None</span><br>        result = []<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;name&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;age&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;sex&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;class_number&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;没有发现搜索的关键字&#x27;</span>)<br><br>        <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> values:  <span class="hljs-comment"># 吐过想用年龄字段模糊查询，需要把年龄改成str类型</span><br>            <span class="hljs-comment"># print(user[key])</span><br>            <span class="hljs-comment"># print(value)</span><br>            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">in</span> user[key]:  <span class="hljs-comment"># in 替代 = 实现模糊查找</span><br>                result.append(user)<br><br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-comment"># 验证参数是否合法，检查位置参数的判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_info</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-comment"># 判断长度是否为4；判断是否我们要的四个参数；判断参数类型是否正确</span><br>        <span class="hljs-comment"># 判断长度是否为4</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;参数必须是4个&#x27;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生姓名参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生年龄参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生性别参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生班级参数&#x27;</span>)<br><br>        <span class="hljs-comment"># 确认四个参数是不是想要的数据类型</span><br>        <span class="hljs-comment"># 先取出数据</span><br>        name_value = kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]<br>        age_value = kwargs[<span class="hljs-string">&#x27;age&#x27;</span>]<br>        sex_value = kwargs[<span class="hljs-string">&#x27;sex&#x27;</span>]<br>        class_number_value = kwargs[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br><br>        <span class="hljs-comment"># isinstance(对比的数据, 数据类型) isinstance(1, str)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(name_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;name 应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age_value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;age应该是整型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(sex_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;sex应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(class_number_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;class_number应该是字符串类型&#x27;</span>)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    student_info = StudentInfo(students)<br>    user = student_info.get_user_by_id(<span class="hljs-number">1</span>)<br>    student_info.add(name=<span class="hljs-string">&#x27;小绿&#x27;</span>, age=<span class="hljs-number">34</span>, class_number=<span class="hljs-string">&#x27;A&#x27;</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>    print(student_info.students)<br><br>    users = [<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小橙&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小黄&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>    ]<br>    student_info.adds(users)<br>    student_info.get_all_students()<br><br>    student_info.deletes([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>])<br>    student_info.get_all_students()<br><br>    student_info.updates([<br>        &#123;<span class="hljs-number">2</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;何同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span>&#125;&#125;,<br>        &#123;<span class="hljs-number">4</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span>&#125;&#125;<br>    ])<br>    student_info.get_all_students()<br><br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;小&#x27;</span>)<br>    print(result)<br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 会把所有的都打印出来</span><br>    print(result)<br><br></code></pre></td></tr></table></figure><h1 id="bug">6. bug</h1><p>bug 是程序中出现的错误，但有没有通过异常去捕获，以至于直接抛出，导致程序的崩溃。</p><p>如何检查 bug？</p><ol type="1"><li><p>调试工具(eg.pycharm) debug。在想要停止的行的左侧点击一下会出现一个小红点，断点。程序运行到这行会停止(包括这一行)。</p></li><li><p>多打印信息。(多print可以聚焦错误点，简单)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django学习笔记</title>
    <link href="/2020/11/10/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/10/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>爬虫基础</title>
    <link href="/2020/11/01/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/11/01/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-爬虫简介">第一章 爬虫简介</h1><h2 id="爬虫概述">爬虫概述</h2><p><strong>爬虫</strong>，就是给网站发起请求，并从响应中提取需要的数据的自动化程序。</p><ol type="1"><li><p><strong>发起请求，获取响应</strong></p><p>通过 HTTP 库，对目标站点进行请求。等同于自己打开浏览器，输入网址</p><p>常用库：urllib，urllib3，requests</p><p>服务器会返回请求的内容，一般为：HTML、二进制文件（视频，音频）、文档，json字符串等</p></li><li><p><strong>解析内容</strong></p><p>寻找自己需要的信息，就是利用正则表达式或其他库提取目标信息</p><p>常用库：re、beautifulsoup4</p></li><li><p><strong>保存数据</strong></p><p>将解析的数据持久化存储到文件或数据库中。</p></li></ol><h2 id="http协议">HTTP协议</h2><ul><li>概念：用于从万维网服务器传输超文本到本地浏览器的传送协议。就是服务器和客户端进行数据交互的形式。</li></ul><h3 id="常见的请求头信息">常见的请求头信息</h3><ul><li><p><strong>User-Agent：</strong>请求载体的身份标识</p></li><li><p><strong>Connection：</strong>浏览器通过这个头告诉服务器，请求完后是断开链接还是保持链接</p></li></ul><h3 id="常见的响应头信息">常见的响应头信息</h3><ul><li><strong>Content-Type：</strong>服务器通过这个头，告诉浏览器回送数据的类型</li></ul><h2 id="https协议">HTTPS协议</h2><p>HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。</p><h3 id="加密方式">加密方式</h3><ul><li>对称秘钥加密</li><li>非对称秘钥加密</li><li>证书秘钥加密</li></ul><h1 id="第二章-requests模块基础">第二章 requests模块基础</h1><h3 id="requests模块">requests模块</h3><p>requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率高。</p><ul><li>urllib模块</li><li>requests模块</li></ul><p><strong>requests模块作用：模拟浏览器发请求</strong></p><h3 id="如何使用requests模块的编码流程">如何使用：(requests模块的编码流程)</h3><ol type="1"><li>指定url<ul><li>UA伪装</li><li>请求参数的处理</li></ul></li><li>发起请求，get方法会返回一个响应对象</li><li>获取相应数据 <code>.text</code> 返回的是字符串形式的响应数据</li><li>持久化存储</li></ol><h4 id="栗子1爬取搜狗首页的页面数据">栗子1：爬取搜狗首页的页面数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬取搜狗首页的页面数据</span><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 1. 指定url</span><br>    url = <span class="hljs-string">&#x27;https://www.sogou.com/&#x27;</span><br><br>    <span class="hljs-comment"># 2. 发起请求</span><br>    <span class="hljs-comment"># get方法会返回一个响应对象</span><br>    response = requests.get(url=url)<br>    <span class="hljs-comment"># 3. 获取相应数据.text返回的是字符串形式的响应数据</span><br>    page_text = response.text<br>    print(page_text)<br>    <span class="hljs-comment"># 4. 持久化存储</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./sogou.html&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        fp.write(page_text)<br><br>    print(<span class="hljs-string">&#x27;爬取数据结束！&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="反爬机制">反爬机制：</h3><ul><li><strong>UA</strong>：User-Agent (请求载体的身份标识)</li><li><p><strong>UA检测</strong>：门户网站的服务器会检测对应请求的载体身份标识，如果检测到请求的载体身份标识为某一款浏览器，就说明该请求是一个正常的请求. 但是，如果检测到请求的载体身份标识不是基于某一款浏览器，则表示该请求为不正常的请求(爬虫)，则服务器就很有可能拒绝该次请求。</p></li><li><p><strong>UA伪装</strong>：让爬虫对应的请求载体身份标识伪装成某一款浏览器 like：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="栗子2ua伪装">栗子2：UA伪装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># UA伪装</span><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># UA伪装：将对应的User-Agent封装到一个字典中</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment"># 1. 指定url</span><br>    url = <span class="hljs-string">&#x27;https://www.sogou.com/web&#x27;</span><br><br>    <span class="hljs-comment"># 处理url携带的参数：封装到字典中</span><br>    kw = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;enter a word:&#x27;</span>)<br>    param = &#123;<br>        <span class="hljs-string">&#x27;query&#x27;</span>: kw<br>    &#125;<br>    <span class="hljs-comment"># 对指定的url发起的请求对应的url是携带参数的，并且请求过程中处理了参数</span><br>    response = requests.get(url=url, params=param,headers=headers)  <span class="hljs-comment"># 相当于动态拼接了参数</span><br><br>    page_text=response.text<br><br>    fileName = kw + <span class="hljs-string">&#x27;.html&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fileName,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        fp.write(page_text)<br><br>    print(fileName, <span class="hljs-string">&#x27;爬完了&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。</p><p>Ajax 是一种用于创建快速动态网页的技术。一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p></blockquote><blockquote><p>数据如果是通过ajax动态请求到的，可以捕获包(url再一次enter)</p></blockquote><h4 id="栗子3破解百度翻译post请求携带了参数">栗子3：破解百度翻译（post请求携带了参数）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 破解百度翻译</span><br><span class="hljs-comment"># - post请求（携带了参数）</span><br><span class="hljs-comment"># - 响应数据是一组jso数据</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 1. 指定url</span><br>    post_url = <span class="hljs-string">&#x27;https://fanyi.baidu.com/sug&#x27;</span><br>    <span class="hljs-comment"># 2. UA伪装</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span><br>    &#125;<br>    <span class="hljs-comment"># 3. post请求参数处理（同get请求一致）</span><br>    word = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;enter a word:&#x27;</span>)<br>    data = &#123;<br>        <span class="hljs-string">&#x27;kw&#x27;</span>:word<br>    &#125;<br>    <span class="hljs-comment"># 4.请求发送</span><br>    response = requests.post(url=post_url,data=data,headers=headers)<br>    <span class="hljs-comment"># 5. 获取响应数据.json()方法返回的是一个obj(如果确认响应数据是json类型的，才可以使用json())</span><br>    <span class="hljs-comment"># 可以看 Content-Type</span><br>    dic_obj = response.json()<br>    print(dic_obj)<br>    <span class="hljs-comment"># 持久化存储</span><br>    fileName = word + <span class="hljs-string">&#x27;.json&#x27;</span><br>    fp = <span class="hljs-built_in">open</span>(fileName,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    json.dump(dic_obj,fp=fp,ensure_ascii=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False</span><br><br>    print(<span class="hljs-string">&quot;done!&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>步骤：</p><ol type="1"><li>指定url</li><li>UA伪装</li><li>请求发送</li><li>获取响应数据</li><li>持久化存储</li></ol></blockquote><h4 id="栗子4爬取豆瓣电影">栗子4：爬取豆瓣电影</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬取豆瓣电影</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    url = <span class="hljs-string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span><br>    &#125;<br><br>    params = &#123;<br>        <span class="hljs-string">&#x27;type&#x27;</span>:<span class="hljs-string">&#x27;24&#x27;</span>,<br>        <span class="hljs-string">&#x27;interval_id&#x27;</span>:<span class="hljs-string">&#x27;100:90&#x27;</span>,<br>        <span class="hljs-string">&#x27;action&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-string">&#x27;start&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>,  <span class="hljs-comment"># 从库中第几个开始取</span><br>        <span class="hljs-string">&#x27;limit&#x27;</span>:<span class="hljs-string">&#x27;20&#x27;</span>,  <span class="hljs-comment"># 一次取的电影个数</span><br>    &#125;<br><br>    response = requests.get(url=url,params=params,headers=headers)<br><br>    list_data = response.json()<br><br>    fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./douban.json&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    json.dump(list_data,fp=fp,ensure_ascii=<span class="hljs-literal">False</span>)<br><br>    print(<span class="hljs-string">&#x27;done!&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="第三章-数据解析">第三章 数据解析</h1><p>聚焦爬虫：爬取页面中指定的页面内容。</p><p><div class="note note-warning">            <p><strong>至此，我们的数据爬取的流程可以修改为：</strong></p><ol type="1"><li><strong>指定url（UA伪装）</strong></li><li><strong>发起请求</strong></li><li><strong>获取响应数据</strong></li><li><strong>数据解析</strong></li><li><strong>持久化存储(不再存一整张页面)</strong></li></ol>          </div></p><p><strong>数据解析原理概述</strong>：解析的局部的文本内容都会在标签之内或者标签对应的属性中进行存储。</p><ol type="1"><li><p>进行指定标签的定位</p></li><li><p>标签或者标签对应属性的中存储的数据值进行提取(解析)</p></li></ol><p>数据解析分类:</p><ul><li>正则表达式</li><li>bs4</li><li>xpath (重点)</li></ul><h3 id="正则表达式使用re解析">1. 正则表达式（使用re解析）</h3><p>贪婪、非贪婪</p><p>贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。</p><p>例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">源字符串：aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc <br><br>正则表达式一：&lt;div&gt;.*&lt;/div&gt; <br>匹配结果一：&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt; <br><br><br>正则表达式二：&lt;div&gt;.*?&lt;/div&gt; <br>匹配结果二：&lt;div&gt;test1&lt;/div&gt;（这里指的是一次匹配结果，所以没包括&lt;div&gt;test2&lt;/div&gt;） <br></code></pre></td></tr></table></figure><p>根据上面的例子，从匹配行为上分析一下，什是贪婪与非贪婪模式。</p><p>正则表达式一采用的是贪婪模式，在匹配到第一个 <code>&lt;/div&gt;</code> 时已经可以使整个表达式匹配成功，但是由于采用的是贪婪模式，所以仍然要向右尝试匹配，查看是否还有更长的可以成功匹配的子串，匹配到第二个 <code>&lt;/div&gt;</code> 后，向右再没有可以成功匹配的子串，匹配结束，匹配结果为 <code>&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;</code> 。(实际的匹配过程并不是这样的...)。</p><blockquote><p>仅从应用角度分析，可以这样认为，贪婪模式，就是在整个表达式匹配成功的前提下，尽可能多的匹配，也就是所谓的“贪婪”，通俗点讲，就是看到想要的，有多少就捡多少，除非再也没有想要的了。</p></blockquote><p>正则表达式二采用的是非贪婪模式，在匹配到第一个 <code>&lt;/div&gt;</code> 时使整个表达式匹配成功，由于采用的是非贪婪模式，所以结束匹配，不再向右尝试，匹配结果为 <code>&lt;div&gt;test1&lt;/div&gt;</code> 。</p><blockquote><p>仅从应用角度分析，可以这样认为，非贪婪模式，就是在整个表达式匹配成功的前提下，尽可能少的匹配，也就是所谓的“非贪婪”，通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了。</p></blockquote><h4 id="re解析">re解析</h4><p><code>re.search(regex, str)</code></p><ul><li><p>在str中查找满足条件的字符串，匹配不上返回None</p></li><li><p>对返回结果可以分组，可在字符串内添加小括号分离数据</p><p><code>groups()</code></p><p><code>group(index)</code> ：返回指定分组内容</p></li></ul><h4 id="练习四川卫健委">练习：四川卫健委</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br><br>url = <span class="hljs-string">&quot;http://wsjkw.sc.gov.cn/scwsjkw/gzbd/fyzt.shtml&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.128 Safari/537.36&#x27;</span><br>&#125;<br><br>new_url = <span class="hljs-string">&quot;http://wsjkw.sc.gov.cn/scwsjkw/gzbd01/2020/2/16/410c4f700cf6439c9d20fa48bb3e6683.shtml&quot;</span><br>res = requests.get(new_url)<br>res.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>html = res.text<br><span class="hljs-comment"># print(html)</span><br>bs4 = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>temp = bs4.find(<span class="hljs-string">&quot;div&quot;</span>, class_=<span class="hljs-string">&#x27;wy_contMain fontSt&#x27;</span>)<br><span class="hljs-comment"># print(temp.text)</span><br><br><br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># patten = &quot;新增确诊病例(\d+)例&quot;</span><br>pattern = <span class="hljs-string">&quot;新增确诊病例(\d+)例.*?出院病例(\d+).*?疑似病例(\d+).*?死亡病例(\d+)&quot;</span>  <span class="hljs-comment"># .*? 非贪婪模式</span><br>res = re.search(pattern, temp.text)<br>print(res.groups())  <span class="hljs-comment"># (&#x27;11&#x27;, &#x27;12&#x27;, &#x27;60&#x27;, &#x27;2&#x27;)</span><br>print(res.group(<span class="hljs-number">0</span>))  <span class="hljs-comment"># 新增确诊病例11例，新增治愈出院病例12例，新增疑似病例60例，新增死亡病例2</span><br>print(res.group(<span class="hljs-number">1</span>), res.group(<span class="hljs-number">2</span>), res.group(<span class="hljs-number">3</span>),res.group(<span class="hljs-number">4</span>))  <span class="hljs-comment"># 11, 12, 60, 2</span><br><br></code></pre></td></tr></table></figure><h4 id="栗子1爬取糗事百科特定的图">栗子1：爬取糗事百科特定的图</h4><p><code>get().content</code> 返回的是二进制形式的图片数据·</p><p><strong>text（字符串）/content（二进制形式图片）/json（）（对象）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬取糗事百科特定的图</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    url = <span class="hljs-string">&#x27;https://pic.qiushibaike.com/system/pictures/12374/123744051/medium/9NBGP34WEBWKFRON.jpg&#x27;</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span><br>    &#125;<br><br><br>    response = requests.get(url=url,headers=headers)<br><br>    <span class="hljs-comment"># content返回的是二进制形式的图片数据</span><br>    <span class="hljs-comment"># text（字符串）content（二进制）json（）（对象）</span><br>    img_data = response.content<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./qiutu.jpg&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        fp.write(img_data)<br><br>    print(<span class="hljs-string">&#x27;done!&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="栗子2爬取糗事百科糗图板块下的所有的糗图图片">栗子2：爬取糗事百科糗图板块下的所有的糗图图片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬取糗事百科中热图板块下的图片</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># &lt;div class=&quot;thumb&quot;&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># &lt;a href=&quot;/article/123739568&quot; target=&quot;_blank&quot;&gt;</span><br><span class="hljs-comment"># &lt;img src=&quot;//pic.qiushibaike.com/system/pictures/12373/123739568/medium/J1YQ1CZA0P0NC1TV.jpg&quot; alt=&quot;糗事#123739568&quot; class=&quot;illustration&quot; width=&quot;100%&quot; height=&quot;auto&quot;&gt;</span><br><span class="hljs-comment"># &lt;/a&gt;</span><br><span class="hljs-comment"># &lt;/div&gt;</span><br><span class="hljs-comment"># ex = &lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建一个文件夹</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">&#x27;./qiutuLibs&#x27;</span>):<br>        os.mkdir(<span class="hljs-string">&#x27;./qiutuLibs&#x27;</span>)<br><br>    url = <span class="hljs-string">&#x27;https://www.qiushibaike.com/imgrank/&#x27;</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment"># 使用通用爬虫对url对应的一整张页面进行爬取,获得的是整张页面的源码数据</span><br>    page_text = requests.get(url=url,headers=headers).text<br><br>    <span class="hljs-comment"># 使用聚焦爬虫</span><br>    ex = <span class="hljs-string">&#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;&#x27;</span><br>    img_src_list = re.findall(ex,page_text,re.S)  <span class="hljs-comment"># re.S 单行匹配，re,M 多行匹配</span><br>    <span class="hljs-comment"># print(img_src_list)</span><br><br>    <span class="hljs-keyword">for</span> src <span class="hljs-keyword">in</span> img_src_list:<br>        <span class="hljs-comment"># 拼接出一个完整的图片url</span><br>        src = <span class="hljs-string">&#x27;https:&#x27;</span> + src<br>        <span class="hljs-comment"># 请求到了图片的二进制数据</span><br>        img_data = requests.get(url=src,headers=headers).content<br>        <span class="hljs-comment"># 生成图片名称</span><br>        img_name = src.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]<br>        imgPath = <span class="hljs-string">&#x27;./qiutuLibs/&#x27;</span> + img_name<br>        <span class="hljs-comment"># 图片存储的路径</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(imgPath,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>            fp.write(img_data)<br>            print(img_name,<span class="hljs-string">&#x27;下载成功！！！&#x27;</span>)<br><br><br>    print(<span class="hljs-string">&#x27;done!&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="栗子3爬取糗事百科图-分页爬取">栗子3：爬取糗事百科图-分页爬取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分页爬取</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">&#x27;./qiutu&#x27;</span>):<br>        os.mkdir(<span class="hljs-string">&#x27;./qiutu&#x27;</span>)<br><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment"># 设置一个通用的url模板</span><br>    url = <span class="hljs-string">&#x27;https://www.qiushibaike.com/imgrank/page/%d/&#x27;</span><br>    <span class="hljs-comment"># page_num = 1</span><br>    <span class="hljs-keyword">for</span> page_num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># 对应页码的url</span><br>        new_url = <span class="hljs-built_in">format</span>(url%page_num)<br>        print(new_url)<br><br>        <span class="hljs-comment"># 使用聚焦爬虫将页面中所有的图进行解析/提取,获得的是整张页面的源码数据</span><br>        page_text = requests.get(url=new_url,headers=headers).text<br>        ex = <span class="hljs-string">&#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;&#x27;</span><br>        img_src_list = re.findall(ex,page_text,re.S)<br><br>        <span class="hljs-keyword">for</span> src <span class="hljs-keyword">in</span> img_src_list:<br>            <span class="hljs-comment"># 拼接出一个完整的图片url</span><br>            src = <span class="hljs-string">&#x27;https:&#x27;</span> + src<br>            <span class="hljs-comment"># 请求到了图片的二进制数据</span><br>            img_data = requests.get(url=src, headers=headers).content<br>            <span class="hljs-comment"># 生成图片名称</span><br>            img_name = src.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]<br>            imgPath = <span class="hljs-string">&#x27;./qiutu/&#x27;</span> + img_name<br>            <span class="hljs-comment"># 图片存储的路径</span><br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(imgPath, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>                fp.write(img_data)<br>                print(img_name, <span class="hljs-string">&#x27;下载成功！！！&#x27;</span>)<br><br>    print(<span class="hljs-string">&quot;done&quot;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="beautifulsoup4">2. BeautifulSoup4</h3><p>beautifulsoup4 将复杂的HTML文档转换成一个树形结构，每个节点都是python对象。</p><h4 id="bs4数据解析的原理">bs4数据解析的原理：</h4><ol type="1"><li><p>实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中</p></li><li><p>通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取</p></li></ol><h4 id="如何实例化beautifulsoup对象">如何实例化BeautifulSoup对象：</h4><ul><li><p><code>from bs4 import BeautifulSoup</code></p></li><li><p>对象的实例化：</p><ul><li><p>将本地的html文档中的数据加载到该对象中(这种很麻烦)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./test.html&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>soup = BeautifulSoup(fp,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>将互联网上获取的页面源码加载到该对象中(一般用这种)</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">page_text = response.text<br>soup = BeautifulSoup(page_text,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br></code></pre></td></tr></table></figure> &gt; <strong>lxml 是一种解析器</strong>，得写，不然有warning</p></li></ul></li></ul><h4 id="提供的用于bs4数据解析的方法和属性">提供的用于bs4数据解析的方法和属性:</h4><ul><li><p><code>soup.tagName</code>：返回的是html中第一次出现的tagName</p><blockquote><p>例：</p><ul><li><code>soup.a</code> 只能找到第一个符合要求的标签</li><li><p><code>soup.a.attrs</code> 获取a所有的属性和属性值，返回一个字典</p></li><li><p><code>soup.a.attrs['href']</code> 获取标签中href属性</p></li></ul></blockquote></li><li><p><code>soup.find()</code> ：找到第一个符合要求的标签</p><blockquote><ul><li><code>find('tagName')</code> ：等同于 <code>soup.tagName</code></li><li>属性定位：<code>soup.find('a',class_ / id / attr='***' )</code></li></ul></blockquote></li><li><p><code>soup.find_all('tagName')</code> ：返回符合要求的所有标签(是一个列表)。</p></li><li><code>select</code> ：<code>select('某种选择器(id, class, 标签...选择器)')</code> 返回的是一个列表。<ul><li>层级选择器：常见的选择器：标签选择器(a)、类选择器(.)、id选择器(#)、层级选择器<ul><li><code>soup.select('.tang &gt; ul &gt; li &gt; a')</code> ： 标识的是一个层级</li><li><code>soup.select('.tang &gt; ul a')</code> ： 中间的空格表示跨越了多个层级</li></ul></li></ul></li><li>获取标签之间的文本数据:<ul><li><code>soup.a.text/string/get_text()</code></li><li><code>text / get_text()</code> ：可以获取某一个标签中所有的文本内容</li><li><code>string</code> ： 值可以获取该标签下面直系的文本内容</li></ul></li></ul><h4 id="练习四川卫健委-1">练习：四川卫健委</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br><br>url = <span class="hljs-string">&quot;http://wsjkw.sc.gov.cn/scwsjkw/gzbd/fyzt.shtml&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.128 Safari/537.36&#x27;</span><br>&#125;<br><br>res = requests.get(url)<br>res.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>html = res.text<br>bs = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>a = bs.find(<span class="hljs-string">&#x27;a&#x27;</span>)<br>print(a)<br>print(a.attrs)  <span class="hljs-comment"># 获取a所有的属性和属性值，返回一个字典</span><br>print(a.attrs[<span class="hljs-string">&#x27;href&#x27;</span>])<br><br><span class="hljs-comment">#########################   输出   #############################</span><br>&lt;a href=<span class="hljs-string">&quot;/scwsjkw/gzbd01/2021/5/14/c6fe8b1fa012498fa40782dce548dd34.shtml&quot;</span> target=<span class="hljs-string">&quot;_blank&quot;</span>&gt;&lt;img alt=<span class="hljs-string">&quot;四川省新型冠状病毒肺炎疫情最新情况（...&quot;</span> src=<span class="hljs-string">&quot;/scwsjkw/gzbd01/2021/5/14/c6fe8b1fa012498fa40782dce548dd34/images/a9a7764154734a4b9fc4fa963bb21cee.jpg</span><br>&quot;/&gt;&lt;/a&gt;<br>&#123;<span class="hljs-string">&#x27;target&#x27;</span>: <span class="hljs-string">&#x27;_blank&#x27;</span>, <span class="hljs-string">&#x27;href&#x27;</span>: <span class="hljs-string">&#x27;/scwsjkw/gzbd01/2021/5/14/c6fe8b1fa012498fa40782dce548dd34.shtml&#x27;</span>&#125;<br>/scwsjkw/gzbd01/<span class="hljs-number">2021</span>/<span class="hljs-number">5</span>/<span class="hljs-number">14</span>/c6fe8b1fa012498fa40782dce548dd34.shtml<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">new_url = <span class="hljs-string">&quot;http://wsjkw.sc.gov.cn&quot;</span> + a.attrs[<span class="hljs-string">&#x27;href&#x27;</span>]<br>print(new_url)  <span class="hljs-comment"># http://wsjkw.sc.gov.cn/scwsjkw/gzbd01/2021/5/14/c6fe8b1fa012498fa40782dce548dd34.shtml</span><br><br>res = requests.get(new_url)<br>res.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>html = res.text<br><span class="hljs-comment"># print(html)</span><br>bs4 = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>temp = bs4.find(<span class="hljs-string">&quot;div&quot;</span>, class_=<span class="hljs-string">&#x27;wy_contMain fontSt&#x27;</span>)<br>print(temp.text)<br><br><span class="hljs-comment">#########################   输出   #############################</span><br><br>    <span class="hljs-number">5</span>月<span class="hljs-number">13</span>日<span class="hljs-number">0</span>-<span class="hljs-number">24</span>时，四川无新增新型冠状病毒肺炎确诊病例，新增治愈出院病例<span class="hljs-number">1</span>例，无新增疑似病例，无新增死亡病例。<br><br>    截至<span class="hljs-number">5</span>月<span class="hljs-number">13</span>日<span class="hljs-number">24</span>时，全省累计报告新型冠状病毒肺炎确诊病例<span class="hljs-number">999</span>例(其中境外输入<span class="hljs-number">445</span>例），累计治愈出院<span class="hljs-number">968</span>例，死亡<span class="hljs-number">3</span>例，目前在院隔离治疗<span class="hljs-number">28</span>例，<span class="hljs-number">460</span>人尚在接受医学观察。<br><br>    <span class="hljs-number">5</span>月<span class="hljs-number">13</span>日<span class="hljs-number">0</span>-<span class="hljs-number">24</span>时，全省新增无症状感染者<span class="hljs-number">1</span>例（境外输入，为<span class="hljs-number">4</span>月<span class="hljs-number">18</span>日自荷兰乘机抵蓉，<span class="hljs-number">5</span>月<span class="hljs-number">13</span>日诊断为无症状感染者），当日转为确诊病例<span class="hljs-number">0</span>例，当日解除集中隔离医学观察<span class="hljs-number">0</span>例。尚在集中隔离医学观察<span class="hljs-number">28</span>例（均为境外输入），比前一日增加<span class="hljs-number">1</span>例。<br><br>    (无症状感染者具体情况由相关市&lt;州&gt;卫生健康委进行通报)<br><br>    全省<span class="hljs-number">183</span>个县（市、区）全部为低风险区。<br><br>    温馨提示：保持警惕，做好防护，勤洗手、不扎堆、少聚集，若有发热、咳嗽等不适症状，请及时就近前往发热门诊、哨点诊室、新冠病毒核酸检测机构。具体请点击https://hissct.mobimedical.cn/urgentYiq，随时查看距您最近的医疗卫生机构，快捷咨询，精准预约。<br><br>    点击健康四川官微左下角“疫情防控”栏目可查询“疫情动态”信息。<br></code></pre></td></tr></table></figure><h4 id="栗子爬取三国演义小说所有的章节标题和章节内容">栗子：爬取三国演义小说所有的章节标题和章节内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬取三国演义小说所有的章节标题和章节内容</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 对首页数据进行爬取</span><br>    url = <span class="hljs-string">&#x27;https://www.shicimingju.com/book/sanguoyanyi.html&#x27;</span><br><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span><br>    &#125;<br><br>    page_text = requests.get(url=url,headers=headers).text<br><br>    <span class="hljs-comment"># 在首页中解析出章节的标题和详情页的url</span><br>    <span class="hljs-comment"># 1. 实例化出BeautifulSoup对象，需要将页面源码数据加载到该对象中</span><br>    soup = BeautifulSoup(page_text,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br>    <span class="hljs-comment"># 2. 解析章节标题和url</span><br>    li_list = soup.select(<span class="hljs-string">&#x27;.book-mulu &gt; ul &gt; li&#x27;</span>)<br>    <span class="hljs-comment"># print(li_list)</span><br>    fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./sanguo.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>        title = li.a.string<br>        detail_url = <span class="hljs-string">&#x27;https://www.shicimingju.com&#x27;</span> + li.a[<span class="hljs-string">&#x27;href&#x27;</span>]<br><br>        <span class="hljs-comment"># 对详情页发起请求，解析出章节内容</span><br>        detail_page_text = requests.get(url=detail_url,headers=headers).text<br><br>        <span class="hljs-comment"># 解析出详情页中相关的章节内容</span><br>        detail_soup = BeautifulSoup(detail_page_text,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br>        div_tag = detail_soup.find(<span class="hljs-string">&#x27;div&#x27;</span>,class_=<span class="hljs-string">&#x27;chapter_content&#x27;</span>)<br><br>        <span class="hljs-comment"># 解析到了章节内容</span><br>        content = div_tag.text<br><br>        <span class="hljs-comment"># 持久化存储(不能写到循环里)</span><br>        fp.write(title+<span class="hljs-string">&#x27;:&#x27;</span>+content+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        print(title,<span class="hljs-string">&#x27;爬取成功&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="xpath解析">3. xpath解析</h3><p>xpath解析：最常用且最高效便捷的一种解析方式。通用性最强。</p><h4 id="xpath解析原理">xpath解析原理：</h4><ol type="1"><li>实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。</li><li>调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获</li></ol><h4 id="如何实例化一个etree对象">如何实例化一个etree对象:</h4><ul><li><p><code>from lxml import etree</code></p></li><li><p>对象的实例化：</p><ul><li><p>将本地的html文档中的源码数据加载到该对象中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">etree.parse(filePath)<br></code></pre></td></tr></table></figure></li><li><p>可以将从互联网上获取的源码数据加载到该对象中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">etree.HTML(<span class="hljs-string">&#x27;PAGE_text&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>xpath('xpath表达式')</strong> <strong>(重点！)</strong></p></li></ul></li></ul><h4 id="xpath表达式">xpath表达式:</h4><ul><li><p><code>/</code>：表示的是从根节点开始定位。标识的是一个层级</p><p><code>//</code>：表示的是多个层级。可以表示从任意位置开始定位</p><ul><li><code>/text()</code> 获取的是标签中直系的文本内容</li><li><code>//text()</code> 标签中非直系的文本内容(所有的文本内容)</li></ul></li><li><p>属性定位：<code>tagName[@attr=&quot;属性名称&quot;]</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#找到class属性值为song的div标签</span><br>//div[@class=&quot;song&quot;]<br></code></pre></td></tr></table></figure></li><li><p>层级&amp;索引定位:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#找到class属性值为tang的div的直系子标签ul下的第二个子标签li下的直系子标签a</span><br>//div[@class=&quot;tang&quot;]/ul/li[2]/a<br></code></pre></td></tr></table></figure></li><li><p>逻辑运算：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#找到href属性值为空且class属性值为du的a标签</span><br>//a[@href=&quot;&quot; and @class=&quot;du&quot;]<br></code></pre></td></tr></table></figure></li><li><p>模糊匹配：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">//div[contains(@class, &quot;ng&quot;)]<br>//div[starts-with(@class, &quot;ta&quot;)]<br></code></pre></td></tr></table></figure></li><li><p>取文本:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /表示获取某个标签下的文本内容</span><br><span class="hljs-comment"># //表示获取某个标签下的文本内容和所有子标签下的文本内容</span><br>//div[@class=&quot;song&quot;]/p[1]/text()<br>//div[@class=&quot;tang&quot;]//text()<br></code></pre></td></tr></table></figure><ul><li>取属性：/<span class="citation" data-cites="attrName">@attrName</span> (前面这里是属性定位)/img/<span class="citation" data-cites="src">@src</span></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">//div[@class=&quot;tang&quot;]//li[2]/a/@href<br></code></pre></td></tr></table></figure></li><li>如果发生乱码问题:<ul><li>第一种:可以手动设定响应数据的编码格式 <code>response.encoding = 'utf-8'</code></li><li>第二种:通用处理中文乱码的解决方案(可能更有效？) <code>img_name = img_name.encode('iso-8859-1').decode('gbk')</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django基础----视图层</title>
    <link href="/2020/10/30/Django%E5%9F%BA%E7%A1%802/"/>
    <url>/2020/10/30/Django%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<h1 id="视图层">2. 视图层</h1><p>视图层是Django处理请求的核心代码层，它对外接收用户请求，对内调度模型层和模版层，统合数据库和前端，最后根据业务逻辑，将处理好的数据，与前端结合，返回给用户。视图层是真正的后端，是Python工程师的‘主营业务’。</p><p>Django的视图层包含下面一些主要内容：</p><ul><li>URL路由</li><li>视图函数</li><li>快捷方式</li><li>装饰器</li><li>请求与响应</li><li>类视图</li><li>文件上传</li><li>CSV/PDF生成</li><li>内置中间件</li></ul><h2 id="url路由基础">2.1 URL路由基础</h2><p>URL是Web服务的入口，用户通过浏览器发送过来的任何请求，都是发送到一个指定的URL地址，然后被响应。</p><h3 id="django如何处理请求">2.1.1 Django如何处理请求</h3><p>当用户请求一个页面时，Django根据下面的逻辑执行操作：</p><ol type="1"><li><strong>决定要使用的根URLconf模块。</strong>通常，这是<code>ROOT_URLCONF</code>设置的值，但是如果传入的HttpRequest对象具有urlconf属性（由中间件设置），则其值将被用于代替<code>ROOT_URLCONF</code>设置。也就是说你可以自定义项目入口url是哪个文件！</li><li><strong>加载该模块并寻找可用的urlpatterns。</strong> 它是<code>django.urls.path()</code>或者<code>django.urls.re_path()</code>实例的一个列表。</li><li><strong>依次匹配每个URL模式，在与请求的URL相匹配的第一个模式停下来</strong>。也就是说，url匹配是从上往下的短路操作（匹配就停），所以url在列表中的位置非常关键。</li><li>导入并调用匹配行中给定的视图，该视图是一个简单的Python函数（被称为视图函数）,或基于类的视图。 视图将获得如下参数:</li><li>一个HttpRequest 实例。</li><li>如果匹配的表达式返回了未命名的组，那么匹配的内容将作为位置参数提供给视图。</li><li>关键字参数由表达式匹配的命名组组成，但是可以被<code>django.urls.path()</code>的可选参数kwargs覆盖。</li><li>如果没有匹配到任何表达式，或者过程中抛出异常，将调用一个适当的错误处理视图。（比如403，比如无任何反应）</li></ol><p>先看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;articles/2003/&#x27;</span>, views.special_case_2003),<br>    path(<span class="hljs-string">&#x27;articles/&lt;int:year&gt;/&#x27;</span>, views.year_archive),<br>    path(<span class="hljs-string">&#x27;articles/&lt;int:year&gt;/&lt;int:month&gt;/&#x27;</span>, views.month_archive),<br>    path(<span class="hljs-string">&#x27;articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/&#x27;</span>, views.article_detail),<br>]<br></code></pre></td></tr></table></figure><p>注意：</p><ol type="1"><li>urlpatterns是个列表，每个元素都是<code>path()</code> 或 <code>re_path()</code> 的实例</li><li>要捕获一段url中的值，需要使用<strong>尖括号</strong>，而不是之前的圆括号；</li><li>可以转换捕获到的值为指定类型，比如例子中的int。默认情况下，捕获到的结果保存为字符串类型，不包含<code>/</code>这个特殊字符；</li><li>匹配模式的最开头不需要添加<code>/</code>，因为默认情况下，每个url都带一个最前面的<code>/</code>，既然大家都有的部分，就不用浪费时间特别写一个了。</li><li>每个匹配模式都建议以斜杠结尾</li></ol><h3 id="path转换器">2.1.2 path转换器</h3><p>默认情况下，Django内置下面的路径转换器：</p><ul><li><code>str</code>：匹配任何非空字符串，但不含斜杠<code>/</code>，如果你没有专门指定转换器，默认使用该转换器</li><li><code>int</code>：匹配0和正整数，返回一个int类型</li><li>...</li></ul><p>对于更复杂的匹配需求，可能需要自定义自己的path转换器。</p><p>path转换器其实就是一个类，包含下面的成员和属性：</p><ul><li>类属性<code>regex</code>：一个字符串形式的正则表达式属性；</li><li><code>to_python(self, value)</code> 方法：一个用来将匹配到的字符串转换为你想要的那个数据类型，并传递给视图函数。如果转换失败，它必须弹出ValueError异常；</li><li><code>to_url(self, value)</code>方法：将Python数据类型转换为一段url的方法，上面方法的反向操作。如果转换失败，也会弹出<code>ValueError</code>异常。</li></ul><p>例如，新建一个<code>converters.py</code>文件，与urlconf同目录，写个下面的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FourDigitYearConverter</span>:</span><br>    regex = <span class="hljs-string">&#x27;[0-9]&#123;4&#125;&#x27;</span>  <span class="hljs-comment"># 1234,5678....</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_python</span>(<span class="hljs-params">self, value</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(value)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_url</span>(<span class="hljs-params">self, value</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;%04d&#x27;</span> % value<br></code></pre></td></tr></table></figure><p>写完类后，在URLconf 中使用<code>register_converter</code>注册它，如下所示，注册了一个yyyy：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> register_converter, path<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> converters, views<br><br>register_converter(converters.FourDigitYearConverter, <span class="hljs-string">&#x27;yyyy&#x27;</span>)<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;articles/2003/&#x27;</span>, views.special_case_2003),<br>    path(<span class="hljs-string">&#x27;articles/&lt;yyyy:year&gt;/&#x27;</span>, views.year_archive),<br>    ...<br>]<br></code></pre></td></tr></table></figure><ul><li>匹配部分</li></ul><p>请求的URL被看做是一个普通的Python字符串，URLconf在其上查找并匹配。<strong>进行匹配时将不包括GET或POST请求方式的参数以及域名。</strong></p><p>例如，在<code>https://www.example.com/myapp/</code>的请求中，URLconf将查找<code>myapp/</code>。</p><p>在<code>https://www.example.com/myapp/?page=3</code>的请求中，URLconf也将查找<code>myapp/</code>。</p><p>URLconf不检查使用何种HTTP请求方法，所有请求方法POST、GET、HEAD等都将路由到同一个URL的同一个视图。在视图中，才根据具体请求方法的不同，进行不同的处理。</p><ul><li>指定视图参数的默认值</li></ul><p>有一个小技巧，我们可以指定视图参数的默认值。 下面是一个URLconf和视图的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># URLconf</span><br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;blog/&#x27;</span>, views.page),<br>    path(<span class="hljs-string">&#x27;blog/page&lt;int:num&gt;/&#x27;</span>, views.page),<br>]<br><br><span class="hljs-comment"># 视图 (blog/views.py)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">page</span>(<span class="hljs-params">request, num=<span class="hljs-number">1</span></span>):</span><br>    <span class="hljs-comment"># Output the appropriate page of blog entries, according to num.</span><br>    ...<br></code></pre></td></tr></table></figure><p>在上面的例子中，两个URL模式指向同一个视图<code>views.page</code>。但是第一个模式不会从URL中捕获任何值。 如果第一个模式匹配，page()函数将使用num参数的默认值&quot;1&quot;。 如果第二个模式匹配，page()将使用捕获的num值。</p><h2 id="路由转发">2.2 路由转发</h2><p>通常，我们会在每个app里，各自创建一个urls.py路由模块，然后从根路由出发，将app所属的url请求，全部转发到相应的urls.py模块中。</p><p>路由转发使用的是<code>include()</code>方法，需要提前导入，它的参数是转发目的地路径的字符串，路径以圆点分割。每当Django 遇到<code>include()</code>时，它会去掉URL中匹配的部分并将剩下的字符串发送给include的URLconf做进一步处理，也就是转发到<strong>二级路由</strong>去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> include, path   <br><br>urlpatterns = [<br>    <span class="hljs-comment"># ... 省略...</span><br>    path(<span class="hljs-string">&#x27;community/&#x27;</span>, include(<span class="hljs-string">&#x27;aggregator.urls&#x27;</span>)),<br>    path(<span class="hljs-string">&#x27;contact/&#x27;</span>, include(<span class="hljs-string">&#x27;contact.urls&#x27;</span>)),<br>    <span class="hljs-comment"># 比如上面这个，直接跳转道contact文件？的urls里</span><br>]<br></code></pre></td></tr></table></figure><h2 id="视图函数">2.3 视图函数</h2><p>视图函数，简称视图，本质上是一个简单的Python函数，<strong>它接受Web请求并且返回Web响应。</strong></p><p>响应的内容可以是HTML网页、重定向、404错误，XML文档或图像等任何东西。但是，无论视图本身是个什么处理逻辑，最好都返回某种响应。</p><p>视图函数的代码放在项目或应用程序目录中的名为<code>views.py</code>的文件中。</p><h3 id="简单的视图">2.3.1 简单的视图</h3><p>下面是一个返回当前日期和时间作为HTML文档的视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">current_datetime</span>(<span class="hljs-params">request</span>):</span><br>    now = datetime.datetime.now()<br>    html = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;&quot;</span> % now<br>    <span class="hljs-keyword">return</span> HttpResponse(html)<br></code></pre></td></tr></table></figure><p>让我们逐行分析一下上面的代码：</p><ul><li>首先，从<code>django.http</code>模块导入了<code>HttpResponse</code>类，以及Python的datetime库。</li><li>接着，我们定义了<code>current_datetime</code>视图函数。</li><li>每个视图函数都接收一个<code>HttpRequest</code>对象作为第一位置参数，一般取名为<code>request</code>，你可以取别的名字，但这不符合潜规则，最好不要那么做。</li><li>视图函数的名称没有强制规则，但尽量不要和Python及Django内置的各种名称重名，并且尽量精确地反映出它的功能，比如这里的<code>current_datetime</code>。</li><li>该视图返回一个<code>HttpResponse</code>对象，其中包含生成的HTML页面。</li></ul><h3 id="返回错误">2.3.2 返回错误</h3><h4 id="默认的">默认的</h4><p>HttpResponse的许多子类对应着除了200（代表“OK”）以外的一些常用的HTTP状态码。</p><p>为了标示一个错误，可以直接返回那些子类中的一个实例，而不是普通的HttpResponse。像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse, HttpResponseNotFound<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">if</span> foo:<br>        <span class="hljs-keyword">return</span> HttpResponseNotFound(<span class="hljs-string">&#x27;&lt;h1&gt;Page not found&lt;/h1&gt;&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;&lt;h1&gt;Page was found&lt;/h1&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>Django为404错误提供了一个特化的子类HttpResponseNotFound。由于一些状态码不太常用，所以不是每个状态码都有一个特化的子类。</p><h4 id="自定义错误页面">自定义错误页面</h4><p>Django有内置的HTML模版，用于返回错误页面给用户，但是这些403，404页面实在丑陋，通常我们都自定义错误页面。</p><p>首先，在根URLconf中额外增加下面的条目，并导入views模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> app <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),<br>]<br><br><span class="hljs-comment"># 增加的条目</span><br>handler400 = views.bad_request<br>handler403 = views.permission_denied<br>handler404 = views.page_not_found<br>handler500 = views.error<br></code></pre></td></tr></table></figure><p>然后在，app/views.py文件中增加四个处理视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> django.views.decorators.csrf <span class="hljs-keyword">import</span> requires_csrf_token<br><br><span class="hljs-meta">@requires_csrf_token</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bad_request</span>(<span class="hljs-params">request, exception</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;400.html&#x27;</span>)<br><br><span class="hljs-meta">@requires_csrf_token</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permission_denied</span>(<span class="hljs-params">request, exception</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;403.html&#x27;</span>)<br><br><span class="hljs-meta">@requires_csrf_token</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">page_not_found</span>(<span class="hljs-params">request, exception</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;404.html&#x27;</span>)<br><br><span class="hljs-meta">@requires_csrf_token</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;500.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再根据自己的需求，创建对应的400、403、404、500.html四个页面文件，就可以了（要注意好模板文件的引用方式，视图的放置位置等等）。</p><p><strong>只有当DEBUG设置为False时，这些错误视图才会被自动使用。DEBUG为True表示开发模式，Django会展示详细的错误信息页面，而不是针对性的错误页面。</strong></p><h3 id="内置的快捷方法">2.3.3 内置的快捷方法</h3><p>Django在<code>django.shortcuts</code>模块中，为我们提供了很多快捷方便的类和方法，它们都很重要，使用频率很高。</p><h4 id="render">render()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">render(request, template_name, context=<span class="hljs-literal">None</span>, content_type=<span class="hljs-literal">None</span>, status=<span class="hljs-literal">None</span>, using=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p><strong>结合一个给定的模板和一个给定的上下文字典，返回一个渲染后的HttpResponse对象。</strong></p><p><strong>必需参数：</strong></p><ul><li><strong>request</strong>：视图函数处理的当前请求，封装了请求头的所有数据，其实就是视图参数request。</li><li><strong>template_name</strong>：要使用的模板的完整名称或者模板名称的列表。如果是一个列表，将使用其中能够查找到的第一个模板。</li></ul><p><strong>可选参数：</strong></p><ul><li><strong>context</strong>：添加到模板上下文的一个数据字典。默认是一个空字典。可以将认可需要提供给模板的数据以字典的格式添加进去。这里有个小技巧，使用Python内置的<code>locals()</code>方法，可以方便地将函数作用域内的所有变量一次性添加进去。</li><li><strong>content_type</strong>：用于生成的文档的MIME类型。 默认为<code>DEFAULT_CONTENT_TYPE</code>设置的值，也就是<code>'text/html'</code>。</li><li><strong>status</strong>：响应的状态代码。 默认为200。</li><li><strong>using</strong>：用于加载模板使用的模板引擎的NAME。</li></ul><p><strong>范例：</strong></p><p>下面的例子将渲染模板<code>myapp/index.html</code>，MIME类型为<code>application/xhtml+xml</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># View code here...</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;myapp/index.html&#x27;</span>, &#123;<br>        <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    &#125;, content_type=<span class="hljs-string">&#x27;application/xhtml+xml&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="redirect">redirect()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">redirect(to, *args, permanent=<span class="hljs-literal">False</span>,* *kwargs)<br></code></pre></td></tr></table></figure><p><strong>根据传递进来的url参数，返回HttpResponseRedirect。</strong></p><p>参数to可以是：</p><ul><li>一个模型实例：将调用模型的<code>get_absolute_url()</code>函数，反向解析出目的url；</li><li>URL的name名称：可能带有参数：reverse()将用于反向解析url；</li><li>一个绝对的或相对的URL：将原封不动的作为重定向的目标位置。</li></ul><p>默认情况下是临时重定向，如果设置<code>permanent=True</code>将永久重定向。</p><p><strong>范例：</strong></p><p>重定向到硬编码的URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    ...<br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;/some/url/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>重定向到一个完整的URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    ...<br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;https://www.liujiangblog.com/&#x27;</span>)<br><br><span class="hljs-comment">#或者</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    ...<br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;/some/url/&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="get_object_or_404">get_object_or_404()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">get_object_or_404(klass, *args,* *kwargs)<br></code></pre></td></tr></table></figure><p>这个方法，非常有用，一定熟记。</p><p><strong>常用于查询某个对象，找到了则进行下一步处理，如果未找到则给用户返回404页面。</strong></p><p>在后台，Django其实是调用了模型管理器的get()方法，只会返回一个对象。不同的是，如果get()发生异常，会引发Http404异常，从而返回404页面，而不是模型的DoesNotExist异常。</p><p><strong>必需参数</strong>：</p><ul><li><code>class</code>：要获取的对象的Model类名或者Queryset等；</li><li><code>**kwargs</code>:查询的参数，格式应该可以被get()接受。</li></ul><p><strong>范例：</strong></p><p>1.从MyModel中使用主键1来获取对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> get_object_or_404<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    obj = get_object_or_404(MyModel, pk=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这个示例等同于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> Http404<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        obj = MyModel.objects.get(pk=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">except</span> MyModel.DoesNotExist:<br>        <span class="hljs-keyword">raise</span> Http404(<span class="hljs-string">&quot;No MyModel matches the given query.&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="httprequest对象">2.4 HttpRequest对象</h2><p>每当一个用户请求发送过来，Django将HTTP数据包中的相关内容，打包成为一个HttpRequest对象，并传递给视图函数作为第一位置参数，也就是request，供我们调用。</p><p>所有的请求和响应对象都位于<code>django.http</code>模块内。</p><h4 id="httprequest.method">HttpRequest.method</h4><p>字符串类型，表示请求使用的HTTP方法。默认为大写。 像这样：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">request.method</span> == <span class="hljs-string">&#x27;GET&#x27;</span>:<br>    <span class="hljs-function"><span class="hljs-title">do_something</span>()</span><br><span class="hljs-variable">elif</span> <span class="hljs-variable">request.method</span> == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>    <span class="hljs-function"><span class="hljs-title">do_something_else</span>()</span><br></code></pre></td></tr></table></figure><p>通过这个属性来判断请求的方法，然后根据请求的方法不同，在视图中执行不同的代码。</p><h4 id="httprequest.session">HttpRequest.session</h4><p>来自<code>SessionMiddleware</code>中间件：一个可读写的，类似字典的对象，表示当前会话。我们要保存用户状态，回话过程等等，靠的就是这个中间件和这个属性。</p><h4 id="httprequest.user">HttpRequest.user</h4><p>来自<code>AuthenticationMiddleware</code>中间件：表示当前登录的用户的<code>AUTH_USER_MODEL</code>的实例，这个模型是Django内置的Auth模块下的User模型。如果用户当前未登录，则user将被设置为<code>AnonymousUser</code>的实例。</p><p>可以使用<code>is_authenticated</code>方法判断当前用户是否合法用户，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> request.user.is_authenticated:<br>    ... <span class="hljs-comment"># Do something for logged-in users.</span><br><span class="hljs-keyword">else</span>:<br>    ... <span class="hljs-comment"># Do something for anonymous users.</span><br></code></pre></td></tr></table></figure><p><a href="https://www.liujiangblog.com/course/django/138">其他的......</a></p><h2 id="httpresponse对象">2.5 HttpResponse对象</h2><p>HttpResponse类定义在django.http模块中。</p><p>HttpRequest对象是浏览器发送过来的请求数据的封装</p><p>HttpResponse对象则是你想要返回给浏览器的数据的封装。</p><p>HttpRequest对象由Django自动解析HTTP数据包而创建</p><p>而HttpResponse对象则由程序员手动创建。</p><p>我们编写的每个视图都要实例化、填充和返回一个HttpResponse对象。也就是函数的return值。</p><h4 id="content">content</h4><p>响应的内容。bytes类型。</p><h4 id="status_code">status_code</h4><p>响应的状态码，比如200。</p><p><a href="https://www.liujiangblog.com/course/django/140">剩下的......</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django基础----模型层</title>
    <link href="/2020/10/28/Django%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/10/28/Django%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="django介绍">0. Django介绍</h1><p>Django是基于Python的Web开发框架。Web开发指的是开发基于B/S架构，通过前后端的配合，将后台服务器的数据在浏览器上展现给前台用户的应用。</p><p>一般Web框架的架构是这样的：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Python/image-20201029080219087.png" alt="image-20201029080219087" /><figcaption>image-20201029080219087</figcaption></figure><p>大多数基于Python的web框架，如Django、Tornado、Flask、Webpy都是在这个范围内进行增删裁剪。例如Tornado用的是自己的异步非阻塞“WSGI”网关接口，Flask则只提供了最精简和基本的框架，Django则是直接使用了现成的WSGI，并实现了大部分功能，提供了大量的应用工具。</p><p>MVC及MTV设计模式：</p><ul><li><p>MVC设计模式</p><p><code>MVC</code>把Web框架分为三个基础部分：</p><ul><li><p><strong>模型(Model)</strong>：用于封装与应用程序的业务逻辑相关的数据及对数据的处理方法，是Web应用程序中用于处理应用程序的数据逻辑的部分，Model只提供功能性的接口，通过这些接口可以获取Model的所有功能。白话说，这个模块就是业务逻辑和数据库的交互层，定义了数据表。</p></li><li><p><strong>视图(View)</strong>：负责数据的显示和呈现，是对用户的直接输出。</p></li><li><p><strong>控制器(Controller)</strong>：负责从用户端收集用户的输入，可以看成提供View的反向功能。</p></li></ul><p>这三个部分互相独立，但又相互联系，使得改进和升级界面及用户交互流程，在Web开发过程任务分配时，不需要重写业务逻辑及数据访问代码。</p><p>MVC在Python之外的语言中也有广泛应用，例如VC++的MFC，Java的Structs及Spring、C#的.NET开发框架，都非常有名。</p></li><li><p>MTV设计模式：</p><p>MTV和MVC本质上是一样的。</p><p>Django对传统的MVC设计模式进行了修改，将视图分成View模块和Template模块两部分，将动态的逻辑处理与静态的页面展示分离开。而<u>Model采用了ORM技术，将关系型数据库表抽象成面向对象的Python类，将数据库的表操作转换成Python的类操作，避免了编写复杂的SQL语句。</u></p><ul><li><p><strong>模型(Model)</strong>：和MVC中的定义一样</p></li><li><p><strong>模板(Template)</strong>：将模型数据与HTML页面结合起来的引擎</p></li><li><p><strong>视图(View)</strong>：负责实际的业务逻辑实现</p></li></ul><p>Django的MTV模型组织可参考下图所示：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Django/image-20201029083915147.png" alt="image-20201029083915147" /><figcaption>image-20201029083915147</figcaption></figure></li></ul><h1 id="模型层">1. 模型层</h1><h2 id="模型和字段">1.1 模型和字段</h2><p>一个模型（model）就是一个单独的、确定的数据的信息源，包含了数据的字段和操作方法。通常，每个模型映射为一张数据库中的表。</p><p>基本的原则如下：</p><ul><li>每个模型在Django中的存在形式为一个Python类</li><li>每个类都是<code>django.db.models.Model</code>的子类</li><li>模型（类）的每个字段（属性）代表数据表的某一列</li><li>Django自动为你生成访问数据库的API</li></ul><p>举个栗子：</p><p>下面的模型定义了一个“人”，它具有<code>first_name</code>和<code>last_name</code>字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">models.Model</span>):</span><br>    first_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br>    last_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>每一个字段都是一个类属性，每个类属性表示数据表中的一个列。</p><p>上面的代码，相当于下面的原生SQL语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">CREATE TABLE myapp_person (<br>    <span class="hljs-string">&quot;id&quot;</span> serial NOT NULL PRIMARY KEY,<br>    <span class="hljs-string">&quot;first_name&quot;</span> varchar(<span class="hljs-number">30</span>) NOT NULL,<br>    <span class="hljs-string">&quot;last_name&quot;</span> varchar(<span class="hljs-number">30</span>) NOT NULL<br>);<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>表名<code>myapp_person</code>由Django自动生成，默认格式为“<code>项目名称+下划线+小写类名</code>”，你可以重写这个规则。</li><li>Django会自动创建自增主键<code>id</code>，当然，你也可以自己指定主键。</li><li>上面的SQL语句基于<code>PostgreSQL</code>语法。</li></ul><p>通常，我们会将模型编写在其所属app下的models.py文件中，没有特别需求时，请坚持这个原则，不要自己给自己添加麻烦。</p><p>创建了模型之后，在使用它之前，需要先在settings文件中的<code>INSTALLED_APPS</code> 处，注册<code>models.py</code>文件所在的<code>myapp</code>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">INSTALLED_APPS</span> = [<br>    <span class="hljs-comment">#...</span><br>    <span class="hljs-string">&#x27;myapp&#x27;</span>,<br>    <span class="hljs-comment">#...</span><br>]<br></code></pre></td></tr></table></figure><p><strong>每次对模型进行增、删、修改时，先执行<code>python manage.py makemigrations</code>让修改动作保存到记录文件中，再执行命令<code>python manage.py migrate</code>，让操作实际应用到数据库上。</strong></p><h2 id="模型方法">模型方法</h2><p>模型的方法其实就是Python的实例方法。Django内置了一些，我们也可以自定义一些。</p><ul><li><code>__str__()</code>： 这个其实是Python的魔法方法，用于返回实例对象的打印字符串。为了让显示的内容更直观更易懂，我们往往自定义这个方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">models.Model</span>):</span><br>    first_name = models.CharField(max_length=<span class="hljs-number">50</span>)<br>    last_name = models.CharField(max_length=<span class="hljs-number">50</span>)<br>    birth_date = models.DateField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.first_name + self.last_name<br></code></pre></td></tr></table></figure><ul><li><code>get_absolute_url()</code>: 这个方法是返回每个模型实例的相应的访问url。</li><li>...</li></ul><h2 id="模型字段fields">模型字段fields</h2><p>Django内置了许多字段类型，它们都位于<code>django.db.models</code>中，例如<code>models.CharField</code>，它们的父类都是Field类。这些类型基本满足需求，如果还不够，也可以自定义字段。</p><table><colgroup><col style="width: 29%" /><col style="width: 70%" /></colgroup><thead><tr class="header"><th>类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>AutoField</td><td>一个自动增加的整数类型字段。通常你不需要自己编写它，Django会自动帮你添加字段：<code>id = models.AutoField(primary_key=True)</code>，这是一个自增字段，从1开始计数。如果你非要自己设置主键，那么请务必将字段设置为<code>primary_key=True</code>。Django在一个模型中只允许有一个自增字段，并且该字段必须为主键！</td></tr><tr class="even"><td>BigAutoField</td><td>64位整数类型自增字段，数字范围更大，从1到9223372036854775807</td></tr><tr class="odd"><td>BigIntegerField</td><td>64位整数字段（看清楚，非自增），类似IntegerField ，-9223372036854775808 到9223372036854775807。在Django的模板表单里体现为一个<code>NumberInput</code>标签。</td></tr><tr class="even"><td><strong>BooleanField</strong></td><td>布尔值类型。默认值是None。在HTML表单中体现为CheckboxInput标签。如果设置了参数null=True，则表现为NullBooleanSelect选择框。可以提供default参数值，设置默认值。</td></tr><tr class="odd"><td><strong>CharField</strong></td><td>最常用的类型，字符串类型。必须接收一个max_length参数，表示字符串长度不能超过该值。默认的表单标签是text input。</td></tr><tr class="even"><td><strong>DateField</strong></td><td><code>class DateField(auto_now=False, auto_now_add=False, **options)</code> , 日期类型。一个Python中的datetime.date的实例。在HTML中表现为DateInput标签。在admin后台中，Django会帮你自动添加一个JS日历表和一个“Today”快捷方式，以及附加的日期合法性验证。两个重要参数：（参数互斥，不能共存） <code>auto_now</code>:每当对象被保存时将字段设为当前日期，常用于保存最后修改时间。<code>auto_now_add</code>：每当对象被创建时，设为当前日期，常用于保存创建日期(注意，它是不可修改的)。设置上面两个参数就相当于给field添加了<code>editable=False</code>和<code>blank=True</code>属性。如果想具有修改属性，请用default参数。例子：<code>pub_time = models.DateField(auto_now_add=True)</code>，自动添加发布时间。</td></tr><tr class="odd"><td>DateTimeField</td><td>日期时间类型。Python的datetime.datetime的实例。与DateField相比就是多了小时、分和秒的显示，其它功能、参数、用法、默认值等等都一样。</td></tr><tr class="even"><td>DecimalField</td><td>固定精度的十进制小数。相当于Python的Decimal实例，必须提供两个指定的参数！参数<code>max_digits</code>：最大的位数，必须大于或等于小数点位数 。<code>decimal_places</code>：小数点位数，精度。 当<code>localize=False</code>时，它在HTML表现为NumberInput标签，否则是textInput类型。例子：储存最大不超过999，带有2位小数位精度的数，定义如下：<code>models.DecimalField(..., max_digits=5, decimal_places=2)</code>。</td></tr><tr class="odd"><td><strong>EmailField</strong></td><td>邮箱类型，默认max_length最大长度254位。使用这个字段的好处是，可以使用Django内置的EmailValidator进行邮箱格式合法性验证。</td></tr><tr class="even"><td><strong>FileField</strong></td><td><code>class FileField(upload_to=None, max_length=100, **options)</code>上传文件类型，后面单独介绍。</td></tr><tr class="odd"><td>FilePathField</td><td>文件路径类型，后面单独介绍</td></tr><tr class="even"><td>FloatField</td><td>浮点数类型，对应Python的float。参考整数类型字段。</td></tr><tr class="odd"><td><strong>ImageField</strong></td><td>图像类型，后面单独介绍。</td></tr><tr class="even"><td><strong>IntegerField</strong></td><td>整数类型，最常用的字段之一。取值范围-2147483648到2147483647。在HTML中表现为NumberInput或者TextInput标签。</td></tr><tr class="odd"><td><strong>GenericIPAddressField</strong></td><td><code>class GenericIPAddressField(protocol='both', unpack_ipv4=False, **options)</code>,IPV4或者IPV6地址，字符串形式，例如<code>192.0.2.30</code>或者<code>2a02:42fe::4</code>。在HTML中表现为TextInput标签。参数<code>protocol</code>默认值为‘both’，可选‘IPv4’或者‘IPv6’，表示你的IP地址类型。</td></tr><tr class="even"><td>JSONField</td><td>JSON类型字段。Django3.1新增。签名为<code>class JSONField(encoder=None,decoder=None,**options)</code>。其中的encoder和decoder为可选的编码器和解码器，用于自定义编码和解码方式。如果为该字段提供default值，请务必保证该值是个不可变的对象，比如字符串对象。</td></tr><tr class="odd"><td><strong>TextField</strong></td><td>用于储存大量的文本内容，在HTML中表现为Textarea标签，最常用的字段类型之一！如果你为它设置一个max_length参数，那么在前端页面中会受到输入字符数量限制，然而在模型和数据库层面却不受影响。只有CharField才能同时作用于两者。</td></tr><tr class="even"><td>TimeField</td><td>时间字段，Python中datetime.time的实例。接收同DateField一样的参数，只作用于小时、分和秒。</td></tr><tr class="odd"><td><strong>URLField</strong></td><td>一个用于保存URL地址的字符串类型，默认最大长度200。</td></tr><tr class="even"><td><strong>UUIDField</strong></td><td>用于保存通用唯一识别码（Universally Unique Identifier）的字段。使用Python的UUID类。在PostgreSQL数据库中保存为uuid类型，其它数据库中为char(32)。这个字段是自增主键的最佳替代品。</td></tr></tbody></table><h2 id="关系类型字段">1.2 关系类型字段</h2><p>除了普通类型字段，Django还定义了一组关系类型字段，用来表示模型与模型之间的关系。</p><h3 id="多对一foreignkey">1.2.1 多对一（ForeignKey）</h3><p>多对一的关系，通常被称为外键。外键字段类的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForeignKey</span>(<span class="hljs-params">to, on_delete, **options</span>)</span><br></code></pre></td></tr></table></figure><p>外键需要两个位置参数，一个是关联的模型，另一个是<code>on_delete</code>。</p><p><strong>外键要定义在‘多’的一方！</strong></p><p>举栗：</p><p>每辆车都会有一个生产工厂，一个工厂可以生产N辆车，于是用一个外键字段manufacturer表示，并放在Car模型中。注意，此manufacturer非彼Manufacturer模型类，它是一个字段的名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manufacturer</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>(<span class="hljs-params">models.Model</span>):</span><br>    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)<br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>在实际的数据库后台，Django会为每一个外键添加<code>_id</code>后缀，并以此创建数据表里的一列。在上面的工厂与车的例子中，Car模型对应的数据表中，会有一列叫做<code>manufacturer_id</code>。但实际上，在Django代码中你不需要使用这个列名，除非你书写原生的SQL语句，一般我们都直接使用字段名<code>manufacturer</code>。</p><p>多对一字段的变量名一般设置为关联的模型的小写单数，而多对多则一般设置为小写复数。在Django的模型定义中，经常出现类似的英文单词大小写不同，一定要注意区分！</p><p>如果要创建一个递归的外键，也就是自己关联自己的的外键，使用下面的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">models.ForeignKey(<span class="hljs-string">&#x27;self&#x27;</span>, on_delete=models.CASCADE)<br></code></pre></td></tr></table></figure><p>关系字段的定义还有个小坑。在后面<code>verbose_name</code>参数用于设置字段的别名。很多情况下，为了方便，我们都会设置这么个值，并且作为字段的第一位置参数。但是对于关系字段，其第一位置参数永远是关系对象，不能是<code>verbose_name</code>，一定要注意！</p><h4 id="参数说明">参数说明</h4><h4 id="on_delete">on_delete</h4><p>当一个外键关联的对象被删除时，Django将模仿<code>on_delete</code>参数定义的SQL约束执行相应操作。</p><p>该参数可选的值都内置在<code>django.db.models</code>中（全部为大写），包括：</p><ul><li>CASCADE：模拟SQL语言中的<code>ON DELETE CASCADE</code>约束，将定义有外键的模型对象同时删除！</li><li>PROTECT:阻止上面的删除操作，但是弹出<code>ProtectedError</code>异常</li><li>SET_NULL：将外键字段设为null，只有当字段设置了<code>null=True</code>时，方可使用该值。</li><li>SET_DEFAULT:将外键字段设为默认值。只有当字段设置了default参数时，方可使用。</li><li>DO_NOTHING：什么也不做。</li><li>SET()：设置为一个传递给SET()的值或者一个回调函数的返回值。注意大小写。</li></ul><h4 id="limit_choices_to">limit_choices_to</h4><p>该参数用于限制外键所能关联的对象，只能用于Django的ModelForm（Django的表单模块）和admin后台，对其它场合无限制功能。其值可以是一个字典、Q对象或者一个返回字典或Q对象的函数调用，如下例所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">staff_member = models.ForeignKey(<br>    User,<br>    on_delete=models.CASCADE,<br>    limit_choices_to=&#123;<span class="hljs-string">&#x27;is_staff&#x27;</span>: <span class="hljs-literal">True</span>&#125;,<br>)<br></code></pre></td></tr></table></figure><p>这样定义，则ModelForm的<code>staff_member</code>字段列表中，只会出现那些<code>is_staff=True</code>的Users对象，这一功能对于admin后台非常有用。</p><h4 id="related_name">related_name</h4><p>用于关联对象反向引用模型的名称。以前面车和工厂的例子解释，就是从工厂反向关联到车的关系名称。</p><p>通常情况下，这个参数我们可以不设置，Django会默认以模型的小写加上<code>_set</code>作为反向关联名，比如对于工厂就是<code>car_set</code>，如果你觉得<code>car_set</code>还不够直观，可以如下定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>(<span class="hljs-params">models.Model</span>):</span><br>    manufacturer = models.ForeignKey(<br>        <span class="hljs-string">&#x27;production.Manufacturer&#x27;</span>,      <br>        on_delete=models.CASCADE,<br>        related_name=<span class="hljs-string">&#x27;car_producted_by_this_manufacturer&#x27;</span>,  <span class="hljs-comment"># 看这里！！</span><br>    )<br></code></pre></td></tr></table></figure><p>也许我定义了一个蹩脚的词，但表达的意思很清楚。以后从工厂对象反向关联到它所生产的汽车，就可以使用<code>maufacturer.car_producted_by_this_manufacturer</code>了。</p><h3 id="多对多manytomanyfield">1.2.2 多对多（ManyToManyField）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManyToManyField</span>(<span class="hljs-params">to, **options</span>)</span><br></code></pre></td></tr></table></figure><p>多对多关系在数据库中也是非常常见的关系类型。比如一本书可以有好几个作者，一个作者也可以写好几本书。多对多的字段可以定义在任何的一方，请尽量定义在符合人们思维习惯的一方，但不要同时都定义，只能选择一个模型设置该字段（比如我们通常将披萨上的配料字段放在披萨模型中，而不是在配料模型中放置披萨字段）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Topping</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pizza</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    toppings = models.ManyToManyField(Topping)<br></code></pre></td></tr></table></figure><ul><li><p>建议为多对多字段名使用复数形式。</p></li><li><p>多对多关系需要一个位置参数：关联的对象模型，其它用法和外键多对一基本类似。</p></li><li><p>如果要创建一个关联自己的多对多字段，依然是通过<code>'self'</code>引用。</p></li></ul><h3 id="一对一onetoonefield">1.2.3 一对一（OneToOneField）</h3><p>一对一关系类型的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneToOneField</span>(<span class="hljs-params">to, on_delete, parent_link=<span class="hljs-literal">False</span>, **options</span>)</span><br></code></pre></td></tr></table></figure><p>从概念上讲，一对一关系非常类似具有<code>unique=True</code>属性的外键关系，但是反向关联对象只有一个。这种关系类型多数用于当一个模型需要从别的模型扩展而来的情况。比如，Django自带auth模块的User用户表，如果你想在自己的项目里创建用户模型，又想方便的使用Django的auth中的一些功能，那么一个方案就是在你的用户模型里，使用一对一关系，添加一个与auth模块User模型的关联字段。</p><p>该关系的第一位置参数为关联的模型，其用法和前面的多对一外键一样。</p><p>如果你没有给一对一关系设置<code>related_name</code>参数，Django将使用当前模型的小写名作为默认值。</p><p>看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-comment"># 两个字段都使用一对一关联到了Django内置的auth模块中的User模型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpecialUser</span>(<span class="hljs-params">models.Model</span>):</span><br>    user = models.OneToOneField(<br>        settings.AUTH_USER_MODEL,<br>        on_delete=models.CASCADE,<br>    )<br>    supervisor = models.OneToOneField(<br>        settings.AUTH_USER_MODEL,<br>        on_delete=models.CASCADE,<br>        related_name=<span class="hljs-string">&#x27;supervisor_of&#x27;</span>,<br>    )<br></code></pre></td></tr></table></figure><h2 id="字段的参数">1.3 字段的参数</h2><p>所有的模型字段都可以接收一定数量的参数，比如CharField至少需要一个max_length参数。下面的这些参数是所有字段都可以使用的，并且是可选的。</p><h4 id="null">null</h4><p>该值为True时，Django在数据库用NULL保存空值。默认值为False。对于保存字符串类型数据的字段，请尽量避免将此参数设为True，那样会导致两种‘没有数据’的情况，一种是<code>NULL</code>，另一种是空字符串<code>''</code>。Django 的惯例是使用空字符串而不是 <code>NULL</code>。</p><h4 id="blank">blank</h4><p>True时，字段可以为空。默认False。和null参数不同的是，null是纯数据库层面的，而blank是验证相关的，它与表单验证是否允许输入框内为空有关，与数据库无关。所以要小心一个null为False，blank为True的字段接收到一个空值可能会出bug或异常。</p><h4 id="choices">choices</h4><p>用于页面上的选择框标签，需要先提供一个二维的二元元组，第一个元素表示存在数据库内真实的值，第二个表示页面上显示的具体内容。在浏览器页面上将显示第二个元素的值。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">models.Model</span>):</span><br>    YEAR_IN_SCHOOL_CHOICES = (<br>        (FRESHMAN, <span class="hljs-string">&#x27;Freshman&#x27;</span>),<br>        (SOPHOMORE, <span class="hljs-string">&#x27;Sophomore&#x27;</span>),<br>        (JUNIOR, <span class="hljs-string">&#x27;Junior&#x27;</span>),<br>        (SENIOR, <span class="hljs-string">&#x27;Senior&#x27;</span>),<br>    )<br>    year_in_school = models.CharField(<br>        max_length=<span class="hljs-number">2</span>,<br>        choices=YEAR_IN_SCHOOL_CHOICES,<br>        default=FRESHMAN,<br>    )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_upperclass</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.year_in_school <span class="hljs-keyword">in</span> (self.JUNIOR, self.SENIOR)<br></code></pre></td></tr></table></figure><h4 id="primary_key">primary_key</h4><p>如果你没有给模型的任何字段设置这个参数为True，Django将自动创建一个AutoField自增字段，名为‘id’，并设置为主键。也就是<code>id = models.AutoField(primary_key=True)</code>。</p><p>如果你为某个字段设置了primary_key=True，则当前字段变为主键，并关闭Django自动生成id主键的功能。</p><p><strong><code>primary_key=True</code>隐含<code>null=False</code>和<code>unique=True</code>的意思。一个模型中只能有一个主键字段！</strong></p><p>另外，主键字段不可修改，如果你给某个对象的主键赋个新值实际上是创建一个新对象，并不会修改原来的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>, primary_key=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">###############    </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fruit = Fruit.objects.create(name=<span class="hljs-string">&#x27;Apple&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>fruit.name = <span class="hljs-string">&#x27;Pear&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fruit.save()<br><span class="hljs-meta">&gt;&gt;&gt; </span>Fruit.objects.values_list(<span class="hljs-string">&#x27;name&#x27;</span>, flat=<span class="hljs-literal">True</span>)<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Pear&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="unique">unique</h4><p>设为True时，在整个数据表内该字段的数据不可重复。</p><p>注意：</p><ul><li><p>对于ManyToManyField和OneToOneField关系类型，该参数无效。</p></li><li><p>当unique=True时，db_index参数无须设置，因为unqiue隐含了索引。</p></li></ul><h4 id="verbose_name">verbose_name</h4><p>为字段设置一个人类可读，更加直观的别名。</p><p>对于每一个字段类型，除了<code>ForeignKey</code>、<code>ManyToManyField</code>和<code>OneToOneField</code>这三个特殊的关系类型，其第一可选位置参数都是<code>verbose_name</code>。如果没指定这个参数，Django会利用字段的属性名自动创建它，并将下划线转换为空格。</p><p>下面这个例子的<code>verbose name</code>是&quot;person’s first name&quot;:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">first_name = models.CharField(<span class="hljs-string">&quot;person&#x27;s first name&quot;</span>, max_length=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>下面这个例子的<code>verbose name</code>是&quot;first name&quot;:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">first_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>对于外键、多对多和一对一字字段，由于第一个参数需要用来指定关联的模型，因此必须用关键字参数<code>verbose_name</code>来明确指定。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">poll = models.ForeignKey(<br>    Poll,<br>    on_delete=models.CASCADE,<br>    verbose_name=<span class="hljs-string">&quot;the related poll&quot;</span>,<br>    )<br>sites = models.ManyToManyField(Site, verbose_name=<span class="hljs-string">&quot;list of sites&quot;</span>)<br>    place = models.OneToOneField(<br>    Place,<br>    on_delete=models.CASCADE,<br>    verbose_name=<span class="hljs-string">&quot;related place&quot;</span>,<br>)<br></code></pre></td></tr></table></figure><h2 id="模型的元数据meta">1.4 模型的元数据Meta</h2><p>模型的元数据，指的是“除了字段外的所有内容”，例如排序方式、数据库表名、人类可读的单数或者复数名等等。想在模型中增加元数据，方法很简单，在模型类中添加一个子类，名字是固定的<code>Meta</code>，然后在这个Meta类下面增加各种元数据选项或者说设置项。参考下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ox</span>(<span class="hljs-params">models.Model</span>):</span><br>    horn_length = models.IntegerField()<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>         <span class="hljs-comment"># 注意，是模型的子类，要缩进！</span><br>        ordering = [<span class="hljs-string">&quot;horn_length&quot;</span>]<br>        verbose_name_plural = <span class="hljs-string">&quot;oxen&quot;</span><br></code></pre></td></tr></table></figure><p>上面的例子中，我们为模型Ox增加了两个元数据‘ordering’和‘verbose_name_plural’，分别表示排序和复数名。</p><p>介绍一些常用的元数据选项：</p><h4 id="abstract">abstract</h4><p>如果<code>abstract=True</code>，那么模型会被认为是一个抽象模型。抽象模型本身不实际生成数据库表，而是作为其它模型的父类，被继承使用。具体内容可以参考Django模型的继承。</p><h3 id="ordering">ordering</h3><p>最常用的元数据之一了！</p><p>用于指定该模型生成的所有对象的排序方式，接收一个字段名组成的元组或列表。默认按升序排列，如果在字段名前加上字符“-”则表示按降序排列，如果使用字符问号“？”表示随机排列。请看下面的例子：</p><p>这个顺序是你通过查询语句，获得Queryset后的列表内元素的顺序，切不可和前面的<code>get_latest_by</code>等混淆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ordering = [<span class="hljs-string">&#x27;pub_date&#x27;</span>]             <span class="hljs-comment"># 表示按&#x27;pub_date&#x27;字段进行升序排列</span><br>ordering = [<span class="hljs-string">&#x27;-pub_date&#x27;</span>]            <span class="hljs-comment"># 表示按&#x27;pub_date&#x27;字段进行降序排列</span><br>ordering = [<span class="hljs-string">&#x27;-pub_date&#x27;</span>, <span class="hljs-string">&#x27;author&#x27;</span>]  <span class="hljs-comment"># 表示先按&#x27;pub_date&#x27;字段进行降序排列，再按`author`字段进行升序排列。</span><br></code></pre></td></tr></table></figure><h4 id="unique_together">unique_together</h4><p>这个元数据是非常重要的一个！它<strong>等同于数据库的联合约束！</strong></p><p>举个例子，假设有一张用户表，保存有用户的姓名、出生日期、性别和籍贯等等信息。要求是所有的用户唯一不重复，可现在有好几个叫“张伟”的，如何区别它们呢？（不要说主键唯一，这里讨论的不是这个问题）</p><p>我们可以设置不能有两个用户在同一个地方同一时刻出生并且都叫“张伟”，使用这种联合约束，保证数据库能不能重复添加用户（也不要和我谈小概率问题）。在Django的模型中，如何实现这种约束呢？</p><p>使用<code>unique_together</code>，也就是联合唯一！</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">unique_together = [[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;birth_day&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>],......]<br></code></pre></td></tr></table></figure><p>这样，哪怕有两个在同一天出生的张伟，但他们的籍贯不同，也就是两个不同的用户。一旦三者都相同，则会被Django拒绝创建。这个元数据选项经常被用在admin后台，并且强制应用于数据库层面。</p><p>unique_together接收一个二维的列表，每个元素都是一维列表，表示一组联合唯一约束，可以同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">unique_together = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;birth_day&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>]<br></code></pre></td></tr></table></figure><p>联合唯一无法作用于普通的多对多字段。</p><h4 id="proxy">proxy</h4><p>如果设置了<code>proxy = True</code>，表示使用代理模式的模型继承方式。具体内容与abstract选项一样，参考模型继承章节。</p><h4 id="verbose_name-1">verbose_name</h4><p>最常用的元数据之一！用于设置模型对象的直观、人类可读的名称，用于在各种打印、页面展示等场景。可以用中文。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">verbose_name = <span class="hljs-string">&quot;story&quot;</span><br>verbose_name = <span class="hljs-string">&quot;披萨&quot;</span><br></code></pre></td></tr></table></figure><p>如果你不指定它，那么Django会使用小写的模型名作为默认值。</p><h4 id="verbose_name_plural">verbose_name_plural</h4><p>英语有单数和复数形式。这个就是模型对象的复数名，比如“apples”。因为我们中文通常不区分单复数，所以保持和<code>verbose_name</code>一致也可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">verbose_name_plural = <span class="hljs-string">&quot;stories&quot;</span><br>verbose_name_plural = <span class="hljs-string">&quot;披萨&quot;</span><br>verbose_name_plural = verbose_name<br></code></pre></td></tr></table></figure><p>如果不指定该选项，那么默认的复数名字是<code>verbose_name</code>加上‘s’</p><h4 id="permissions">permissions</h4><p>该元数据用于当创建对象时增加额外的权限。它接收一个所有元素都是二元元组的列表或元组，每个元素都是<code>(权限代码, 直观的权限名称)</code>的格式。比如下面的例子：</p><p>这个Meta选项非常重要，和auth框架的权限系统紧密相关。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">permissions = ((<span class="hljs-string">&quot;can_deliver_pizzas&quot;</span>, <span class="hljs-string">&quot;可以送披萨&quot;</span>),)<br></code></pre></td></tr></table></figure><h2 id="模型的继承">1.5 模型的继承</h2><p>Django中所有的模型都必须继承<code>django.db.models.Model</code>模型</p><p>Django有三种继承的方式：</p><ul><li><u>抽象基类</u>：被用来继承的模型被称为<code>Abstract base classes</code>，将子类共同的数据抽离出来，供子类继承重用，它不会创建实际的数据表；</li><li><u>多表继承</u>：<code>Multi-table inheritance</code>，每一个模型都有自己的数据库表，父子之间独立存在；</li><li><u>代理模型</u>：如果你只想修改模型的Python层面的行为，并不想改动模型的字段，可以使用代理模型。</li></ul><p><strong>注意！同Python的继承一样，Django也是可以同时继承两个以上父类的！</strong></p><h3 id="抽象基类">1.5.1 抽象基类</h3><p>只需要在模型的Meta类里添加<code>abstract=True</code>元数据项，就可以将一个模型转换为抽象基类。Django不会为这种类创建实际的数据库表，它们也没有管理器，不能被实例化也无法直接保存，它们就是被当作父类供起来，让子类继承的。抽象基类完全就是用来保存子模型们共有的内容部分，达到重用的目的。当它们被继承时，它们的字段会全部复制到子模型中。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonInfo</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    age = models.PositiveIntegerField()<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        abstract = <span class="hljs-literal">True</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">CommonInfo</span>):</span><br>    home_group = models.CharField(max_length=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>Student模型将拥有name，age，home_group三个字段，并且CommonInfo模型不能当做一个正常的模型使用，不会有这张表出现。</p><p>那如果我想修改CommonInfo父类中的name字段的定义呢？</p><ul><li>在Student类中创建一个name字段，覆盖父类的即可。</li></ul><p>那如果我不需要CommonInfo父类中的name字段呢？</p><ul><li>在Student类中创建一个name变量，值设为None即可。</li></ul><h4 id="抽象基类的meta数据">抽象基类的Meta数据：</h4><p>如果子类没有声明自己的Meta类，那么它将自动继承抽象基类的Meta类。</p><p>如果子类要设置自己的Meta属性，则需要扩展基类的Meta：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonInfo</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        abstract = <span class="hljs-literal">True</span><br>        ordering = [<span class="hljs-string">&#x27;name&#x27;</span>]<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">CommonInfo</span>):</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>(<span class="hljs-params">CommonInfo.Meta</span>):</span>   <span class="hljs-comment"># 注意这里有个继承关系</span><br>        db_table = <span class="hljs-string">&#x27;student_info&#x27;</span><br></code></pre></td></tr></table></figure><p>这里有几点要特别说明：</p><ul><li><p>抽象基类中有的元数据，子模型没有的话，直接继承；子模型也有的话，直接覆盖；</p></li><li><p>子模型可以额外添加元数据；</p></li><li><p>抽象基类中的<code>abstract=True</code>这个元数据不会被继承。也就是说如果想让一个抽象基类的子模型，同样成为一个抽象基类，那你必须显式的在该子模型的Meta中同样声明一个<code>abstract = True</code>；</p></li><li><p>有一些元数据对抽象基类无效，比如<code>db_table</code>，首先是抽象基类本身不会创建数据表，其次它的所有子类也不会按照这个元数据来设置表名。</p></li><li><p>由于Python继承的工作机制，如果子类继承了多个抽象基类，则默认情况下仅继承第一个列出的基类的 Meta 选项。如果要从多个抽象基类中继承 Meta 选项，必须显式地声明 Meta 继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonInfo</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    age = models.PositiveIntegerField()<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        abstract = <span class="hljs-literal">True</span><br>        ordering = [<span class="hljs-string">&#x27;name&#x27;</span>]<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unmanaged</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        abstract = <span class="hljs-literal">True</span><br>        managed = <span class="hljs-literal">False</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">CommonInfo, Unmanaged</span>):</span><br>    home_group = models.CharField(max_length=<span class="hljs-number">5</span>)<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>(<span class="hljs-params">CommonInfo.Meta, Unmanaged.Meta</span>):</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="多表继承">1.5.2 多表继承</h3><p>这种继承方式下，父类和子类都是独立自主、功能完整、可正常使用的模型，都有自己的数据库表，内部隐含了一个一对一的关系。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Place</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">50</span>)<br>    address = models.CharField(max_length=<span class="hljs-number">80</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Restaurant</span>(<span class="hljs-params">Place</span>):</span><br>    serves_hot_dogs = models.BooleanField(default=<span class="hljs-literal">False</span>)<br>    serves_pizza = models.BooleanField(default=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h4 id="meta和多表继承">Meta和多表继承</h4><p>在多表继承的情况下，由于父类和子类都在数据库内有物理存在的表，父类的Meta类会对子类造成不确定的影响，因此，Django在这种情况下关闭了子类继承父类的Meta功能。这一点和抽象基类的继承方式有所不同。</p><p>但是，还有两个Meta元数据属性特殊一点，那就是<code>ordering</code>和<code>get_latest_by</code>，这两个参数是会被继承的。因此，如果在多表继承中，你不想让你的子类继承父类的上面两种参数，就必须在子类中显示的指出或重写。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildModel</span>(<span class="hljs-params">ParentModel</span>):</span><br>    <span class="hljs-comment"># ...</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        <span class="hljs-comment"># 移除父类对子类的排序影响</span><br>        ordering = []<br></code></pre></td></tr></table></figure><h4 id="多表继承和反向关联">多表继承和反向关联</h4><p>因为多表继承使用了一个隐含的OneToOneField来链接子类与父类，所以象上例那样，你可以从父类访问子类。但是这个OnetoOneField字段默认的<code>related_name</code>值与ForeignKey和 ManyToManyField默认的反向名称相同。如果你与父类或另一个子类做多对一或是多对多关系，你就必须在每个多对一和多对多字段上强制指定<code>related_name</code>。如果你没这么做，Django就会在你运行或验证(validation)时抛出异常。</p><p>仍以上面Place类为例，我们创建一个带有ManyToManyField字段的子类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Supplier</span>(<span class="hljs-params">Place</span>):</span><br>    customers = models.ManyToManyField(Place)<br></code></pre></td></tr></table></figure><p>这会产生下面的错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Reverse query name <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Supplier.customers&#x27;</span> clashes <span class="hljs-keyword">with</span> reverse query<br>name <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Supplier.place_ptr&#x27;</span>.<br>HINT: Add <span class="hljs-keyword">or</span> change a related_name argument to the definition <span class="hljs-keyword">for</span><br><span class="hljs-string">&#x27;Supplier.customers&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;Supplier.place_ptr&#x27;</span>.<br></code></pre></td></tr></table></figure><p>解决方法是：向customers字段中添加<code>related_name</code>参数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">customers = models.ManyToManyField(Place, related_name=<span class="hljs-string">&#x27;provider&#x27;</span>)。<br></code></pre></td></tr></table></figure><h3 id="代理模型">1.5.3 代理模型</h3><p>使用多表继承时，父类的每个子类都会创建一张新数据表，通常情况下，这是我们想要的操作，因为子类需要一个空间来存储不包含在父类中的数据。但有时，你可能只想更改模型在Python层面的行为，比如更改默认的manager管理器，或者添加一个新方法。</p><p>代理模型就是为此而生的。你可以创建、删除、更新代理模型的实例，并且所有的数据都可以像使用原始模型（非代理类模型）一样被保存。不同之处在于你可以在代理模型中改变默认的排序方式和默认的manager管理器等等，而不会对原始模型产生影响。</p><p>代理模型其实就是给原模型换了件衣服（API），实际操作的还是原来的模型和数据。</p><p><strong>声明一个代理模型只需要将Meta中proxy的值设为True。</strong></p><p>例如你想给Person模型添加一个方法。你可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">models.Model</span>):</span><br>    first_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br>    last_name = models.CharField(max_length=<span class="hljs-number">30</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPerson</span>(<span class="hljs-params">Person</span>):</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        proxy = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_something</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># ...</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>MyPerson类将操作和Person类同一张数据库表。并且任何新的Person实例都可以通过MyPerson类进行访问，反之亦然。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Person.objects.create(first_name=<span class="hljs-string">&quot;foobar&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>MyPerson.objects.get(first_name=<span class="hljs-string">&quot;foobar&quot;</span>)<br>&lt;MyPerson: foobar&gt;<br></code></pre></td></tr></table></figure><p>下面的例子通过代理进行排序，但父类却不排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderedPerson</span>(<span class="hljs-params">Person</span>):</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        <span class="hljs-comment"># 现在，普通的Person查询是无序的，而OrderedPerson查询会按照`last_name`排序。</span><br>        ordering = [<span class="hljs-string">&quot;last_name&quot;</span>]<br>        proxy = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>一些约束：</strong></p><ul><li>代理模型必须继承自一个非抽象的基类，并且不能同时继承多个非抽象基类；</li><li>代理模型可以同时继承任意多个抽象基类，前提是这些抽象基类没有定义任何模型字段。</li><li>代理模型可以同时继承多个别的代理模型，前提是这些代理模型继承同一个非抽象基类。</li></ul><h3 id="多重继承">1.5.4 多重继承</h3><p>注意，多重继承和多表继承是两码事，两个概念。</p><p>Django的模型体系支持多重继承，就像Python一样。如果多个父类都含有Meta类，则只有第一个父类的会被使用，剩下的会忽略掉。</p><p>一般情况，能不要多重继承就不要，尽量让继承关系简单和直接，避免不必要的混乱和复杂。</p><h2 id="验证器">1.6 验证器</h2><p>在Django的模型字段参数中，有一个参数叫做<code>validators</code>，这个参数是用来指定当前字段需要使用的验证器，也就是对字段数据的合法性进行验证，比如大小、类型等。</p><p>Django的验证器可以分为模型相关的验证器和表单相关的验证器，它们基本类似，但在使用上有区别。</p><p>详情请见<a href="https://www.liujiangblog.com/course/django/101">这里</a>，这里讨论模型相关的验证器。</p><h2 id="查询操作">1.7 查询操作</h2><p>查询操作是Django的ORM框架中最重要的内容之一。我们建立模型、保存数据为的就是在需要的时候可以查询得到数据。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blog</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    tagline = models.TextField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">200</span>)<br>    email = models.EmailField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.name<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>(<span class="hljs-params">models.Model</span>):</span><br>    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)<br>    headline = models.CharField(max_length=<span class="hljs-number">255</span>)<br>    body_text = models.TextField()<br>    pub_date = models.DateField()<br>    mod_date = models.DateField()<br>    authors = models.ManyToManyField(Author)<br>    number_of_comments = models.IntegerField()<br>    number_of_pingbacks = models.IntegerField()<br>    rating = models.IntegerField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.headline<br></code></pre></td></tr></table></figure><h3 id="创建对象">1.7.1 创建对象</h3><p>创建一个模型实例，也就是一条数据库记录，最一般的方式是使用模型类的实例化构造方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">b = Blog.objects.create(name=<span class="hljs-string">&#x27;小张&#x27;</span>, tagline=<span class="hljs-string">&#x27;你猜&#x27;</span>)<br></code></pre></td></tr></table></figure><p>有时实现一些额外需求，常见的做法是自定义<code>__init__</code>方法。但这不好，容易打断Django源码的调用链，存在漏洞。更推荐的是下面的方法：</p><ul><li>自定义管理器，并在其中添加创建对象的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookManager</span>(<span class="hljs-params">models.Manager</span>):</span>   <span class="hljs-comment"># 继承默认的管理器</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_book</span>(<span class="hljs-params">self, title</span>):</span><br>        book = self.create(title=title)<br>        <span class="hljs-comment"># 将你的个人代码放在这里</span><br>        print(<span class="hljs-string">&#x27;测试一下是否工作正常&#x27;</span>)<br>        <span class="hljs-keyword">return</span> book<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">models.Model</span>):</span><br>    title = models.CharField(max_length=<span class="hljs-number">100</span>)<br><br>    objects = BookManager()   <span class="hljs-comment"># 赋值objects</span><br><br>book = Book.objects.create_book(<span class="hljs-string">&quot;www&quot;</span>)   <span class="hljs-comment">#改为使用create_book方法创建对象</span><br></code></pre></td></tr></table></figure><h3 id="修改对象并保存">1.7.2 修改对象并保存</h3><p>我们往往会重写save方法，添加自己的业务逻辑，然后在其中调用原来的save方法，保证Django基本工作机制正常。比如下面的例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Blog</span>(<span class="hljs-title">models</span>.<span class="hljs-type">Model</span>):</span><br><span class="hljs-class">    name = models.<span class="hljs-type">CharField</span>(<span class="hljs-title">max_length</span>=100)</span><br><span class="hljs-class">    tagline = models.<span class="hljs-type">TextField</span>()</span><br><span class="hljs-class"></span><br><span class="hljs-class">    def save(<span class="hljs-title">self</span>, *<span class="hljs-title">args</span>, **<span class="hljs-title">kwargs</span>):</span><br><span class="hljs-class">        do_something()   # 保存前做点私活</span><br><span class="hljs-class">        super().save(*<span class="hljs-title">args</span>, **<span class="hljs-title">kwargs</span>)  # 一定不要忘记这行代码</span><br><span class="hljs-class">        do_something_else()  # 保存后又加塞点东西</span><br></code></pre></td></tr></table></figure><p>这样，任何一篇博客在保存前后都会执行一些额外的代码。</p><p>注意，千万不要忘记<code>super().save(*args, **kwargs)</code>，这行确保了Django源码中关于save方法的代码会依然被执行。</p><p>下面的例子则是对博客名字做限制，只有小张的博客才可以保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blog</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    tagline = models.TextField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        <span class="hljs-keyword">if</span> self.name != <span class="hljs-string">&quot;小张的博客&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-comment"># 只有小张的博客才可以保存</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">super</span>().save(*args, **kwargs)  <span class="hljs-comment"># 调用真正的save方法</span><br></code></pre></td></tr></table></figure><p><code>*args, **kwargs</code>的参数设计，确保我们自定义的save方法是个万金油，不论Django源码中的save方法的参数怎么变，我们自己的save方法不会因为参数定义的不正确而出现bug。</p><p>此外：</p><p>执行save方法后，Django才会真正为对象设置自增主键的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b2 = Blog(name=<span class="hljs-string">&#x27;Cheddar Talk&#x27;</span>, tagline=<span class="hljs-string">&#x27;Thoughts on cheese.&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b2.<span class="hljs-built_in">id</span>     <span class="hljs-comment"># 返回None，因为此时b2还没有写入数据库，没有id值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b2.save()<br><span class="hljs-meta">&gt;&gt;&gt; </span>b2.<span class="hljs-built_in">id</span>     <span class="hljs-comment"># 这回有了</span><br></code></pre></td></tr></table></figure><p>当然，你也可以自己指定主键的值，不需要等待数据库为主键分配值，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b3 = Blog(<span class="hljs-built_in">id</span>=<span class="hljs-number">3</span>, name=<span class="hljs-string">&#x27;Cheddar Talk&#x27;</span>, tagline=<span class="hljs-string">&#x27;Thoughts on cheese.&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b3.<span class="hljs-built_in">id</span>     <span class="hljs-comment"># 返回 3.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b3.save()<br><span class="hljs-meta">&gt;&gt;&gt; </span>b3.<span class="hljs-built_in">id</span>     <span class="hljs-comment"># 返回 3.</span><br></code></pre></td></tr></table></figure><p>很显然，你必须确保分配的主键值是没有被使用过的，否则肯定出问题，因为在这种情况下，Django认为你是在更新一条已有的数据对象，而不是新建对象，比如下面的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">b4 = Blog(<span class="hljs-built_in">id</span>=<span class="hljs-number">3</span>, name=<span class="hljs-string">&#x27;Not Cheddar&#x27;</span>, tagline=<span class="hljs-string">&#x27;Anything but cheese.&#x27;</span>)<br>b4.save() <br><span class="hljs-comment"># 实际上是更新了上面的b3，而不是新建，此时b4==b3</span><br></code></pre></td></tr></table></figure><p>上面现象的本质是Django对SQL的INSERT和UPDATE语句进行了抽象合并，共用一个save方法。</p><p>有些罕见情况下，可能你必须强制进行INSERT或者UPDATE操作，而不是让Django自动决定。这时候可以使用save方法的<code>force_insert</code>和<code>force_update</code>参数，将其中之一设置为True，强制指定保存模式。</p><ul><li>保存外键和多对多字段:</li></ul><p>保存一个外键字段和保存普通字段没什么区别，只是要注意值的类型要正确。下面的例子，有一个Entry的实例entry和一个Blog的实例<code>cheese_blog</code>，然后把<code>cheese_blog</code>作为值赋给了entry的blog属性，最后调用save方法进行保存。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">from</span> blog.models <span class="hljs-keyword">import</span> Blog, Entry</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry = Entry.objects.get(pk=<span class="hljs-number">1</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">cheese_blog = Blog.objects.get(name=<span class="hljs-string">&quot;Cheddar Talk&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry.blog = cheese_blog</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry.save()</span><br></code></pre></td></tr></table></figure><p>多对多字段的保存稍微有点区别，需要调用一个<code>add()</code>方法，而不是直接给属性赋值，但它不需要调用save方法。如下例所示：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">from</span> blog.models <span class="hljs-keyword">import</span> Author</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">joe = Author.objects.create(name=<span class="hljs-string">&quot;Joe&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry.authors.add(joe)</span><br></code></pre></td></tr></table></figure><p>在一行语句内，可以同时添加多个对象到多对多的字段，如下所示：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">john = Author.objects.create(name=<span class="hljs-string">&quot;John&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">paul = Author.objects.create(name=<span class="hljs-string">&quot;Paul&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">george = Author.objects.create(name=<span class="hljs-string">&quot;George&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">ringo = Author.objects.create(name=<span class="hljs-string">&quot;Ringo&quot;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">entry.authors.add(john, paul, george, ringo)</span><br></code></pre></td></tr></table></figure><p>如果你指定或添加了错误类型的对象，Django会抛出异常。</p><h3 id="检索对象">1.7.3 检索对象</h3><p>想要从数据库内检索对象，你需要基于模型类，通过管理器（Manager）操作数据库并返回一个查询结果集（QuerySet）。</p><p>详情请看有关<a href="https://www.liujiangblog.com/course/django/129">查询结果集（QuerySet）</a>的介绍</p><h2 id="返回querysets的api">1.8 返回QuerySets的API</h2><p><a href="https://www.liujiangblog.com/course/django/130">详情请看有关介绍</a></p><h2 id="不返回querysets的api">1.9 不返回QuerySets的API</h2><p>以下的方法不会返回QuerySets，但是作用非常强大，尤其是粗体显示的方法，需要背下来。</p><table><thead><tr class="header"><th>方法名</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><strong>get()</strong></td><td>获取单个对象</td></tr><tr class="even"><td><strong>create()</strong></td><td>创建对象，无需save()</td></tr><tr class="odd"><td><strong>get_or_create()</strong></td><td>查询对象，如果没有找到就新建对象</td></tr><tr class="even"><td><strong>update_or_create()</strong></td><td>更新对象，如果没有找到就创建对象</td></tr><tr class="odd"><td><code>bulk_create()</code></td><td>批量创建对象</td></tr><tr class="even"><td>bulk_update()</td><td>批量更新对象</td></tr><tr class="odd"><td><strong>count()</strong></td><td>统计对象的个数</td></tr><tr class="even"><td><code>in_bulk()</code></td><td>根据主键值的列表，批量返回对象</td></tr><tr class="odd"><td><code>iterator()</code></td><td>获取包含对象的迭代器</td></tr><tr class="even"><td><strong>latest()</strong></td><td>获取最近的对象</td></tr><tr class="odd"><td><strong>earliest()</strong></td><td>获取最早的对象</td></tr><tr class="even"><td><strong>first()</strong></td><td>获取第一个对象</td></tr><tr class="odd"><td><strong>last()</strong></td><td>获取最后一个对象</td></tr><tr class="even"><td><strong>aggregate()</strong></td><td>聚合操作</td></tr><tr class="odd"><td><strong>exists()</strong></td><td>判断queryset中是否有对象</td></tr><tr class="even"><td><strong>update()</strong></td><td>更新对象</td></tr><tr class="odd"><td><strong>delete()</strong></td><td>删除对象</td></tr><tr class="even"><td>as_manager()</td><td>获取管理器</td></tr><tr class="odd"><td>explain()</td><td>对数据库操作的解释性信息</td></tr></tbody></table><h4 id="get">1. get()</h4><p>返回按照查询参数匹配到的单个对象，参数的格式应该符合Field lookups的要求。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Entry.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>)<br>Entry.objects.get(blog=blog, entry_number=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>如果匹配到的对象个数不只一个的话，触发<code>MultipleObjectsReturned</code>异常:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Entry.objects.get(name=<span class="hljs-string">&#x27;张伟&#x27;</span>) <br><span class="hljs-comment"># raises Entry.MultipleObjectsReturned</span><br></code></pre></td></tr></table></figure><p>如果根据给出的参数匹配不到对象的话，触发DoesNotExist异常。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Entry.objects.get(<span class="hljs-built_in">id</span>=-<span class="hljs-number">999</span>) <br><span class="hljs-comment"># raises Entry.DoesNotExist</span><br></code></pre></td></tr></table></figure><p>DoesNotExist异常从<code>django.core.exceptions.ObjectDoesNotExist</code>继承，可以定位多个DoesNotExist异常。 例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.core.exceptions <span class="hljs-keyword">import</span> ObjectDoesNotExist<br><br><span class="hljs-keyword">try</span>:<br>    blog = Blog.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>)<br>    entry = Entry.objects.get(blog=blog, entry_number=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">except</span> ObjectDoesNotExist:<br>    print(<span class="hljs-string">&quot;Either the blog or entry doesn&#x27;t exist.&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果希望查询器只返回一个对象，则可以使用get()，无需添加任何参数：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml">entry = Entry.objects.filter(...).exclude(...).get()</span><br></code></pre></td></tr></table></figure><h4 id="create">2. create()</h4><p>在一步操作中同时创建并且保存对象的便捷方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Person.objects.create(first_name=<span class="hljs-string">&quot;Bruce&quot;</span>, last_name=<span class="hljs-string">&quot;Springsteen&quot;</span>)<br></code></pre></td></tr></table></figure><p>等于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Person(first_name=<span class="hljs-string">&quot;Bruce&quot;</span>, last_name=<span class="hljs-string">&quot;Springsteen&quot;</span>)<br>p.save(force_insert=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>参数<code>force_insert</code>表示强制创建对象。如果model中有一个你手动设置的主键，并且这个值已经存在于数据库中, 调用create()将会失败并且触发IntegrityError因为主键必须是唯一的。如果你手动设置了主键，做好异常处理的准备。</p><h4 id="get_or_create">3. get_or_create()</h4><p><strong>通过kwargs来查询对象的便捷方法（如果模型中的所有字段都有默认值，可以为空），如果该对象不存在则创建一个新对象</strong>。</p><p>该方法<strong>返回一个由(object, created)组成的元组</strong>，元组中的object 是一个查询到的或者是被创建的对象， created是一个表示是否创建了新的对象的布尔值。</p><p>对于下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    obj = Person.objects.get(first_name=<span class="hljs-string">&#x27;John&#x27;</span>, last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>)<br><span class="hljs-keyword">except</span> Person.DoesNotExist:<br>    obj = Person(first_name=<span class="hljs-string">&#x27;John&#x27;</span>, last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>, birthday=date(<span class="hljs-number">2020</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>))<br>    obj.save()<br></code></pre></td></tr></table></figure><p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用<code>get_or_create()</code>重写 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj, created = Person.objects.get_or_create(<br>    first_name=<span class="hljs-string">&#x27;John&#x27;</span>,<br>    last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>,<br>    defaults=&#123;<span class="hljs-string">&#x27;birthday&#x27;</span>: date(<span class="hljs-number">2020</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>)&#125;,<br>)<br></code></pre></td></tr></table></figure><p>任何传递给<code>get_or_create()</code>的关键字参数，除了一个可选的defaults，都将传递给get()调用。 如果查找到一个对象，返回一个包含匹配到的对象以及False 组成的元组。</p><h4 id="update_or_create">4. update_or_create()</h4><p>类似前面的<code>get_or_create()</code>。</p><p><strong>通过给出的kwargs来更新对象的便捷方法， 如果没找到对象，则创建一个新的对象</strong>。defaults是一个由 (field, value)对组成的字典，用于更新对象。defaults中的值可以是可调用对象（也就是说函数等）。</p><p>该方法返回一个由(object, created)组成的元组,元组中的object是一个创建的或者是被更新的对象， created是一个标示是否创建了新的对象的布尔值。</p><p><code>update_or_create</code>方法尝试通过给出的kwargs 去从数据库中获取匹配的对象。 如果找到匹配的对象，它将会依据defaults 字典给出的值更新字段。</p><p>像下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">defaults = &#123;<span class="hljs-string">&#x27;first_name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>&#125;<br><span class="hljs-keyword">try</span>:<br>    obj = Person.objects.get(first_name=<span class="hljs-string">&#x27;John&#x27;</span>, last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>)<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> defaults.items():<br>        <span class="hljs-built_in">setattr</span>(obj, key, value)<br>    obj.save()<br><span class="hljs-keyword">except</span> Person.DoesNotExist:<br>    new_values = &#123;<span class="hljs-string">&#x27;first_name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;last_name&#x27;</span>: <span class="hljs-string">&#x27;Lennon&#x27;</span>&#125;<br>    new_values.update(defaults)<br>    obj = Person(**new_values)<br>    obj.save()<br></code></pre></td></tr></table></figure><p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用<code>update_or_create()</code> 重写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">obj, created = Person.objects.update_or_create(<br>    first_name=<span class="hljs-string">&#x27;John&#x27;</span>, last_name=<span class="hljs-string">&#x27;Lennon&#x27;</span>,<br>    defaults=&#123;<span class="hljs-string">&#x27;first_name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>&#125;,<br>)<br></code></pre></td></tr></table></figure><p>kwargs中的名称如何解析的详细描述可以参见<code>get_or_create()</code>。</p><p>和<code>get_or_create()</code>一样，这个方法也容易导致竞态条件，如果数据库层级没有前置唯一性会让多行同时插入。</p><h4 id="count">5. count()</h4><p>count()</p><p>返回在数据库中对应的QuerySet对象的个数。count()永远不会引发异常。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 返回总个数.</span><br>Entry.objects.count()<br><span class="hljs-comment"># 返回包含有&#x27;Lennon&#x27;的对象的总数</span><br>Entry.objects.<span class="hljs-built_in">filter</span>(headline__contains=<span class="hljs-string">&#x27;Lennon&#x27;</span>).count()<br></code></pre></td></tr></table></figure><h4 id="exists">6. exists()</h4><p>如果QuerySet包含任何结果，则返回True，否则返回False。</p><p>查找具有唯一性字段（例如primary_key）的模型是否在一个QuerySet中的最高效的方法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">entry = Entry.objects.get(pk=<span class="hljs-number">123</span>)<br><span class="hljs-keyword">if</span> some_queryset.<span class="hljs-built_in">filter</span>(pk=entry.pk).exists():<br>    print(<span class="hljs-string">&quot;Entry contained in queryset&quot;</span>)<br></code></pre></td></tr></table></figure><p>它将比下面的方法快很多，这个方法要求对QuerySet求值并迭代整个QuerySet：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> entry <span class="hljs-keyword">in</span> some_queryset:<br>   print(<span class="hljs-string">&quot;Entry contained in QuerySet&quot;</span>)<br></code></pre></td></tr></table></figure><p>若要查找一个QuerySet是否包含任何元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> some_queryset.exists():<br>    print(<span class="hljs-string">&quot;There is at least one object in some_queryset&quot;</span>)<br></code></pre></td></tr></table></figure><p>将快于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> some_queryset:<br>    print(<span class="hljs-string">&quot;There is at least one object in some_queryset&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="update">7. update()</h4><p><strong>对指定的字段执行更新操作，并返回匹配的行数</strong>（如果某些行已具有新值，则可能不等于已更新的行数）。</p><p>例如，要对2010年发布的所有博客条目关闭评论功能，可以执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(pub_date__year=<span class="hljs-number">2010</span>).update(comments_on=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>可以同时更新多个字段 （没有多少字段的限制）。 例如同时更新comments_on和headline字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(pub_date__year=<span class="hljs-number">2010</span>).update(comments_on=<span class="hljs-literal">False</span>, headline=<span class="hljs-string">&#x27;This is old&#x27;</span>)<br></code></pre></td></tr></table></figure><p>update()方法无需save操作，会立刻写入数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">update只能更新模型主表中的字段，不能更新关联模型中的字段。<br></code></pre></td></tr></table></figure><p>例如不能这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.update(blog__name=<span class="hljs-string">&#x27;foo&#x27;</span>) <span class="hljs-comment"># 这样做是无效的</span><br></code></pre></td></tr></table></figure><p>但是，仍然可以根据相关字段进行过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(blog__id=<span class="hljs-number">1</span>).update(comments_on=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>update()方法返回受影响的行数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">id</span>=<span class="hljs-number">64</span>).update(comments_on=<span class="hljs-literal">True</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(slug=<span class="hljs-string">&#x27;nonexistent-slug&#x27;</span>).update(comments_on=<span class="hljs-literal">True</span>)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(pub_date__year=<span class="hljs-number">2010</span>).update(comments_on=<span class="hljs-literal">False</span>)<br><span class="hljs-number">132</span><br></code></pre></td></tr></table></figure><p>如果你只是更新一下对象，不需要为对象做别的事情，最有效的方法是调用update()，而不是将模型对象加载到内存中。 例如，不要这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">e = Entry.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-number">10</span>)<br>e.comments_on = <span class="hljs-literal">False</span><br>e.save()<br></code></pre></td></tr></table></figure><p>建议如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Entry.objects.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">id</span>=<span class="hljs-number">10</span>).update(comments_on=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>用update()还可以防止在加载对象和调用save()之间的短时间内数据库中某些内容可能发生更改的竞争条件。</p><p><code>update()方法不会调用save()方法，也不会发出pre_save和post_save信号。</code>所以，如果想更新一个具有自定义save()方法的模型的记录，请循环遍历它们并调用save()，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> Entry.objects.<span class="hljs-built_in">filter</span>(pub_date__year=<span class="hljs-number">2020</span>):<br>    e.comments_on = <span class="hljs-literal">False</span><br>    e.save()<br></code></pre></td></tr></table></figure><h4 id="delete">8. delete()</h4><p>批量删除QuerySet中的所有对象，并返回删除的对象个数和每个对象类型的删除次数的字典。</p><p>delete()动作是立即执行的。</p><p>例如，要删除特定博客中的所有条目：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b = Blog.objects.get(pk=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 删除b下所属的所有条目</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.<span class="hljs-built_in">filter</span>(blog=b).delete()<br>(<span class="hljs-number">4</span>, &#123;<span class="hljs-string">&#x27;weblog.Entry&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>默认情况下，任何具有指向要删除的对象的外键的对象将与它们一起被删除。 像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>blogs = Blog.objects.<span class="hljs-built_in">all</span>()<br><span class="hljs-comment"># This will delete all Blogs and all of their Entry objects.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>blogs.delete()<br>(<span class="hljs-number">5</span>, &#123;<span class="hljs-string">&#x27;weblog.Blog&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;weblog.Entry&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>这种级联的行为可以通过的ForeignKey的<code>on_delete</code>参数自定义。（什么时候要改变这种行为呢？比如日志数据，就不能和它关联的主体一并被删除！）</p><p>delete()会为所有已删除的对象（包括级联删除）发出<code>pre_delete</code>和<code>post_delete</code>信号。</p><p>详情请百度，或查阅<a href="https://www.liujiangblog.com/course/django/131">这里</a>。</p><h2 id="注解与聚合">1.10 注解与聚合</h2><p>Django的ORM提供的API主要是用来增删查改单个对象的方法。 然而，有时候你要获取的值需要根据一组对象聚合后才能得到，比如几个学生成绩的平均分，非常类似数据分析和统计。</p><p>本节以下面的模型为例，来记录多个网上书店的库存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)<br>    age = models.IntegerField()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">300</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">300</span>)<br>    pages = models.IntegerField()<br>    price = models.DecimalField(max_digits=<span class="hljs-number">10</span>, decimal_places=<span class="hljs-number">2</span>)<br>    rating = models.FloatField()<br>    authors = models.ManyToManyField(Author)<br>    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)<br>    pubdate = models.DateField()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>(<span class="hljs-params">models.Model</span>):</span><br>    name = models.CharField(max_length=<span class="hljs-number">300</span>)<br>    books = models.ManyToManyField(Book)<br></code></pre></td></tr></table></figure><h3 id="速查表">速查表</h3><p>下面是根据以上模型执行常见的聚合查询范例，注意阅读其中的注释文字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 书籍的总数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.count()<br><span class="hljs-number">2452</span><br><br><span class="hljs-comment"># BaloneyPress出版社出版的书籍总数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.<span class="hljs-built_in">filter</span>(publisher__name=<span class="hljs-string">&#x27;BaloneyPress&#x27;</span>).count()<br><span class="hljs-number">73</span><br><br><span class="hljs-comment"># 所有书籍的平均价格</span><br><span class="hljs-comment"># 要注意！Avg，Count等聚合工具是由Django提供的，不是Python内置的，也不是你自己编写的。</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Avg<br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.<span class="hljs-built_in">all</span>().aggregate(Avg(<span class="hljs-string">&#x27;price&#x27;</span>))<br>&#123;<span class="hljs-string">&#x27;price__avg&#x27;</span>: <span class="hljs-number">34.35</span>&#125;   <span class="hljs-comment"># 本来返回的是查询集，聚合后返回的是一个数据字典，字典的键名是有规律的</span><br><br><span class="hljs-comment"># 所有书籍中最高的价格</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Max<br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.<span class="hljs-built_in">all</span>().aggregate(Max(<span class="hljs-string">&#x27;price&#x27;</span>))<br>&#123;<span class="hljs-string">&#x27;price__max&#x27;</span>: Decimal(<span class="hljs-string">&#x27;81.20&#x27;</span>)&#125;<br><br><span class="hljs-comment"># 所有书籍中最高价和平均价的差</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> FloatField<br><span class="hljs-meta">&gt;&gt;&gt; </span>Book.objects.aggregate(<br><span class="hljs-meta">... </span>    price_diff=Max(<span class="hljs-string">&#x27;price&#x27;</span>, output_field=FloatField()) - Avg(<span class="hljs-string">&#x27;price&#x27;</span>))<br>&#123;<span class="hljs-string">&#x27;price_diff&#x27;</span>: <span class="hljs-number">46.85</span>&#125;<br><br><br><span class="hljs-comment"># 下面是annonte注解的用法</span><br><br><span class="hljs-comment"># 每一个被过滤出来的出版社对象都被附加了一个&quot;num_books&quot;属性，这个属性就是所谓的注释</span><br><span class="hljs-comment"># 和aggregate不同，annotate返回的依然是查询集，添加了私货的查询集。</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Count<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="hljs-string">&#x27;book&#x27;</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs<br>&lt;QuerySet [&lt;Publisher: BaloneyPress&gt;, &lt;Publisher: SalamiPress&gt;, ...]&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs[<span class="hljs-number">0</span>].num_books<br><span class="hljs-number">73</span><br><br><span class="hljs-comment"># 每一个出版商都被附加了两个额外的属性，分别表示好评率大于5和好评率小于等于5的书籍的总数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> Q<br><span class="hljs-comment"># 统计每个出版社中好评率大于5的书籍的数量</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>above_5 = Count(<span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-built_in">filter</span>=Q(book__rating__gt=<span class="hljs-number">5</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>below_5 = Count(<span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-built_in">filter</span>=Q(book__rating__lte=<span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># 要理解这里的链式调用含义。annotate不是filter，不会增减查询集的元素。</span><br><span class="hljs-comment"># 所以Publisher.objects实际上等于pubs=Publisher.objects.all()</span><br><span class="hljs-comment"># 第一个annotate为pubs增加below_5属性，第二个annotate又再次增加above_5属性</span><br><span class="hljs-comment"># 虽然是链式调用，但不是过滤行为，而是追加行为</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(below_5=below_5).annotate(above_5=above_5)<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs[<span class="hljs-number">0</span>].above_5<br><span class="hljs-number">23</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs[<span class="hljs-number">0</span>].below_5<br><span class="hljs-number">12</span><br><br><span class="hljs-comment"># 这个比较复杂。首先获取了所有的出版社。其次统计每个出版社的发行书籍数量，保存在num_books属性中。</span><br><span class="hljs-comment"># 然后对所有的出版社进行排序，根据num_books属性进行反向由多到少排序，最后切片获取前5个出版社。</span><br>The top <span class="hljs-number">5</span> publishers, <span class="hljs-keyword">in</span> order by number of books.<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="hljs-string">&#x27;book&#x27;</span>)).order_by(<span class="hljs-string">&#x27;-num_books&#x27;</span>)[:<span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>pubs[<span class="hljs-number">0</span>].num_books<br><span class="hljs-number">1323</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小张的反思日记</title>
    <link href="/2020/10/12/%E5%B0%8F%E5%BC%A0%E7%9A%84%E4%B8%89%E5%B9%B4%E5%9B%9E%E9%A1%BE/"/>
    <url>/2020/10/12/%E5%B0%8F%E5%BC%A0%E7%9A%84%E4%B8%89%E5%B9%B4%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>天亮了。</p><blockquote><p>张欣妍</p><p>2020.10.12 4:20</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>小张日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小张日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2020/10/07/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2020/10/07/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法">双指针算法</h1><h2 id="思路">思路</h2><p>在利用双指针算法解题时,考虑原问题如何用暴力算法解出,观察是否可构成单调性,若可以,就可采用双指针算法对暴力算法进行优化。</p><p>常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p><h3 id="code">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span>(j &lt; i &amp;&amp; check(i , j))<br>        <br>    <span class="hljs-comment">//每道题目的具体逻辑。。。</span><br>&#125;  <br></code></pre></td></tr></table></figure><p>核心思想就是优化暴力枚举，两重循环。将 <span class="math inline">\(O(n^2)\)</span> 变为 <span class="math inline">\(O(n)\)</span> 。</p><h2 id="例题">例题</h2><h3 id="acwing-799.-最长连续不重复子序列">1、<a href="https://www.acwing.com/problem/content/801/">AcWing 799. 最长连续不重复子序列</a></h3><h4 id="思路-1">思路</h4><ol type="1"><li>遍历数组a中的每一个元素a[i], 对于每一个i，找到j使得双指针[j, i]维护的是以a[i]结尾的最长连续不重复子序列，长度为i - j + 1, 将这一长度与r的较大者更新给r。</li><li>对于每一个i，如何确定j的位置：由于[j, i - 1]是前一步得到的最长连续不重复子序列，所以如果[j, i]中有重复元素，一定是a[i]，因此右移j直到a[i]不重复为止（由于[j, i - 1]已经是前一步的最优解，此时j只可能右移以剔除重复元素a[i]，不可能左移增加元素，因此，j具有“单调性”、本题可用双指针降低复杂度）。</li><li>用<strong>数组s记录子序列a[j ~ i]中各元素出现次数</strong>，遍历过程中对于每一个i有3步操作：将a[i]出现次数s[a[i]]加1 -&gt; 若a[i]重复则右移j（s[a[j]]要先减1，再右移） -&gt; 确定j及更新当前长度i - j + 1给r。</li></ol><h4 id="注意细节">注意细节</h4><p>当a[i]重复时，<strong>一定要先把a[j]次数减1，再右移j。</strong></p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/双指针/image-20201006172808285.png" alt="image-20201006172808285" /><figcaption>image-20201006172808285</figcaption></figure><h4 id="code-1">code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> s[N];  <span class="hljs-comment">// 记录数组元素出现的次数</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        s[a[i]] ++ ;<br>        <span class="hljs-keyword">while</span>(s[a[i]] &gt; <span class="hljs-number">1</span>) <br>        &#123;<br>            s[a[j]] -- ;  <span class="hljs-comment">// 先减次数</span><br>            j ++ ;  <span class="hljs-comment">// 再往后移指针</span><br>        &#125;<br>        <br>        res = max(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acwing-800.-数组元素的目标和">2、<a href="https://www.acwing.com/problem/content/description/802/">AcWing 800. 数组元素的目标和</a></h3><h4 id="思路-2">思路</h4><p>当 <code>a[i]+b[j]&gt;x</code> 时,随着i增加，j减少</p><h4 id="code-2">code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> a[N], b[N];<br><span class="hljs-keyword">int</span> n, m, x;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; b[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j -- ;<br>        <br>        <span class="hljs-keyword">if</span> (a[i] + b[j] == x) <br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, j);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统课堂笔记总结</title>
    <link href="/2020/10/06/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/10/06/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p><div class="note note-warning">            <p>2020.10.4：总结了一些有关操作系统的常见面试问题以及一些书上和笔记上的知识点。</p>          </div></p><h1 id="第一章-操作系统概述">第一章 操作系统概述</h1><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20201006083338715.png" alt="image-20201006083338715" /><figcaption>image-20201006083338715</figcaption></figure><h2 id="什么是操作系统它的主要特征是什么">1、什么是操作系统？它的主要特征是什么？</h2><p><strong>操作系统是指控制和管理整个计算机系统硬件和软件资源的最基本的系统软件。</strong></p><p><strong>特征：</strong></p><ol type="1"><li><p><strong>并发性</strong>：两个或多个事件在<strong>同一时间间隔</strong>内发生（而并行性是指两个或多个事件在同一时刻发生）计算机系统中同时存在多个运行的程序，因此他有处理和调度多个程序同时执行的能力。在os中，引入进程的目的是使程序能够并发执行。</p><blockquote><p>并发和并行的区别？</p><ul><li>并发：同一时间间隔。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此微观上这些程序仍是分时交替执行的。操作系统的并发性是通过分时得以实现的。</li><li>并行：同一时刻</li></ul></blockquote></li><li><p><strong>共享性</strong>：系统中的硬件和软件资源不再为某个程序所独占，而是供多个用户共同使用（包括互斥共享（如<em>打印机，某些变量，队列等一段时间只能供一个作业使用的资源</em>）和同时访问（如<em>可重入代码，磁盘等</em>），后者作业访问资源的顺序不会影响访问的结果）</p></li><li><p><strong>虚拟性</strong>：把一个物理上的实体变为若干个逻辑上的对应物</p></li><li><p><strong>异步性</strong>：在多道程序环境中，由于资源等因素的限制，程序（进程）走走停停，以不可预知的速度向前推进</p></li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200827214637040.png" alt="image-20200827214637040" /><figcaption>image-20200827214637040</figcaption></figure><h2 id="操作系统的功能">2、操作系统的功能</h2><h3 id="操作系统是计算机资源的管理者">1. 操作系统是计算机资源的管理者</h3><ol type="1"><li><strong>处理器管理</strong>：对处理器的分配和和运行（以进程为单位）实施有效的管理，包括<code>进程控制（负责进程的创建，撤销以及状态转换），进程同步（对并发执行的进程进行协调），进程通信（负责进程间的信息交流），进程调度（按一定算法进行处理器分配）</code></li><li><strong>存储器管理</strong>：对内存进行分配，保护和扩充，包括<code>内存分配（按一定策略为每道程序分配内存），内存保护（保证各程序在自己的内存区域内运行而不相互干扰），内存扩充（为允许大型最作业或多作业的运行，必须借助虚拟存储技术去获得增加内存的效果）</code></li><li><strong>文件管理</strong>：操作系统中负责信息管理的部分称为文件系统，文件管理的主要任务包括<code>文件存储空间的管理（存储空间的分配与回收），目录管理（提供按名存取的功能），文件操作管理（负责完成数据的读写），文件保护</code> 用户接口：方便用户使用操作系统，包括<code>命令接口（包括联机命令接口和脱机命令接口），程序接口（也称系统调用），图形接口</code></li><li><strong>设备管理</strong>：对计算机系统内的所有设备进行管理。包括<code>设备分配（根据一定的设备分配原则对设备进行分配），设备传输控制（实现物理的输入输出操作），设备独立性（用户程序中的设备与实际使用的物理设备无关)</code></li></ol><h3 id="提供用户与计算机之间的接口">2. 提供用户与计算机之间的接口</h3><h3 id="扩充机器">3. 扩充机器</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200827190507593.png" alt="image-20200827190507593" /><figcaption>image-20200827190507593</figcaption></figure><h2 id="中断和异常">3、中断和异常</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830115528580.png" alt="image-20200830115528580" /><figcaption>image-20200830115528580</figcaption></figure><h3 id="中断的引入为了支持cpu和设备之间的并行操作">1. 中断的引入——为了支持CPU和设备之间的并行操作</h3><p>中断也称外中断，<u>指来自CPU执行指令以外的事件的发生</u>，如设备发出的I/O结束中断、时钟中断 等。这一类中断通常是与当前执行的指令无关的事件。</p><h3 id="异常的引入表示cpu执行指令本身时出现的问题">2. 异常的引入——表示CPU执行指令本身时出现的问题</h3><p>异常也称内中断、例外或陷入，<u>指源自CPU执行指令内部的事件</u>，如程序的非法操作码、地址越 界、算术溢出、缺页异常等。对异常的处理一般要依赖与当前程序的运行现场，不能被屏蔽。</p><h3 id="中断和异常的联系与区别">3. 中断和异常的联系与区别</h3><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006112017650.png" alt="image-20201006112017650" style="zoom:80%;" /></p><h3 id="中断执行的流程">4. 中断执行的流程</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830104258275.png" alt="image-20200830104258275" /><figcaption>image-20200830104258275</figcaption></figure><h2 id="系统调用是什么">4、系统调用是什么？</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830114156802.png" alt="image-20200830114156802" /><figcaption>image-20200830114156802</figcaption></figure><ul><li><strong>系统调用：是操作系统为应用程序使用内核功能所提供的接口。</strong></li><li>系统调用的目的：申请系统服务。OS不允许用户直接操作各种硬件资源，因此用户只能通过系统调用的方式来请求内核为其服务，间接地使用各种资源。</li></ul><p>操作系统为用户态进程与硬件设备进行交互提供了一组接口——系统调用:</p><ol type="1"><li><p>把用户从底层的硬件编程中解放了出来;</p></li><li><p>极大地提高了系统的安全性使用户程序具有可移植性；用户程序与具体硬件 已经被抽象接口所替代。</p></li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统//image-20200830104510608.png" alt="image-20200830104510608" /><figcaption>image-20200830104510608</figcaption></figure><h3 id="与一般过程调用有何区别">与一般过程调用有何区别？</h3><p>一般过程调用工作在用户态，通过过程调用语句实现，可以无限制嵌套调用；</p><p>系统调用运行在核心态，通过访管中断进入，不可以嵌套调用。</p><h3 id="指令是内核态的多还是用户态的多">指令是内核态的多还是用户态的多？</h3><p>内核态，CPU可以访问内存所有数据，用户态下是受限访问，只能访问自己空间中的内存</p><h3 id="中断和系统调用的区别">中断和系统调用的区别:</h3><ol type="1"><li><p>中断是由外设产生, 无意的, 被动的</p><p>系统调用是由应用程序请求操作系统提供服务产生, 有意的, 主动的。要从用户态通过中断进入内核态。（联系）</p></li><li><p>中断过程：中断请求 中断响应 断点保护 执行中断服务程序 断点恢复 中断返回</p><p>系统调用过程：应用程序在用户态执行时请求系统调用，中断，从用户态进入内核态，在内核态执行相应的内核代码。</p></li></ol><h3 id="中断之后保存什么">中断之后保存什么？</h3><p>保存pc, psw, 通用寄存器。Pc程序计数器program count，存放下一条指令所在的单元的地址。Psw，program status word程序状态字，指处理器的状态。</p><h2 id="操作系统的发展与分类">5、操作系统的发展与分类</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200827215158997.png" alt="image-20200827215158997" /><figcaption>image-20200827215158997</figcaption></figure><h1 id="第二章-进程管理">第二章 进程管理</h1><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829172422636.png" alt="image-20200829172422636" /><figcaption>image-20200829172422636</figcaption></figure><h2 id="进程与线程的基本概念">1、进程与线程的基本概念</h2><h2 id="进程">进程</h2><h3 id="进程的定义">进程的定义</h3><p><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong></p><h3 id="进程的组成进程映像-进程实体">进程的组成（进程映像 / 进程实体）</h3><ul><li><p>程序段：进程运行的程序的代码进程中能被进程调度程序调度到CPU上执行的代码段</p></li><li><p>数据段：存储程序运行过程中相关的一些数据</p></li><li><p>PCB：每一个进程都有一个PCB，记录进程的状态和控制进程的全部信息。既能标识进程存在（唯一标识），又能刻画执行瞬间的数据结构 。系统通过PCB对进程进行控制和管理。</p><p>【为什么PCB是进程存在的唯一标志？】</p><blockquote><p>在系统调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存地址，找到其程序和数据</p><p>进程在执行过程中，当需要和与之合作的进程实现同步，通信或访问文件时，也都需要访问PCB</p><p>当程序由于某种原因暂停执行时，又需要将其断点的处理机环境保存在PCB中</p></blockquote></li></ul><h3 id="进程的状态与转换">进程的状态与转换</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828090515446.png" alt="image-20200828090515446" /><figcaption>image-20200828090515446</figcaption></figure><blockquote><p>就绪态和阻塞态的区别？</p><ul><li>就绪态：指进程进缺少处理机，只要获得处理机资源就立即执行。</li><li>阻塞态：指进程需要 其他资源（除了处理机）或 等待某事件发生。</li></ul><p>之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地由运行态转换到就绪态的。</p><p>而其它资源（如外设）的使用和分配 或 某一事件的发生（I/O操作的完成）对应的时间相对来说很长，进程由运行态转换为阻塞态的次数也相对较少。</p></blockquote><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006092312841.png" alt="image-20201006092312841" /><figcaption>image-20201006092312841</figcaption></figure><h3 id="进程与程序的关系">进程与程序的关系</h3><ul><li>进程是动态的，程序是静态的</li><li>进程是暂时的，进程是永久的</li><li>进程与程序的组成不同<ul><li>进程是竞争计算机资源的基本单位</li><li>程序是一组有序的指令集合</li></ul></li><li>进程具有并发性，而程序没有</li><li>通过多次执行，一个程序可以产生多个不同的进程；通过调用关系，一个进程可以执行多个程序。进程可以创建其他进程，而程序不能形成新的程序。进程与程序之间不是一一对应的，一个进程可以执行多个程序，但一个进程只能对应一个程序。</li></ul><h3 id="进程同步有哪几种机制">进程同步有哪几种机制</h3><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p><h3 id="进程间通信ipc的几种方式">进程间通信IPC的几种方式</h3><h4 id="低级通信方式pv">低级通信方式PV</h4><p>我们通过信号量机制, 来解决进程同步和互斥的问题.而pv操作是可以访问信号量的两个原语. P<a href="https://baike.baidu.com/item/原语">原语</a>操作的动作是：S减1；若S减1后仍大于或等于零，则进程继续执行；若S减1后小于零，则该进程被阻塞后进入等待队列。</p><p>V原语操作的动作是：S加1；若相加结果大于零，则进程继续执行；若相加结果小于或等于零，则从待队列中唤醒一等待进程.</p><h4 id="高级通信方式">高级通信方式</h4><ol type="1"><li><p>共享内存</p><p>顾名思义，共享内存就是两个进程同时共享一块内存，然后在这块内存上的数据可以共同修改和 读取，达到通信的目的。</p></li><li><p>无名管道</p><p>无名管道是半双工的通信方式；并且只能在具有亲缘关系的进程之间使用（亲缘关系是指进程间 的父子关系，兄弟关系等），具有亲缘关系的进程在创建时同时拥有一个无名管道的句柄，可以 进行读写；无名管道不存在磁盘节点，只存在与内存中用完即销毁。</p></li><li><p>命名管道</p><p>命名管道也是半双工的通信方式；可以在不具有亲缘关系的进程间通信；有名管道存在磁盘节 点，有对应的FIFO文件，凡是可以访问该路径的文件的进程均可以进行通信。</p></li><li><p>消息队列</p><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信 息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>套接字</p><p>套接字是网络编程的api，通过套接字可以不同的机器间的进程进行通信，常用于客户端进程和服 务器进程的通信。</p></li><li><p>信号</p><p>信号是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中 发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原 始机制。一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等） 都有可能产生一个信号。Shell也使用信号向它的子进程发送作业控制信号。</p></li></ol><h2 id="线程">线程</h2><h3 id="线程的定义">线程的定义</h3><ul><li><p>“轻量级进程”</p></li><li><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828095244971.png" alt="image-20200828095244971" /><figcaption>image-20200828095244971</figcaption></figure><h3 id="线程的实现">线程的实现</h3><ul><li>用户级线程：不依赖于操作系统核心，线程管理（现成的创建、撤销和切换等）的所有工作都有应用程序完成，内核意识不到线程的存在。</li><li>内核级线程：<strong>依赖于内核</strong>，线程管理的所有工作都有内核完成。应用程序没有进行线程管理的代码，只有一个到被内核级线程的编程接口。内核为进程及起内部的每个进程维护上下文信息，调度也在内核基于线程架构的基础上完成。</li></ul><h3 id="线程同步的方式">线程同步的方式</h3><ul><li>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li><li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li></ul><h3 id="线程与进程的比较">线程与进程的比较</h3><blockquote><ul><li><p>引入进程的目的：为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量。</p><p>多道程序同时运行的过程，是一个动态的过程，而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程序内部的执行情况，即无法从程序的字面上看出他何时停顿，中止，也无法看出它与其他执行程序的关系，因此，程序这个静态概念已不能如实反映程序的并发执行的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。</p></li><li><p>引入线程的目的：为了减小程序在并发执行时所付出的时空开销，提高OS的并发性能。</p></li></ul></blockquote><ol type="1"><li><p><strong>调度。</strong>引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位；在同一进程中，线程的切换不会引起进程切换；在不同进程中进行线程切换，将引起进程切换。</p></li><li><p><strong>拥有资源。</strong>进程始终是拥有资源的基本单位；线程不拥有系统资源，但可以访问其隶属进程的系统资源</p></li><li><p><strong>并发性。</strong>引入线程的操作系统中，不仅进程之间可以并发执行，而且同一进程内的多个线程之间也可以并发执行，这使得操作系统具有更好的并发性，提高了系统的资源吞吐量。</p></li><li><p><strong>系统开销。</strong>引入线程后，线程之间的切换开销很小，而且由于同一进程内的多个线程共享进程的地址空间，因此多线程之间的同步与通信容易实现</p></li><li><p><strong>通信方面。</strong>进程间通信IPC需要进程同步和互斥手段的辅助，以保正数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p></li></ol><blockquote><p>【进程的特征】</p><ul><li>动态性：进程是程序的一次执行过程，是动态地产生，变化和消亡的</li><li>并发性：内存中有多个进程实体，各进程可并发执行</li><li>独立性：进程是能独立运行，独立获得资源，独立接受调度的基本单位</li><li>异步性：各进程按各自独立的，不可预知的速度向前推进</li><li>结构性：每个进程都会配置一个PCB，结构上看，进程由数据段，程序段，PCB组成</li></ul><p>【导致进程创建的事件有哪些？】</p><ul><li><p>用户登录。在分时系统中，用户在终端输入登录信息，系统检测通过后就为该终端用户建立新进程并插入到就绪队列</p></li><li><p>作业调度。在批处理系统中，当作业调度程序按照一定的算法调度到某个作业时，将该作业装入内存，并为其分配资源并创建进程，并插入到就绪队列</p></li><li><p>请求服务。基于进程的需要，由其自身创建一个新进程并完成特定任务</p></li></ul><p>【创建进程时，操作系统需要完成的主要工作是什么？】</p><ul><li><p>先向系统申请一个空闲PCB，并指定唯一的进程标识符（PID）</p></li><li><p>为新进程分配必要的资源</p></li><li><p>将新进程的PCB初始化。为新进程的PCB填入进程名，家族信息，程序数据地址，优先级等信息</p></li><li><p>将新进程的PCB插入到就绪队列</p></li></ul><p>【导致进程撤销的事件有哪些？】</p><p>进程正常结束，进程异常结束以及外界干预等</p><p>【撤销一个进程时，操作系统主要完成的工作是什么？】</p><ul><li><p>先从PCB集合中找到被撤销进程的PCB</p></li><li><p>若被撤销进程正处于执行状态，则应立即停止该进程的执行，设置重新调度标识，以便进程重新后将处理器分配给其他进程</p></li><li><p>对后一种撤销策略，若被撤销进程有子孙进程，还应将该进程的子孙进程撤销</p></li><li><p>回收被撤销进程所占有的资源，或者归还给父进程，或者归还给系统。最后，回收其PCB</p></li></ul><p>【阻塞一个进程时，操作系统主要完成的工作是什么？】</p><ul><li><p>首先停止当前进程的运行。因该进程正处于执行状态，故应中断处理器</p></li><li><p>保存该进程的CPU现场以便之后可以重新调用该进程并从中断点开始执行</p></li><li><p>停止运行该进程，将进程状态由执行状态改为阻塞状态，然后将该进程插入到相应事件的等待队列中</p></li><li><p>转到进程调度程序，从就绪队列中选择一个新的进程投入运行</p></li></ul><p>【唤醒一个进程时，操作系统主要完成的工作是什么？】</p><ul><li><p>将被唤醒进程从相应的等待队列中移出</p></li><li><p>将状态改为就绪并插入相应的就绪队列</p></li></ul><p>【简述进程上下文切换的过程】==【切换进程时，操作系统主要完成的工作是什么？】</p><ul><li><p>保存处理及上下文，包括程序计数器和其他寄存器</p></li><li><p>更新PCB信息</p></li><li><p>把进程的PCB移入相应队列，如就绪，某事件的阻塞队列</p></li><li><p>选择另一个进程执行，更新其PCB</p></li><li><p>更新内存管理的数据结构</p></li><li><p>恢复处理器上下文</p></li></ul><p>【进程与作业的关系】</p><p>作业是用户向计算机提交任务的任务实体，而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位</p><p>一个作业可由一个或多个进程组成，但一个进程不能构成多个作业</p><p>作业的概念主要用在批处理系统中，而进程的概念则几乎用在所有的多道程序系统中</p></blockquote><h2 id="进程调度的基本概念调度方式调度算法">2、进程调度的基本概念、调度方式、调度算法</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/IMG_2285(20200829-102509).PNG" alt="IMG_2285(20200829-102509)" /><figcaption>IMG_2285(20200829-102509)</figcaption></figure><h3 id="进程调度的概念">进程调度的概念</h3><ul><li><strong>系统按照某种算法动态地把处理器分配给就绪队列中的某个进程，以便使之执行</strong></li></ul><h3 id="操作系统中的3级调度">操作系统中的3级调度</h3><blockquote><p>高级调度，又称作业调度，按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程，发生频率最低</p><p>中级调度，又称内存调度，按照某种规则，从挂起队列中选择合适的进程将其数据调回内存，发生频率中等</p><p>低级调度，又称进程调度，按照某种规则，从就绪队列中选择一个进程为其分配处理机，发生频率最高</p></blockquote><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828152139261.png" alt="image-20200828152139261" /><figcaption>image-20200828152139261</figcaption></figure><h3 id="进程调度的方式cpu调度算法中抢占式调度和非抢占式调度有何区别">进程调度的方式/CPU调度算法中抢占式调度和非抢占式调度有何区别？</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200828161817900.png" alt="image-20200828161817900" /><figcaption>image-20200828161817900</figcaption></figure><ul><li><p>抢占方式，当一个进程正在处理器上运行时，若有更高优先级的进程进入就绪队列，则立即暂停执行当前进程，将处理器分配给新进程。可优先处理紧急进程，也可实现让各进程按时间片轮流执行，适用于分时操作系统，实时操作系统</p></li><li><p>非抢占方式，当一个进程正在处理器上运行时，即使有更高优先级的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或者因发生某种事件而进入完成或者阻塞状态时，才把处理器分配个新进程。实现简单，开销小，但无法处理紧急任务，适用于早期批处理系统</p></li></ul><h3 id="在交互式系统中非剥夺是不是一个好的策略为什么">在交互式系统中，非剥夺是不是一个好的策略？为什么？</h3><p>在分时系统中不剥夺并不是一个好的策略。因为在分时系统中，除了交互性以外，及时性是很重要的性能因素。当一个作业被阻塞后，CPU就完全空闲了，别的用户的及时性就无法保证了，而完全可以把这些时间分配给别的作业运行。以提高整体的吞吐量。</p><h3 id="调度算法的评级指标">调度算法的评级指标</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901161312189.png" alt="image-20200901161312189" /><figcaption>image-20200901161312189</figcaption></figure><h3 id="调度算法">调度算法</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111857860.png" alt="image-20201006111857860" /><figcaption>image-20201006111857860</figcaption></figure><ul><li><p>先来先服务：先请求CPU的进程先分配到CPU</p></li><li><p>短作业优先：平均等待时间最短，但难以知道下一个CPU区间长度</p></li><li><p>优先级调度：分为抢占式和非抢占式，优先级相同时，通常按照先来先服务或者短作业优先的顺序执行</p></li><li><p>时间片轮转：各进程执行一个时间片</p></li><li><p>高响应比优先：响应比=（等待时间+运行时间）/运行时间</p></li><li><p>多级反馈队列调度</p><p>与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p></li></ul><blockquote><p><u>优先级调度算法</u>按照任务的优先级进行调度，对于更紧急的任务会有更高的优先级，适合实时操作系统。</p><p><u>高响应比优先调度算法，时间片轮转调度算法，多级反馈队列调度算法</u> 都能保证每个任务在一定时间内分到时间片，并轮流占用CPU，适合分时操作系统。</p></blockquote><h3 id="为什么要进行处理机的调度">为什么要进行处理机的调度？</h3><p>答：若没有处理机的调度，就意味着要等到当前运行的进程执行完毕后，下一个进程才能执行，而实际情况中，进程时常需要等待一些外部设备的输入，而外部设备的速度与处理机相比是非常缓慢的，若让处理机总是等待外部设备，则对处理机的资源是一种极大的浪费。而引进处理机调度后，可在运行进程等待外部设备时，把处理机调度给其他进程，从而提高处理机的利用率。简单来说，就是<strong>为了合理地处理计算机的软/硬件资源</strong>。</p><blockquote><p>【引起进程调度的原因】</p><p>当前进程运行结束，包括任务完成而正常结束或者因出现错误而异常结束</p><p>当前运行进程因某种原因，如I/O请求，P操作，阻塞原语等从运行态变为阻塞态</p><p>执行完系统调用等系统程序后返回用户进程，这时可以看作系统进程执行完毕，从而可以调度一个新的用户进程</p><p>在采用抢占式调度方式的系统中，更高优先级的进程要求使用处理器，则使当前运行进程进入就绪队列</p><p>在分时系统中，分配给该进程的时间片已用完</p><p>【不能进行进程调度的情况】</p><p>处理中断的过程中。处理中断过程复杂，很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理器资源</p><p>在操作系统内核程序临界区中。进程进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放</p><p>在其他需要完全屏蔽中断的原子操作过程中。原子操作不可再分，不能进行进程切换</p></blockquote><h2 id="进程同步的基本概念临界区信号量经典同步问题">3、进程同步的基本概念、临界区、信号量、经典同步问题</h2><h3 id="为什么要引入进程同步的概念">为什么要引入进程同步的概念？</h3><p>答：在多道程序共同执行的条件下，进程与进程之间是并发执行的，不同进程之间存在不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p><h3 id="两种形式的制约关系同步和互斥">两种形式的制约关系：同步和互斥？</h3><ul><li><p>同步：直接相互制约关系。多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消 息，获得消息之前进入阻塞态；</p></li><li><p>互斥：间接相互制约关系。多个进程在同一时刻只有一个进程能进入临界区</p></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829102854372.png" alt="image-20200829102854372" /><figcaption>image-20200829102854372</figcaption></figure><blockquote><p>临界资源：同时仅允许一个进程使用的资源</p><p>临界区：进程中用于访问临界资源的代码，又称临界段</p></blockquote><h3 id="临界区互斥的要求同步机制的4个准则">临界区互斥的要求/同步机制的4个准则</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006101307403.png" alt="image-20201006101307403" /><figcaption>image-20201006101307403</figcaption></figure><ul><li><strong>空闲让进</strong>：当没有进程处于临界区时，可以允许一个请求进入临界区的进程立即进入临界区</li><li><strong>忙则等待</strong>：当已有进程进入临界区时，其他师徒进入的进程必须等待</li><li><strong>有限等待</strong>：对要求访问临界区的进程，应在有限的时间内进入自己的临界区</li><li><strong>让权等待</strong>：当一个进程因为某些已有无法进入自己的临界区时，应释放处理器给其他进程</li></ul><h3 id="信号量">信号量</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829110504215.png" alt="image-20200829110504215" /><figcaption>image-20200829110504215</figcaption></figure><blockquote><p>(1)整型信号量：未遵循让权等待</p><p>(2)记录型信号量（资源信号量），P&amp;V 操作主要用这个</p></blockquote><h3 id="经典ipc问题">经典IPC问题</h3><blockquote><p>生产者-消费者 读者写者问题（读优先，读写公平，写优先） 哲学家进餐 理发师</p></blockquote><h3 id="什么是管程">什么是管程？</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829111335944.png" alt="image-20200829111335944" /><figcaption>image-20200829111335944</figcaption></figure><p>管程是由<strong>一组局部变量</strong>、<strong>对局部变量进行操作的一组过程</strong>和<strong>对局部变量进行初始化的语句序列</strong>组成。 引入的原因是因为P/V操作太过分散，对它的<strong>维护很麻烦且容易造成死锁</strong>。 管程的特点是：</p><ol type="1"><li>管程的过程只能访问管程的局部变量，管程的局部变量只能由其过程来访问；</li><li>任何时刻只能有一个进程进入管程执行；</li><li>进程只能通过管程提供的过程入口进入管程。</li></ol><h2 id="死锁的基本概念处理策略死锁预防和死锁避免的算法死锁检测">4、死锁的基本概念、处理策略、死锁预防和死锁避免的算法、死锁检测</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829165839493.png" alt="image-20200829165839493" /><figcaption>image-20200829165839493</figcaption></figure><h3 id="死锁的定义">死锁的定义</h3><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829120015942.png" alt="image-20200829120015942" /><figcaption>image-20200829120015942</figcaption></figure><h3 id="饥饿和死锁">饥饿和死锁？</h3><p>饥饿：指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。</p><p>相同：二者都是因为竞争资源引起的。</p><p>差别：</p><ol type="1"><li><p>进入饥饿的进程可以只有一个，但是死锁必须大于等于两个；</p></li><li><p>出于饥饿状态的进程可以是一个就绪进程，但是死锁状态的进程必定是阻塞进程。</p></li></ol><h3 id="可剥夺资源与不可剥夺资源的区别">可剥夺资源与不可剥夺资源的区别</h3><ul><li><p>可剥夺资源是指虽然资源占有者进程需要使用该资源，但另一个进程可以强行把该资源剥夺来归自己使用</p></li><li><p>不可剥夺资源是指除占有者进程不再需要使用该资源而主动释放资源，其他进程不可在资源占有者使用资源过程中强行剥夺</p></li></ul><h3 id="死锁产生的原因">死锁产生的原因</h3><ul><li><p>系统资源不足（根本原因）（对不可剥夺资源的竞争）</p></li><li><p>进程推进顺序不当（P1拥有A申请B，P2拥有B申请A）</p></li></ul><h3 id="死锁产生的必要条件">死锁产生的必要条件</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829121437044.png" alt="image-20200829121437044" /><figcaption>image-20200829121437044</figcaption></figure><ul><li><p><strong>互斥条件</strong>：进程要求对所分配的资源进行排他性控制，即在一段时间内某种资源仅为一个进程所占有</p></li><li><p><strong>不剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，只能由获得该资源的进程主动释放</p></li><li><p><strong>请求和保持条件</strong>：也成部分分配条件，是指进程已经保持了至少一个资源，但又提出了新的资源请求，而在等待新的资源被分配的同时，又对已有资源保持占有</p></li><li><p><strong>循环等待条件</strong>：存在一种资源的循环等待链，而链中每一个进程已获得的资源同时被链中的下一个进程所请求</p></li></ul><h3 id="有什么方法解决死锁问题处理死锁的基本方法">有什么方法解决死锁问题？（处理死锁的基本方法）</h3><ol start="0" type="1"><li><p>鸵鸟算法：视死锁不见</p></li><li><p>预防死锁：破坏死锁产生的4个必要条件中的一个或多个</p></li><li><p>避免死锁：在资源的动态分配过程中，用 某种方法(一些算法)去防止系统进入不安全状态，从而避免发生死锁。</p></li><li>检测死锁：若不加任何限制措施，系统可在为进程分配资源的同时，记录下来进程的请求和分配信息，然后按某种算法计算系统是否会发生死锁；</li><li><p>解除死锁：系统发生死锁时通常采用撤销进程或剥夺进程资源的方法使系统解除死锁。</p></li></ol><h3 id="死锁的预防静态策略">死锁的预防（静态策略）</h3><ol type="1"><li><p>破坏互斥条件：允许多个进程同时访问资源，可行性不高</p></li><li><p>破坏不剥夺条件：对于一个已经获得了某些资源的进程，若新的资源请求不能立即得到满足，则它必须释放所拥有的全部资源，以后需要时再重新申请，实现复杂，可能导致部分工作失效，导致系统开销增大，导致饥饿</p></li><li><p>破坏请求和保持条件：运行之前一次行分配好所需要的全部资源，简单安全，但资源利用率低，可能导致饥饿</p></li><li><p>破坏循环等待条件：给资源编号，必须按照编号从小到大的顺序申请资源，不方便增加新设备，会造成资源浪费，用户编程麻烦</p></li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829130743530.png" alt="image-20200829130743530" /><figcaption>image-20200829130743530</figcaption></figure><h3 id="死锁的避免动态策略">死锁的避免（动态策略）</h3><h4 id="什么是安全状态">什么是安全状态？</h4><p>安全状态是指系统按照某种进程顺序，为进程分配资源，使得每个进程都能获取所需的最大资源，并顺利完成。</p><p>当系统不安全时就是系统不一定是死锁状态，但是死锁状态一定是不安全状态。</p><h4 id="银行家算法">银行家算法</h4><p>主要思想是避免系统进入不安全状态，在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先试行分配，并对分配后的新状态进行安全性检查。如果新状态安全，则正式分配上述资 源，否则拒绝分配上述资源。这样就保证系统始终处于安全状态，从而避免死锁现象的发生。</p><h3 id="死锁的检测">死锁的检测</h3><h4 id="死锁定理">死锁定理</h4><p>系统状态为死锁的条件是：当且仅当g该状态下的资源分配图是不可完全简化的。</p><p>如果资源分配图是可以完全简化的（能消去所有的边），则没有死锁。</p><h3 id="死锁的解除">死锁的解除</h3><ul><li><p><strong>资源剥夺法</strong>：从其进程中抢占足够的资源给死锁的进程以解除其死锁状态</p></li><li><p><strong>撤销进程法</strong>：撤销一些进程，直到有足够的资源分配给其他进程，进程死锁状态</p></li><li><p><strong>进程回退法</strong>：让一个或多个进程回退到足以避免死锁的地步，进程回退时资源释放资源而不是被剥夺，要求系统保持进程的历史信息，设置还原点</p></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829130957970.png" alt="image-20200829130957970" /><figcaption>image-20200829130957970</figcaption></figure><h1 id="第三章-内存管理">第三章 内存管理</h1><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901090309778.png" alt="image-20200901090309778" /><figcaption>image-20200901090309778</figcaption></figure><h2 id="内存管理基本概念">1、内存管理基本概念</h2><h4 id="内存管理的功能">内存管理的功能？</h4><ul><li><p>内存的分配与回收：实施内存的分配，回收系统或用户释放的内存空间。</p></li><li><p>地址变换：提供地址变换功能，将逻辑地址转换成物理地址。</p></li><li><p>内存扩充：借助于虚拟存储技术或其他自动覆盖技术，为用户提供比内存空间大的地址空间， 从逻辑 上扩充内存。</p></li><li><p>存储保护：保证进入内存的各道作业都在自己的存储空间内运行，互不干扰</p></li></ul><h4 id="将用户程序变为可在内存中执行的程序的步骤">将用户程序变为可在内存中执行的程序的步骤？</h4><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200831084249851.png" alt="image-20200831084249851" /><figcaption>image-20200831084249851</figcaption></figure><ol start="0" type="1"><li><p>编辑</p></li><li><p><strong>编译</strong>：由编译程序将用户源代码编译成若干目标模块</p></li><li><p><strong>链接</strong>：由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的 装入模块。</p></li><li><p><strong>装入</strong>：由装入程序将装入模块装入内存中运行。</p></li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829200126647.png" alt="image-20200829200126647" /><figcaption>image-20200829200126647</figcaption></figure><h4 id="链接的3种方式">链接的3种方式</h4><ul><li><p><strong>静态链接</strong>：在程序运行之前，先把各个目标模块及所需库链接为一个完整的可执行程序，以后不再拆开</p></li><li><p><strong>装入时动态链接</strong>：将应用程序编译后所得到一组目标模块装入内存时采用边装入边链接的动态链接方式</p></li><li><p><strong>运行时动态链接</strong>：在程序执行中需要该目标模块时，才对这些模块进行链接，便于修改和更新，便于实现对目标模块的共享</p></li></ul><h4 id="程序装入的3种方式">程序装入的3种方式</h4><ul><li><p><strong>绝对装入</strong>：编译时就知道程序将要驻留在内存中的物理地址，编译程序产生含有物理地址的目标代码，不适合多道程序设计</p></li><li><p><strong>可重定位装入</strong>：又称静态重定位，根据内存当前情况，将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，之后不再改变，适用于早期的多道批处理操作系统，容易实现，无需增加硬件地址变换机构，但要求为每个程序分配一个连续的存储区，而且在程序执行期间不能移动，不能再申请内存空间，难以做到程序和数据的共享</p></li><li><p><strong>动态运行时装入</strong>：又称动态重定位，允许程序运行时在内存中移动位置，把地址变换推迟到程序真正要执行时才进行，需要一个重定位寄存器的支持：物理地址=基址寄存器内容+逻辑地址</p></li></ul><p>【内存保护的方法】</p><blockquote><p>界限寄存器方法，包括上、下界寄存器方法和基址和限长寄存器方法</p><p>存储保护键方法,给每个存储块分配一个单独的保护键</p></blockquote><h2 id="内存交换及分页分段段页式内存分配管理">2、内存交换及分页、分段、段页式内存分配管理</h2><h3 id="内存空间的分配与回收----连续分配管理方式">内存空间的分配与回收----连续分配管理方式</h3><ol type="1"><li><p><strong>单一连续分配</strong></p><ul><li><p>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户 区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。</p></li><li><p>这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。缺点是只能 用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。</p></li></ul></li><li><p><strong>固定分区分配</strong></p><p>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小 的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中,选择适 当大小的作业装入该分区，如此循环。</p><p>固定分区分配在划分分区时，有两种不同的方法。</p><ul><li><p>分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。</p></li><li><p>分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。</p></li></ul></li><li><p><strong>动态分区分配</strong></p><p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内 存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进 程的需要。因此系统中分区的大小和数目是可变的。</p></li></ol><h3 id="动态分区分配算法">动态分区分配算法</h3><p>在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存 块给进程使用，这就是动态分区的分配策略，考虑以下几种算法：</p><ol type="1"><li><strong>首次适应(First Fit)算法</strong>：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能 满足要求的第一个空闲分区。</li><li><strong>最佳适应(Best Fit)算法</strong>：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分 区。</li><li><strong>最坏适应(Worst Fit)算法</strong>：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链 接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</li><li><strong>邻近适应(Next Fit)算法</strong>：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分 配内存时从上次查找结束的位置开始继续查找。</li></ol><h2 id="非连续分配管理">非连续分配管理</h2><h3 id="基本分页-存储管理方式的优缺点">基本分页 存储管理方式的优缺点</h3><ul><li><p>优点：内存利用率高，实现了离散分配，便于存储访问控制，无外部碎片</p></li><li><p>缺点：需要硬件支持（尤其是快表），内存访问效率下降，共享困难，有内部碎片</p></li></ul><h3 id="基本分段-存储管理方式的优缺点">基本分段 存储管理方式的优缺点</h3><ul><li><p>优点：便于程序模块化处理和处理变换的数据结构，便于动态链接和共享，无内部碎片</p></li><li><p>缺点：与分页类似，需要硬件支持；为满足分段的动态增长和减少外部碎片，要采用拼接技术；分段的最大尺寸受到主存可用空间的限制；有外部碎片</p></li></ul><h3 id="分段与分页的区别">分段与分页的区别</h3><ul><li><p>页是信息的物理单位，段是信息的逻辑单位；</p></li><li><p>分页的目的是系统管理所需，为了提高内存利用率；分段的目的是为了更好的满足用户的需要，实现地址共享</p></li><li><p>页的大小固定且由系统决定；段的长度不固定，段长由用户编写的程序决定</p></li><li><p>分页的地址空间是一维的；而分段的地址空间是二维的；</p></li><li><p>分页有内部碎片，无外部碎片；分段有外部碎片，无内部碎片</p></li></ul><h3 id="页式存储管理方式中设置快表的作用">页式存储管理方式中设置快表的作用</h3><p>快表，又称联想寄存器(TLB)，时一种访问速度比内存快很多的高速缓存，用来存放最近访问过的页表项的副本，若快表命中，则只要访问一次高速缓存以及一次主存即可，这样就可以加速地址变换的速度，从而提高了查找的速度和指令执行效率</p><h3 id="什么是页表和快表有什么作用">什么是页表和快表，有什么作用？</h3><p>页表指出逻辑地址中的页号与所占主存块号的对应关系。</p><p>作用：页式存储管理在用动态重定位方式装入作业时，要利用页表做地址转换工作。快表就是存放在高速缓冲存储器的部分页表。它起页表相同的作用。由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表， 有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><h3 id="地址翻译的过程">地址翻译的过程？</h3><blockquote><p>TLB-&gt;页表（TLB不命中）-&gt;Cache-&gt;主存（Cache不命中）-&gt;外存</p></blockquote><h2 id="虚拟内存">3、虚拟内存</h2><h3 id="内存空间的扩充">内存空间的扩充</h3><ul><li><p>覆盖</p></li><li><p>交换</p></li></ul><ol type="1"><li><p>覆盖技术： 把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位，把程序执行时并不要 求同时 装入内存的覆盖组成一组，成为覆盖段，这个覆盖段分配到同一个存储区域，这个存储区 域成为覆盖区，它与覆盖段一一对应。覆盖段的大小由覆盖段中最大的覆盖来确定。（为了解决 内存容量太小的问题，打破了必须将一个程序全部信息装入内存后才能运行的限制）</p></li><li><p>交换技术： 把暂时不用的某个程序及数据部分从内存移到外存中去，以便腾出必要的内存空间；或者把指定 的程序或数据从外存读到相应的内存中，并将控制权交给他，让其在系统上运行的一种内存扩充 技术。处理器的中级调度就是采用交换技术。</p></li><li><p>区别：</p></li></ol><p>① 与覆盖技术相比，交换技术不要求程序员给出的 程序段之间的覆盖结构；</p><p>② 交换技术主要在进程和作业之间进行，覆盖技术主要在同一个进程或作业中进行；</p><p>③ 覆盖技术只能覆盖于覆盖程序段无关的程序段，交换进程由换出和换入两个过程组成。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901033503721.png" alt="image-20200901033503721" /><figcaption>image-20200901033503721</figcaption></figure><h3 id="虚拟内存的特征">虚拟内存的特征</h3><ul><li><p><strong>离散性</strong>：程序在内存中离散存储</p></li><li><p><strong>多次性</strong>：一个作业可以分成多次调入内存</p></li><li><p><strong>对换性</strong>：又称交换性，指作业在运行过程中可以换入换出</p></li><li><p><strong>虚拟性</strong>：从逻辑上扩充内存容量，用户可以使用的空间远大于实际内存容量</p></li></ul><h3 id="局部性原理">局部性原理</h3><ul><li><p>时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问，都集中在一个较短的时期内</p></li><li><p>空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的数据，都集中在一个较小的区域内</p></li></ul><h3 id="页面置换算法决定应该换入换出哪页">页面置换算法（决定应该换入/换出哪页）</h3><p>进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲时间时，就需要从内存中调入一页程序或数据，送入磁盘的对换区。</p><p>选择调出页面的算法就成为页面置换算法。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829211857819.png" alt="image-20200829211857819" /><figcaption>image-20200829211857819</figcaption></figure><h4 id="最佳opt置换算法">1. 最佳（OPT）置换算法</h4><p>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。 于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 即被淘汰页面是以后永不使用或最长时间内不再访问的页面。（往后看）</p><h4 id="先进先出fifo置换算法">2. 先进先出（FIFO）置换算法</h4><p>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存 时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被 使用的可能性最大。 即优先淘汰最早进入内存的页面。（往前看）</p><h4 id="最近最久未使用lru算法">3. 最近最久未使用（LRU）算法</h4><p>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推 测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访 问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的 页面予以淘汰。 即淘汰最近最长时间未访问过的页面。（往前看）</p><h4 id="时钟clock置换算法">4. 时钟(CLOCK)置换算法</h4><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。 所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是 CLOCK算法的变体。</p><p>该算法为每个页面设置一位访问位，将内存中的所有页面通过指针链成一个循环队列。由于该算法<strong>只有一位访问位</strong>，只能用它表示该页是否已经使用过，而置换时是将最近未使用过的页面换出去，所以把该算法称为最近未用算法。 <strong>选择页置换的过程</strong>： 1.当某页被访问时，其访问位置“1”； 2.在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页； 3.在循环队列中检查下一个页面，直到访问到访问位为“0”的页面为止。</p><p>由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。</p><h3 id="抖动现象">抖动现象</h3><p>刚刚换出的页面，过后不久又要访问，并且调入不久后又被调出，如此反复，使得系统把大部分的时间用在了页面的调入调出上，而几乎不能有效的工作</p><h1 id="第四章-文件管理">第四章 文件管理</h1><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200829211145794.png" alt="image-20200829211145794" /><figcaption>image-20200829211145794</figcaption></figure><h2 id="文件系统基础">1、文件系统基础</h2><h3 id="文件的定义">文件的定义</h3><p>文件是具有文件名的一组相关元素的集合，在文件系统中是一个最大的数据单位，它描述了一个对象集，每个文件都有一个文件名，用户通过文件名来访问文件</p><h3 id="文件的组成结构">文件的组成结构</h3><p>数据项，文件系统中最低级的数据组织形式，包括基本数据项(<code>用于描述一个对象是的某种特性的一个值</code>)和组合数据项(<code>由多个数据项组合而成</code>)</p><p>记录，是指一组相关的数据项的集合，用于描述一个对象在某一方面的属性</p><p>文件，是指由创建者所定义的一组相关数据的集合，逻辑上可分为有结构文件和无结构文件</p><h3 id="文件的属性">文件的属性</h3><blockquote><p>名称。文件名唯一，以容易读取的形式保存</p><p>标识符。系统内文件的唯一标签，对用户透明</p><p>文件类型。被支持不同类型的文件系统使用</p><p>文件位置。指向文件的指针</p><p>文件的大小，建立时间，用户标识</p></blockquote><h3 id="文件的逻辑结构顺序文件索引文件和索引顺序文件">文件的逻辑结构：顺序文件、索引文件和索引顺序文件</h3><p>3种有结构文件：</p><ul><li><p>顺序文件：定长记录的顺序文件，若物理上采用顺序存储则可以实现随机存取，若再能保证记录的顺序结构，则可实现快速检索，但因为文件存储要求连续的存储空间，所以会产生碎片，同时也不利于文件的动态扩充</p></li><li><p>索引文件：可以进行随机访问，易于文件的增删，但索引表的使用增加了存储空间的开销，并且索引表的查找策略对文件系统的影响很大</p></li><li><p>索引顺序文件：大大提高了了顺序存取速度，但仍需配置一个索引表，增加了存储开销</p></li></ul><p>FAT: 文件配置表file allocation table: 分配给文件的所有盘块号都放在该表中，记录了文件所在位置。</p><p>文件系统：负责管理和存储文件信息的软件机构，由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性</p><p>文件系统类型： Windows中有FAT32，NTFS，Linus中有ext2,ext3,ext4</p><h3 id="目录结构">目录结构</h3><p>【目录的功能】</p><blockquote><p>实现按名存取</p><p>提高检索速度</p><p>允许文件同名</p><p>允许文件共享</p></blockquote><h4 id="区分文件目录目录文件">区分文件目录，目录文件</h4><ul><li><p>文件目录：又称文件控制块，存储的是文件的管理信息，控制对象是单个文件；</p><ul><li><p>文件控制块FCB</p><p>文件控制块是用于保存文件属性信息的数据结构，至少包含以下信息：文件名，文件的结构（有结构的记录式文件or无格式的流式文件），文件的物理位置，存取控制信息，管理信息</p></li></ul></li><li><p>目录文件：存储的是若干个文件目录，控制对象是整个文件系统；</p><ul><li>目前广泛采用的树形目录结构，优点是：允许文件重命名，实现了文件分类。</li></ul></li></ul><p>【索引结点】</p><blockquote><p>FCB的改进，把除了文件名之外的其他文件描述信息都放到<code>索引结点（i结点）</code>，文件目录中的每个目录项仅由文件名和指向该文件i节点的指针构成；</p><p>存放在磁盘上的使用节点称为<code>磁盘索引节点</code>，每个文件都有唯一的磁盘索引节点，主要包括以下内容：文件主标识符，文件类型，文件存取权限，文件物理地址，文件长度，文件链接计数，文件存取时间；</p><p>存放在内存中的索引节点称为<code>内存索引节点</code>，主要包括以下内容：索引节点编号，状态，访问计数，逻辑设备号，链接指针</p></blockquote><p>【文件的目录结构】</p><blockquote><p>单级目录结构，在整个文件系统中只建立一张目录表，每个文件占据其中的一个表目，易于实现，管理简单，但不允许文件重名，文件查找速度慢</p><p>二级目录结构，将文件目录分为主文件目录和用户文件目录，允许文件重名，可获得较高的查找速度，但缺乏灵活性，用户不能对自己的文件进行分类</p><p>多级目录结构，又称树形目录结构，，使用路径名来唯一标识文件，便于对文件分类，层次结构清晰，能更有效的进行文件的管理与保护，但查找文件时需按照路径名逐级访问中间节点，增加了磁盘访问次数，进而影响了查询速度</p><p>无环图目录结构，实现了文件的共享，但使得系统的管理变得复杂</p></blockquote><p>（4）文件的访问类型及访问控制</p><p>【访问类型】</p><blockquote><p>读，写，执行，添加，删除，列表清单</p></blockquote><p>【访问控制】</p><blockquote><p>对不同的用户访问同一个文件采取不同的访问类型，访问控制通常有四种方法：</p><p>访问控制矩阵，访问控制表和用户权限表都是采用某种数据结构来记录用户或用户组对每个文件的操作权限，而口令和密码是另一种访问控制方法，口令直接存储在系统内部，不够安全，密码方法的保密性强，节省存储空间，但编码和译码要花费一定时间</p></blockquote><h2 id="文件系统实现">2、文件系统实现</h2><p>（1）文件系统层次结构</p><p>【文件的层次结构】</p><blockquote><p>用户接口</p><p>文件目录系统</p><p>存取控制验证</p><p>逻辑文件系统与文件信息缓冲区</p><p>物理文件系统</p></blockquote><p>（2）目录实现</p><p>【目录的实现】</p><blockquote><p>线性表</p><p>散列表</p></blockquote><p>（3）文件实现</p><p>【外存分配方式】</p><blockquote><p>静态分配：在文件建立时一次性分配所需的全部空间</p><p>动态分配：根据动态增长的文件长度进行分配</p></blockquote><p>【连续分配】</p><blockquote><p>最简单的磁盘空间分配策略，为文件分配连续的磁盘区域，保证了逻辑文件中的记录顺序与存储器中文件占用盘块顺序一致；优点是查找速度快（只需起始块号和文件大小），目录中关于文件物理存储位置的信息也比较简单，缺点是不方便文件拓展，容易产生碎片，需要定期进行存储空间的紧缩</p></blockquote><p>【链接分配】</p><blockquote><p>分为隐式链接和显式链接。</p><p>隐式链接（默认）：目录项中有指向索引顺序文件的第一块盘块和最后一块盘块的指针，此外每个盘块中都含有指向下一个盘块的指针；缺点是不支持随机访问，访问效率低下，并且由于其中任何一个盘块的指针错误都会导致后面的盘块的位置丢失；另外，指向下一个盘块的指针也需要耗费少量的存储空间；优点是方便文件拓展，不会有碎片问题，外存利用率高</p><p>显式链接：把用于链接文件各物理块的指针显式地存放在一张表中，称为文件分配表(FAT)，一个磁盘仅设置一张FAT并且在开机时就将其读入内存且常驻内存；优点是既支持顺序访问，又支持随机访问，块号转换过程无需访问磁盘，因此访问速度较快；缺点是FAT需要占用一定的存储空间</p></blockquote><p>【索引分配】</p><blockquote><p>系统为每个文件分配一个索引块，索引块中存放索引表，索引表的每个表项对应分配给该文件的一个物理块；优点是支持随机访问，无外部碎片，便于文件拓展，缺点是访存次数增加导致文件的存取速度降低（可以通过提前将索引表调入内存来解决），索引表本身需占用一定的存储空间</p></blockquote><p>【文件的存储空间管理】</p><blockquote><p>空闲文件表 空闲块链表 位示图，保存在主存中</p><p>成组链接法(UNIX的文件存储空间管理方法)，适用于大型文件系统</p></blockquote><h2 id="磁盘组织与管理">3、磁盘组织与管理</h2><p>（1）磁盘的结构</p><blockquote><p>引导控制块</p><p>分区控制块</p><p>目录结构</p><p>文件控制块</p></blockquote><h3 id="磁盘调度算法有哪些">磁盘调度算法有哪些？</h3><h4 id="先来先服务算法fcfsfirst-come-first-service">1. 先来先服务算法（FCFS）First Come First Service</h4><p>这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优 点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满 足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低 设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较 小。</p><h4 id="最短寻道时间优先算法sstf-shortest-seek-time-first">2. 最短寻道时间优先算法（SSTF） Shortest Seek Time First</h4><p>该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时 间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的 服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况 下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。</p><h4 id="扫描算法scan电梯调度">3. 扫描算法（SCAN）电梯调度</h4><p>扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例 如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当 前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换 向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁 道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称 为电梯调度算法。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间 变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但 由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。</p><h4 id="循环扫描算法cscan">4. 循环扫描算法（CSCAN）</h4><p>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一 端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一 端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定 磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里 的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。</p><h1 id="第五章-输入输出管理">第五章 输入输出管理</h1><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901094051834.png" alt="image-20200901094051834" /><figcaption>image-20200901094051834</figcaption></figure><p><strong>设备管理的主要任务就是控制设备和内存或处理及之间的数据传送。</strong></p><p>外设和内存之间的io控制方式有四种：</p><h2 id="io控制方式有哪些">I/O控制方式有哪些？</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20200901094752112.png" alt="image-20200901094752112" /><figcaption>image-20200901094752112</figcaption></figure><h3 id="程序-io-方式">1. 程序 I/O 方式</h3><p>早期的计算机系统中， 没有中断系统，所以CPU和I/O设备进行通信，传输数据时CPU速度远快于 I/O设备，于是CPU需要不断测试I/O设备，看其是否完成了传输。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111433996.png" alt="image-20201006111433996" style="zoom:80%;" /></p><h3 id="中断驱动方式">2. 中断驱动方式</h3><p>当某进程要启动某个 I/O 设备工作时，便由 CPU 向相应的设备控制器发出一条 I/O 命令，然后立 即返回继续执行原来的任务。仅当输完一个数据时，才需 CPU 花费极短的时间去做些中断处理。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111522762.png" alt="image-20201006111522762" style="zoom:80%;" /></p><h3 id="dma方式直接存储器访问">3. DMA方式（直接存储器访问）</h3><p>在中断驱动方式中，io设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度还是受限，而DMA（直接存储器存取）的思想是：在I/O设备和内存之间开辟直接的数据交换通路，彻底”解放“CPU。</p><p>通过在I/O设备和内存之间开启一个可以直接传输数据的通路，采用DMA控制器来控制一个数据块 的传输，CPU只需在一个数据块传输开始阶段设置好传输所需的控制信息，并在传输结束阶段做 进一步处理。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111541455.png" alt="image-20201006111541455" /><figcaption>image-20201006111541455</figcaption></figure><h4 id="dma控制方式与中断驱动方式的主要区别">DMA控制方式与中断驱动方式的主要区别：</h4><ul><li><p>主要区别是，中断驱动方式在每个数据需要传输时中断CPU，而DMA控制方式则是在所要求的传送的一批数据完成传送结束后才中断CPU。</p></li><li><p>中断驱动方式的数据传送，在中断处理时由CPU控制，而DMA控制方式是在DMA控制器的控制下完成的。</p></li></ul><h3 id="io通道控制方式">4. I/O通道控制方式</h3><p>通道，独立于 CPU 的专门负责输入输出控制的处理机，它控制设备与内存直接进行数据交换。有自己的通道指令，这些指令由 CPU 启动，并在操作结束时向 CPU 发出中断信号。</p><p>直接程序控制方式和中断程序控制方式适合于低速设备的数据传送，而 DMA 方式虽然适合于高速设备的数据传送，但一个 DMA 控制器只能控制少量的同类设备，这远远不能满足大型计算机系统的需要。通常，一个大型计算机需要连接大量的高速和低速设备，通道控制方式可以满足这个要求。</p><h4 id="io通道与一般处理机的区别">I/O通道与一般处理机的区别：</h4><p>通道指令单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说 通道与CPU共享内存。</p><h4 id="io通道与dma控制方式的区别">I/O通道与DMA控制方式的区别：</h4><ul><li><p>DMA方式需要CPU来控制传输的数据块大小，传输的内存位置，而通道方式中这些信息是由通道控制的。</p></li><li><p>每个DMA控制对应一台设备与内存传递数据，而一个通道可以龙之多台设备与内训的数据交换。</p></li></ul><h2 id="spooling技术">Spooling技术？</h2><p>虚拟性是OS的四大特性之一。如果说可以通过多道程序技术将一台物理CPU虚拟为多台逻辑 CPU，从而允许多个用户共享一台主机，那么，通过SPOOling技术便可将一台物理I/O设备虚拟 为多台逻辑I/O设备，同样允许多个用户共享一台物理I/O设备。</p><p>SPOOLing技术是对脱机输入、输出系统的模拟。相应地，SPOOLing系统必须建立在具有多道程 序功能的操作系统上，而且还应有高速随机外存的支持，这通常是采用磁盘存储技术。</p><p>SPOOLing系统主要有以下三部分：</p><p>（1）输入井和输出井。这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设 备，用于暂存I/Q设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数 据。</p><p>（2）输入缓冲区和输出缓冲区。为了缓和和CPU和磁盘之间速度不匹配的矛盾，在内存中要开辟 两个缓冲区；输入缓冲区和输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传 送到输入井。输出缓冲区用与暂存从输出井送来的数据，以后在传送给输出设备。</p><p>（3）输入进程SPi 和输入进程SP0。这里利用两个进程来模拟脱机I/O时的外围控制机。其中，进 程SPi模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井， 当CPU需要输入数据时，直接从输入井读入内存；进程SP0模拟脱机输出时的外围控制机，把用户 要求输出的数据从先内存送到输出井，待输出设备空闲时，在将输出井中的数据经过输出缓冲区 送到输出设备上。</p><h3 id="spooling技术的特点">SPOOLing技术的特点：</h3><p>(1)提高了I/O速度。从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作，如同脱机操作 一样，提高了I/O速度，缓和了CPU与低速I/O设备速度不匹配的矛盾。</p><p>(2)将独占设备改造为共享设备。因为在SPOOLing系统的系统中，实际上并没为任何进程分配设 备，而知识在输入井或输出井中为进程分配一个存储区和建立一张I/O请求表。这样，便把独占设 备改造为共享设备。</p><p>(3)实现了虚拟设备功能。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这 一设备，从而实现了设备的虚拟分配。不过，该设备是逻辑上的设备。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2020/10/05/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2020/10/05/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和">前缀和</h1><h2 id="一维前缀和计算区域内的和">一维前缀和（计算区域内的和 ）</h2><h3 id="思路">思路</h3><ul><li><p>作用：能快速求出原数组中一段区间的数字和。</p></li><li><p>计算公式：计算 <span class="math inline">\([l, r]\)</span> 区间和前缀和 <code>S[r] - S[l - 1]</code></p></li><li><p><code>a[l] + ... + a[r] = S[r] - S[l - 1]</code></p><p>如何推导？ <span class="math display">\[S_r = a_1 + a_2 + .... +  a_{l-1} + a_l + ... + a_r\]</span></p><p><span class="math display">\[S_{l-1} = a_1 + a_2 + .... + a_{l-1}\]</span></p><p><span class="math inline">\((1) - (2)\)</span> 得： <span class="math display">\[S_r - S_{l-1} = a_l + .... + a_r\]</span></p></li><li><p>为什么下标要从 <span class="math inline">\(1\)</span> 开始？</p><p>比如 <span class="math inline">\([1, 10] =&gt;\)</span> <span class="math inline">\(S_{10} - S_{0} = S_{10}\)</span> ，这样可以统一处理所有情况。</p></li></ul><h3 id="注意">注意</h3><p><strong>差分操作和前缀和一样数组下标都从1开始。</strong></p><h3 id="code">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> a[N],S[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) S[i] = S[i - <span class="hljs-number">1</span>] + a[i]; <span class="hljs-comment">// 前缀和的初始化</span><br><br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;    <br>        <span class="hljs-keyword">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,S[r] - S[l<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// 区间和的计算</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="例题">例题</h3><h4 id="acwing-795.-前缀和">1、<a href="https://www.acwing.com/problem/content/description/797/">AcWing 795. 前缀和</a></h4><blockquote><p>模板题</p></blockquote><h2 id="二维前缀和">二维前缀和</h2><h3 id="思路-1">思路</h3><ul><li><span class="math inline">\(S [i, j]\)</span> = 第i行j列格子左上部分所有元素的和</li></ul><ol type="1"><li><p><strong>如何计算前缀和矩阵？</strong></p><p><strong>容斥原理：</strong> <span class="math display">\[S_{x,y} = S_{x-1,y} +  S_{x,y-1} - S_{x-1,y-1} + a_{x,y}\]</span> <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/前缀和与差分/image-20201005210359578.png" alt="image-20201005210359578" style="zoom:80%;" /></p></li><li><p><strong>如何利用前缀和矩阵，计算某一子矩阵的和？</strong></p></li></ol><ul><li><p>以 <span class="math inline">\((x1, y1)\)</span> 为左上角，<span class="math inline">\((x2, y2)\)</span> 为右下角的子矩阵的和为：</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/前缀和与差分/image-20201005210336024.png" alt="image-20201005210336024" /><figcaption>image-20201005210336024</figcaption></figure></li></ul><h3 id="code-1">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">int</span> a[N][N], S[N][N];<br><span class="hljs-keyword">int</span> n, m, q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            S[i][j] += S[i - <span class="hljs-number">1</span>][j] + S[i][j - <span class="hljs-number">1</span>] - S[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br>            <br>    <span class="hljs-keyword">while</span>(q -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x1, x2, y1, y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, S[x2][y2] - S[x2][y1 - <span class="hljs-number">1</span>] - S[x1 - <span class="hljs-number">1</span>][y2] + S[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="差分">差分</h1><h2 id="一维差分">一维差分</h2><h3 id="思路-2">思路</h3><p><strong>差分是前缀和的逆运算。</strong></p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/前缀和与差分/image-20201005210457677.png" alt="image-20201005210457677" /><figcaption>image-20201005210457677</figcaption></figure><p><span class="math inline">\(b[i]\)</span> 是差分数组， <span class="math inline">\(a[i]\)</span> 是原数组，其实原数组 相当于 前缀和数组，所以 <span class="math inline">\(a[i]\)</span> 我用 <span class="math inline">\(S[i]\)</span> 代替，即 <span class="math inline">\(S[i]\)</span> 是前缀和数组。</p><p>拥有数组 <span class="math inline">\(b[n]\)</span> 后，想要对 <span class="math inline">\(S[n]\)</span> 中所有的数据加上 <span class="math inline">\(c\)</span> ,只需要将 <span class="math inline">\(b[1]+c\)</span> 即可，因为 <span class="math inline">\(S[n]\)</span> 是 <span class="math inline">\(a[n]\)</span>的前缀和，<span class="math inline">\(S[i]=b[1]+b[2]+b[3]+……+b[n]\)</span> 。<span class="math inline">\(b[1]\)</span> 是所有的 <span class="math inline">\(S[i]\)</span> 都拥有的子元素，将<span class="math inline">\(b[1]+c\)</span>，那么 <span class="math inline">\(a[n]\)</span> 中所有的数据都会加上 <span class="math inline">\(c\)</span> 。如果想将 <span class="math inline">\(S[n]\)</span> 中 <span class="math inline">\([l,r]\)</span> 部分的数据全部加上c，只需要将 <span class="math inline">\(b[l]+c\)</span> ,然后 <span class="math inline">\(b[r+1]-c\)</span> 即可。</p><h3 id="注意-1">注意</h3><p><strong>差分操作和前缀和一样数组下标都从1开始。</strong> <span class="math inline">\(b[l]+c\)</span> 后，<span class="math inline">\(l\)</span> 后面的数组都会加 <span class="math inline">\(c\)</span> 。<span class="math inline">\(r\)</span> 后面的数据也会被改变，要改回来就得 <span class="math inline">\(b[r+1]-c\)</span></p><h3 id="code-2">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> b[N];  <span class="hljs-comment">// 差分数组</span><br><span class="hljs-keyword">int</span> S[N];  <span class="hljs-comment">// 原数组</span><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-comment">// 1. 输入原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; S[i];  <br>    <br>    <span class="hljs-comment">// 2. 构造差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) b[i] = S[i] - S[i - <span class="hljs-number">1</span>]; <br>    <br>    <span class="hljs-comment">// 3. 求</span><br>    <span class="hljs-keyword">while</span>(m --)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l, r, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;<br>        <br>        b[l] += c;      <span class="hljs-comment">// 将l和以后+c</span><br>        b[r + <span class="hljs-number">1</span>] -= c;  <span class="hljs-comment">// 将r之后-c(r + 1 和以后)</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        b[i] = b[i - <span class="hljs-number">1</span>] + b[i];<br>        <span class="hljs-built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="差分矩阵">差分矩阵</h2><h3 id="思路-3">思路</h3><p>有些难理解...</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/前缀和与差分/image-20201005210540990.png" alt="image-20201005210540990" /><figcaption>image-20201005210540990</figcaption></figure><h3 id="code-3">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">int</span> S[N][N];  <span class="hljs-comment">// 前缀和数组</span><br><span class="hljs-keyword">int</span> b[N][N];  <span class="hljs-comment">// 差分数组</span><br><br><span class="hljs-keyword">int</span> n, m, q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <br>    <span class="hljs-comment">// 1. 输入原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-built_in">cin</span> &gt;&gt; S[i][j];<br>            <br>    <span class="hljs-comment">// 2. 构造差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>        &#123;<br>            b[i][j] += S[i][j];<br>            b[i + <span class="hljs-number">1</span>][j] -= S[i][j];<br>            b[i][j + <span class="hljs-number">1</span>] -= S[i][j];<br>            b[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] += S[i][j];<br>        &#125;<br>    <br>    <span class="hljs-comment">// 3. 求</span><br>    <span class="hljs-keyword">while</span>(q -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x1, y1, x2, y2, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;<br>        <br>        b[x1][y1] += c;<br>        b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>        b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>        b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 差分数组求前缀和才变回原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>        &#123;<br>            b[i][j] += b[i - <span class="hljs-number">1</span>][j] + b[i][j - <span class="hljs-number">1</span>] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">cout</span> &lt;&lt; b[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>        <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2020/10/04/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2020/10/04/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度">高精度</h1><h2 id="高精度加法">高精度加法</h2><ul><li><strong>C = A + B, A &gt;= 0, B &gt;= 0</strong></li></ul><h3 id="思路">思路</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/高精度/image-20201004231525570.png" alt="image-20201004231525570" /><figcaption>image-20201004231525570</figcaption></figure><h3 id="注意">注意</h3><p>将数字倒序读入，注意数组里的存放位置是 <code>size()-1</code> ~ <code>0</code>，范围一定不要写错。</p><h3 id="code">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.size() &lt; B.size()) <span class="hljs-keyword">return</span> add(B, A);<br><br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C;<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span>(i &lt; B.size()) t += B[i];<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.push_back(t);<br>    <span class="hljs-keyword">return</span> C;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a, b;      <span class="hljs-comment">//按字符串形式输入123456</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, B;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;                      <span class="hljs-comment">//按照 ‘6’‘5’‘4’‘3’‘2’‘1’压栈</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) B.push_back(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = add(A, B);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="例题">例题</h3><h4 id="acwing-791.-高精度加法">1、<a href="https://www.acwing.com/problem/content/793/">AcWing 791. 高精度加法</a></h4><blockquote><p>模板题</p></blockquote><h2 id="高精度减法">高精度减法</h2><ul><li><strong>C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</strong></li></ul><h3 id="注意-1">注意</h3><p>一定要模拟好样例，并且多举几个例子。比如<strong>多余的前导0问题</strong>就要处理。</p><h3 id="code-1">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">//判断是否有 A &gt;= B</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.size() != B.size()) <span class="hljs-keyword">return</span> A.size() &gt; B.size();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )&#123;<br>        <span class="hljs-keyword">if</span> (A[i] != B[i]) <br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.size()) t = t - B[i];<br>        <br>        C.push_back((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();  <span class="hljs-comment">// 除去首部多余的0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a, b;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, B;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) B.push_back(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);   <br>    <br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <br>    <span class="hljs-keyword">if</span>(cmp(A, B)) C = sub(A, B);<br>    <span class="hljs-keyword">else</span>&#123;<br>        C = sub(B, A);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>     <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题-1">例题</h3><h4 id="acwing-791.-高精度加法-1">1、<a href="https://www.acwing.com/problem/content/793/">AcWing 791. 高精度加法</a></h4><blockquote><p>模板题</p></blockquote><h2 id="高精度乘法">高精度乘法</h2><ul><li><strong>C = A <span class="math inline">\(*\)</span> b, A &gt;= 0, b &gt; 0</strong>，这里的高精乘是指<strong>高精度乘以低精度</strong>。</li></ul><h3 id="注意-2">注意</h3><p>一定要模拟好样例，并且多举几个例子。比如<strong>多余的前导0问题</strong>就要处理。</p><h3 id="code-2">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t += A[i] * b;<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        <br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(t) C.push_back(t);<br>    <br>    <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();  <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, C;<br>    <span class="hljs-built_in">string</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-keyword">if</span>( b == <span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;0&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <br><br>        C = mul (A, b);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )  <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="例题-2">例题</h3><h4 id="acwing-793.-高精度乘法">1、<a href="https://www.acwing.com/problem/content/795/">AcWing 793. 高精度乘法</a></h4><blockquote><p>模板题</p></blockquote><h4 id="a从wing-1500.-趣味数字">2、<a href="https://www.acwing.com/problem/content/description/1502/">A从Wing 1500. 趣味数字</a></h4><h5 id="小知识点">小知识点</h5><ol type="1"><li><p>int : <span class="math inline">\(2^{31} - 1\)</span> 约为 <span class="math inline">\(2 * 10^{9}\)</span></p></li><li><p>long long : <span class="math inline">\(2^{63} - 1\)</span> 约为 <span class="math inline">\(9 * 10^{18}\)</span></p></li><li><p>高精加！可以先复习一下 <a href="https://www.acwing.com/problem/content/793/">高精加模板题</a></p></li><li><p>高精乘！可以先复习一下 <a href="https://www.acwing.com/problem/content/795/">高精乘模板题</a></p></li></ol><h5 id="小分析">小分析</h5><p>给一个数字加倍， <code>A * 2</code>可以当作是 <code>A + A</code>,题中输入数字不超过20位，如果写成longlong 也会爆掉，所以还是得写成字符串形式。两个大数相加，这时，便想到了我们的 高精加！2333</p><p>(其实高精乘也可以hh，高精乘是高精度乘以低精度)</p><h5 id="小步骤">小步骤</h5><ol type="1"><li><p>按字符串形式 输入</p></li><li><p>将乘法转为加法</p></li><li><p>将原数按要求和结果比较</p><ul><li><p>那么如何判断：加倍以后得到的数字是否可以由原数字的各数位重新排列得到 呢？</p><p>答：可以将两个结果排序，都是vector型的，<strong>vector 类型支持字典序比较</strong>！相同就可以呗。</p></li></ul></li></ol><h5 id="错误历程">错误历程</h5><p>最开始写高精加模板时，忘记给<code>int t = 0</code>了，结果怎么都算不对hh气死了</p><p>后来忘记给原来的数字排序了，怎么输出都不对hh，看来还是得先想明白过程再写！</p><p><strong>捋清思路先~</strong></p><h5 id="code-3">code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;  <span class="hljs-comment">//记得初始化</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ ) <br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.size()) t += B[i];<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.push_back(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = add(A, A);<br><br>    <span class="hljs-keyword">auto</span> CC = C;  <span class="hljs-comment">// 把结果先复制出来</span><br><br>    <span class="hljs-comment">// 得对两个都排序！</span><br>    sort(CC.begin(), CC.end());<br>    sort(A.begin(), A.end());<br><br>    <span class="hljs-keyword">if</span> (CC == A) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但其实用高精乘也可以吧hhh，高精乘是高精度乘以低精度。 高精乘 和 高精加差不多hh</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mul</span> <span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t += A[i] * b;<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(t) C.push_back(t);     <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = mul(A, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">auto</span> CC = C;  <span class="hljs-comment">// 把结果先复制出来</span><br><br>    <span class="hljs-comment">// 得对两个都排序！</span><br>    sort(CC.begin(), CC.end());<br>    sort(A.begin(), A.end());<br><br>    <span class="hljs-keyword">if</span> (CC == A) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="高精度除法">高精度除法</h2><ul><li><strong>A / b = C ... r, A &gt;= 0, b &gt; 0</strong></li></ul><h3 id="注意-3">注意</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/高精度/image-20201004231448128.png" alt="image-20201004231448128" /><figcaption>image-20201004231448128</figcaption></figure><p>一定要捋清思路，输入时是倒过来存入数组的，但除法算的时候其实是正着算的，所以还要再倒过来遍历，也就是 <code>for (int i = A.size() - 1; i &gt;= 0; i -- )</code> ，因为同样结果也是倒着输出的，所以这里应该把正着的结果倒过来，再倒过来输出就是正着的结果。记得同样<strong>存在前导0问题</strong>。</p><h3 id="code-4">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> +A[i];<br>        C.push_back( r / b);<br>        r %= b;<br>    &#125;<br>    <br>    reverse(C.begin(),C.end());<br>    <span class="hljs-keyword">while</span>( C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    <span class="hljs-keyword">int</span> r;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C = div(A, b, r);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="例题-3">例题</h3><h4 id="acwing-794.-高精度除法">1、<a href="https://www.acwing.com/problem/content/796/">AcWing 794. 高精度除法</a></h4><blockquote><p>模板题。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2020/10/03/%E4%BA%8C%E5%88%86/"/>
    <url>/2020/10/03/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找">二分查找</h1><h2 id="思路">思路</h2><p><strong>二分关键词：“最大值最小”，“最小值最大”，“平均值最大/最小”</strong></p><blockquote><p>一个题目，如果一个区间具有单调性质，那么一定可以二分，但是如果说这道题目没有单调性质，而是具有某种区间性质的话，我们同样可以使用二分.<strong>（二段性）</strong></p><p>就是：<strong>如果有单调性，一定可以二分。</strong></p><p>但是可以二分的题目，不一定有单调性。也就是说，没有单调性的题目也可以二分</p><p>二段性：满足一段而不满足另一段，两段连上！</p></blockquote><ol type="1"><li>确定一个区间，使得目标一定在区间中。</li><li>找一个性质，满足：<ol type="1"><li>性质具有二段性（答案是性质的边界）所有二分都成立</li><li>答案是二段性的分界点</li></ol></li></ol><ul><li><strong>一定要好好分析 <code>check()</code> 函数</strong></li></ul><h2 id="整数二分">整数二分</h2><h3 id="思路-1">思路</h3><p>在一个范围内,查找一个数字,要求找到这个元素的起始位置和结束位置,请注意这个范围内的数字都是单调递增的,即具有单调性质.</p><h3 id="code">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 一定要加1</span><br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="例题">例题</h3><h4 id="acwing-789.-数的范围">1、<a href="https://www.acwing.com/problem/content/description/791/">Acwing 789. 数的范围</a></h4><blockquote><p>模板题</p></blockquote><h5 id="思路-2">思路</h5><p>需要写两个二分，一个需要找到 &gt;=x 的第一个数，另一个需要找到 &lt;=x 的最后一个数</p><ol type="1"><li><p><strong>查找大于等于x的第一个位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br><span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br><span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>查找小于等于x的第一个位置（查找大于等于x的最后一个位置）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br><span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 一定要加1！</span><br><span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>为什么这里一定要 <strong>加 1</strong> 呢？</p><p>答：因为如果按照上一个二分的写法，循环判断条件还是l &lt; r,当只有两个元素比如“2 2”时，l指向第一个元素，r指向第二个元素，mid指向第一个元素即 mid = l，q[mid] &lt;= x，l = mid还是指向第一个元素，指针不移动了，陷入死循环了，此刻l + 1 == r，未能退出循环。</p></li><li><p>为什么查找大于等于x的第一个位置不会死循环？</p><p>因为这时就算只有两个元素，l + 1 = r，mid = l，q[mid] &lt; x 时 l 是会+1的，不小于 x 时r = mid也会缩小区间。而查找小于等于x的第一个位置之所以会死循环是因为编程语言里面除以2的下取整性，试想下如果l + 1 = r时， mid = r 呢，q[mid] &lt;= x，l = mid = r，区间缩小；否则r = mid - 1 = l 区间缩小，l都会与r相遇。就不会死循环。</p></li><li><p>那如何做到上取整呢？</p><p>只需要取mid时在l + r后面再加1即可，这里l和r都是闭区间，所以当a[mid] &gt; x时，r = mid - 1.</p></li></ul></li></ol><h5 id="code-1">code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> q[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        <br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 找左端点，即: 大于等于x的第一个位置</span><br>        <span class="hljs-keyword">while</span>(l &lt; r)<br>        &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (q[l] != x) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-1 -1&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            r = n - <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-comment">// 找右端点，即: 小于等于x的第一个位置</span><br>            <span class="hljs-keyword">while</span>(l &lt; r)<br>            &#123;<br>                <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span>&gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <br>            <span class="hljs-built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><h3 id="思路-3">思路</h3><ul><li><p>将区间 <code>[l, r]</code> 划分成 <code>[l, mid]</code> 和 <code>[mid, r]</code></p></li><li><p>当区间长度足够小时就停止。一般是多2位！</p><blockquote><p>比如题目要求小数点后六位，你就写 <code>while(r - l &gt; 1e-8)</code></p></blockquote></li></ul><h3 id="code-2">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l, <span class="hljs-keyword">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> ((r - l) &gt; eps)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="例题-1">例题</h3><h4 id="acwing-790.-数的三次方根">1、<a href="https://www.acwing.com/problem/content/792/">AcWing 790. 数的三次方根</a></h4><blockquote><p>模板题</p></blockquote><h5 id="code-3">code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>    <br>    <span class="hljs-keyword">double</span> l = <span class="hljs-number">-10000</span>, r = <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-keyword">while</span> ((r - l) &gt; <span class="hljs-number">1e-8</span>)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid * mid &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在stl中的二分查找">在stl中的二分查找</h2><p><code>lower_bound( )</code> 和 <code>upper_bound( )</code>都是利用二分查找的方法在一个<u>排好序的数组中</u>进行查找的。</p><p>在从小到大的排序数组中，</p><p><strong>lower_bound( begin,end,num)</strong>：从数组的begin位置到end-1位置二分查找<strong>第一个<u>大于或等于</u>num的数字，找到返回该数字的地址</strong>，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><strong>upper_bound( begin,end,num)</strong>：从数组的begin位置到end-1位置二分查找<strong>第一个<u>大于</u>num的数字，找到返回该数字的地址，</strong>不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>AC 67. 数字在排序数组中出现的次数</p>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2020/10/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/10/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><h2 id="思路">思路</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/归并排序/image-20201002121328404.png" alt="image-20201002121328404" /><figcaption>image-20201002121328404</figcaption></figure><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/归并排序/image-20201002120409804.png" alt="image-20201002120409804" /><figcaption>image-20201002120409804</figcaption></figure><ol start="0" type="1"><li><strong>注意递归要退出！记得写退出条件！</strong></li><li>将区间一分为二：<code>int mid = l + r &gt;&gt; 1 ;</code></li><li>递归排序 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code></li><li>归并：将左右两个有序序列 合并成一个有序序列</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_sort(q, l, mid);          <span class="hljs-comment">// 递归排序左右边</span><br>    merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// k是当前tmp数组里有多少数</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br>    &#125;<br><br>    <span class="hljs-comment">// 左半边或右半边可能没有循环完，只要拿过来放入就行</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-comment">// 结果存入tmp里面去了，得拿回来</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="例题">例题</h2><h3 id="acwing-787.-归并排序">1、<a href="https://www.acwing.com/problem/content/789/">AcWing 787. 归并排序</a></h3><blockquote><p>模板题</p></blockquote><h3 id="acwing-788.-逆序对的数量">2、<a href="https://www.acwing.com/problem/content/790/">AcWing 788. 逆序对的数量</a></h3><h4 id="题目">题目</h4><p>给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</p><p><strong>样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><h4 id="思路-1">思路</h4><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/归并排序/image-20201003094921152.png" alt="image-20201003094921152" /><figcaption>image-20201003094921152</figcaption></figure><h4 id="注意">注意</h4><ol type="1"><li>注意结果数据范围会爆int，所以 <code>res</code> 和 <code>merge_sort()</code> 要用 <code>long long</code> 数据类型。</li><li><code>res</code> 要累加啊！！！</li></ol><h4 id="code">code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N], tmp[N];<br><br><span class="hljs-function">LL <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    LL res = merge_sort(q, l, mid) + merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tmp[k ++ ] = q[j ++ ];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>, i = l; i &lt;= r; i ++ , k ++ ) q[i] = tmp[k];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; merge_sort(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acwing-107.-超快速排序">3、<a href="https://www.acwing.com/problem/content/description/109/">AcWing 107. 超快速排序</a></h3><h4 id="题目-1">题目</h4><p>在这个问题中，您必须分析特定的排序算法----超快速排序。</p><p>该算法通过交换两个相邻的序列元素来处理n个不同整数的序列，直到序列按升序排序。</p><p>对于输入序列<code>9 1 0 5 4</code>，超快速排序生成输出<code>0 1 4 5 9</code>。</p><p>您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。</p><p><strong>输入格式</strong></p><p>输入包括一些测试用例。</p><p>每个测试用例的第一行输入整数n，代表该用例中输入序列的长度。</p><p>接下来n行每行输入一个整数 <span class="math inline">\(a_i\)</span> ,代表用例中输入序列的具体数据，第i行的数据代表序列中第i个数。</p><p>当输入用例中包含的输入序列长度为0时，输入终止，该序列无需处理。</p><p><strong>输出格式</strong></p><p>对于每个需要处理的输入序列，输出一个整数op，代表对给定输入序列进行排序所需的最小交换操作数，每个整数占一行。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(0≤N&lt;5000000,\)</span></p><p><span class="math inline">\(0≤a_i≤9999999990\)</span></p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br>9<br>1<br>0<br>5<br>4<br>3<br>1<br>2<br>3<br>0<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br>0<br></code></pre></td></tr></table></figure><h4 id="思路-2">思路</h4><p>一、<strong>最少交换多少次</strong>，其实就是求<strong>逆序对的数量</strong>，所以转换到了<strong>归并排序</strong>。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/归并排序/image-20201003232550206.png" alt="image-20201003232550206" /><figcaption>image-20201003232550206</figcaption></figure><ol type="1"><li><p>左右两个区域的逆序对不会受影响。</p></li><li><p>左边与 <span class="math inline">\(a_i\)</span>，右边与 <span class="math inline">\(a_{i+1}\)</span> ，在逆序对交换后也不会受影响。以左边为例， <span class="math inline">\(a_i &gt; a_{i+1}\)</span> ，在这个逆序对交换后，只是逆序对数量<span class="math inline">\(- 1\)</span>。因为：</p><ol type="1"><li>若 <span class="math inline">\(A &gt; a_{i+1}\)</span> ，逆序对交换后依旧是 <span class="math inline">\(A &gt; a_{i+1}\)</span> 。</li><li>若 <span class="math inline">\(A &lt; a_{i+1}\)</span> ，逆序对交换后依旧是 <span class="math inline">\(A &lt; a_{i+1}\)</span> 。</li></ol><p>右边同理。</p><p>综上，逆序对的交换，只是会使逆序对的数量<span class="math inline">\(- 1\)</span>。不会对其他逆序对造成影响。</p></li></ol><p>二、将整个序列变成升序，等同于 逆序对数量为0。</p><p>假设有<span class="math inline">\(k\)</span>个逆序对，变为0，也就是要操作<span class="math inline">\(k\)</span>次。就是求逆序对的数量，包装了一下~</p><h4 id="code-1">code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br>LL q[N], tmp[N];<br><br><span class="hljs-function">LL <span class="hljs-title">merge_sort</span><span class="hljs-params">(LL q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <br>    LL res = merge_sort(q, l, mid) + merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            tmp[k ++ ] =q[j ++ ] ;<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k ++ ] =q[i ++ ];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">for</span> (i = l, k = <span class="hljs-number">0</span>; i &lt;= r ; i ++ , k ++ ) q[i] = tmp[k]; <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n), n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, merge_sort(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络课堂笔记总结</title>
    <link href="/2020/09/30/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/09/30/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络知识点总结">计算机网络知识点总结</h1><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200815124453263.png" alt="IMG_2219(20200815-125837)" /><figcaption>IMG_2219(20200815-125837)</figcaption></figure><h2 id="一计算机网络的定义">一、计算机网络的定义</h2><ul><li>定义：计算机网络就是一些互连的，自治的计算机系统的集合。</li><li>功能：<ol type="1"><li><strong>数据通信</strong>：计算机网络<code>最基本</code>和<code>最重要</code>的功能，包括连接控制、传输控制、差错控制、流量控制、路由选择、多路复用等子功能；</li><li><strong>资源共享</strong>：包括数据资源、软件资源以及硬件资源；</li><li><strong>分布式处理</strong>：当计算机网络中某个计算机系统负载过重时，可以将其处理的任务传送给网络中的其他计算机系统进行处理，利用空闲计算机资源提高整个系统的利用率；</li><li><strong>信息综合处理</strong>：将分散在各地计算机中的数据资料进行集中处理或分级处理；</li><li><strong>负载均衡</strong>：将工作任务均衡地分配给计算机网络中的各台计算机；</li><li><strong>提高可靠性</strong>：计算机网络中的各台计算机可以通过网络互为替代机。</li></ol></li></ul><h2 id="二计算机网络的分类">二、计算机网络的分类</h2><p>(1)按分布范围分类：广域网、城域网、局域网、个人区域网； (2)按拓扑结构分类：星形网络、总线型网络、环形网络、网状型网络； (3)按传输技术分类：广播式网络、点对点网络； (4)按使用者分类：公用网、专用网； (5)按数据交换技术分类：电路交换网络、报文交换网络、分组交换网络；</p><h2 id="三介绍一下五层协议">三、介绍一下五层协议</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/IMG_2219(20200815-125837).PNG" alt="IMG_2219(20200815-125837)" /><figcaption>IMG_2219(20200815-125837)</figcaption></figure><h2 id="四说一说osi七层模型">四、说一说OSI七层模型</h2><p>其中表示层和会话层用途如下：</p><ul><li><p>表示层 ：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。</p></li><li><p>会话层 ：建立及管理会话。</p></li></ul><p>其余五层同五层协议。</p><h2 id="五说一说tcpip四层模型">五、说一说TCP/IP四层模型</h2><p>TCP/IP参考模型分为四个层次：应用层、传输层、网络互连层和网络接口层。</p><p>1、主机到网络层　　</p><p>​ 实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。　　</p><p>2、网络互连层　　</p><p>　　网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。　　</p><p>3、传输层　　</p><p>　　在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。　　</p><p>4、应用层　　</p><p>​ TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现，为特定应用程序提供数据传输服务。</p><h2 id="六端到端通信和点到点通信的区别">六、端到端通信和点到点通信的区别？</h2><p>从本质上说，由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到 点的服务， 而传输层为网络中的主机提供端到端的通信。</p><ul><li>直接相连的结点之间的通信称为点到点通信， 它只提供一台机器到另一台机器之间的通信， 不涉及程序或进程的概念。同时，点到点通信并不能保证数据传输的可靠性，也不能说明源主机 与目的主机之间是哪两个进程在通信，这些工作都是由传输层来完成的。</li><li>端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是比点到 点通信更高一级的通信方式，以完成应用程序（进程） 之间的通信。”端” 是指用户程序的端口， 端口号标识了应用层中不同的进程。</li></ul><h1 id="第六章-应用层">第六章 应用层</h1><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200530163458793.png" alt="image-20200530163458793" /><figcaption>image-20200530163458793</figcaption></figure><h2 id="一网络应用模型">一、网络应用模型</h2><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710160145030.png" alt="image-20200710160145030"  /></p><table><thead><tr class="header"><th style="text-align: left;">客户机（client）</th><th style="text-align: left;">服务器（server）</th><th style="text-align: left;">P2P</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">1. 服务请求方</td><td style="text-align: left;">1. 服务提供方</td><td style="text-align: left;">1. 既client又server</td></tr><tr class="even"><td style="text-align: left;">2. 不是一直在线的</td><td style="text-align: left;">2. 是一直在线的（always-on host）</td><td style="text-align: left;">2. 不是一直在线的</td></tr><tr class="odd"><td style="text-align: left;">3. 动态IP地址</td><td style="text-align: left;">3. 固定IP地址</td><td style="text-align: left;">3. 动态IP地址</td></tr><tr class="even"><td style="text-align: left;">4. 客户机间接性接入</td><td style="text-align: left;"></td><td style="text-align: left;">4. 间接性接入</td></tr><tr class="odd"><td style="text-align: left;">5. 客户机之间不能相连</td><td style="text-align: left;"></td><td style="text-align: left;">5. 之间可以直接相连</td></tr><tr class="even"><td style="text-align: left;">6. 可扩展性差。</td><td style="text-align: left;"></td><td style="text-align: left;">6. 可扩展性好。</td></tr><tr class="odd"><td style="text-align: left;">（受网络带宽和服务器硬件限制）</td><td style="text-align: left;">（服务器支持的客户机数有限）</td><td style="text-align: left;"></td></tr></tbody></table><h2 id="二域名系统dns">二、域名系统DNS</h2><h3 id="介绍一下域名系统">1、介绍一下域名系统</h3><ul><li><p><strong>DNS 是一个基于C/S的分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。</strong>这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p></li><li><p><strong>运行在UDP上，端口号：53</strong></p></li></ul><h3 id="域名服务器与层次域名空间">2、域名服务器与层次域名空间</h3><ul><li>本地服务器不属于域名服务器层次结构</li></ul><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710163447364.png" alt="image-20200710163447364" style="zoom:80%;" /></p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710164611776.png" alt="image-20200710164611776" style="zoom: 50%;" /></p><h3 id="dns域名解析协议解析过程">3、DNS域名解析协议，解析过程</h3><ul><li><strong>域名解析是指把域名映射成为IP 地址或把IP 地址映射成域名的过程。</strong>前者称为正向解析，后者称 为反向解析。当客户端需要域名解析时，通过本机的DNS 客户端构造一个DNS 请求报文，以<strong>UDP</strong> 数据报方式发往本地域名服务器。域名解析有两种方式：<u>递归查询</u> 和 <u>递归与迭代相结合</u> 的查询</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710163843009.png" alt="image-20200710163843009" /><figcaption>image-20200710163843009</figcaption></figure><h2 id="三文件传输协议ftp">三、文件传输协议FTP</h2><h3 id="控制连接-与-数据连接">1、控制连接 与 数据连接</h3><ul><li>控制连接<ul><li>端口号：21；</li><li>控制连接用来传输控制信息；<strong>7 位 ASCII码格式</strong></li><li>整个会话期间一直保持打开状态</li></ul></li><li>数据连接<ul><li>端口号：20；</li><li>数据连接用来连接client与server的数据传送进程，数据传送进程实际完成文件的传送，传送完<strong>关闭连接</strong></li></ul></li><li><p>==FTP工作步骤：==</p><ul><li><p><em>打开端口号为21的控制连接端口（控制连接：persitent），等待客户端能够连接</em></p></li><li><p>客户端发出请求，通过控制连接发送给服务器端的控制进程，并在整个会话期间一直保持打开，但是控制连接不用来传输文件</p></li><li><p>服务器在收到客户进程的文件传输请求时，会创建数据传送进程和数据连接，</p><p>数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成对数据的传送。</p></li><li><p>传送完毕后，关闭数据连接（non-persistent）。</p></li></ul></li><li><p>为什么设计两条链接？</p><p>因为使用两条独立的连接可使得FTP变得更简单，更容易实现，更有效率。同时在文件传输过程中，还可以利用控制连接控制传输过程，比如：客户可以请求中止，暂停传输等。</p></li></ul><h2 id="四电子邮件">四、电子邮件</h2><h3 id="电子邮件的组成结构">1、电子邮件的组成结构</h3><ul><li><strong>邮件代理（user agent），邮件服务器，电子邮件使用的协议</strong></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710215957643.png" alt="image-20200710215957643" /><figcaption>image-20200710215957643</figcaption></figure><ul><li><strong>电子邮件的收发过程：</strong><ol type="1"><li>发送方调用用户代理上撰写要发送的邮件。邮件代理用SMTP把邮件发送到发送端邮件服务器</li><li>发送端邮件服务器将邮件在邮件缓存队列中等待发送</li><li>运行在发送方邮件服务器的<strong>SMTP客户进程</strong>，发现邮件缓存里有待发送的邮件，向 运行在接收端邮件服务器的<strong>SMTP服务器进程</strong>发起 <strong>请求建立TCP连接</strong> 的请求。</li><li><strong>建立TCP连接后，SMTP客户进程发送邮件给SMTP服务器进程。发送过后，SMTP关闭TCP连接。</strong></li><li>SMTP服务器进程 收到邮件后，放入收件人的用户信箱</li><li>接受方收取邮件时，调用用户代理，使用POP3（IMAP）将邮件取回。</li></ol></li></ul><h3 id="smtpmime邮件读取协议pop3imap">2、SMTP，MIME；邮件读取协议：POP3、IMAP；</h3><ul><li><strong>SMTP协议：“push协议”</strong></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710231807637.png" alt="image-20200710231807637" /><figcaption>image-20200710231807637</figcaption></figure><ul><li><strong>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型</strong></li></ul><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200710231734814.png" alt="image-20200710231734814" style="zoom:50%;" /></p><ul><li><strong>POP3：“pull协议”</strong></li></ul><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200710231652740.png" alt="image-20200710231652740" style="zoom:50%;" /></p><ul><li><strong>IMAP</strong><ul><li>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。<strong>IMAP 服务器维护了会话期间用户的状态信息。</strong></li></ul></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710231626211.png" alt="image-20200710231626211" /><figcaption>image-20200710231626211</figcaption></figure><h3 id="电子邮件格式">3、电子邮件格式</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710230632107.png" alt="image-20200710230632107" /><figcaption>image-20200710230632107</figcaption></figure><h2 id="五万维网">五、万维网</h2><h3 id="www的概念与组成结构">1、WWW的概念与组成结构</h3><ul><li>万维网 WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的信息储藏所。是一个资料空间，在这个空间中：一样有用的事物叫做“资源”，并由URL（统一资源定位符）表示；通过HTTP传送给使用者，使用者单击链接来获取资源。</li><li>“链接”：万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li><strong>万维网的内核部分有三个标准构成：URL，HTTP，HTML</strong></li></ul><h3 id="url">2、URL</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200711073216041.png" alt="image-20200711073216041" /><figcaption>image-20200711073216041</figcaption></figure><h3 id="http">3、HTTP</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200711082317004.png" alt="image-20200711082317004" /><figcaption>image-20200711082317004</figcaption></figure><h3 id="http连接方式">4、HTTP连接方式</h3><p>HTTP既可以使用持久连接，也可以使用非持久连接。</p><ul><li><strong>非持久连接</strong></li></ul><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200730090528749.png" alt="image-20200730090528749"  /></p><ul><li><strong>持久连接</strong></li></ul><p><strong>持久连接</strong>：是指万维网服务器在发送响应之后，仍然保留这条连接，是同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求与响应报文。</p><p><strong>非流水线方式</strong>：客户在收到前一个响应之后，才能发出下一个请求</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200730090651069.png" alt="image-20200730090651069" /><figcaption>image-20200730090651069</figcaption></figure><h3 id="简述http中get和post的区别">5、简述HTTP中GET和POST的区别</h3><blockquote><p>？？？</p><ul><li><p>GET参数通过URL传递，POST放在Request body中。</p></li><li>GET比POST相对来说！更不安全，因为参数直接暴露在URL上</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包。<ul><li>GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）</li><li>POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li></ul></li></ul></blockquote><h4 id="get-和-post-是什么">5.1 GET 和 POST 是什么？</h4><blockquote><p>GET 和 POST 其实都是 HTTP 的请求方法。除了这 2 个请求方法之外，HTTP 还有 <strong>HEAD、PUT、DELETE、TRACE、CONNECT、OPTIONS</strong> 这 6 个请求方法。</p></blockquote><blockquote><p>GET：请求指定的页面信息，并返回实体主体。</p><p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p></blockquote><h4 id="get-和-post-的特点">5.2 GET 和 POST 的特点？</h4><h4 id="get">GET</h4><ul><li>GET 用于信息获取，而且应该是安全和幂等的 。</li></ul><blockquote><p><strong>安全性</strong>指的是非修改信息，即该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用，也就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p><p><strong>幂等性</strong> (Idempotence) 则指的是无论调用这个URL 多少次，都不会有不同的结果的 HTTP 方法。而在实际过程中，这个规定没有那么严格。例如在一个新闻应用中，新闻站点的头版不断更新，虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。</p></blockquote><ul><li>GET 方法只产生一个 TCP 数据包，浏览器会把请求头和请求数据一并发送出去，服务器响应 200 ok(返回数据)。</li></ul><h4 id="post">POST</h4><ul><li>POST请求方式是既不幂等又不安全。</li></ul><p>首先<u>POST请求方式往数据库中提交数据的，因此会改变数据库中的数据。</u>其次，POST请求方式每次获得的结果都有可能不一样，因为POST请求是作用在上一级的URL上的，则每一次请求都会添加一份新资源（这也是POST和PUT方式的最大区别，PUT方式是幂等的）。</p><blockquote><p>幂等性的定义：对数据库的一次操作和多次操作获得的结果是一致的，则认为符合幂等性。</p><p>安全性的定义：对数据库的操作没有改变数据库中的数据，则认为符合安全性</p></blockquote><ul><li>POST 方法会产生两个 TCP 数据包，浏览器会先将请求头发送给服务器，待服务器响应100 continue，浏览器再发送请求数据，服务器响应200 ok(返回数据)。这么看起来 GET 请求的传输会比 POST 快上一些（因为GET 方法只发送一个 TCP 数据包），但是实际上在网络良好的情况下它们的传输速度基本相同。</li></ul><h4 id="get-和-post-的区别">5.3 GET 和 POST 的区别？</h4><p>本质是一样的，并无区别！！！</p><p>GET 和 POST 是什么？它们是 HTTP 请求协议的请求方法，而 HTTP 又是基于TCP/IP的关于数据如何在万维网中如何通信的协议，<strong>所以 GET/POST 实际上都是 TCP 链接</strong>。</p><p><strong>既然 GET 和 POST 的底层都是 TCP，那么为什么 HTTP 还要特别将它们区分出来呢？</strong></p><p>其实可以想象一下，如果我们直接使用 TCP 进行数据的传输，那么无论是单纯获取资源的请求还是修改服务器资源的请求在外观上看起来都是 TCP 链接，这样就非常不利于进行管理。所以在 HTTP 协议中，就会对这些不同的请求设置不同的类别进行管理，例如单纯获取资源的请求就规定为 GET、修改服务器资源的请求就规定为 POST，并且也对它们的请求报文的格式做出了相应的要求（例如请求参数 GET 位于 URL 而 POST 则位于请求数据中）。</p><p>对于 GET 和 POST 的区别，总结来说就是：<strong>它们的本质都是 TCP 链接，并无区别。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同。</strong></p><h3 id="http与https区别">6、HTTP与HTTPS区别</h3><table><thead><tr class="header"><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr class="odd"><td>http是超文本传输协议，信息是明文传输</td><td>https则是具有安全性的ssl加密传输协议</td></tr><tr class="even"><td>http的连接很简单，是无状态的</td><td>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</td></tr><tr class="odd"><td></td><td>https协议需要到ca申请证书</td></tr><tr class="even"><td>端口号80</td><td>端口号443</td></tr></tbody></table><h1 id="第五章-传输层">第五章 传输层</h1><h2 id="一传输层的功能">一、传输层的功能？</h2><ol type="1"><li><p>提供<strong>应用进程</strong>间的逻辑通信。（网络层是提供主机间的逻辑通信）</p></li><li>复用和分用。<ul><li>复用：<strong>发送方</strong>不同的应用进程都可使用同一个传输层协议传输数据</li><li>分用：<strong>接收方</strong>的传输层<u>在剥去报文段的首部</u>后能够将这些数据正确的交付给目的应用进程</li></ul></li><li>对收到的报文的首部和数据部分进行差错检测(网络层只检查IP 数据报首部)；</li><li><p>提供两种不同的协议：TCP &amp; UDP</p></li></ol><h2 id="二udp">二、UDP</h2><p>UDP是User Datagram Protocol的简称，中文名是用户数据报协议</p><ul><li><p><strong>UDP应用：</strong>DNS、SNMP（简单网络管理协议）、TFTP（小文件传输协议）、RTP（实时协议）</p></li><li><p><strong>特点</strong></p></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200731231921197.png" alt="image-20200731231921197" /><figcaption>image-20200731231921197</figcaption></figure><ul><li><strong>UDP是面向数据报的传输</strong>，发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，既不合并也不拆分，而是保留这些报文的边界。接收方UDP对IP层交上来UDP数据报，在去除首部之后原封不动上交给上层应用进程</li></ul><h3 id="udp校验和计算">1、UDP校验和计算</h3><ul><li>UDP的校验和检查首部和数据部分。使用<u>二进制反码</u>运算求和再取反。</li><li><strong>伪首部包含IP首部一些字段</strong>。其目的是让UDP两次检查数据是否已经正确到达目的地，只是单纯为了做校验用的。</li><li>步骤：<ul><li>发送方首先添加伪首部。然后把UDP数据报视为许多16位的字连接起来。</li><li>按二进制反码计算出这些16位字的和，并将此和的二进制反码写入检验位和字段。</li><li>接收方把收到的UDP数据报加上伪首部后，把所有16位的字相加，如果遇到进位，则将高于16字节的进位部分的值加到最低位上（wrap around回卷，就是循环加法）。计算这些16位字的和。</li><li>将所有字相加得到的结果应该为一个16位的数，将该数取反则可以得到检验和checksum</li><li>当无差错时其结果全为1，否则有差错出现，接收方就应该丢弃这个UDP数据报。</li></ul></li><li>这种简单的差错检验方法的检测能力不强，但是好处是简单、处理速度快</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200731224105668.png" alt="image-20200731224105668" /><figcaption>image-20200731224105668</figcaption></figure><h2 id="三tcp">三、TCP</h2><ul><li><strong>特点</strong></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200731231947938.png" alt="image-20200731231947938" /><figcaption>image-20200731231947938</figcaption></figure><ul><li><strong>TCP是面向字节流的传输</strong>：即TCP传送时是逐个字节传送的，所以TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段发送的数据的第一个字节的序号。</li></ul><h2 id="四tcp和udp的区别">四、TCP和UDP的区别</h2><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><p>1）<strong>TCP提供面向连接的传输</strong>，必须先建立连接，管理连接，释放连接；UDP<strong>提供无连接的传输</strong>，无需建立连接，就不会引入建立连接的时延。</p><p>2）<strong>TCP提供可靠的传输（有序，无差错，不丢失，不重复）；UDP提供不可靠的传输，尽最大努力交付。</strong></p><p>3）<strong>TCP是面向字节流的传输</strong>，因此它能将信息分割成组，并在接收端将其重组；<strong>UDP是面向数据报的传输</strong>，发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，既不合并也不拆分，而是保留这些报文的边界。接收方UDP对IP层交上来UDP数据报，在去除首部之后原封不动上交给上层应用进程</p><p>4）<strong>TCP提供拥塞控制和流量控制机制</strong>；<strong>UDP不提供拥塞控制和流量控制机制。</strong></p><p>5）<strong>TCP只能是点对点的（一对一）</strong>。<strong>UDP支持一对一、一对多、多对一和多对多的交互通信。</strong></p><p>6）<strong>TCP首部20B。UDP首部8B。</strong></p><ul><li><strong>TCP应用：</strong></li><li><strong>UDP应用：</strong>DNS、SNMP（简单网络管理协议）、TFTP（小文件传输协议）、RTP（实时协议）</li></ul><h3 id="tcp连接管理">1、TCP连接管理</h3><p>TCP是面向连接的协议，因此每隔TCP连接都有三个阶段：连接建立、数据传送和连接释放</p><h4 id="连接建立三次握手">1）连接建立：三次握手</h4><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200720215725358.png" alt="image-20200720215725358" /><figcaption>image-20200720215725358</figcaption></figure><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p><p>1、第一步：源主机A的TCP向主机B发出连接请求报文段，其首部中的SYN(同步)标志位应置为1，表示想与目标主机B进行通信，并发送一个同步序列号X(例：SEQ=100)进行同步，表明在后面传送数据时的第一个数据字节的序号是X＋1（即101）。SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。</p><p>2、第二步：目标主机B的TCP收到连接请求报文段后，如同意，则发回确认。在确认报中应将ACK位和SYN位置1，表示客户端的请求被接受。确认号应为X＋1(即为101)，同时也为自己选择一个序号Y。</p><p>3、第三步：源主机A的TCP收到目标主机B的确认后要向目标主机B给出确认，其ACK置1，确认号为Y＋1，而自己的序号为X＋1。（TCP的标准规定，SYN置1的报文段要消耗掉一个序号。）</p><p>​ 运行客户进程的源主机A的TCP通知上层应用进程，连接已经建立。当源主机A向目标主机B发送第一个数据报文段时，其序号仍为X＋1，因为前一个确认报文段并不消耗序号。</p><p>　　当运行服务进程的目标主机B的TCP收到源主机A的确认后，也通知其上层应用进程，连接已经建立。至此建立了一个全双工的连接。</p><blockquote><p>ACK：确认位。TCP规定在连接建立后所有传送的报文段都得把ACK置为1。(ACK = 1:有效)</p><p>ack：确认号。期望收到下一个报文段的第一个字节的序号。</p></blockquote><h4 id="数据传输">2）数据传输</h4><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200801095645291.png" alt="image-20200801095645291" /><figcaption>image-20200801095645291</figcaption></figure><h4 id="连接释放四次挥手">3）连接释放：四次挥手</h4><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200801001922740.png" alt="image-20200801001922740" /><figcaption>image-20200801001922740</figcaption></figure><p>1、第一步：客户机打算关闭连接时，向其TCP 发送一个连接释放报文段，并停止发送数据，主动关 闭TCP 连接，该报文段的FIN 标志位被置1, seq= u, 它等于前面已传送过的数据的后一个字节的 序号加1 (FIN 报文段即使不携带数据，也要消耗一个序号）。TCP 是全双工的，即可以想象为一 条TCP 连接上有两条数据通路。发送FIN 报文时，发送FIN 的一端不能再发送数据，即关闭了其中 一条数据通路，但对方还可以发送数据。 2、第二步：服务器收到连接释放报文段后即发出确认，确认号是ack = u + 1, 而这个报文段自己的序 号是V, 等于它前面已传送过的数据的后一个字节的序号加1 。此时，从客户机到服务器这个方 向的连接就释放了， TCP 连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服 务器到客户机这个方向的连接并未关闭。 3、第三步：若服务器已经没有要向客户机发送的数据，就通知TCP 释放连接，此时其发出FIN= 1 的 连接释放报文段。 4、第四步：客户机收到连接释放报文段后，必须发出确认。在确认报文段中， ACK 字段被置为1, 确 认号ack= w + 1, 序号seq= u + 1 。此时TCP 连接还未释放，必须经过时间等待计时器设置的时间 2MSL 后， A 才进入连接关闭状态。</p><h3 id="为什么不采用两次握手建立连接">2、为什么不采用“两次握手”建立连接？</h3><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好，确认彼此的收发能力)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><ul><li>关于这个序列号，为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 <u>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</u></li><li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li></ul><h3 id="为什么不采用三次握手释放连接">3、为什么不采用“三次握手“释放连接？</h3><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p><p>但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h3 id="为什么发送最后一次握手报文后要等待2msl最大报文段生存时间的时间呢">4、为什么发送最后一次握手报文后要等待2MSL(最大报文段生存时间)的时间呢？</h3><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h2 id="五拥塞控制的四种算法">五、拥塞控制的四种算法</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200801095616550.png" alt="image-20200801095616550" /><figcaption>image-20200801095616550</figcaption></figure><ol type="1"><li>慢开始算法</li></ol><p>刚开始设置拥塞窗口为1，每收到对一个新的报文段的确认，拥塞窗口加1，这样子逐步增大发送方的拥塞窗口从而使得分组注入网络的速率更加合理。（1-》2-》4-》8）</p><ol start="2" type="1"><li>拥塞避免算法</li></ol><p>发送端的拥塞窗口每经过一个往返时延RTT就增加一个最大报文段长度的大小，通常表现为按线性规律增长。（cwnd++）</p><blockquote><p>在慢开始和拥塞避免算法中使用了“乘法减小”和“加法增大”方法。</p><p>“乘法减小”就是不论在慢开始阶段还是拥塞避免阶段，只要发生超时（很可能出现了网络拥塞），就把阈值设为当前拥塞窗口值的一半。</p><p>“加法增大”是指执行拥塞避免后，在收到所有报文段的确认后，把拥塞窗口增加1，让拥塞窗口缓慢增加，以过早的防止网络出现拥塞。</p></blockquote><ol start="3" type="1"><li>快重传算法（3次冗余ACK）</li></ol><p>首先要求接收方每收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到3个重复确认就应当立即重传对方尚未收到的报文段。</p><ol start="4" type="1"><li>快恢复算法</li></ol><p>当<strong>发送端收到连续的3个重复的ACK</strong>时，就<strong>重新设置慢开始门限值为拥塞窗口的一半</strong>，同时<strong>将拥塞窗口设为新的慢开始门限值</strong>。若发送窗口值还允许发送报文段，<strong>就按拥塞避免算法继续发送报文段</strong>。</p><h2 id="六拥塞控制与流量控制的区别">六、拥塞控制与流量控制的区别</h2><p>拥塞控制的作用是确保子网能够承载所达到的流量，这是一个全局性的过程，设几个方面的行为：主机、路由器以及路由器内部的转发处理过程等。单一地增加资源并不能解决拥塞。</p><p>流量控制与拥塞控制的区别：</p><ul><li>流量控制往往是指在发送端和接收端之间的点对点通信的控制。流量控制所做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li>拥塞控制必须确保子网能够传送待传送的数据，是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。</li></ul><h1 id="第四章-网络层">第四章 网络层</h1><h2 id="一网络层功能">一、网络层功能？</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200805163758191.png" alt="image-20200805163758191" /><figcaption>image-20200805163758191</figcaption></figure><ol type="1"><li><strong>异构网络互联</strong></li></ol><p>网络互联，是指两个以上的计算机网络，通过一定的方法，用一种或多种通信设备/中间设备相互连接起来，以构成更大的网络系统。</p><ol start="2" type="1"><li><p><strong>路由与转发</strong></p><ul><li>路由：根据路由算法确定一个进来的分组应该被传送到哪一条输出线路上</li><li>转发：路由器根据转发表将用户的IP数据报从合适的端口发送出去</li></ul></li><li><p><strong>拥塞控制</strong></p><ul><li><p>开环控制：设计网络时事先将有关发生拥塞的因素考虑到，力求在网络工作时不产生拥塞。这是静态的预防方法</p></li><li><p>闭环控制：事先不考虑有关发生拥塞的各种因素，采用监测网络去监视，即时检测哪里发生了拥塞，然后将拥塞信息传到合适的地方，来调整网络系统的运行，并解决出项的问题。闭环控制是基于反馈环路的概念，是一种动态的方法。</p></li></ul></li></ol><h2 id="二数据交换方式">二、数据交换方式</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200805230405872.png" alt="image-20200805230405872" /><figcaption>image-20200805230405872</figcaption></figure><ol type="1"><li><strong>电路交换（circuit switching）</strong></li></ol><ul><li><p>电路交换：在发送方和接收方之间通过<u>多台交换机</u>建立一条连接(电路circuit)；</p></li><li><p>建立连接 -&gt; 通信 -&gt; 释放</p></li><li><p>电路交换网络中，端系统间通信会话期间，预留了端系统间通信沿路径所需要的资源（缓存、链路传输速率）</p></li></ul><ol start="2" type="1"><li><strong>报文交换（meassge switching）</strong></li></ol><ul><li><p><strong>存储转发；</strong></p></li><li>报文交换方式的数据传输单位是报文，报文就是站点一次性要发送的数据块，其长度不限且可变。当一个站要发送报文时，它将一个目的地址附加到报文上，网络节点根据报文上的目的地址信息，把报文发送到下一个节点，一直逐个节点地转送到目的节点。</li><li><p>每个节点在收到整个报文并检查无误后，就暂存这个报文，然后利用路由信息找出下一个节点的地址，再把整个报文传送给下一个节点。因此，端与端之间无需先通过呼叫建立连接。</p></li></ul><ol start="3" type="1"><li><p><strong>分组交换（packet switching）</strong></p><p>分组交换是报文交换的一种改进，它将报文分成若干个分组，每个分组的长度有一个上限，有限长度的分组使得每个节点所需的存储能力降低了，分组可以存储到内存中，提高了交换速度。它适用于交互式通信，如终端与主机通信。</p></li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200805233942970.png" alt="image-20200805233942970" /><figcaption>image-20200805233942970</figcaption></figure><h2 id="三ipv4">三、IPv4</h2><h3 id="ip数据报">1、IP数据报</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200805234515982.png" alt="image-20200805234515982" /><figcaption>image-20200805234515982</figcaption></figure><h3 id="ipv4地址分类">2、IPv4地址分类</h3><ul><li>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200806114557796.png" alt="image-20200806114557796" /><figcaption>image-20200806114557796</figcaption></figure><blockquote><p><strong>A类地址</strong>：网络号8位，规定第一位是0，可指派的网络数为<span class="math inline">\(2^7-2\)</span>，因为其中网络地址全0的地址是个保留地址，意思是“本网络”，网络号01111111用于本地软件环回测试。后面3B（24位）代表主机号，主机号全0代表该网络，全1代表广播地址，最大主机数为<span class="math inline">\(2^{24}-2\)</span>。 <strong>B类地址</strong>：网络号为16位，规定前两位是10（因此网络地址不可能出现全0），网络地址128.0.0.0不指派，所以可指派的网络数为<span class="math inline">\(2^{14}-1\)</span>。主机号也为16位，同样，每一个网络上的最大主机数为<span class="math inline">\(2^{16}-2\)</span>。 <strong>C类地址</strong>：网络号为24位，规定前3位为110（因此网络地址不可能出现全0），网络地址192.0.0.0不指派，所以可指派的网络数为<span class="math inline">\(2^{21}-1\)</span>。主机号为8位，同样，每一个网络上的最大主机数为<span class="math inline">\(2^{8}-2\)</span>。</p></blockquote><ul><li>特殊IP</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20201008084615794.png" alt="image-20201008084615794" /><figcaption>image-20201008084615794</figcaption></figure><h3 id="网络地址转换nat">3、网络地址转换NAT</h3><ul><li>用于实现<u>专用网的主机和因特网的主机的通信</u>。</li><li>NAT可以将专用网内部使用的本地IP地址转换成有效的外部全球IP地址，使得这个专用网只需要1个全球IP地址就可以与因特网连通。</li><li>使用NAT技术，需要在专用网连接到因特网的路由器上安装NAT软件(NAT 路由器)。 NAT技术可大大节省IP地址的消耗，它至少有一个有效的外部全球IP地址，但并没有知己IP地址的个数。</li></ul><h3 id="子网划分">4、子网划分</h3><ul><li><p>两级IP地址的缺点：IP地址空间的利用率低；给每一个物理网络分配一个网络号会是路由表变得太大而使网络性能变坏；两级IP地址不够灵活</p></li><li><strong>子网划分：</strong>将两级IP地址变为三级IP地址，从主机号借用若干个比特作为子网号，而主机号也就相应减少了若干比特，网络号不变。注意子网号不能使用全0和全1.</li><li><p><strong>子网掩码：</strong>子网掩码与IP地址一样，是二进制表示也是由0和1组成，连续的1表示网络地址，连续的0表示主机地址，只有网络地址相同的主机在同一个子网，才能直接通信</p></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200806135152272.png" alt="image-20200806135152272" /><figcaption>image-20200806135152272</figcaption></figure><ul><li>使用IP地址和子网掩码计算网段和广播地址 ：<ul><li><strong>IP地址</strong>和<strong>子网掩码</strong>进行<strong>与</strong>运算，结果是<strong>网络地址</strong>（即主机号全0是网络地址）</li><li>将运算结果中的网络地址不变，主机地址变为1，结果就是广播地址</li></ul></li></ul><blockquote><p>默认子网掩码：A：255.0.0.0 B：255.255.0.0 C：255.255.255.0</p></blockquote><h3 id="无类别域间路由classless-inter-domain-routing">5、无类别域间路由（Classless Inter-Domain Routing）</h3><ul><li>它消除了传统的A类、B类和C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间。</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200806141424352.png" alt="image-20200806141424352" /><figcaption>image-20200806141424352</figcaption></figure><blockquote><p>将网络前缀（整个网络号字段）都相同的连续的IP地址组成“CIDR地址块”，一个CIDR地址块可以表示很多地址，这种地址的聚合称为<code>路由聚合</code>，也称<code>构成超网</code>。</p></blockquote><h3 id="各种情况下路由表表项的结构">6、各种情况下路由表表项的结构</h3><ul><li>没划分子网前的路由表：目的网络地址、下一跳地址；</li><li>划分子网后的路由表：目的网络地址、子网掩码、下一跳地址；</li><li>使用CIDR后的路由表：网络前缀、下一跳地址。</li></ul><h2 id="四ip相关协议">四、IP相关协议</h2><h3 id="地址解析协议arp网络层协议">1、地址解析协议ARP（网络层协议）</h3><ul><li>在每个主机中都有一个ARP高速缓存，里面存放的是所在局域网上的各主机和路由器的IP地址到硬件地址的映射表，ARP的职责就是动态的维护该表。</li><li>ARP请求分组是广播发送的，但ARP响应分组是普通的单播。</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200806150729758.png" alt="image-20200806150729758" /><figcaption>image-20200806150729758</figcaption></figure><ul><li>同一网络</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200806163646772.png" alt="image-20200806163646772" /><figcaption>image-20200806163646772</figcaption></figure><ul><li>另一网络</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200806163749164.png" alt="image-20200806163749164" /><figcaption>image-20200806163749164</figcaption></figure><h3 id="动态主机配置协议dhcp应用层协议">2、动态主机配置协议DHCP（应用层协议）</h3><ul><li>常用于给主机动态的分配IP地址，提供了即插即用的连网机制，允许一台计算机加入新的网络和获取IP地址而不用手工参与。</li><li>DHCP是<strong>应用层协议</strong>，DHCP报文使用<strong>UDP</strong>传输。</li><li>DHCP服务器分配给DHCP客户的IP地址是临时的(<code>租用期</code>内可用)。</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200809143816958.png" alt="image-20200809143816958" /><figcaption>image-20200809143816958</figcaption></figure><h3 id="网际控制报文协议icmp网络层协议">3、网际控制报文协议ICMP（网络层协议）</h3><ul><li>ICMP 差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况。</li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200806165438903.png" alt="image-20200806165438903" /><figcaption>image-20200806165438903</figcaption></figure><h2 id="五ipv6">五、IPv6</h2><ul><li><p>解决IP地址耗尽的方法有三种：</p><ul><li><p>使用CIDR：它消除了传统的A类、B类和C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间。</p></li><li><p>使用NAT表：用于实现专用网的主机和因特网的主机的通信。</p></li><li><p>IPv6：采用更大地址空间的新版本的IPv6。</p><blockquote><p>前两种都是延长地址的分配结束时间，而IPv6才能根本上解决耗尽问题。IPv4中规定IP地址长度为32，即有2<sup>32-1（符号</sup>表示升幂，下同）个地址；而IPv6中IP地址的长度为128，即有<span class="math inline">\(2^{128}-1\)</span>个地址。</p></blockquote></li></ul></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200809145920071.png" alt="image-20200809145920071" /><figcaption>image-20200809145920071</figcaption></figure><ul><li>IPv6优势：<ul><li>比IPV4有长得多的地址；</li><li>简化了IP分组的基本首部，从而改善吞吐率；</li><li>更好的支持选项。从前的一些必选的段现在变成了可选的，路由器可以简单的跳过无关选项，加快了分组的处理速度。</li></ul></li></ul><h2 id="六路由选择协议">六、路由选择协议</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200809165549634.png" alt="image-20200809165549634" /><figcaption>image-20200809165549634</figcaption></figure><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200809203206766.png" alt="image-20200809203206766" /><figcaption>image-20200809203206766</figcaption></figure><h3 id="rip路由信息协议">1、RIP(路由信息协议)</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200809203233581.png" alt="image-20200809203233581" /><figcaption>image-20200809203233581</figcaption></figure><p>RIP 是基于分布式的<strong>距离向量路由算法</strong>的路由选择协议，只适用于小型互联网。RIP 按照固定的时间间隔与相邻路由器交换信息，交换的信息是当前路由表。</p><ul><li><p><strong>距离向量路由算法</strong>：路由器只掌握<strong>物理相连的邻居</strong>以及链路费用。</p></li><li><strong>优点</strong>：实现简单，开销小，收敛速度快。</li><li><strong>缺点</strong>：<ul><li>限制了网络规模（16不可达）；</li><li>由于路由器之间交换的路由信息是路由器中的完整路由表，所以随着网络规模扩大开销也变大；</li><li>坏消息传播的慢，此时收敛时间长。</li></ul></li></ul><blockquote><p>RIP是应用层协议，使用UDP传送数据；RIP选择的路径不一定是时间最短的，但一定是路径最短的。</p></blockquote><p><img src="D:\TIM\MobileFile\BA3467D2DE4874CAF07D8E9F307F889D.png" alt="BA3467D2DE4874CAF07D8E9F307F889D" style="zoom: 45%;" /></p><h3 id="ospf开放最短路径优先协议">2、OSPF（开放最短路径优先协议）</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200809203257563.png" alt="image-20200809203257563" /><figcaption>image-20200809203257563</figcaption></figure><p>OSPF 是基于分布式的<strong>链路状态路由算法</strong>的路由选择协议，适用于大型互联网，只在链路状态发生变化时才向本自治系统中的所有路由器用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。</p><p>基于链路状态协议，使用<code>洪泛法</code>（一传十，十传百）向本自制系统内的所有路由器发送信息，只有当链路状态改变时才更新。</p><ul><li><strong>链路状态路由算法</strong>：所有路由器<strong>掌握完整的网络拓扑信息</strong>和链路费用信息。</li></ul><h3 id="ospf-与rip-相比有以下3-点主要区别">OSPF 与RIP 相比有以下3 点主要区别：</h3><ol type="1"><li>OSPF 向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法。</li></ol><p>​ 而RIP 仅向自已相邻 的几个路由器发送信息。</p><ol start="2" type="1"><li><p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛 得快，不会出现RIP&quot; 坏消息传得慢＂的问题。而在RIP 中，不管网络拓扑是否发生变化，路由器 之间都会定期交换路由表的信息。</p></li><li><p>OSPF发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。” 链路状态”说明本路由器和哪些路由器相邻及该链路的“度量”（或代价）。</p></li></ol><p>​ 而在RIP 中，发送的信息是本路由器所知道的全部信息，即完整的路由表。（因此网络规模越来越大，开销也越来越大）</p><blockquote><p>OSPF工作原理：由于各路由器频繁的交换链路状态信息，因此所有路由器最终都能建立一个链路状态数据库。这个数据库实际上就是全网的拓扑信息图，全网范围一直。然后每个路由器根据这个全网拓扑结构图使用Dijkstra算法计算自己到各个网络的最优路径，以此构造自己的路由表。此后当路由状态发生变化时，每个路由器会重新计算到各个目的网络的最优路径，构造新的路由表。（虽然使用Dijkstra算法会计算完整的最优路径，但是路由表不存储完整路径，只存储“下一跳”，只有到了下一跳路由器才能知道下一跳路由器怎么走）</p></blockquote><h3 id="bgp边界网关协议">3、BGP(边界网关协议)</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200809203323533.png" alt="image-20200809203323533" /><figcaption>image-20200809203323533</figcaption></figure><p>基于路径-向量协议，自治系统之间路由器交换信息时使用这个。</p><ul><li>BGP是应用层协议，基于TCP</li><li>BGP 是不同自治系统的路由器之间交换路由信息的 协议，是一种外部网关协议。<ul><li>因特网的规模太大，使得自治系统之间路由选择非常困难。</li><li>对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。</li><li>自治系统之间的路由选择必须考虑有关策略。</li></ul></li><li>边界网关协议(BGP) 只能力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并 非寻找一条最佳路由。</li></ul><blockquote><p>BGP 的工作原理如下：每个自治系统的管理员要选择至少一个路由器（可以有多个）作为该自治系统的<u>&quot;BGP 发言人“</u>。一个BGP 发言人与其他自治系统中的BGP发言人要交换路由信息，就要先 建立TCP 连接（可见BGP 报文是通过TCP 传送的，也就是说BGP 报文是TCP 报文的数据部分）， 然后在此连接上交换BGP 报文以建立BGP 会话，再利用BGP 会话交换路由信息。当所有BGP 发 言人都相互交换网络可达性的信息后，各BGP 发言人就可找出到达各个自治系统的较好路由。</p></blockquote><h2 id="七ip组播多播">七、IP组播（多播）</h2><h3 id="ip组播">1、IP组播</h3><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200810140316189.png" alt="image-20200810140316189" /><figcaption>image-20200810140316189</figcaption></figure><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200810140144536.png" alt="image-20200810140144536" /><figcaption>image-20200810140144536</figcaption></figure><p><strong>组播一定是仅应用于UDP。</strong></p><ul><li>把一个分组发送给多台目的主机，采用的方法并不是让源主机给每台目的知己都发送一份分组，而是将分组发给一个组播地址，该组播地址标示一组主机。网络把这个分组复制后传递给该组中的每一台在主机。</li><li>与广播不同，主机组播时仅发送一份数据，组播的数据仅在传送路径分叉时才将数据报复制后继续转发。</li><li><p>组播需要路由器的支持(组播路由器)。</p></li><li>组播的特点：<ol type="1"><li>组播地址只能用于目的地址，不能用于源地址；</li><li>组播数据报“尽最大努力交付”，不提供可靠交付；</li><li>对组播数据报不产生差错报文；</li><li>并非所有D类地址都可以作为组播地址。</li></ol></li></ul><h3 id="网际组管理协议-igmp">2、网际组管理协议 IGMP</h3><ul><li><p><strong>IP 多播使用 IGMP 协议</strong>，IGMP 并非在互联网范围内对所有多播组成员进行管理，它不知道 IP 多播组包含的成员个数也不知道这些成员都分布在哪些网络上。</p></li><li><p>IGMP 协议是：<u>让连接在本地局域网上的多播路由器知道本局域网上是否有主机上的某个进程参加或推出了某个多播组。</u></p></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200810142231432.png" alt="image-20200810142231432" /><figcaption>image-20200810142231432</figcaption></figure><h2 id="八移动ip">八、移动IP</h2><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200810142459521.png" alt="image-20200810142459521" /><figcaption>image-20200810142459521</figcaption></figure><h3 id="移动ip">1、移动IP</h3><p>移动节点（比如一台笔记本电脑）在本地时使用传统的TCP/IP方式进行通信，而当移动节点漫游到外地网络时，仍需要使用固定的IP地址进行通信，为了能收到信息，<code>移动节点</code>需要向<code>本地代理</code>注册当前的位置地址(也就是<code>转交地址</code>)，本地代理收到后会建立一条<code>隧道</code>，将截获的发送给移动节点的IP分组送到转交地址处，在转交地址处解除隧道封装，最后送到移动节点。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/IMG_2201(20200810-143354).PNG" alt="IMG_2201(20200810-143354)" /><figcaption>IMG_2201(20200810-143354)</figcaption></figure><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200810135349266.png" alt="image-20200810135349266" /><figcaption>image-20200810135349266</figcaption></figure><h3 id="移动ip与动态ip的区别">2、移动IP与动态IP的区别</h3><p><strong>移动IP</strong>为移动主机设置了两个IP地址，即主地址和辅地址(转交地址)。移动节点在本地网时使用主地址，在外网需要获得一个辅助的临时地址，但是此时主地址不变，当从外网回来时，辅地址就会被改变或撤销，而主地址依然不变。</p><p><strong>动态IP</strong>是指局域网中的计算机可以通过网络中的DHCP服务器动态的获得一个IP地址，所以不需要用户在计算机网络设置中指定IP地址。</p><h2 id="九路由器的主要功能">九、路由器的主要功能？</h2><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200809203500531.png" alt="image-20200809203500531" style="zoom: 67%;" /></p><p><strong>路由器</strong>实质上是一种多个输入端口和多个输出端口的专用计算机，其任务是连接不同的网络转发分组。也就是说，将路由器某个输入端口收到的分组，按照分组要取的目的地（目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。</p><ul><li>路由器的结构：<ol type="1"><li>路由选择：根据所选定的<u>路由选择协议</u>构造出路由表，同时经常或定期的和相邻路由器交换路由信息而不断更新和维护路由表，其核心部件是路由选择处理器；</li><li>分组转发：包括一组输入端口、交换结构和一组输出端口，交换结构(路由器的核心部件)从输入端口接收到分组后，根据转发表对分组进行处理，然后从一个合适的输出端口转发出去。</li></ol></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/A7CAF9BE3412A567CE201ACA40D6A242.png" alt="A7CAF9BE3412A567CE201ACA40D6A242" /><figcaption>A7CAF9BE3412A567CE201ACA40D6A242</figcaption></figure><ul><li>若接收到的分组是路由器之间交换路由信息的分组，比如RIP和OSPF分组，则把这种分组送交路由器的路由选择部分的选择处理器；</li><li>若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，经过交换结构到达合适的输出端口。</li><li>当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组，这个分组就要排队，因而产生了<strong>时延</strong>。</li></ul><h1 id="第三章-数据链路层">第三章 数据链路层</h1><h2 id="一数据链路层的功能">一、数据链路层的功能</h2><p>数据链路层 在物理层所提供的服务的基础上 <u>向网络层提供服务</u>，即将原始的、有差错的物理线路改进成<u>逻辑上无差错的数据链路</u>，从而向网络层提供高质量的服务。</p><ol type="1"><li><p><strong>向网络层提供服务</strong>：包括3种：<u>无确认的无连接服务、有确认的无连接服务和有确认的有连接服务（没有无确认的有连接服务）</u></p></li><li><p><strong>链路管理</strong>：负责数据链路的建立、维持和释放，主要用于面向连接的服务；</p></li><li><p><strong>帧同步</strong>：接收方确定收到的比特流中以帧的开始位置和结束位置；</p></li><li><p><strong>差错控制</strong>：用于使接收方确定接收到的数据就是发送方发送的数据；</p></li><li><p><strong>透明传输</strong>：解决与控制符形同的数据如何发送，就是不管数据是什么样的比特组合，都应当能在链路上发送；</p></li></ol><h2 id="二组帧在网络中以帧为最小传输单位mtu最大传输单元">二、组帧（在网络中以帧为最小传输单位，MTU，最大传输单元）</h2><h3 id="为什么要组帧">1、为什么要组帧？</h3><p>如果传输比特流出错，只需要重传出错的帧即可，无需重传全部比特流，从而提高效率，值！</p><h3 id="组帧的4种方法">2、组帧的4种方法</h3><ol type="1"><li><p><strong>字符计数法</strong>：用一个<code>特殊的字符</code>表示一帧的开始，然后用一个<u>计数字段</u>来表明该帧包含的字节数。当目的主机接收到该帧时，根据此字段提供的字节数，便可知道该帧的结束位和下 一帧的开始位。</p><blockquote><p>存在问题：若计算字段出错，就无法实现帧同步，因此该方法很少被使用。</p></blockquote></li><li><p><strong>字节填充（的首尾界符）法</strong>：字符填充发使用一些特定的字符来定界一帧的开始和结束。在数据中可能出现的 特殊字符 前面加上转义字符<code>ESC</code>。接收方收到转义字符后就知道，其后面紧跟的是数据信息，二不是控制信息。</p></li><li><p><strong>比特填充的首尾标识法（零比特填充法）</strong>：使用<code>01111110</code>作为帧的开始和结束标志。若数据部分也出现<code>01111110</code>，可以这样子：（只要遇到5个“1”，立刻就在后面填1个“0”） 只要数据帧检测到有5个连续的1，就立刻那个在后面插入0，而接收方没收到连续的5个1，就自动删除后面紧跟的0，以恢复原始数据。</p></li><li><p><strong>物理编码违例法</strong>：利用物理介质上编码的违法标志来区分帧的开始和结束。</p></li></ol><blockquote><p>目前比较常用的是：比特填充法和违规编码法</p></blockquote><h2 id="三差错控制">三、差错控制</h2><h3 id="检错编码">1、检错编码</h3><ol type="1"><li><p><strong>奇偶校验码</strong>：在信息码后面添加一位校验码，分为<code>奇校验</code>和<code>偶校验</code>： 缺点：若同时有两位数据发送改变，则无法检出错误。检错率低</p></li><li><p><strong>循环冗余码(CRC)</strong> 优势：检错率极高、开销小、易实现。</p></li></ol><h3 id="纠错编码不但能检错还能纠错">2、纠错编码（不但能检错，还能纠错）</h3><p><strong>海明码</strong>。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200812011414338.png" alt="image-20200812011414338" /><figcaption>image-20200812011414338</figcaption></figure><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200812011440896.png" alt="image-20200812011440896" /><figcaption>image-20200812011440896</figcaption></figure><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200812011130160.png" alt="image-20200812011130160" /><figcaption>image-20200812011130160</figcaption></figure><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200812012155028.png" alt="image-20200812012155028" /><figcaption>image-20200812012155028</figcaption></figure><h2 id="四流量控制和可靠传输机制in-传输层">四、流量控制和可靠传输机制（in 传输层）</h2><blockquote><p>数据链路层的流量控制与传输层的区别？</p><ol type="1"><li><p>数据链路层的流量控制是点对点的（两个相邻结点之间的），而传输层的流量控制是端到端的（两个主机之间的）。</p></li><li><p>数据链路层的流量控制手段是：接收方收不下就不回复确认。</p><p>传输层的流量控制手段是：接受端给发送端一个窗口公告（告诉他接收端目前的信息，让它慢点发类似的）</p></li></ol></blockquote><h3 id="流量控制">1、流量控制</h3><p><strong>含义</strong>：控制发送方发送数据的速率，使接收方来得及接收。 <strong>基本方法</strong>：由接收方控制发送方的数据流，常见两种方法：</p><h3 id="可靠传输机制">2、可靠传输机制</h3><p>与无差错接收（比如在数据链路层使用循环冗余码检验差错检测技术，凡是接收端接收的帧均无差错，有差错的被丢弃了呗）不同，</p><p>可靠传输是指<strong>数据链路层发送什么，接收端就接收什么</strong>。传输差错包括<code>无比特差错（可用CRC检测）</code>和<code>无传输差错（更复杂，可能帧没问题，但出现了帧失序或者帧重复）</code>。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200812141447173.png" alt="image-20200812141447173" /><figcaption>image-20200812141447173</figcaption></figure><h3 id="停止-等待协议基于停止-等待流量控制技术">3、停止-等待协议（基于停止-等待流量控制技术）</h3><ul><li><p><strong>原理</strong>：发送方传输一个帧后，就停止发送，必须等待对方的确认才能发送下一帧。若在规定的时间内（超时计时器：比平均RTT长一些，因为发送方和接收方都有发送时延）没有收到确认，则发送超时，并重传原始帧。</p><ol type="1"><li>数据帧丢失</li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813085752930.png" alt="image-20200813085752930" /><figcaption>image-20200813085752930</figcaption></figure><ol start="2" type="1"><li>ACK丢失</li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813085904219.png" alt="image-20200813085904219" /><figcaption>image-20200813085904219</figcaption></figure><ol start="3" type="1"><li>ACK迟到</li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813091030252.png" alt="image-20200813091030252" /><figcaption>image-20200813091030252</figcaption></figure><ul><li><strong>信道利用率：</strong>（也叫信道效率）针对发送方而言，是指发送方在一个发送周期的时间内，有效地发送数据所需要的时间占整个发送周期的比率。</li><li><strong>信道利用率 = <span class="math inline">\(\frac{数据帧的发送时间}{数据帧的发送时间 + RTT + 确认帧的发送时间}\)</span></strong></li><li><strong>信道利用率 = 信道利用率 * 发送方的发送速率</strong></li><li><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813091322288.png" title="fig:" alt="image-20200813091322288" /></li></ul></li></ul><h3 id="滑动窗口机制">4、滑动窗口机制</h3><ul><li>只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。</li><li>当接收窗口大小为1时，可保证帧按序接收。</li></ul><h4 id="后退n帧gbn协议基于滑动窗口流量控制技术">4.1 后退N帧（GBN）协议（基于滑动窗口流量控制技术）</h4><ul><li><strong>累计确认！冗余丢弃！</strong></li></ul><p><strong>原理</strong>：发送方发送完一个数据帧后，不是停下来等待确认帧，而是可以连续再发送若干个数据帧。如果这时收到了接收方的确认帧，那么还可以接着再发送数据帧。如果某个帧出错了，接收方只能简单地丢弃该帧机器所有的后续帧。发送方超时后需重发该出错帧及其后续所有帧。 <strong>评价</strong>：减少了等待时间，使得整个通信的吞吐量得到提高。但接收方已发行错误帧，就不再接收后续帧，造成了一定浪费。于是有了下面的<code>选择重传协议</code></p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/3105B543D1CC214C93F7748FC014C53C.png" alt="3105B543D1CC214C93F7748FC014C53C" /><figcaption>3105B543D1CC214C93F7748FC014C53C</figcaption></figure><blockquote><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/E356708BCD2A0D73AF00627F543D0926.png" alt="E356708BCD2A0D73AF00627F543D0926" /><figcaption>E356708BCD2A0D73AF00627F543D0926</figcaption></figure><p><strong>答：</strong>GBN采用累计确认，即接收方对按需到达的最后一个分组发送确认。所以收到3的确认帧就表示0，1，2，3的帧已接受，而此时发送方未收到1的确认只能代表确认帧在返回时的过程中丢失，而不代表1号帧未到达接受方。因此需要重传的是4，5，6，7。</p></blockquote><h4 id="选择重传sr协议基于滑动窗口流量控制技术">4.2 选择重传（SR）协议（基于滑动窗口流量控制技术）</h4><ul><li><strong>单一确认！冗余缓存（buffered）</strong></li></ul><p><strong>原理</strong>：若一帧出错，则其后续帧先存入接收方的缓冲区帧，同时要求发送方重传出错帧，一旦收到重传帧后，就和原先存在缓冲区的其余帧一起按正确的顺序送至主机。 <strong>评价</strong>：避免了重复传输那些本来已经正确到达接收方的数据帧，进一步提高了信道利用率，但代价是增加了缓冲空间。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/43FE3D2E021E046C7040229B37E7EEAD.png" alt="43FE3D2E021E046C7040229B37E7EEAD" /><figcaption>43FE3D2E021E046C7040229B37E7EEAD</figcaption></figure><h4 id="后退n帧gbn协议-vs-选择重传sr协议">后退N帧（GBN）协议 vs 选择重传（SR）协议</h4><table><thead><tr class="header"><th style="text-align: center;">Go-Back-N</th><th style="text-align: center;">Selective Repeat</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">累积ACK</td><td style="text-align: center;">单一ACK</td></tr><tr class="even"><td style="text-align: center;">单一timer</td><td style="text-align: center;">多个timer</td></tr><tr class="odd"><td style="text-align: center;">乱序分组丢弃；并生成冗余ACK</td><td style="text-align: center;">乱序分组缓存；并生成单个ACK</td></tr><tr class="even"><td style="text-align: center;">超时重传：丢失及以后的</td><td style="text-align: center;">超时重传：只重传音器超时的那个</td></tr></tbody></table><h3 id="介质访问控制media-access-controlmac">5、介质访问控制（Media Access Control，MAC）</h3><p>介质访问控制：为使用介质的每个结点隔离来自同一信道上其他节点所传送的信号，以协调活动结点的传输。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813133118906.png" alt="image-20200813133118906" /><figcaption>image-20200813133118906</figcaption></figure><ol type="1"><li>信道划分介质访问控制；</li><li>随机访问介质访问控制；</li><li>轮询访问介质访问控制。</li></ol><h4 id="信道划分介质访问控制静态划分信道">5.1 信道划分介质访问控制(静态划分信道)</h4><ol type="1"><li><p>频分多路复用： 将一条信道分割成多个不同频率的信道(类似将马路分割为多个车道)。 若复用数之间，则需增加信道的(频率)带宽。</p></li><li><p>时分多路复用： 将一个固定时间分割成多个时间段。 但是有可能某个时间段内，要使用的那个人不用了，此时会出现空等状态，太浪费</p></li><li><p>统计时分多路复用：</p><p>于是出现了改进版的，也就是<code>统计时分复用</code>，这是一种动态的时间分配，又称<code>异步时分复用</code>，可以避免浪费（只要没人用就自己用）。</p></li><li><p>波分多路复用： 光的频分多路复用。</p></li><li><p>码分多路复用： 又称<code>码分多址（CDMA）</code>，既共享信道的频率，又共享时间，是一种真正的动态复用技术，抗干扰能力强、保密性强、语音质量好。</p></li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813134158489.png" alt="image-20200813134158489" /><figcaption>image-20200813134158489</figcaption></figure><h4 id="随机访问介质访问控制动态划分信道--随机接入">5.2 随机访问介质访问控制（动态划分信道--&gt;随机接入）</h4><ul><li><code>动态划分信道</code>包括<code>随机接入</code>和<code>受控接入</code></li><li><code>随机访问介质访问控制</code>又称<code>争用型协议</code>，因为其核心思想是通过争用，胜利者才可以获得信道，主要有4种协议：</li></ul><ol type="1"><li><strong>ALOHA协议</strong>： 当网络中的任何一个结点发送数据时，可以不进行任何检测就发送数据。如果在一段时间内没有收到确认，该结点就认为传输过程中发生了冲突。发生冲突的结点需要等待一个随机的数据后再次发生数据。直到发送成功。 缺点：信道利用率不理想 改进：<u>时分ALOHA</u>：所有结点的时间被划分为间隔相同的时隙，并规定每个节点只有当下一个时隙到来时才可以发送数据。</li></ol><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813140243367.png" /></p><ol start="2" type="1"><li><strong>载波侦听多路访问(CSMA)协议</strong>： 每个节点在发送数据之前，使用载波侦听技术来判定通信信道是否空闲，常用<strong>3种策略</strong>：</li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813143626671.png" alt="image-20200813143626671" /><figcaption>image-20200813143626671</figcaption></figure><p>      </p><ol start="3" type="1"><li><p><strong>带冲突检测的载波侦听多路访问（CSMA/CD）协议（collision detection）</strong>： <strong>策略</strong>：<strong>先听后发，边听边发，冲突停发，随机重发。</strong> <strong>争用期</strong>：<u>以太网</u>端到端的往返时延，又称<code>冲突窗口</code>或者<code>碰撞窗口</code>。只有经过争用期这段时间还没有检测到冲突，才能肯定这次发送不会发生冲突。</p></li><li><p><strong>CSMA/CA协议（collision avoidance）</strong>： 在CSMA基础上增加了<u>冲突避免</u>功能。主要用在<u>无线局域网</u>中。 冲突避免要求每个结点在发送数据之前监听信道，若信道空闲，则发送数据。发送完一个帧后，必须等待一段时间，检查接收方是否发回了帧确认，若收到则继续发送，否则表明出现冲突，重发该帧。</p></li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813135052730.png" alt="image-20200813135052730" /><figcaption>image-20200813135052730</figcaption></figure><h4 id="轮询访问介质访问控制动态划分信道--受控接入">5.3 轮询访问介质访问控制（动态划分信道--&gt;受控接入）</h4><p>用户不能随意地发送信息，而是通过一个集中控制的监控站经过轮询过程后再决定信道的分配。典型的轮询访问介质访问控制协议就是<code>令牌传递协议</code>。</p><h3 id="局域网">6、局域网</h3><h4 id="局域网的定义">6.1 局域网的定义</h4><p>局域网是指一个较小范围内的多台计算机或者其他通信设备，通过双绞线、同轴电缆等连接介质互连起来，以达到资源和信息共享目的的互联网络。</p><h4 id="局域网的主要特点">6.2 局域网的主要特点</h4><ol type="1"><li>局域网为一个单位所拥有；</li><li>地理范围和站点数目有限；</li><li>与以前的非光纤的广域网相比，局域网具有较高的数据率、较低的时延和较小的误码率。</li></ol><h4 id="局域网的主要优点">6.3 局域网的主要优点</h4><ol type="1"><li>具有广播功能，从一个站点可很方便访问全网；</li><li>具有便于系统的扩展和演变，各设备的位置可灵活的调整和改变；</li><li>提高了系统的可靠性、可用性；</li><li>各站为平等关系而不是主从关系。</li></ol><h4 id="局域网的主要技术要素">6.4 局域网的主要技术要素</h4><ol type="1"><li><strong>网络拓扑结构</strong>：星形网、环形网、总线型网和树形网。</li><li><strong>传输介质</strong>：双绞线（主流）、铜缆、光纤。</li><li><strong>介质访问控制方法</strong>：CSMA/CD、令牌总线和令牌环。</li></ol><h4 id="一个局域网的典型代表----以太网">6.5 一个局域网的典型代表----以太网</h4><ul><li><strong>工作原理</strong>：以太网采用<code>IEEE802.3</code>标准，采用<strong>总线拓扑结构</strong>，信息以<strong>广播</strong>形式发送，使用<strong>CSMA/CD</strong>技术对总线进行访问控制，提供的是<strong>不可靠的服务</strong>（无连接，不对发送的数据帧编号，也不要求接收方发回确认）。</li><li><strong>以太网的MAC帧</strong>：包括<code>前导码</code>和<code>目的地址、源地址</code>和<code>类型</code>和<code>数据</code>和<code>填充</code>和<code>校验码</code>。</li><li><strong>以太网的传输介质</strong>：10Base5（粗缆）、10Base2（细缆）、10Base-T（双绞线）、10Base-F（光纤）。</li></ul><h4 id="令牌环网的工作原理">6.5 令牌环网的工作原理</h4><blockquote><p>(1）当网络空闲时，环路中只有令牌在网络中循环传递； (2) 令牌传递到有数据要发送的结点处，该节点就修改令牌的一个标志位，然后在令牌中附加自己需要的数据，这样就将令牌改换成了一个数据帧，源结点将这个数据帧发送出去； (3)数据帧沿着环路传递，接收到的结点一边转发数据，一边查看帧的目的地址，若是自己的就收下； (4）当数据帧到达了源节点，源节点收到了自己发出去的数据帧，便不再转发了。同时，源节点要通过校验返回的数据帧进行检错，若出错，则重发； (5源节点传送完数据后，重新产生一个令牌，并将其传递给下一个站点，以交出发送数据帧的权限。</p></blockquote><h3 id="广域网">7、广域网</h3><h4 id="广域网定义">7.1 广域网定义</h4><p>覆盖范围很广的长距离网络。</p><h4 id="ppp面向字节无连接">7.2 PPP（面向字节，无连接）</h4><p>PPP（point-to-point protocal）是使用串行线路通信的面向字节的协议，该协议应用在直接连接两个节点的链路上。设计的主要目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一 种共通的解决方案。</p><blockquote><p>点到点协议（Point to Point Protocol，PPP）是为在同等单元之间传输数据包这样的简单链路设 计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。</p></blockquote><p>PPP具有以下功能：</p><ul><li>PPP具有错误检测能力，但不具备纠错能力，只保证无差错接受（通过硬件进行CRC检验）</li><li>ppp是不可靠传输协议，不使用序号和确认机制</li><li>支支持全双工链路，只支持点对点的链路通信</li><li>PPP支持多种网络协议，比如TCP/IP、NetBEUI、NWLINK等；</li><li>面向字节的协议</li></ul><h4 id="hdlc协议面向比特">7.3 HDLC协议（面向比特）</h4><p>HDLC协议可适用于两种配置：</p><p>非平衡配置（由一个主站控制整个链路的工作）和平衡配置（链路两端的两个站都是复合站，每个复合站都可以平等地发起数据传输，而不需要得到对方复合站的允许）。</p><p>主要有四个特点：</p><ol type="1"><li>对于任何一种比特流都可透明传输。</li><li>全双工通信，较高的数据链路传输效率。</li><li>所有的帧都有帧校验序列（FCS），传输可靠性高。</li><li>用统一的帧格式来实现传输。</li></ol><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813181910941.png" alt="image-20200813181910941" /><figcaption>image-20200813181910941</figcaption></figure><h3 id="数据链路层的设备网桥-交换机-回来看-然后做126页题">==8、数据链路层的设备：网桥 &amp; 交换机 回来看 然后做126页题==</h3><h4 id="网桥">8.1 网桥</h4><p>具有<strong>过滤帧</strong>的功能。</p><p><strong>优点</strong>：</p><ol type="1"><li>过滤通信量；</li><li>扩大了物理范围；</li><li>提高了可靠性；</li><li>可互连不同物理层、不同MAC子层和不同速率的以太网。</li></ol><p><strong>缺点</strong>：</p><ol type="1"><li>存储转发增加了时延；</li><li>在MAC子层并没有流量控制功能；</li><li>具有不同MAC子层的网段桥接在一起时时延更大；</li><li>网桥只适合于用户数不太多和通信量不太大的局域网，否则产生广播风暴（传播过多的广播信息而产生网络拥塞）。</li></ol><p><strong>分类</strong>：透明网桥（选择的不是最佳路由）、源路由网桥（是最佳路由）。</p><h4 id="局域网交换机">8.2 局域网交换机</h4><p><strong>实质</strong>：<strong>多端口网桥。</strong> <strong>优点</strong>：不仅每个端口节点所占用的带宽不会因为端口节点数量的最佳而减少，而且整个交换机的带宽会随着带宽节点的增加而增加。 <strong>两种交换模式</strong>：</p><ol type="1"><li>直通式交换：只检查帧的目的地址，帧在被接收后立即发出。速度快，不安全，不支持具有不同速率的端口的交换；</li><li>存储转发式交换：先将接收到的帧存储在高速缓存中，检错，若不错则查找转发表，将该帧从查询到的端口转发出去；若出错则丢弃。可靠性高，支持不同速率端口间的转换，但延迟较大。</li></ol><p><strong>工作原理</strong>： 和网桥类似，检测从某端口进入交换机的帧的源MAC地址和目的MAC地址，然后与系统内部的动态查找表进行比较，若数据报的MAC地址不在查找表中，则将该地址加入查找表中，并将数据报发送给相应的目的端口。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200813185405548.png" alt="image-20200813185405548" /><figcaption>image-20200813185405548</figcaption></figure><h1 id="集线器交换机网桥区别">==集线器、交换机、网桥区别==</h1><h1 id="第二章-物理层">第二章 物理层</h1><h2 id="物理层的功能">1、物理层的功能？</h2><p>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用 是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p><h2 id="信号信源信道信宿">2、信号、信源、信道、信宿</h2><ul><li><p><strong>信号</strong>是数据（<code>传送信息的实体</code>）的电气或电磁的表现。 <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200814164850309.png" alt="image-20200814164850309" /> 一句话：基带对应数字信号，宽带对应模拟信号。 注意：宽带传输==频带传输(in 考研）。</p></li><li><p><strong>信源</strong>：通信过程中<u>产生和发送</u>信息的设备或计算机。</p></li><li><p><strong>信道</strong>：信息传送的道路，也就是信号的传输媒质，分为有线信道和无线信道。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20201028130741608.png" alt="image-20201028130741608" style="zoom:50%;" /></p></li><li><p><strong>信宿</strong>：通信过程中<u>接收和处理</u>信息的设备或计算机。</p></li></ul><h2 id="速率波特码元带宽">3、速率、波特、码元、带宽</h2><ul><li><p><strong>速率</strong>：就是单位时间内传输的数据量，可用波特率和比特率来描述。 <img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200814181139948.png" alt="image-20200814181139948" /></p></li><li><p><strong>码元</strong>：数字通信中数字信号的计量单位。用一个固定市场的信号波形表示一位k进制数，这个时长内的信号成为k进制码元。</p><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200814181933593.png" alt="image-20200814181933593" /><figcaption>image-20200814181933593</figcaption></figure></li><li><p><strong>带宽</strong>：带宽是用来表示<code>网络的通信线路</code>所能<code>传送数据的能力</code>，表示<u>单位时间内从网络中的某一点到另一点所能通过的<code>最高数据率</code>。</u> 此时，带宽的单位不再是赫兹(Hz)，而是<code>bit/s</code>。</p></li></ul><h2 id="通信方式">4、通信方式：</h2><h3 id="单工半双工全双工">4.1 单工&amp;半双工&amp;全双工</h3><p>从通信双方信息的交互来看：</p><ol type="1"><li><strong>单工通信</strong>：只有一个方向的通信而没有反方向的交互；需要一条信道（广播）</li><li><strong>半双工通信</strong>：通信双方都可以收发信息，但不能同时；需要两条信道（对讲机）</li><li><strong>全双工通信</strong>：通信双方可以同时收发信息；需要两条信道（打电话）</li></ol><h3 id="串行传输并行传输">4.2 串行传输&amp;并行传输</h3><ol type="1"><li><strong>串行传输</strong>：将表示1个字符的8位二进制数按由低位到高位的顺序依次发送。<ul><li>速度慢，费用低，适合远距离</li></ul></li><li><strong>并行传输</strong>：将表示1个字符的8位二进制数同时通过8条信道发送。<ul><li>速度快，费用高，适合近距离</li></ul></li></ol><h3 id="同步传输异步传输">4.3 同步传输&amp;异步传输</h3><ul><li><p><strong>同步通信</strong></p><p>同步通信的通信双方必须先建立同步， 即<strong>双方的时钟要调整到同一个频率</strong>。收发双方<u>不停地</u> 发送和接收连续的同步比特流，是一个区块。主要有两种同步方式： 一种是全网同步， 即用一个非常精确的主 时钟对全网所有结点上的时钟进行同步；另一种是准同步， 即各结点的时钟之间允许有微小的误 差，然后采用其他措施实现同步传输。同步通信数据率较高，但实现的代价也较高。</p></li><li><p><strong>异步通信</strong></p><p>异步通信在发送字符时，<u>所发送的字符之间的时间间隔可以是任意的，但接收端必须时刻做 好接收的准备。发送端可以在任意时刻开始发送字符，</u> <strong>因此必须在每个字符开始和结束的地方加 上标志， 即开始位和停止位</strong>，以便使接收端能够正确地将每个字符接收下来。异步通信也可以帧 作为发送的单位。这时，帧的首部和尾部必须设有一些特殊的比特组合，使得接收端能够找出一 帧的开始（即帧定界）。异步通信的通信设备简单、便宜，但传输效率较低（因为标志的开销所 占比例较大）。</p></li></ul><h2 id="奈氏准则奈奎斯特定理">5、奈氏准则（奈奎斯特定理）</h2><ul><li><p><strong>由来：寻找在保证不出现码间串扰的条件下的码元的最大传输速率。</strong></p><blockquote><p>码间串扰：具体的信道所能通过的频率范围总是有限的，所以信号中的大部分高频分量就过不去了，这样在传输共享中会衰减，导致在接收端收到的信号的波形就<u>失去了码元之间的清晰界限</u>，这种现象就是码间串扰</p></blockquote></li></ul><figure><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200814195905803.png" alt="image-20200814195905803" /><figcaption>image-20200814195905803</figcaption></figure><ul><li><p><strong>奈奎斯特定理</strong>: <span class="math display">\[C_{max}=f_{采样}*log_2N(bit/s)\]</span> 其中，<code>f</code>代表<code>理想低通信道</code>的带宽，<code>N</code>表示每个码元的离散电平的数目。</p></li><li><p><strong>区分低通信道和带通信道</strong></p></li></ul><p><code>低通信道</code>就是信号的频率只要不超过某个上限值，都可以不失真地通过信道（有上限，无下限），理想低通信道的最高码元传输速率是每秒2个码元； <code>带通信道</code>既有上限也有下限，理想带通信道的最高码元传输速率是每秒1个码元。</p><h2 id="香农定理">6、香农定理</h2><p>公式： <span class="math display">\[C_{max}=W*log_2(1+S/N)(bit/s)\]</span> 其中，<code>W</code>为信道的带宽，<span class="math inline">\(S/N\)</span>为信噪比。 <strong>想要提高信息的传输速率，需要增大信噪比或者提高带宽</strong>（注意：仅仅提高改善编码不可能超过香农公式算出的速率）。</p><h2 id="对比奈奎斯特定理和香农定理">7、对比奈奎斯特定理和香农定理</h2><p><strong>奈奎斯特定理</strong>：</p><p>寻找在保证不出现码间串扰的条件下的码元的最大传输速率。只考虑了带宽与码元速率的关系。</p><ol type="1"><li>指出了<strong>码元的传输速率是受限的</strong>，不能任意提高，否则在接收端就无法判定码元是0还是1（码间串扰）;</li><li>是在理想条件下推出来的(无噪声);</li><li>并没有对信息传输速率给出限制（可以无限大，只要编码技术足够好）。</li></ol><p><strong>香农定理</strong>:</p><p>不仅考虑了带宽与码元速率的关系，也考虑了信噪比。</p><ol type="1"><li><strong>给出了信息传输速率的极限值</strong>，只要传输带宽（Hz）和信噪比确定了，传输速率也就确定了;</li><li>有噪声。</li></ol><h2 id="编码与调制">8、编码与调制</h2><ul><li><strong>编码</strong>：将模拟数据或数字数据<strong>转换为数字信号</strong>的过程。</li><li><strong>调制</strong>：将模拟数据或数字数据<strong>转化为模拟信号</strong>的过程。</li></ul><h3 id="编码">8.1 编码</h3><ol type="1"><li>数字数据 编码为 数字信号： 用于基带信号传输中。（数字发送器） 常用编码方式：<ol type="1"><li>非归零码；</li><li>曼彻斯特编码；（1：先1后0 0：先0后1）</li><li>差分曼彻斯特编码。</li></ol></li><li>模拟数据 编码为 数字信号： 典型例子就是<code>脉冲编码调制PCM</code>，有3个步骤：采样、量化、编码。</li></ol><h3 id="调制">8.2 调制</h3><ol type="1"><li><p>数字数据 调制为 模拟信号：（调制器）</p><ol type="1"><li>带通调制：将基带信号的频带范围搬移到较高的频段以便在信道中传输（3种方法：调频，调幅，调相）；</li><li>基带调制：改变基带信号的低频成分的波形（仍是基带信号）。</li></ol></li><li><p>模拟数据 调制为 模拟信号：（放大器调制器）</p><p>（原因）</p><ol type="1"><li>为了实现传输的有效性，可能需要较高的频率；</li><li>充分利用带宽。</li></ol></li></ol><h2 id="数据传输方式电路交换报文交换分组交换">9、==数据传输方式(电路交换、报文交换、分组交换)==</h2><figure><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200805230405872.png" alt="image-20200805230405872" /><figcaption>image-20200805230405872</figcaption></figure><ol type="1"><li><strong>电路交换（circuit switching）</strong></li></ol><ul><li>电路交换：在发送方和接收方之间通过多台交换机建立一条连接(电路circuit)物理通信路径；</li><li>建立连接 -&gt; 通信 -&gt; 释放</li><li><p>电路交换网络中，端系统间通信会话期间，预留了端系统间通信沿路径所需要的资源（缓存、链路传输速率）</p></li><li>优点：<ul><li>通信时延小；实时性强；</li><li>有序传输；控制简单；使用范围广（数字/模拟信号均可传输）；</li><li>避免冲突。</li></ul></li><li>缺点：<ul><li>建立连接时间长；</li><li>信道利用率低；</li><li>灵活性差（任一节点出错都需要建立新的连接）。</li><li>缺乏统一标准(电路交换时，数据之大，不同规格终端难以相互通信，也很难进行差错控制)；</li></ul></li></ul><ol start="2" type="1"><li><strong>报文交换（meassge switching）</strong></li></ol><ul><li><strong>数据交换的单位是报文，报文携带目的地址、源地址等信息；报文交换在交换节点时采用存储转发方式。</strong></li><li>报文交换方式的数据传输单位是报文，报文就是站点一次性要发送的数据块，其长度不限且可变。当一个站要发送报文时，它将一个目的地址附加到报文上，网络节点根据报文上的目的地址信息，把报文发送到下一个节点，一直逐个节点地转送到目的节点。</li><li>每个节点在收到整个报文并检查无误后，就暂存这个报文，然后利用路由信息找出下一个节点的地址，再把整个报文传送给下一个节点。因此，端与端之间无需先通过呼叫建立连接。</li><li><strong>优点：</strong><ul><li>无需建立连接(因此不存在连接时延)；</li><li>动态分配线路；</li><li>提高了可靠性；</li><li>提高线路利用率；</li><li>提供多目标服务（一个报文可以发送到多个目的地址）。</li></ul></li><li><strong>缺点：</strong><ul><li>由于数据进入交换节点后要经理存储、转发这一过程，从而引起转发时延；</li><li>报文交换对报文的大小没有限制，这就要求网络节点有大量的存储缓存空间。</li></ul></li></ul><ol start="3" type="1"><li><strong>分组交换（packet switching）</strong></li></ol><ul><li><strong>仍采用存储转发方式，但将一个长报文先分割为若干较短的分组，然后逐个转发分组（每个分组都携带目的地址、源地址和编号信息）。</strong></li></ul><p>分组交换是报文交换的一种改进，它将报文分成若干个分组，每个分组的长度有一个上限，有限长度的分组使得每个节点所需的存储能力降低了，分组可以存储到内存中，提高了交换速度。它适用于交互式通信，如终端与主机通信。</p><figure><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200805233942970.png" alt="image-20200805233942970" /><figcaption>image-20200805233942970</figcaption></figure><ul><li>优点：<ol type="1"><li>加速传输（分组是逐个传输的，所以可以使后一个分组的存储操作与前一个分组的转发操作并行；传输一个分组所需缓冲区较小，因此因缓冲区不足而等待发送的概率以及等待时间也会减小）；</li><li>简化了存储管理（分组长度固定，相应缓冲区大小也固定）；</li><li>减少了出错概率和重发数据量(因为分组较短，所以出错概率也较小，这样既提高了可靠性，又降低了传输时延)；</li></ol></li><li>缺点：<ol type="1"><li>存在传输时延（尽管比报文交换的传输时延少，但相对于电路交换，仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力）；</li><li>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组的现象，分组到达目的节点时，要重排，很麻烦；若采用虚电路服务，虽无失序问题，单有呼叫建立、数据传输和虚电路释放3个过程。</li></ol></li></ul><h2 id="电路交换报文交换分组交换的应用场景">10、电路交换、报文交换、分组交换的应用场景</h2><ul><li>传送的数据量很大，且其传送时间远大于呼叫时间--&gt;<strong>电路交换；</strong></li><li>端到端的通路由很多段链路组成--&gt;分组交换；</li><li>从提高整个网络的信道利用率来看，报文交换和分组交换优于电路交换，其中<strong>分组交换比报文交换的时延小，尤其适合计算机之间的突发式的数据通信。</strong></li></ul><h2 id="分组交换的方式无连接的数据报方式面向连接的虚电路方式">11、分组交换的方式（无连接的数据报方式、面向连接的虚电路方式）</h2><ul><li>数据报：<ul><li>发送分组前无需建立连接；</li><li>网络尽最大努力交付，传输不保证可靠性，可能乱序或丢失；</li><li>在具有多个分组的报文中，交换机尚未接收完第二个分组，已经收到的第一个分组就可以转发出去，不仅减小了延迟，而且大大提高了吞吐量；</li><li>当某一台交换机或一段链路故障时，可相应地更新转发表，寻找到另一条替代路径转发分组，对故障适应能力强；</li><li>发送方和接收方不独占某一链路，所以资源利用率高。</li></ul></li><li>虚电路：发送数据之前，在源主机和目的主机之间建立一条虚连接(逻辑上的连接)。<ul><li>用户之间必须建立连接，数据传输过程中不再需要寻找路径，相对数据报方式开销小；</li><li>分组走相同路径，故按序到达；</li><li>分组首部并不包含目的地址，而是包含虚电路标识符，相对数据报方式开销小；</li><li>当某个交换机或某条链路出现故障而彻底失效时，所有经过该交换机或该链路的虚电路将遭到破坏。</li></ul></li></ul><figure><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200805233942970.png" alt="image-20200805233942970" /><figcaption>image-20200805233942970</figcaption></figure><h2 id="传输介质分类">12、传输介质分类</h2><ul><li>导向性传输介质：双绞线（无屏蔽双绞线和屏蔽双绞线）、同轴电缆、光纤；</li><li>非导向性传输介质：短波、微波、红外线与可见光。</li></ul><h2 id="物理层接口特性">13、物理层接口特性</h2><ul><li>机械特性、电气特性、功能特性、规程特性。</li></ul><h2 id="物理层设备中继器集线器">14、物理层设备（中继器、集线器）</h2><h3 id="中继器">14.1 中继器</h3><p>中继器：主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后，因噪声或其他原因而造成失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。其原理是信号再生，而非简单的衰减的信号放大。中继器有两个端口，数据从一个端口输入，从另一个端口输出。端口仅用作信号的电气部分，而不管数据中是否有错误数据或不适用于网段的数据。</p><h3 id="集线器">14.2 集线器</h3><p>集线器实质上是多端口的中继器，也工作在物理层。</p><p>当hub工作时，一个端口接收到数据信号后，由于信号在从端口到hub的传输过程中已经有衰减，所以hub该信号进行整形放大，使之恢复到发送时的状态，紧接着转发到其他处于工作状态的端口。如果同时2个或多个端口输入，那么输出时会发生冲突，致使这些数据都无效。</p><p>从hub的工作方式来看，他在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而不具备信号的定向传送能力，即信号传输的方向是固定的，是一个标准的共享式设备。</p><blockquote><p>中继器、集线器（多端口的中继器，处在网络中心，也叫<code>HUb</code>）。 注意：中继器放大模拟信号，放大器放大数字信号 这俩货的缺点： 1）扩大了冲突域且总的吞吐量未提高； 2）不能互联使用不同以太网技术的局域网。</p></blockquote><h3 id="附加题简述一下cookie-和-session的区别">附加题：简述一下Cookie 和 Session的区别</h3><p>Cookie 和 <strong>Session</strong>都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p>Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构课堂笔记总结</title>
    <link href="/2020/09/28/%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/09/28/%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><div class="note note-warning">            <p>2020.09.28：总结了一些有关数据结构的常见面试问题以及一些书上和笔记上的知识点。</p>          </div></p><h1 id="数据结构常见面试问题">数据结构常见面试问题</h1><h2 id="大o什么意思">大O什么意思？</h2><p>大O表示法：算法的时间复杂度通常用 <u>大O符号</u> 表述，定义为 $T[n] = O(f(n)) $。称函数 T(n)以f(n)为界或者称T(n)受限于f(n)。 如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。当输入量n逐渐加大时，时间复杂度的极限情形称为算法的“渐近时间复杂度”。</p><h2 id="简述数据结构的三要素">简述数据结构的三要素</h2><ul><li>逻辑结构：从逻辑上描述数据，即数据之间的逻辑关系。（线性结构和非线性结构）</li><li>物理结构：数据在计算机内的存储方式（顺序存储，链式存储，索引存储，散列存储）</li><li>数据的运算：数据的运算包括数据的定义与实现，运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</li></ul><h2 id="循环比递归效率高吗">循环比递归效率高吗？</h2><p>并不能绝对的说循环比递归效率高。</p><p>递归的优点是：代码简洁清晰，容易检查代码的正确性。缺点是：当递归调用的次数很多时，对执行效率会有一定的影响。</p><p>循环的优点是：结构简单，速度快；缺点是：并不能解决所有问题，有些问题适合用递归来解决而不适合用循环。</p><h3 id="循环比递归效率高吗-1">循环比递归效率高吗？</h3><p>并不能绝对的说循环比递归效率高。</p><p>递归：</p><ul><li>优点：代码简洁清晰，容易检查代码的正确性。</li><li>缺点：当递归调用的次数很多时，对执行效率会有一定的影响。</li></ul><p>循环：</p><ul><li>优点：结构简单，速度快</li><li>缺点是：并不能解决所有问题，有些问题适合用递归来解决而不适合用循环。</li></ul><h2 id="栈和队列的区别">栈和队列的区别</h2><p>队列和栈都是操作受限的线性表。</p><p>队列是只允许在一段插入，在另一端删除的线性表。进入队列的元素按先入先出的原则进行处理；</p><p>栈是指能在表尾进行插入和删操作的线性表。对于插入到栈的元素按先进后出的规则进行处理，插入和删除操作都在栈顶进行。</p><h2 id="共享栈">共享栈</h2><p>利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，将两个栈的栈底设在共享空间的两端，两个栈顶向共享空间的中间延伸，这样能够更有效的利用存储空间。</p><h2 id="kmp算法">KMP算法</h2><p>思想：如果已匹配相等的前缀序列中有某个后缀正好是子串的前缀，就可以将子串向后滑动到与这些后缀相匹配的位置。</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习-数据结构/kmp.jpg" /></p><h2 id="名词解释满二叉树完全二叉树二叉排序树平衡二叉树">名词解释：满二叉树，完全二叉树，二叉排序树，平衡二叉树。</h2><ul><li>满二叉树：高度为H，结点数为 <span class="math inline">\(2^{H}-1\)</span> 的二叉树为满二叉树。</li><li>完全二叉树：除最后一层外，其余各层的节点数量达到最大值，并且最后一层只能在右侧缺少节点。</li><li>二叉排序树：左子树上所有的关键字均小于根结点，右子树上所有关键字均大于根结点。左子树和右子树又分别是一棵二叉排序树。</li><li>平衡二叉树：树中每一个结点的左子树，右子树高度之差的绝对值小于等于1</li></ul><h2 id="二叉树的存储结构">二叉树的存储结构</h2><ul><li><p>顺序存储：用一组连续的地址单元自上到下，自左到右的存储完全二叉树的结点元素。</p></li><li><p>链式存储：采用二叉链表来存储树的每个节点。二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针 指向该结点的两个孩子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> struct <span class="hljs-title">BTNode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">lchild</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> *<span class="hljs-title">rchild</span>;</span><br>&#125;BTNode;<br></code></pre></td></tr></table></figure></li></ul><h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的dfs遍历，递归和非递归，一个是系统栈，一个是用户栈，为什么用户栈比系统栈效率高？</p><p>答：递归函数申请的系统栈是一个所有递归函数都要通用的栈，系统栈除了会 记录访问过的节点信息，还有其他信息比如函数参数和返回值等等，以实现函 数的递归调用。</p><p>而用户自己定义的栈仅保存遍历所需的节点信息，是一个有针对性的设计，所 以相比之下更高效。</p><h3 id="先序遍历">1、先序遍历：</h3><ol type="1"><li>访问根结点；</li><li>先序遍历左子树；</li><li>先序遍历右子树。</li></ol><ul><li><p>递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(BTBode *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        visit(p);<br>        preorder(p-&gt;lchild);<br>        preorder(p-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>非递归</p><ol type="1"><li><p>根节点入栈</p></li><li><p>循环栈：</p></li></ol><p>​ 1）根节点出栈</p><p>​ 2）右节点入栈</p><p>​ 3）左节点入栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">perorderNonrecursion</span> <span class="hljs-params">(BTNode *bt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (bt != null)<br>    &#123;<br>        BTNode * Stack[N];  <span class="hljs-comment">// 定义一个栈</span><br>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 初始化栈</span><br>        BTNode *p;<br>        Stack[++ top] = p;<br>        <span class="hljs-keyword">if</span> (top != <span class="hljs-number">-1</span>)<br>        &#123;<br>            p = Stack[-- top];<br>            visit(p);<br>            <span class="hljs-keyword">if</span> (p -&gt; rchild != null ) Stack[++ top] = p -&gt; rchild;<br>            <span class="hljs-keyword">if</span> (p -&gt; lchild != null ) Stack[++ top] = p -&gt; lchild;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="中序遍历">2、中序遍历：</h3><ol type="1"><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树。</li></ol><ul><li><p>递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(BTBode *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        preorder(p-&gt;lchild);<br>        visit(p);<br>        preorder(p-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>非递归</p><ol type="1"><li><p>根节点入栈</p></li><li><p>循环栈：</p><p>1）看栈顶是否有左子，有的话，左子一直入栈</p><p>2）（没有左子）输出栈顶（就是“中”）</p><p>3）再看是否有右子，有则右子入栈，再循环2.1</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorderNonrecursion</span> <span class="hljs-params">(BTNode *bt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (bt != null)<br>    &#123;<br>        BTNode * Stack[N];  <span class="hljs-comment">// 定义一个栈</span><br>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 初始化栈</span><br>        BTNode *p;<br>        p = bt;<br>        <span class="hljs-comment">// 中序遍历</span><br>        <span class="hljs-comment">// 栈不空 或者 指针不空 （循环条件）</span><br>        <span class="hljs-keyword">while</span>(top != <span class="hljs-number">-1</span> || p != null)<br>        &#123;<br>         <span class="hljs-keyword">while</span>(p != null)  <span class="hljs-comment">// 左孩子存在，则左孩子入栈</span><br>            &#123;<br>                Stack[++ top] = p;<br>                p = p -&gt; lchild;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (top != <span class="hljs-number">-1</span>)  <span class="hljs-comment">// 栈不空</span><br>            &#123;<br>                p = Stack[top --];  <span class="hljs-comment">// 输出栈顶</span><br>                visit(p);  <span class="hljs-comment">// 访问元素</span><br>                p = p -&gt; rchild;  <br>            &#125;<br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="后序遍历">3、后序遍历</h3><ol type="1"><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点。</li></ol><ul><li><p>递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(BTBode *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        preorder(p-&gt;lchild);<br>        preorder(p-&gt;rchild);<br>        visit(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>非递归</p><ol type="1"><li><p>根节点入栈</p></li><li><p>循环栈：</p><p>1）看栈顶是否有左子，有的话，左子一直入栈</p><p>2）（没有左子）看右子</p><p>​ 右子入栈，再重复2.1</p><p>。。。有问题</p></li></ol></li></ul><h3 id="层序遍历">4、层序遍历</h3><p>若树为空，则什么都不做直接返回。 否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p><p>建立一个队列</p><ol type="1"><li>根节点入队</li><li>出队，访问该节点：<ul><li>如果有左孩子，左孩子入队</li><li>如果有右孩子，右孩子入队</li></ul></li></ol><h2 id="线索二叉树">线索二叉树</h2><ul><li><p>二叉树的非递归遍历避免了系统栈的调用，提高了一定的效率。线索二叉树可以把用户栈也省掉，把二叉树的遍历过程线索化，进一步提高效率。</p></li><li><p>N个结点的二叉链表，N+1个空指针域。</p></li><li><p>将树中的空指针域作为寻找当前结点前驱或后继的线索。</p></li></ul><table><thead><tr class="header"><th style="text-align: center;">lchild</th><th style="text-align: center;">ltag</th><th style="text-align: center;">data</th><th style="text-align: center;">rtag</th><th style="text-align: center;">rchild</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>指针</strong>，指向左孩子</td><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;">0</td><td style="text-align: center;"><strong>指针</strong>，指向右孩子</td></tr><tr class="even"><td style="text-align: center;"><strong>线索</strong>，指向前驱结点</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;">1</td><td style="text-align: center;"><strong>线索</strong>，指向后继结点</td></tr></tbody></table><h2 id="二叉树树森林的转换">二叉树、树、森林的转换</h2><ol type="1"><li><p>树---》二叉树：</p><ul><li><p>同一节点的各孩子用线连接串起来</p></li><li><p>将每个结点的分支从左往右除了第一个，其余都剪掉</p></li></ul></li><li>二叉树---》树：<ul><li>找到一个孩子节点，然后沿着他一直往右下走</li><li>途径的所有的节点都与该孩子的父节点相连；然后断开孩子之间的连线</li></ul></li><li>森林---》二叉树：<ul><li>先将森林里的每一棵树转为二叉树（树的根节点一定是没有右兄弟的，因此转换为二叉树后，根节点一定没有右孩子）</li><li>再将第二棵二叉树转换为第一棵的右子树，以此类推</li></ul></li><li>二叉树---》森林：<ul><li>将根节点有右孩子的二叉树都断开</li><li>再进行二叉树---》树</li></ul></li></ol><ul><li><p>树/森林 的先序遍历 == 二叉树的先序遍历</p><p>树/森林 的后序遍历 == 二叉树的中序遍历</p></li></ul><h2 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h2><ul><li><p><strong>哈夫曼树：又叫最优二叉树。带权路径长度最短。</strong></p><p>构建哈夫曼树：</p><ol type="1"><li>将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。</li><li>构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li><li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</li><li>重复步骤2）和3），直至F中只剩下一棵树为止。</li></ol></li><li><p><strong>哈夫曼编码：通过哈夫曼树导出的每个字符的编码，进而得到对整个字符串的编码（压缩空间）</strong></p><p>哈夫曼编码是前缀码，因为根通往任意叶子节点的路径都不可能是通往其余叶子节点路径的子路径</p><blockquote><p>前缀码中：任意字符的编码串都不是另一字符编码串的前缀。</p><p>用前缀码，在解码时不会发生歧义</p></blockquote><ul><li>权值：字符出现在字符串里的次数（然后构建哈夫曼树）</li><li>对字符的编码：是路径</li></ul></li><li><p><strong>为什么要用哈夫曼树构建前缀码？</strong></p><p><strong>答：</strong>由哈夫曼树的特性可知，其树的带权路径长度是最短的。哈夫曼编码的过程中，每个字符的权值是在字符串中出现的次数，路径长度是每个字符编码的长度。字符出现的次数越多，编码长度越短。这样就使得其整个字符串在编码后的前缀码长度最短。</p><p>哈夫曼编码产生的是最短前缀码。</p></li></ul><h2 id="图的存储结构">图的存储结构</h2><ul><li><strong>邻接矩阵法（顺序存储）（稠密图）</strong>：用一个一维数组存储图的顶点信息，用二维数组存储各顶点的邻接关系。存储顶点邻接关系的二维数组称为邻接矩阵。</li><li><strong>邻接表法（链式存储）（稀疏图）</strong>：图中每个顶点与其有邻接关系的顶点拉成一个单链表，每个顶点都有一个单链表。<ul><li>十字链表法（有向图）：十字链表法是有向图的一种链式存储结构。在十字链表中，有向图中的每一条弧都有一个对应的节点，每个顶点都有对应的一个节点。</li><li>邻接多重表法（无向图）</li></ul></li></ul><h2 id="图的遍历">图的遍历</h2><h3 id="深度优先遍历">深度优先遍历</h3><p>深度优先搜索(DFS:Depth-First-Search)：深度优先搜索类似于树的先序遍历算法</p><ul><li>空间复杂度：<strong>由于DFS是一个递归算法，递归是需要一个工作栈</strong>来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|)</li><li>时间复杂度：<ol type="1"><li><p>邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)</p></li><li><p>邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2)</p></li></ol></li></ul><h3 id="广度优先遍历">广度优先遍历</h3><p>广度优先搜索(BFS:Breadth-First-Search)：广度优先搜索类似于树的层序遍历算法</p><ul><li>空间复杂度：<strong>BFS需要借助一个队列</strong>，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。<br /></li><li>时间复杂度：<ol type="1"><li>邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)</li><li>邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)</li></ol></li></ul><h2 id="图的应用">图的应用</h2><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习-数据结构/tulun.jpg" /></p><h3 id="一最小生成树">一、最小生成树</h3><h3 id="prim算法">1、Prim算法</h3><p><strong>与Dijkstra区别：Dijkstra算法是更新到起始点的距离；Prim是更新到集合S的距离 </strong></p><ul><li><strong>思路：<span class="math inline">\(O(n ^2)\)</span></strong><ol type="1"><li><strong>找集合之外距离最近的点</strong></li><li><strong>标记这个点(并加入集合)</strong></li><li><strong>用这个点 <span class="math inline">\(t\)</span> 更新其他点到集合的距离</strong></li></ol></li><li>双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为<span class="math inline">\(O(n ^2)\)</span> 而且时间复杂度只和n有关，所以适合稠密图</li></ul><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/prim.jpg" /></p><h3 id="kruskal算法">2、Kruskal算法</h3><ul><li><strong>思路：<span class="math inline">\(O(mlogm)\)</span></strong><ol type="1"><li><strong>将图中边按照权值从小到大排列</strong></li><li><strong>然后从最小的边开始枚举。如果该边并入不构成回路的话，将该边并入集合中（当前生成树）。直到所有的边都检测完为止。</strong></li></ol></li><li>概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图</li></ul><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习-数据结构/kruskal.jpg" /></p><h3 id="二最短路径">二、最短路径</h3><h3 id="dijkstra算法">1、Dijkstra算法</h3><ul><li><strong>单源最短路：一个源点到其余顶点的最短路径</strong></li></ul><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习-数据结构/朴素dijstra.jpg" /></p><h3 id="弗洛伊德">2、弗洛伊德</h3><ul><li><strong>多源汇最短路：所有顶点到所有顶点的最短路径（询问从i-&gt;j的最短路）</strong><ul><li>算法思想： 递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1) 其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径</li><li>非带权图</li></ul></li><li>两点之间经过边数最少的路径<ul><li>带权图</li></ul></li><li>两点之间经过的边上权值之和最小的路径</li></ul><h2 id="拓扑排序">拓扑排序</h2><ul><li><p>拓扑排序常用来确定一个依赖关系集中，事物发生的顺序。例如，在日常工作中，可能会将项目拆分成A、B、C、D四个子部分来完成，但A依赖于B和D，C依赖于D。为了计算这个项目进行的顺序，可对这个关系集进行拓扑排序，得出一个线性的序列，则排在前面的任务就是需要先完成的任务。</p></li><li><p>AOV(Activity On Vertex)</p></li><li><p>如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)</p></li><li><p>拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果： 如果此图全部顶点都被输出了，说明它是不存在回路的AOV网； 如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。</p></li><li><p><strong>拓扑排序算法：</strong> 从AOV网中<strong>选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧</strong>。重复这个步骤<u>直到输出图中全部顶点，或者找不到入度为0的顶点为止。</u></p></li><li><p><strong>拓扑排序流程(bfs)：</strong></p><ol type="1"><li><p><strong>遍历所有点找到入度为0的点，把它们入队</strong></p></li><li><p><strong>开始从入度为0的点 找：</strong></p><ol type="1"><li><strong>队头出队</strong></li><li><strong>遍历队头的临边</strong></li><li><p><strong>临边的入度 - 1</strong></p></li><li><p><strong>判断此时入度是否为0：为0说明它可以做新的起点，入队</strong></p></li></ol></li><li><p><strong>return tt == n - 1 (队尾下标是n-1，说明所有点都已经入队)</strong>.</p></li></ol></li></ul><h2 id="aov与aoe的区别">AOV与AOE的区别？</h2><p>相同点：AOV网和AOE网都是有向无环图，<u>区别在于它们的顶点和边所代表的含义是不同的</u>：</p><ul><li>AOV网的顶点：活动，边：仅代表活动之间的关系，无权值。</li><li>AOE网的顶点：事件，边：表示活动，边有权值，表示完成该活动所需要的时间。</li></ul><p><strong>关键路径</strong></p><ul><li>AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。</li></ul><h2 id="查找">查找</h2><ul><li>静态查找：若一个查找表的操作无需动态的修改表，称为静态查找。</li><li>动态查找：需要动态的插入和删除的查找表称为动态查找表。</li><li>平均查找长度：所有查找过程中进行关键字比较次数的平均值。</li></ul><h2 id="顺序查找">顺序查找</h2><p>从线性表的一端开始，逐个比较关键字的值是否满足查询条件。</p><ul><li>优点：对数据元素的存储没有要求，顺序存储或链式存储均可。</li><li>缺点：平均查找长度大，效率低。</li></ul><h2 id="折半查找">折半查找</h2><p>若顺序表有序，先将关键字与表中间元素比较，若相等则查找成功，否则在除中间元素以外的前半部分或后半部分进行同样的查找，如此重复直到查找成功或者确定表中没有要查找的元素，查找失败。</p><ul><li>优点：比顺序查找效率高</li><li>缺点：查找表必须有序且必须采用顺序存储结构。</li></ul><h2 id="分块查找">分块查找</h2><p>将查找表分为若干个子块，块内元素可以无序，各块之间必须有序，也就是说，第一个块内最大的关键字要小于第二个块内所有记录的关键字，第二个块内最大的关键字要小于第三个块内所有记录的关键字以此类推，再建立一张索引表，表项中存放每个块的最大关键字和第一个元素的地址。 查找步骤为：</p><ol type="1"><li>在索引表中确定待查记录所在的块，可以顺序查找也可以折半查找。</li><li>在块内顺序查找。</li></ol><p><u>吸取了顺序查找和折半查找各自的优点。</u></p><h2 id="散列表">散列表</h2><p>散列函数：一个把查找表中关键字映射成为该关键字对应地址的函数。Hash(key)=Addr</p><p>散列表：根据关键字直接进行访问的散列表，建立了关键字与存储地址的直接映射关系。</p><ul><li>散列函数的构造方法：(开除平)</li></ul><ol type="1"><li><strong>开放定址法</strong>：直接取关键字的某个线性函数值为其存储地址。H(key)=a×key+b</li><li><strong>除留余数法</strong>：假定散列表表长为m，取一个不大于m且最接近m的质数p，通过关键字取余p来得到关键字的存储地址。</li><li><strong>平方取中法</strong>：取关键字平方的中间几位作为该关键字的存储地址。</li></ol><ul><li>解决冲突的办法：(线平双)</li></ul><ol type="1"><li><p><strong>开放地址法</strong>：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。</p><ol type="1"><li><p><u>线性探测法</u>：冲突发生时顺序查看表中下一个单元，直到找出一个空闲单元为止。（可能会造成大量元素在相邻的散列地址上堆积，降低查找效率）</p></li><li><p><u>平方探测法</u>：设发生冲突的地址为d,平方探测法得到的新的地址序列为<span class="math inline">\((d+1)^2\)</span>，<span class="math inline">\((d-1)^2\)</span>，<span class="math inline">\((d+2)^2\)</span>，<span class="math inline">\((d-2)^2\)</span>......</p><p>能够避免出现”堆积问题“，但是不能够探测到散列表中的所有单元。</p></li><li><p><u>双散列法</u>：使用两个散列函数，当第一个散列函数出现冲突时，就选用第二个散列函数。</p></li></ol></li><li><p><strong>拉链法</strong>：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非 同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表 由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。</p></li></ol><p>散列表的查找性能：和装填因子有关。α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突 的可能性越小</p><h2 id="排序">排序</h2><ul><li><p>内部排序：排序期间元素全部存放在内存中。（插入，交换，选择，归并，基数）</p></li><li><p>外部排序：排序期间元素无法同时存放在内存中，必须在排序期间根据要求不停地在内，外存移动。（多路归并）</p></li><li><p>排序的稳定性：如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p></li></ul><h2 id="插入排序">插入排序</h2><ul><li><p><strong>直接插入排序</strong>：每次将一个待排序的记录按其关键字的大小插入到已排好序的子序列中。</p><ol type="1"><li><p>从前面的有序子表中查出待插入元素应该插入的位置</p></li><li><p>将已排序的记录逐步向后移动，给待插入元素腾出位置，并将待插入元素复制到插入位置。</p><p>适用顺序存储/链式存储</p></li></ol></li><li><p><strong>折半插入排序</strong>：如果是顺序存储的线性表，可以通过折半查找的方式来查找待插入元素在有序子序列的位置。确定待插入位置之后，可以统一的向后移动位置。</p></li><li><p><strong>希尔排序</strong>：将待排序列按相隔某个增量分割成若干个子序列，对各个子序列进行直接插入排序，逐渐缩小增量，重复上述步骤，直到序列基本有序，再对全体记录进行一次直接插入排序。</p></li></ul><h2 id="交换排序">交换排序</h2><ul><li><p><strong>冒泡排序</strong>：从前到后（从后往前）依次两两比较相邻元素的值，若为逆序，就交换元素，每一趟排序完成之后，就有一个元素被放在最终位置上，重复上述步骤，当一趟排序不发生任何元素的交换为止。</p></li><li><p><strong>快速排序</strong>：快速排序是一种基于分治法的排序方法。</p><p>每一趟快排选择序列中任一个元素作为枢轴(通常选第一个元素)，将序列中比枢 轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。最后确定枢轴元素的最终位置并将枢轴放入，再对枢轴前后得到的子序列再重复上述步骤，直到每部分只有一个元素或为空为止，则所有元素放在最终位置上。</p><ul><li><p>时间复杂度： 最好情况下时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，待排序序列越无序，算法效率越高。 最坏情况下时间复杂度为<span class="math inline">\(O(n^2)\)</span>，待排序序列越有序，算法效率越低。</p></li><li><p>空间复杂度： 由于快速排序是递归的，需要借助一个<strong>递归工作栈</strong>来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。 最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn) 最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；</p></li><li><p>稳定性：快速排序是不稳定的，是因为存在交换关键字。</p></li></ul></li></ul><h2 id="选择排序">选择排序</h2><ul><li><p><strong>简单选择排序</strong>：每趟排序选择关键字最小的元素与序列前面的元素进行交换，每次排序均可确定一个元素的最终位置。</p></li><li><p><strong>堆排序</strong>：先将待排元素建成初始堆，以大根堆为例，堆顶元素为最大值，将其输出后，把堆底元素送入堆顶，此时堆不满足大根堆的性质，将堆顶元素向下调整（从堆的最后一个非叶子节点开始，从左到右，从下到上的顺序进行调整），成为大根堆之后再输出堆顶元素，重复上述过程，直到输出所有元素。</p><ul><li><p>什么是堆？</p><ul><li>堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。<ul><li>如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。</li><li>如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。</li></ul></li></ul></li><li><p>什么是堆排序？</p><ul><li><p>我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。</p></li><li><p>时间复杂度： 堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆</p><p>堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)</p></li><li><p>堆排序不稳定</p></li></ul></li></ul></li></ul><h2 id="归并排序">归并排序</h2><p>“归并”：就是将两个或两个以上的有序表组成一个新的有序表。</p><p>归并排序是分治的思想。先将整个序列分为两半，对每一半分别进行排序，得 到两个有序序列，再将两个序列归并成一个序列即可。</p><blockquote><p>假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1， 然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重 复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。</p></blockquote><p>稳定性：稳定</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习-数据结构/归并快排.jpg" /></p><p>可以发现，<strong>归并排序的处理过程是由下到上的</strong>，先处理子问题，然后再合并。而<strong>快排正好相反，它的处理过程是由上到下的</strong>，先分区，然后再处理子问题。<strong>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法</strong>。我们前面讲过，归并之所以是非原地排序算法，主要原因是<strong>合并函数无法在原地执行</strong>。<strong>快速排序通过设计</strong>巧妙的原地分区函数，<strong>可以实现原地排序。</strong></p><h2 id="基数排序">基数排序</h2><ul><li>基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。</li><li>创建0~9的十个数组，将待排序表的所有元素先按个位进行分类，将分类后的元素按索引大小取出形成新的队列，再对队列按十位，百位的顺序进行分类，重复上述过程，最后形成一个有序序列。</li><li>例子：53, 3, 542, 748, 14, 214, 154, 63, 616<ul><li>补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616</li><li>桶实际是一个队列，先进先出(从桶的上面进，下面出)</li><li>关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10</li></ul></li><li>空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)</li><li>时间复杂度：需要进行关键字位数d次&quot;分配&quot;和&quot;收集&quot;，一次&quot;分配&quot;需要将n个关键字放进各个队列中，一次&quot;收集&quot;需要将r个桶都收集一遍。所以一次&quot;分配&quot;和一次&quot;收集&quot;时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。</li><li>稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。</li></ul><h2 id="选取排序算法需要考虑的因素">选取排序算法需要考虑的因素</h2><ol type="1"><li>待排元素的数目；</li><li>稳定性的要求；</li><li>元素本身信息量的大小；</li><li>关键字的结构及其分布情况；</li></ol><p>若n较小，可直接采用直接插入排序或者简单选择排序。由于直接插入排序比简单选择排序移动的元素要多，所以当元素本身信息量比较大时可选用简单选择排序。 若待排序表已基本有序可以选用直接插入排序或者冒泡排序。</p><p>当n比较大时，可以选用快速排序、堆排序、归并排序。快速排序被认为是当前基于比较的内部排序中最好的排序方法，当待排序表记录随机分布时，使用快速排序速度最快。堆排序所用存储空间少于快速排序，且不会出现快速排序的最坏情况，这两种算法都是不稳定的，若要稳定排序则选用归并排序算法。</p><h2 id="外部排序">外部排序</h2><p>采用多路归并法，包括两个相对独立的阶段： （1）根据内部缓冲区的大小，将待排文件分成若干个大小合适的子文件，将子文件带入内存采用内部排序算法排序完成后再写回外存。 （2）对这些归并段进行逐趟归并，使归并段逐渐由小到大，直到得到整个有序文件为止。</p><h2 id="提高外部排序算法的效率">提高外部排序算法的效率</h2><p>由于待排文件无法全部放入内存，所以排序期间必须要频繁的进行内外存之间数据的交换，这会耗费大量的时间。所以可以通过增加归并路数来减少归并趟数，进而减少I/O次数。而增加归并路数又会增加内部排序的时间，所以引入了败者树。 增加初始归并段个数，并且不受内存空间的限制，引入了置换-选择算法。 文件经过置换-选择算法之后得到的是长度不同的初始归并段，如何组织长度不等的出使归并段的归并顺序，使得I/O次数最少，就引入了最佳归并树。</p><h2 id="败者树大的为失败者小的为胜利者">败者树（大的为失败者，小的为胜利者）</h2><p>可视为一棵完全二叉树，每个叶结点存放各归并段在归并过程中参加比较的记录，非叶结点用来记录左右子树中的“失败者”，胜利者继续向上比较直到根节点。输出最后的胜利者。</p><h2 id="置换选择算法">置换选择算法</h2><p>根据缓冲区的大小，由外存读入记录，当记录充满缓冲区时，选择最小的输出，其空缺位置由下一个记录来取代，输出记录称为当前初始归并段的一部分，如果新输出的记录比新建立归并段最大的记录小，就不能成为该归并段的一部分，只能成为下一个归并段的选择。重复上述步骤，直到缓冲区中所有记录都比当前归并段最大记录小时，就生成了一个初始归并段，用同样的方法继续生成下一个归并段，直到全部记录都处理完毕为止。</p><h2 id="最佳归并树">最佳归并树</h2><p>对于K路归并算法，可用构造K叉哈夫曼树的方法来构造最佳归并树。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World！</title>
    <link href="/2020/09/24/World/"/>
    <url>/2020/09/24/World/</url>
    
    <content type="html"><![CDATA[<p>耶嘿！小张的宇宙空间站正式开通啦！</p><p>这里将记录小张的成长过程！</p><p>小张同学加油！</p><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/codedog.jpg" style="zoom:50%;" /></p>]]></content>
    
    
    <categories>
      
      <category>小张日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小张日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
