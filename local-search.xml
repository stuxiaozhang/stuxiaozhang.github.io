<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2022/04/03/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2022/04/03/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="kmp算法-思路">KMP算法 思路</h2><p>KMP 是一个字符串匹配算法。使用场景是这样的：给定一个主串 s，以及一个子串 p。子串 p 在主串 s 中多次作为子串出现。求出子串 p 在 s 中所有出现的位置的起始下标。（n为子串p的长度，m为主串s串的长度）</p><p>读完这个题，我们首先能想到的方式就是一个暴力的动作hh。就是两个指针扫就完了。暴力的做法就是对于每一个 i，都去和 j 一起往后扫描看二者是否相等，不等的话就继续下一个 i（把 p串 往后移一位）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[i + j - <span class="hljs-number">1</span>] != p[j])<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>KMP 算法是对暴力的这种一一对比的方法进行了优化，时间复杂度由 <span class="math inline">\(O(n^2)\)</span> 降低为 <span class="math inline">\(O(m + n)\)</span>。</p><p><strong>KMP 核心思想</strong>：在每次匹配不相等时，不是把 p串 往后移一位，而是把 p串 往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找 Next[ ] 数组确定的。</p><p>即，KMP 算法分为两步：</p><ol type="1"><li>计算 Next 数组（针对子串 p 而言）</li><li>子串 p 和 主串 s 进行匹配</li></ol><h3 id="next-数组的性质">Next 数组的性质</h3><p>首先要清楚几个定义：</p><ul><li>“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。</li><li><p>“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。</p></li><li><p><strong><span class="math inline">\(Next[i]\)</span> 表示子串 p 中以 j (下标从1开始) 结尾的非平凡后缀能匹配 p 的前缀的最大长度。</strong> (或者说 <span class="math inline">\(j\)</span> 是 p 的每个最长公共前后缀中的前缀的尾坐标)</p><p>即 <span class="math inline">\(Next[i]=j\)</span> 表示：<code>p[1, j] = p[i - j + 1, i]</code></p></li></ul><p><strong>Next 数组的性质：</strong></p><p><code>Next[i] = j</code>：<code>p[1, j] = p[i - j + 1, i]</code></p><p><img src="https://cdn.acwing.com/media/article/image/2020/04/28/6828_2f9f9aa689-KMP_1.png" /></p><p><code>Next[j] = k</code>：<code>p[1, k] = p[j - k + 1, j]</code></p><p><img src="https://cdn.acwing.com/media/article/image/2020/04/28/6828_333abd1289-KMP_2.png" /></p><p>就是说，若以 i 结尾的非平凡后缀能匹配 p 的前缀的最大长度为 <code>Next[i]</code>，那么它能匹配的次长前缀长度为 <code>Next[Next[i]]</code>，以此类推，<code>Next[Next[Next[i]]]⋯</code> 直至匹配长度为 0 为止。</p><p>这是一条很重要的性质，是KMP算法的关键，它与子串 p 在主串 p 中发生失配时的下一步操作有关。</p><h3 id="kmp-匹配过程">KMP 匹配过程</h3><p>下面模拟 <span class="math inline">\(Next[ ]\)</span> 在匹配过程中的作用。</p><p>已知主串 s 和子串 p。且 p 的 <span class="math inline">\(Next[]\)</span> 数组已经求出来了，当前主串 s 匹配到下标 i−1 位置，子串 p 匹配到下标 j 位置，即满足 <span class="math inline">\(S[i−j:i−1]==P[1:j]\)</span>，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220404112803.png" /></p><ol type="1"><li><span class="math inline">\(S[i]==P[j+1]\)</span>，则 j 后移一位，表示这一位匹配成功.<ul><li><p>此时如果 j 到达了 p 串的末尾，说明 p 在 s 中出现了，在 s 中的起始下标为 <span class="math inline">\(i−|P|+1\)</span>。</p><p>Note：j 接下来不是回到 p串 起始处重新在 s 中找下一个位置，而是 继续从 <span class="math inline">\(j = Next[j]\)</span> 的位置继续匹配。</p><p>举个栗子，比如子串是 <span class="math inline">\(abcdabcd\)</span>，主串是 <span class="math inline">\(abcdabcdabfg...\)</span>。在匹配到 <span class="math inline">\(s[8] == p[7 + 1]\)</span> 的时候，j 后移一位，刚好 <span class="math inline">\(j == m\)</span>，找到一个匹配的输出。此时 j 无需从 p 的起始再开始，而是从 <span class="math inline">\(j = Next[8] = 4\)</span> 开始继续看二者的下一位比较即可。</p></li><li>如果还没到，继续看 s 的下一位，即 <code>i ++</code></li></ul></li><li><span class="math inline">\(S[i]≠P[j+1]\)</span>，发生失配，此时不需要从头开始匹配。因为 s 和 p 一路匹配过来的，所以 3串 和 2 串是相同的。通过 Next 数组知道 1串 和 2串 是相同的，所以可以推出 1串和 3串 是相同的。所以下一次匹配完全不用从 s 串的下一位开始，直接从相同缀的下一位开始匹配就行了。如下图所示：</li></ol><p><img src="https://cdn.acwing.com/media/article/image/2020/04/28/6828_3c59de6e89-KMP_4.png" /></p><ul><li>如何用代码描述子串 p 移动的过程呢？</li></ul><p>我理解：大家所说的 <strong>失配后 j 回退的过程，我将其看作将 p 向后移动的过程</strong>。也就是说这两个动作是相反的。</p><p>p 向后移动的过程，就是令 <span class="math inline">\(j=Next[j]\)</span>。然后我们只需要再比较 <span class="math inline">\(S[i]\)</span> 与 <span class="math inline">\(P[j+1]\)</span> 是否匹配即可。如果不匹配就需要不断回退 <span class="math inline">\(j=Next[j]\)</span>，其实就是不断用 p 中已经能与 s 中以 <span class="math inline">\(i−1\)</span> 结尾的后缀匹配的前缀，减少中间多余匹配过程，在不断失配的过程中，所使用的 p 的前缀长度递减，直至为 0。如果经过某次 j 的回退，满足了 <span class="math inline">\(S[i]==P[j+1]\)</span>，那么 j 就可以后移了。图中表现的是，经过一次回退，就能成功匹配的情况（都是蓝色的小方块）。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220404153407.png" /></p><p>以上就是 KMP 算法的匹配过程，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// n为子串p的长度，m为主串s串的长度 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = Next[j]; <span class="hljs-comment">// 失配j就不断回退</span><br>    <span class="hljs-comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span><br>    <span class="hljs-comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span><br>    <br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j++; <span class="hljs-comment">//当前元素匹配，j移向p串下一位</span><br>    <span class="hljs-keyword">if</span> (j == n)  <span class="hljs-comment">// p在s中完整出现</span><br>    &#123;<br>        <span class="hljs-comment">//匹配成功，进行相关操作</span><br>        j = Next[j];  <span class="hljs-comment">//继续匹配下一个子串</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="next-数组求解">Next 数组求解</h3><p>理解了上述匹配过程，<span class="math inline">\(Next[ ]\)</span> 的求解就不难理解了。我们可以把 <span class="math inline">\(Next[ ]\)</span> 的求解过程看成是两个相同的串 p 匹配的过程。</p><p>首先对于 p 串，显然有 <span class="math inline">\(Next[1]=0\)</span>（因为只考虑非平凡前/后缀），然后两个指针 <span class="math inline">\(i=2,j=0\)</span> 开始，考虑 <span class="math inline">\(P[i]\)</span> 与 <span class="math inline">\(P[j+1]\)</span> 是否匹配，如果不匹配，那么 <span class="math inline">\(j=Next[j]\)</span> 不断回退，直到回退到匹配长度为 0 或者某一个 j 能满足 <span class="math inline">\(P[i]==P[j+1];\)</span> 如果 <span class="math inline">\(P[i]==P[j+1]\)</span> ，j 后移，说明以 p 中以 i 结尾的非平凡后缀能匹配 p 的前缀的最大长度为 j，因此 <span class="math inline">\(Next[i]=j\)</span>。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220403111436.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>&#123;<br>    <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="hljs-number">1</span>]) j = Next[j];<br><br>    <span class="hljs-keyword">if</span>(p[i] == p[j+<span class="hljs-number">1</span>]) j++;<br>    Next[i] = j;  <span class="hljs-comment">// 更新Next</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>其实 KMP的核心就是匹配的时候不必每次都从下一个 i 开始，只要从后缀（最长的公共串）开始继续匹配即可。而 Next 数组记录了每个 i 对应的最长公共前后缀的长度(也可以说是前缀的尾坐标)。</p><p>KMP 模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">char</span> s[N], p[N];<br><span class="hljs-keyword">int</span> ne[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// p+1，s+1是让读入之后字符串的下标会从1开始。也可以写成scanf(“%s”, p + 1)</span><br>    <br>    <span class="hljs-comment">// 求 Next 数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">// 不等于</span><br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <br>        <span class="hljs-comment">// 等于</span><br>        <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        ne[i] = j;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m ; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <br>        <span class="hljs-keyword">if</span>(s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        <span class="hljs-keyword">if</span>(j == n)<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; i - n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2022/03/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/03/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找">二分查找</h1><h2 id="思路">思路</h2><p><strong>二分关键词：“最大值最小”，“最小值最大”，“平均值最大/最小”</strong></p><p>一个题目，如果一个区间具有单调性质，那么一定可以二分，但是如果说这道题目没有单调性质，而是具有某种区间性质的话，我们同样可以使用二分.<strong>（不用单调性，有二段性：满足一段而不满足另一段，两段连上！）</strong></p><p>每次都要选择答案所在区间进行下一步处理：</p><ol type="1"><li>确定一个区间，使得目标一定在区间中。</li><li>找一个性质，满足：<ol type="1"><li>性质具有二段性（答案是性质的边界）所有二分都成立</li><li><strong>答案是二段性的分界点</strong></li></ol></li></ol><p>Note：一定要好好分析 <code>check()</code> 函数</p><h2 id="整数二分">整数二分</h2><h3 id="整数二分思路">整数二分思路</h3><p>在一个范围内，查找一个数字，要求找到这个元素的起始位置和结束位置，请注意这个范围内的数字都是单调递增的，即具有单调性质.</p><h3 id="模板code">模板code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l; <br>&#125;<br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 一定要加1</span><br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题">例题</h3><h4 id="acwing-789.-数的范围"><a href="https://www.acwing.com/problem/content/description/791/">1. Acwing 789. 数的范围</a></h4><blockquote><p>模板题</p></blockquote><h5 id="思路-1">思路</h5><p>需要写两个二分，一个需要找到 &gt;=x 的第一个数，另一个需要找到 &lt;=x 的最后一个数</p><p>1、<strong>查找大于等于x的第一个位置</strong></p><p>就是看 mid 是否满足右区间</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220401141638.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br><span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br><span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、<strong>查找小于等于x的第一个位置（查找大于等于x的最后一个位置）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220401141701.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br><span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 一定要加1！</span><br><span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为什么这里一定要 <strong>加 1</strong> 呢？</li></ul><p>答：因为如果按照上一个二分的写法，循环判断条件还是l &lt; r，当只有两个元素比如“2 2”时，l指向第一个元素，r指向第二个元素，mid指向第一个元素即 mid = l，q[mid] &lt;= x，l = mid还是指向第一个元素，指针不移动了，陷入死循环了，此刻 l + 1 == r，未能退出循环。</p><ul><li>为什么查找大于等于x的第一个位置不会死循环？</li></ul><p>因为这时就算只有两个元素，l + 1 = r，mid = l，q[mid] &lt; x 时 l 是会+1的，不小于 x 时r = mid也会缩小区间。而查找小于等于x的第一个位置之所以会死循环是因为编程语言里面除以2的下取整性，试想下如果l + 1 = r时， mid = r 呢，q[mid] &lt;= x，l = mid = r，区间缩小；否则r = mid - 1 = l 区间缩小，l都会与r相遇。就不会死循环。</p><h5 id="code">code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> q[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        <br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 找左端点，即: 大于等于x的第一个位置</span><br>        <span class="hljs-keyword">while</span>(l &lt; r)<br>        &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果找到的这个&gt;=x 的最小整数 不是x，说明数组里就没有x</span><br>        <span class="hljs-keyword">if</span> (q[l] != x) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-1 -1&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            r = n - <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-comment">// 找右端点，即: 小于等于x的第一个位置</span><br>            <span class="hljs-keyword">while</span>(l &lt; r)<br>            &#123;<br>                <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span>&gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <br>            <span class="hljs-built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><h3 id="浮点数二分思路">浮点数二分思路</h3><ul><li><p>将区间 <code>[l, r]</code> 划分成 <code>[l, mid]</code> 和 <code>[mid, r]</code></p></li><li><p>当区间长度足够小时就停止。一般是<strong>多2位</strong>！</p><p>比如题目要求小数点后六位，你就写 <code>while(r - l &gt; 1e-8)</code></p></li></ul><h3 id="模板code-1">模板code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l, <span class="hljs-keyword">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> ((r - l) &gt; eps)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题-1">例题</h3><h4 id="acwing-790.-数的三次方根"><a href="https://www.acwing.com/problem/content/792/">1. AcWing 790. 数的三次方根</a></h4><blockquote><p>模板题</p></blockquote><h5 id="code-1">code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>    <br>    <span class="hljs-keyword">double</span> l = <span class="hljs-number">-10000</span>, r = <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-keyword">while</span> ((r - l) &gt; <span class="hljs-number">1e-8</span>)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid * mid &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在-stl-中的二分查找">在 stl 中的二分查找</h2><p><code>lower_bound( )</code> 和 <code>upper_bound( )</code>都是利用二分查找的方法在一个<u>排好序的数组中</u>进行查找的。</p><p>在从小到大的排序数组中，</p><p><strong>lower_bound( begin,end,num)</strong>：从数组的begin位置到end-1位置二分查找<strong>第一个<u>大于或等于</u>num的数字，找到返回该数字的地址</strong>，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><strong>upper_bound( begin,end,num)</strong>：从数组的begin位置到end-1位置二分查找<strong>第一个<u>大于</u>num的数字，找到返回该数字的地址，</strong>不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2022/03/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><p>归并排序思路：</p><ol start="0" type="1"><li><strong>注意递归要退出！记得写退出条件！</strong></li><li>确定分界点：<code>int mid = l + r &gt;&gt; 1 ;</code> (下标的中心值)</li><li>递归排序 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code></li><li>归并：将左右两个有序序列 合并成一个有序序列</li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331113606.png" style="zoom: 60%;" /></p><p><strong>归并排序和快速排序的区别：</strong></p><ol type="1"><li><p>归并排序的分界点是整个区间的中心位置，下标的中间值</p><p>而快排的分界点是从当前这个区间随机一个数组的<strong>值</strong>(一般我们选取数组中间位置的<strong>数</strong>)</p></li><li><p>归并的关键是：合二为一</p><p>快排的关键是：划分成两段</p></li><li><p>归并：稳定</p><p>快排：不稳定（可以改为稳定的，按照 &lt;<span class="math inline">\(a_i, i\)</span>&gt; ，变成 pair，双关键字进行排序）</p></li></ol><blockquote><p>稳定是指：原序列中的两个相同的数，排序后，相对位置不发生变化。</p></blockquote><p><strong>模板code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_sort(q, l, mid);          <span class="hljs-comment">// 递归排序左右边</span><br>    merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// k是当前tmp数组里有多少数</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br>    &#125;<br><br>    <span class="hljs-comment">// 左半边或右半边可能没有循环完，只要拿过来放入就行</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-comment">// 结果存入tmp里面去了，得拿回来</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331113325.png" /></p><h2 id="例题">例题</h2><h3 id="acwing-787.-归并排序"><a href="https://www.acwing.com/problem/content/789/">1. AcWing 787. 归并排序</a></h3><blockquote><p>模板题</p></blockquote><h3 id="acwing-788.-逆序对的数量"><a href="https://www.acwing.com/problem/content/790/">2. AcWing 788. 逆序对的数量</a></h3><h4 id="题目">题目</h4><p>给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</p><p><strong>样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><h4 id="思路">思路</h4><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331141954.png" /></p><p>这个题可以使用分治法解决问题：将序列从中间分开，将逆序对分成三类(如上图所示)：</p><ol type="1"><li>两个元素都在左边；</li><li>两个元素都在右边；</li><li>两个元素一个在左 一个在右</li></ol><p><strong>我觉得其实递归到最深处，只有第三种情况，前两个就是描述这个递归的过程，只是用来帮助理解，事实上不存在。归并排序的递归过程的边界就是区间只有1个数，所以就是第三种情况。</strong><font color='red'>通过代码验证，确实不需要相加，将 res 定义为全局变量，直接递归左边和右边，不需要将二者加和，也可以ac。</font></p><p>可以注意到一个重要的性质，左右半边的元素在各自区间任意调换顺序，是不影响第三步计数的，因为第三步是左右区间各取一个数进行比较。因此我们可以数完就给它排序。这么做的好处在于，如果序列是有序的，会让第三步计数很容易。其实这个双指针还是归并排序中“归并”的过程，只不过在归并时，顺便计算他后面有几个数，即：<code>mid - i + 1</code></p><p>如果无序暴力数的话这一步是 <span class="math inline">\(O(n^2)\)</span> 的。</p><p><strong>Note</strong></p><ol type="1"><li>注意结果数据范围会爆int，所以 <code>res</code> 和 <code>merge_sort()</code> 要用 <code>long long</code> 数据类型。</li></ol><p><strong>code</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N], tmp[N];<br>LL res;<br><br><span class="hljs-function">LL <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_sort(q, l, mid);<br>    merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tmp[k ++ ] = q[j ++ ];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>, i = l; i &lt;= r; i ++ , k ++ ) q[i] = tmp[k];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; merge_sort(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟链表</title>
    <link href="/2022/03/20/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/03/20/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>关于链表的题，一般都是写成结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    Node *next;<br>&#125;<br></code></pre></td></tr></table></figure><p>面试用的比较多。每次都需要 new 一个新节点，要调用 new 函数。</p><p>算法题中多用数组模拟链表，单链表一般用于存储图和树，双链表用于优化某些题。</p><h1 id="单链表">单链表</h1><ul><li><code>idx</code>：当前节点的下标</li><li><code>e[idx]</code>：当前节点的值</li><li><code>ne[idx]</code>：下一个节点的位置下标 (节点的next指针)</li><li><code>head</code>：头指针（我理解为 <code>ne[头]</code>，头指针指向的下一个节点的下标，初始是指向链表的末尾 <strong>-1</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331104210.png" /></p><p>操作命令可能为以下几种：</p><ol type="1"><li><code>H x</code>，表示向链表头插入一个数 x。</li><li><code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li><li><code>I k x</code>，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li></ol><p><strong>Note：</strong></p><ol type="1"><li>idx 初始化时从0开始，第1个插入的数下标为0，所以第 k 个插入的数下标为 k - 1</li><li>删除头节点可以看成是指向下一个被插入的节点：<code>head = ne[head]</code></li></ol><p><strong>code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//往头节点位置插入x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = head;<br>    head = idx;<br>    idx ++ ;<br>&#125;<br><br><span class="hljs-comment">//往idx = k 的位置后插入x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = ne[k];<br>    ne[k] = idx;<br>    idx ++ ;<br>&#125;<br><br><span class="hljs-comment">//删除idx = k 后面的节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m;<br><br>    init();<br><br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> k, x;<br>        <span class="hljs-keyword">char</span> op;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;H&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            add_to_head(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;D&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            <span class="hljs-keyword">if</span> (!k ) head = ne[head];   <span class="hljs-comment">// 删除头节点可以看成是指向下一个被插入的节点</span><br>            <span class="hljs-keyword">else</span> remove(k - <span class="hljs-number">1</span>);         <span class="hljs-comment">// 第 k-1 个输入才是idx</span><br>        &#125;           <br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            insert(k - <span class="hljs-number">1</span>, x);<br>        &#125;<br><br>    &#125;<br><span class="hljs-comment">// 从 head 开始，也就是 头的下一个节点开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head; i != <span class="hljs-number">-1</span>; i = ne[i]) <span class="hljs-built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双链表">双链表</h1><ul><li><code>idx</code>：当前节点的下标</li><li><code>e[idx]</code>：当前节点的值</li><li><code>r[idx]</code>：当前节点的右边节点的位置下标 (节点的 right 指针)</li><li><code>l[idx]</code>：当前节点的左边节点的位置下标 (节点的 left 指针)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331111811.png" /></p><p>作命令可能为以下几种：</p><ol type="1"><li><code>L x</code>，表示在链表的最左端插入数 x。</li><li><code>R x</code>，表示在链表的最右端插入数 x。</li><li><code>D k</code>，表示将第 k 个插入的数删除。</li><li><code>IL k x</code>，表示在第 k 个插入的数左侧插入一个数。</li><li><code>IR k x</code>，表示在第 k 个插入的数右侧插入一个数。</li></ol><p><strong>Note:</strong></p><ol type="1"><li><p>插入 与 删除操作 都是针对 下标为 idx 的节点的右节点。然后对 idx 的左节点的操作都可以写为 <code>l[idx]</code></p><blockquote><p>例如在下标为 idx 的左边插入一个点相当于在 <code>l[idx]</code>右边插入一个点</p></blockquote></li><li><p>插入操作需要注意顺序：<strong>idx 的 左右指针先与两边节点连上，然后先右节点指向 idx，再 idx 指向左节点</strong>。</p></li></ol><p><strong>code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> idx, e[N], l[N], r[N];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 0和1已经用过了</span><br>&#125;<br><br><span class="hljs-comment">// 在下标是k的点的右边，插入一个点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    r[idx] = r[k];<br>    l[idx] = k;<br>    l[r[k]] = idx;<br>    r[k] = idx;<br>    idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除第k个店</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br><br>    init();<br><br>    <span class="hljs-keyword">while</span>(n -- )<br>    &#123;<br>        <span class="hljs-built_in">string</span> op;<br>        <span class="hljs-keyword">int</span> x, k;<br><br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;L&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            add(<span class="hljs-number">0</span>, x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;R&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            add(l[<span class="hljs-number">1</span>], x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;D&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            remove(k + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;IL&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            add(l[k + <span class="hljs-number">1</span>], x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            add(k + <span class="hljs-number">1</span>, x);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 从 0 的下一个位置的元素开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">1</span>;i = r[i]) <span class="hljs-built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速选择</title>
    <link href="/2022/03/18/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/"/>
    <url>/2022/03/18/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p><strong>快速选择算法</strong>是快速排序的一种变形。通常用在<strong>未排序的数组中寻找第k小/第k大的元素</strong>。快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是<strong>只递归进入一边的元素中继续寻找</strong>。这降低了平均时间复杂度，从 <span class="math inline">\(O(n logn)\)</span> 至 <span class="math inline">\(O(n)\)</span> ，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span> 。</p><p><em><a id="more"></a></em></p><h1 id="快速选择算法">快速选择算法</h1><p>快速选择算法是快速排序的一种变形。通常用<strong>在未排序的数组中寻找第k小/第k大的元素</strong>。</p><h2 id="思路">思路</h2><p>快速选择的总体思路与快速排序一致。（先快排）</p><ol type="1"><li><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</li><li><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</li><li><strong>递归处理k在的一端</strong>：快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。直至 <code>if (l &gt;= r) return q[l];</code> 。其中 <code>q[l]</code> 或者 <code>q[r]</code> 都可以，因为最后一次递归数组里只有一个数，就是要找的数。</li></ol><h2 id="快速选择模板">快速选择模板</h2><p><strong>快速选择算法：类似快排+二分，k在哪半部分，就递归哪个部分。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quick_select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];  <span class="hljs-comment">// q[l]/q[r]都可以，因为最后一次递归数组里只有一个数</span><br>    <br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> left_num = j - l + <span class="hljs-number">1</span>;  <span class="hljs-comment">// left_num: 左边的数有多少个</span><br>    <br>    <span class="hljs-keyword">if</span> (k &lt;= left_num) quick_select(q, l, j, k);  <span class="hljs-comment">// 递归左半边</span><br>    <span class="hljs-keyword">else</span> quick_select(q, j + <span class="hljs-number">1</span>, r, k - left_num);  <span class="hljs-comment">// 递归右半边</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间复杂度">时间复杂度</h2><p>快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 <span class="math inline">\(O(n logn)\)</span> 至 <span class="math inline">\(O(n)\)</span> ，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span> 。</p><p>第一层：<span class="math inline">\(O(n)\)</span></p><p>第二层：<span class="math inline">\(O(n/2)\)</span></p><p>第三层：<span class="math inline">\(O(n/4)\)</span></p><p>...</p><p>所以：<span class="math inline">\(O(n·(1 + \frac{1}{2}+ \frac{1}{4} + ... + \frac{1}{n})) &lt;= O(2n) = O(n)\)</span></p><h2 id="例题">例题</h2><h3 id="acwing-786.-第k个数"><a href="https://www.acwing.com/problem/content/788/">1. AcWing 786. 第k个数</a></h3><p>给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span>。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个整数（所有整数均在 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(10^9\)</span>范围内），表示整数数列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示数列的第k小数。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(1≤n≤100000\)</span>, <span class="math inline">\(1≤k≤n\)</span></p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><blockquote><p>模板题</p></blockquote><p><strong>code</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;algorithm&gt;</span><br><br>using namespace std;<br><br>const <span class="hljs-built_in">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">int</span> q[N];<br><span class="hljs-built_in">int</span> n, k;<br><br><span class="hljs-built_in">int</span> quick_select(<span class="hljs-built_in">int</span> q[], <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r, <span class="hljs-built_in">int</span> k)<br>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];  // q[l]/q[r]都可以，因为最后一次递归数组里只有一个数<br>    <br>    <span class="hljs-built_in">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        do i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        do j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">int</span> left_num = j - l + <span class="hljs-number">1</span>;  // left_num: 左边的数有多少个<br>    <br>    <span class="hljs-keyword">if</span> (k &lt;= left_num) quick_select(q, l, j, k);  // 递归左半边<br>    <span class="hljs-keyword">else</span> quick_select(q, j + <span class="hljs-number">1</span>, r, k - (j - l + <span class="hljs-number">1</span>));  // 递归右半边<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];<br>    <br>    cout &lt;&lt; quick_select(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acwing-104.-货仓选址"><a href="https://www.acwing.com/problem/content/106/">2. AcWing 104. 货仓选址</a></h3><p>题意是：在一条数轴上，有很多商店，选一个点，让其到所有商店距离最小。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330144746.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> res;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    sort(a, a + n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res += <span class="hljs-built_in">abs</span>(a[i] - a[(n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
      <tag>快速选择</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2022/03/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>第一次是在数据结构课学的快速排序。基本思路是：令 <code>i = l; j = r</code> ，选最左边的数为pivot。<code>j --</code> 从后向前找比它小的数，找到后与pivot交换。再 <code>i ++</code> 从前往后找比它大的数，找到后与pivot交换。再重复执行这一过程，直到 <code>i == j</code> 时，就找到了pivot的位置。再分别递归直至顺序。学了y总的方法感觉更聪明，是一种双指针快排的思路。</p><p><em><a id="more"></a></em></p><h1 id="快速排序算法双指针排序">快速排序算法(双指针排序)</h1><h2 id="思路">思路</h2><p>快排属于分治算法，一般分三步：</p><ol start="0" type="1"><li><p><strong>注意递归要退出！记得写退出条件！<code>if(l &gt;= r)</code> 时退出</strong></p></li><li><p><strong>分成子问题</strong>：</p><ul><li><p><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</p></li><li><p><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</p></li></ul></li><li><p><strong>递归处理子问题</strong>：即递归处理左右两端 (又回到0)</p></li><li><p>子问题合并. 快排这一步不需要操作，但归并排序的核心在这一步骤</p></li></ol><div class="note note-info">            <p>分治算法都有三步：</p><ol start="0" type="1"><li><p>确定递归退出条件</p></li><li>分成子问题</li><li>递归处理子问题</li><li><p>子问题合并</p></li></ol>          </div><h2 id="快排模板">快排模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 0. 循环退出条件</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;  <br><span class="hljs-comment">// 1. 分成子问题。</span><br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意值和下角标的区别。</span><br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 2. 递归处理子问题</span><br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);  <span class="hljs-comment">// 边界不要写错</span><br>    <span class="hljs-comment">// 3. 子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间复杂度">时间复杂度</h2><p>平均时间复杂度 <span class="math inline">\(O(nlogn)\)</span>，最坏情况下 <span class="math inline">\(O(n^2)\)</span>，在数组已排好序的情况下出现，可以通过随机化或者取中点来避免最差情况。</p><blockquote><p>数学推导证明过程挺复杂的。算法导论上有，用主定理证明的，很详细。但是没法简化</p></blockquote><h2 id="注意">注意</h2><h3 id="待证问题">1. 待证问题</h3><p>while循环结束后，<code>q[l..j] &lt;= x</code>, <code>q[j+1..r] &gt;= x</code></p><p>注: <code>q[l..j] &lt;= x</code> 意为 <code>q[l],q[l+1]...q[j-1],q[j]</code> 的所有元素都 <code>&lt;= x</code></p><p><strong>证明:</strong> 循环不变式：<code>q[l..i] &lt;= x q[j..r] &gt;= x</code></p><ol type="1"><li><p>初始化</p><p>循环开始之前 <code>i = l - 1, j = r + 1</code></p><p>则 <code>q[l..i]</code>, <code>q[j..r]</code> 为空，循环不变式显然成立</p></li><li><p>保持</p><p>假设某轮循环开始前循环不变式成立，即<code>q[l..i] &lt;= x, q[j..r] &gt;= x</code></p><p>执行循环体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>会使得 q[l..i<span class="hljs-number">-1</span>] &lt;= x, q[i] &gt;= x<br><br><span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>会使得 q[j+<span class="hljs-number">1.</span>.r] &gt;= x, q[j] &lt;= x<br><br><span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>会使得 q[l..i] &lt;= x, q[j..r] &gt;= x<br></code></pre></td></tr></table></figure><p>所以，i 和 j 更新之后，下一次循环开始之前，循环不变式依然成立</p><p>注意: 由于使用 do-while 循环,所以 <code>i</code> 和 <code>j</code> 一定会!!!自增!!!使得循环会继续下去,但是如果采用while循环(<code>i</code> 和 <code>j</code> 的初始化做出对应的变更), <code>i</code> 和 <code>j</code> 在特殊情况下不自增的话,循环就会卡死</p><p>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(q[i] &lt; x) i++;<br><span class="hljs-keyword">while</span>(q[j] &gt; x) j--;<br></code></pre></td></tr></table></figure><p>当 <code>q[i]</code> 和 <code>q[j]</code> 都为 x 时, i 和 j 都不会更新, 导致 while 陷入死循环</p></li><li><p>终止</p><p>循环结束时，<code>i &gt;= j</code></p><p>正常情况下，按照循环不变式，我们应该会觉得结果已经显然了</p><p>因为<code>i &gt;= j, q[l..i] &lt;= x, q[j..r] &gt;= x</code></p><p>所以按照 <code>j</code> 来划分的话，<code>q[l..j] &lt;= x, q[j+1..r] &gt;= x</code>是显然的</p><p>可是，最后一轮循环有点特殊，因为<strong>最后一轮循环的 if 语句一定不会执行</strong></p><p>因为最后一轮循环一定满足 i &gt;= j, 不然不会跳出 while 循环的，所以 if 语句一定不执行</p><p><strong>正确分析</strong>：</p><p>由于最后一轮的 if 语句一定不执行</p><p>所以，只能保证 <code>i &gt;= j</code> 和 <code>q[l..i-1] &lt;= x, q[i] &gt;= x</code>和<code>q[j+1..r] &gt;= x, q[j] &lt;= x</code></p><p>由 <code>q[l..i-1] &lt;= x，i &gt;= j(i-1 &gt;= j-1)</code> 和 <code>q[j] &lt;= x</code> 可以得到 <code>q[l..j] &lt;= x</code></p><p>又因为 <code>q[j+1..r] &gt;= x</code></p><p>所以，<code>q[l..j] &lt;= x,q[j+1..r] &gt;= x</code>, <strong>问题得证</strong></p><p><strong>总结</strong>: 只有最后一轮循环结束时，循环不变式不成立，其余的循环都是成立的, 但最终要求的问题还是解决了</p><p><strong>注意</strong>: 循环结束时要记得检查是否存在数组越界/无限递归的情况</p><p>所以还需要证明 <code>j</code> 最终的取值范围是 <code>[l..r-1]</code> (即不存在<code>n</code>划分成<code>0</code>和<code>n</code>的无限递归情况), 分析过程在分析<code>2.5</code></p></li></ol><h3 id="边界情况分析">2. 边界情况分析</h3><p>快排属于<strong>分治算法</strong>，最怕的就是 <code>n分成0和n</code>，或 <code>n分成n和0</code>，这会造成<strong>无限划分</strong>(死循环)</p><ol type="1"><li><p><strong>以 <code>j</code> 为划分时，<code>x</code> 不能选 <code>q[r]</code> (若以 <code>i</code> 为划分,则 <code>x</code> 不能选 <code>q[l]</code> )</strong></p><p>假设 <code>x = q[r]</code>：关键句子 <code>quick_sort(q, l, j), quick_sort(q, j + 1, r)</code></p><p>因为 <code>j</code> 的最小值是 <code>l</code>，所以 <code>[j + 1, r]</code> 不会造成无限划分，</p><p>但<code>[l..j]</code>(即 <code>quick_sort(q, l, j)</code> )却可能造成无限划分，因为 <code>j</code> 可能为 <code>r</code></p><p>举例来说，若 <code>x</code> 选为 <code>q[r]</code> ，数组中 <code>q[l..r-1] &lt; x</code> ，</p><p>那么这一轮循环结束时 <code>i = r, j = r</code>，这就造成了无限划分。</p><p>以 <code>0, 1</code> 这组数据为例，<code>x = q[r] = 1</code>，<code>do i ++ ; while(q[i] &lt; x)</code> ，</p><p>则 <code>i = 1 = r</code> ，<code>do j -- ; while(q[j] &gt; x)</code> ，则 <code>j = 1 = r</code> 。</p><p>则 <code>[0, 1]</code> 被划分成 <code>[0, 1]</code> 和 <code>[2, 1]</code> ，这就造成无限划分，即死循环。</p><blockquote><p>边界情况复杂，建议 <code>x = q[l + r &gt;&gt; 1]</code> 。</p></blockquote></li><li><p><strong><code>do i++; while(q[i] &lt; x)</code> 和 <code>do j--; while(q[j] &gt; x)</code> 不能用 <code>q[i] &lt;= x</code> 和 <code>q[j] &gt;= x</code>。</strong></p><p>举个栗子，比如 取的 <code>x</code> 刚好是数据里的最大值，执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>i+1</code>，交换的时候就是 <code>q[i + 1]</code> 和 <code>q[j]</code> 交换了，这显然不对。</p><p>或者举个极端情况，假设 <code>q[l..r]</code> 全相等，则执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>r+1</code>，然后继续执行 <code>q[i] &lt;= x</code> 判断条件，造成数组下标越界(但这貌似不会报错)。</p><p>并且如果之后的 <code>q[i] &lt;= x</code> (此时 <code>i &gt; r</code> ) 条件也不幸成立，就会造成一直循环下去(亲身实验)，造成内存超限 <code>(Memory Limit Exceeded)</code></p></li><li><p><code>if(i &lt; j) swap(q[i], q[j])</code> 能否使用 <code>i &lt;= j</code> ？</p><p><strong>可以使用 <code>if(i &lt;= j) swap(q[i], q[j]);</code></strong></p><p>因为 i = j 时，交换一下 <code>q[i],q[j]</code> 也就是交换自己，无影响，马上就会跳出循环了</p></li><li><p>最后一句能否改用 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 作为划分(用 <code>i</code> 做划分时也是同样的道理,)</p><p><strong>不能</strong>。根据之前的证明，最后一轮循环可以得到这些结论</p><ul><li><code>q[l..i-1] &lt;= x, q[i...r] &gt;= x</code></li><li><code>q[l...j] &lt;= x, q[j+1..r] &gt;= x</code></li><li><code>j &lt;= i</code></li></ul><p>所以，<code>q[l..j-1] &lt;= x</code> 是显然成立的，</p><p>但 <code>quick_sort(q, j, r)</code> 中的 <code>q[j]</code> 却是 <code>q[j] &lt;= x</code> ，这不符合快排的要求</p><p>另外一点，注意 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 可能会造成无线划分</p><p>当 <code>x</code> 选为 <code>q[l]</code> 时会造成无限划分，报错为(MLE),</p><p>如果手动改为 <code>x = q[r]</code>，可以避免无限划分。</p><p>但是上面所说的 <code>q[j] &lt;= x</code> 的问题依然不能解决，这会造成 <code>WA (Wrong Answer)</code></p></li><li><p><strong><code>j</code> 的取值范围为 <code>[l..r-1]</code></strong> (这块还是不太懂....)</p><p>证明：<strong>反证法</strong></p><p>假设 <code>j</code> 最终的值为 <code>r</code> ,说明只有一轮循环(两轮的话 <code>j</code> 至少会自减两次)</p><p>说明 <code>q[r] &lt;= x</code> (因为要跳出 <code>do-while</code> 循环)</p><p>说明 <code>i &gt;= r</code>( <code>while</code> 循环的结束条件), <code>i</code> 为 <code>r</code> 或 <code>r + 1</code>(必不可能成立)</p><p>说明 <code>i</code> 自增到了 <code>r</code> , 说明 <code>q[r] &gt;= x</code> 和 <code>q[l..r-1] &lt; x</code>，</p><p>得出 <code>q[r] = x</code> 和 <code>q[l..r-1] &lt; x</code> 的结论，但这与 <code>x = q[l + r &gt;&gt; 1]</code> 矛盾</p><p><strong>反证法</strong>得出 <code>j &lt; r</code></p><p>假设 <code>j</code> 可能小于 <code>l</code> 说明 <code>q[l..r] &gt; x</code> ,矛盾</p><p><strong>反证法</strong>得出 <code>j &gt;= l</code></p><p>所以 <code>j</code> 的取值范围为 <code>[l..r-1]</code> ，不会造成无限划分和数组越界</p></li></ol><p>顺带一提用 <code>i</code> 做划分时的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];  <span class="hljs-comment">// 注意是向上取整,因为向下取整可能使得x取到q[l]</span><br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    quick_sort(q, l, i - <span class="hljs-number">1</span>), quick_sort(q, i, r);  <span class="hljs-comment">// 不用q[l..i],q[i+1..r]划分的道理和分析4中j的情况一样</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还有从大到小排序的模板(仅仅改两个地方的判断符号)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &gt; x);  <span class="hljs-comment">// 这里和下面</span><br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &lt; x);  <span class="hljs-comment">// 这行的判断条件改一下</span><br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);<br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="元素值-和-q角标-的区别">3. <code>元素值</code> 和 <code>q[角标]</code> 的区别</h3><p>我之前一直搞错了角标的问题。正确写法是 <code>x = q[l + r &gt;&gt; 1]</code> ，我总是写成 <code>x = l + r &gt;&gt; 1; ...q[i] &lt; q[x]</code>。好蠢，一直没弄清楚 <strong><code>元素值</code> 和 <code>q[角标]</code> 的区别</strong>。<code>元素值</code> 就是一个数字，而 <code>q[角标]</code> 表示角标所在位置的值，相当于一个坑。快排在交换元素时，可能这个坑里的元素会有变化，而快排想要的仅仅是一个作为比较的值，模板里选了中间位置的元素值，而不是这个位置的数(也就是位置的角标)。之前一直没想通这个问题，直到模拟了一个错误样例才想明白。</p><blockquote><p>错误样例为：49，59，88，37，98，97，68，54，31，3</p></blockquote><p>以后遇到错误也要<u>多模拟样例</u>，自己想明白才是真的明白，不然也不会背了四五遍模板也记不清楚。</p><hr /><h2 id="例题">例题</h2><h3 id="acwing-785.-快速排序"><a href="https://www.acwing.com/problem/content/787/">1. AcWing 785. 快速排序</a></h3><p>模板题。</p><p><strong>code</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;    <br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ;i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    quick_sort(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TextCNN 的 PyTorch 实现</title>
    <link href="/2022/03/15/TextCNN%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/15/TextCNN%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="textcnn-的-pytorch-实现">TextCNN 的 PyTorch 实现</h1><p>本文主要介绍一篇将 CNN 应用到 NLP 领域的一篇论文 <a href="https://www.aclweb.org/anthology/D14-1181.pdf">Convolutional Neural Networks for Sentence Classification</a>，然后给出 PyTorch 实现。</p><p>论文比较短，总体流程不太复杂，最主要的是下面这张图，只要理解了这张图，就知道如何写代码了。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131223.png" /></p><p>下图的 feature map 是将一句话中的各个词通过 Word Embedding 得到的，feature map 的宽为 embedding 的维度，长为一句话的单词数量。例如下图中，很明显就是用一个 6 维的向量去编码每个词，并且一句话中有 9 个词。</p><p>之所以有两张 feature map，可以理解为 batchsize 为 2。</p><p>其中，红色的框代表的就是卷积核。而且很明显可以看出，这是一个长宽不等的卷积核。有意思的是，卷积核的宽可以认为是 n-gram，比方说下图卷积核宽为 2，所以同时考虑了 &quot;wait&quot; 和 &quot;for&quot; 两个单词的词向量，因此可以认为该卷积是一个类似于 bigram 的模型</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131248.png" style="zoom: 50%;" /></p><p>后面的部分就是传统 CNN 的步骤，激活、池化、Flatten</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131333.png" style="zoom: 50%;" /></p><h3 id="代码实现pytorch-版">代码实现（PyTorch 版）</h3><p>源码来自于 <a href="https://github.com/graykode/nlp-tutorial">nlp-tutorial</a>，<a href="https://wmathor.com/index.php/archives/1445/">王铃鑫同学</a>在其基础上进行了修改。</p><p>导入库.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br>dtype = torch.FloatTensor<br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br></code></pre></td></tr></table></figure><p>定义一些数据，以及设置一些常规参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 3 words sentences (=sequence_length is 3)</span><br>sentences = [<span class="hljs-string">&quot;i love you&quot;</span>, <span class="hljs-string">&quot;he loves me&quot;</span>, <span class="hljs-string">&quot;she likes baseball&quot;</span>, <span class="hljs-string">&quot;i hate you&quot;</span>, <span class="hljs-string">&quot;sorry for that&quot;</span>, <span class="hljs-string">&quot;this is awful&quot;</span>]<br>labels = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 1 is good, 0 is not good.</span><br><br><span class="hljs-comment"># TextCNN</span><br>embedding_size = <span class="hljs-number">2</span><br>sequence_length = <span class="hljs-built_in">len</span>(sentences[<span class="hljs-number">0</span>])  <span class="hljs-comment"># every sentences contains sequence_length(=3) words</span><br>num_classes =<span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels))  <span class="hljs-comment"># 几分类，这里是二分类</span><br>batch_size = <span class="hljs-number">3</span><br><br>word_list = <span class="hljs-string">&quot; &quot;</span>.join(sentences).split()<br>vocab = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(word_list))<br>vocab_size = <span class="hljs-built_in">len</span>(vocab)<br>word2idx = &#123;w:i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(vocab)&#125;<br></code></pre></td></tr></table></figure><p>数据预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_data</span>(<span class="hljs-params">sentences, labels</span>):</span><br>    inputs = []<br>    <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> sentences:<br>        inputs.append([word2idx[word] <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> sen.split()])  <span class="hljs-comment"># 把sentences中的每个句子拿出来，分成单词，找到对应idx加入 inputs</span><br>        <br>    targets = []<br>    <span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> labels:<br>        targets.append(out)   <span class="hljs-comment"># To using Torch Softmax Loss function</span><br>        <br>    <span class="hljs-keyword">return</span> inputs, targets<br><br>input_batch, targets_batch = make_data(sentences, labels)<br>input_batch, targets_batch = torch.LongTensor(input_batch), torch.LongTensor(targets_batch)<br><br>dataset = Data.TensorDataset(input_batch, targets_batch)<br>loader = Data.DataLoader(dataset, batch_size, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div class="note note-primary">            <ul><li><code>TensorDataset</code> 可以用来对 tensor 进行打包，把数据放在数据库中, 就好像 python 中的 zip 功能。该类通过每一个 tensor 的第一个维度进行索引。</li><li><code>DataLoader</code> 从数据库中每次抽出 batch size 个样本</li></ul>          </div><p>构建 TextCNN 模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextCNN</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TextCNN, self).__init__()<br>        self.W = nn.Embedding(vocab_size, embedding_size)<br>        output_channel = <span class="hljs-number">3</span><br>        self.conv = nn.Sequential(<br>            <span class="hljs-comment"># conv : [input_channel(=1), output_channel, (filter_height, filter_width), stride=1]</span><br>            nn.Conv2d(<span class="hljs-number">1</span>, output_channel, (<span class="hljs-number">2</span>, embedding_size)),  <span class="hljs-comment"># [batch_size, output_channel * 2 * 1]</span><br>            nn.ReLU(),<br>            <span class="hljs-comment"># pool : ((filter_height, filter_width))</span><br>            nn.MaxPool2d((<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)),<br>        )<br>        <span class="hljs-comment"># fc</span><br>        self.fc = nn.Linear(output_channel, num_classes)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        X: [batch_size, sequence_length]</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        batch_size = X.shape[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 因为测试的时候不知道有几个句子，所以在这里动态的获取一下</span><br>        embedding_X = self.W(X)  <span class="hljs-comment"># [batch_size, sequence_length, embedding_size]</span><br>        <br>        embedding_X = embedding_X.unsqueeze(<span class="hljs-number">1</span>)  <span class="hljs-comment"># add channel(=1) [batch, channel(=1), sequence_length, embedding_size]</span><br>        conved = self.conv(embedding_X)  <span class="hljs-comment"># 卷积之后：[batch_size, output_channel，1，1]</span><br>        <br>        flatten = conved.view(batch_size, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># [batch_size, output_channel * 1 * 1]</span><br>        output = self.fc(flatten)<br>        <br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><p>详细介绍一下数据在网络中流动的过程中维度的变化:</p><p>输入数据是个矩阵，矩阵维度为 <code>[batch_size, sequence_length]</code>，输入矩阵的数字代表的是某个词在整个词库中的索引（下标）</p><p>首先通过 Embedding 层，也就是查表，将每个索引转为一个向量，比方说 <code>12</code> 可能会变成 <code>[0.3,0.6,0.12,...]</code>，因此整个数据无形中就增加了一个维度，变成了 <code>[batch_size, sequence_length, embedding_size]</code></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144253.png" style="zoom: 67%;" /></p><p>之后使用 <code>unsqueeze(1)</code> 函数使数据增加一个维度，变成 <code>[batch_size, 1, sequence_length, embedding_size]</code>。现在的数据才能做卷积，因为在传统 CNN 中，输入数据就应该是 <code>[batch_size, in_channel, height, width]</code> 这种维度</p><p><code>[batch_size, 1, 3, 2]</code> 的输入数据通过 <code>nn.Conv2d(1, 3, (2, 2))</code> 的卷积之后，得到的就是 <code>[batch_size, 3, 2, 1]</code> 的数据，由于经过 ReLU 激活函数是不改变维度的，所以就没画出来。最后经过一个 <code>nn.MaxPool2d((2, 1))</code> 池化，得到的数据维度就是 <code>[batch_size, 3, 1, 1]</code></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144327.png" style="zoom:80%;" /></p><p>训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">model = TextCNN().to(device)<br>criterion = nn.CrossEntropyLoss().to(device)<br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    <span class="hljs-keyword">for</span> batch_x, batch_y <span class="hljs-keyword">in</span> loader:<br>        batch_x, batch_y = batch_x.to(device), batch_y.to(device)<br>        pred = model(batch_x)<br>        loss = criterion(pred, batch_y)<br>        <br>        <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>) % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">&#x27;Epoch:&#x27;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch + <span class="hljs-number">1</span>), <span class="hljs-string">&#x27;loss=&#x27;</span>, <span class="hljs-string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(loss))<br>            <br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Test</span><br>test_text = <span class="hljs-string">&#x27;i hate me&#x27;</span><br>tests = [[word2idx[n] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> test_text.split()]]<br>test_batch = torch.LongTensor(tests).to(device)<br><br><span class="hljs-comment"># Predict</span><br>model = model.<span class="hljs-built_in">eval</span>()<br>predict = model(test_batch).data.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> predict[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>    print(test_text,<span class="hljs-string">&quot;is Bad Mean...&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(test_text,<span class="hljs-string">&quot;is Good Mean!!&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Word2Vec 的 PyTorch 实现（乞丐版）</title>
    <link href="/2022/03/10/Word2Vec%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B9%9E%E4%B8%90%E7%89%88%EF%BC%89/"/>
    <url>/2022/03/10/Word2Vec%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B9%9E%E4%B8%90%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="word2vec-的-pytorch-实现乞丐版">Word2Vec 的 PyTorch 实现（乞丐版）</h1><p>自然语言处理问题中，一般以词作为基本单元，例如我们想要分析 &quot;我去过华盛顿州&quot; 这句话的情感，一般的做法是先将这句话进行分词，变成<code>我</code>，<code>去过</code>，<code>华盛顿州</code>，由于神经网络无法处理词，所以我们需要将这些词通过某些办法映射成词向量。词向量是用来表示词的向量，也可被认为是词的特征向量。<strong>把词映射为实数域向量的技术也叫词嵌入（word embedding）</strong></p><p>源码来自于 <a href="https://github.com/graykode/nlp-tutorial">nlp-tutorial</a>，<a href="https://wmathor.com/index.php/archives/1443/">王铃鑫大佬</a>在其基础上进行了修改：</p><p>导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optimizer<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>dtype = torch.FloatTensor<br></code></pre></td></tr></table></figure><p>文本预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">sentences = [<span class="hljs-string">&quot;jack like dog&quot;</span>, <span class="hljs-string">&quot;jack like cat&quot;</span>, <span class="hljs-string">&quot;jack like animal&quot;</span>,<br>  <span class="hljs-string">&quot;dog cat animal&quot;</span>, <span class="hljs-string">&quot;banana apple cat dog like&quot;</span>, <span class="hljs-string">&quot;dog fish milk like&quot;</span>,<br>  <span class="hljs-string">&quot;dog cat animal like&quot;</span>, <span class="hljs-string">&quot;jack like apple&quot;</span>, <span class="hljs-string">&quot;apple like&quot;</span>, <span class="hljs-string">&quot;jack like banana&quot;</span>,<br>  <span class="hljs-string">&quot;apple banana jack movie book music like&quot;</span>, <span class="hljs-string">&quot;cat dog hate&quot;</span>, <span class="hljs-string">&quot;cat dog like&quot;</span>]<br><br>sentence_list = <span class="hljs-string">&quot; &quot;</span>.join(sentences).split()  <br><span class="hljs-comment"># [&#x27;jack&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;, &#x27;jack&#x27;, &#x27;like&#x27;, &#x27;cat&#x27;, &#x27;animal&#x27;,...]</span><br><span class="hljs-comment">#     0      1       2       0      1       3       4</span><br><br><span class="hljs-comment"># 去个重，构建词汇的语料库</span><br>vocab = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(sentence_list))<br><span class="hljs-comment"># vocab = sorted(set(sentence_list), key=sentence_list.index)  # 我自己写的，为了保持原句子的顺序</span><br><br>word2idx = &#123;w:i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(vocab)&#125;<br><span class="hljs-comment"># &#123;&#x27;hate&#x27;: 0, &#x27;cat&#x27;: 1,...</span><br>vocab_size = <span class="hljs-built_in">len</span>(vocab)<br></code></pre></td></tr></table></figure><p>模型相关参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Word2Vec Parameters</span><br>C = <span class="hljs-number">2</span> <span class="hljs-comment"># window size</span><br>batch_size = <span class="hljs-number">8</span><br>embedding_size = <span class="hljs-number">2</span>  <span class="hljs-comment"># 2 dim vector represent one word</span><br></code></pre></td></tr></table></figure><p>数据预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">skip_grams = []<br><span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(C, <span class="hljs-built_in">len</span>(sentence_list) - C):<br>    center = word2idx[sentence_list[idx]]  <span class="hljs-comment"># 中心词的位置</span><br>    context_idx = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(idx - C, idx)) + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(idx + <span class="hljs-number">1</span>, idx + C + <span class="hljs-number">1</span>))  <span class="hljs-comment"># 左边的背景词 + 右边的背景词</span><br>    context = [word2idx[sentence_list[i]] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> context_idx]  <span class="hljs-comment"># 这个地方是 背景词索引 找出 背景词</span><br><span class="hljs-comment">#     print(context)</span><br>    <br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> context:<br>        skip_grams.append([center, w])<br></code></pre></td></tr></table></figure><p>假设所有文本分词，转为索引之后的 list 如下图所示. 根据论文所述，设定 window size=2，即每个中心词左右各取 2 个词作为背景词，那么对于上面的 list，窗口每次滑动，选定的中心词和背景词如下图.</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328130934.png" /></p><p>那么 skip_grams 变量里存的就是中心词和背景词一一配对后的 list，例如中心词 <code>2</code>，有背景词 <code>0,1,0,1，</code>一一配对以后就会产生 <code>[2,0],[2,1],[2,0],[2,1]</code>。skip_grams 如下图所示.</p><p>输入的是 one-hot 向量，“1”的位置就是中心词. 由于 Word2Vec 的输入是 one-hot 表示，所以我们先构建一个对角全 1 的矩阵，利用 <code>np.eye(rows)</code> 方法，其中的参数 rows 表示全 1 矩阵的行数，对于这个问题来说，语料库中总共有多少个单词，就有多少行</p><p>然后根据 skip_grams 每行第一列的值，取出相应全 1 矩阵的行。将这些取出的行，append 到一个 list 中去，最终的这个 list 就是所有的样本 X。标签不需要 one-hot 表示，只需要类别值，所以只用把 skip_grams 中每行的第二列取出来存起来即可</p><p>最后就是构建 dataset，然后定义 DataLoader</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131035.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用中心词生成背景词的概率</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_data</span>(<span class="hljs-params">skip_grams</span>):</span><br>    input_data = []<br>    output_data = []<br>    <br>    <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> skip_grams:<br>        input_data.append(np.eye(vocab_size)[a])  <span class="hljs-comment"># 就是数组里的数相当于在onehot数组里的位置是1</span><br>        output_data.append(b)<br><br>    <span class="hljs-keyword">return</span> input_data, output_data<br><br><br>input_data, output_data = make_data(skip_grams)<br>input_data, output_data = torch.Tensor(input_data), torch.LongTensor(output_data)<br>dataset = Data.TensorDataset(input_data, output_data)<br>loader = Data.DataLoader(dataset, batch_size, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><code>np.eye()</code> 的函数，除了生成对角阵外，还可以将一个label数组，大小为(1,m)或者(m,1)的数组，转化成one-hot数组。</p><p>例如 可以将类别总数为6的 <code>labels=[1,2,3,0,1,1]</code> 的数组转化成数组 <code>[[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0],[0,0,0,0,0,0],[0,1,0,0,0,0],[0,1,0,0,0,0]]</code> 这就是所谓的one-hot的形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">labels=np.array([[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>]])<br>print(<span class="hljs-string">&quot;labels的大小：&quot;</span>,labels.shape,<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>因为我们的类别是从0-2，所以这里是3个类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a=np.eye(<span class="hljs-number">3</span>)[<span class="hljs-number">1</span>]<br>print(<span class="hljs-string">&quot;如果对应的类别号是1，那么转成one-hot的形式&quot;</span>,a,<span class="hljs-string">&quot;\n&quot;</span>)<br>--&gt; 如果对应的类别号是1，那么转成one-hot的形式 [0. 1. 0.]<br></code></pre></td></tr></table></figure>          </div><p>定义模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义模型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Word2Vec</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(Word2Vec, self).__init__()<br>        self.W = nn.Parameter(torch.randn(vocab_size, embedding_size).<span class="hljs-built_in">type</span>(dtype))<br>        self.V = nn.Parameter(torch.randn(embedding_size, vocab_size).<span class="hljs-built_in">type</span>(dtype))<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-comment"># X: [batch_size, vocab_size]</span><br>        hidden = torch.mm(X, self.W)  <span class="hljs-comment"># [batch_size, m]</span><br>        output = torch.mm(hidden, self.V)  <span class="hljs-comment"># [batch_size, vocab_size]</span><br>        <span class="hljs-keyword">return</span> output<br>    <br>    <br>model = Word2Vec().to(device)<br>loss_fn = nn.CrossEntropyLoss().to(device)<br>optim = optimizer.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br></code></pre></td></tr></table></figure><p>训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># train</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000</span>):<br>    <span class="hljs-keyword">for</span> i, (batch_x, batch_y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(loader):<br>        <span class="hljs-comment"># 先移到cuda上去</span><br>        batch_x = batch_x.to(device)<br>        batch_y = batch_y.to(device)<br>        pred = model(batch_x)<br>        loss = loss_fn(pred, batch_y)<br>        <br>        <span class="hljs-keyword">if</span>(epoch + <span class="hljs-number">1</span>) % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            print(epoch + <span class="hljs-number">1</span>, i, loss.item())<br>            <br>        optim.zero_grad()<br>        loss.backward()<br>        optim.step()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NNLM 的 PyTorch 实现</title>
    <link href="/2022/03/10/NNLM%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/10/NNLM%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="nnlm-的-pytorch-实现">NNLM 的 PyTorch 实现</h1><h2 id="a-neural-probabilistic-language-model">A Neural Probabilistic Language Model</h2><p>本文算是训练语言模型的经典之作，Bengio 将神经网络引入语言模型的训练中，并得到了词向量这个副产物。词向量对后面深度学习在自然语言处理方面有很大的贡献，也是获取词的语义特征的有效方法</p><p>其主要架构为三层神经网络，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330140630.png" style="zoom:50%;" /></p><p>现在的任务是输入 <span class="math inline">\(w_{t−n+1},...,w_{t−1}\)</span> 这前 n-1 个单词，然后预测出下一个单词 <span class="math inline">\(w_t\)</span></p><p>数学符号说明：</p><ul><li><span class="math inline">\(C(i)\)</span>：单词 <span class="math inline">\(w\)</span> 对应的词向量，其中 <span class="math inline">\(i\)</span> 为词 <span class="math inline">\(w\)</span> 在整个词汇表中的索引</li><li><span class="math inline">\(C\)</span>：词向量，大小为 <span class="math inline">\(|V|×m\)</span> 的矩阵</li><li><span class="math inline">\(|V|\)</span>：词汇表的大小，即预料库中去重后的单词个数</li><li><span class="math inline">\(m\)</span>：词向量的维度，一般大于 50</li><li><span class="math inline">\(H\)</span>：隐藏层的 weight</li><li><span class="math inline">\(d\)</span>：隐藏层的 bias</li><li><span class="math inline">\(U\)</span>：输出层的 weight</li><li><span class="math inline">\(b\)</span>：输出层的 bias</li><li><span class="math inline">\(W\)</span>：输入层到输出层的 weight</li><li><span class="math inline">\(h\)</span>：隐藏层神经元个数</li></ul><p>计算流程：</p><ol type="1"><li>首先将输入的 <span class="math inline">\(n−1\)</span> 个单词索引转为词向量，然后将这 <span class="math inline">\(n−1\)</span> 个向量进行 concat，形成一个 <span class="math inline">\((n−1)×w\)</span> 的矩阵，用 <span class="math inline">\(X\)</span> 表示</li><li>将 <span class="math inline">\(X\)</span> 送入隐藏层进行计算，<span class="math inline">\(hidden_{out}=tanh⁡(d+X∗H)\)</span></li><li>输出层共有 <span class="math inline">\(|V|\)</span> 个节点，每个节点 <span class="math inline">\(y_i\)</span> 表示预测下一个单词 <span class="math inline">\(i\)</span> 的概率，<span class="math inline">\(y\)</span> 的计算公式为 <span class="math inline">\(y=b+X∗W+hidden_{out}∗U\)</span></li></ol><h2 id="代码实现pytorch">代码实现（PyTorch）</h2><p>导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><br>dtype = torch.FloatTensor<br></code></pre></td></tr></table></figure><p>数据预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">sentences = [ <span class="hljs-string">&quot;i like dog&quot;</span>, <span class="hljs-string">&quot;i love coffee&quot;</span>, <span class="hljs-string">&quot;i hate milk&quot;</span>]<br><br><span class="hljs-comment"># 将空格加入到单词之间，然后按空格隔开组成一个list</span><br>word_list = <span class="hljs-string">&quot; &quot;</span>.join(sentences).split()  <span class="hljs-comment"># [&#x27;i&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;, &#x27;i&#x27;, &#x27;love&#x27;, &#x27;coffee&#x27;, &#x27;i&#x27;, &#x27;hate&#x27;, &#x27;milk&#x27;]</span><br><br><span class="hljs-comment"># 构建词汇表，词汇表需要去重，再转换成list</span><br>word_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(word_list))  <span class="hljs-comment"># [&#x27;i&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;, &#x27;love&#x27;, &#x27;coffee&#x27;, &#x27;hate&#x27;, &#x27;milk&#x27;]</span><br><br><br>word_dict = &#123;w: i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word_list)&#125;  <span class="hljs-comment"># &#123;&#x27;i&#x27;:0, &#x27;like&#x27;:1, &#x27;dog&#x27;:2, &#x27;love&#x27;:3, &#x27;coffee&#x27;:4, &#x27;hate&#x27;:5, &#x27;milk&#x27;:6&#125;</span><br>number_dict = &#123;i: w <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word_list)&#125;  <span class="hljs-comment"># &#123;0:&#x27;i&#x27;, 1:&#x27;like&#x27;, 2:&#x27;dog&#x27;, 3:&#x27;love&#x27;, 4:&#x27;coffee&#x27;, 5:&#x27;hate&#x27;, 6:&#x27;milk&#x27;&#125;</span><br>n_class = <span class="hljs-built_in">len</span>(word_dict)  <span class="hljs-comment"># number of Vocabulary, just like |V|, in this task n_class=7（维度，有多少词就是多少行）</span><br><br><br><span class="hljs-comment"># NNLM(Neural Network Language Model) Parameter</span><br><span class="hljs-comment"># n_step = 2  # 输入数据的长度，这里就是两个单词</span><br>n_step = <span class="hljs-built_in">len</span>(sentences[<span class="hljs-number">0</span>].split())-<span class="hljs-number">1</span>  <span class="hljs-comment"># n-1 in paper, look back n_step words and predict next word. In this task n_step=2</span><br>n_hidden = <span class="hljs-number">2</span>  <span class="hljs-comment"># h in paper</span><br>m = <span class="hljs-number">2</span>  <span class="hljs-comment"># m in paper, word embedding dim</span><br></code></pre></td></tr></table></figure><p>由于 PyTorch 中输入数据是以 mini-batch 小批量进行的，下面的函数首先将原始数据（词）全部转为索引，然后通过 <code>TensorDataset()</code> 和 <code>DataLoader()</code> 编写一个实用的 mini-batch 迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_batch</span>(<span class="hljs-params">sentences</span>):</span><br>    input_batch = []<br>    target_batch = []<br>    <br>    <span class="hljs-comment"># 遍历每一条句子</span><br>    <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> sentences:<br>        word = sen.split()  <span class="hljs-comment"># [&#x27;i&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;]</span><br>        <span class="hljs-comment"># 只要前两个词作为输入，最后一个词是预测的</span><br>        <span class="hljs-built_in">input</span> = [word_dict[n] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> word[:-<span class="hljs-number">1</span>]]  <span class="hljs-comment"># [0, 1], [0, 3], [0, 5]</span><br>        target = word_dict[word[-<span class="hljs-number">1</span>]]  <span class="hljs-comment"># 2, 4, 6</span><br><br>        input_batch.append(<span class="hljs-built_in">input</span>)  <span class="hljs-comment"># [[0, 1], [0, 3], [0, 5]]</span><br>        target_batch.append(target)  <span class="hljs-comment"># [2, 4, 6]</span><br><br>    <span class="hljs-keyword">return</span> input_batch, target_batch<br><br><br>input_batch, target_batch = make_batch(sentences)<br><span class="hljs-comment"># 需要将 list 转换为 tensor</span><br>input_batch = torch.LongTensor(input_batch)<br>target_batch = torch.LongTensor(target_batch)<br><br>dataset = Data.TensorDataset(input_batch, target_batch)<br><br>loader = Data.DataLoader(dataset=dataset, batch_size=<span class="hljs-number">16</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>定义网络结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义网络结构</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NNLM</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(NNLM, self).__init__()<br>        self.C = nn.Embedding(n_class, m)  <span class="hljs-comment"># 有多少行，</span><br>        self.H = nn.Parameter(torch.randn(n_step * m, n_hidden).<span class="hljs-built_in">type</span>(dtype))<br>        self.W = nn.Parameter(torch.randn(n_step * m, n_class).<span class="hljs-built_in">type</span>(dtype))<br>        self.d = nn.Parameter(torch.randn(n_hidden).<span class="hljs-built_in">type</span>(dtype))<br>        self.U = nn.Parameter(torch.randn(n_hidden, n_class).<span class="hljs-built_in">type</span>(dtype))<br>        self.b = nn.Parameter(torch.randn(n_class).<span class="hljs-built_in">type</span>(dtype))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        X: [batch_size, n_step]  batch_size：选几个数据，n_step 列</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        X = self.C(X) <span class="hljs-comment"># [batch_size, n_step] =&gt; [batch_size, n_step, m]</span><br>        X = X.view(-<span class="hljs-number">1</span>, n_step * m)  <span class="hljs-comment"># [batch_size, n_step * m] 维度变为2维</span><br>        hidden_out = torch.tanh(self.d + torch.mm(X, self.H))  <span class="hljs-comment"># [batch_size, n_hidden]</span><br>        output = self.b + torch.mm(X, self.W) + torch.mm(hidden_out, self.U)  <span class="hljs-comment"># [batch_size, n_class]</span><br>        <span class="hljs-keyword">return</span> output<br><br>    <br>model = NNLM()<br>criterion = nn.CrossEntropyLoss()<br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br></code></pre></td></tr></table></figure><p><code>nn.Parameter()</code> 的作用是将该参数添加进模型中，使其能够通过 <code>model.parameters()</code> 找到、管理、并且更新。更具体的来说就是：</p><ol type="1"><li><code>nn.Parameter()</code> 与 <code>nn.Module</code> 一起使用时会有一些特殊的属性，其会被自动加到 Module 的 <code>parameters()</code> 迭代器中</li><li>使用很简单：<code>torch.nn.Parameter(data, requires_grad=True)</code>，其中 data 为 tensor</li></ol><p>简单解释一下执行 <code>X=self.C(X)</code> 这一步之后 <code>X</code> 发生了什么变化，假设初始 <code>X=[[0, 1], [0, 3]]</code></p><p>通过 <code>Embedding()</code> 之后，会将每一个词的索引，替换为对应的词向量，例如 <code>love</code> 这个词的索引是 <code>3</code>，通过查询 Word Embedding 表得到行索引为 3 的向量为 <code>[0.2, 0.1]</code>，于是就会将原来 <code>X</code> 中 <code>3</code> 的值替换为该向量，所有值都替换完之后，<code>X=[[[0.3, 0.8], [0.2, 0.4]], [[0.3, 0.8], [0.2, 0.1]]]</code></p><p>训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Training</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    <span class="hljs-keyword">for</span> batch_x, batch_y <span class="hljs-keyword">in</span> loader:<br>        output = model(batch_x)  <span class="hljs-comment"># 预测值 pred</span><br>        optimizer.zero_grad()  <span class="hljs-comment"># 梯度清零</span><br><br>        <span class="hljs-comment"># output : [batch_size, n_class], batch_y : [batch_size] (LongTensor, not one-hot)</span><br>        <span class="hljs-comment"># 中间打印一下loss</span><br>        loss = criterion(output, batch_y)<br>        <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>)%<span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">&#x27;Epoch:&#x27;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch + <span class="hljs-number">1</span>), <span class="hljs-string">&#x27;cost =&#x27;</span>, <span class="hljs-string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(loss))<br><br>        loss.backward()  <span class="hljs-comment"># 误差反向传播</span><br>        optimizer.step()  <span class="hljs-comment"># 更新参数</span><br><br><br><span class="hljs-comment"># Predict</span><br>predict = model(input_batch).data.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)[<span class="hljs-number">1</span>]<br><br><br><span class="hljs-comment"># Test</span><br>print([sen.split()[:n_step] <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> sentences], <span class="hljs-string">&#x27;-&gt;&#x27;</span>, [number_dict[n.item()] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> predict.squeeze()])        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用指令记录</title>
    <link href="/2021/10/13/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/10/13/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>以后学某一项技术，可以去看官方文档入门教程。以后边写边查即可。(from y总)</p><p>不定时更新。努力学习记录中...:p</p>          </div><h2 id="文件管理命令">文件管理命令</h2><p><code>.</code>：当前目录（也是文件）</p><p><code>..</code>：上层目录</p><p>绝对路径 以 <code>/</code> 开头，相对路径直接是文件夹名</p><p>常用命令介绍</p><ol type="1"><li><p><code>ctrl c</code>：取消命令，并且换行（比如说你不想打这行或者打错了，直接 crtl c 换一行，就是 换行＋清空）</p></li><li><p><code>ctrl u</code>：清空本行命令</p></li><li><p><code>tab键</code>：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p><code>ls</code>: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p><ul><li><code>-a</code> 显示所有文件及目录 (. 开头的隐藏文件也会列出)</li><li><code>-l</code> 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<ul><li><code>-lh</code> 加个 h，可以人性化输出，比如 30952字节，就会写成 31k，方便看~</li></ul></li><li><code>-A</code> 同 <code>-a</code> ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录)</li><li><code>-t</code> 按建立时间</li></ul></li><li><p><code>pwd</code>：显示当前路径</p></li><li><p><code>cd XXX</code>： 进入XXX目录下，<code>cd ..</code> 返回上层目录</p></li><li><p><code>cp XXX YYY</code>：将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如 ../dir_c/a.txt，表示上层目录下的 dir_c 文件夹下的文件 a.txt</p><p><code>cp</code> = 复制 + 粘贴 + 重命名</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144435.png" /></p><p>可以将一个文件夹整个复制到另一个文件夹下面：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144452.png" /></p><p>也可以将一个文件夹复制到当前目录下：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144507.png" /></p><p>Note：复制文件夹一定要加 <code>-r</code> （r 是递归的缩写）</p></li><li><p><code>mkdir XXX</code>：创建目录XXX</p><blockquote><p>遇到文件夹名称有空格，转义字符就行 <code>/</code>。eg <code>cp a y/ c</code></p></blockquote></li><li><p><code>rm XXX</code>：删除普通文件;</p><p><code>rm XXX -r</code>：删除文件夹</p><p>可以删掉整个文件夹连带着里面的文件</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144526.png" /></p><p>也可以只删除文件夹下面的文件而保留文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144539.png" /></p></li><li><p><code>mv XXX YYY</code>：剪切+粘贴+重命名。将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144603.png" /></p><p>重命名也是用这个命令</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144627.png" /></p><blockquote><p>cp：是拷贝一份</p><p>mv：是移动一份</p></blockquote></li><li><p><code>touch XXX</code>：创建一个文件</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144733.png" /></p></li><li><p><code>cat XXX</code>：展示文件XXX中的内容</p></li><li><p>复制文本 windows/Linux下：<code>Ctrl + insert</code>，Mac下：<code>command + c</code></p></li><li><p>粘贴文本 windows/Linux下：<code>Shift + insert</code>，Mac下：<code>command + v</code></p></li></ol><blockquote><p>笔记本上需要加 fn 键，复制是 <code>ctrl + fn + insert</code>，粘贴是 <code>shift + fn +insert</code></p></blockquote><h2 id="tmux">tmux</h2><h3 id="功能">功能：</h3><ol type="1"><li>分屏。</li><li><strong>允许断开Terminal连接后，继续运行进程</strong>。</li></ol><h3 id="结构">结构：</h3><p>一个 tmux 可以包含多个 session，一个 session 可以包含多个 window，一个 window 可以包含多个 pane。</p><h3 id="实例">实例：</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">tmux:<br>session <span class="hljs-number">0</span>:<br><span class="hljs-built_in">window</span> <span class="hljs-number">0</span>:<br>pane <span class="hljs-number">0</span><br>pane <span class="hljs-number">1</span><br>pane <span class="hljs-number">2</span><br>...<br><span class="hljs-built_in">window</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">window</span> <span class="hljs-number">2</span><br>...<br>session <span class="hljs-number">1</span><br>session <span class="hljs-number">2</span><br>...<br></code></pre></td></tr></table></figure><p>操作：</p><ol type="1"><li><p><code>tmux</code>：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>%</code>：将当前pane左右平分成两个pane。</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>&quot;</code>（注意是双引号&quot;）：将当前pane上下平分成两个pane。</p></li><li><p><code>Ctrl + d</code>：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</p></li><li><p>鼠标点击可以选pane。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按方向键：选择相邻的pane。</p></li><li><p>鼠标拖动pane之间的分割线，可以调整分割线的位置。</p></li><li><p>按住<code>ctrl + a</code>的同时按方向键，可以调整pane之间分割线的位置。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>z</code>：将当前pane全屏/取消全屏。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>d</code>：挂起当前session。</p></li><li><p><code>tmux a</code>：打开之前挂起的session。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>s</code>：选择其它session。 方向键 —— 上：选择上一项 session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键 —— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>c</code>：在当前session中创建一个新的window。</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>w</code>：选择其他window，操作方法与(12)完全相同。</p><blockquote><p>每个 session 开一个 window 这样清楚些..</p></blockquote></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>PageUp</code>：翻阅当前pane内的内容。</p></li><li><p><code>鼠标滚轮</code>：翻阅当前pane内的内容。</p></li><li><p>在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</p></li><li><p>tmux中复制/粘贴文本的通用方式：</p></li><li><p>按下<code>Ctrl + a</code>后松开手指，然后按<code>[</code></p></li><li><p>用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</p></li><li><p>按下Ctrl + a后松开手指，然后按<code>]</code>，会将剪贴板中的内容粘贴到光标处</p></li></ol><h2 id="vim-教程">vim 教程</h2><h3 id="功能-1">功能：</h3><ol type="1"><li><p>命令行模式下的文本编辑器。</p></li><li><p>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</p></li><li><p>使用方式：<code>vim filename</code> 如果已有该文件，则打开它。 如果没有该文件，则打开个一个新的文件，并命名为filename</p></li></ol><h3 id="模式">模式：</h3><ol type="1"><li><p>一般命令模式</p><p>默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</p></li><li><p>编辑模式</p><p>在一般命令模式里按下<code>i</code>，会进入编辑模式。 按下<code>ESC</code>会退出编辑模式，返回到一般命令模式。</p></li><li><p>命令行模式</p><p>在一般命令模式里按下<code>: / ?</code>三个字母中的任意一个，会进入命令行模式。命令行在最下面。 可以查找、替换、保存、退出、配置编辑器等。</p></li></ol><h3 id="操作">操作：</h3><ol type="1"><li><p><code>i</code>：进入编辑模式</p></li><li><p><code>ESC</code>：进入一般命令模式</p></li><li><p><code>h</code> 或 <code>左箭头键</code>：光标向左移动一个字符</p></li><li><p><code>j</code> 或 <code>向下箭头</code>：光标向下移动一个字符</p></li><li><p><code>k</code> 或 <code>向上箭头</code>：光标向上移动一个字符</p></li><li><p><code>l</code> 或 <code>向右箭头</code>：光标向右移动一个字符</p></li><li><p><code>n&lt;Space&gt;</code>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</p></li><li><p><code>0</code> 或 <code>功能键[Home]</code>：光标移动到本行开头</p></li><li><p><code>$</code> 或 <code>功能键[End]</code>：光标移动到本行末尾</p></li><li><p><code>G</code>：光标移动到最后一行</p></li><li><p><code>:n</code> 或 <code>nG</code>：n为数字，光标移动到第n行</p></li><li><p><code>gg</code>：光标移动到第一行，相当于1G</p></li><li><p><code>n&lt;Enter&gt;</code>：n为数字，光标向下移动n行</p></li><li><p><code>/word</code>：向光标之下寻找第一个值为word的字符串。7</p></li><li><p><code>?word</code>：向光标之上寻找第一个值为word的字符串。</p></li><li><p><code>n</code>：重复前一个查找操作</p></li><li><p><code>N</code>：反向重复前一个查找操作</p></li><li><p><code>:n1,n2s/word1/word2/g</code>：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</p></li><li><p><code>:1,$s/word1/word2/g</code>：将全文的word1替换为word2</p></li><li><p><code>:1,$s/word1/word2/gc</code>：将全文的word1替换为word2，且在替换前要求用户确认。</p></li><li><p><code>v</code>：选中文本</p></li><li><p><code>d</code>：删除选中的文本.其实是剪切，可以粘贴回来的.</p></li><li><p><code>dd</code>：删除当前行</p></li><li><p><code>y</code>：复制选中的文本</p></li><li><p><code>yy</code>：复制当前行</p></li><li><p><code>p</code>：将复制的数据在光标的下一行/下一个位置粘贴</p></li><li><p><code>u</code>：撤销</p></li><li><p><code>Ctrl + r</code>：取消撤销</p></li><li><p><code>大于号 &gt;</code>：将选中的文本整体向右缩进一次</p></li><li><p><code>小于号 &lt;</code>：将选中的文本整体向左缩进一次</p></li><li><p><code>:w</code> 保存</p></li><li><p><code>:w!</code> 强制保存</p></li><li><p><code>:q</code> 退出</p></li><li><p><code>:q!</code> 强制退出</p></li><li><p><code>:wq</code> 保存并退出</p></li><li><p><code>:set paste</code> 设置成粘贴模式，取消代码自动缩进</p></li><li><p><code>:set nopaste</code> 取消粘贴模式，开启代码自动缩进</p></li><li><p><code>:set nu</code> 显示行号</p></li><li><p><code>:set nonu</code> 隐藏行号(为了复制文本时没有行号)</p></li><li><p><code>gg=G</code>：将全文代码格式化。</p><p><code>ggdG</code>：全删</p></li><li><p><code>:noh</code> 关闭查找关键词高亮</p></li><li><p><code>Ctrl + q</code>：当vim卡死时，可以取消当前正在执行的命令</p></li></ol><h3 id="异常处理">异常处理：</h3><p>每次用vim编辑文件时，会自动创建一个<code>.filename.swp</code>的临时文件。</p><p>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</p><ol type="1"><li>找到正在打开该文件的程序，并退出</li><li>直接删掉该swp文件即可</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小张同学的2020年度总结</title>
    <link href="/2020/12/31/%E5%B0%8F%E5%BC%A0%E2%80%98s2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/31/%E5%B0%8F%E5%BC%A0%E2%80%98s2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ed03a36c773264b24335a4bf6c650abbf9e4122c55e31683e7fcb6e3bf171fce">2c3eb40cbd03027ad9e37b5ead0a8959ee5c19daf66ddf9423535ad275743aac339b96d3c0da3e42bd38116cbba3b545fa36a0c479e99ced9e0daefe07036f6f41f6ca7ef0b27dd77c74a49acf9cf7a6258d5cd47d8248a8242e603da1280f2b2a3125d49a8b17a980391bb57bf238624f93c429978d59ae48c88f2bc66367fe663da4b1318d5d4108f46d5752f4b0b28013951204571262795c38a2f3526667ede2b39a53c595a57d3ff13061f4e21d661f9da3f998379bb864b9789647e9d7248cc5a75789f6d90a520f8ea151c83ad57dd9860cba196eb1f49d642274b133e7790311b0bbf86d09849469ac6d09f3b8b105dbd565d04d42a0c48703bff05ef32f14a261f0b57b67968c4585c6d027b2e2162ade9a5de65c5ac939b7eaa0bdb3e67a24ba2c44526d19d39277c8e84d43f298d6d10e7e3d970a9c339a0bcb632ecb7824f2e1cf55982bf2e20049fbed5c8c8c7818990a6be94ab2f9ac0e2fc24f29e65f22c35abd68aa7221a43463465fd0e61c6cc22ea2a7bd6366df74123b3776c1a02bd4f7c29fb975102074db2179cf4410e990292086c9d8585fe8f08806a777677d6da0a40245de3b5438d8d81c9788a057fdb805623aa46d1ad352d48a72e44221a58b7844e8dd890c13d56916b9981c99239afecf79348d37a1f1411bf5e367fd004968ebb54b5a82df1f4126c5f5b2d2629219ea799398f86ceba5383ee65f4eed80389922906e1435309d9ef8d149506736f85ab958062e681303d125bb1c9e97a613ac3edcb10c31adbefb51775bc575efcd185550977fa1b4f5e0feb5c73070c5c8b061d5347ad2c9f13b3a9a9419da129ddfd294f625bdebfd371463b78af18c01e3e8fc0680b8ea02e64a01b00936b8eb9fc2492d2f591384a63d87fd343ef9c0d16b2045819356e207a99e473e81536ae0f42523e8fde7a26c03935d418b31153316d2bdca36d6de50fa179bdb00ea3fc915d4164291eb205d3cfe023d2594cc492296af4419aa4cdcea8f113429fbe6441214031f9bb61863d6e882cfdd17912ca6412d260bacf103401b4883ab0d38f603379c6d6a40a181d04561d01bb910050d8ccd654449b89e25a574e51feac0a3020f4f6ee1b0d1f8cfd8f57002e7a0685c177eb1ec24cc7701beaa57c6387f6a97dbacb39d293ee60739f89c7c355773d2570e7c2b545fa9545e8781b99e0931c7f812fad26a29d4053bf01729564c196b5b58fda252283e669b85265a6b749011377f5d398cdcbea63e1fc0d197c3a9fad9b0b60319e0066554cd7db995809745cab568e35b8f6e6b0c6e76071c03ec056f597910c84ba740ca08399b26bbbbb09b81ae6cd8ab57b90b18e2531501708df07e296101577d548bdcc8d4fdaab8718802318acc5893c78c464c0a77dc0c54e4eaeba4004e50386f6756e38efdf108dfad00e8930c4d6d31a49d35a1563035890c048d948d9c0683225c3605c30a6cf2ac3a81d86169d1de9e78dcd685c925f20ced1af9631437d49f6b75903934c04c940ad07b336fb88a902e84bed353575114bd95838c98c321057df97a109b117f89213b50e5b710799739e8b7dcfa3f11d9bc46f3b4fbf3a2d102903bf28e5cab6d8545286024347972bc186600836c80d3626fec2755af9f9f92662ad94b27dbc91edfb1ea49642d27f26dc794203750a8faeba471d90a5e5dac7dfdde0131d38fb144d089bea1f94f9d8d0957da2746214b15a877f68ca4dcb349e21b8885ec6f143b15a488ea18bd848a7a6e1c27da5748bc265b3048d8a88f06f03a0c989e55d452b5157a3b58e0280c9f557e44401cfa54041636ac3c67ed34df492359449e512034140f528c17a84057f496148e58fa740fa487a8907d40355a9e78d59cf08c50b216fa9b2851647ec75f3d34644a83bb77392c89b2e9759aac18884217a9ecfc8666a227dd03a8559a81cd55a6f47eb20b95649ec65ddf07b0843ca59ab9dc44103b4b87f0eb1febdc86c898890bf711e887d37e78754d5ffa366e759ad654d6f82856ccb2b535d9ba7b98cc88cc658b1a1eba1e340d2bbfb413e810b55850b01b530a1dd4fbd937d560d17ee03df69352a15cbe1d7186aa5485f6144ddc6c6ab09b51cfb9ac07da8a5aadee92603ef9cac09fc84b54d74b758334255dc85203e17e36661870c34871c992016bc2a730fb42ad6d1d3e482c70cba1359258a74e238f998f1c59c9e768c8bc9e0fbdef8b98fa5a74918fc6db83e359fbdc31d6d026cdb202e718c9fd981cfef8d01fcde31c00ca5b75611d3713176085d003c1ec4fa8e83fb2a1436881beeb04462c30d2fa8a9f4e878ddc2a0f594d465728d381d1d80e599b476f1b9f5a91f11153f362dfcba0456c43c71fb4f70c48c91410dfb16b18d066ae4a06f223ed8cf4fa53654cead8293cde8275572b8838507d21732ca2f700fd1660236b0be53430a3da5156d4d19407f424f753a0b3f4cb19c2f087684749369c29e9daf20623ae525c5f74c0874f5cc6ff2d155416ab5a810beba4ad3dfecd036a27aa9c94d98ea54f8fc6a80d059459090c5bc9e712543566728a864b505c08bff6bac63eb3752fafff8fe32145dea5caff55bf7c83d562fe61c2a93d8fc9d3b32d0618ea8bd7dd86df76d79358c1977022b8505353f56b868c4484bab4628a6fb9c851b4b9c4788a6d2fc39f75ae8d019c5b01816679c95f17e7b6c3c39a190187ddc820443e1fb9bf6efb813c35d9e7d63b8a593317cf17121eb6e4fd01ea54bde115843d1346933c734c474e5d00c24d29ba32ff22973c84b4ce33c60ef1f629211d1208dbc36aab2ebb540538e0b416872a7dbdaa0d2b9b8c9831df92faf5471a77dc7cf44c0fa7cf770efd0c5b6e076d71aed1a8b8b0bd7be13c3994dce97c12a56bf5d1af4a2d3ae5d973b5223500bde618bba864044fec110adb7837268cd05b73a4f8a6599ee66f19a0ca64e032f085758e4c4e4802c3dd6d47df4a23a50e23ccfdc3bd7a716237534f1f3b1d3cc3a15e878345c5f130904f1e8248df5120f82e9255c0cdf991d3456cade65f2e6230f8292c3cdb8a01b4b8ffbf4de2f56a27af7805ff0e302e16c692f150854dc9f8867d8fe86565f3ec162600662467c9663751be66659b27666662a58181fceaca371e75fd006d39672c8aca13948d69c733c0fc58570aa73a6fca0ed5ba5866d5d520b10f084ca199574eec5070239c0e666c5fb8926c4ec9579405e9565728476122875d303c8fd23887789b60e0ed76d030a21362448896a56fbcd912f00fdf2da35047b9a50a8183661ced1f027e14fc2cf8c7dfe1c6fe65304e4f796bdc54e35e7d16a990c1ace4b1362e67b9d8fa097b3073f7ef35792f3f6d6b7b5af74356fe7dbe66a104f042ac0c7cea568ab25af426e8f61cd1aa7b6e8e2e952ea23a82f76f70659c0fb404f1b90a42cbd510cabc20e0768ed5b25f2af511d3bfaf07ab5903975a727edaa52db581151bb8364493ac697a7e3e18ce5d18101b66094f2e5768977eb834fad97afb9ebd1427041822dd84d1415f13eed5ab4646eff2720a4bff88dca2a3e6b5ad59eec0a771091171b770b6225b0746dc28ac7bb63a0909dc4d2a80b6c8b03593c5f416d4a9f1ba4a84a431c36e5f662ea314cd0bba9b956cc4a76079be932dbb63193b01778c9d6456b69c7927cd7791fd533f258f00f8333037704e560f0b86762dcd17cb3e19ad7cd8d9681d2e68c538b0e1188ba4e9a84286b1fff1bf5008daf19a578021df1142c86d92a262def50a0e01f2033ed06c27db187d574a7e591b8ad554b4881170437a0a192b36c708d93f5e2dae6e2e43a79e3f287ba313c60d641f3f218c42201576a107b7de664ed9ee5056820fec9c32a4e1aa5f4b19e9af9dc823e6a958e0da051a3e179ccfeb02f91225e306b1b4c06e910163db3dc9abe6f6bf83d1b5f125c3081a2ec2490d9cc8190a2f9198602a213d015e5d1a56fe015d3d0780a893068f5876bd7e77eb76c882234d9b86a2d0a0db22a24364f560892ee5dbdaefb586397ac3fa2fb6a56d59279f41e35eb9204c90d4d7b6c9ec3d7829662af25bc542adb1793051934838abbd3659b13d1cbe1d2d45a3ff3b449ce0e00ff3f9decbe9a6792f0f70d308368ae5d002e0abb3391c58d185d65db671e3a7e00556c2099777ed7262b154d9b898d8f53b6e24233d68304e10a95434b23f91019d452675fb23880a5d1af95486b599e0f5e9e026c2da2f070db577e0941f0a0655622d2655ebdf3709655c160bd8b77f8fcf778332618b77b13f8adf6c3e397186f217f25c8dc3bf3247d4a7d70ccaa4b6b9a5ae9c16e6d594c9d8105e3273764ffe7c27514e6f2004a44cf7a3b18a6ef6f48366e02f7bd2071867511c228d39e65b021d5b1cb3467e622650a96d76c36fad0fe61f485648a62e4dcffaaed20b89f20f28bdf0a2dcb66250e3abb7abcbc85cffe0d2ca6ea94d7760988c194fb5d7fd3837d49a58b5dfae136d10a7b230f0f8e836fd535856be5d31fbcc23483ee666240753cc01004eb775915d370b7e5e61f4e853d56a0b7189670b3954efb60d995302edc49c2812b6e23d4fdd003d7d860ed2167b5704cc0cd0e9cef0679f8223ceb6e1fe4698c38b54fa126553d64183c731c64db3e60d5162d6433cbb804e62597d76509d5c9685320a3fbf49b32695faa7db6228c9f9b0b4a35defd7290a624fe93a6fb9c741fee7b62a8fa45b74cab83641714aa2367e0d01fe47bf32beb898ec07231b3aa1b38688d5a04353531e0d7da723f96865e3bfa61f5ac0e62126d06b7ce6dccae33c18a5422b830281b314e79907248c44e07d688044611554e92332f63ddcb727f2351d2b1b2009a838580a916212340207a0ccd8fe54d534654121bc3eb5bf92594cb09e9f6e3ff9b04d46aed3323c815443821eb3ea4152ba3296fbfa304b27a4eedbd50166dc05cd931901576f825c67b806648d1b5fab0792cb932c9da18f63b813a8d6dba749ca42014f5855bc5ff3b046798d541727f14c7382724d3c913f3d7c50fd35500cd2bd9bd8587cab6588ab610f50e74e30fdbadff6d384d526543e2d3aa338d4afa13e40d8e2123c4084b4f8b7798d16720605fc9af5ada1406f77d8ac8b59ce3be48432bed2f274927df7958cd4e06b66faa1913db32d8900b40e56a548d6fc4e232ea1b74311a7710248377e733c48bd0d46887792f0a9b0e7d216cd2b21f4e638ac66ecdf677d3e91cbcc4d731943df03046db506f5837ca22c22b3aed78c1b0aab77221292b89056ef4d888dd85237a25e59524d7624dc388aa6cd5cf554852d2b36430a234ef1e6ab3da2031fe405b93f736d127e09935f20ebcb555f343bb5fae103a1fc4b9e3ec3ce0af6e5e85a9d86326dc0030da46eac988abc866112866ebe84199cdecad96d36c987224ef98b22a9d270a4013389be65ce55d484cef5c801138a960ebec44c4aef8ae5b8718d1abb891bf5ca2584b65d96091bca1488971dfee8f627e3212c8d103eb45302b9fc8f6c2419380a522b6bced03a5988ec24ec36763a75494918d92b4e653b58716e8180e47ecd2b678ef79003998119e29e52a50c2a74fb5100ea7a1a5fa67bb67ca846afa6b864b1b468820bd8ae4231acb5ddc015a3cd963d9666de06474f43ad90667be20c710c3b033ef72a4ffb481cd729411d923db2e38c3341d5ba0ed3a27f7193ed5956d66f1483c0144d6e1454a327924d6b629d49386439151bbb4c1306a00979079464cac3fe33e8b6e09137b9ec093c018623b04a308fea6878402ee070a3f7c26217eb6c7fc6406cf64187cf87083c7d9940a80e5b13cc7bb55407552c13fa79ef5a1445328e0e9bc18da94f2a575f9f04230b6967123161dbc6922a2bc31a82b75260aa7e056648396d2aeab1242f94f14eaf324ef45d7f8e03cf7a028e001bdff9a9da6554002d4ca100d87fbcc2532d28408632aa7b942deba55be67d88bcfef468779f1e335ed95325c115a8775b2db5b17781d40eff96dca6b005ef725d12c7aa40452009c41ecc064f08adce799f6c992b06d3f2122b7158c37078cd386f1ee858841492cd6e437ec73ec54f1aca0ff95222195d8467cd2bdcdd122892eb69dcd0e7cd2f806e466783e6e87ac2de142e0eeed00d986c5c377d118381f823b1fb9cfbc33cf9249a2dd3d02600bcaa9caa9681c68e6abfda69d853d2659695883a4900f57745843ba8b1e7bdfd5016648db753808e4f4a79bcc7e97e226ecc11a0cbaac86cd402635015535e7d669e848ab830c5c1d0a40f5bc674f50a4012d2f95335b2e565f825a4c8fbd0e4a5fd8516f27f631ff6a8e91d61e8f01c03951c823c02df0947d144b6c74e0e61079aef2b2edc156ff6cae495bb2c3b4d89ab8b5415987fdf1cca52a1f9109dad56c26e607a0cb982686839c0a87389b56aaa7da630aba41504a2434421aaf83e89998085abfb4e0a9e5bab7662df045b7ebcc64419bd2297d6109328215fcec8d3be12b15ee8d23ad4bbe5a2cf289b1b0a98abe4b50d878fb6487faed9573c8dedf75b5518ebc0d89f374c5022ce8a3e8614b2efcdf55ece387c541c5315bed2a101b64f68be28e36b5f4453bcf66f958977b5f4c71948a42a13a6d3686513c895a8e788a7a11715c7924772c8b95292559d71f60578ca573c56ce6d865cc93988be901b91ae3e7cd709afaac5dd8deba9668ef27d7644320c8035f03645d6d14e392b1a33e9ca1952904557c625355b96b4ef6038c278d24541c29dfc9220ed49a46b35bbeb2c1d9e93afd0cd3797350e0b96d0466f8a0d1da843c8f0609e74e13bca039770814cfe253defbedc6265ec280770e5bc490c3d97d8c81049974a3e062d66b74a028e6847736a16caeed3c915c7f32796eaf974abc59fb554a7a709e614a4203ecf88da8ee63ba35b12cc1d9207e71e4732d57d66dc7e8e08bd067ad7e9a1106e35e287acdc344d423a197f69293cb8660f3579d867e2f172fc6195283c0d0ac5c31ee47f241b8e5f177d5198eb340fd565fe845b294fe08861a780ca56b48dc24027dcd3111cffa564f6e1854f801593e14b3cbdb436c1ec2fa42631fac10b8039a2f0699b4befe61ad49e67b84b84068a9ea8e4590e2830ea462bc69c8069ceab80cddb22b56926a01035fb0f60a0487bcde2d90bd7d4e7a0566d4f3906472d6f970a88e6fca0f9d130f6d498012988e90fa38630c34e329eafdf49e0263fa8328a926dd40da1a711a219e6c037993f9c8739711a4cfcc111834a3df91540b3c559bbd9307b5f58c975a10fcfaee8d90ea412605545d3b34062c224bdc83f1c3231036a4d7e6fe3638a64231d223bac37c5857223a096150eff6156205b43886e4168d3371b5541db0160a9e5385bf931cddf910e08b8ee728abb0558801aebc51400b8913e052953535ce576074bff8156e522fcc43542369f542241ef1c61e6f7ee4e2a97b306d44a3f7dc8123b6f9b49e10c06f1a283d12d6ea6c2f397b14aaf5e4899c33a58fa2a89adc4977433fa4fb8835100e36bcc916079e007331880be8029c867449a28d77d1a5dfe96e59fd6e085f536aca50d431d844d3bc8852f5f322f9629fb56a31ef7dcacd05cad53c6a5874548fc3b24584c8da26ab035d23b82bfb288355e2ae68ff9746ad4f2e80f6b970763b6cda25298b9f623515da12a89138e0b797e8d572860b9214bf3159f2dca5ad867ce89c5e0c7d79bd4622660571095121fc2283a3097569e144bd2e53ed47daa9924c7b6f61c0fb5bb8e828127c4ca1d9e49559edfa89d10e10faaa5d2c9e4d74050c71a0b2ff54bd15309b6068cf0e157c7eaabc00abb80c4da8e861caf96b8af0e7ba3a42bdb558b421b9a5f81b0cff6113677a20ff69e760ad960f1b4ac0b9f6810d7f3a87af589a5bece5149e3e9be2af87d894d7718e9f5c991757fa92575b49c1d874d4d0f8534cdc0026bf3839f92d35b0fa3cc2f8b4578cb252391f3b876ca90bdc783d1c211d35de3596bf66371d6a17310e0a31f9392cdbd3041a19ef1383805b9ba029f03abdbe4deed5a9cae4bde78cbb925eed30c62d3cea346a97914f1e980e2982d3c5a45142b364fa7105cadfca4d59b0145bfc1265d22a5b6c64961536619c3e5c839d66d5b33a59438c20817cbbc034e67d5443a148c88fd024c88cf262a84fd7a5ab2e9c9775be50fa7ea5c00fd2cd7b388dff47be25fe03d83b922a9b06f7a0d0c89aba526f5131d8000472809d506d14f5abba119bbcd041be3ee98353668d322b154929952997654a5424ef57c572f250c10ff72b2c364f079753309b77f5f0e7fa8cba9a2a91cda72d09cc4ca40b19685a682efb522596cb3f9aee0893335916fb4e163f008cd5e89ac560c6cc43de23744de4b5fdf9a850bca0643a0627309f7fd61ad6a1406123365c519d44a0fb44bc1534f8b117545684a49c0bed64ddb9a96af5e1ea936fbde1998df50e0623623eab7981b05878fb10d5f3b3aafd7f93a7710033afa686c6c099fe0d6294b904b2104e9836a52b62530a25823f313e27c995b2712fa5628bd22e1b7a0184adb1d877e7ba0fdb8b3cb053471064c23178a67163553a4302e680404ce474c58e4f403a9a292edf909673cd904f79cf8b2030653d285d2aedfda55f15f32dc4a01ddcc7c0e5306c9624db24d4bee319a94c373a0cded66bfc032c6b4aa15036761fbf988ceb93e08bab8d69dcf9006afa3a27f36727f4eefc3e85d92a6c012ab492e25cc96658080f17b0082c4bfb479ee0796005f1c7c875f44829bd67aeed1d789a18829b98b70f7dd2d0a06cf09ffc4d012987ed0a6b62ef2e2e947cd54838c9979acf29efbaabe3b0857e015c7d501630ebeec2e7a2399fa6267471529105df52383cc24e7d7f8c779624fb72ae69a05bd17526c651c37ab825c11d29a9be306a2d699cc0746f62445db568cbf298b09c09f6e9723ba55f238ee348593338749600f32d076268714265897c21b43c7b97bd1d4f8218cbc516ba8b80d61f564cef4193183a94dc0958aa39b5db6103798b00f8b6ea6093dce4ba6b75b01dd4388ab7138022e3ed8780a3b9a24cb6d8b5e7a5e8c93ad25420616347589b77a983d3b2a9180ded5ef1e0c05a9ec287fe27ab10106df284312b7245b21fb429a708170f55299469ac2c592ca1fde23fb804b60ff340681b2fa50045a4a6d83aa4df8d765e18d9617806b87fda8c978586cca69c613daf6d1858eb170fb33e2e9d15d55622159663d11a57bd07e2f0b391c09a1ea3a04155cbcf0ab0f7ba7fe2dbc212c02efe02b025ddb8ce92212e03664cc35e8df514c3d76a0030875bc8ce0034c7a71ced3db5e5a8b1231bec224e41e95dcca83767ebe4a75884e8440dc48450e7edfec9f3eadebec6fb559fb0df23b5384bdc80ccef51e62c3ee21c4a62a14052ca1817d202049f3fe78cd2c190e47a5aa7d0f14a28544a7e5d626681ca55f1a41d643df1d75e46301b4352d009de7ef16835de9250c98a5491a755da1427ed35681ba72564c2e10a16d420d80f85d5b3ad38273c91164e2564344cc8dae262676adb17c135767049a82d991e1ff9de590ff865c672ed2872f29435f0eaff633ed07736f5f5266c69bc4e0b2700f90ecfccf4db3077e69e0a2219cf8f1cb2d9ad84865a5801756afb2144605d649832d533729de003ae35050a2cece01c5933de11503ebc25613f081205b967e58082abe6020050a10f1cb4c0e0179af9e5a9ebdca1f29711e69f20522b4311859c2906773a4bf89a875da65f3e833a6e8149ad8f4000d018f75efc733d31ea16b58297b06be70286589b4e905fb633acc05b57547af3c4cf593de0083dd42bc8de4ddc071eafcb6af523ea115ffe5ff90f0755093ee3a35fc3c2b4074ddc233b74fdda69995de6795aa1ca6d9e4e4b06970f81ccb5c92d154715eaae5634a1799b799a3f1a71b5f4f5248c52eec9e3045d08367b5fac05b26aec17a65323d3fab2749f3b4d71a40f2978a43935d52c31a4f52e6aecc85e3f979f918d427ae7d1cc9acf00b66f20ff2aa59001008812e11bf204ba042a2225bd2159870457b0c580c6ef6a85909c3460261f6bb9492dd7710d135e029da1aad2350352cbe04b221016543e3b323769c7b691296eb1b4ee98a206808969fa8930ea4a6af46ee36ab616e8e634eba0ecf2bee49ab2562a11cb1ea4475bcac4e217df71dfb4d954d02c16f4c2a0e9b9b994299f8bb97d096a2b2687905b9e21e0491adfede9c081156385ac90284ddaabf241861ccd1e30d84de97e3c523f614203d863bc763c4e78839744678d52e5123cee98dd7dfc568d0b21287fc3dd2266902f7378684a5196b18278069d60cd8ff3d16963c35c366fc020bd7043287a98edfc0bf9fa7eccd7bd89b4aef8baa59e91a50a86f99216ad174147883d5fb97fcdacd312512b9f83c36aceb871af4459b5647cf2ab500201cb717e9035be4b10c125f3d4967af0942baba11b3facc4310b448e79c755d8c8f62d5620d1a4bc1e1098bdffdc9d3e70bb9db8ddb5f95f0f0f4e4c3cc5454a6893cfebf91ac0e1c18683f5bbcac554a1c31e082c89725ba99d9f0313f8120fba322ba34601e9fa7870e4a8c2b6e977288587e62cb5535a3684daa1043abd72776b0a46149e6d89e59b4939a10aa96399287647622f39dd8e648ab8ffcb7f433972c7d73abf1444002a1917a1cd57c5a86e10001a49dc2399c8dc93fd4653fb9a79bd6b13bdd31849daaa4addc9087c41e824de5935a99421c29bb6a8c1260baeb341bc1b736a9a949d7032ecc021ab0cff0354779a320002b05cca9980a9b730e05b660a334c2682e764434b3c58f7c2621de5e1ccd65e0da0b196c1b10364a8ee18b6a35ffaa3e6dbe78af058201c8dca634f151d0f2b706036ad3f8629be0f3586bfaa7c830f2cac07b53d92f0e555ad136d5ff79dab83f4d975a31397f7a6bb1ed7c05692614dcf54d50faad339df004f714ced17f1ec9b0a74bebb7b94e7c185c1a36f22d9cf3c0c92bb8ea0703b788a2aabd82a5a3a96457323451f4b8d5a2cff8a67766b5be45707ab4b2a1dab015d4740ad24be6ef2130036e18e41c2b7917a6dbabcb89422282a3989081db7a4b73bde287aaa6df8985e9c02bc30e61af1303acbc31f5c1936ea76cde739b8f83aeafa833e816dca3bf5ad2982decaad10b6cb25229ee6d146d1a731f82afa1fe0e19364f6215df32fb20417ff3552763cdc5d3e45db8e0a7a2352b92ff50c97c14acc4d5191ead153d4bf068f60cfa96412dd6c33926d30e5c269505</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>小张日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小张日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 基础语法</title>
    <link href="/2020/11/14/Python%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/11/14/Python%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>这里记录了 Python 的一些基本知识点。</p><p><em><a id="more"></a></em></p><h1 id="基础知识">1. 基础知识</h1><h2 id="编译器与解释器">1.1 编译器与解释器</h2><p>编译器/解释器：<strong>高级语言与机器之间的翻译官</strong></p><p>都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程有不同而已。</p><p>用一个通俗的例子进行比喻：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。</p><ul><li>程序入口的编写：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    print(<span class="hljs-string">&quot;hello world&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="标识符就是变量名">1.2 标识符(就是变量名)</h2><p>所谓的标识符就是对变量、常量、函数、类等对象起的名字，变量名。</p><p>Python对于标识符的命名有如下规定：</p><ul><li><p>第一个字符必须是字母表中的字母或下划线 **‘_’** ，标识符的其他的部分由字母、数字和下划线组成</p></li><li>标识符对大小写敏感，严格区分大小写！</li><li><p>变量的命名不要用关键字和内置函数的名字</p></li></ul><p>一些代码规范：</p><ul><li>变量名全部小写，常量名全部大写</li><li>函数和方法名用小写加下划线， <code>count_star</code></li><li>类名用大写驼峰，每个单词的首字母大写， <code>ThreadMixIn</code></li><li>模块和包的名字用小写</li></ul><h2 id="变量与常量">1.3 变量与常量</h2><ul><li><p>Python 中的变量不需要声明类型。变量可以直接使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">4</span><br>b = <span class="hljs-string">&quot;xiaozhang&quot;</span><br>c = []<br>d = <span class="hljs-number">9</span>-<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li><p>用“=”号来给变量赋值，从右往左的计算顺序。</p></li><li><p>每个变量在使用前都必须赋值，变量赋值以后才会被创建。</p></li><li><p>在Python中，变量本身没有数据类型的概念，通常所说的“变量类型”是变量所引用的对象的类型，或者说是变量的值的类型。</p></li><li><p>Python允许同时为多个变量赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = b = c = <span class="hljs-number">1</span>，最终大家都是<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure></li><li><p>也可以同时为多个变量赋值，用逗号分隔，逐一对应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>，最后a是<span class="hljs-number">1</span>，b是<span class="hljs-number">2</span>，c是<span class="hljs-number">3.</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Python中，一切事物都是对象，变量引用的是对象或者说是对象在内存中的地址。</strong></p><ul><li><p>栗子：a = 'ABC'时，Python解释器干了两件事情：</p><ul><li>在内存中创建了一个‘ABC’的字符串对象；</li><li>在内存中创建了一个名为a的变量，并把它指向'ABC'。</li></ul></li><li><p>栗子：a和b是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;Jack&#x27;</span><br>b = a<br>a = <span class="hljs-string">&#x27;Tom&#x27;</span><br>print(b)<br>print(a)<br></code></pre></td></tr></table></figure><ul><li>执行a = ‘Jack’，解释器创建字符串‘Jack’对象和变量a，并把a指向‘Jack’对象；</li><li>执行b = a,解释器创建变量b，并且将其指向变量a指向的字符串‘Jack’对象。</li><li>执行a = ‘Tom’,解释器创建字符串‘Tom’对象，并把a改为指向‘Tom’对象，与b无关。</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141413.png" /></p><h2 id="输入输出">1.4 输入输出</h2><h3 id="input输入函数">1.4.1 input输入函数</h3><p>input函数：获取用户输入，保存成一个<strong>字符串</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>inp  = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input your name: &quot;</span>)<br>please <span class="hljs-built_in">input</span> your name: jack<br><span class="hljs-meta">&gt;&gt;&gt; </span>inp<br><span class="hljs-string">&#x27;jack&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(inp)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><span class="hljs-class"></span><br>&gt;&gt;&gt; age  = input(&quot;please input your age: &quot;)<br>please <span class="hljs-built_in">input</span> your age: <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age<br><span class="hljs-string">&#x27;18&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(age)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><span class="hljs-class"></span><br>&gt;&gt;&gt; a = input(&quot;请输入一个字符：&quot;)<br>请输入一个字符：<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>)<br>请输入一个字符：   前后带有空白   <br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;   前后带有空白   &#x27;</span><br></code></pre></td></tr></table></figure><h3 id="print-输出函数">1.4.2 print 输出函数</h3><p>普通的输出没啥可说的。</p><p>说一下 <code>print</code> 格式化输出。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141451.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141504.png" style="zoom: 67%;" /></p><p>下面是一些经典的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;i am %s&quot;</span> % <span class="hljs-string">&quot;jack&quot;</span><br><span class="hljs-comment">#i am jack</span><br>s = <span class="hljs-string">&quot;i am %s age %d&quot;</span> % (<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-comment">#i am jack age 18</span><br>s = <span class="hljs-string">&quot;i am %(name)s age %(age)d&quot;</span> % &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;<br><span class="hljs-comment">#i am jack age 18</span><br>s = <span class="hljs-string">&quot;percent %.2f&quot;</span> % <span class="hljs-number">99.97623</span><br><span class="hljs-comment">#percent 99.98</span><br>s = <span class="hljs-string">&quot;i am %(pp).2f&quot;</span> % &#123;<span class="hljs-string">&quot;pp&quot;</span>: <span class="hljs-number">123.425556</span>, &#125;<br><span class="hljs-comment">#i am 123.43</span><br>s = <span class="hljs-string">&quot;i am %.2f %%&quot;</span> % <span class="hljs-number">123.425556</span><br><span class="hljs-comment">#i am 123.43 %</span><br></code></pre></td></tr></table></figure><blockquote><p>注：如果你想在print中打印一个%百分符号本身，那么你需要使用%%，两个百分符转义出一个百分符，也就是print(&quot;%%&quot;)。</p></blockquote><h1 id="数据类型">2. 数据类型</h1><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141519.png" /></p><h2 id="数字类型">2.1 数字类型</h2><p>数字类型用于存储数学意义上的数值。</p><p>数字类型是不可变类型。所谓的不可变类型，指的是类型的值一旦有不同了，那么它就是一个全新的对象。数字1和2分别代表两个不同的对象，对变量重新赋值一个数字类型，会新建一个数字对象。</p><p>还是要强调一下Python的变量和数据类型的关系，变量只是对某个对象的引用或者说代号、名字、调用等等，变量本身没有数据类型的概念。类似1，[2, 3, 4]，“haha”这一类对象才具有数据类型的概念。</p><blockquote><p>例如：</p><p>a = 1 # 创建数字对象1</p><p>a = 2 # 创建数字对象2，并将2赋值给变量a，a不再指向数字对象1</p><p>这里，发生了变化的是变量a的指向，而不是数字对象1变成了数字对象2。</p></blockquote><p>Python 支持三种不同的数字类型：整数、浮点数和复数。</p><h2 id="字符串">2.2 字符串</h2><p><strong>字符串是不可变的序列数据类型</strong>，不能直接修改字符串本身，和数字类型一样</p><blockquote><p>注：中文符号 &gt; 字母 &gt; 数字 &gt;英文符号</p><p>例: <code>print(min('今天是个好日子！'))</code> 返回 ”！“</p></blockquote><ul><li>字符串的拼接，用 ”+“ 这个符号</li></ul><h3 id="常用函数">常用函数</h3><table><colgroup><col style="width: 34%" /><col style="width: 65%" /></colgroup><thead><tr class="header"><th>函数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>upper()</td><td>函数的作用是将字符串中所有的字母大写，只针对字母。</td></tr><tr class="even"><td>lower()</td><td>函数的作用是将字符串中所有的字母小写，只针对字母。</td></tr><tr class="odd"><td>capitalize()</td><td>将字符串的第一个字母变成大写，其它字母变小写。</td></tr><tr class="even"><td>swapcase()</td><td>将字符串的小写变大写，大写变小写。</td></tr><tr class="odd"><td>zfill(参数=新字符串希望的宽度)</td><td>返回指定长度的字符串，原字符串右对齐，前面填充0。</td></tr><tr class="even"><td>count(参数=查询某个元素的元素)</td><td>返回当前字符串中某个元素的个数。</td></tr><tr class="odd"><td>startswith(参数=字符串)</td><td>判断字符串开始位是否为某个元素，返回布尔值</td></tr><tr class="even"><td>endswith(参数=字符串)</td><td>判断字符串结尾为是否为某个元素，返回布尔值</td></tr><tr class="odd"><td>find(参数=查询某个元素的元素)</td><td>用于获取子字符串出现的位置，如果存在则返回子字符串中<u>第一个字符</u>的索引值，如果没有找到则返回-1</td></tr><tr class="even"><td>index(参数=查询某个元素的元素 )</td><td>用于获取子字符串出现的位置，如果存在则返回子字符串中<u>第一个字符</u>的索引值，如果index找不到元素，会导致程序报错</td></tr><tr class="odd"><td>strip(参数=想去掉的某个元素)</td><td>去掉字符串开头与结尾指定元素，默认是空格</td></tr><tr class="even"><td>lstrip()</td><td>仅去掉字符串开头指定元素或空格</td></tr><tr class="odd"><td>rstrip()</td><td>仅去掉字符串结尾指定元素或空格</td></tr><tr class="even"><td>replace()</td><td>用于将字符串中旧元素替换成新元素，并能指定替换的数量</td></tr><tr class="odd"><td>isspace()</td><td>判断字符串是否是只由空格组成的字符串</td></tr><tr class="even"><td>istitle()</td><td>判断字符串是否是一个标题类型,所有单词的首字母大写才属于标题</td></tr><tr class="odd"><td>isupper()/islower()</td><td>判断字符串的所有字母是否都是大写或者小写</td></tr><tr class="even"><td>split()</td><td>连接字符串</td></tr><tr class="odd"><td>join()</td><td>拆分字符串</td></tr></tbody></table><ul><li><code>spilt(str=&quot;&quot;, num=string.count(str))</code><ul><li>str -- 分隔符，默认为所有的空字符，包括空格、换行()、制表符()等。</li><li>num -- 分割次数。默认为 -1, 即分隔所有。</li></ul></li><li><code>str.join(sequence)</code><ul><li>sequence -- 要连接的元素序列。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">li = [<span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>]<br>print(<span class="hljs-string">&#x27; &#x27;</span>.join(li))<br><br>b = <span class="hljs-string">&#x27;my job is a teacher&#x27;</span><br>print(b.split())<br><br>b = <span class="hljs-string">&#x27;my_name_is_bob&#x27;</span><br>print(b.split(<span class="hljs-string">&#x27;_&#x27;</span>))<br>print(b.split(<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>字符串和bytes转换：</p><ul><li><code>encode(encoding='UTF-8,errors='strict')</code> ：将字符串内容转换为bytes类型的数据</li><li><code>decode(encoding='UTF-8,errors='strict')</code> ：以 <em>encoding</em> 指定的编码格式解码字符串。</li></ul><h3 id="编码格式">编码格式</h3><p>对语言的解析识别/标准</p><ul><li>gbk中文编码</li><li>ASCII英文编码</li><li>utf-8国际通用编码</li></ul><h3 id="格式化输出">格式化（输出）</h3><ol type="1"><li>字符符串格式化用操作符 <code>%</code> 来实现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;my name is %s&#x27;</span><br>name = <span class="hljs-string">&#x27;xz&#x27;</span><br>print(info % name)<br></code></pre></td></tr></table></figure><ul><li>格式化符</li></ul><table><thead><tr class="header"><th>符号</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>%s</td><td>格式化字符串，通用类型</td></tr><tr class="even"><td>%d</td><td>格式化整型</td></tr><tr class="odd"><td>%f</td><td>格式化浮点型</td></tr><tr class="even"><td>%u</td><td>格式化无符号整型（正整型）</td></tr><tr class="odd"><td>%c</td><td>格式化字符</td></tr><tr class="even"><td>%o</td><td>格式化无符号八进制数</td></tr><tr class="odd"><td>%x</td><td>格式化无符号16进制数</td></tr><tr class="even"><td>%e</td><td>科学计数法格式化浮点数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&#x27;%u&#x27;</span> % -<span class="hljs-number">1</span>)  <span class="hljs-comment"># -1</span><br>print(<span class="hljs-string">&#x27;%f&#x27;</span> % <span class="hljs-number">3.14</span>)  <span class="hljs-comment"># 3.140000</span><br>print(<span class="hljs-string">&#x27;%d&#x27;</span> % <span class="hljs-number">10</span>)  <span class="hljs-comment"># 10</span><br>print(<span class="hljs-string">&#x27;%d&#x27;</span> % <span class="hljs-number">1.2</span>)  <span class="hljs-comment">#1</span><br>print(<span class="hljs-string">&#x27;%s&#x27;</span> % <span class="hljs-string">&#x27;123&#x27;</span> )  <span class="hljs-comment"># 123</span><br><br>print(<span class="hljs-string">&#x27;&#123;:f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1.2</span>))  <span class="hljs-comment"># 1.200000</span><br><br>print(<span class="hljs-string">&#x27;%o&#x27;</span> % <span class="hljs-number">8</span>)  <span class="hljs-comment"># 10</span><br>print(<span class="hljs-string">&#x27;%x&#x27;</span> % <span class="hljs-number">32</span>)  <span class="hljs-comment"># 20</span><br><span class="hljs-comment"># print(&#x27;%x&#x27; % &#x27;123ab&#x27;)</span><br>number = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;123ab&#x27;</span>, <span class="hljs-number">16</span>)<br>print(number)<br>print(<span class="hljs-string">&#x27;%x&#x27;</span> % number)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>字符串格式化函数 - <code>format</code></li></ol><ul><li>使用 format的字符串主体使用 <code>&#123;&#125; 大括号</code> 来代替格式符，可以不取下标，取的话从0开始</li><li><code>string.format(data, data...)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;my name is &#123;&#125;&#x27;</span><br>name = <span class="hljs-string">&#x27;xz&#x27;</span><br>print(info.<span class="hljs-built_in">format</span>(name))<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>f-strings</code> <em>新方法</em></li></ol><ul><li>定义一个变量</li><li>字符串前加 f 符号</li><li>需要格式化的位置使用 <code>&#123;变量名&#125;</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;xz&#x27;</span>  <span class="hljs-comment"># 一定要先定义变量名</span><br>info = <span class="hljs-string">f&#x27;my name is <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span><br>print(info)<br></code></pre></td></tr></table></figure><ul><li>转义字符</li></ul><table><thead><tr class="header"><th>符号</th><th>说明</th></tr></thead><tbody><tr class="odd"><td></td><td>换行，一般用于末尾，strip对其也有效</td></tr><tr class="even"><td></td><td>横向制表符</td></tr><tr class="odd"><td></td><td>响铃</td></tr><tr class="even"><td></td><td>退格符，光标前移，覆盖（删除前一个）</td></tr><tr class="odd"><td></td><td>回车</td></tr><tr class="even"><td> '</td><td>转义字符串中的单引号</td></tr><tr class="odd"><td> '‘</td><td>转义字符串中的双引号</td></tr><tr class="even"><td>\</td><td>转移斜杠</td></tr></tbody></table><ul><li>在字符串前加 r 来将当前字符串的转义字符无效化</li></ul><h2 id="布尔类型">2.3 布尔类型</h2><ul><li><p><code>0、0.0、-0.0、空字符串、空列表、空元组、空字典</code>，这些都被判定为False。而<code>-1、&quot;False&quot;</code>也被判断为True。</p></li><li><p><code>None</code> 也不是布尔类型，而是<code>NoneType</code>。</p></li></ul><blockquote><p>平时最容易犯的错误就是获得了一个None值，却对它进行各种方法调用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-literal">None</span>]<br><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> list1:<br>    print(char.join(<span class="hljs-string">&quot;A&quot;</span>))<br><br>    <br>AttributeError: <span class="hljs-string">&#x27;NoneType&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;join&#x27;</span>        <br></code></pre></td></tr></table></figure></blockquote><h2 id="列表-list">2.4 列表 List</h2><p>Python的列表是一个有序可重复的元素集合，可嵌套、迭代、修改、分片、追加、删除，成员判断。</p><p>从数据结构角度看，Python的列表是一个可变长度的顺序存储结构，每一个位置存放的都是对象的指针。</p><p>比如，对于这个列表 <code>alist = [1, “a”, [11,22], &#123;“k1”:”v1”&#125;]</code>，其在内存内的存储方式是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141602.png" /></p><h3 id="索引">索引</h3><p>索引是最左边记录的位置。用数字表示，从0开始，<code>len(list)-1</code> 结束。</p><ul><li>创建</li></ul><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表内的元素，可以是其它任意类型的数据，可多层嵌套列表，元素个数无限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = []        <span class="hljs-comment"># 创建一个空列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>], &#123;<span class="hljs-string">&#x27;k1&#x27;</span>:<span class="hljs-string">&#x27;v1&#x27;</span>&#125;]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><ul><li>访问</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;b&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;c&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">3</span>]<br><span class="hljs-comment">###########</span><br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><ul><li>修改：直接对元素进行重新赋值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;d&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>字符串不可以通过索引修改或删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;comprehensive&quot;</span><br>a[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;a&#x27;</span><br><br><span class="hljs-comment">############</span><br>TypeError: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br></code></pre></td></tr></table></figure></blockquote><ul><li>删除：使用 <code>del</code> 语句或者 <code>remove()</code> ，<code>pop()</code> 方法删除指定的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> lis[<span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis.remove(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[<span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis.pop()<br><span class="hljs-string">&#x27;c&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[]<br></code></pre></td></tr></table></figure><ul><li>常用函数</li></ul><table><thead><tr class="header"><th>函数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>len(list)</td><td>返回列表元素个数，也就是获取列表长度</td></tr><tr class="even"><td>max(list)</td><td>返回列表元素最大值</td></tr><tr class="odd"><td>min(list)</td><td>返回列表元素最小值</td></tr><tr class="even"><td>list(seq)</td><td>将序列转换为列表</td></tr><tr class="odd"><td>in/not in</td><td>判断某个元素是否在列表中</td></tr></tbody></table><h3 id="切片">切片</h3><p>切片指的是对序列进行截取，选取序列中的某一段。</p><p>切片的语法是： <code>list[start:end]</code>，注意，<strong>区间是左闭右开的</strong>！</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141634.png" /></p><ul><li>如果下标是负数，从后往前数，是 <code>-1 ~ -len(list)</code></li></ul><h3 id="列表的常见方法">列表的常见方法</h3><table><colgroup><col style="width: 39%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>函数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>append(item)</td><td>将一个元素添加到当前原有列表的末尾</td></tr><tr class="even"><td>insert(index, new_item)</td><td>插入新的元素，在什么位置。如果插入位置不存在，则加在结尾。如果插入位置存在元素，则该元素往后移，将插入元素放入该位置。</td></tr><tr class="odd"><td>count(item)</td><td>返回当前列表中某个元素的个数</td></tr><tr class="even"><td>remove(item)</td><td>删除列表的指定元素。如不存在，会报错。如有多个，只删第一个。</td></tr><tr class="odd"><td>del item</td><td>删掉整个列表</td></tr><tr class="even"><td>reverse()</td><td>反转当前列表</td></tr><tr class="odd"><td>sort(cmp=None, key=None, reverse=False)</td><td>对当前列表按照一定规律进行排序且list中的元素必须是统一类型，否则程序就会报错。</td></tr><tr class="even"><td>clear()</td><td>将list中的元素都清除，将其变成一个空列表即[]</td></tr><tr class="odd"><td>copy()/deepcopy()</td><td><strong>浅拷贝/深拷贝</strong></td></tr><tr class="even"><td>extend()</td><td>将其他list中的元素导入到当前的list</td></tr></tbody></table><blockquote><p>例：append()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">books = [<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>]<br>book = [<span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>]<br>books.append(book)<br>print(books)<br><br>---------------------------------<br>[<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, [<span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>]]<br></code></pre></td></tr></table></figure><ul><li>extend()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&quot;name&quot;</span>]<br>tuplee=(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>)<br><br>list1.extend(tuplee)<br>print(list1)<br><br>---------------------------------<br>[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>]<br></code></pre></td></tr></table></figure></blockquote><p>注意：</p><ol type="1"><li><p>其中的类似 append，insert, remove 等方法会修改列表本身，并且没有返回值（严格的说是返回None）。</p></li><li><p><font color='red'>浅拷贝与深拷贝</font></p><p>使用浅拷贝，当原容器对象中可变对象中有元素发生变化，拷贝得到的对象也会变化。而使用深拷贝时，不会有这种问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>]<br>list2 = list1.copy()<br><br>print(<span class="hljs-built_in">id</span>(list1), <span class="hljs-built_in">id</span>(list2))<br>list2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">123</span><br>list2[<span class="hljs-number">2</span>] = <span class="hljs-number">77</span><br>print(list1, list2)<br><br>---------------------------------<br><span class="hljs-number">1904206959560</span> <span class="hljs-number">1904227747656</span><br>[[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>] [[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>   <br>list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>]<br>list2 = copy.deepcopy(list1)<br>   <br>print(<span class="hljs-built_in">id</span>(list1), <span class="hljs-built_in">id</span>(list2))<br>list2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">123</span><br>list2[<span class="hljs-number">2</span>] = <span class="hljs-number">77</span><br>print(list1, list2)<br>   <br>---------------------------------<br><span class="hljs-number">1563824640968</span> <span class="hljs-number">1563844713928</span><br>[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>] [[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure><blockquote><p>可以理解为：浅拷贝对于一个复杂对象的子对象并不会完全复制，复杂对象的子对象是指比如序列中的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，python会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。</p></blockquote></li></ol><blockquote><p>例题：使用给定的整数n，编写一个程序生成一个包含(i, i*i)的字典，该字典包含1到n之间的整数(两者都包含)。然后程序应该打印字典。 假设向程序提供以下输入:8，则输出为:{1:1，2:4，3:9，4:16，5:25，6:36，,7:49，8:64}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">8</span><br>d = <span class="hljs-built_in">dict</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    d[i] = i * i<br>print(d)<br></code></pre></td></tr></table></figure></blockquote><h2 id="元组-tuple">2.5 元组 Tuple</h2><p>用圆括号括起来的是元组。</p><p>元组也是序列结构，但是是一种<strong>不可变序列</strong>，可以<strong>简单的理解为内容不可变的列表。除了在内部元素不可修改的区别外</strong>，元组和列表的用法差不多。</p><blockquote><p>因为元组是不可变的，所以不能在原来的数据基础上再添加数据，因此元组占用的资源会比列表更小。</p></blockquote><p><strong>元组与列表相同的操作</strong>：</p><ul><li>使用方括号加下标访问元素</li><li>切片（形成新元组对象）</li><li>count()/index()</li><li>len()/max()/min()/tuple()</li></ul><p><strong>元组中不允许的操作，确切的说是元组没有的功能</strong>：</p><ul><li><p>修改、新增元素</p><blockquote><p><strong>元组只保证它的一级子元素不可变，对于嵌套的元素内部，不保证不可变！</strong>所以，在使用元组的时候，请尽量使用数字、字符串和元组这种不可变的数据类型作为元组的元素，这样就能确保元组不发生变化。</p></blockquote></li><li><p>删除某个元素（但可以删除整个元组）</p></li><li><p>所有会对元组内部元素发生修改动作的方法。例如，元组没有remove，append，pop等方法。</p></li></ul><h2 id="字典-dic">2.6 字典 Dic</h2><p>字典可精确描述为<strong>不定长、可变、散列的集合类型</strong>。</p><p>字典数据类型是基于hash散列算法实现的，采用<strong>键值对(key:value)</strong>的形式，根据key的值计算value的地址，具有非常快的查取和插入速度。</p><p>字典包含的元素个数不限，值的类型可以是任何数据类型！但是字典的key必须是不可变的对象，例如数字、字符串、bytes和元组，最常见的还是将字符串作为key。列表、字典、集合等就不可以作为key。同时，同一个字典内的key必须是唯一的，但值则不必。</p><blockquote><p>字典类型的数据不支持累乘。</p></blockquote><ul><li>创建</li></ul><ol type="1"><li><code>dic = &#123;&#125;</code> # 创建空字典</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;&#125;    <span class="hljs-comment"># 创建空字典</span><br>dic = &#123;<span class="hljs-string">&#x27;Alice&#x27;</span>: <span class="hljs-string">&#x27;2341&#x27;</span>, <span class="hljs-string">&#x27;Beth&#x27;</span>: <span class="hljs-string">&#x27;9102&#x27;</span>, <span class="hljs-string">&#x27;Cecil&#x27;</span>: <span class="hljs-string">&#x27;3258&#x27;</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>([(<span class="hljs-string">&#x27;sape&#x27;</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">4098</span>)])<br>&#123;<span class="hljs-string">&#x27;sape&#x27;</span>: <span class="hljs-number">4139</span>, <span class="hljs-string">&#x27;jack&#x27;</span>: <span class="hljs-number">4098</span>, <span class="hljs-string">&#x27;guido&#x27;</span>: <span class="hljs-number">4127</span>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p><code>update()</code> ：在update函数里传入一个新的字典key和value就可以。存在就覆盖。</p></li><li><p><code>setdefault()</code>：传入一个字典key和value，如果键不存在于字典中，将会添加见并键值设为默认值，如果字典中包含有给定键，则返回该键对应的值，若不包含则返回为该键设置的值。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;&#125;<br>dic.setdefault(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;haha&#x27;</span>)<br>dic.setdefault(<span class="hljs-string">&#x27;sex&#x27;</span>)<br>print(dic)<br><br>---------------------------------<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>访问</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;Name&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;Name&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;Age&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;Age&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;address&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;address&#x27;</span>])<br><br>---------------------------------<br>KeyError: <span class="hljs-string">&#x27;address&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>增加和修改</li></ul><p>增加就是往字典插入新的键值对，修改就是给原有的键赋予新的值。由于一个key只能对应一个值，所以，多次对一个key赋值，后面的值会把前面的值冲掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;Shanghai&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;Beijing&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;Age&quot;</span>] = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic<br>&#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>删除字典元素、清空字典和删除字典</li></ul><p>使用 <code>del</code> 关键字删除字典元素或者字典本身，使用字典的 <code>clear()</code> 方法清空字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-keyword">del</span> dic[<span class="hljs-string">&#x27;Name&#x27;</span>]<br>print(dic)<br>a = dic.pop(<span class="hljs-string">&#x27;Class&#x27;</span>)  <span class="hljs-comment"># 弹出并返回指定键对应的值。必须提供参数！</span><br>print(a)<br>dic.clear()<br>print(dic)<br><span class="hljs-keyword">del</span> dic<br>print(dic)<br><br>---------------------------------<br>NameError: name <span class="hljs-string">&#x27;dic&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br>&#123;<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>First<br>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="字典的常见方法">字典的常见方法</h3><table><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><strong>get(key)</strong></td><td><strong>返回指定键的值，如果键不在字典中，则返回default值</strong></td></tr><tr class="even"><td><strong>items()</strong></td><td><strong>以列表返回可遍历的(键, 值) 元组对</strong></td></tr><tr class="odd"><td><strong>keys()</strong></td><td><strong>以列表返回字典所有的键，假列表，不可对其操作，可以通过list(dict.keys())变为真列表</strong></td></tr><tr class="even"><td><strong>values()</strong></td><td><strong>以列表返回字典所有的值，同上</strong></td></tr><tr class="odd"><td>pop(key)</td><td>删除并返回指定key的值</td></tr><tr class="even"><td>popitem()</td><td>删除并返回字典的最后一个键值对的(key,value)形式，不接受参数。且字典如果是空则直接报错</td></tr><tr class="odd"><td>setdefault(key, default=None)</td><td>和get()类似,但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr class="even"><td>update(dict2)</td><td>把字典dict2的键/值对更新到dict里</td></tr><tr class="odd"><td>copy()</td><td>将当前字典复制到一个新的字典</td></tr></tbody></table><p>注：</p><ol type="1"><li><code>get()</code> 和 <code>[]</code> 的区别</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>values = []<br>values.append(dic[<span class="hljs-string">&#x27;Name&#x27;</span>])<br>values.append(dic[<span class="hljs-string">&#x27;Age&#x27;</span>])<br>print(values)<br><span class="hljs-comment"># values.append(dic[&#x27;grade&#x27;])  # KeyError: &#x27;grade&#x27;</span><br>values.append(dic.get(<span class="hljs-string">&#x27;grade&#x27;</span>))<br>print(values)<br><br>---------------------------------<br>[<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;20&#x27;</span>]<br>[<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-literal">None</span>]<br></code></pre></td></tr></table></figure><blockquote><p>字典中获取key的方法[]如果获取不到key会直接报错，而get如果获取不到key会返回默认值，在开发中优先考虑get方法来获取key</p></blockquote><ol start="2" type="1"><li><code>get()</code> 与 <code>in</code> 判断的区别</li></ol><p>字典中的成员判断 in 和not in是判断是否有value，有对、无错，并不判断value是不是空。</p><p>而get判断值的结果，如果value是None就会返回False</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_1 = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-literal">None</span>&#125;  <br>bool(dict_1.get(&quot;name&quot;)) --&gt; False<br></code></pre></td></tr></table></figure><h3 id="遍历字典">遍历字典</h3><p><strong>遍历字典获得的键值对是有序的！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><br><span class="hljs-comment"># 1  直接遍历字典获取键，根据键取值</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic:<br>    print(key, dic[key])<br><br><span class="hljs-comment"># 2  利用items方法获取键值，速度很慢，少用！</span><br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> dic.items():<br>    print(key,value)<br><br><span class="hljs-comment">#3  利用keys方法获取键</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic.keys():<br>    print(key, dic[key])<br><br><span class="hljs-comment">#4  利用values方法获取值，但无法获取对应的键。</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> dic.values():<br>    print(value)<br></code></pre></td></tr></table></figure><h2 id="集合-set">2.7 集合 set</h2><p><strong>集合是一个无序不重复元素的集</strong>，基本功能包括关系测试和消除重复元素。集合使用大括号 <code>&#123;&#125;</code> 框定元素，并以逗号进行分隔。成员是不可变类型。</p><p>但是注意：<u>如果要创建一个空集合，必须用 set() 而不是 {} ，因为后者创建的是一个空字典</u>。集合除了在形式上最外层用的也是花括号外，其它的和字典没有一毛钱关系。</p><p>集合数据类型的核心在于<strong>自动去重</strong>。很多时候能省不少事。</p><ul><li>增加</li></ul><ol type="1"><li>通过add(key)方法可以添加一个元素到set中，可以重复添加，但不会有效果</li><li>可以通过update()方法，将另一个对象更新到已有的集合中，这一过程同样会进行去重。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>s.add(<span class="hljs-number">5</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5&#125;</span><br><br>s.update(<span class="hljs-string">&quot;hello&quot;</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>删除</li></ul><p>通过remove(key)方法删除指定元素，或者使用pop()方法。注意，集合的pop方法无法设置参数，删除指定的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br>s.remove(<span class="hljs-string">&#x27;l&#x27;</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br>s.pop(<span class="hljs-number">3</span>)  <span class="hljs-comment"># TypeError: pop() takes no arguments (1 given)</span><br></code></pre></td></tr></table></figure><p><strong>不能从集合取某个元素。因为集合既不支持下标索引也不支持字典那样的通过键获取值。</strong></p><h3 id="集合的常用方法">集合的常用方法</h3><table><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>difference() / -</td><td>返回集合的差集</td></tr><tr class="even"><td>intersection()</td><td>返回集合的交集</td></tr><tr class="odd"><td>union()</td><td>返回集合的并集</td></tr><tr class="even"><td>isdisjoint()</td><td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr class="odd"><td>issubset()</td><td>判断指定集合是否为该方法参数集合的子集。</td></tr><tr class="even"><td>add()</td><td>为集合添加一个元素</td></tr><tr class="odd"><td>update()</td><td>给集合添加元素</td></tr><tr class="even"><td>pop()</td><td>移除元素</td></tr><tr class="odd"><td>remove()</td><td>移除指定元素</td></tr></tbody></table><h1 id="函数">3. 函数</h1><p>总结函数的传参方式，有以下四种：</p><ul><li>位置参数</li><li>默认参数</li><li>关键参数</li><li>非固定参数<ul><li><code>*args</code></li><li><code>**kwargs</code></li></ul></li></ul><h2 id="位置参数">3.1 位置参数</h2><p>位置参数就是调用函数时穿的实参与形参位置上一一对应的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country</span>):</span><br>print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;CN&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="默认参数">3.2 默认参数</h2><p>默认参数就是在函数形参中定义好的，当是惨重未穿对应的参数时，参数就会以默认值为准。</p><p>注：默认参数必须放在位置参数之后，否则会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country = <span class="hljs-string">&#x27;CN&#x27;</span></span>):</span><br>print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="关键参数">3.3 关键参数</h2><p>正常情况下，给函数传参数要按照顺序，如果不按顺序就可以用关键参数，只需指定参数名即可（指定参数名的参数叫关键参数）</p><p>注：关键参数必须放在位置参数（以位置顺序确定对应关系的参数）之后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country = <span class="hljs-string">&#x27;CN&#x27;</span></span>):</span><br>print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, country = <span class="hljs-string">&#x27;UK&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="非固定参数">3.4 非固定参数</h2><p><code>*args</code>与 <code>**kwargs</code> 是可变类型且 <code>*args</code> 将参数封装成元组类型给函数体调用，<code>**kwargs</code> 将参数封装成字典类型给函数体调用</p><blockquote><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">seq</span>(<span class="hljs-params">num, num1, num2</span>):</span><br>    <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">88</span> :<br>        print(num1 * num2)<br>    <span class="hljs-keyword">else</span>:<br>        print(num1 + num2)<br>        <br><span class="hljs-comment"># 定义变量tuple1的值为(5,2,1)</span><br>tuple1 = (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 调用函数，传入参数tuple1，并打印函数返回值</span><br>seq(*tuple1)  <span class="hljs-comment"># *tuple1可实现对元组tuple1的解包</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="args">3.4.1 <code>*args</code></h3><p>可同时指定多个用户，传过来的所有参数打包成元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_args</span>(<span class="hljs-params">first, *args</span>):</span><br>    print(<span class="hljs-string">&#x27;Required argument: &#x27;</span>, first)<br>    print(<span class="hljs-built_in">type</span>(args))<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> args:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument: &#x27;</span>, v)<br><br>test_args(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>第一个参数是必须要传入的参数，所以使用了第一个形参，而后面三个参数则作为可变参数列表传入了实参，并且是作为元组tuple来使用的。代码的运行结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Required argument:  <span class="hljs-number">1</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">tuple</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">Optional</span> <span class="hljs-title">argument</span>:</span>  <span class="hljs-number">2</span><br>Optional argument:  <span class="hljs-number">3</span><br>Optional argument:  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="kwargs">3.4.2 <code>**kwargs</code></h3><p>可同时指定多个用户，传过来的所有参数打包成元组或字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_kwargs</span>(<span class="hljs-params">first, *args, **kwargs</span>):</span><br>   print(<span class="hljs-string">&#x27;Required argument: &#x27;</span>, first)<br>   print(<span class="hljs-built_in">type</span>(kwargs))<br>   <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> args:<br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument (args): &#x27;</span>, v)<br>   <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items():<br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument %s (kwargs): %s&#x27;</span> % (k, v))<br><br>test_kwargs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, k1=<span class="hljs-number">5</span>, k2=<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>正如前面所说的，<code>args</code> 类型是一个tuple，而 <code>kwargs</code> 则是一个字典 <code>dict</code>，并且 <code>args</code> 只能位于 <code>kwargs</code> 的前面。代码的运行结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Required argument:  <span class="hljs-number">1</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">dict</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">Optional</span> <span class="hljs-title">argument</span> (<span class="hljs-params">args</span>):</span>  <span class="hljs-number">2</span><br>Optional argument (args):  <span class="hljs-number">3</span><br>Optional argument (args):  <span class="hljs-number">4</span><br>Optional argument k1 (kwargs): <span class="hljs-number">5</span><br>Optional argument k2 (kwargs): <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="综合练习函数的使用">综合练习：函数的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    学生信息库</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>students = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;dewei&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小木&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">5</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小安&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 检查位置参数的判断</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_info</span>(<span class="hljs-params">**kwargs</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生姓名&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生年龄&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生性别&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生班级&#x27;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_students</span>():</span><br>    <span class="hljs-keyword">for</span> id_, value <span class="hljs-keyword">in</span> students.items():<br>        print(<span class="hljs-string">&#x27;学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>            id_, value[<span class="hljs-string">&#x27;name&#x27;</span>], value[<span class="hljs-string">&#x27;age&#x27;</span>], value[<span class="hljs-string">&#x27;sex&#x27;</span>], value[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>        ))<br>    <span class="hljs-keyword">return</span> students<br><br><span class="hljs-comment"># result = get_all_students()</span><br><span class="hljs-comment"># print(&#x27;---&#x27;, result)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_student</span>(<span class="hljs-params">**kwargs</span>):</span><br>    check = check_user_info(**kwargs)<br>    <span class="hljs-keyword">if</span> check != <span class="hljs-literal">True</span>:<br>        print(check)<br>        <span class="hljs-keyword">return</span><br><br>    id_ = <span class="hljs-built_in">max</span>(students) + <span class="hljs-number">1</span>  <span class="hljs-comment"># 不在长度上加1，会覆盖以前删掉的号码</span><br><br>    students[id_] = &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: kwargs[<span class="hljs-string">&#x27;name&#x27;</span>],<br>        <span class="hljs-string">&#x27;age&#x27;</span>: kwargs[<span class="hljs-string">&#x27;age&#x27;</span>],<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: kwargs[<span class="hljs-string">&#x27;sex&#x27;</span>],<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: kwargs[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>    &#125;<br><br><span class="hljs-comment"># add_student(name=&#x27;小章鱼&#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span><br><span class="hljs-comment"># get_all_students()</span><br><br><span class="hljs-comment"># 删除</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_student</span>(<span class="hljs-params">student_id</span>):</span><br>    <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> students:<br>        print(<span class="hljs-string">&#x27;学号是&#123;&#125;号的同学的信息不存在&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br>    <span class="hljs-keyword">else</span>:<br>        user_info = students.pop(student_id)<br>        print(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br><span class="hljs-comment"># delete_student(2)</span><br><span class="hljs-comment"># add_student(name=&#x27;小章鱼&#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span><br><span class="hljs-comment"># get_all_students()</span><br><br><span class="hljs-comment"># 修改</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_student</span>(<span class="hljs-params">student_id, **kwargs</span>):</span><br>    <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> students:<br>        print(<span class="hljs-string">&#x27;不存在学号：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br><br>    check = check_user_info(**kwargs)<br>    <span class="hljs-keyword">if</span> check != <span class="hljs-literal">True</span>:<br>        print(check)<br>        <span class="hljs-keyword">return</span><br><br>    students[student_id] = kwargs<br>    print(<span class="hljs-string">&#x27;&#123;&#125;同学信息更新完毕&#x27;</span>.<span class="hljs-built_in">format</span>(kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>update_student(<span class="hljs-number">2</span>, name=<span class="hljs-string">&#x27;2小木&#x27;</span>, age=<span class="hljs-number">11</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>,class_number=<span class="hljs-string">&#x27;B&#x27;</span>)<br>get_all_students()<br><br><span class="hljs-comment"># 查找，通过学号</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_id</span>(<span class="hljs-params">student_id</span>):</span><br>    <span class="hljs-keyword">return</span> students.get(student_id)<br><br>print(get_user_by_id(<span class="hljs-number">3</span>))<br><br><span class="hljs-comment">#</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_users</span>(<span class="hljs-params">**kwargs</span>):</span><br>    values = <span class="hljs-built_in">list</span>(students.values())<br>    key = <span class="hljs-literal">None</span><br>    value = <span class="hljs-literal">None</span><br>    result = []<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;name&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;age&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;sex&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;class_number&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;没有发现搜索的关键字&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> values:<br>        <span class="hljs-keyword">if</span> user[key] == value:<br>            result.append(user)<br><br>    <span class="hljs-keyword">return</span> result<br><br>print(<span class="hljs-string">&#x27;--------------------&#x27;</span>)<br>users = search_users(sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>print(users)<br></code></pre></td></tr></table></figure><h1 id="面向对象编程">4. 面向对象编程</h1><p>基本概念：</p><ul><li>面向对象：是一种以对象为核心的编程思想。主要是找出问题中的共性问题，作为对象进行操作。</li><li>类：类可以创建实例。</li><li>对象：类不能直接使用。通过类创建实例，也就是对象，才能使用。</li><li>属性：类中的所有变量都称为属性。</li><li>方法：类中的所有函数都成为方法。不过，和函数有所不同的是，类方法至少要包含一个 <code>self</code> 参数。类方法不能单独使用，需要和类的对象一起使用。创建对象后就可以直接调用类中的方法和属性。</li></ul><h2 id="类的-self-参数">4.1 类的 self 参数</h2><ul><li><code>self</code> 是类函数中的必传参数，且必须定义在第一个参数位置</li><li><code>self</code> 是一个对象，他代表实例化的变量自身</li><li><code>self</code> 可以直接通过点 <strong><code>.</code></strong> 来定义一个类变量</li></ul><p><code>self</code> 的举例说明：</p><p><strong>1、属性</strong></p><ol type="1"><li>如果变量定义在类下面而不是类的方法下面，那这个变量既是类的属性也是类实例的属性。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    name = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>    age = <span class="hljs-string">&#x27;21&#x27;</span><br><br>ps = Person()<br>print(ps.name)<br><br>---------------------<br>xiaozhang<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>如果变量定义在类的方法下面，如果加了 <code>self</code> ，那这个变量就是<u>类实例</u>的属性，而不是类的属性；如果没加 <code>self</code> ，那这个变量就是这个方法的局部变量，既不是类的属性也不是类实例的属性。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.name = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>        age = <span class="hljs-string">&#x27;21&#x27;</span><br><br>ps = Person()<br>print(ps.name)<br>print(ps.age)<br><br>---------------------------------<br>xiaozhang<br>Traceback (most recent call last):<br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;age&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>2、方法</strong></p><ol type="1"><li>如果在类中定义函数时<u>加了</u> <code>self</code> ，那这个函数就是类实例的方法，而不是类的方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小张爱跑步&#x27;</span>)<br><br><br>ps = Person()<br>ps.run()<br><span class="hljs-comment"># Person.run()</span><br><br>---------------------------------<br>小张爱跑步<br><span class="hljs-comment"># TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>如果在类中定义函数时<u>没加</u> <code>self</code> ，那这个函数就只是类的方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>        print(<span class="hljs-string">&#x27;小张爱跑步&#x27;</span>)<br><br><br>ps = Person()<br><span class="hljs-comment"># ps.run()</span><br>Person.run()<br><br>---------------------------------<br><span class="hljs-comment"># TypeError: run() takes 0 positional arguments but 1 was given</span><br>小张爱跑步<br><br></code></pre></td></tr></table></figure><h2 id="私有函数与私有变量">4.2 私有函数与私有变量</h2><ul><li>只希望类内部业务调用使用，不希望被使用者调用</li><li>私有函数与变量无法被实例化后的对象所调用</li><li><p>而类内部可以调用私有函数与变量</p></li><li><p>在变量或者函数前添加两个下横线 <code>__</code></p></li></ul><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __cat_type = <span class="hljs-string">&#x27;cat&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, sex</span>):</span><br>        self.name = name<br>        self.__sex = sex<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        tmp = self.__run()<br>        print(tmp)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="hljs-subst">&#123;self.name&#125;</span> <span class="hljs-subst">&#123;self.__sex&#125;</span> 开心的奔跑着&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span>(<span class="hljs-params">self</span>):</span><br>        tmp = self.__jump()<br>        print(tmp)                                        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__jump</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="hljs-subst">&#123;self.name&#125;</span> <span class="hljs-subst">&#123;self.__sex&#125;</span> 开心的跳着&#x27;</span><br><br>cat = Cat(name = <span class="hljs-string">&#x27;米粒&#x27;</span>, sex = <span class="hljs-string">&#x27;boy&#x27;</span>)<br>cat.run()<br>cat.jump()<br><span class="hljs-comment"># cat.__run()</span><br>print(<span class="hljs-built_in">dir</span>(cat))  <span class="hljs-comment"># dir() 可以查看实例化对象有哪些方法</span><br>print(cat._Cat__jump())  <span class="hljs-comment"># 实例化对象调用私有函数也可以行得通，但是最好不要这样做</span><br>print(cat._Cat__cat_type)<br><br>---------------------------------<br>cat, 小猫 米粒 boy 开心的奔跑着<br>cat, 小猫 米粒 boy 开心的跳着<br>[<span class="hljs-string">&#x27;_Cat__cat_type&#x27;</span>, <span class="hljs-string">&#x27;_Cat__jump&#x27;</span>, <span class="hljs-string">&#x27;_Cat__run&#x27;</span>, <span class="hljs-string">&#x27;_Cat__sex&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;jump&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;run&#x27;</span>]<br>cat, 小猫 米粒 boy 开心的跳着<br>cat<br><br></code></pre></td></tr></table></figure><h3 id="举个栗子----编程练习">举个栗子----编程练习：</h3><p>自定义一个交通工具类(Vehicle)，并根据提示对该类进行进一步封装，使其拥有工具类型、速度、体积等属性值。通过自定义实例方法实现交通工具的前移、速度设置、获取当前速度、加速行驶、减速行驶、实例信息展示、实例类型判别等功能。</p><p>任务 1、自定义一个交通工具类(Vehicle) 2、设置类属性trans_type（固定值为'SUV'）和实例属性速度speed（int 类型，单位为 km/h）、体积size（tuple类型，单位为米。） 3、自定义方法 show_info( )，打印实例的所属类型和速度、体积的值； 4、自定义实例方法如下： （1）定义move( )方法，实现打印“我已向前移动了50米” （2）定义set_speed(new_speed)方法，设置对应实例的速度为new_speed km/h （3）定义get_speed()方法，如果（2）中设置了速度值则打印出来，打印格式为'我的时速为：设置的速度值 km/h' （4）定义speed_up()方法，设置每次调用时实例的速度都增加10km/h，并打印“我的速度由xx km/提升到了xx km/h” （5）定义speed_down()方法，设置每次调用时实例的速度都降低15km/h，并打印“我的速度由xx km/下降到了xx km/h” 5、自定义方法 transport_identify( )，判断实例是否为Vehicle类型。若是则打印‘类型匹配’，反之则打印‘类型不匹配’ 6、初始化实例对象tool_1</p><p>任务提示 类的初始化方法中所传参数size是元组类型，直接传入实例的长，宽，高即可，如size=(10,10,10)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 自定义Vehicle类属性</span><br>    trans_type = <span class="hljs-string">&#x27;SUV&#x27;</span><br><br>    <span class="hljs-comment"># 自定义实例的初始化方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, speed, size</span>):</span><br>        self.speed = speed<br>        self.size = size<br><br>    <span class="hljs-comment"># 自定义实例方法show_info，打印实例的速度和体积</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我的所属类型为: &#123;&#125;, 我的速度: &#123;&#125; km/h, 我的体积: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.trans_type, self.speed, self.size))<br><br>    <span class="hljs-comment"># 自定义实例方法move,打印“我已向前移动了50米”</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我已向前移动了50米&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义实例方法set_speed，设置对应的速度值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_speed</span>(<span class="hljs-params">self, new_speed</span>):</span><br>        self.speed = new_speed  <span class="hljs-comment"># 在这里将旧速度与新设置的速度进行统一。</span><br><br>    <span class="hljs-comment"># 自定义实例方法get_speed，打印当前的速度值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_speed</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我的时速为 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(self.speed))<br><br>    <span class="hljs-comment"># 自定义实例方法speed_up，实现对实例的加速</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speed_up</span>(<span class="hljs-params">self</span>):</span><br>        old_speed = self.speed<br>        self.speed += <span class="hljs-number">10</span><br>        print(<span class="hljs-string">&quot;我的时速由 &#123;&#125; km/h 提升到了 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(old_speed, self.speed))<br><br><span class="hljs-comment"># 自定义实例方法speed_down，实现对实例的减速</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speed_down</span>(<span class="hljs-params">self</span>):</span><br>        old_speed = self.speed<br>        self.speed -= <span class="hljs-number">15</span><br>        print(<span class="hljs-string">&quot;我的时速由 &#123;&#125; km/h 下降到了 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(old_speed, self.speed))<br><br><span class="hljs-comment"># 自定义实例方法transport_identify，实现对实例所属类型的判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transport_identify</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.trans_type == <span class="hljs-string">&#x27;SUV&#x27;</span>:<br>            print(<span class="hljs-string">&quot;类型匹配&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;类型不匹配&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    tool_1 = Vehicle(<span class="hljs-number">20</span>, (<span class="hljs-number">3.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">1.75</span>))<br><br>    <span class="hljs-comment"># 调用实例方法 打印实例的速度和体积</span><br>    tool_1.show_info()<br><br>    <span class="hljs-comment"># 调用实例方法 实现实例的前移</span><br>    tool_1.move()<br><br>    tool_1.set_speed(<span class="hljs-number">40</span>)<br>    <span class="hljs-comment"># 调用实例方法 打印当前速度</span><br>    tool_1.get_speed()<br><br>    <span class="hljs-comment"># 调用实例方法 对实例进行加速</span><br>    tool_1.speed_up()<br><br>    <span class="hljs-comment"># 调用实例方法 对实例进行减速</span><br>    tool_1.speed_down()<br><br>    <span class="hljs-comment"># 调用实例方法 判断当前实例的类型</span><br>    tool_1.transport_identify()<br>    <br>---------------------------------------------    <br>我的所属类型为: SUV, 我的速度: <span class="hljs-number">20</span> km/h, 我的体积: (<span class="hljs-number">3.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">1.75</span>)<br>我已向前移动了<span class="hljs-number">50</span>米<br>我的时速为 <span class="hljs-number">40</span> km/h<br>我的时速由 <span class="hljs-number">40</span> km/h 提升到了 <span class="hljs-number">50</span> km/h<br>我的时速由 <span class="hljs-number">50</span> km/h 下降到了 <span class="hljs-number">35</span> km/h<br>类型匹配<br></code></pre></td></tr></table></figure><h2 id="类的封装">4.3 类的封装</h2><p><strong>封装</strong>：将<u>不对外的私有属性或方法</u>通过<u>可对外使用的函数</u>而使用（类中定义私有的，只有类内部使用，外部无法访问）</p><ul><li>这样做的原因：保护隐私，明确区分内外</li></ul><blockquote><p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。 对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者self间接获取被封装的内容。</p></blockquote><h2 id="装饰器">4.4 装饰器</h2><p><strong>装饰器</strong>：装饰器本质上就是一个python函数，他可以让其他函数在<strong>不需要做任何代码变动的前提下，增加额外的功能</strong>，装饰器的<strong>返回值也是一个函数对象</strong>。他们有助于让代码更简短，也更Pythonic（Python范儿）。装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等等场景。有了装饰器，我们可以抽离出大量与函数功能本身无关的雷同代码。</p><p>我们知道，在python中，我们可以像使用变量一样使用函数，这主要依赖于以下几点：</p><ul><li>函数可以被赋值给其他变量</li><li>函数可以被删除</li><li>可以在函数里面再定义函数，函数嵌套。</li><li><strong>函数可以作为参数传递给另外一个函数</strong></li><li>函数可以作为另一个函数的返回值</li></ul><p>为了更好的理解装饰器，先从对一个简单的函数进行装饰，假设有下面这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world!&quot;</span><br></code></pre></td></tr></table></figure><p>现在我们的需求是要增强 <code>hello()</code> 函数的功能，希望给返回加上HTML标签，比如<code>&lt;i&gt;he不得改变</code>hello()` 函数原来的定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span>+fun()+<span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个函数 <code>makeitalic</code>，该函数有一个参数 <code>fun</code>，它是一个函数；在 <code>makeitalic</code> 函数里面我们又定义了一个内部函数 <code>wrapped</code> ，并将该函数作为返回。</p><p>现在我们就达到了我们的需求，不改变 <code>hello()</code> 函数的定义，但实现了我们想要的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>          <span class="hljs-keyword">return</span> wrapped<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br>hello = makeitalic(hello)<br>print(hello()) <span class="hljs-comment"># &lt;i&gt;hello world&lt;/i&gt;</span><br></code></pre></td></tr></table></figure><p>在上面，我们将 <code>hello</code> 函数传入 <code>makeitalic</code> ，再将返回赋值给 <code>hello</code> ，此时，调用 <code>hello()</code> 函数就可以得到我们想要的结果。 不过需要注意的是，由于我们将 <code>makeitalic</code> 的返回赋值给 <code>hello</code> ，此时，<code>hello()</code> 函数仍然存在，但它已不在指向原来定义的 <code>hello()</code> 函数了，而是指向了 <code>wrapped</code>。</p><p>现在我们来总结一下，上面例子为了增强原函数 <code>hello</code> 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，在这个返回的函数中，执行了原函数，并对原函数的功能进行了增强。完整的代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>          <span class="hljs-keyword">return</span> wrapped<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br>hello = makeitalic(hello)<br>print(hello())<br>print(hello.__name__)<span class="hljs-number">123456789101112</span><br></code></pre></td></tr></table></figure><p>事实上，<code>makeitalic</code> 就是一个装饰器（<code>decorator</code>），它封装了原函数 <code>hello</code>，并返回了一个新函数，用于增强原函数的功能，并将其赋值给 <code>hello</code>。</p><p>一般情况下，我们使用装饰器提供的<strong><span class="citation" data-cites="语法糖">@语法糖</span>（Syntactic Sugar）</strong>，来简化上面的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-meta">@makeitalic</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><p>这种做法是我们在平时写程序时，常见的操作，但前面例子中的讲解才是内部的实现原理。</p><p>像上面的情况，可以动态的修改函数（或类的）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 <code>hello</code>）为参数，并返回一个包装后的函数（比如上面的 <code>wrapped</code>）给被修饰函数（<code>hello</code>）。</p><blockquote><p>之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，<strong>糖在不改变其所在位置的语法结构的前提下，实现了运行时等价</strong>。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。</p><p>之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：<strong>代码更简洁流畅，代码更语义自然</strong>... 写得爽，看着爽，就像吃了糖hhh。据说还有语法盐hhh反人类的代码</p></blockquote><p>举个简单的栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_str</span>(<span class="hljs-params">func</span>):</span><br>    print(<span class="hljs-string">&#x27;func:&#x27;</span>, func)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        print(<span class="hljs-string">&#x27;args:&#x27;</span>, args, kwargs)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-keyword">if</span> result == <span class="hljs-string">&#x27;okk&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is %s&#x27;</span> % result<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is failed:%s &#x27;</span> % result<br><br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@check_str</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">return</span> data<br><br>result = test(<span class="hljs-string">&#x27;no&#x27;</span>)<br>print(result)<br><br>result = test(<span class="hljs-string">&#x27;okk&#x27;</span>)<br>print(result)<br><br>-------------------------------------<br>func: &lt;function test at <span class="hljs-number">0x00000191FC0A9168</span>&gt;<br>args: (<span class="hljs-string">&#x27;no&#x27;</span>,) &#123;&#125;<br>result <span class="hljs-keyword">is</span> failed:no <br>args: (<span class="hljs-string">&#x27;okk&#x27;</span>,) &#123;&#125;<br>result <span class="hljs-keyword">is</span> okk<br></code></pre></td></tr></table></figure><blockquote><p>小练习：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141840.png" style="zoom:60%;" /></p><p>输出：</p><p>​ 2018-11-27</p><p>​ call hello()</p><p>​ hello world</p><p>​ 本题考查的是装饰器的应用。代码中函数的执行顺序为先执行now函数再执行hello函数，执行now函数时输出2018-11-27，当执行hello函数时，发现了装饰器log函数，因此要先执行装饰器，输出call hello(): ，然后执行传入的hello函数，输出hello world</p></blockquote><h2 id="常用的装饰器">4.5 常用的装饰器</h2><ul><li><code>classmethod</code></li><li><code>staticmethod</code></li><li><code>property</code></li></ul><h3 id="classmethod-的功能">4.5.1 <code>classmethod</code> 的功能</h3><p><code>classmethod</code> ：将类函数可以不经过实例化而直接被调用。</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, a</span>):</span><br>        self.a = a<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;run&#x27;</span>)<br>        self.jump()  <span class="hljs-comment"># # &gt;&gt;&gt; run/n jump 证明普通的self函数可以调用带有classmethod装饰器的类函数</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span>(<span class="hljs-params">cls</span>):</span><br>        print(<span class="hljs-string">&#x27;jump&#x27;</span>)<br>        <span class="hljs-comment"># cls.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br>                   <span class="hljs-comment"># 证明带有classmethod装饰器的类函数无法调用self函数</span><br><br>t = Test(<span class="hljs-string">&#x27;aa&#x27;</span>)<br><span class="hljs-comment"># t.run()</span><br><span class="hljs-comment"># Test.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br>            <span class="hljs-comment"># 因为没有实例化！(这时就可以用classmethod)</span><br><span class="hljs-comment"># Test.jump()  # &gt;&gt;&gt; jump</span><br>t.run()   <span class="hljs-comment"># &gt;&gt;&gt; run/n jump</span><br></code></pre></td></tr></table></figure><h3 id="staticmethod-的功能">4.5.2 <code>staticmethod</code> 的功能</h3><p><code>staticmethod</code> ：可以将类函数不经过实例化而直接被调用，被该装饰器调用的函数<strong>不许传递 <code>self</code> 或 <code>cls</code> 参数</strong>，且无法在该函数内调用其它类函数或类变量。</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, a</span>):</span><br>        self.a = a<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;run&#x27;</span>)<br>        self.sleep()  <span class="hljs-comment"># 证明普通的self函数可以调用带有staticmethod装饰器的类函数</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span>():</span><br>        print(<span class="hljs-string">&#x27;i wanna sleep&#x27;</span>)<br>        self....  <span class="hljs-comment"># 直接报错，都没有self参数</span><br><br>t = Test(<span class="hljs-string">&#x27;aa&#x27;</span>)<br>Test.sleep()  <span class="hljs-comment"># &gt;&gt;&gt; i wanna sleep</span><br>t.sleep()  <span class="hljs-comment"># &gt;&gt;&gt; i wanna sleep</span><br>t.run()  <span class="hljs-comment"># &gt;&gt;&gt; run\n i wanna sleep</span><br><br></code></pre></td></tr></table></figure><h3 id="property-的功能">4.5.3 <code>property</code> 的功能</h3><p><code>property</code> ：将类含糊的执行免去括弧，类似于调用属性(变量)</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.__name = name<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__name<br><br><span class="hljs-meta">    @name.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self, value</span>):</span><br>        self.__name = value<br><br>t = Test(name=<span class="hljs-string">&#x27;xiaozhang&#x27;</span>)<br>print(t.name)<br><br>t.name = <span class="hljs-string">&#x27;xiaohong&#x27;</span>  <span class="hljs-comment"># AttributeError: can&#x27;t set attribute</span><br>print(t.name)<br></code></pre></td></tr></table></figure><h2 id="类的继承">4.6 类的继承</h2><p>1、什么是继承？</p><ul><li>通过继承基类来得到基类的功能</li><li>被继承的类称作父类或基类，继承者称作子类</li><li><strong>代码重用</strong></li></ul><p>2、父类和子类的关系？</p><ul><li>子类拥有父类的<strong>所有属性和方法</strong></li><li>父类不具备子类<strong>自有</strong>的属性和方法</li></ul><p>3、继承的用法：</p><ul><li>定义子类时，将父类传入子类参数内</li><li>子类实例化可以调用自己与父类的函数与变量</li><li>父类无法调用子类的函数与变量</li></ul><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, sex</span>):</span><br>        self.name = name<br>        self.sex = sex<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is talking&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_sex</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.sex == <span class="hljs-string">&#x27;boy&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is a boy&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is a girl&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildOne</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play_football</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is playing football&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildTwo</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play_pingpong</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is playing pingpong&#x27;</span><br><br>c_one = ChildOne(name=<span class="hljs-string">&#x27;小张&#x27;</span>, sex=<span class="hljs-string">&#x27;girl&#x27;</span>)<br>result = c_one.play_football()<br>print(result)<br>result = c_one.talk()<br>print(result)<br><br>c_two = ChildTwo(name=<span class="hljs-string">&#x27;小红&#x27;</span>, sex=<span class="hljs-string">&#x27;girl&#x27;</span>)<br>result = c_two.play_pingpong()<br>print(result)<br>result = c_two.talk()<br>print(result)<br><br>p = Parent(name=<span class="hljs-string">&#x27;父亲&#x27;</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>result = p.talk()<br>print(result)<br>result = p.is_sex()<br>print(result)<br>result = p.playing()  <span class="hljs-comment"># AttributeError: &#x27;Parent&#x27; object has no attribute &#x27;playing&#x27;</span><br><br></code></pre></td></tr></table></figure><p>4、<strong><code>super</code> 函数</strong>的作用 (<strong>单继承</strong>)</p><p><code>super</code> ：是python子类继承父类的方法而使用的关键字，当子类继承父类后，就可以使用父类的方法。</p><blockquote><p>注：一般适用于<strong>单继承</strong>。</p></blockquote><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, p</span>):</span><br>        print(<span class="hljs-string">&#x27;hello i am parent %s&#x27;</span> % p)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, c, p</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(p)<br>        print(<span class="hljs-string">&#x27;hello i am child %s&#x27;</span> % c)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    c = Child(c=<span class="hljs-string">&#x27;小张&#x27;</span>, p=<span class="hljs-string">&#x27;老张&#x27;</span>)<br>    <br>----------------------------------------------------<br>hello i am parent 老张<br>hello i am child 小张<br></code></pre></td></tr></table></figure><h3 id="举个栗子----编程练习-1">举个栗子----编程练习：</h3><p>自定义两个类Person和Student，且Student继承自Person。Person类主要描述人的姓名和性别两大基本特征。Student类除了保持父类的基本属性之外还具有分数、主修两个公有属以及一个私有属性（学号）。请根据上述的基本说明，对stu和stu_2两个对象的信息进行综 合展示。</p><p>任务 1、自定义Person类，并重写其构造（初始化）方法<code>__init__( )</code>，将name和gender参数赋值给实例对象的属性 2、自定义实例方法<code>speak( )</code>，功能：打印“hello ! 我是xxx”。<code>relaton( )</code>方法主要是占位作用，无其他实质性功能 3、自定义Student类，继承自Person类，并重写其构造（初始化）方法<code>__init__( )</code>，name、gender参数通过调用父类的构造函数进行赋值，score和major通过子类重写的<code>__init__( )</code>进行赋值。 4、自定义实例方法<code>speak( )</code>，功能：打印 '我的学号为xxxxxxxxxx，很高兴认识大家'; 5、自定义实例方法<code>identify_stu( )</code>，功能：判断Student对象的学号。若学号为2018014002，则打印‘我的分组已经完成’，反之则打印‘请稍后，马上为你自动分组’； 6、自定义实例方法<code>set_num( new_num)</code>，功能：将学号重写设置为new_num； 7、自定义实例方法<code>relation( )</code>，功能：判断Student是否为Person的子类。若成立，则打印‘我的父类是Person’，反之则打印‘父类在查询中······’ 8、初始化实例对象stu和stu_2，并根据上述效果图调用对应方法</p><p>任务提示 Person类中的实例方法<code>relation( )</code>为占位功能时，其方法体可用pass语句代替</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 重写实例对象的构造（初始化）方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, gender</span>):</span><br>        self.name = name<br>        self.gender = gender<br><br>    <span class="hljs-comment"># 自定义实例方法，格式化打印实例属性name的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;hello! 我是 %s 。&quot;</span> % self.name)<br><br>    <span class="hljs-comment"># 自定义实例方法，占位作用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relation</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">Person</span>):</span><br>    <span class="hljs-comment"># 重写实例对象的构造（初始化）方法，并调用父类构造方法，实现对实例属性的赋值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, gender, score, major, __stu_num = <span class="hljs-string">&#x27;2018014002&#x27;</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__( name, gender)<br>        self.score = score<br>        self.major = major<br>        self.__stu_num = __stu_num<br><br>    <span class="hljs-comment"># 自定义实例方法，格式化打印实例属性stu_num的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;我的学号为 %s，很高兴认识大家&#x27;</span> % self.__stu_num)<br><br>    <span class="hljs-comment"># 自定义实例方法，判断学号是否为既定值，并根据判断结构 进行分类打印</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identify_stu</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.__stu_num == <span class="hljs-string">&#x27;2018014002&#x27;</span>:<br>            print(<span class="hljs-string">&quot;我的分组已经完成&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;请稍后，马上为你自动分组&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义实例方法，设置实例对象的学号为传入的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_num</span>(<span class="hljs-params">self, new_num</span>):</span><br>        self.__stu_num = new_num<br><br>    <span class="hljs-comment"># 自定义实例方法，判断该类是否为Person类的子类，并进行分类打印</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relation</span>(<span class="hljs-params">self, cls_son, cls_fa</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(cls_son, cls_fa):<br>            print(<span class="hljs-string">&quot;我的父类是Person&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;父类正在查询中....&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    stu = Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;数学&#x27;</span>)<br>    <span class="hljs-comment"># 调用speak方法 打印stu对应的值</span><br>    stu.speak()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别学号是否为指定值</span><br>    stu.identify_stu()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别实例对象所属的类的父类是否为Person</span><br>    stu.relation(Student, Person)<br><br>    print(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">12</span>)<br><br>    stu_2 = Student(<span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>)<br>    <span class="hljs-comment"># 调用实例方法 设置stu_2的学号为&#x27;2018040625&#x27;</span><br>    stu_2.set_num(<span class="hljs-string">&#x27;2018040625&#x27;</span>)<br><br>    <span class="hljs-comment"># 调用实例方法 打印stu_2对应的值</span><br>    stu_2.speak()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别学号是否为指定值</span><br>    stu_2.identify_stu()<br><br>---------------------------------------------------------<br>我的学号为 <span class="hljs-number">2018014002</span>，很高兴认识大家<br>我的分组已经完成<br>我的父类是Person<br>------------------------------------<br>我的学号为 <span class="hljs-number">2018040625</span>，很高兴认识大家<br>请稍后，马上为你自动分组<br><br></code></pre></td></tr></table></figure><h2 id="类的多态">4.7 类的多态</h2><p>1、什么是多态？</p><p>多态是指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承）</p><blockquote><p>注：多态和多态性不是同一概念。</p><p>什么是多态性？</p><ul><li><p>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。<strong>子类继承父类；子类重写父类方法</strong></p></li><li><p>多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的爸爸说了一句话&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brother</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的哥哥在奔跑...&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的哥哥在说话...&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明也说话&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    b = Brother()<br>    b.run()<br>    b.talk()<br><br>    p = Parent()<br>    p.talk()<br><br>    c = Child()<br>    c.talk()<br>    <br>----------------------------------------------------<br>小明的哥哥在奔跑...<br>小明的哥哥在说话...<br>小明的爸爸说了一句话<br>小明也说话<br></code></pre></td></tr></table></figure><p>2、为什么要使用多态？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">metaclass=abc.ABCMeta</span>):</span> <span class="hljs-comment">#同一类事物:动物</span><br><span class="hljs-meta">    @abc.abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之一:猫</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say miaomiao&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之二:狗</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say wangwang&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之三:猪</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say aoao&#x27;</span>)<br><br>c = Cat()<br>d = Dog()<br>p = Pig()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">obj</span>):</span><br>    obj.talk()<br><br>func(c)<br>func(d)<br>func(p)<br><br>------------------------------<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>say miaomiao<br><span class="hljs-meta">&gt;&gt;&gt; </span>say wangwang<br><span class="hljs-meta">&gt;&gt;&gt; </span>say aoao<br></code></pre></td></tr></table></figure><p>仅仅是用了一个 <code>func(obj)</code> 函数，不同的对象就实现了不同的功能。综上可以说，多态性是 : <strong>一个接口，多种实现</strong></p><p><strong>多态性的好处:</strong></p><ul><li>增加了程序的<strong>灵活性</strong>，以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如 <code>func(obj)</code></li><li>增加了程序额<strong>可扩展性</strong>，通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用 <code>func(obj)</code> 去调用</li></ul><h2 id="类的多重继承">4.8 类的多重继承</h2><p>1、什么是多重继承？</p><p>我理解为一个子类可以继承多个父类。</p><p>2、多重继承的方法？</p><p><code>class Child(Parent1, Parent 2, Parent 3...)</code>，从左往右依次继承</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tool</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;tool work&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;car will run&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;food work&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cake</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;i like cake&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">Tool, Food</span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Person()<br>    print(p.car(), <span class="hljs-string">&#x27; &#x27;</span>, p.cake())<br>    print(p.work())  <span class="hljs-comment"># 继承的第一个类</span><br>    print(Person.__mro__)  <span class="hljs-comment"># 得到类的继承顺序</span><br><br>------------------------------<br>car will run   i like cake<br>tool work<br>(&lt;class &#x27;__main__.Person&#x27;&gt;, &lt;class &#x27;__main__.Tool&#x27;&gt;, &lt;class &#x27;__main__.Food&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)<br><br></code></pre></td></tr></table></figure><blockquote><p>注：继承关系可以延续。例，孙子继承父亲，父亲继承爷爷，则孙子也继承爷爷。</p></blockquote><h3 id="举个栗子----编程练习-2">举个栗子----编程练习：</h3><p>圆形、长方形除了是几何学科中的基本图形之外，也还是我们日常生活中最常见的平面图形。请根据面向对象的相关知识，将上述两种平面图形用Python语言进行表示，使得我们的程序可以正常对其使用。</p><p>任务 1、自定义Point类，并重写其构造（初始化）方法 <code>__init__( )</code>，将参数x和y赋值给实例对象的属性 2、自定义该类实例方法<code>string( )</code>，功能：打印“{X：xx, Y：xx}” 3、自定义Circle类，继承自Point类，并重写其构造（初始化）方法<code>__init__( )</code>，x、y参数通过调用父类的构造函数进行赋值，radius通过子类重写的<code>__init__( )</code>进行赋值。 4、自定义该类实例方法<code>string( )</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; {半径为：xx}” 5、自定义Size类，并重写其构造（初始化）方法<code>__init__( )</code>，将参数width和height赋值给实例对象的属性 6、自定义该类实例方法<code>string( )</code>，功能：打印“{Width：xx, Height：xx}” 7、自定义Rectangle类，继承自Point类和Size类，并重写其构造（初始化）方法<code>__init__( )</code>，x、y、width、height 4个参数全部通过调用父类的构造函数进行赋值 8、自定义该类实例方法<code>string( )</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; 长宽分别为：{Width：xx, Height：xx} 9、初始化Circle类的对象c，并调用其格式化输出函数<code>string( )</code> 10、初始化Rectangle类的对象r1、r2,并分别调用其格式化输出函数<code>string( )</code></p><p>任务提示 1、在自定义Rectangle类的构造方法时，调用父类方法必须按照<code>类名.__init__(参数列表)</code>的方式进行调用，如<code>Point.__init__(self, x, y)</code> 2、自定义Rectangle类格式化输出方法时，调用父类的格式化输出函数<code>string()</code>时，应按照<code>类名.string(参数)</code>的方式进行调用，如<code>Point.string(self)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    x = <span class="hljs-number">1.0</span><br>    y = <span class="hljs-number">1.0</span><br><br>    <span class="hljs-comment"># 自定义Point类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y</span>):</span><br>        self.x = x<br>        self.y = y<br>        print(<span class="hljs-string">&quot;Point 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Point类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;X: %s, Y: %s&#125;&quot;</span>  % (self.x, self.y))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">Point</span>):</span><br>    <span class="hljs-comment"># 自定义Circle类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, radius</span>):</span><br>        Point.__init__(self, x, y)<br>        self.radius = radius<br>        print(<span class="hljs-string">&quot;Circle 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Circle类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;该图形初始化点为: &#123;X: &quot;</span> + <span class="hljs-built_in">str</span>(self.x) + <span class="hljs-string">&quot;, Y: &quot;</span> + <span class="hljs-built_in">str</span>(self.y) \<br>               + <span class="hljs-string">&quot;&#125;, &#123;半径为: &quot;</span> + <span class="hljs-built_in">str</span>(self.radius) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 自定义Size类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br>        print(<span class="hljs-string">&quot;Size 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Size类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;Height: &quot;</span> + <span class="hljs-built_in">str</span>(self.width) + <span class="hljs-string">&quot;, Width: &quot;</span> + <span class="hljs-built_in">str</span>(self.height) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">Point, Size</span>):</span><br>    <span class="hljs-comment"># 自定义Rectangle类的构造(初始化)方法，并在方法中调用父类的初始化方法以完成初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, width, height</span>):</span><br>        Point.__init__(self, x, y)<br>        Size.__init__(self, width, height)<br><br>    <span class="hljs-comment"># 自定义Rectangle类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;该图形初始化点为: &#123;X: &quot;</span> + <span class="hljs-built_in">str</span>(self.x) + <span class="hljs-string">&quot;, Y: &quot;</span> + <span class="hljs-built_in">str</span>(self.y) + <span class="hljs-string">&quot;&#125;&quot;</span> + \<br>              <span class="hljs-string">&quot;, 长宽分别为: &#123;Height: &quot;</span> + <span class="hljs-built_in">str</span>(self.width) + <span class="hljs-string">&quot;, Width: &quot;</span> + <span class="hljs-built_in">str</span>(self.height) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 实例化Point对象，点位置为（3, 3）</span><br>    p = Point(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>    p.string()<br><br>    <span class="hljs-comment"># 实例化Circle对象，圆心为（5,5），半径为8</span><br>    c = Circle(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br>    c.string()<br><br>    <span class="hljs-comment"># 实例化Rectangle对象，顶点位置（15,30），长和宽分别为20和10</span><br>    r = Rectangle(<span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)<br>    r.string()<br><br>------------------------------------------------------------------------------------------------------<br>Point 构造函数被调用...<br>&#123;X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">3</span>&#125;<br><br>Point 构造函数被调用...<br>Circle 构造函数被调用...<br>该图形初始化点为: &#123;X: <span class="hljs-number">5</span>, Y: <span class="hljs-number">5</span>&#125;, &#123;半径为: <span class="hljs-number">8</span>&#125;<br><br>Point 构造函数被调用...<br>Size 构造函数被调用...<br>该图形初始化点为: &#123;X: <span class="hljs-number">15</span>, Y: <span class="hljs-number">30</span>&#125;, 长宽分别为: &#123;Height: <span class="hljs-number">20</span>, Width: <span class="hljs-number">10</span>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>该案例如果用super()调用拥有同名方法的父类，就只会调用最靠前的拥有同名方法的类，后面的类中同名方法也就无法被调用。</strong></p><p><strong>因此本案例多继承中进行父类调用时采用“<code>类名.__init__</code>”的形式。</strong></p></blockquote><h2 id="类的高级函数">4.9 类的高级函数</h2><ul><li><code>__str__</code> 函数</li><li><code>__gtrattr()__</code> 函数</li><li><code>__setattr__</code> 函数</li><li><code>__call__</code> 函数</li></ul><h3 id="str__-函数">4.9.1 <code>__str__</code> 函数</h3><p>如果定义了该函数，当print当前实例化对象时候，会返回该函数的 return信息。</p><ul><li>通常会返回一个字符串作为类的描述信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 一般会定义一些类的描述信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;this is a test class&#x27;</span><br><br>t = Test()<br>print(t)<br></code></pre></td></tr></table></figure><h3 id="gtrattr__-函数">4.9.2 <code>__gtrattr__</code> 函数</h3><p>当调用的属性或者方法不存在时，会返回该方法定义的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这个key: &#123;&#125; 并不存在&#x27;</span>.<span class="hljs-built_in">format</span>(key)<br><br><span class="hljs-comment"># print(t.a)  # AttributeError: &#x27;Test&#x27; object has no attribute &#x27;a&#x27;</span><br>print(t.a )  <span class="hljs-comment"># &gt;&gt;&gt; 这个key: a 并不存在</span><br></code></pre></td></tr></table></figure><h3 id="setattr__.-函数">4.9.3 <code>__setattr__.</code> 函数</h3><p>拦截当前类中不存在的属性与值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span>(<span class="hljs-params">self, key, value</span>):</span><br>        <span class="hljs-comment"># print(key, value)</span><br>        self.__dict__[key] = value<br>        print(self.__dict__)<br><br>t = Test()<br>t.name = <span class="hljs-string">&#x27;小明&#x27;</span><br>print(t.name)<br><br>-----------------------------------------------<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小明&#x27;</span>&#125;<br>小明<br></code></pre></td></tr></table></figure><h3 id="call__-函数">4.9.4 <code>__call__</code> 函数</h3><p>本质是将一个类变成一个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, a</span>):</span><br>        print(<span class="hljs-string">&#x27;call func will start&#x27;</span>)<br>        print(a)<br><br>t = Test()<br>t(<span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br>-----------------------------------------------<br>call func will start<br>xiaoming<br></code></pre></td></tr></table></figure><h1 id="异常">5. 异常</h1><ul><li>异常就是错误</li><li><p>异常会导致程序崩溃并停止运行</p></li><li><p>python中的异常机制能监控并捕获异常，将异常部位的程序进行修理使得程序继续正常运行</p></li></ul><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    &lt;代码块<span class="hljs-number">1</span>&gt; 被<span class="hljs-keyword">try</span>关键字检查并保护的业务代码<br><span class="hljs-keyword">except</span> &lt;异常的类型&gt;:<br>    &lt;代码块<span class="hljs-number">2</span>&gt; <span class="hljs-comment"># 代码块1出现错误后执行的代码块</span><br></code></pre></td></tr></table></figure><p>1、捕获通用异常</p><ul><li>无法确定是在哪种异常情况下使用的捕获方法</li></ul><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    &lt;代码块&gt; <br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    &lt;异常代码块&gt; <br></code></pre></td></tr></table></figure><p>2、捕获具体异常</p><ul><li><p>确定是哪种异常的情况下使用的捕获方法</p></li><li><p><code>exceppt &lt;具体的异常类型&gt; as e</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">UPPER</span>(<span class="hljs-params">str_data</span>):</span><br>    new_str = <span class="hljs-string">&#x27;None&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        new_str = str_data.upper()<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e :<br>        print(<span class="hljs-string">&#x27;程序出错了:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(e))<br>    <span class="hljs-keyword">return</span> new_str<br><br>result = UPPER(<span class="hljs-string">&#x27;xiaohong&#x27;</span>)<br>result1 = UPPER(<span class="hljs-number">1</span>)<br>print(<span class="hljs-string">&#x27;result1 is&#x27;</span>, result1)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>        print(<span class="hljs-string">&#x27;hello&#x27;</span>)  <span class="hljs-comment"># 遇到错误立刻进入except，所以错误后的代码全都不会执行</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><br>test()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        print(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>        print(name)  <span class="hljs-comment"># except 里没有对应的异常类型，所以报错了</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><br>test1()<br></code></pre></td></tr></table></figure><p>3、捕获多个异常</p><ol type="1"><li>可以有多个except并列。但当第一个异常捕获到之后，不会再继续往下捕获。</li><li>写一个 <code>except (异常类型1, 异常类型2) as e</code> 。当except代码后边的异常类型使用<strong>元组</strong>包裹起来，捕获到哪种就抛哪种</li></ol><h2 id="常用异常类型">5.1 常用异常类型</h2><table><thead><tr class="header"><th style="text-align: left;">异常名称</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Exception</td><td style="text-align: left;">通用异常类型（基类）</td></tr><tr class="even"><td style="text-align: left;">ZeroDivisionError</td><td style="text-align: left;">不能整除0</td></tr><tr class="odd"><td style="text-align: left;">AttributeError</td><td style="text-align: left;">对象没有这个属性</td></tr><tr class="even"><td style="text-align: left;">IOError</td><td style="text-align: left;">输入输出操作失败</td></tr><tr class="odd"><td style="text-align: left;">IndexError</td><td style="text-align: left;">没有当前的索引</td></tr><tr class="even"><td style="text-align: left;">KeyError</td><td style="text-align: left;">没有这个键值（key）</td></tr><tr class="odd"><td style="text-align: left;">NameError</td><td style="text-align: left;">没有这个变量（未初始化对象）</td></tr><tr class="even"><td style="text-align: left;">SyntaxError</td><td style="text-align: left;">Python语法错误</td></tr><tr class="odd"><td style="text-align: left;">SystemError</td><td style="text-align: left;">解释器的系统错误</td></tr><tr class="even"><td style="text-align: left;">ValueError</td><td style="text-align: left;">传入的参数错误</td></tr></tbody></table><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br>t = Test()<br><span class="hljs-keyword">try</span>:<br>    t.name<br><span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># &#x27;Test&#x27; object has no attribute &#x27;name&#x27;</span><br><br>d = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小明&#x27;</span>&#125;<br><span class="hljs-keyword">try</span>:<br>    d[<span class="hljs-string">&#x27;age&#x27;</span>]<br><span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>    print(<span class="hljs-string">&#x27;没有对应的键: &#x27;</span>, e)  <span class="hljs-comment"># 没有对应的键:  &#x27;age&#x27;</span><br><br>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">try</span>:<br>    l[<span class="hljs-number">5</span>]<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># list index out of range</span><br><br>name = <span class="hljs-string">&#x27;ssss&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(name)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># invalid literal for int() with base 10: &#x27;ssss&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-keyword">return</span> a<br><span class="hljs-keyword">try</span>:<br>    test()<br><span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># test() missing 1 required positional argument: &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="异常中的finally">5.2 异常中的finally</h2><ul><li>无论是否发生异常，只要定义了 <code>finally</code>，就一定会执行其中的代码块。</li><li>在函数中，即便在 <code>try</code> 或 <code>except</code> 中进行了 return 也依然会执行 <code>finally</code> 语法块</li><li><code>try</code> 语法至少要伴随 <code>except</code> 或 <code>finally</code> 中的一个来使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(e)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;finally&#x27;</span><br>t = test1()<br>print(t)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&#x27;1&#x27;</span>)<br>        <span class="hljs-keyword">return</span> e<br>    <span class="hljs-keyword">finally</span>:<br>        print(<span class="hljs-string">&#x27;2&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;finally&#x27;</span>  <span class="hljs-comment"># 即使在try和except中进行return，也依然会执行finally</span><br>    <br>--------------------------------------------------<br>division by zero<br><span class="hljs-keyword">finally</span><br><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span><br></code></pre></td></tr></table></figure><h2 id="自定义异常类型与抛出异常">5.3 自定义异常类型与抛出异常</h2><h3 id="自定义抛出异常-raise">5.3.1 自定义抛出异常 <code>raise</code></h3><p>将信息以报错的形式抛出。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141932.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">if</span> number == <span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;number不可以是100&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> number<br><br>print(test(<span class="hljs-number">50</span>))<br>t = test(<span class="hljs-number">100</span>)  <span class="hljs-comment"># ValueError: number不可以是100</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> test(number)<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> e<br>    <br>t2 = test2(<span class="hljs-number">100</span>)<br>print(t2)<br><br>--------------------------------------------------<br><span class="hljs-number">50</span><br>number不可以是<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="自定义异常类">5.3.2 自定义异常类</h3><ul><li><strong>定义一个基类</strong>，然后继承基类----<code>Exception</code></li><li><strong>在构造函数中定义错误信息</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberLimitError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameLimitError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&#x27;小明&#x27;</span>:<br>        <span class="hljs-keyword">raise</span> NameLimitError(<span class="hljs-string">&#x27;小明不可以被填写&#x27;</span>)<br>    <span class="hljs-keyword">return</span> name<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test0</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">if</span> number &gt; <span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">raise</span> NumberLimitError(<span class="hljs-string">&#x27;数字不可以大于100&#x27;</span>)<br>    <span class="hljs-keyword">return</span> number<br><br><br><span class="hljs-keyword">try</span>:<br>    test(<span class="hljs-string">&#x27;小明&#x27;</span>)<br><span class="hljs-keyword">except</span> NameLimitError <span class="hljs-keyword">as</span> e:<br>    print(e)<br><br><span class="hljs-keyword">try</span>:<br>    test0(<span class="hljs-number">101</span>)<br><span class="hljs-keyword">except</span> NumberLimitError <span class="hljs-keyword">as</span> e:<br>    print(e)<br> <br>--------------------------------------------------<br>小明不可以被填写<br>数字不可以大于<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="断言">5.4 断言</h2><p>断言：用于判断一个表达式，在表达式条件为false的时候触发异常(为true不会触发异常，继续执行)。</p><p><code>assert expression, message</code></p><ul><li><code>expression</code> ：表达式，一般是判断相等，或者判断是某种数据类型的 <code>bool</code> 判断的语句</li><li><code>message</code> ：具体的错误信息</li><li>无返回值</li></ul><h3 id="使用断言对综合案例进行改进">使用断言对综合案例进行改进</h3><p>很好的案例。一定要吃透！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    学生信息库</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>students = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小鱼&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小何&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">5</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小安&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 缺少参数的错误，定义一个基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotArgError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentInfo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, students</span>):</span><br>        self.students = students<br><br>    <span class="hljs-comment"># 查找，通过学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_id</span>(<span class="hljs-params">self, student_id</span>):</span><br>        <span class="hljs-keyword">return</span> self.students.get(student_id)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_students</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># get_all_students</span><br>        <span class="hljs-keyword">for</span> id_, value <span class="hljs-keyword">in</span> self.students.items():<br>            print(<span class="hljs-string">&#x27;学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                id_, value[<span class="hljs-string">&#x27;name&#x27;</span>], value[<span class="hljs-string">&#x27;age&#x27;</span>], value[<span class="hljs-string">&#x27;sex&#x27;</span>], value[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>            ))<br>        <span class="hljs-keyword">return</span> self.students<br><br>    <span class="hljs-comment"># 添加单个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, **student</span>):</span>  <span class="hljs-comment"># add_student</span><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.__add(**student)<br><br>    <span class="hljs-comment"># 添加多个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adds</span>(<span class="hljs-params">self, new_students</span>):</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> new_students:<br>            <span class="hljs-keyword">try</span>:<br>                self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                print(e, student.get(<span class="hljs-string">&#x27;name&#x27;</span>))<br>                <span class="hljs-keyword">continue</span><br>            self.__add(**student)<br><br>    <span class="hljs-comment"># 添加新的学号；并将新的学生入库</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add</span>(<span class="hljs-params">self, **student</span>):</span><br>        new_id = <span class="hljs-built_in">max</span>(self.students) + <span class="hljs-number">1</span><br>        self.students[new_id] = student<br><br>    <span class="hljs-comment"># 删除</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, student_id</span>):</span>  <span class="hljs-comment"># delete_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;号的同学的信息不存在&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br>        <span class="hljs-keyword">else</span>:<br>            user_info = self.students.pop(student_id)<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>    <span class="hljs-comment"># 批量删除，删除学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deletes</span>(<span class="hljs-params">self, ids</span>):</span><br>        <span class="hljs-keyword">for</span> id_ <span class="hljs-keyword">in</span> ids:  <span class="hljs-comment"># id_防止和函数id()冲突</span><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;id_&#125;</span> 不存在学生库中&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br>            student_info = students.pop(id_)<br>            print(<span class="hljs-string">f&#x27;学号<span class="hljs-subst">&#123;id_&#125;</span> 学生<span class="hljs-subst">&#123;student_info[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span> 已被移除&#x27;</span>)<br><br><br>    <span class="hljs-comment"># 修改</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, student_id, **kwargs</span>):</span>  <span class="hljs-comment"># update_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;不存在学号：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**kwargs)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.students[student_id] = kwargs<br>        print(<span class="hljs-string">&#x27;&#123;&#125;同学信息更新完毕&#x27;</span>.<span class="hljs-built_in">format</span>(kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>    <span class="hljs-comment"># 批量更新，key是学号，value是信息  # todo:添加异常捕获 17&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updates</span>(<span class="hljs-params">self, update_students</span>):</span>  <span class="hljs-comment"># update_students是一个列表</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> update_students:<br>            <span class="hljs-keyword">try</span>:<br>                id_ = <span class="hljs-built_in">list</span>(student.keys())[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 不加list()是假列表  # todo：添加异常捕获  # list可能没有0索引</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续循环列表</span><br><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;学号 <span class="hljs-subst">&#123;id_&#125;</span> 不存在&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br><br>            user_info = student[id_]<br>            <span class="hljs-keyword">try</span>:<br>                check = self.check_user_info(**user_info)  <span class="hljs-comment"># todo：添加异常捕获</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span><br>            self.students[id_] = user_info<br>        print(<span class="hljs-string">&#x27;所有信息更新完成&#x27;</span>)<br><br>    <span class="hljs-comment"># 查询</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_users</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;参数数量传递错误&#x27;</span>  <span class="hljs-comment"># 参数不能为空，长度必须是1</span><br><br>        values = <span class="hljs-built_in">list</span>(self.students.values())<br>        key = <span class="hljs-literal">None</span><br>        value = <span class="hljs-literal">None</span><br>        result = []<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;name&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;age&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;sex&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;class_number&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;没有发现搜索的关键字&#x27;</span>)<br><br>        <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> values:  <span class="hljs-comment"># 吐过想用年龄字段模糊查询，需要把年龄改成str类型</span><br>            <span class="hljs-comment"># print(user[key])</span><br>            <span class="hljs-comment"># print(value)</span><br>            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">in</span> user[key]:  <span class="hljs-comment"># in 替代 = 实现模糊查找</span><br>                result.append(user)<br><br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-comment"># 验证参数是否合法，检查位置参数的判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_info</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-comment"># 判断长度是否为4；判断是否我们要的四个参数；判断参数类型是否正确</span><br>        <span class="hljs-comment"># 判断长度是否为4</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;参数必须是4个&#x27;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生姓名参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生年龄参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生性别参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生班级参数&#x27;</span>)<br><br>        <span class="hljs-comment"># 确认四个参数是不是想要的数据类型</span><br>        <span class="hljs-comment"># 先取出数据</span><br>        name_value = kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]<br>        age_value = kwargs[<span class="hljs-string">&#x27;age&#x27;</span>]<br>        sex_value = kwargs[<span class="hljs-string">&#x27;sex&#x27;</span>]<br>        class_number_value = kwargs[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br><br>        <span class="hljs-comment"># isinstance(对比的数据, 数据类型) isinstance(1, str)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(name_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;name 应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age_value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;age应该是整型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(sex_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;sex应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(class_number_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;class_number应该是字符串类型&#x27;</span>)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    student_info = StudentInfo(students)<br>    user = student_info.get_user_by_id(<span class="hljs-number">1</span>)<br>    student_info.add(name=<span class="hljs-string">&#x27;小绿&#x27;</span>, age=<span class="hljs-number">34</span>, class_number=<span class="hljs-string">&#x27;A&#x27;</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>    print(student_info.students)<br><br>    users = [<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小橙&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小黄&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>    ]<br>    student_info.adds(users)<br>    student_info.get_all_students()<br><br>    student_info.deletes([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>])<br>    student_info.get_all_students()<br><br>    student_info.updates([<br>        &#123;<span class="hljs-number">2</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;何同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span>&#125;&#125;,<br>        &#123;<span class="hljs-number">4</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span>&#125;&#125;<br>    ])<br>    student_info.get_all_students()<br><br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;小&#x27;</span>)<br>    print(result)<br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 会把所有的都打印出来</span><br>    print(result)<br><br></code></pre></td></tr></table></figure><h1 id="bug">6. bug</h1><p>bug 是程序中出现的错误，但有没有通过异常去捕获，以至于直接抛出，导致程序的崩溃。</p><p>如何检查 bug？</p><ol type="1"><li><p>调试工具(eg.pycharm) debug。在想要停止的行的左侧点击一下会出现一个小红点，断点。程序运行到这行会停止(包括这一行)。</p></li><li><p>多打印信息。(多print可以聚焦错误点，简单)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
