<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Genetic CNN</title>
    <link href="/2022/04/26/Genetic%20CNN/"/>
    <url>/2022/04/26/Genetic%20CNN/</url>
    
    <content type="html"><![CDATA[<h1 id="genetic-cnn">Genetic CNN</h1><p>Genetic CNN 将遗传算法用于神经网络架构搜索，论文首先提出了一种能表示神经网络架构的编码方案，在此编码方案上初始化种群，对种群进行选择、变异、交叉，从而抛弃性能差的神经网络架构并产生新的神经网络架构，论文将训练好的架构在验证集上的准确率作为评判网络性能好坏的指标。</p><h2 id="basic-idea">Basic Idea</h2><p>核心思想是提出一种编码方法，用固定长度的二进制字符串表示每个网络结构。通过生成一组随机个体来初始化遗传算法。在每一次生成中，定义标准的遗传操作，例如选择，变异和交叉，以产生有竞争能力的个体并消除弱势的个体。每个个体的（适应度函数）取决于参考数据集上的识别准确率。为此，对每个个体（即网络结构）执行独立于遗传算法的完整训练过程。在固定次数的迭代之后，遗传过程就结束了。</p><h2 id="background">Background</h2><p>传统的遗传算法往往具有下列步骤</p><ol type="1"><li>定义个体的基因编码方案</li><li>初始化种群</li><li>衡量个体生存竞争能力的适应度（通常是一个函数，函数值表示个体的生存竞争能力）</li><li>淘汰适应度低的个体，选择适应度高的个体构成种群下一代的成员（选择）</li><li>按一定概率对下一代成员进行基因的交叉与变异（交叉与变异），产生新个体的基因编码方案</li><li>评估新种群的适应度</li></ol><p>可以看到，遗传算法其实就是模仿生物进化的过程。</p><h2 id="method">Method</h2><h3 id="二进制网络表示">二进制网络表示</h3><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220422150322.png" /></p><p>许多常见的state-of-the-art神经网络架构都可以分为几个stage，两个stage之间通过池化操作连接，同个stage内的所有卷积操作都有相同的过滤器数目，基于上述观察，论文得出了神经网络架构的基因编码方案，具体如下：</p><ol type="1"><li>每个神经网络架构由S个阶段构成，阶段与阶段之间通过池化操作连接</li><li>每个阶段都有 <span class="math inline">\(K_s\)</span> 个节点组成，这 <span class="math inline">\(K_s\)</span> 个节点其实是卷积 + BN + ReLU的操作，Ks个节点编号并由小到大顺序排序</li><li>使用有向边连接一个阶段中的节点，每个节点只能连接比自己编号要大的节点，用 <span class="math inline">\(v_{s,k_s}\)</span> 表示第 <span class="math inline">\(s\)</span> 阶段的第 <span class="math inline">\(k_s\)</span> 个节点，其中 <span class="math inline">\(k_s=1,2...,K_S\)</span></li></ol><p>为了使每个二进制字符串有效，在每个阶段定义两个默认节点。<strong>默认输入节点</strong>（表示为 <span class="math inline">\(v_{s,0}\)</span>）从上一阶段接收数据，执行卷积并将其输出发送到每个节点，而无需前置节点（例如 <span class="math inline">\(v_{s,1}\)</span>）。<strong>默认输出节点</strong>（表示为 <span class="math inline">\(v_{s,K_s+1}\)</span>）从所有节点接收数据并对其求和，然后进行卷积，然后将其输出发送到池化层，同样也没有后继节点，例如 <span class="math inline">\(v_{s,K_s}\)</span>。注意，普通节点和默认节点之间的连接未被编码。</p><p><strong>有两种特殊情况</strong>。首先，如果一个普通节点 <span class="math inline">\(v_{s,i}\)</span> 是孤立的（即它没有连接到任何其他普通节点 <span class="math inline">\(v_{s,j},i \ne j\)</span>），那么它将被简单地忽略，即它没有连接到默认输入节点 也没有默认输出节点（请参见图1中的B2节点）。这是为了确保具有更多节点的阶段可以模拟由具有较少节点的阶段表示的所有结构。其次，如果某个阶段没有连接，即二进制字符串中的所有位均为0，则卷积运算仅执行一次，而不是执行两次（一个由默认输入节点执行，另一个由默认输出节点执行） 。</p><p>使用所提出的编码方案可以表示许多流行的网络结构。示例包括 VGGNet，ResNet 和 DenseNet 的改进版本，如图2所示。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424155115.png" style="zoom: 80%;" /></p><p>存在的局限性：</p><ul><li>当前，编码的结构仅涉及卷积和池化操作，无法生成某些棘手的网络模块，例如 Maxout。</li><li>卷积核的大小和通道的数量在每个阶段都是固定的，这限制了网络无法像初始模块一样合并多维度信息。</li></ul><h3 id="遗传操作">遗传操作</h3><p>遗传过程的流程图如算法1所示。该过程从具有N个随机个体的初始化种群开始。然后，执行T轮迭代代，每次迭代包括三个操作，即选择，突变和交叉。通过在参考数据集中进行从头训练来评估每个个体的性能。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220422155522.png" /></p><h4 id="初始化种群">1 初始化种群</h4><p>初始化一个随机模型集合 <span class="math inline">\(\left\{\mathbb{M}_{0, n}\right\}_{n=1}^{N}\)</span>，每个模型是长度为L的二进制串，串上每位服从伯努利分布 <span class="math inline">\(b_{0,n}^l \sim \mathcal{B}(0.5), l=1,2,...,L\)</span>，然后训练并测试每个模型的准确率，这里<strong>不同的初始化策略不会对遗传性能产生太大影响</strong>。即使从最简单的初始化开始（所有个体都是零字符串），遗传过程仍可以通过交叉和突变发现相当有竞争性的结构。</p><h4 id="选择">2 选择</h4><p>在每一代种群生成前都会进行选择操作，在t-th代前，个体 <span class="math inline">\(\mathbb{M}_{t-1,n}\)</span> 的适应性为 <span class="math inline">\(r_{t-1,n}\)</span>，直接影响 <span class="math inline">\(\mathbb{M}_{t-1,n}\)</span> 在选择阶段存活的概率。具体选择使用俄罗斯轮盘选择法(Russian roulette)，每个个体选取的概率与 <span class="math inline">\(r_{t-1,n}-r_{t-1,0}\)</span> 成比例，<span class="math inline">\(r_{t-1,0}\)</span> 为上一代的最低适应性。选择后的保持种群总数不变，所以一个个体可能会被选择多次</p><h4 id="变异和交叉">3 变异和交叉</h4><p>单个 <span class="math inline">\(\mathbb M_{t,n}\)</span> 的变异的操作包含对二进制串每个位进行概率为 <span class="math inline">\(q_M\)</span> 的反转。在实验中，<span class="math inline">\(q_M\)</span> 通常很小，例如0.05，因此变异不太可能使一个个体改变太多。这是为了保留一个个体的良好信息，同时提供尝试新可能性的机会。</p><p>交叉过程涉及同时更改两个个体，每对阶段以很小的概率 <span class="math inline">\(q_C\)</span> 交换。<strong>交叉中的基本单元是一个阶段stage，而不是单独考虑每个位</strong>，这是由于需要将局部结构保留在每个阶段内。</p><h4 id="评价">4 评价</h4><p>在上述过程之后，对每个单独的 <span class="math inline">\(\mathbb M_{t,n}\)</span> 进行训练和测试来获得适应度函数值。如果先前对 <span class="math inline">\(\mathbb M_{t,n}\)</span> 进行过评估，只需再次对其进行评估，然后求所有发生次数的平均。这样减轻了训练过程中随机性引起的不稳定性。</p><h2 id="experiments">Experiments</h2><h3 id="mnist">MNIST</h3><ol type="1"><li><p>通过遗传操作，可以找到具有竞争力的网络结构，达到较高的精度。虽然在很短的时间内，最佳个体的识别率没有提高，但平均和中等准确率通常会随着代代而提高。这是非常重要的，因为它保证了遗传算法提高了个体的整体素质。</p></li><li>实验验证了：一个更好的个体更有可能通过变异或交叉产生一个好的个体。</li><li><p>做了对比试验不同初始化网络的影响。验证了不同的初始化策略不会对遗传性能产生太大影响。</p></li></ol><h3 id="cifar10">CIFAR10</h3><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424151857.png" /></p><p>图5绘制了从两个单独的遗传过程中学习到的网络结构。通过遗传算法学习的结构与人工设计的结构有很大不同，尽管观察到一些人工设计的局部结构，如链状网络、多径网络和公路网络。我们强调这两个网络是通过独立的遗传过程获得的，这表明我们的遗传过程通常会收敛到类似的网络结构。</p><h3 id="svhn">SVHN</h3><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424155207.png" style="zoom: 80%;" /></p><p>可以看到虽然GeNet（17层）的识别错误率较高，但是可以看到中使用的结构(后4个)都很深......由于密集连接通常不是最佳选择，作者认为可以使用遗传算法来优化网络中使用的连接 。</p><h2 id="summary">Summary</h2><p>本文将遗传算法应用于神经网络的结构设计。首先提出了一种编码方法，用固定长度的二进制字符串来表示每个网络结构，然后使用一些遗传操作，如变异和交叉，来有效地探索搜索空间（基本相当于只搜索节点间的连接方式=_=）。不同的初始化策略对遗传过程影响不大。使用一个相对较小的参考数据集（CIFAR10）进行遗传算法，发现生成的结构可以很好地转移到其他任务，包括大规模的ILSVRC2012数据集。</p><p>这样的编码形式可以编码目前的主流分类结构，但也有很多局限性：</p><ul><li>目前的连接方式只有卷积和池化，不能使用其它比较tricky的模块，例如Maxout。</li><li>每个阶段的卷积核是固定的，阻碍了multi-scale特征的融合。</li></ul><p>所以说最大的问题就是能生成这样类似的网络结构，但是参数是定死的，这样子就会失去它的灵活性，搜索出的网络结构比较局限。</p><p>在目前的工作中，遗传算法仅用于探索网络结构，而网络训练过程是单独进行的。未来工作可以将遗传算法结合起来同时训练网络结构和权重。</p>]]></content>
    
    
    <categories>
      
      <category>Papers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EANAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟哈希表</title>
    <link href="/2022/04/23/%E6%A8%A1%E6%8B%9F%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2022/04/23/%E6%A8%A1%E6%8B%9F%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟哈希表-模板"><a href="#模拟哈希表-模板" class="headerlink" title="模拟哈希表 模板"></a>模拟哈希表 模板</h1><p>Hash表又称为散列表，<strong>一般由Hash函数(散列函数)与链表结构共同实现</strong>。与离散化思想类似，当要对若干复杂信息进行统计时，可以<strong>用Hash函数把这些复杂信息映射到一个容易维护的值域内</strong>。因为值域变简单、范围变小，有可能<strong>造成两个不同的原始信息被Hash函数映射为相同的值</strong>，所以需要<strong>处理这种冲突情况</strong>。</p><p>Note：离散化和哈希表都是把数据范围大的数，映射到一个小区间内。区别在于离散化强调“保序性”，即映射之前如果具有小于关系，映射之后仍需要保证小于关系。</p><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220417213926.png" style="zoom: 43%;" /></p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>一般定义无穷大数都是 <code>inf=99999999</code>,或者 <code>0x7f ff ff ff</code>，但是有的时候inf过大，虽然保证了没有数超过它，但是在需要加上一个数的时候，<code>inf+a</code> 可能会导致溢出，最终变成一个负数。</p><p><code>0x3f3f3f3f</code> 的数量级是1e9的，（一般题不会给超过1e9的数），在把它当成无穷大的时候，两个 <code>0x3f3f3f3f</code> 相加的结果也不会爆int。所以这个数比较合适了。</p><p>如果开一个数组，让数组中每个元素的值都为这个无穷大时，可以使用 <code>memset(a, 0x3f, sizeof(a))</code>，它的效果就是int类型的4个字节中每个字节都是0x3f，最终这个元素的值也是 <code>0x3f3f3f3f</code>。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200003</span>, null = <span class="hljs-number">0x3f3f3f3f</span>;  <span class="hljs-comment">// 规定空指针为 null 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> h[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>    &#123;<br>        t ++ ;<br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;  <span class="hljs-comment">// 如果这个位置是空的, 则返回的是他应该存储的位置</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, op, &amp;x);<br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) h[find(x)] = x;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (h[find(x)] == null) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>拉链法：建立一个邻接表结构, 以Hash函数的值域作为表头数组head，映射后的值相同的原始信息被分到同一类,构成一个链表接在对应的表头之后,链表的节点上可以保存原始信息。哈希函数相当于把 $10^{-9}～10^9$ 中的一个个数x压缩存放在N(质数)个链表中。因此第一步是对x取模，找到x对应的链表的头指针，再用头插法插入。</p><p>Hash表主要包括来两个基本操作:</p><ol><li>计算Hash函数的值.</li><li>定位到对应链表中依次遍历、比较。</li></ol><p>当Hash函数设计较好时，原始信息会被比较均匀地分配到各个表头之后，从而使每次查找，统计的时间降低到“原始信息总数除以表头数组长度”。若原始信息总数与表头数组长度都是O(N)级别且Hash函数分散均匀，几乎不产生冲突，那么每次查找，统计的时间复杂度期望为O(1).</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220417213906.png" alt=""></p><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>$h[N]$ 我把它看作不同的头指针，记录第一个节点的下标。</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100003</span>;  <span class="hljs-comment">//  取大于1e5的第一个质数，取质数冲突的概率最小</span><br><br><span class="hljs-comment">// 开一个槽 h</span><br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;  <span class="hljs-comment">// 邻接表</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// c++ 中如果是负数 那他取模也是负的，所以 加N 再 %N 就一定是一个正数</span><br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span> (e[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);  <span class="hljs-comment">// 将槽先清空 空指针一般用 -1 来表示</span><br><br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, op, &amp;x);<br><br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) insert(x);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (find(x)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="字符串哈希-模板"><a href="#字符串哈希-模板" class="headerlink" title="字符串哈希 模板"></a>字符串哈希 模板</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），将p进制转换为10进制，根据 mod Q 的余数，实现不同的字符串映射到不同的数字。</p><p>对形如 $X<em>1X_2X_3⋯X</em>{n−1}X_n$ 的字符串，采用字符的 ASCII 码乘上 P 的次方来计算哈希值。</p><ul><li>hash映射公式：$ (X<em>1×P^{n−1}+X_2×P^{n−2}+⋯+X</em>{n−1}×P^1+X_n×P^0)modQ$</li></ul><p>注意点：</p><ol><li>任意字符不可以映射成0，否则会出现不同的字符串都映射成0的情况，比如A，AA，AAA皆为0</li><li>冲突问题：通过巧妙设置P (131 或 13331) , Q ($2^{64}$) 的值，一般情况下可以理解为不产生冲突。</li></ol><p><strong>问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220418114327.png" alt=""></p><ul><li>$h[i]$ ：前i个字符的hash值</li><li>$p[i]$：我觉得是 P 的 i 次幂，e.g. $p[2]$ 是 p 的 2次幂，$p[0]$ 是 p 的 0次幂，要初始化为1</li></ul><p>求一个字符串的哈希值就相当于求前缀和，初始化前缀和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];  <span class="hljs-comment">// 前缀和求整个字符串的哈希值</span><br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;  <span class="hljs-comment">// 存P的i次幂，为了后面计算区间和，保持相同最高位。</span><br>&#125; <br></code></pre></td></tr></table></figure><p>求一个字符串的子串哈希值就相当于求部分和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>区间和公式 $h[l,r]=h[r]−h[l−1]×p[r−l+1]$</li></ul><p>区间和公式的理解：举栗，求 DEF 的哈希值，ABCDEF 与 ABC 的前三个字符值是一样，只差三位，乘上 P 的 3次幂 把 ABC 变为 ABC000，再用 ABCDEF - ABC000 得到 DE 的哈希值。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220419094029.png" alt=""></p><h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ULL;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, P = <span class="hljs-number">131</span>;  <span class="hljs-comment">//131 13331</span><br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">char</span> str[N];<br>ULL h[N], p[N];<br><br><span class="hljs-comment">// h[i]前i个字符的hash值</span><br><span class="hljs-comment">// 使用场景： 两个字符串的子串是否相同</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str + <span class="hljs-number">1</span>);<br><br>    <br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// P的0次幂初始化为1</span><br>    h[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 字符串从1开始编号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];  <span class="hljs-comment">//前缀和求整个字符串的哈希值</span><br>        p[i] = p[i - <span class="hljs-number">1</span>] * P;  <span class="hljs-comment">// 存 P的i次幂，为了后面保持相同位</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> l1, r1, l2, r2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);<br><br>        <span class="hljs-keyword">if</span> (get(l1, r1) == get(l2, r2)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-哈希表"><a href="#C-哈希表" class="headerlink" title="C++ 哈希表"></a>C++ 哈希表</h1><p>unordered_map是C++中的哈希表，可以在任意类型与类型之间做映射。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol><li>引用头文件(C++11)：<code>#include &lt;unordered_map&gt;</code></li><li>定义：<code>unordered_map&lt;int,int&gt;、unordered_map&lt;string, double&gt; ...</code></li><li>插入：<code>hash[key] = value</code>；例如将<code>(&quot;ABC&quot; -&gt; 5.45)</code> 插入 <code>unordered_map&lt;string, double&gt; hash</code>中，<code>hash[&quot;ABC&quot;]=5.45</code></li><li>查询：<code>hash[&quot;ABC&quot;]</code> 会返回 5.45。(<code>hash[key] = value</code>)</li><li>判断key是否存在：<code>hash.count(&quot;ABC&quot;) != 0</code> 或 <code>hash.find(&quot;ABC&quot;) != hash.end()</code></li><li>遍历</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : hash)<br>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; item.first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; item.second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">double</span>&gt;::iterator it = hash.begin(); it != hash.end(); it ++ )<br>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><p>如果想让自定义的class作为key（unordered_map<key,value>）来使用unordered_map，需要实现：</p><ol><li>哈希函数，需要实现一个class重载operator()，将自定义class变量映射到一个size_t类型的数。一般常用std::hash模板来实现。</li><li>判断两个自定义class类型的变量是否相等的函数，一般在自定义class里重载operator==。<br>示例代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> first;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; second;<br><br>    <span class="hljs-comment">// 重载等号，判断两个Myclass类型的变量是否相等</span><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-keyword">const</span> Myclass &amp;other) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> first == other.first &amp;&amp; second == other.second;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 实现Myclass类的hash函数</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span><br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;&gt;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;</span>Myclass&gt;<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Myclass &amp;k)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">int</span> h = k.first;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : k.second)<br>            &#123;<br>                h ^= x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> h;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">unordered_map</span>&lt;Myclass, <span class="hljs-keyword">double</span>&gt; S;<br>    Myclass a = &#123; <span class="hljs-number">2</span>, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; &#125;;<br>    Myclass b = &#123; <span class="hljs-number">3</span>, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; &#125;;<br>    S[a] = <span class="hljs-number">2.5</span>;<br>    S[b] = <span class="hljs-number">3.123</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; S[a] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; S[b] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">5</span> <span class="hljs-number">3</span>.<span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-LeetCode-1-两数之和"><a href="#1-LeetCode-1-两数之和" class="headerlink" title="1. LeetCode 1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. LeetCode 1. 两数之和</a></h2><blockquote><p>题目样例：</p><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：</p><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：</p><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p></blockquote><h3 id="算法1-暴力枚举-o-n-2"><a href="#算法1-暴力枚举-o-n-2" class="headerlink" title="算法1 暴力枚举 $o(n^2)$"></a>算法1 暴力枚举 $o(n^2)$</h3><p>暴力枚举方法很简单：两重循环枚举下标 $i,j$，然后判断 $nums[i]+nums[j]$ 是否等于 $target$。</p><p>时间复杂度：由于有两重循环，所以复杂度是 $O(n^2)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target)<br>                &#123;<br>                    res = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(&#123;j, i&#125;);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (res.size() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="算法2-哈希表-O-n"><a href="#算法2-哈希表-O-n" class="headerlink" title="算法2 (哈希表) $O(n)$"></a>算法2 (哈希表) $O(n)$</h3><p>使用C++中的哈希表——<a href="https://www.acwing.com/blog/content/9/"><code>unordered_map hash</code></a>.</p><p>循环一遍 nums 数组，在每步循环中我们做两件事：</p><ol><li>判断 $target−nums[i]$ 是否在哈希表中；</li><li>将 $nums[i]$ 插入哈希表中。<strong>哈希表的key是 $nums[i]$，值是下标位置。</strong></li></ol><p>解释：由于数据保证有且仅有一组解，假设是 $i,j$，则我们循环到 $j$ 时，$nums[i]$ 一定在哈希表中，且有 $nums[i]+nums[j]==target$， 所以我们一定可以找到解。</p><p>时间复杂度：由于只扫描一遍，且哈希表的插入和查询操作的复杂度是 $O(1)$，所以总时间复杂度是 $O(n)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> another = target - nums[i];<br>            <span class="hljs-keyword">if</span> (hash.count(another))<br>            &#123;<br>                res = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(&#123;hash[another], i&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            hash[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟堆</title>
    <link href="/2022/04/21/%E6%A8%A1%E6%8B%9F%E5%A0%86/"/>
    <url>/2022/04/21/%E6%A8%A1%E6%8B%9F%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h1><p>堆是一棵完全二叉树。模拟堆用一维数组存储，数组方法可以删除/修改堆中的任意元素，这是相较于 STL 中的优先队列的优势。对于数组，直接在末尾进行添加或者删除更方便，所以可将添加或者删除的数和末尾联系起来。</p><p>需要注意的是：由于修改，删除等操作对堆的调整，使得数的坐标与第k个插入对应不上，所以需要额外开<strong>两个数组存储二者之间的对应关系</strong>。</p><blockquote><p>堆的坐标是一直不动的。(想象成空壳子，我之前搞错了这个T_T)</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>以小根堆为例。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220415133832.png"  style="zoom: 40%;" /></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>关于堆有两个基本操作： $up(u)$ 和 $down(u)$ ，对 堆中 下标为 $u$ 的数上调或者下调。</p><h4 id="up-u"><a href="#up-u" class="headerlink" title="$up(u)$"></a>$up(u)$</h4><p>节点向上调整。只要根节点存在，并且 u 这个节点的值 比 根节点小，就需要交换，坐标就上移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        swap(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="down-u"><a href="#down-u" class="headerlink" title="$down(u)$"></a>$down(u)$</h4><p>节点向下调整。该节点与左子节点比较一次，将自己变成较小的。再和右子节点比较一次，将自己变成较小的。经过两次比较和调整，将成为3个节点中最小的。完成了这个小根堆的调整。然后进行递归即可。当 $u == t$，说明这个点已经到了位置，递归就结束了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">int</span> t = u;  <span class="hljs-comment">// t 记录三个点中最小的数的下标</span><br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= heap_size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= heap_size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        swap(u, t);<br>        down(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="1-插入一个数"><a href="#1-插入一个数" class="headerlink" title="1. 插入一个数"></a>1. 插入一个数</h4><p>把这个数加到末尾，然后 up 调整他的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">heap[ ++ size] = x;<br>up(size);<br></code></pre></td></tr></table></figure><h4 id="2-求集合中的最小值"><a href="#2-求集合中的最小值" class="headerlink" title="2. 求集合中的最小值"></a>2. 求集合中的最小值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">heap[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h4 id="3-删除最小值"><a href="#3-删除最小值" class="headerlink" title="3. 删除最小值"></a>3. 删除最小值</h4><p>删除数组的头很费劲，但是删除尾很容易。用末尾的值覆盖最小值，然后将末尾的值 down 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">heap[<span class="hljs-number">1</span>] = heap[size];<br>size -- ;<br>down(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="4-删除任意元素"><a href="#4-删除任意元素" class="headerlink" title="4. 删除任意元素"></a>4. 删除任意元素</h4><p>同删除头，就是用末尾的值覆盖 idx 位置的元素。idx 位置的元素被替换后，有三种情况：和它相等；比它大，应该往上走；比它小，应该往上走。其实可以不用分情况，直接 down up都做一遍，因为操作里面已经包括了判断条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">heap[idx] = heap[size];<br>size -- ;<br>up(idx);<br>down(idx);<br></code></pre></td></tr></table></figure><h4 id="5-修改任意元素"><a href="#5-修改任意元素" class="headerlink" title="5. 修改任意元素"></a>5. 修改任意元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">heap[idx] = x;<br>up(idx);<br>down(idx);<br></code></pre></td></tr></table></figure><h3 id="第k个插入的数-和-数组下标-idx-的关系"><a href="#第k个插入的数-和-数组下标-idx-的关系" class="headerlink" title="第k个插入的数 和 数组下标 idx 的关系"></a>第k个插入的数 和 数组下标 idx 的关系</h3><p>Review: </p><ul><li><p>单链表：头节点初始为 $-1$，所以第1个插入的数下标为0，所以 $k - 1 = idx$</p></li><li><p>双链表：左右头节点分别初始为 $0$ 和 $1$，所以第1个插入的数下标为2，所以 $k + 1 = idx$</p></li></ul><p>那堆呢？堆排序不需要修改中间元素的值。但，当需要修改中间某个元素的值时，如果我们<strong>需要自己定位中间元素的位置</strong>，那就需要<strong>自己写 heap_swap 维护 数值的坐标 和 第 k 个插入 的映射关系。</strong> </p><blockquote><p><strong>Note: </strong> 堆数组中的 idx 是不变的。</p></blockquote><p>比如说：<code>h[k] = x</code>，h 数组存的是结点的值，按理来说应该 <code>h[idx]</code> 来存，但是结点位置总是在变的，因此可以维护 k 和 idx 的映射关系：</p><ul><li><strong>$ph[k] = idx$：第 k 个插入的数，在堆中的下标为 idx</strong></li><li><strong>$hp[idx] = k$：堆中下标为 idx 的，是 第 k 个插入的数</strong></li></ul><p>这样，节点的下标是 $ph[k]$，值为 $h[ph[k]] = x$，儿子分别是 $ph[k] <em> 2$ 和 $ph[k] </em> 2 + 1$</p><p>为什么要有一个 hp 数组呢？</p><p>原因就在于在<code>swap</code>操作中我们输入是<u>堆数组的下标</u>，无法知道每个堆数组的 $idx$ 下标对应是 第 k 个插入，所以需要 $hp$ 数组方便查找 $idx$。</p><p><strong>Note：</strong> a，b 是堆数组元素的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    swap(ph[hp[a]], ph[hp[b]]); <br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="举例：堆中的插入操作"><a href="#举例：堆中的插入操作" class="headerlink" title="举例：堆中的插入操作"></a>举例：堆中的插入操作</h3><p><strong>注意：</strong> 在堆这个数据结构中，数据的插入都是插入到堆尾，然后再<code>up</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;i&quot;</span>)<br>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    size ++ ;  <span class="hljs-comment">// 整个堆的长度</span><br>    k ++ ;  <span class="hljs-comment">// 第 k 个插入</span><br>    h[size] = x;  <span class="hljs-comment">// 在堆尾添加元素</span><br>    ph[k] = size, hp[size] = k;  <span class="hljs-comment">// 存入映射关系</span><br>    up(size);  <span class="hljs-comment">// 调整堆尾元素的位置</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="举例：删除第-k-个插入元素"><a href="#举例：删除第-k-个插入元素" class="headerlink" title="举例：删除第 k 个插入元素"></a>举例：删除第 k 个插入元素</h3><p>删除操作，三个步骤：</p><ol><li><p><strong>找到第 k 个插入元素在堆数组中的位置（堆数组下标）：$ph[k]$</strong></p></li><li><p>与堆尾元素交换：$swap$</p></li><li><p>在原来第 k 个元素所在的位置进行 down 和 up 操作。<strong>（up，down，swap操作的都输入都是下标）</strong></p><p>需要调整的是 <strong>原来第 $k$ 的元素所在的位置</strong>，由于交换完后的 $ph[k]$ 值变了，变为堆尾的下标了，所以必须要在之前保存 $ph[k]$ 的值</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;D&quot;</span>)<br>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;idx);<br>    <span class="hljs-comment">// 第k个插入的数的坐标不是ph[k]了，但是我们要调整的是 原来第k个插入的数的位置，所以需要记录</span><br>    k = ph[k];  <span class="hljs-comment">// origin_k 是之前记录被删除的结点的下标</span><br>    heap_swap(k, size);  <br>    size -- ;<br>    up(k);<br>    down(k);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="举例：修改第-k-个插入元素"><a href="#举例：修改第-k-个插入元素" class="headerlink" title="举例：修改第 k 个插入元素"></a>举例：修改第 k 个插入元素</h3><p>修改第 k 个插入元素：</p><ol><li><strong>找到 第 k 个插入元素对应的 idx：$ph[k]$</strong></li><li>$h[ph[k]] = x$</li><li>调整</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;C&quot;</span>)<br>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);<br>    h[ph[k]] = x;<br>    up(ph[k]);<br>    down(ph[k]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-839-模拟堆"><a href="#1-AcWing-839-模拟堆" class="headerlink" title="1. AcWing 839. 模拟堆"></a><a href="https://www.acwing.com/problem/content/841/">1. AcWing 839. 模拟堆</a></h3><p>考察优先队列（堆）的实现原理（手写）。</p><blockquote><p>模板题</p></blockquote><p>模拟一下样例：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220415155138.png" style="zoom: 50%;" /></p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> h[N], ph[N], hp[N], cnt;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    swap(ph[hp[a]],ph[hp[b]]);<br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        heap_swap(u, t);<br>        down(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        heap_swap(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">int</span> k, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;I&quot;</span>))<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>            cnt ++ ;<br>            m ++ ;<br>            ph[m] = cnt, hp[cnt] = m;<br>            h[cnt] = x;<br>            up(cnt);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;PM&quot;</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, h[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;DM&quot;</span>))<br>        &#123;<br>            heap_swap(<span class="hljs-number">1</span>, cnt);<br>            cnt -- ;<br>            down(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;D&quot;</span>))<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>            k = ph[k];<br>            heap_swap(k, cnt);<br>            cnt -- ;<br>            up(k);<br>            down(k);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);<br>            k = ph[k];<br>            h[k] = x;<br>            up(k);<br>            down(k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-AcWing-838-堆排序"><a href="#2-AcWing-838-堆排序" class="headerlink" title="2. AcWing 838. 堆排序"></a><a href="https://www.acwing.com/problem/content/840/">2. AcWing 838. 堆排序</a></h3><h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><p>1、堆排序不需要修改中间元素的值。当需要修改中间某个元素的值时，如果我们需要自己定位中间元素的位置，那就需要用heap_swap自己维护数值和堆中节点的映射关系。</p><p>2、建堆：从n / 2开始向前。i 为什么从n/2开始down？</p><p>从 i 开始的这个 i 节点需要满足的性质：</p><ol><li><p>左右儿子满足堆的性质。</p></li><li><p>下标最大（因为要往上遍历）</p></li><li><p>不是叶结点（叶节点一定满足堆的性质）</p></li></ol><p>这样的节点就是倒数第二层的第n/2个点开始，倒序遍历。</p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> h[N];<br><span class="hljs-keyword">int</span> heap_size;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = u;  <span class="hljs-comment">// t是三个点中最小的点的下标</span><br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> &lt;= heap_size &amp;&amp; h[<span class="hljs-number">2</span> * u] &lt; h[t]) t = <span class="hljs-number">2</span> * u;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= heap_size &amp;&amp; h[<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span> *u + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">if</span>(u != t)<br>    &#123;<br>        swap(h[t], h[u]);<br>        down(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; h[i];  <span class="hljs-comment">//下标从1开始，也就是根节点,下标为1</span><br>    <br>    heap_size = n;<br>    <br>    <span class="hljs-comment">// 建堆</span><br>    <span class="hljs-comment">// 进行down(i)时需要保证i的左右两个儿子都已经满足堆的性质。从n / 2开始向前做，相当于从整棵二叉树的最后一层开始往上做，那么是可以保证这个性质的。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = heap_size / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i -- ) down(i);<br>    <br>    <span class="hljs-comment">// 堆排序就是先输出堆顶，再删掉堆顶</span><br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, h[<span class="hljs-number">1</span>]);<br>        h[<span class="hljs-number">1</span>] = h[heap_size];<br>        heap_size -- ;<br>        down(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/04/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/04/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集思路"><a href="#并查集思路" class="headerlink" title="并查集思路"></a>并查集思路</h1><p>并查集：</p><ol><li><p><strong>将两个集合合并</strong></p></li><li><p><strong>询问两个元素是否在一个集合中</strong></p><p>基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存它的父节点，<code>p[x]</code> 表示 x 的父节点</p></li></ol><p>问题：</p><ol><li>如何判断树根：<code>if(p[x] == x)</code>，x 的父节点是x自己，说明它是根节点</li><li>如何求 x 的集合编号：<code>while(p[x] != x) x = p[x];</code>，如果 x 的父节点不是x自己(x不是根节点)，让x上移变为父节点，递归寻找到最终的根节点，就是x的集合编号</li><li>如何合并两个集合：<code>p[x] = y</code>。其中，<code>p[x]</code> 是 x 的集合编号，<code>p[y]</code> 是 y 的集合编号。</li></ol><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化就是将当前数据的父节点指向自己：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i ++) p[i] = i;<br></code></pre></td></tr></table></figure><p>上面的代码实现的结果如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220420115154.png" alt=""></p><h2 id="查找-路径压缩"><a href="#查找-路径压缩" class="headerlink" title="查找 + 路径压缩"></a>查找 + 路径压缩</h2><p>$find()$ 函数的功能是用于查找祖先节点 和 路径压缩。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回x的祖先节点 + 路径压缩</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 祖先节点的父节点是自己本身</span><br>    <span class="hljs-comment">// 如果x的父节点不是自己(说明x不是祖先节点)</span><br>    <span class="hljs-keyword">if</span>(p[x] != x) <br>        <span class="hljs-comment">// 就将x的父节点置为x的父节点的祖先节点，实现路径压缩</span><br>        p[x] = find(p[x]);<br>    <br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><p>路径压缩的过程，举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220420115343.png" alt=""></p><p>针对 x = 1：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220420180107.png" alt=""></p><p>这个递归过程，将所有的1，2，3的父节点全部置为了4，实现路径压缩；同时也实现了1的父节点的返回。</p><p>Note：这个找祖宗节点的写法更好理解一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fa[x] = find(fa[x]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-AcWing-836-合并集合"><a href="#1-AcWing-836-合并集合" class="headerlink" title="1. AcWing 836. 合并集合"></a><a href="https://www.acwing.com/problem/content/838/">1. AcWing 836. 合并集合</a></h2><blockquote><p>模板题</p></blockquote><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> p[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = find(p[x]);<br>    <br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        p[i] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;M&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>            p[find(a)] = find(b);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>            <span class="hljs-keyword">if</span>(find(a) == find(b)) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-AcWing-837-连通块中点的数量"><a href="#2-AcWing-837-连通块中点的数量" class="headerlink" title="2. AcWing 837. 连通块中点的数量"></a><a href="https://www.acwing.com/problem/content/839/">2. AcWing 837. 连通块中点的数量</a></h2><p>给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 m 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 a 和点 b 之间连一条边，a 和 b 可能相等；</li><li><code>Q1 a b</code>，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；</li><li><code>Q2 a</code>，询问点 a 所在连通块中点的数量；</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>也是模板题，加了一点点小变形。</p></blockquote><ol><li><p>初始化：注意Size数组，只在祖节点有意义，表示这棵树的节点数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        fa[i] = i;<br>        Size[i] = <span class="hljs-number">1</span>;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>找祖源（我觉得这个写法挺好理解）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fa[x] = find(fa[x]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>合并：<strong>注意如果没有提前定义变量，要先把祖宗节点数量加过去，再合并子树。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = find(a);<br>    <span class="hljs-keyword">int</span> y = find(b);<br>    fa[x] = y;<br>    size[y] += size[x];  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>询问是否连通</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> find(a)==find(b);<br>   &#125;<br><br>##<span class="hljs-meta"># code</span><br><br>```c++<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> p[N], Size[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b;<br>    <span class="hljs-keyword">char</span> op[<span class="hljs-number">5</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <br>    &#123;<br>        p[i] = i;<br>        Size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;C&#x27;</span>) <br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br><br>            <span class="hljs-keyword">if</span>(find(b) != find(a))<br>            &#123;<br>                Size[find(b)] += Size[find(a)];  <span class="hljs-comment">// 注意这里一定是先加长度，加集合！动脑子思考一下</span><br>                p[find(a)] = find(b);<br>            &#125;    <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>            <span class="hljs-keyword">if</span> (find(a) == find(b)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;   <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, Size[find(b)]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-AcWing-240-食物链"><a href="#3-AcWing-240-食物链" class="headerlink" title="3. AcWing 240. 食物链"></a><a href="https://www.acwing.com/problem/content/description/242/">3. AcWing 240. 食物链</a></h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220428151447.png"  style="zoom: 80%;" /></p><blockquote><p>思路还不是太清晰。。等遇到并查集再回来看</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mySQL</title>
    <link href="/2022/04/15/mySQL/"/>
    <url>/2022/04/15/mySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="mySQL"><a href="#mySQL" class="headerlink" title="mySQL"></a>mySQL</h1><h2 id="0-数据库常见概念"><a href="#0-数据库常见概念" class="headerlink" title="0. 数据库常见概念"></a>0. 数据库常见概念</h2><h3 id="0-1-概念"><a href="#0-1-概念" class="headerlink" title="0.1 概念"></a>0.1 概念</h3><p><strong>数据库：</strong>英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。</p><p><strong>数据库管理系统：</strong>DataBaseManagement，简称DBMS。数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。</p><p><strong>常见的数据库管理系统：</strong>MySQL、Oracle、MS SqlServer、DB2、sybase等….</p><p><strong>SQL：结构化查询语言</strong>。通过编写SQL语句，然后DBMS负责执行SQL语句，最终来完成数据库中数据的增删改查操作。</p><p>SQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，<br>同时在Oracle中也可以使用，在DB2中也可以使用。</p><p><strong>三者之间的关系？</strong>DBMS—&gt; 执行—&gt; SQL —操作—&gt; DB</p><h3 id="0-2-SQL语句分类"><a href="#0-2-SQL语句分类" class="headerlink" title="0.2 SQL语句分类"></a>0.2 SQL语句分类</h3><p><strong>DQL：</strong>数据查询语言（凡是带有sel        ect关键字的都是查询语句）</p><ul><li>select…        </li></ul><p><strong>DML：</strong>数据操作语言（凡是对表当中的数据进行增删改的都是DML）insert delete update。这个主要是操作表中的数据data。</p><ul><li>insert 增</li><li>delete 删</li><li>update 改</li></ul><p><strong>DDL：</strong>数据定义语言（凡是带有create、drop、alter的都是DDL。）这个增删改和DML不同，这个主要是对表结构进行操作。</p><ul><li>DDL主要操作的是表的结构。不是表中的数据。</li><li>create：新建，等同于增</li><li>drop：删除</li><li>alter：修改</li></ul><p><strong>TCL：</strong>事务控制语言。</p><ul><li>事务提交：commit;</li><li>事务回滚：rollback;</li></ul><p><strong>DCL：</strong>是数据控制语言。</p><ul><li>授权grant</li><li>撤销权限revoke</li><li>….</li></ul><h3 id="0-3-mySQL中的数据类型"><a href="#0-3-mySQL中的数据类型" class="headerlink" title="0.3 mySQL中的数据类型"></a>0.3 mySQL中的数据类型</h3><p><strong>varchar(最长255)</strong>：可变长度的字符串，比较智能，节省空间。会根据实际的数据长度动态分配空间。</p><ul><li>优点：节省空间</li><li>缺点：需要动态分配空间，速度慢。</li></ul><p><strong>char(最长255)</strong>：定长字符串，不管实际的数据长度是多少，分配固定长度的空间去存储数据。使用不恰当的时候，可能会导致空间的浪费。</p><ul><li>优点：不需要动态分配空间，<strong>速度快。</strong>​</li><li>缺点：使用不当可能会导致空间的浪费。</li></ul><p><strong>varchar和char我们应该怎么选择？</strong></p><ul><li>性别字段你选什么？因为性别是固定长度的字符串，所以选择char。<br>​</li><li>姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。</li></ul><p><strong>int(最长11)</strong>：数字中的整数型。等同于java的int。</p><p><strong>bigint</strong>：数字中的长整型。等同于java中的long。</p><p><strong>float</strong>：单精度浮点型数据</p><p><strong>double</strong>：双精度浮点型数据</p><p><strong>date</strong>：短日期类型</p><p><strong>datetime</strong>：长日期类型</p><p><strong>clob</strong>：字符大对象。最多可以存储4G的字符串。<br>比如：存储一篇文章，存储一个说明。超过255个字符的都要采用CLOB字符大对象来存储。<br>Character Large OBject:CLOB</p><p><strong>blob</strong>：二进制大对象。Binary Large OBject。专门用来存储图片、声音、视频等流媒体数据。<br>往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，你需要使用IO流才行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">t_movie 电影表（专门存储电影信息的）<br>编号<span class="hljs-keyword">no</span>(<span class="hljs-type">bigint</span>)名字name(<span class="hljs-type">varchar</span>)故事情节history(<span class="hljs-type">clob</span>)<br>上映日期playtime(<span class="hljs-type">date</span>)时长<span class="hljs-type">time</span>(<span class="hljs-keyword">double</span>)海报image(<span class="hljs-type">blob</span>)<br>类型type(<span class="hljs-type">char</span>)<br></code></pre></td></tr></table></figure><h3 id="0-4-SQL脚本的执行"><a href="#0-4-SQL脚本的执行" class="headerlink" title="0.4 SQL脚本的执行"></a>0.4 SQL脚本的执行</h3><p>xxxx.sql 这种文件被称为sql脚本文件。</p><p>sql脚本文件中编写了大量的sql语句。</p><p>我们执行sql脚本文件的时候，该文件中所有的sql语句会全部执行！批量的执行SQL语句，可以使用sql脚本文件。</p><p><code>mysql&gt; source D:\course\03-MySQL\document\vip.sql</code></p><blockquote><p>你在实际的工作中，第一天到了公司，项目经理会给你一个xxx.sql文件，你执行这个脚本文件，你电脑上的数据库数据就有了！</p></blockquote><h3 id="0-5-数据库和表的导入导出"><a href="#0-5-数据库和表的导入导出" class="headerlink" title="0.5 数据库和表的导入导出"></a>0.5 数据库和表的导入导出</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">数据导出？<br>注意：在windows的dos命令窗口中：<br>mysqldump bjpowernode<span class="hljs-operator">&gt;</span>D:\bjpowernode.sql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p123456<br>可以导出指定的表吗？<br>mysqldump bjpowernode emp<span class="hljs-operator">&gt;</span>D:\bjpowernode.sql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p123456<br><br>数据导入？<br>注意：需要先登录到mysql数据库服务器上。<br>然后创建数据库：<span class="hljs-keyword">create</span> database bjpowernode;<br>使用数据库：use bjpowernode<br>然后初始化数据库：source D:\bjpowernode.sql<br></code></pre></td></tr></table></figure><h2 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1. 数据库操作"></a>1. 数据库操作</h2><p><strong>show databases;</strong>     查看mysql中有哪些数据库</p><p><strong>use test;</strong>    表示正在使用一个名字叫做test的数据库。</p><p><strong>create database db01;</strong>    创建数据库</p><p><strong>show tables;</strong>     查看某个数据库下有哪些表</p><p><strong>select version();</strong>    查看mysql数据库的版本号</p><p><strong>select database();</strong>    查看当前使用的是哪个数据库</p><p><strong>\c</strong>    用来终止一条命令的输入。</p><h2 id="2-建表操作"><a href="#2-建表操作" class="headerlink" title="2. 建表操作"></a>2. 建表操作</h2><h3 id="2-1-创建一个表create"><a href="#2-1-创建一个表create" class="headerlink" title="2.1 创建一个表create"></a>2.1 创建一个表create</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">学号、姓名、年龄、性别、邮箱地址<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>        <span class="hljs-keyword">no</span> <span class="hljs-type">int</span>,<br>        name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>),<br>        sex <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>        age <span class="hljs-type">int</span>(<span class="hljs-number">3</span>),<br>        email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>    );<br></code></pre></td></tr></table></figure><h3 id="2-2-删除一个表drop"><a href="#2-2-删除一个表drop" class="headerlink" title="2.2 删除一个表drop"></a>2.2 删除一个表drop</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 当这张表不存在的时候会报错！<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 如果这张表存在的话，删除<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_student;<br></code></pre></td></tr></table></figure><ul><li>对表结构的修改需要使用：<strong>alter</strong>属于DDL语句</li><li><strong>desc</strong> t_student    查看表结构</li></ul><h3 id="2-3-插入数据insert"><a href="#2-3-插入数据insert" class="headerlink" title="2.3 插入数据insert"></a>2.3 插入数据insert</h3><ul><li>insert into 表名(字段名1,字段名2,字段名3…) values(值1,值2,值3);</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-keyword">no</span>,name,sex,age,email)<br><span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;zhangsan@123.com&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(email,name,sex,age,<span class="hljs-keyword">no</span>)<br><span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;lisi@123.com&#x27;</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-keyword">no</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>省略字段名<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;lisi@123.com&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>insert 语句但凡是执行成功了，那么必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。</li></ul><p><strong>一次插入多条数据</strong></p><ul><li>insert into t_user(字段名1,字段名2) values(),(),(),();</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user(id,name,birth,create_time) <span class="hljs-keyword">values</span><br>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-string">&#x27;1980-10-11&#x27;</span>,now()), <br>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;1981-10-11&#x27;</span>,now()),<br>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;wangwu&#x27;</span>,<span class="hljs-string">&#x27;1982-10-11&#x27;</span>,now());<br></code></pre></td></tr></table></figure><h3 id="2-4-修改数据update"><a href="#2-4-修改数据update" class="headerlink" title="2.4 修改数据update"></a>2.4 修改数据update</h3><ul><li><p>update 表名 set 字段名1=值1,字段名2=值2,字段名3=值3… where 条件;</p></li><li><p>没有条件限制会导致所有数据全部更新。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> t_user <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;jack&#x27;</span>, birth <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2000-10-11&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">update</span> t_user <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;jack&#x27;</span>, birth <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2000-10-11&#x27;</span>, create_time <span class="hljs-operator">=</span> now() <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h3 id="2-5-删除数据"><a href="#2-5-删除数据" class="headerlink" title="2.5 删除数据"></a>2.5 删除数据</h3><p><strong>delete</strong>语句删除数据的原理？（delete属于DML语句！！！）</p><ul><li>表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！</li><li>这种删除缺点是：删除效率比较低。</li><li>这种删除优点是：支持回滚，后悔了可以再恢复数据！！！</li></ul><p><strong>truncate</strong>语句删除数据的原理？</p><ul><li>这种删除效率比较高，表被一次截断，物理删除。</li><li>这种删除缺点：不支持回滚。</li><li>这种删除优点：快速。</li></ul><h4 id="2-5-1-delete"><a href="#2-5-1-delete" class="headerlink" title="2.5.1 delete"></a>2.5.1 delete</h4><ul><li>delete from 表名 where 条件;</li><li><p>没有条件，整张表的数据会全部删除！</p></li><li><p>delete from t_user where id = 2;</p></li></ul><h4 id="2-5-2-truncate"><a href="#2-5-2-truncate" class="headerlink" title="2.5.2 truncate"></a>2.5.2 truncate</h4><ul><li>truncate table dept_bak; （这种操作属于DDL操作。）</li></ul><p>下列演示内容所用表</p><p><img src="C:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220415214055230.png" alt="image-20220415214055230"></p><h2 id="3-单表查询"><a href="#3-单表查询" class="headerlink" title="3. 单表查询"></a>3. 单表查询</h2><h3 id="3-1-基础条件查询"><a href="#3-1-基础条件查询" class="headerlink" title="3.1 基础条件查询"></a>3.1 基础条件查询</h3><ul><li>select  字段1,字段2,字段3….  from   表名  where  条件;</li></ul><p><strong>= 等于</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询薪资等于<span class="hljs-number">800</span>的员工姓名和编号？<br><span class="hljs-keyword">select</span> empno,ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">=</span> <span class="hljs-number">800</span>;<br>查询SMITH的编号和薪资？<br><span class="hljs-keyword">select</span> empno,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SMITH&#x27;</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>字符串使用单引号<br></code></pre></td></tr></table></figure><p><strong>&lt;&gt;或!= 不等于</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询薪资不等于<span class="hljs-number">800</span>的员工姓名和编号？<br><span class="hljs-keyword">select</span> empno,ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">!=</span> <span class="hljs-number">800</span>;<br><span class="hljs-keyword">select</span> empno,ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">800</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 小于号和大于号组成的不等号<br></code></pre></td></tr></table></figure><p><strong>&lt; 小于</strong>  <strong>&lt;= 小于等于</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询薪资小于等于<span class="hljs-number">3000</span>的员工姓名和编号？<br><span class="hljs-keyword">select</span> empno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3000</span>;<br></code></pre></td></tr></table></figure><p><strong>(&gt;)大于 </strong>  <strong>(&gt;=) 大于等于</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询薪资大于等于<span class="hljs-number">3000</span>的员工姓名和编号？<br><span class="hljs-keyword">select</span> empno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3000</span>;<br></code></pre></td></tr></table></figure><p><strong>between … and ….</strong> 两个值之间, 等同于 &gt;= and &lt;=</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询薪资在<span class="hljs-number">2450</span>和<span class="hljs-number">3000</span>之间的员工信息？包括<span class="hljs-number">2450</span>和<span class="hljs-number">3000</span><br>第一种方式：<span class="hljs-operator">&gt;=</span> <span class="hljs-keyword">and</span> <span class="hljs-operator">&lt;=</span> （<span class="hljs-keyword">and</span>是并且的意思。）<br><span class="hljs-keyword">select</span> empno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2450</span> <span class="hljs-keyword">and</span> sal <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3000</span>;<br>    第二种方式：<br>    <span class="hljs-keyword">select</span> empno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-keyword">between</span> <span class="hljs-number">2450</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3000</span>;<br></code></pre></td></tr></table></figure><p><strong>is null 为 null（is not null 不为空）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询哪些员工的津贴<span class="hljs-operator">/</span>补助为<span class="hljs-keyword">null</span>？<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> empno,ename,sal,comm <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> comm <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>;<br><br>查询哪些员工的津贴<span class="hljs-operator">/</span>补助不为<span class="hljs-keyword">null</span>？<br><span class="hljs-keyword">select</span> empno,ename,sal,comm <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> comm <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p><strong>and 并且    or 或者</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> <span class="hljs-number">2500</span> <span class="hljs-keyword">and</span> (deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">or</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">20</span>);<br><br><span class="hljs-keyword">and</span>和<span class="hljs-keyword">or</span>同时出现，<span class="hljs-keyword">and</span>优先级较高。如果想让<span class="hljs-keyword">or</span>先执行，需要加“小括号”，以后在开发中，如果不确定优先级，就加小括号就行了。<br></code></pre></td></tr></table></figure><p><strong>in 包含，相当于多个 or （not in 不在这个范围中）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询工作岗位是MANAGER和SALESMAN的员工？<br><span class="hljs-keyword">select</span> empno,ename,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MANAGER&#x27;</span> <span class="hljs-keyword">or</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SALESMAN&#x27;</span>;<br><span class="hljs-keyword">select</span> empno,ename,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;MANAGER&#x27;</span>, <span class="hljs-string">&#x27;SALESMAN&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>not 可以取非，主要用在 is 或 in 中</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br><span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br><span class="hljs-keyword">in</span><br><span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span><br></code></pre></td></tr></table></figure><p><strong>like</strong>     </p><p>称为模糊查询，支持%或下划线匹配</p><ul><li>%匹配任意多个字符</li><li>下划线：任意一个字符。</li><li>（%是一个特殊的符号，_ 也是一个特殊符号）    </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">找出名字中含有O的？<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%O%&#x27;</span>;<br><br>找出名字中有“_”的？<br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> t_student <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%_%&#x27;</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>这样不行。<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> t_student <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%\_%&#x27;</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> \转义字符。<br></code></pre></td></tr></table></figure><p><strong>distinct</strong></p><p>把查询结果去除重复记录【distinct】</p><ul><li>distinct 只能出现在所有字段的最前方。</li><li><p>distinct 出现在 job,deptno 两个字段之前，表示两个字段联合起来去重。</p></li><li><p>select distinct job from emp;</p></li><li>select distinct job,deptno from emp;</li></ul><h3 id="3-2-排序"><a href="#3-2-排序" class="headerlink" title="3.2 排序"></a>3.2 排序</h3><p>查询所有员工薪资，排序？</p><ul><li>select  ename,sal from emp order by sal; // 默认是升序！！！</li></ul><p>指定降序：<strong>desc</strong></p><ul><li>select  ename,sal from emp order by sal desc;</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排列。<br><span class="hljs-keyword">select</span> <br>ename,sal<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>sal <span class="hljs-keyword">asc</span>, ename <span class="hljs-keyword">asc</span>;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。<br></code></pre></td></tr></table></figure><h3 id="3-3-分页"><a href="#3-3-分页" class="headerlink" title="3.3 分页"></a>3.3 分页</h3><ul><li><strong>limit</strong> 作用：将查询结果集的一部分取出来。通常使用在分页查询当中。<ul><li>完整用法：limit startIndex, length        startIndex是起始下标，length是长度。</li><li>起始下标从0开始。</li><li>缺省用法：limit 5; 这是取前5.</li></ul></li></ul><p><strong>按照薪资降序，取出排名在前5名的员工？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>ename,sal<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <br>sal <span class="hljs-keyword">desc</span><br>limit <span class="hljs-number">5</span>;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>取前<span class="hljs-number">5</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<br><br>mysql当中limit在<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>之后执行！！！！！！<br></code></pre></td></tr></table></figure><p><strong>取出工资排名在[3-5]名的员工？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>ename,sal<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>sal <span class="hljs-keyword">desc</span><br>limit<br><span class="hljs-number">2</span>, <span class="hljs-number">3</span>;<br><span class="hljs-number">2</span>表示起始位置从下标<span class="hljs-number">2</span>开始，就是第三条记录。<br><span class="hljs-number">3</span>表示长度。<br></code></pre></td></tr></table></figure><ul><li><p>每页显示3条记录</p><ul><li>第1页：limit 0,3        [0 1 2]</li><li>第2页：limit 3,3        [3 4 5]</li><li>第3页：limit 6,3        [6 7 8]</li></ul></li><li><p>每页显示pageSize条记录</p><ul><li>第pageNo页：limit (pageNo - 1) * pageSize  , pageSize</li></ul></li></ul><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><h3 id="4-1-单行处理函数"><a href="#4-1-单行处理函数" class="headerlink" title="4.1 单行处理函数"></a>4.1 单行处理函数</h3><ul><li>单行处理函数的特点：一个输入对应一个输出。<ul><li>和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs sql">lower 转换小写<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">lower</span>(ename) <span class="hljs-keyword">as</span> ename <span class="hljs-keyword">from</span> emp;<br><br>upper 转换大写<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_student;<br><br>substr 取子串：substr(被截取的字符串, 起始下标, 截取的长度)<br><span class="hljs-keyword">select</span> substr(ename, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> ename <span class="hljs-keyword">from</span> emp;<br>注意：起始下标从<span class="hljs-number">1</span>开始，没有<span class="hljs-number">0.</span><br>        找出员工名字第一个字母是A的员工信息？<br>第一种方式：模糊查询<br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;A%&#x27;</span>;<br>第二种方式：substr函数<br><span class="hljs-keyword">select</span> <br>ename <br><span class="hljs-keyword">from</span> <br>emp <br><span class="hljs-keyword">where</span> <br>substr(ename,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>concat函数进行字符串的拼接<br><span class="hljs-keyword">select</span> concat(empno,ename) <span class="hljs-keyword">from</span> emp;<br><br>length 取长度<br><span class="hljs-keyword">select</span> length(ename) enamelength <span class="hljs-keyword">from</span> emp;<br><br>trim 去空格<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;  KING&#x27;</span>;<br><br>str_to_date 将字符串转换成日期<br>date_format 格式化日期<br>format 设置千分位<br>round 四舍五入<br><span class="hljs-keyword">select</span> 字段 <span class="hljs-keyword">from</span> 表名;<br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">from</span> emp; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">select</span>后面直接跟“字面量<span class="hljs-operator">/</span>字面值”<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">as</span> bieming <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> round(<span class="hljs-number">1236.567</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> emp;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 保留<span class="hljs-number">1</span>个小数<br><span class="hljs-keyword">select</span> round(<span class="hljs-number">1236.567</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> emp;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 保留<span class="hljs-number">2</span>个小数<br><span class="hljs-keyword">select</span> round(<span class="hljs-number">1236.567</span>, <span class="hljs-number">-1</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> emp; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 保留到十位。<br><br>rand() 生成随机数<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> round(rand() <span class="hljs-operator">*</span> <span class="hljs-number">100</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">from</span> emp; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-number">100</span>以内的随机数<br><br>ifnull 可以将 <span class="hljs-keyword">null</span> 转换成一个具体值<br>ifnull是空处理函数。专门处理空的。<br>在所有数据库当中，只要有<span class="hljs-keyword">NULL</span>参与的数学运算，最终结果就是<span class="hljs-keyword">NULL</span>。<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> ename, sal <span class="hljs-operator">+</span> comm <span class="hljs-keyword">as</span> salcomm <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h3 id="4-2-分组函数"><a href="#4-2-分组函数" class="headerlink" title="4.2 分组函数"></a>4.2 分组函数</h3><ul><li>多行处理函数的特点：输入多行，最终输出一行。<ul><li>count    计数</li><li>sum    求和</li><li>avg    平均值</li><li>max    最大值</li><li>min    最小值</li></ul></li><li>注意：<pre><code>分组函数在使用的时候必须先进行分组，然后才能用。如果你没有对数据进行分组，整张表默认为一组。    </code></pre></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">找出最高工资？<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp;<br>找出最低工资？<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(sal) <span class="hljs-keyword">from</span> emp;<br>计算工资和：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(sal) <span class="hljs-keyword">from</span> emp;<br>计算平均工资：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp;<br>计算员工数量？<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(ename) <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><p><strong>分组函数在使用的时候需要注意哪些？</strong>    </p><ul><li><p>第一点：分组函数自动忽略NULL，你不需要提前对NULL进行处理。</p></li><li><p>第二点：分组函数中 count(*) 和 count(具体字段) 有什么区别？</p><ul><li>count(具体字段)：表示统计该字段下所有不为NULL的元素的总数。</li><li>count(*)：统计表当中的总行数。（只要有一行数据count则++）<br>因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。</li></ul></li><li><p>第三点：分组函数不能够直接使用在where子句中。<br>找出比最低工资高的员工信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> <span class="hljs-built_in">min</span>(sal);<br>表面上没问题，运行一下？<br>ERROR <span class="hljs-number">1111</span> (HY000): Invalid use <span class="hljs-keyword">of</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">function</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5.分组查询"></a>5.分组查询</h2><h3 id="5-1-group-by"><a href="#5-1-group-by" class="headerlink" title="5.1 group by"></a>5.1 group by</h3><p><strong>找出每个工作岗位的工资和？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">实现思路：按照工作岗位分组，然后对工资求和。<br><span class="hljs-keyword">select</span> <br>job,<span class="hljs-built_in">sum</span>(sal)<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>job;<br><br>以上这个语句的执行顺序？<br>先从emp表中查询数据。根据job字段进行分组。然后对每一组的数据进行<span class="hljs-built_in">sum</span>(sal)<br></code></pre></td></tr></table></figure><ul><li>在一条select语句当中，如果有group by语句的话，select 后面只能跟：<strong>参加分组的字段，以及分组函数</strong>。其它的一律不能跟。</li></ul><p><strong>找出每个部门的最高薪资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">实现思路: 按照部门编号分组，求每一组的最大值。<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> deptno, <span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br></code></pre></td></tr></table></figure><h3 id="5-2-联合分组"><a href="#5-2-联合分组" class="headerlink" title="5.2 联合分组"></a>5.2 联合分组</h3><p><strong>找出“每个部门，不同工作岗位”的最高薪资？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">技巧：两个字段联合成<span class="hljs-number">1</span>个字段看。（两个字段联合分组）<br><span class="hljs-keyword">select</span> <br>deptno, job, <span class="hljs-built_in">max</span>(sal)<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>deptno, job;<br></code></pre></td></tr></table></figure><h3 id="5-3-having"><a href="#5-3-having" class="headerlink" title="5.3 having"></a>5.3 having</h3><ul><li><p>使用having可以对分完组之后的数据进一步过滤。</p></li><li><p>having不能单独使用，having不能代替where，having必须和group by联合使用。</p></li></ul><p><strong>找出每个部门平均薪资，要求显示平均薪资高于2500的。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>deptno, <span class="hljs-built_in">avg</span>(sal)<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>deptno<br><span class="hljs-keyword">having</span><br><span class="hljs-built_in">avg</span>(sal) <span class="hljs-operator">&gt;</span> <span class="hljs-number">2500</span>;<br></code></pre></td></tr></table></figure><ul><li>where和having，优先选择where，where实在完成不了了，再选择having。</li></ul><h3 id="5-4-总结sql执行顺序"><a href="#5-4-总结sql执行顺序" class="headerlink" title="5.4 总结sql执行顺序"></a>5.4 总结sql执行顺序</h3><ul><li>select  —&gt; from —&gt; where —&gt; group by —&gt; having —&gt; order by —&gt;<br>以上关键字只能按照这个顺序来，不能颠倒。</li></ul><p>执行顺序？</p><ul><li>from —&gt; where —&gt; group by —&gt; having —&gt; select —&gt; order by</li></ul><ol><li>从某张表中查询数据，</li><li>先经过where条件筛选出有价值的数据。</li><li>对这些有价值的数据进行分组。</li><li>分组之后可以使用having继续筛选。</li><li>select查询出来。</li><li>最后排序输出！</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">找出每个岗位的平均薪资，要求显示平均薪资大于<span class="hljs-number">1500</span>的，除MANAGER岗位之外，要求按照平均薪资降序排。<br><br><span class="hljs-keyword">select</span> <br>job, <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">as</span> avg_sal<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">where</span><br>job <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;MANAGER&#x27;</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>job<br><span class="hljs-keyword">having</span><br>avg_sal<span class="hljs-operator">&gt;</span> <span class="hljs-number">1500</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>avgsal <span class="hljs-keyword">desc</span>;  <br></code></pre></td></tr></table></figure><h2 id="6-连表查询"><a href="#6-连表查询" class="headerlink" title="6. 连表查询"></a>6. 连表查询</h2><ul><li><p>从一张表中单独查询，称为单表查询</p></li><li><p>emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。</p></li><li><p>这种跨表查询，多张表联合起来查询数据，被称为连接查询。</p><p>select ename,dname from emp, dept;</p></li><li><p>当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。</p></li></ul><h3 id="6-1-内连接之等值连接"><a href="#6-1-内连接之等值连接" class="headerlink" title="6.1 内连接之等值连接"></a>6.1 内连接之等值连接</h3><p><strong>查询每个员工所在部门名称，显示员工名和部门名？</strong></p><ul><li>emp e和dept d表进行连接。条件是：e.deptno = d.deptno</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">SQL92语法：<br><span class="hljs-keyword">select</span> <br>e.ename,d.dname<br><span class="hljs-keyword">from</span><br>emp e, dept d<br><span class="hljs-keyword">where</span><br>e.deptno <span class="hljs-operator">=</span> d.deptno;<br><br>sql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了<span class="hljs-keyword">where</span>后面。<br><br>SQL99语法：<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">inner</span>可以省略（带着<span class="hljs-keyword">inner</span>可读性更好！！！一眼就能看出来是内连接）<br><span class="hljs-keyword">select</span> <br>e.ename,d.dname<br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span><br>e.deptno <span class="hljs-operator">=</span> d.deptno; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 条件是等量关系，所以被称为等值连接。<br><br>sql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加<span class="hljs-keyword">where</span><br></code></pre></td></tr></table></figure><h3 id="6-2-内连接之非等值连接"><a href="#6-2-内连接之非等值连接" class="headerlink" title="6.2 内连接之非等值连接"></a>6.2 内连接之非等值连接</h3><p><strong>找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>e.ename, e.sal, s.grade<br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">join</span><br>salgrade s<br><span class="hljs-keyword">on</span><br>e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 条件不是一个等量关系，称为非等值连接。<br></code></pre></td></tr></table></figure><h3 id="6-3-内连接之自己连接"><a href="#6-3-内连接之自己连接" class="headerlink" title="6.3 内连接之自己连接"></a>6.3 内连接之自己连接</h3><p><strong>查询员工的上级领导，要求显示员工名和对应的领导名？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">技巧：一张表看成两张表。<br><span class="hljs-keyword">select</span> <br>a.ename <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;员工名&#x27;</span>, b.ename <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;领导名&#x27;</span><br><span class="hljs-keyword">from</span><br>emp a<br><span class="hljs-keyword">join</span><br>emp b<br><span class="hljs-keyword">on</span><br>a.mgr <span class="hljs-operator">=</span> b.empno; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>员工的领导编号 <span class="hljs-operator">=</span> 领导的员工编号<br></code></pre></td></tr></table></figure><h3 id="6-4-外连接"><a href="#6-4-外连接" class="headerlink" title="6.4 外连接"></a>6.4 外连接</h3><ul><li><p>内连接：（A和B连接，AB两张表没有主次关系。平等的。）</p></li><li><p>内连接的特点：完成能够匹配上ON后面的条件的数据查询出来。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">outer</span>是可以省略的，带着可读性强。<br><span class="hljs-keyword">select</span> <br>e.ename,d.dname<br><span class="hljs-keyword">from</span><br>emp e <br><span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <br>dept d<br><span class="hljs-keyword">on</span><br>e.deptno <span class="hljs-operator">=</span> d.deptno;<br></code></pre></td></tr></table></figure><ul><li>right代表什么：表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表。</li><li><strong>在外连接当中，两张表连接，产生了主次关系。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>e.ename,d.dname<br><span class="hljs-keyword">from</span><br>dept d <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <br>emp e<br><span class="hljs-keyword">on</span><br>e.deptno <span class="hljs-operator">=</span> d.deptno;<br><br>带有<span class="hljs-keyword">right</span>的是右外连接，又叫做右连接。<br>带有<span class="hljs-keyword">left</span>的是左外连接，又叫做左连接。<br>任何一个右连接都有左连接的写法。<br>任何一个左连接都有右连接的写法。<br></code></pre></td></tr></table></figure><h3 id="6-5-多表连接"><a href="#6-5-多表连接" class="headerlink" title="6.5 多表连接"></a>6.5 多表连接</h3><p><strong>三张表，四张表怎么连接？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">语法：<br><span class="hljs-keyword">select</span> <br>...<br><span class="hljs-keyword">from</span><br>a<br><span class="hljs-keyword">join</span><br>b<br><span class="hljs-keyword">on</span><br>a和b的连接条件<br><span class="hljs-keyword">join</span><br>c<br><span class="hljs-keyword">on</span><br>a和c的连接条件<br><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span><br>d<br><span class="hljs-keyword">on</span><br>a和d的连接条件<br></code></pre></td></tr></table></figure><p><strong>找出每个员工的部门名称以及工资等级，要求显示员工名、部门名、薪资、薪资等级？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>e.ename,e.sal,d.dname,s.grade<br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span> <br>e.deptno <span class="hljs-operator">=</span> d.deptno<br><span class="hljs-keyword">join</span><br>salgrade s<br><span class="hljs-keyword">on</span><br>e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 通过薪资所在salgrade表的范围确定薪资等级<br></code></pre></td></tr></table></figure><p><strong>找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>e.ename,e.sal,d.dname,s.grade,l.ename<br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span> <br>e.deptno <span class="hljs-operator">=</span> d.deptno<br><span class="hljs-keyword">join</span><br>salgrade s<br><span class="hljs-keyword">on</span><br>e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span><br>emp l<br><span class="hljs-keyword">on</span><br>e.mgr <span class="hljs-operator">=</span> l.empno;<br></code></pre></td></tr></table></figure><h2 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7. 子查询"></a>7. 子查询</h2><ul><li><p>select 语句中嵌套 select 语句，被嵌套的 select 语句称为子查询。</p></li><li><p>子查询可以出现在 select 后面，from 后面，where 后面。</p></li></ul><h3 id="7-1-where-子句中的子查询"><a href="#7-1-where-子句中的子查询" class="headerlink" title="7.1 where 子句中的子查询"></a>7.1 where 子句中的子查询</h3><p><strong>找出比最低工资高的员工姓名和工资？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(sal) <span class="hljs-keyword">from</span> emp);<br></code></pre></td></tr></table></figure><h3 id="7-2-from-子句中的子查询"><a href="#7-2-from-子句中的子查询" class="headerlink" title="7.2 from 子句中的子查询"></a>7.2 from 子句中的子查询</h3><ul><li>from 后面的子查询，可以将子查询的查询结果当做一张临时表。（技巧）</li></ul><p><strong>找出每个岗位的平均工资的薪资等级。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>t.<span class="hljs-operator">*</span>, s.grade<br><span class="hljs-keyword">from</span><br>(<span class="hljs-keyword">select</span> job,<span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">as</span> avgsal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job) t<br><span class="hljs-keyword">join</span><br>salgrade s<br><span class="hljs-keyword">on</span><br>t.avgsal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;<br></code></pre></td></tr></table></figure><h2 id="8-约束"><a href="#8-约束" class="headerlink" title="8. 约束"></a>8. 约束</h2><ul><li>在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！</li></ul><h3 id="8-1-约束类型"><a href="#8-1-约束类型" class="headerlink" title="8.1 约束类型"></a>8.1 约束类型</h3><ul><li>非空约束：not null</li><li>唯一性约束：unique</li><li>主键约束：primary key （简称PK）</li><li>外键约束：foreign key（简称FK）</li><li>检查约束：check（mysql不支持，oracle支持）</li></ul><p>重点学习四个约束：<strong>not null，unique，primary key，foreign key。</strong></p><h3 id="8-2-not-null"><a href="#8-2-not-null" class="headerlink" title="8.2 not null"></a>8.2 not null</h3><ul><li>非空约束 not null 约束的字段不能为 NULL。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>    id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> 只有列级约束，没有表级约束！<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id, name) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>);<br>ERROR <span class="hljs-number">1364</span> (HY000): Field <span class="hljs-string">&#x27;name&#x27;</span> doesn<span class="hljs-string">&#x27;t have a default value</span><br></code></pre></td></tr></table></figure><h3 id="8-3-unique"><a href="#8-3-unique" class="headerlink" title="8.3 unique"></a>8.3 unique</h3><ul><li>唯一性约束 unique 约束的字段不能重复，但是<strong>可以为NULL</strong>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>id <span class="hljs-type">int</span>,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">unique</span>,<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;lisi@123.com&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;wangwu&#x27;</span>,<span class="hljs-string">&#x27;wangwu@123.com&#x27;</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_vip;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;wangwu&#x27;</span>,<span class="hljs-string">&#x27;wangwu@sina.com&#x27;</span>);<br>ERROR <span class="hljs-number">1062</span> (<span class="hljs-number">23000</span>): Duplicate entry <span class="hljs-string">&#x27;wangwu&#x27;</span> <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;name&#x27;</span><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id) <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+------------------+</span><br><span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span> email            <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+------------------+</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span> zhangsan<span class="hljs-variable">@123</span>.com <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span> lisi     <span class="hljs-operator">|</span> lisi<span class="hljs-variable">@123</span>.com     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span> wangwu   <span class="hljs-operator">|</span> wangwu<span class="hljs-variable">@123</span>.com   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+------------------+</span><br>name字段虽然被<span class="hljs-keyword">unique</span>约束了，但是可以为<span class="hljs-keyword">NULL</span>。<br></code></pre></td></tr></table></figure><h4 id="8-3-1-联合唯一"><a href="#8-3-1-联合唯一" class="headerlink" title="8.3.1 联合唯一"></a>8.3.1 联合唯一</h4><ul><li>name 和 email 两个字段联合起来具有唯一性！！！！</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>id <span class="hljs-type">int</span>,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br><span class="hljs-keyword">unique</span>(name,email) <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 约束没有添加在列的后面，这种约束被称为表级约束。<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;zhangsan@123.com&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;zhangsan@sina.com&#x27;</span>);<br>name 和 email两个字段联合起来唯一！！！<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;zhangsan@sina.com&#x27;</span>);<br>ERROR <span class="hljs-number">1062</span> (<span class="hljs-number">23000</span>): Duplicate entry <span class="hljs-string">&#x27;zhangsan-zhangsan@sina.com&#x27;</span> <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>在 mysql 当中，如果一个字段同时被 not null 和 unique 约束的话，该字段自动变成主键字段。（注意：oracle中不一样！）</li></ul><h3 id="8-4-primary-key"><a href="#8-4-primary-key" class="headerlink" title="8.4 primary key"></a>8.4 primary key</h3><ul><li><p>主键值是每一行记录的唯一标识。主键值是每一行记录的身份证号！！！</p></li><li><p>主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-number">1</span>个字段做主键，叫做：单一主键<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>列级约束<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>(id)  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 表级约束<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>);<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>错误：不能重复<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>);<br>ERROR <span class="hljs-number">1062</span> (<span class="hljs-number">23000</span>): Duplicate entry <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;PRIMARY&#x27;</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>错误：不能为<span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhaoliu&#x27;</span>);<br>ERROR <span class="hljs-number">1364</span> (HY000): Field <span class="hljs-string">&#x27;id&#x27;</span> doesn<span class="hljs-string">&#x27;t have a default value</span><br></code></pre></td></tr></table></figure><h4 id="8-4-1-复合主键"><a href="#8-4-1-复合主键" class="headerlink" title="8.4.1 复合主键"></a>8.4.1 复合主键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> id和name联合起来做主键：复合主键！！！！<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>    id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>(id,name)<br>);<br>        <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;zhangsan@123.com&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;lisi@123.com&#x27;</span>);<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>错误：不能重复<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;lisi@123.com&#x27;</span>);<br>ERROR <span class="hljs-number">1062</span> (<span class="hljs-number">23000</span>): Duplicate entry <span class="hljs-string">&#x27;1-lisi&#x27;</span> <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;PRIMARY&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>在实际开发中不建议使用：复合主键。建议使用单一主键！</li><li>因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">一个表中主键约束能加两个吗？<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span><br>);<br>ERROR <span class="hljs-number">1068</span> (<span class="hljs-number">42000</span>): Multiple <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> defined<br></code></pre></td></tr></table></figure><ul><li>结论：一张表，主键约束只能添加1个。（主键只能有1个。）</li></ul><p><strong>主键分类</strong></p><ul><li><p>自然主键：主键值是一个自然数，和业务没关系。</p></li><li><p>业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！</p></li></ul><h4 id="8-4-2-主键自增"><a href="#8-4-2-主键自增" class="headerlink" title="8.4.2 主键自增"></a>8.4.2 主键自增</h4><ul><li>在mysql当中，有一种机制，可以帮助我们自动维护一个主键值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql">rop <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment, <span class="hljs-operator">/</span><span class="hljs-operator">/</span>auto_increment表示自增，从<span class="hljs-number">1</span>开始，以<span class="hljs-number">1</span>递增！<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br></code></pre></td></tr></table></figure><h3 id="8-5-foreign-key"><a href="#8-5-foreign-key" class="headerlink" title="8.5 foreign key"></a>8.5 foreign key</h3><ul><li>如果一个实体的某个字段指向另一个实体的主键，就称为外键</li><li>被指向的实体，称之为主实体（主表），也叫父实体（父表）。</li><li>负责指向的实体，称之为从实体（从表），也叫子实体（子表）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_class(<br>classno <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,<br>classname <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br><span class="hljs-keyword">no</span> <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>cno <span class="hljs-type">int</span>,<br><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(cno) <span class="hljs-keyword">references</span> t_class(classno)<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_class(classno, classname) <span class="hljs-keyword">values</span>(<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;北京市大兴区亦庄镇第二中学高三1班&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_class(classno, classname) <span class="hljs-keyword">values</span>(<span class="hljs-number">101</span>, <span class="hljs-string">&#x27;北京市大兴区亦庄镇第二中学高三1班&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;lilei&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;hanmeimei&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">101</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-number">101</span>);<br></code></pre></td></tr></table></figure><ul><li>外键可以为空，可以理解成 一名学生肯定会关联到一个存在的班级，但来了一个转校生，还没有分班，他现在属于学生子表，但还没有关联到班级主表中的任何一条记录。</li></ul><p>t_class是父表，t_student是子表</p><p>​        <strong>删除表</strong>的顺序？    先删子，再删父。</p><p>​        <strong>创建表</strong>的顺序？    先创建父，再创建子。</p><p>​        <strong>删除数据</strong>的顺序？先删子，再删父。</p><p>​        <strong>插入数据</strong>的顺序？先插入父，再插入子</p><ul><li>子表中的外键引用的父表中的某个字段，被引用的这个字段不一定是主键，但至少具有unique约束。</li></ul><h2 id="9-存储引擎"><a href="#9-存储引擎" class="headerlink" title="9. 存储引擎"></a>9. 存储引擎</h2><ul><li>存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）</li><li>实际上存储引擎是一个表存储/组织数据的方式。</li><li>不同的存储引擎，表存储数据的方式不同。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student;<br>可以在建表的时候给表指定存储引擎。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_student` (<br>  `<span class="hljs-keyword">no</span>` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `cno` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`<span class="hljs-keyword">no</span>`),<br>  KEY `cno` (`cno`),<br>  <span class="hljs-keyword">CONSTRAINT</span> `t_student_ibfk_1` <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (`cno`) <span class="hljs-keyword">REFERENCES</span> `t_class` (`classno`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">11</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure><p>在建表的时候可以在最后小括号的”)”的右边使用：</p><ul><li>ENGINE 来指定存储引擎。    mysql默认的存储引擎是：<strong>InnoDB</strong></li><li>CHARSET 来指定这张表的字符编码方式。mysql默认的字符编码方式是：<strong>utf8</strong></li></ul><h3 id="9-1-mysql-支持的存储引擎"><a href="#9-1-mysql-支持的存储引擎" class="headerlink" title="9.1 mysql 支持的存储引擎"></a>9.1 mysql 支持的存储引擎</h3><ul><li>show engines \G   查看mysql支持哪些存储引擎</li><li>mysql 支持九大存储引擎，当前5.5.36支持8个。版本不同支持情况不同。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220418201608.png" alt=""></p><h3 id="9-2-MyISAM存储引擎"><a href="#9-2-MyISAM存储引擎" class="headerlink" title="9.2 MyISAM存储引擎"></a>9.2 MyISAM存储引擎</h3><ul><li><p>使用三个文件表示每个表：</p><ul><li>格式文件 — 存储表结构的定义（mytable.frm）</li><li>数据文件 — 存储表行的内容（mytable.MYD）</li><li>索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。</li></ul></li><li><p>可被转换为压缩、只读表来节省空间</p></li><li>MyISAM存储引擎特点：<ul><li>可被转换为压缩、只读表来节省空间这是这种存储引擎的优势！！！！</li><li>MyISAM不支持事务机制，安全性低。</li></ul></li></ul><h3 id="9-3-InnoDB存储引擎"><a href="#9-3-InnoDB存储引擎" class="headerlink" title="9.3 InnoDB存储引擎"></a>9.3 InnoDB存储引擎</h3><ul><li>这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。</li><li>InnoDB支持事务，支持数据库崩溃后自动恢复机制。</li><li><p>InnoDB存储引擎最主要的特点是：非常安全。</p></li><li><p>它管理的表具有下列主要特征：</p><ul><li>每个 InnoDB 表在数据库目录中以.frm 格式文件表示</li><li>InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）</li><li>提供一组用来记录事务性活动的日志文件</li><li>用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理</li><li>提供全 ACID 兼容</li><li>在 MySQL 服务器崩溃后提供自动恢复</li><li>多版本（MVCC）和行级锁定</li><li>支持外键及引用的完整性，包括级联删除和更新</li></ul></li><li>InnoDB最大的特点就是支持事务：以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，</li><li>不能很好的节省存储空间。</li></ul><h3 id="9-4-MEMORY存储引擎"><a href="#9-4-MEMORY存储引擎" class="headerlink" title="9.4 MEMORY存储引擎"></a>9.4 MEMORY存储引擎</h3><ul><li><p>使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得 MEMORY 存储引擎非常<strong>快</strong>。</p></li><li><p>MEMORY 存储引擎管理的表具有下列特征：</p><ul><li>在数据库目录内，每个表均以.frm 格式的文件表示。</li><li>表数据及索引被存储在内存中。（目的就是快，查询快！）</li><li>表级锁机制。</li><li>不能包含 TEXT 或 BLOB 字段。</li></ul></li><li><p>MEMORY 存储引擎以前被称为HEAP 引擎。</p></li><li>MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。</li><li>MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</li></ul><h2 id="10-事务"><a href="#10-事务" class="headerlink" title="10.事务"></a>10.事务</h2><ul><li><p>一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。</p></li><li><p>什么是一个完整的业务逻辑？</p><pre><code>假设转账，从A账户向B账户中转账10000.      将A账户的钱减去10000（update语句）      将B账户的钱加上10000（update语句）      这就是一个完整的业务逻辑。</code></pre></li><li>以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。</li><li>insert   delete   update  只有以上的三个语句和事务有关系，其它都没有关系。</li><li>事务：就是<strong>批量的DML语句同时成功，或者同时失败！</strong></li></ul><h3 id="10-1-InnoDB-实现事务"><a href="#10-1-InnoDB-实现事务" class="headerlink" title="10.1 InnoDB 实现事务"></a>10.1 InnoDB 实现事务</h3><ul><li><p>InnoDB 存储引擎：提供一组用来记录事务性活动的日志文件</p></li><li><p>在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。</p></li><li><p>在事务的执行过程中，<strong>我们可以提交事务，也可以回滚事务。</strong></p></li><li><p>提交事务   <strong>commit</strong>; 语句</p><ul><li>清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。</li><li>提交事务标志着，事务的结束。并且是一种全部成功的结束。</li></ul></li><li><p>回滚事务   <strong>rollback</strong>; 语句（回滚永远都是只能回滚到上一次的<strong>提交点</strong>！）</p><ul><li>将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件</li><li>回滚事务标志着，事务的结束。并且是一种全部失败的结束。</li></ul></li><li><p>将mysql的自动提交机制<strong>关闭</strong>掉   start transaction;</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql">事务回滚<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept_bak;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> transaction;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept_bak <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;tj&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept_bak <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;tj&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept_bak;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+------+</span><br><span class="hljs-operator">|</span> DEPTNO <span class="hljs-operator">|</span> DNAME <span class="hljs-operator">|</span> LOC  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> abc   <span class="hljs-operator">|</span> tj   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> abc   <span class="hljs-operator">|</span> tj   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">rollback</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept_bak;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="10-2-事物的四个特性-ACID"><a href="#10-2-事物的四个特性-ACID" class="headerlink" title="10.2 事物的四个特性 ACID"></a>10.2 事物的四个特性 ACID</h3><p><strong>A：原子性</strong><br>        说明事务是最小的工作单元。不可再分。</p><p><strong>C：一致性</strong><br>    所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性。</p><p><strong>I：隔离性</strong><br>    A事务和B事务之间具有一定的隔离。<br>    教室A和教室B之间有一道墙，这道墙就是隔离性。<br>    A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？</p><p><strong>D：持久性</strong><br>    事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据<br>    保存到硬盘上！</p><h3 id="10-3-事务的隔离性"><a href="#10-3-事务的隔离性" class="headerlink" title="10.3 事务的隔离性"></a>10.3 事务的隔离性</h3><h4 id="10-3-1-事务和事务之间四个隔离级别"><a href="#10-3-1-事务和事务之间四个隔离级别" class="headerlink" title="10.3.1 事务和事务之间四个隔离级别"></a>10.3.1 事务和事务之间四个隔离级别</h4><p><strong>读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》</strong></p><ul><li>事务A可以读取到事务B未提交的数据。</li><li>这种隔离级别存在的问题就是：<strong>脏读现象</strong>！(Dirty Read)我们称读到了脏数据。</li><li>这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！</li></ul><p><strong>读已提交：read committed《提交之后才能读到》</strong></p><ul><li>事务A只能读取到事务B提交之后的数据。</li><li>这种隔离级别解决了解决了脏读的现象。</li><li>这种隔离级别不可重复读取数据。<ul><li>在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3不等于4称为不可重复读取。</li></ul></li><li>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。</li><li>oracle数据库默认的隔离级别是：read committed</li></ul><p><strong>可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》</strong></p><ul><li>事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。</li><li>可重复读可能会出现幻影读。每一次读取到的数据都是幻象。不够真实！</li><li><p>早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！读到的是假象。不够绝对的真实。</p></li><li><p>mysql中默认的事务隔离级别就是这个！！！！！！！！！！！</p></li></ul><p><strong>序列化/串行化：serializable（最高的隔离级别）</strong></p><ul><li>这是最高隔离级别，效率最低。解决了所有的问题。</li><li>这种隔离级别表示事务排队，不能并发！</li><li>synchronized，线程同步（事务同步）每一次读取到的数据都是最真实的，并且效率是最低的。</li></ul><h4 id="10-3-2-验证各种隔离级别"><a href="#10-3-2-验证各种隔离级别" class="headerlink" title="10.3.2 验证各种隔离级别"></a>10.3.2 验证各种隔离级别</h4><ul><li>mysql 5 查看隔离级别：SELECT @@tx_isolation</li><li>mysql 8 查看隔离级别：select @@transaction_isolation;</li></ul><p><strong>验证：read uncommited</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read uncommitted;<br>事务A事务B<br><span class="hljs-comment">--------------------------------------------------------------------------------</span><br>use bjpowernode;<br>use bjpowernode;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br></code></pre></td></tr></table></figure><p><strong>验证：read commited</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read committed;<br>事务A事务B<br><span class="hljs-comment">--------------------------------------------------------------------------------</span><br>use bjpowernode;<br>use bjpowernode;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br><span class="hljs-keyword">commit</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br></code></pre></td></tr></table></figure><p><strong>验证：repeatable read</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level repeatable read;<br>事务A事务B<br><span class="hljs-comment">--------------------------------------------------------------------------------</span><br>use bjpowernode;<br>use bjpowernode;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;lisi&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;wangwu&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br></code></pre></td></tr></table></figure><p><strong>验证：serializable</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level serializable;<br>事务A事务B<br><span class="hljs-comment">--------------------------------------------------------------------------------</span><br>use bjpowernode;<br>use bjpowernode;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="11-索引"><a href="#11-索引" class="headerlink" title="11. 索引"></a>11. 索引</h2><ul><li>索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。</li><li>一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。</li><li><p>索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。</p></li><li><p>MySQL在查询方面主要就是两种方式：全表扫描  ；根据索引检索。</p></li><li><p>在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet</p></li><li><strong>数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。</strong></li><li><strong>遵循左小又大原则存放。采用中序遍历方式遍历取数据。</strong></li></ul><p><strong>索引的实现原理？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220418204148.png" style="zoom:90%;" /></p><ul><li>提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象</li><li>提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。</li><li>提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式</li></ul><p><strong>什么条件下，我们会考虑给字段添加索引呢？</strong></p><ol><li>数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）</li><li>该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。</li><li>该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）</li></ol><ul><li>建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。</li><li>建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。</li></ul><h3 id="11-1-索引的创建和删除"><a href="#11-1-索引的创建和删除" class="headerlink" title="11.1 索引的创建和删除"></a>11.1 索引的创建和删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql">创建索引：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> index emp_ename_index <span class="hljs-keyword">on</span> emp(ename);<br>给emp表的ename字段添加索引，起名：emp_ename_index<br><br>删除索引：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">drop</span> index emp_ename_index <span class="hljs-keyword">on</span> emp;<br>将emp表上的emp_ename_index索引对象删除。<br><br>查看一个<span class="hljs-keyword">SQL</span>语句是否使用了索引进行检索？<br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;KING&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+-</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br>扫描<span class="hljs-number">14</span>条记录：说明没有使用索引。type<span class="hljs-operator">=</span><span class="hljs-keyword">ALL</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> index emp_ename_index <span class="hljs-keyword">on</span> emp(ename);<br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;KING&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+-----------------</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys   <span class="hljs-operator">|</span> key             <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+-----------------</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> emp_ename_index <span class="hljs-operator">|</span> emp_ename_index <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+-----------------</span><br></code></pre></td></tr></table></figure><h3 id="11-2-索引失效"><a href="#11-2-索引失效" class="headerlink" title="11.2 索引失效"></a>11.2 索引失效</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs sql">失效的第<span class="hljs-number">1</span>种情况：<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%T&#x27;</span>;<br>ename上即使添加了索引，也不会走索引，为什么？<br>原因是因为模糊匹配当中以“<span class="hljs-operator">%</span>”开头了！<br>尽量避免模糊查询的时候以“<span class="hljs-operator">%</span>”开始。<br>这是一种优化的手段<span class="hljs-operator">/</span>策略。<br>myql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%T&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br><br>失效的第<span class="hljs-number">2</span>种情况：<br>使用<span class="hljs-keyword">or</span>的时候会失效，如果使用<span class="hljs-keyword">or</span>那么要求<span class="hljs-keyword">or</span>两边的条件字段都要有<br>索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个<br>字段上的索引也会实现。所以这就是为什么不建议使用<span class="hljs-keyword">or</span>的原因。<br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;KING&#x27;</span> <span class="hljs-keyword">or</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MANAGER&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+------+---------</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys   <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+------+---------</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> emp_ename_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+------+---------</span><br><br>失效的第<span class="hljs-number">3</span>种情况：<br>使用复合索引的时候，没有使用左侧的列查找，索引失效<br>什么是复合索引？<br>两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。<br><br><span class="hljs-keyword">create</span> index emp_job_sal_index <span class="hljs-keyword">on</span> emp(job,sal);<br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MANAGER&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-------------------+---------------</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys     <span class="hljs-operator">|</span> key           <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-------------------+---------------</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> emp_job_sal_index <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-------------------+---------------</span><br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">=</span> <span class="hljs-number">800</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br></code></pre></td></tr></table></figure><h2 id="12-视图"><a href="#12-视图" class="headerlink" title="12. 视图"></a>12. 视图</h2><ul><li>视图view：站在不同的角度去看待同一份数据。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">表复制：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept2 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept;<br>dept2表中的数据：<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><span class="hljs-operator">|</span> DEPTNO <span class="hljs-operator">|</span> DNAME      <span class="hljs-operator">|</span> LOC      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span> <span class="hljs-keyword">NEW</span> YORK <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">20</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span> DALLAS   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span> CHICAGO  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">40</span> <span class="hljs-operator">|</span> OPERATIONS <span class="hljs-operator">|</span> BOSTON   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><br>创建视图对象：<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> dept2_view <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2;<br><br>删除视图对象：<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> dept2_view;<br><br>注意：只有DQL语句才能以<span class="hljs-keyword">view</span>的形式创建。<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> view_name <span class="hljs-keyword">as</span> 这里的语句必须是DQL语句;<br></code></pre></td></tr></table></figure><h3 id="12-1-视图的作用"><a href="#12-1-视图的作用" class="headerlink" title="12.1 视图的作用"></a>12.1 视图的作用</h3><ul><li>我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>面向视图查询<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2_view; <br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 面向视图插入<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept2_view(deptno,dname,loc) <span class="hljs-keyword">values</span>(<span class="hljs-number">60</span>,<span class="hljs-string">&#x27;SALES&#x27;</span>, <span class="hljs-string">&#x27;BEIJING&#x27;</span>);<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 查询原表数据<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><span class="hljs-operator">|</span> DEPTNO <span class="hljs-operator">|</span> DNAME      <span class="hljs-operator">|</span> LOC      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span> <span class="hljs-keyword">NEW</span> YORK <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">20</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span> DALLAS   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span> CHICAGO  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">40</span> <span class="hljs-operator">|</span> OPERATIONS <span class="hljs-operator">|</span> BOSTON   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">60</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span> BEIJING  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 面向视图删除<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> dept2_view;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 查询原表数据<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 创建视图对象<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> <br>emp_dept_view<br><span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> <br>e.ename,e.sal,d.dname<br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span><br>e.deptno <span class="hljs-operator">=</span> d.deptno;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 查询视图对象<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp_dept_view;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------+------------+</span><br><span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> sal     <span class="hljs-operator">|</span> dname      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------+------------+</span><br><span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> <span class="hljs-number">2450.00</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> KING   <span class="hljs-operator">|</span> <span class="hljs-number">5000.00</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> <span class="hljs-number">1300.00</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span>  <span class="hljs-number">800.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> <span class="hljs-number">2975.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> <span class="hljs-number">3000.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> <span class="hljs-number">1100.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> <span class="hljs-number">3000.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> <span class="hljs-number">1600.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> <span class="hljs-number">1250.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> <span class="hljs-number">1250.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> <span class="hljs-number">2850.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> <span class="hljs-number">1500.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span>  <span class="hljs-number">950.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------+------------+</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 面向视图更新<br><span class="hljs-keyword">update</span> emp_dept_view <span class="hljs-keyword">set</span> sal <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ACCOUNTING&#x27;</span>;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 原表数据被更新<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-----------+------+------------+---------+---------+----</span><br><span class="hljs-operator">|</span> EMPNO <span class="hljs-operator">|</span> ENAME  <span class="hljs-operator">|</span> JOB       <span class="hljs-operator">|</span> MGR  <span class="hljs-operator">|</span> HIREDATE   <span class="hljs-operator">|</span> SAL     <span class="hljs-operator">|</span> COMM    <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-----------+------+------------+---------+---------+----</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7369</span> <span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> CLERK     <span class="hljs-operator">|</span> <span class="hljs-number">7902</span> <span class="hljs-operator">|</span> <span class="hljs-number">1980</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span> <span class="hljs-operator">|</span>  <span class="hljs-number">800.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7499</span> <span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> SALESMAN  <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-02</span><span class="hljs-number">-20</span> <span class="hljs-operator">|</span> <span class="hljs-number">1600.00</span> <span class="hljs-operator">|</span>  <span class="hljs-number">300.00</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7521</span> <span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> SALESMAN  <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-02</span><span class="hljs-number">-22</span> <span class="hljs-operator">|</span> <span class="hljs-number">1250.00</span> <span class="hljs-operator">|</span>  <span class="hljs-number">500.00</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7566</span> <span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> MANAGER   <span class="hljs-operator">|</span> <span class="hljs-number">7839</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-04</span><span class="hljs-number">-02</span> <span class="hljs-operator">|</span> <span class="hljs-number">2975.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7654</span> <span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> SALESMAN  <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-09</span><span class="hljs-number">-28</span> <span class="hljs-operator">|</span> <span class="hljs-number">1250.00</span> <span class="hljs-operator">|</span> <span class="hljs-number">1400.00</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> MANAGER   <span class="hljs-operator">|</span> <span class="hljs-number">7839</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-05</span><span class="hljs-number">-01</span> <span class="hljs-operator">|</span> <span class="hljs-number">2850.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7782</span> <span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> MANAGER   <span class="hljs-operator">|</span> <span class="hljs-number">7839</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-06</span><span class="hljs-number">-09</span> <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7788</span> <span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> ANALYST   <span class="hljs-operator">|</span> <span class="hljs-number">7566</span> <span class="hljs-operator">|</span> <span class="hljs-number">1987</span><span class="hljs-number">-04</span><span class="hljs-number">-19</span> <span class="hljs-operator">|</span> <span class="hljs-number">3000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7839</span> <span class="hljs-operator">|</span> KING   <span class="hljs-operator">|</span> PRESIDENT <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-11</span><span class="hljs-number">-17</span> <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7844</span> <span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> SALESMAN  <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-09</span><span class="hljs-number">-08</span> <span class="hljs-operator">|</span> <span class="hljs-number">1500.00</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0.00</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7876</span> <span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> CLERK     <span class="hljs-operator">|</span> <span class="hljs-number">7788</span> <span class="hljs-operator">|</span> <span class="hljs-number">1987</span><span class="hljs-number">-05</span><span class="hljs-number">-23</span> <span class="hljs-operator">|</span> <span class="hljs-number">1100.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7900</span> <span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> CLERK     <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-12</span><span class="hljs-number">-03</span> <span class="hljs-operator">|</span>  <span class="hljs-number">950.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7902</span> <span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> ANALYST   <span class="hljs-operator">|</span> <span class="hljs-number">7566</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-12</span><span class="hljs-number">-03</span> <span class="hljs-operator">|</span> <span class="hljs-number">3000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7934</span> <span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> CLERK     <span class="hljs-operator">|</span> <span class="hljs-number">7782</span> <span class="hljs-operator">|</span> <span class="hljs-number">1982</span><span class="hljs-number">-01</span><span class="hljs-number">-23</span> <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-----------+------+------------+---------+---------+----</span><br></code></pre></td></tr></table></figure><h3 id="12-2-视图在开发中的作用"><a href="#12-2-视图在开发中的作用" class="headerlink" title="12.2 视图在开发中的作用"></a>12.2 视图在开发中的作用</h3><ul><li><p>假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。<br>每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？</p><pre><code>    可以把这条复杂的SQL语句以视图对象的形式新建。    在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。    并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要    修改视图对象所映射的SQL语句。</code></pre></li><li><p>我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。</p></li><li><p>可以对视图进行增删改查等操作。<strong>视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。</strong></p></li></ul><h2 id="13-数据库三范式"><a href="#13-数据库三范式" class="headerlink" title="13. 数据库三范式"></a>13. 数据库三范式</h2><p><strong>第一范式</strong>：要求任何一张表必须有主键，每一个字段原子性不可再分。</p><p><strong>第二范式</strong>：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，<br>不要产生部分依赖。</p><p><strong>第三范式</strong>：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，<br>不要产生传递依赖。</p><ul><li>声明：三范式是面试官经常问的，所以一定要熟记在心！</li></ul><p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</p><h3 id="13-1-第一范式"><a href="#13-1-第一范式" class="headerlink" title="13.1 第一范式"></a>13.1 第一范式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">学生编号 学生姓名 联系方式<br><span class="hljs-comment">------------------------------------------</span><br><span class="hljs-number">1001</span>张三zs<span class="hljs-variable">@gmail</span>.com,<span class="hljs-number">1359999999</span><br><span class="hljs-number">1002</span>李四ls<span class="hljs-variable">@gmail</span>.com,<span class="hljs-number">13699999999</span><br><span class="hljs-number">1001</span>王五ww<span class="hljs-variable">@163</span>.net,<span class="hljs-number">13488888888</span><br><br>以上是学生表，满足第一范式吗？<br>不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话<br><br>学生编号(pk) 学生姓名邮箱地址联系电话<br><span class="hljs-comment">----------------------------------------------------</span><br><span class="hljs-number">1001</span>张三zs<span class="hljs-variable">@gmail</span>.com<span class="hljs-number">1359999999</span><br><span class="hljs-number">1002</span>李四ls<span class="hljs-variable">@gmail</span>.com<span class="hljs-number">13699999999</span><br><span class="hljs-number">1003</span>王五ww<span class="hljs-variable">@163</span>.net<span class="hljs-number">13488888888</span><br></code></pre></td></tr></table></figure><h3 id="13-2-第二范式"><a href="#13-2-第二范式" class="headerlink" title="13.2 第二范式"></a>13.2 第二范式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs sql">学生编号 学生姓名 教师编号 教师姓名<br><span class="hljs-comment">----------------------------------------------------</span><br><span class="hljs-number">1001</span>张三<span class="hljs-number">001</span>王老师<br><span class="hljs-number">1002</span>李四<span class="hljs-number">002</span>赵老师<br><span class="hljs-number">1003</span>王五<span class="hljs-number">001</span>王老师<br><span class="hljs-number">1001</span>张三<span class="hljs-number">002</span>赵老师<br>这张表描述了学生和老师的关系：（<span class="hljs-number">1</span>个学生可能有多个老师，<span class="hljs-number">1</span>个老师有多个学生）<br>这是非常典型的：多对多关系！<br><br>分析以上的表是否满足第一范式？<br>不满足第一范式。<br><br>怎么满足第一范式呢？修改<br><br>学生编号<span class="hljs-operator">+</span>教师编号(pk)学生姓名  教师姓名<br><span class="hljs-comment">----------------------------------------------------</span><br><span class="hljs-number">1001</span><span class="hljs-number">001</span>张三王老师<br><span class="hljs-number">1002</span><span class="hljs-number">002</span>李四赵老师<br><span class="hljs-number">1003</span><span class="hljs-number">001</span>王五王老师<br><span class="hljs-number">1001</span><span class="hljs-number">002</span>张三赵老师<br><br>学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号<span class="hljs-operator">+</span>教师编号）<br>经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？<br>不满足，“张三”依赖<span class="hljs-number">1001</span>，“王老师”依赖<span class="hljs-number">001</span>，显然产生了部分依赖。<br>产生部分依赖有什么缺点？<br>数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。<br><br>为了让以上的表满足第二范式，你需要这样设计：<br>使用三张表来表示多对多的关系！！！！<br>学生表<br>学生编号(pk)学生名字<br><span class="hljs-comment">------------------------------------</span><br><span class="hljs-number">1001</span>张三<br><span class="hljs-number">1002</span>李四<br><span class="hljs-number">1003</span>王五<br><br>教师表<br>教师编号(pk)教师姓名<br><span class="hljs-comment">--------------------------------------</span><br><span class="hljs-number">001</span>王老师<br><span class="hljs-number">002</span>赵老师<br><br>学生教师关系表<br>id(pk)学生编号(fk)教师编号(fk)<br><span class="hljs-comment">------------------------------------------------------</span><br><span class="hljs-number">1</span><span class="hljs-number">1001</span><span class="hljs-number">001</span><br><span class="hljs-number">2</span><span class="hljs-number">1002</span><span class="hljs-number">002</span><br><span class="hljs-number">3</span><span class="hljs-number">1003</span><span class="hljs-number">001</span><br><span class="hljs-number">4</span><span class="hljs-number">1001</span><span class="hljs-number">002</span><br></code></pre></td></tr></table></figure><ul><li>多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！</li></ul><h3 id="13-3-第三范式"><a href="#13-3-第三范式" class="headerlink" title="13.3 第三范式"></a>13.3 第三范式</h3><p>​    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs sql">学生编号（PK） 学生姓名  班级编号  班级名称<br><span class="hljs-comment">---------------------------------------------------------</span><br><br>​<span class="hljs-number">1001</span>张三<span class="hljs-number">01</span>一年一班<br>​<span class="hljs-number">1002</span>李四<span class="hljs-number">02</span>一年二班<br>​<span class="hljs-number">1003</span>王五<span class="hljs-number">03</span>一年三班<br>​<span class="hljs-number">1004</span>赵六<span class="hljs-number">03</span>一年三班<br><br>以上表的设计是描述：班级和学生的关系。很显然是<span class="hljs-number">1</span>对多关系！<br>一个教室中有多个学生。<br><br>分析以上表是否满足第一范式？<br>满足第一范式，有主键。<br><br>分析以上表是否满足第二范式？<br>满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。<br><br>分析以上表是否满足第三范式？<br>第三范式要求：不要产生传递依赖！<br>一年一班依赖<span class="hljs-number">01</span>，<span class="hljs-number">01</span>依赖<span class="hljs-number">1001</span>，产生了传递依赖。<br>不符合第三范式的要求。产生了数据的冗余。<br><br>那么应该怎么设计一对多呢？<br><br>班级表：一<br>班级编号(pk)班级名称<br><span class="hljs-comment">----------------------------------------</span><br><span class="hljs-number">01</span>一年一班<br><span class="hljs-number">02</span>一年二班<br><span class="hljs-number">03</span>一年三班<br><br>学生表：多<br><br>学生编号（PK） 学生姓名 班级编号(fk)<br><span class="hljs-comment">-------------------------------------------</span><br><span class="hljs-number">1001</span>张三<span class="hljs-number">01</span><br><span class="hljs-number">1002</span>李四<span class="hljs-number">02</span><br><span class="hljs-number">1003</span>王五<span class="hljs-number">03</span><br><span class="hljs-number">1004</span>赵六<span class="hljs-number">03</span><br></code></pre></td></tr></table></figure><ul><li>一对多，两张表，多的表加外键！！！！！！！！！！！！</li></ul><p><strong>关于三范式的实际使用</strong></p><p>数据库设计三范式是理论上的，实践和理论有的时候有偏差。</p><p>最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。</p><p>因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）</p><p>有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。</p><p>面试的时候把这句话说上：他就不会认为你是初级程序员了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>mySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie树</title>
    <link href="/2022/04/15/Trie%E6%A0%91/"/>
    <url>/2022/04/15/Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>链表，Trie树或是堆，他们的基本单元都是一个个节点连接构成的，可以成为“链”式结构。即，可以<strong>用数组模拟链</strong>。</p><p><u>回想一下：</u></p><p>链表中会使用到这几个数组来模拟：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头指向的节点，e[]存储节点的值，ne[]存储节点的next指针(下一个节点的位置)，idx表示当前用到了哪个节点</span><br>head, e[N], ne[N], idx;<br></code></pre></td></tr></table></figure><p>head 表示头节点指针，一开始初始化指向 -1，每次插入x的操作 <code>idx++;</code>。利用 <code>idx</code> 联系结构体本身的值和 <code>next</code> 指针，因此 <code>e[idx]</code> 可以表示节点的值，<code>ne[idx]</code> 可以作为<code>next</code>指针，存储下一个节点的位置。同理双链表也是如此。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//单链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_to_head</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] =  x;<br>    ne[idx] = head;<br>    head = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">//双链表</span><br><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,  <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br><br>    l[idx] = a;<br>    r[idx] = r[a];<br><br>    l[r[a]] = idx;<br>    r[a] = idx;<br>    <br>    idx ++ ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>Trie树</strong> 的作用：<strong>快速存储</strong> 和 <strong>查找</strong> 字符串集合 的数据结构。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220411163913.png" alt=""></p><p>Trie树一般有两个操作：</p><ul><li>插入：向集合中插入一个字符串</li><li>查询：询问一个字符串在集合中出现了多少次</li></ul><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>Trie树中有个二维数组 <code>son[N][26]</code>，<strong>表示当前节点的儿子的信息</strong>，如果当前节点没有儿子的话，可以等于 <code>++idx</code>。Trie树本质上是一颗多叉树，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。</p><p>比如：</p><ul><li><p><code>son[0][0] = 1</code> ：表示0节点(当前位置是 根)的子节点的值是0，子节点的坐标是 1节点</p></li><li><p><code>son[1][1] = 2</code> ：表示1节点(当前位置是 1)的子节点的值是1，子节点的坐标是 2节点</p></li></ul><p>所以说，这里的<strong><code>son[p][u] = x</code> 是描述当前节点的儿子节点的值 $u$ 和坐标 $x$，也记录了本父节点的坐标 $p$</strong>（好神奇!）。</p><p><code>son[M][N]</code> 中的 M 是 Trie 树总节点数上限。一共 N 个数，每个数 31 位，从根开始往下存，要 31 个结点，M = 31 * N。</p><p>N 是儿子节点的可能性有多少。模板题中是字符串，而题目本身又限定了均为小写字母所以只有26种可能性。比如是存二进制数，那下一位只有0或者1两种情况，所以应为2。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220411163836.png" alt=""></p><p><strong>插入操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 从根结点开始遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">// 存映射 类似&#x27;c&#x27; - &#x27;a&#x27;，</span><br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;  <span class="hljs-comment">//没有该子结点就创建一个, 存入本节点，子节点的值，子节点的坐标 先+1</span><br>        p = son[p][u];  <span class="hljs-comment">// 移向下一个节点</span><br>    &#125;<br>    <br>    cnt[p] ++ ;  <span class="hljs-comment">// 以当前节点结尾的点 标记一下</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询字符串是否存在，需要满足两个条件：遍历字符串，需要每一个字符都能找到；还有就是结尾节点要有标记，以防止只是出现局部这种反例，如第一张图举例所示。所以 $cnt[]$ 就是标记字符串尾节点的，<strong>表示以这个节点结尾的字符串的数量</strong>（可能找到的是存在字符串的子串，这种情况就直接是0）</p><p><strong>查询操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 从根节点开始找</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 没有这个字符，字符串就不存在</span><br>        p = son[p][u];  <span class="hljs-comment">// 移向下一个节点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cnt[p];  <span class="hljs-comment">// 返回以这个节点结尾的字符串的数量(可能找到的是存在字符串的子串，这种情况就直接是0)</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-835-Trie字符串统计"><a href="#1-AcWing-835-Trie字符串统计" class="headerlink" title="1. AcWing 835. Trie字符串统计"></a><a href="https://www.acwing.com/problem/content/837/">1. AcWing 835. Trie字符串统计</a></h3><p>维护一个字符串集合，支持两种操作：</p><ol><li><code>I x</code> 向集合中插入一个字符串 x；</li><li><code>Q x</code> 询问一个字符串在集合中出现了多少次。</li></ol><p>共有 N 个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。</p><blockquote><p>模板题</p></blockquote><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-keyword">char</span> str[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    <br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 因为有好多测试点会输一些空格，用字符串可以有效避免这些无效字符，所以即使用字符，也用数组存好一点</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, op, str);  <span class="hljs-comment">// scanf(“%s”)会跳过空格、回车，而且测试点会多出一下空格什么的</span><br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) insert(str);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, query(str));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><p>字符串是 “” 号赋值的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">例:<br><span class="hljs-keyword">char</span> a[]=<span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//长度为6  最后加了一个 &#x27;\0&#x27;</span><br>或<br><span class="hljs-keyword">char</span> a[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>字符串会自动的在最后加一个 <code>&#39;\0&#39;</code> 的结束符</li></ul><p>字符数组是一个一个的赋值 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">例： <span class="hljs-keyword">char</span> a[<span class="hljs-number">5</span>]=&#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>&#125;;  <span class="hljs-comment">//长度为5 不会自动的加 &#x27;\0&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>%s它要求参数是一个指针！！！即： 要求 char * 类型</p><p>%s 字符串的格式输出, 它是一个接一个挨着输出, 直到遇见’\0’才中止</p></blockquote><p><code>char a1[] = “abc”;</code> 下面的结果分别是什么？<br>输出相同，都是数组元素的第一个地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cout</span> &lt;&lt; &amp;a1[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><code>char* pa = “abc”;</code> 下面的结果分别是什么？</p><p>pa是指针，就是指向首个元素的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cout</span> &lt;&lt; &amp;pa &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出pa在栈上的地址</span><br><span class="hljs-built_in">cout</span> &lt;&lt; &amp;pa[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 首地址。</span><br><span class="hljs-built_in">cout</span> &lt;&lt; pa &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 首地址。</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>下面的结果，违反直觉，按道理第5，6行应该输出地址。但是却输出指向的字符串。这有一定的合理性，我们打印char指针，往往是要看指向的内容，而不是要看地址是多少。而且cout很容易做到，只要遇到 <code>\0</code> 就结束。那么问题来了，我想看地址怎么办？使用int强制转化为地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a1[] = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">char</span>* pa = <span class="hljs-string">&quot;def&quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="hljs-built_in">endl</span>;          <span class="hljs-comment">// 输出abc</span><br><span class="hljs-built_in">cout</span> &lt;&lt; pa &lt;&lt; <span class="hljs-built_in">endl</span>;          <span class="hljs-comment">// 输出def</span><br><span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">int</span>)a1 &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-comment">// 输出a1地址</span><br><span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">int</span>)pa &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-comment">// 输出pa地址</span><br></code></pre></td></tr></table></figure><p>除此之外，还可以用 $<em> $ <em>*来获取单个字符</em></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span>* pa = abcde;<br><span class="hljs-built_in">cout</span> &lt;&lt; *pa &lt;&lt; <span class="hljs-built_in">endl</span>;          <span class="hljs-comment">// 输出a</span><br><span class="hljs-built_in">cout</span> &lt;&lt; *(pa+<span class="hljs-number">2</span>) &lt;&lt;<span class="hljs-built_in">endl</span>;       <span class="hljs-comment">// 输出c</span><br></code></pre></td></tr></table></figure>          </div><h3 id="2-AcWing-143-最大异或对"><a href="#2-AcWing-143-最大异或对" class="headerlink" title="2. AcWing 143. 最大异或对"></a>2. AcWing 143. 最大异或对</h3><p>给定的 $a_1, a_2, …,a_n$ 中选出两个进行 xor（异或）运算，得到的结果最大是多少？</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>这道题的启示是：字典树不单单可以高效存储和查找字符串集合,还可以存储二进制数字</strong></p><p>思路：将每个数以二进制方式存入字典树,找的时候从最高位去找有无该位的异(1找0，0找1).</p><p>想一下暴力做法：穷举所有的数对, 找到异或运算的最大值 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 二重循环</span><br>res = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to n<br>    <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to i<br>        res = max(res, a[i] ^ a[j])<br></code></pre></td></tr></table></figure><p>优化暴力：将暴力做法的内层循环用 $O(1)$ 时间来实现</p><p>相当于只有一层循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单重循环</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to n<br>    insert(a[i])<br>    res = max(res, a[i] ^ query(a[i]))<br></code></pre></td></tr></table></figure><p><strong>如何把内层循环用 O(1) 时间来实现 ?</strong></p><ul><li>实现一个 $query()$ 函数，使得 <code>query(a[i])</code> 的值一定是 <code>a[1..i]</code> 中与 <code>a[i]</code> 异或运算结果最大的。</li></ul><p><strong>如何使得一个数与 <code>a[i]</code> 异或最大？</strong></p><ul><li><strong><code>query(a[i])</code> 尽可能找二进制高位上与 <code>a[i]</code> 相反的元素, 于是在该位上异或结果尽可能为 1。一定是从高位往低处找，这个数才能尽可能的大。</strong>举个例子：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220413100349.png" alt=""></p><ul><li>找和 2(010) 异或最大的：先找 0 的相反 1(有)，再找 1 的相反 0(有)，继续找 0 的相反 1(有)。那就找到了，和 2(010) 异或最大的是 5(101)</li><li>找和 6(110) 异或最大的：先找 1 的相反 0(有)，再找 1 的相反 0(没有，此时因为没有0的选择，只能选差一点的选择，就是 1)，继续找 0 的相反 1(有)。所以就找到了，和 6(110) 异或最大的是 3(011)</li></ul><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">31</span> * N;<br><br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> son[M][<span class="hljs-number">2</span>], idx;  <span class="hljs-comment">// N 是儿子节点的可能性有多少。存二进制数，那下一位只有0或者1两种情况，所以应为2。</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 取X的第i位的二进制数是什么</span><br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// query(x)查找的和x值的最大的异或值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )  <span class="hljs-comment">// 从最大位开始找</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> u = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(son[p][!u])  <span class="hljs-comment">// 如果当前层有对应的 “异”数(相反的数), 就选它</span><br>        &#123;<br>            p = son[p][!u];<br>            res = (res &lt;&lt; <span class="hljs-number">1</span>) + !u;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 没有相反的就只能将就选一样的...</span><br>        &#123;<br>            p = son[p][u];<br>            res = (res &lt;&lt; <span class="hljs-number">1</span>) + u;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>        insert(a[i]);<br>        <br>        res = max(res, a[i] ^ query(a[i]));  <span class="hljs-comment">// query(a[i])查找的是a[i]值的最大异或值</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL</title>
    <link href="/2022/04/13/C-STL/"/>
    <url>/2022/04/13/C-STL/</url>
    
    <content type="html"><![CDATA[<h1 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p><code>include&lt;vector&gt;</code></p></li><li><p>定义：vector，变长数组，倍增的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span> &lt; <span class="hljs-keyword">typename</span> &gt; v;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-built_in">vector</span> &lt; <span class="hljs-keyword">typename</span> &gt; arrayname[size];<br><br>&gt; 系统为某一程序分配空间时，所需时间，与空间大小无关，与申请次数有关。<br><br><span class="hljs-built_in">vector</span> 优化的目标是减少申请次数，可以浪费空间。倍增的思想是：每次数组长度不够时，就会把新数组长度设为旧的*<span class="hljs-number">2</span>，然后 copy到新数组。比如说申请一个 $n=<span class="hljs-number">10</span>^<span class="hljs-number">6</span>$ 的数组，大概 copy $<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span>+<span class="hljs-number">8</span>+...+<span class="hljs-number">5</span> \times <span class="hljs-number">10</span>^<span class="hljs-number">5</span> = <span class="hljs-number">10</span>^<span class="hljs-number">6</span>$ 。所以可以看成，平均情况下每插入一个数的时间复杂度是 $o(<span class="hljs-number">1</span>)$ 的。申请空间的次数是 $log_n$。<br><br><br><br>### 访问<br><br><span class="hljs-number">1.</span> 通过下标访问：`v[ i ]`<br><br><span class="hljs-number">2.</span> 通过迭代器访问：<br><br>   ```c++<br>   <span class="hljs-built_in">vector</span>&lt; <span class="hljs-keyword">typename</span> &gt; ::  iterator it<br></code></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>( it = b.begin(); it!=b.end(); it++)<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="vector-常用函数"><a href="#vector-常用函数" class="headerlink" title="vector 常用函数"></a>vector 常用函数</h3></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">size()  返回元素个数<br>empty()  返回是否为空<br>clear()  清空<br>front()/back()  返回第一个/最后一个<br>push_back()/pop_back()  尾部添加/删除<br>begin()/end()   迭代器：第<span class="hljs-number">0</span>个数/最后一个数的后面一个数<br>[]  随机寻址<br>支持比较运算，按字典序<br></code></pre></td></tr></table></figure><p>1：32：29</p>]]></content>
    
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2022/04/13/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2022/04/13/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP算法-思路"><a href="#KMP算法-思路" class="headerlink" title="KMP算法 思路"></a>KMP算法 思路</h2><p>KMP 是一个字符串匹配算法。使用场景是这样的：给定一个主串 s，以及一个子串 p。子串 p 在主串 s 中多次作为子串出现。求出子串 p 在 s 中所有出现的位置的起始下标。（n为子串p的长度，m为主串s串的长度）</p><p>读完这个题，我们首先能想到的方式就是一个暴力的动作hh。就是两个指针扫就完了。暴力的做法就是对于每一个 i，都去和 j 一起往后扫描看二者是否相等，不等的话就继续下一个 i（把 p串 往后移一位）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[i + j - <span class="hljs-number">1</span>] != p[j])<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>KMP 算法是对暴力的这种一一对比的方法进行了优化，时间复杂度由 $O(n^2)$ 降低为 $O(m + n)$。</p><p><strong>KMP 核心思想</strong>：在每次匹配不相等时，不是把 p串 往后移一位，而是把 p串 往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找 Next[ ] 数组确定的。</p><p>即，KMP 算法分为两步：</p><ol><li>计算 Next 数组（针对子串 p 而言）</li><li>子串 p 和 主串 s 进行匹配</li></ol><h3 id="Next-数组的性质"><a href="#Next-数组的性质" class="headerlink" title="Next 数组的性质"></a>Next 数组的性质</h3><p>首先要清楚几个定义：</p><ul><li>“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。</li><li><p>“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。</p></li><li><p><strong>$Next[i]$ 表示子串 p 中以 j (下标从1开始) 结尾的非平凡后缀能匹配 p 的前缀的最大长度。</strong> (或者说 $j$ 是 p 的每个最长公共前后缀中的前缀的尾坐标)</p><p>即 $Next[i]=j$ 表示：<code>p[1, j] = p[i - j + 1, i]</code></p></li></ul><p><strong>Next 数组的性质：</strong></p><p><code>Next[i] = j</code>：<code>p[1, j] = p[i - j + 1, i]</code></p><p><img src="https://cdn.acwing.com/media/article/image/2020/04/28/6828_2f9f9aa689-KMP_1.png" alt=""></p><p> <code>Next[j] = k</code>：<code>p[1, k] = p[j - k + 1, j]</code></p><p><img src="https://cdn.acwing.com/media/article/image/2020/04/28/6828_333abd1289-KMP_2.png" alt=""></p><p>就是说，若以 i 结尾的非平凡后缀能匹配 p 的前缀的最大长度为 <code>Next[i]</code>，那么它能匹配的次长前缀长度为 <code>Next[Next[i]]</code>，以此类推，<code>Next[Next[Next[i]]]⋯</code> 直至匹配长度为 0 为止。</p><p>这是一条很重要的性质，是KMP算法的关键，它与子串 p 在主串 p 中发生失配时的下一步操作有关。</p><h3 id="KMP-匹配过程"><a href="#KMP-匹配过程" class="headerlink" title="KMP 匹配过程"></a>KMP 匹配过程</h3><p>下面模拟 $Next[ ]$ 在匹配过程中的作用。</p><p>已知主串 s 和子串 p。且 p 的 $Next[]$ 数组已经求出来了，当前主串 s 匹配到下标 i−1 位置，子串 p 匹配到下标 j 位置，即满足 $S[i−j:i−1]==P[1:j]$，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220404112803.png" alt=""></p><ol><li><p>$S[i]==P[j+1]$，则 j 后移一位，表示这一位匹配成功.</p><ul><li><p>此时如果 j 到达了 p 串的末尾，说明 p 在 s 中出现了，在 s 中的起始下标为  $i−|P|+1$。</p><p>Note：j 接下来不是回到 p串 起始处重新在 s 中找下一个位置，而是 继续从 $j = Next[j]$ 的位置继续匹配。</p><p>举个栗子，比如子串是 $abcdabcd$，主串是 $abcdabcdabfg…$。在匹配到 $s[8] == p[7 + 1]$ 的时候，j 后移一位，刚好 $j == m$，找到一个匹配的输出。此时 j 无需从 p 的起始再开始，而是从 $j = Next[8] = 4$ 开始继续看二者的下一位比较即可。</p></li><li><p>如果还没到，继续看 s 的下一位，即 <code>i ++</code> </p></li></ul></li><li>$S[i]≠P[j+1]$，发生失配，此时不需要从头开始匹配。因为 s 和 p 一路匹配过来的，所以 3串 和 2 串是相同的。通过 Next 数组知道 1串 和 2串 是相同的，所以可以推出 1串和 3串 是相同的。所以下一次匹配完全不用从 s 串的下一位开始，直接从相同缀的下一位开始匹配就行了。如下图所示：</li></ol><p><img src="https://cdn.acwing.com/media/article/image/2020/04/28/6828_3c59de6e89-KMP_4.png" alt=""></p><ul><li>如何用代码描述子串 p 移动的过程呢？</li></ul><p>我理解：大家所说的 <strong>失配后 j 回退的过程，我将其看作将 p 向后移动的过程</strong>。也就是说这两个动作是相反的。</p><p>或者说，p 向后移动的过程，看成 j 回退的过程，即 令 $j=Next[j]$。然后我们只需要再比较 $S[i]$ 与 $P[j+1]$ 是否匹配即可。如果不匹配就需要不断回退 $j=Next[j]$，其实就是不断用 p 中已经能与 s 中以  $i−1$ 结尾的后缀匹配的前缀，减少中间多余匹配过程，在不断失配的过程中，所使用的  p 的前缀长度递减，直至为 0。如果经过某次 j 的回退，满足了 $S[i]==P[j+1]$，那么  j 就可以后移了。图中表现的是，经过一次回退，就能成功匹配的情况（都是蓝色的小方块）。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220404153407.png" alt=""></p><p>以上就是 KMP 算法的匹配过程，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// n为子串p的长度，m为主串s串的长度 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = Next[j]; <span class="hljs-comment">// 失配j就不断回退</span><br>    <span class="hljs-comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span><br>    <span class="hljs-comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span><br>    <br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j++; <span class="hljs-comment">//当前元素匹配，j移向p串下一位</span><br>    <span class="hljs-keyword">if</span> (j == n)  <span class="hljs-comment">// p在s中完整出现</span><br>    &#123;<br>        <span class="hljs-comment">//匹配成功，进行相关操作</span><br>        j = Next[j];  <span class="hljs-comment">//继续匹配下一个子串</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Next-数组求解"><a href="#Next-数组求解" class="headerlink" title="Next 数组求解"></a>Next 数组求解</h3><p>理解了上述匹配过程，$Next[ ]$ 的求解就不难理解了。我们可以把 $Next[ ]$ 的求解过程看成是两个相同的串 p 匹配的过程。</p><p>首先对于 p 串，显然有 $Next[1]=0$（因为只考虑非平凡前/后缀），然后两个指针  $i=2,j=0$ 开始，考虑 $P[i]$ 与 $P[j+1]$ 是否匹配，如果不匹配，那么  $j=Next[j]$ 不断回退，直到回退到匹配长度为 0 或者某一个 j 能满足 $P[i]==P[j+1];$ 如果  $P[i]==P[j+1]$ ，j 后移，说明以 p 中以 i 结尾的非平凡后缀能匹配 p 的前缀的最大长度为  j，因此 $Next[i]=j$。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220403111436.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>&#123;<br>    <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="hljs-number">1</span>]) j = Next[j];<br><br>    <span class="hljs-keyword">if</span>(p[i] == p[j+<span class="hljs-number">1</span>]) j++;<br>    Next[i] = j;  <span class="hljs-comment">// 更新Next</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实 KMP的核心就是匹配的时候不必每次都从下一个 i 开始，只要从后缀（最长的公共串）开始继续匹配即可。而 Next 数组记录了每个 i 对应的最长公共前后缀的长度(也可以说是前缀的尾坐标)。</p><p>KMP 模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">char</span> s[N], p[N];<br><span class="hljs-keyword">int</span> ne[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// p+1，s+1是让读入之后字符串的下标会从1开始。也可以写成scanf(“%s”, p + 1)</span><br>    <br>    <span class="hljs-comment">// 求 Next 数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">// 不等于</span><br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <br>        <span class="hljs-comment">// 等于</span><br>        <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        ne[i] = j;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m ; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <br>        <span class="hljs-keyword">if</span>(s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        <span class="hljs-keyword">if</span>(j == n)<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; i - n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调队列</title>
    <link href="/2022/04/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2022/04/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="单调队列思路"><a href="#单调队列思路" class="headerlink" title="单调队列思路"></a>单调队列思路</h1><p>单调队列可以用来解决滑动窗口问题。</p><p>举个例子，从数组中第一个元素开始遍历，由于窗口的大小是<code>3</code>，因此当遍历到第三个元素时，窗口就形成了。之后，继续遍历元素时，为了保持窗口的大小为3，左侧元素就需要从窗口中剔除。这样使得窗口一直在向右移动，直到考察到最后一个元素结束，这就是所谓的滑动窗口。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424142653.png" alt="image-20220424142349088" style="zoom:60%;" /></p><p>解题思路（以最小值为例）：</p><p>由于我们需要求出的是滑动窗口的最小值。</p><ul><li><p>如果当前的滑动窗口中有两个下标 <code>i</code> 和 <code>j</code> ，其中<code>i</code>在<code>j</code>的左侧（<code>i</code>&lt;<code>j</code>），并且<code>i</code>对应的元素不大于j对应的元素（<code>a[i]≤a[j]</code>），则：</p><p>当滑动窗口向右移动时，只要 <code>i</code> 还在窗口中，那么 <code>j</code> 一定也还在窗口中。这是由于 <code>i</code> 在 <code>j</code> 的左侧所保证的。</p><p><strong>因此，由于 <code>a[j]</code> 的存在，<code>a[i]</code> 一定不会是滑动窗口中的最大值了，我们可以将<code>a[i]</code>永久地移除。</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424151349.png" alt=""></p><ul><li><p>因此我们可以使用一个<strong>队列</strong>存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组<code>a[]</code>中对应的值是严格单调递增的。</p></li><li><p>当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。</p></li><li><p>为了保持<strong>队列的单调性的性质</strong>，我们会不断地将新的元素与队尾的元素相比较，如果新元素小于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。</p></li><li><p>由于队列中下标对应的元素是严格单调递增的，因此此时队首下标对应的元素就是滑动窗口中的最大值。</p></li><li><p>窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。</p></li></ul><p>滑动窗口思路：</p><ol><li>队首已经出窗口：<code>if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ;</code></li><li>解决队尾与当前元素 <code>a[i]</code> 不满足单调性的问题：<code>while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;</code></li><li>将当前元素下标加入队尾：<code>q[++ tt] = i;</code></li><li>如果满足条件则输出结果：<code>if(i + 1&gt; = k) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;</code></li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-AcWing-154-滑动窗口"><a href="#1-AcWing-154-滑动窗口" class="headerlink" title="1. AcWing 154. 滑动窗口"></a><a href="https://www.acwing.com/problem/content/156/">1. AcWing 154. 滑动窗口</a></h2><p>模板题。</p><p>求滑动窗口内的最小值和最大值。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-keyword">int</span> a[N], q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) hh ++ ;   <span class="hljs-comment">// 若队首出窗口，hh加1</span><br><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;  <span class="hljs-comment">// 若队尾不单调，tt减1</span><br>        q[ ++ tt] = i;  <span class="hljs-comment">// 下标加到队尾</span><br><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);  <span class="hljs-comment">// 输出结果</span><br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) hh ++ ;<br><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt -- ;<br>        q[ ++ tt] = i;<br><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2022/04/09/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2022/04/09/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈思路"><a href="#单调栈思路" class="headerlink" title="单调栈思路"></a>单调栈思路</h1><p><strong>单调栈：在一个序列中，每个数左边/右边离它最近的”比它小/大“大的数在哪？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220423105624.png" style="zoom: 67%;" /></p><p>首先想到的暴力做法就是双指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j; j -- )<br>        <span class="hljs-keyword">if</span>(a[i] &lt; a[j]) <br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; a[j] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>可以使用单调栈进行优化。为什么会想到单调栈呢？</p><p>双指针暴力的思路是确定一个点，找另一个点。这个点：</p><ol><li>刚好是往回找另一个点</li><li>往回找一个点是第一个比这个点小的，其余的数，对后面用不到（就可以删掉）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220423105637.png" alt=""></p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220423105643.png" alt=""></p><p>流程：</p><ol><li>$stk[tt] &gt;= x$ 的话，出栈，一直出栈，直到找到栈顶 $stk[tt] &lt; x$</li><li>此时，这个数一定是第一个比它小的数（当然也可能栈空），判断栈的情况<ol><li>栈空，栈顶就是0，说明没有比它小的值，输出 $-1$</li><li>非空，输出栈顶</li></ol></li><li>把这个数 $x$ 存入栈</li></ol><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> stk[N], tt;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;  <span class="hljs-comment">// 如果栈顶元素大于当前待入栈元素，则出栈</span><br>        <span class="hljs-keyword">if</span> (!tt) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 &quot;</span>);  <span class="hljs-comment">// 如果栈空，则没有比该元素小的值。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, stk[tt]);  <span class="hljs-comment">// 栈顶元素就是左侧第一个比它小的元素。</span><br>        stk[ ++ tt] = x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟队列</title>
    <link href="/2022/04/07/%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"/>
    <url>/2022/04/07/%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟队列思路"><a href="#模拟队列思路" class="headerlink" title="模拟队列思路"></a>模拟队列思路</h1><p>用数组模拟队列：</p><ul><li>用 $hh$ 表示队头的索引，$tt$ 表示队尾的索引。初始时，<code>hh = 0, tt = -1</code>。表示没有元素，队列为空。</li><li><code>push x</code>：队尾所在索引往后移动一格，然后放入x。<code>q[ ++ top] = x;</code>。</li><li><code>pop</code>：队头 hh 往后移动一格。<code>hh ++ ;</code></li><li><code>empty</code>：<code>hh &gt; tt ? “YES” : “NO”</code>。$hh&lt;=tt$ 时，队列有元素。</li><li><code>query</code>：返回队头元素。<code>q[hh];</code></li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(n -- )<br>    &#123;<br>        <span class="hljs-built_in">string</span> op;<br>        <span class="hljs-keyword">int</span> x;<br>        <br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            q[ ++ tt] = x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;empty&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(hh &lt;= tt) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;query&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; q[hh] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;pop&quot;</span>) hh ++ ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Neural Architecture Search with reinforcement learning</title>
    <link href="/2022/04/05/Neural%20Architecture%20Search%20with%20reinforcement%20learning/"/>
    <url>/2022/04/05/Neural%20Architecture%20Search%20with%20reinforcement%20learning/</url>
    
    <content type="html"><![CDATA[<h1 id="Neural-Architecture-Search-with-reinforcement-learning"><a href="#Neural-Architecture-Search-with-reinforcement-learning" class="headerlink" title="Neural Architecture Search with reinforcement learning"></a>Neural Architecture Search with reinforcement learning</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>超参数：指的是搭建神经网络之前需要手动设置的一些数值。</p><ul><li>神经网络结构超参数：比如卷积层数，卷积核数量，卷积核大小…</li><li>优化算法超参数：SGD/Adam等等，学习率，batch大小，epoches的数量…</li></ul><p>神经结构搜索的早期方法主要是基于强化学习或进化算法，指导神经网络的搜索。大体的过程如图中的早期NAS架构所示，首先定义好搜索空间，通过搜索策略采样得到一个网络结构，进行性能评估并反馈给搜索策略，重复上述过程，直至得到一个表现最佳的神经网络结构。近年来，基于权重共享(weight-sharing)的结构搜索方法兴起，在这类方法中，搜索策略和性能评估是高度相关的。于是，现阶段的NAS架构主要是在搜索空间定义好的基础上，进行结构搜索与优化，继而得到性能最优的网络结构。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405184326.png" style="zoom: 80%;" /></p><p>NAS：寻找最优的网络结构使得验证集准确率最大化。</p><h3 id="搜索空间-search-space"><a href="#搜索空间-search-space" class="headerlink" title="搜索空间 search space"></a>搜索空间 search space</h3><p>Search Space：包含所有可能的结构，如：卷积，池化，跳跃连接等等。需要先指定搜索空间，然后做搜索。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405185525.png" style="zoom: 33%;" /></p><p>输出每一层的结果</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405175857.png" style="zoom: 33%;" /></p><h3 id="搜索策略-search-strategy"><a href="#搜索策略-search-strategy" class="headerlink" title="搜索策略 search strategy"></a>搜索策略 search strategy</h3><p>搜索策略(search strategy)：寻找到一个神经网络，并能够最大化性能指标，例如在验证集上的准确率。</p><p>现阶段的搜索策略主要包含5种方法，分别为随机搜索、贝叶斯优化、进化算法、强化学习和基于梯度的方法。从历史上看，前4种搜索方式在一定程度上实现了神经结构搜索，但无法满足大多数研究人员的要求。于是，基于梯度的方法是目前的主流方向，革命性地将离散的结构搜索方式建模为一种连续松弛的搜索方式。尤其是，同以往在某个特定层固定操作相比，这种基于梯度的方法能够计算一系列操作的凸组合，灵活性更高。</p><p>下图是随机搜索的图例：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195632.png" style="zoom:33%;" /></p><h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h3><p>神经网络结构搜索的巨大计算量主要来自对神经网络的性能进行评估,很多工作都在尝试解决该问题,主要方法大致可以分为以下 4类:</p><ol><li>低置信度的预测。降低训练步数，在部分数据集上进行训练或者在分辨率更低的数据集上进行训练。</li><li>在现有预训练模型的基础上进行结构改动，并在训练时继承原模型的权重。</li><li>对学习曲线进行插值,对精度进行预测。</li><li>将搜索到的所有结构都当做某个更大的超网络结构的子结构,所有子结构都继承超网络的权重，这种方式通常称为 one-shot。</li></ol><h2 id="NAS-via-RNN-RL"><a href="#NAS-via-RNN-RL" class="headerlink" title="NAS via RNN + RL"></a>NAS via RNN + RL</h2><p>介绍一篇论文：Neural Architecture Search with reinforcement learning，ICLR 2017。主要是用了 RNN + RL 来做 NAS。</p><p>初始状态 $h_0$ 向量和初始输入 $x_0$ 向量输入到 RNN 网络里，输出一个 向量 $h_1 = tanh(W \cdot[h_0;x_0] + b)$，$h_1$ 输入到 一个 softmax 分类器。softmax分类器是指1个或多个全连接层+softmax函数。输出 $p_1$ 得到这一步任务的输出，就是几个概率值。选出最大的概率值，对应的方案就是这一步的输出。然后将结果进行 one hot 表示，得到了这一步的输出 $a_1$.</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195642.png" style="zoom: 33%;" /></p><p>接下来做 embedding，将 one hot 向量映射成一个稠密向量。embedding 的结果记作 $x_1$。通过 embedding 层的过程就是将 one hot 向量 通过一个参数矩阵，映射成一个稠密向量。参数矩阵刚开始随机初始化，之后根据训练数据进行学习。 embedding 层的参数可以在相同任务中重复利用。这是一步的过程。将上一层的隐藏状态 $h_1$ 和 $a_1$ 作为下一步的输入，就进行了下一步的动作。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195650.png" style="zoom: 33%;" /></p><p>关于 softmax 分类器：每一步的 softmax 分类器都是独立的，不可以和其他步的公用。任务不一样不应该共用softmax分类器，因为1. 每一步的任务是不同的，2. 输出的向量维度都不一样。</p><p>第一步运行完后，得到了第一层的超参数：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195659.png" style="zoom: 33%;" /></p><p>RNN 如此运行60步，每一步生成一个超参数：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195712.png" style="zoom: 33%;" /></p><p>这个东西就叫做 Controller RNN。接下来训练它，目的是让生成的CNN 结构能最大化验证集的准确率。</p><h3 id="训练-Controller-RNN"><a href="#训练-Controller-RNN" class="headerlink" title="训练 Controller RNN"></a>训练 Controller RNN</h3><p>Controller RNN 运行60步，生成20个卷积层的超参数。按照超参数来搭建一个CNN。假设只搜索卷积层的超参数，其他类型的层都手动设置。搭建好CNN后进行训练。训练后计算验证集上的准确率。用准确率来更新 Controller RNN 的参数。</p><p>整体的流程表示：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406165703.png" style="zoom:33%;" /></p><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>一个优化问题：对于目标函数 $r$，$\theta$ 是它的参数，优化目标是找 $\theta$ 使得目标函数的值最大。如果目标函数 $r$ 是 $\theta$ 的可微函数，就很容易，计算函数 $r$ 关于 $\theta$ 的梯度，然后梯度上升就好了。但是 函数 $r$ 关于 $\theta$ 不可微，就无法计算函数 $r$ 关于 $\theta$ 的梯度。</p><p>在我们的问题中，目标函数 $r$ 是 CNN 在验证集上的准确率，而优化的变量 $\theta$ 是 Controller RNN 的参数， $r$ 不是关于 $\theta$ 的函数，也就不可微。</p><p>所以想到了 强化学习，但是 RL 也有问题，需要大量的训练才能收集奖励。</p><h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>目标：改进 Controller RNN 使得验证集准确率逐渐提高。</p><p><strong>Reward</strong>：验证集准确率</p><p><strong>Policy function</strong>：Controller RNN。用 policy gradient ascent 来更新策略函数。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405180218.png"  style="zoom: 33%;" /></p><p>在前59步看不到验证集准确率，在第60步后才能看到，所以让前59步奖励都是0，第60步的奖励为准确率。</p><p>Return (aka cumulative reward)：$ u<em>t = r_t+r</em>{t+1} + … + r<em>{59} + r</em>{60}$</p><p>所以，所有 return 都相等： $u_1=u_2=…=u_60=ValAcc$</p><h3 id="REINFORCE-Algorithm"><a href="#REINFORCE-Algorithm" class="headerlink" title="REINFORCE Algorithm"></a>REINFORCE Algorithm</h3><p>近似策略梯度：</p><script type="math/tex; mode=display">\frac{\partial \log \pi\left(\mathbf{a}_{t+1} \mid\left[\mathbf{h}_{t}, \mathbf{x}_{t}\right] ; \boldsymbol{\theta}\right)}{\partial \boldsymbol{\theta}} \cdot u_{t}</script><p>用近似策略梯度更新参数 $\theta$</p><script type="math/tex; mode=display">\boldsymbol{\theta} \leftarrow \boldsymbol{\theta}+\beta \cdot \sum_{t=1}^{60} \frac{\partial \log \pi\left(\mathbf{a}_{t+1} \mid\left[\mathbf{h}_{t}, \mathbf{x}_{t}\right] ; \boldsymbol{\theta}\right)}{\partial \boldsymbol{\theta}} \cdot u_{t}</script><h3 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h3><ul><li>用  Controller RNN 生成20个卷积层的超参数（20*3=60个）。</li><li>搭建出CNN；训练CNN；在验证集计算CNN准确率；把准确率作为 reward</li><li>REINFORCE Algorithm 用 reward 来更新策略函数 Controller RNN</li><li>将这个过程重复上万次 </li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>更新一次 Controller RNN，需要从头训练 CNN，训练一次就很长时间了。想要训练好 RNN，至少得训练 10000+ 次CNN。</li><li>用 RNN 训练 CNN 找超参数，但 RNN 自己本身就有很多超参数，比如循环层的层数， $x/h$ 向量的维度。调RNN 的超参数也需要很多时间。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Papers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RLNAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟栈</title>
    <link href="/2022/04/05/%E6%A8%A1%E6%8B%9F%E6%A0%88/"/>
    <url>/2022/04/05/%E6%A8%A1%E6%8B%9F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟栈思路"><a href="#模拟栈思路" class="headerlink" title="模拟栈思路"></a>模拟栈思路</h1><p>用数组模拟栈：</p><ul><li>用 $top$ 表示栈顶所在的索引。初始时，<code>top = -1</code>。表示没有元素。</li><li><code>push x</code>：栈顶所在索引往后移动一格，然后放入x。<code>stk[ ++ top] = x;</code>。</li><li><code>pop</code>: top 往前移动一格。<code>top --;</code></li><li><code>empty</code>：top 大于等于 0 栈非空，小于 0 栈空。<code>top == -1 ? “YES” : “NO”</code></li><li><code>query</code>：返回栈顶元素。<code>stk[top]</code></li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> stk[N];<br><span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n -- )<br>    &#123;<br>        <span class="hljs-built_in">string</span> s;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br><br>        <span class="hljs-comment">//栈顶所在索引往后移动一格，然后放入x。</span><br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> a;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; a;<br>            stk[ ++ top] = a;<br>        &#125;<br><br>        <span class="hljs-comment">//往前移动一格</span><br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)<br>        &#123;<br>            top --;<br>        &#125;<br>        <span class="hljs-comment">//返回栈顶元素</span><br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; stk[top] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>        <span class="hljs-comment">//大于等于 0 栈非空，小于 0 栈空</span><br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; (top == <span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-3302-表达式求值"><a href="#1-AcWing-3302-表达式求值" class="headerlink" title="1. AcWing 3302. 表达式求值"></a><a href="https://www.acwing.com/problem/content/3305/">1. AcWing 3302. 表达式求值</a></h3><p>题目：给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>“表达式求值”问题，两个核心关键点：</p><ol><li><p>双栈，一个操作数栈，一个运算符栈；</p></li><li><p>运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：</p></li></ol><ul><li><p><strong>栈顶运算符的优先级低的话，就直接入栈新的运算符。</strong></p></li><li><p><strong>栈顶运算符的优先级高的话，必须出栈计算，才能入栈新的运算符，</strong></p><ul><li><strong>相同操作符的话，也认为栈顶的优先级高，先进行运算，再入栈新的运算符。</strong></li></ul></li></ul><p>这个方法的时间复杂度为O(n)，整个字符串只需要扫描一遍。</p><hr><p>举个例子：</p><p>开始，初始化好输入的字符串，以及操作数栈，运算符栈。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100554.png" style="zoom:70%;" /></p><p>一步步，扫描字符串，操作数一个个入栈，运算符也入栈。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100557.png" style="zoom:70%;" /></p><p>下一个操作符要入栈时，需要先比较优先级。栈内的优先级高，必须先计算，才能入栈。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100620.png" style="zoom:70%;" /></p><p>计算的过程为：(<code>eval()</code> 函数)</p><ol><li>操作数出栈，作为num2；</li><li>操作数出栈，作为num1；</li><li>运算符出栈，作为op；</li><li>根据运算符计算出结果；</li><li>将结果入栈</li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100628.png" style="zoom:70%;" /></p><p>接下来，运算符和操作数继续入栈。</p><p>下一个操作符要入栈时，继续比较与栈顶的优先级。栈内的优先级低，可以直接入栈。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100639.png" style="zoom:70%;" /></p><p>字符串继续移动。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100646.png" style="zoom:70%;" /></p><p>需要比较优先级了。栈内的优先级高，先计算（3*4=12），再入栈。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100659.png" style="zoom:67%;" /></p><p>继续将数字和操作符入栈。操作符要比较优先级，栈顶优先级低，操作符入栈。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100707.png" style="zoom:67%;" /></p><p>此时字符串扫描完毕。</p><p>开始出栈操作符，直至操作符都出栈，12 * 5 = 60, 3 + 60 = 63，所有数计算完毕。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100721.png" style="zoom:67%;" /></p><h4 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h4><ul><li><code>(</code> 不在map中默认对应的值是0</li></ul><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; num;<br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; op;<br><br><span class="hljs-comment">// 优先级表</span><br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; pr&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> b = num.top(); num.pop();  <span class="hljs-comment">// 第二个操作数</span><br>    <span class="hljs-keyword">auto</span> a = num.top(); num.pop();  <span class="hljs-comment">// 第一个操作数</span><br>    <span class="hljs-keyword">auto</span> c = op.top(); op.pop();    <span class="hljs-comment">// 运算符 </span><br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span>) x = a + b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) x = a - b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span>) x = a * b;<br>    <span class="hljs-keyword">else</span> x = a / b;<br>    <br>    num.push(x);  <span class="hljs-comment">// 结果入栈 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> str;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; str;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.size(); i ++ )<br>    &#123;<br>        <span class="hljs-keyword">auto</span> c = str[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))  <span class="hljs-comment">// 把这个数取出来(可能是多位)</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; str.size() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[j]))<br>                x = x * <span class="hljs-number">10</span> + str[j ++ ] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            i = j - <span class="hljs-number">1</span>;<br>            num.push(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) op.push(c);  <span class="hljs-comment">// 左括号无优先级，直接入栈</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.top() != <span class="hljs-string">&#x27;(&#x27;</span>) eval();  <span class="hljs-comment">// 一直计算到左括号</span><br>            op.pop();  <span class="hljs-comment">// 左括号出栈</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 待入栈运算符优先级低，则先计算</span><br>            <span class="hljs-keyword">while</span> (op.size() &amp;&amp; op.top() != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; pr[op.top()] &gt;= pr[c]) eval();  <br>            op.push(c);  <span class="hljs-comment">// 操作符入栈</span><br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">while</span> (op.size()) eval();  <span class="hljs-comment">// 剩余的进行计算</span><br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; num.top() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟链表</title>
    <link href="/2022/04/03/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/04/03/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>关于链表的题，一般都是写成结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    Node *next;<br>&#125;<br></code></pre></td></tr></table></figure><p>面试用的比较多。每次都需要 new 一个新节点，要调用 new 函数。</p><p>算法题中多用数组模拟链表，单链表一般用于存储图和树，双链表用于优化某些题。</p><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><ul><li><code>idx</code>：当前节点的下标</li><li><code>e[idx]</code>：当前节点的值</li><li><code>ne[idx]</code>：下一个节点的位置下标 (节点的next指针)</li><li><code>head</code>：头指针（我理解为 <code>ne[头]</code>，头指针指向的下一个节点的下标，初始是指向链表的末尾 <strong>-1</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331104210.png" alt=""></p><p>操作命令可能为以下几种：</p><ol><li><code>H x</code>，表示向链表头插入一个数 x。</li><li><code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li><li><code>I k x</code>，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li></ol><p><strong>Note：</strong></p><ol><li>idx 初始化时从0开始，第1个插入的数下标为0，所以第 k 个插入的数下标为 k - 1</li><li>删除头节点可以看成是指向下一个被插入的节点：<code>head = ne[head]</code></li></ol><p><strong>code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//往头节点位置插入x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = head;<br>    head = idx;<br>    idx ++ ;<br>&#125;<br><br><span class="hljs-comment">//往idx = k 的位置后插入x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = ne[k];<br>    ne[k] = idx;<br>    idx ++ ;<br>&#125;<br><br><span class="hljs-comment">//删除idx = k 后面的节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m;<br><br>    init();<br><br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> k, x;<br>        <span class="hljs-keyword">char</span> op;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;H&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            add_to_head(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;D&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            <span class="hljs-keyword">if</span> (!k ) head = ne[head];   <span class="hljs-comment">// 删除头节点可以看成是指向下一个被插入的节点</span><br>            <span class="hljs-keyword">else</span> remove(k - <span class="hljs-number">1</span>);         <span class="hljs-comment">// 第 k-1 个输入才是idx</span><br>        &#125;           <br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            insert(k - <span class="hljs-number">1</span>, x);<br>        &#125;<br><br>    &#125;<br><span class="hljs-comment">// 从 head 开始，也就是 头的下一个节点开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head; i != <span class="hljs-number">-1</span>; i = ne[i]) <span class="hljs-built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><ul><li><code>idx</code>：当前节点的下标</li><li><code>e[idx]</code>：当前节点的值</li><li><code>r[idx]</code>：当前节点的右边节点的位置下标 (节点的 right 指针)</li><li><code>l[idx]</code>：当前节点的左边节点的位置下标 (节点的 left 指针)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331111811.png" alt=""></p><p>作命令可能为以下几种：</p><ol><li><code>L x</code>，表示在链表的最左端插入数 x。</li><li><code>R x</code>，表示在链表的最右端插入数 x。</li><li><code>D k</code>，表示将第 k 个插入的数删除。</li><li><code>IL k x</code>，表示在第 k 个插入的数左侧插入一个数。</li><li><code>IR k x</code>，表示在第 k 个插入的数右侧插入一个数。</li></ol><p><strong>Note:</strong></p><ol><li><p>插入 与 删除操作 都是针对 下标为 idx 的节点的右节点。然后对 idx 的左节点的操作都可以写为 <code>l[idx]</code></p><blockquote><p>例如在下标为 idx 的左边插入一个点相当于在 <code>l[idx]</code>右边插入一个点</p></blockquote></li><li><p>插入操作需要注意顺序：<strong>idx 的 左右指针先与两边节点连上，然后先右节点指向 idx，再 idx 指向左节点</strong>。</p></li></ol><p><strong>code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> idx, e[N], l[N], r[N];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 0和1已经用过了</span><br>&#125;<br><br><span class="hljs-comment">// 在下标是k的点的右边，插入一个点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    r[idx] = r[k];<br>    l[idx] = k;<br>    l[r[k]] = idx;<br>    r[k] = idx;<br>    idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除第k个店</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br><br>    init();<br><br>    <span class="hljs-keyword">while</span>(n -- )<br>    &#123;<br>        <span class="hljs-built_in">string</span> op;<br>        <span class="hljs-keyword">int</span> x, k;<br><br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;L&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            add(<span class="hljs-number">0</span>, x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;R&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            add(l[<span class="hljs-number">1</span>], x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;D&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            remove(k + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;IL&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            add(l[k + <span class="hljs-number">1</span>], x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            add(k + <span class="hljs-number">1</span>, x);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 从 0 的下一个位置的元素开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">1</span>;i = r[i]) <span class="hljs-built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2022/04/02/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2022/04/02/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220412101750.png" alt=""></p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220412101017.png" alt=""></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;PII&gt; res;<br><br>    sort(segs.begin(), segs.end());  <span class="hljs-comment">// 按左端点排序</span><br><br>    <span class="hljs-keyword">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)  <span class="hljs-comment">// 情况3. 两个区间无法合并</span><br>        &#123;<br>            <span class="hljs-comment">// 循环里面的if语句是为了防止初始的st和ed，也就是st=-2e9 ed=-2e9被记录下来</span><br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);  <span class="hljs-comment">// 将旧区间 存入 res</span><br>            st = seg.first, ed = seg.second;  <span class="hljs-comment">// 更新 新区间的左右端点</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 情况2. 两个区间可以合并：区间包含，区间合并，二者都是选最大的ed（如第一张图所示）</span><br>        <span class="hljs-keyword">else</span> ed = max(ed, seg.second);<br>    &#125;<br><br>    <span class="hljs-comment">// 考虑循环结束时的st,ed变量，此时的st,ed变量不需要继续维护，只需要放进res数组即可。</span><br>    <span class="hljs-comment">// 因为这是最后的一个序列，所以不可能继续进行合并。</span><br>    <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);  <span class="hljs-comment">// if语句则是防止输入空的区间，不对空区间进行记录 </span><br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-803-区间合并"><a href="#1-AcWing-803-区间合并" class="headerlink" title="1. AcWing 803. 区间合并"></a><a href="https://www.acwing.com/problem/content/805/">1. AcWing 803. 区间合并</a></h3><p>给定 n 个区间 $[l_i,r_i]$，要求合并所有有交集的区间。注意如果在端点处相交，也算有交集。输出合并完成后的区间个数。</p><p>例如：[1,3] 和 [2,6] 可以合并为一个区间 [1,6]。</p><blockquote><p>模板题</p></blockquote><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">vector</span>&lt;PII&gt; segs;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;PII&gt; res;<br><br>    sort(segs.begin(), segs.end());<br><br>    <span class="hljs-keyword">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-comment">// // 循环里面的if语句是为了防止初始的st和ed，也就是st=-2e9 ed=-2e9被记录下来</span><br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = max(ed, seg.second);<br>    &#125;<br><br>    <span class="hljs-comment">// 防止输入空的区间</span><br>    <br>    <span class="hljs-comment">// 循环外面的if语句则是为了当n=0时，不进行最后一个区间的记录。</span><br>    <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br>    segs = res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <br>    &#123;<br>        <span class="hljs-keyword">int</span> l, r;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r;<br>        segs.push_back(&#123;l, r&#125;);<br>    &#125;<br><br>    merge(segs);<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; segs.size() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>也可以输出合并区间。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区间合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散化</title>
    <link href="/2022/04/01/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2022/04/01/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>离散化的作用是：是<strong>映射</strong>，<strong>将间隔很大的点，映射到相邻的数组元素中</strong>。减少对空间的需求，也减少计算量。</p><ul><li>如何映射？ </li></ul><p>定义一个 $find()$ 函数，输入离散数组的位置(映射前的位置)，返回连续数组的位置(映射后的位置<strong>+1</strong>，为了前缀和数组)</p><blockquote><p>定义 $x$ 是原下标，$c$ 是在 $x$ 的位置存入的数字。</p></blockquote><p>如何能够将不连续的点映射到连续的数组的下标？解决办法就是<strong>开辟额外的数组存放原来的数组下标</strong>，然后接下来的操作都是映射后的新坐标和数字的操作。设 $idx$ 是 $x$ 的下标，新映射数组 $alls[idx] = x$ </p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220410163235.png" style="zoom: 50%;" /></p><p>找 <code>alls</code> 数组里的数 对应的下标，这不是<strong>二分查找</strong>吗！查找 $&gt;=x$ 的最小值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// “映射”: 把add数组的下标x映射到下标的下标</span><br><span class="hljs-comment">// find(): 输入一个离散数组的位置（映射前的位置）x, 返回连续数组的位置+1（映射后的位置+1）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = alls.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid] &gt;= x) r = mid;  <span class="hljs-comment">// 这个地方总写错！alls数组</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 前缀和从1开始</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><font color='red'>**Note：是 alls 数组，总是写错！**</font></li></ul><p><strong>总结离散化步骤：</strong></p><ol><li><p>先存 数字和下标 <code>adds&#123;x, c&#125;</code>，把下标存入 <code>alls</code></p><p> 再存入 查询区间 <code>query&#123;l, r&#125;</code>，把左右点也放入 <code>alls</code></p></li><li><p>对 存入的下标和查询左右下标，进行排序</p><p>然后删掉重复的点（为了后边计算前缀和）</p></li><li><p>add，将离散的点 <code>alls[]</code> 通过<strong>二分</strong> <strong>映射</strong>到密集的下标，将数字存入映射后的新下标的数组</p></li><li><p>计算新的密集坐标对应的前缀和</p></li><li><p>用前缀和计算区间和，使用映射后的坐标计算 $s[r]-s[l-1]$</p></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-802-区间和"><a href="#1-AcWing-802-区间和" class="headerlink" title="1. AcWing 802. 区间和"></a><a href="https://www.acwing.com/problem/content/804/">1. AcWing 802. 区间和</a></h3><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p><p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p><blockquote><p>模板题</p></blockquote><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e6</span> + <span class="hljs-number">10</span>;  <span class="hljs-comment">// 前缀和的原因，还有两个查询的点要存入</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; alls;<br><span class="hljs-built_in">vector</span>&lt;PII&gt; add, query;<br><br><span class="hljs-keyword">int</span> a[N], s[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-comment">// 找alls 数组里的数 对应的下标，这不是二分查找吗！</span><br><span class="hljs-comment">// “映射”：把add数组的下标x映射到下标的下标</span><br><span class="hljs-comment">// find(): 输入一个离散数组的位置（映射前的位置）x, 返回连续数组的位置+1（映射后的位置+1）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = alls.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid] &gt;= x) r = mid;  <span class="hljs-comment">// 这个地方总写错！alls数组</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-comment">// 1. 处理输入，&#123;x, c&#125;存到 add 数组；alls数组存储 x 下标</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; c;<br>        <br>        add.push_back(&#123;x, c&#125;);<br>        <br>        alls.push_back(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 1. 处理查询，&#123;l, r&#125;存到 query 数组；alls数组存储 l, r 下标</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> l, r;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r;<br>        <br>        query.push_back(&#123;l, r&#125;);<br>        <br>        alls.push_back(l);<br>        alls.push_back(r);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 排序；去重</span><br>    sort(alls.begin(), alls.end());<br>    alls.erase(unique(alls.begin(), alls.end()), alls.end());<br>    <br>    <span class="hljs-comment">// 3. 执行“添加”，将数c加入到映射过后的新数组a[x] (新的下标x)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item: add)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x = find(item.first);<br>        a[x] += item.second;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 预处理新数组a[]的前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= alls.size(); i ++ ) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>    <br>    <span class="hljs-comment">// 5. 执行“查询”，通过l，r找到映射后的新坐标，算前缀和即可。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item: query)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l = find(item.first), r = find(item.second);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; s[r] - s[l - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2022/03/31/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/03/31/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>位运算涉及的两种操作：</p><ol><li>$x &gt;&gt; k \&amp; 1$：x 的二进制表示中的第 k 位数字是几</li><li>返回 x 的最后一位1后面的所有位：<code>lowbit(x) = x &amp; -x</code></li></ol><h2 id="x-gt-gt-k-amp-1-：x-的二进制表示中的第-k-位"><a href="#x-gt-gt-k-amp-1-：x-的二进制表示中的第-k-位" class="headerlink" title="$x &gt;&gt; k \&amp; 1$：x 的二进制表示中的第 k 位"></a>$x &gt;&gt; k \&amp; 1$：x 的二进制表示中的第 k 位</h2><p>问题：整数 $n$ 的二进制表示中，第 $k$ 位数字是几？</p><p>$&gt;&gt;$ 是右移运算符。假设x=5，那么x的二进制为0101，$x&gt;&gt;1$ 表示x右移1位，即把最右边一位的1删掉，变为010，此时x=2； 仍然设x=5，二进制0101，$x&gt;&gt;2$ 表示x右移2位，把最右边两位的01去掉，变为01，此时x=1。$x&gt;&gt;=1$ 等价于 $x=x&gt;&gt;1$，跟 $x+=1$ 等价于 $x=x+1$ 是一个道理</p><blockquote><p>$x &gt;&gt;= 1$ 相当于 $x = x / 2$</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220409190225.png" style="zoom: 40%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">31</span>; k &gt;= <span class="hljs-number">0</span> ; k -- ) <span class="hljs-built_in">cout</span> &lt;&lt; (x &gt;&gt; k &amp; <span class="hljs-number">1</span>);  =&gt; <span class="hljs-number">1010</span><br></code></pre></td></tr></table></figure><p><strong>Note：</strong>注意要倒序输出。</p><h2 id="lowbit-x-：返回x的最后一位1后面的所有位"><a href="#lowbit-x-：返回x的最后一位1后面的所有位" class="headerlink" title="lowbit(x)：返回x的最后一位1后面的所有位"></a>lowbit(x)：返回x的最后一位1后面的所有位</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220409192144.png" style="zoom: 50%;" /></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>例：<br>x = 1010         lowbit(x) = 10<br>x = 101000     lowbit(x) = 1000</p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="AcWing-801-二进制中1的个数"><a href="#AcWing-801-二进制中1的个数" class="headerlink" title="AcWing 801. 二进制中1的个数"></a><a href="https://www.acwing.com/problem/content/description/803/">AcWing 801. 二进制中1的个数</a></h3><h4 id="1-用-x-gt-gt-k-amp-1"><a href="#1-用-x-gt-gt-k-amp-1" class="headerlink" title="1.用 $x &gt;&gt; k \&amp; 1$"></a>1.用 $x &gt;&gt; k \&amp; 1$</h4><p>$x &gt;&gt; k \&amp; 1$：x 的二进制表示中的第 k 位数字。遍历每一位即可，如果是 1，<code>res ++</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(n -- )<br>&#123;<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; x;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">31</span>; k &gt;= <span class="hljs-number">0</span>; k -- ) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (x &gt;&gt; k &amp; <span class="hljs-number">1</span>) res ++ ;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-用-lowbit-x"><a href="#2-用-lowbit-x" class="headerlink" title="2. 用 lowbit(x)"></a>2. 用 lowbit(x)</h4><p>lowbit(x)：返回x的最后一位1后面的所有位。每次lowbit操作截取一个数字最后一个1后面的所有位，每次减去lowbit得到的数字，直到数字减到0，就得到了最终1的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">while</span>(n -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        <br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x) &#123;<br>            x -= lowbit(x);<br>            res ++ ;<br>        &#125;<br>        <br>        <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2022/03/29/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2022/03/29/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h1><p>双指针的核心思想：<strong>优化</strong>。降低时间复杂度 $O(n^2) -&gt; O(n)$</p><p><img src="C:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220410094054260.png" alt="image-20220410094054260" style="zoom:50%;" /></p><p>双指针算法的基本应用：输入一串字符串(中间带空格)，把每个单词数出来。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220410094744.png" alt="image-20220410094738815" style="zoom:80%;" /></p><p>用code表示就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">strlen</span>(str); i ++ )<br>&#123;<br><span class="hljs-keyword">int</span> j = i;<br>    <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; str[j] !+ <span class="hljs-string">&#x27; &#x27;</span>) j ++ ;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k ++ ) <span class="hljs-built_in">cout</span> &lt;&lt; str[k];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    i = j;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-AcWing-799-最长连续不重复子序列"><a href="#1-AcWing-799-最长连续不重复子序列" class="headerlink" title="1. AcWing 799. 最长连续不重复子序列"></a><a href="https://www.acwing.com/problem/content/801/">1. AcWing 799. 最长连续不重复子序列</a></h2><p>给定一个长度为 $n$ 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历数组 $a$ 中的每一个元素 $a[i]$，对于每一个 $i$，找到j使得双指针 $[j, i]$ 维护的是<strong>以 $a[i]$ 结尾的</strong>最长连续不重复子序列，长度为 $i - j + 1$，将这一长度与 $res$ 的较大者更新给 $res$。</p><p>对于每一个 $i$，如何确定 $j$ 的位置?</p><ul><li><p>由于 $[j, i - 1]$ 是前一步得到的最长连续不重复子序列，所以如果 $[j, i]$ 中有重复元素，一定是 $a[i]$，因此右移 $j$ 直到 $a[i]$ 不重复为止。</p><p>由于 $[j, i - 1]$ 已经是前一步的最优解，此时 $j$ 只可能右移以剔除重复元素 $a[i]$，不可能左移增加元素，因此，$j$ 具有“单调性”、本题可用双指针降低复杂度。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220410105419.png" style="zoom: 50%;" /></p><p>总结一下：用数组 $s$ 记录子序列 $a[j$ ~ $i]$ 中各元素出现次数，遍历过程中对于每一个 $i$ 有四步操作：</p><ul><li>$cin &gt;&gt; a[i] $</li><li>将 $a[i]$ 出现次数 $s[a[i]]$ 加1</li><li>若 $a[i]$ 重复，则$s[a[j]]$ 要减1，然后右移 $j$</li><li>确定 $j$ 及更新当前长度 $i - j + 1$ 给 $res$。</li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><font color='red'><strong>当 $a[i]$ 重复时，先把 $a[j]$ 次数减1，再右移 $j$</strong></font>。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> s[N];  <span class="hljs-comment">// 记录数组元素出现的次数</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        s[a[i]] ++ ;<br>        <span class="hljs-keyword">while</span>(s[a[i]] &gt; <span class="hljs-number">1</span>) <br>        &#123;<br>            s[a[j]] -- ;  <span class="hljs-comment">// 先减次数</span><br>            j ++ ;  <span class="hljs-comment">// 再往后移指针</span><br>        &#125;<br>        <br>        res = max(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Leetcode-3-无重复字符的最长子串"><a href="#2-Leetcode-3-无重复字符的最长子串" class="headerlink" title="2. Leetcode 3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">2. Leetcode 3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.size(); i ++ )<br>        &#123;<br>            hash[s[i]] ++ ;<br>            <span class="hljs-keyword">while</span>(hash[s[i]] &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                hash[s[j]] -- ;<br>                j ++ ;<br>            &#125;<br>            res = max(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-AcWing-800-数组元素的目标和"><a href="#3-AcWing-800-数组元素的目标和" class="headerlink" title="3. AcWing 800. 数组元素的目标和"></a><a href="https://www.acwing.com/problem/content/802/">3. AcWing 800. 数组元素的目标和</a></h2><p>给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。数组下标从 0 开始。</p><p>请你求出满足 A[i]+B[j]=x 的数对 (i,j)。数据保证有唯一解。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>从两端往中间逼近答案:</p><ul><li>i 从 0开始 从前往后遍历</li><li>j 从 m - 1开始 从后向前遍历</li></ul><p>和纯暴力的 $O(n^2)$ 算法的区别就在于 <strong>j 指针不会回退</strong></p><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> a[N], b[N];<br><span class="hljs-keyword">int</span> n, m, x;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>; i &lt;n ; i ++ ) <br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j -- ;<br>        <span class="hljs-keyword">if</span>(a[i] + b[j] == x)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, j);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-AcWing-2816-判断子序列"><a href="#4-AcWing-2816-判断子序列" class="headerlink" title="4. AcWing 2816. 判断子序列"></a><a href="https://www.acwing.com/problem/content/2818/">4. AcWing 2816. 判断子序列</a></h2><p>给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。请你判断 a 序列是否为 b 序列的子序列。</p><p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>$j$ 指针用来扫描整个b数组，$i$ 指针用来扫描a数组。若发现 $a[i]==b[j]$，则让 $i$ 指针后移一位。</li><li>整个过程中，$j$ 指针不断后移，而 $i$ 指针只有当匹配成功时才后移一位，若最后若 $i==n$，则说明匹配成功。</li></ol><h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; b[j];<br>    <br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; n &amp;&amp; a[i] == b[j]) i ++; <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(i == n) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>最长不重复子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差分</title>
    <link href="/2022/03/25/%E5%B7%AE%E5%88%86/"/>
    <url>/2022/03/25/%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="差分">差分</h1><h2 id="一维差分">一维差分</h2><h3 id="思路">思路</h3><ul><li>差分是前缀和的逆运算。</li><li>作用：给一段区间内的数加上 c</li></ul><p><strong>差分数组：</strong></p><p>首先给定一个原数组 <span class="math inline">\(a: a[1], a[2], a[3],..., a[n];\)</span></p><p>然后构造一个数组 <span class="math inline">\(b: b[1] ,b[2] , b[3],..., b[i];\)</span></p><p>使得 <span class="math inline">\(a[i] = b[1] + b[2 ]+ b[3] +... + b[i]\)</span></p><p>也就是说，<span class="math inline">\(a\)</span> 数组是 <span class="math inline">\(b\)</span> 数组的前缀和数组，反过来我们把 <span class="math inline">\(b\)</span> 数组叫做 <span class="math inline">\(a\)</span> 数组的<strong>差分数组</strong>。换句话说，每一个 <span class="math inline">\(a[i]\)</span> 都是 <span class="math inline">\(b\)</span> 数组中从头开始的一段区间和。</p><p><strong>考虑如何构造差分<span class="math inline">\(b\)</span>数组？</strong></p><p>最为直接的方法： <span class="math display">\[\begin{array}{l}a[0]=0 \\b[1]=a[1]-a[0] \\b[2]=a[2]-a[1] \\b[3]=a[3]-a[2] \\\ldots \ldots \\b[n]=a[n]-a[n-1]\end{array}\]</span> <strong>只要有 <span class="math inline">\(b\)</span> 数组，通过前缀和运算，就可以在 <span class="math inline">\(O(n)\)</span> 的时间内得到 <span class="math inline">\(a\)</span> 数组 。</strong></p><p>差分数组用于：给定区间<span class="math inline">\([l ,r ]\)</span>，把 <span class="math inline">\(a\)</span> 数组中的<span class="math inline">\([l, r]\)</span>区间中的每一个数都加上，即 <span class="math inline">\(a[l] + c , a[l+1] + c,..., a[r] + c\)</span>;</p><p>暴力做法是 <span class="math inline">\(for\)</span> 循环 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(r\)</span> 区间，时间复杂度 <span class="math inline">\(O(n)\)</span>，如果我们需要对原数组执行 <span class="math inline">\(m\)</span> 次这样的操作，时间复杂度就会变成 <span class="math inline">\(O(n*m)\)</span>。有没有更高效的做法吗? <strong>考虑差分做法</strong>：</p><ol type="1"><li><p>首先让差分 $b $ 数组中的 $b[l] + c $ , $a $ 数组变成 <span class="math inline">\(a[l] + c ,a[l+1] + c,..., a[n] + c\)</span></p></li><li><p>然后让 $b[r+1] - c $, $a $ 数组变成 <span class="math inline">\(a[r+1] - c,a[r+2] - c,...,a[n] - c\)</span></p></li></ol><p>画个图理解一下：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220407130926.png" style="zoom:50%;" /></p><p>$b[l] + c $ 使得 $a $ 数组中 $a[l] $ 及以后的数都加上了 $c $ (红色部分)，但只要求 $l $ 到 $r $ 区间加上 <span class="math inline">\(c\)</span>，因此还需要执行 $b[r+1] - c $，让 $a $数组中 $a[r+1] $ 及往后的区间再减去 $c $ (绿色部分)，这样对于 $a[r] $ 以后区间的数相当于没有发生改变。</p><p>因此得出<strong>一维差分结论</strong>：给 $a $ 数组中的 $[ l, r] $区间中的每一个数都加上 $c $，只需对差分数组 $b $ 做 $b[l] + = c $， $b[r+1] - = c $。时间复杂度为 $O(1) $，大大提高了效率。</p><h3 id="note">Note</h3><ul><li><p><strong>差分操作和前缀和一样数组下标都从1开始。</strong></p></li><li><p><span class="math inline">\(b[l]+c\)</span> 后，<span class="math inline">\(l\)</span> 后面的数组都会加 <span class="math inline">\(c\)</span> 。<span class="math inline">\(r\)</span> 后面的数据也会被改变，要改回来就得 <span class="math inline">\(b[r+1]-c\)</span></p><p>核心操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="code">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n, q;<br><span class="hljs-keyword">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-comment">// a[i] 是原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];  <br>    <br>    <span class="hljs-comment">// b[i] 是差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">// insert(i, i, a[i]);</span><br>        b[i] = a[i] - a[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(q -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> l, r, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;<br>        insert(l, r, c); <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        a[i] = b[i] + a[i - <span class="hljs-number">1</span>];    <span class="hljs-comment">//前缀和运算</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维差分">二维差分</h2><h3 id="思路-1">思路</h3><p><code>a[][]</code>数组是<code>b[][]</code>数组的前缀和数组，那么<code>b[][]</code>是<code>a[][]</code>的差分数组</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220407133657.png" style="zoom: 50%;" /></p><h3 id="note-1">Note</h3><ul><li><p>核心操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function">  </span>&#123;<br>      b[x1][y1] += c;<br>      b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>      b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>      b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>  &#125;<br><br><br><br><br><br>##<span class="hljs-meta"># code</span><br><br>```c++<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">int</span> n, m, q;<br><span class="hljs-keyword">int</span> a[N][N], b[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[x1][y1] += c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-built_in">cin</span> &gt;&gt; a[i][j];<br>    <br>    <span class="hljs-comment">// 构建差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-comment">// insert(i, j, i, j, a[i][j]);</span><br>            b[i][j] = a[i][j] - a[i - <span class="hljs-number">1</span>][j] - a[i][j - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <br>    <span class="hljs-keyword">while</span>(q -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x1, y1, x2, y2, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;<br>        <br>        insert(x1, y1, x2, y2, c);<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            b[i][j] +=  b[i - <span class="hljs-number">1</span>][j] + b[i][j - <span class="hljs-number">1</span>] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j =<span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-built_in">cout</span> &lt;&lt; b[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和</title>
    <link href="/2022/03/24/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2022/03/24/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和">前缀和</h1><h2 id="一维前缀和计算区域内的和">一维前缀和（计算区域内的和 ）</h2><h3 id="思路">思路</h3><ul><li><p>作用：能快速求出<strong>原数组中一段区间的数字和</strong>。</p></li><li><p>计算公式：计算 <span class="math inline">\([l, r]\)</span> 区间和前缀和 <code>S[r] - S[l - 1]</code></p></li><li><p><code>a[l] + ... + a[r] = S[r] - S[l - 1]</code></p><p>如何推导？ <span class="math display">\[S_r = a_1 + a_2 + .... +  a_{l-1} + a_l + ... + a_r\]</span></p><p><span class="math display">\[S_{l-1} = a_1 + a_2 + .... + a_{l-1}\]</span></p><p><span class="math inline">\((1) - (2)\)</span> 得： <span class="math display">\[S_r - S_{l-1} = a_l + .... + a_r\]</span></p></li><li><p>为什么下标要从 <span class="math inline">\(1\)</span> 开始？</p><p>比如 <span class="math inline">\([1, 10] =&gt;\)</span> <span class="math inline">\(S_{10} - S_{0} = S_{10}\)</span> ，这样可以统一处理所有情况。</p></li></ul><h3 id="注意">注意</h3><p><strong>差分操作和前缀和一样数组下标都从1开始。</strong></p><h3 id="code">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> a[N],S[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) S[i] = S[i - <span class="hljs-number">1</span>] + a[i]; <span class="hljs-comment">// 前缀和的初始化</span><br><br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;    <br>        <span class="hljs-keyword">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,S[r] - S[l<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// 区间和的计算</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维前缀和">二维前缀和</h2><h3 id="思路-1">思路</h3><ul><li><span class="math inline">\(S [i, j]\)</span> = 第i行j列格子左上部分所有元素的和</li></ul><ol type="1"><li><p><strong>如何计算前缀和矩阵？</strong></p><p><strong>容斥原理：</strong> <span class="math display">\[S_{x,y} = S_{x-1,y} +  S_{x,y-1} - S_{x-1,y-1} + a_{x,y}\]</span> <img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220408215133.png" style="zoom: 33%;" /></p></li><li><p><strong>如何利用前缀和矩阵，计算某一子矩阵的和？</strong></p></li></ol><ul><li><p>以 <span class="math inline">\((x1, y1)\)</span> 为左上角，<span class="math inline">\((x2, y2)\)</span> 为右下角的子矩阵的和为：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220408215251.png" style="zoom: 50%;" /></p></li></ul><h3 id="code-1">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">int</span> a[N][N], S[N][N];<br><span class="hljs-keyword">int</span> n, m, q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            S[i][j] += S[i - <span class="hljs-number">1</span>][j] + S[i][j - <span class="hljs-number">1</span>] - S[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br>            <br>    <span class="hljs-keyword">while</span>(q -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x1, x2, y1, y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, S[x2][y2] - S[x2][y1 - <span class="hljs-number">1</span>] - S[x1 - <span class="hljs-number">1</span>][y2] + S[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2022/03/23/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2022/03/23/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度">高精度</h1><p>高精度的模板包括高精度的加法、减法、乘法、除法。它们在输入输出时的处理方式是一样的，只是在核心的模拟计算的过程不同，在写板子的时候记得模拟一下过程，并多想想特殊情况，比如乘0这种情况会有前导0，等等。</p><p>输入输出：</p><ol type="1"><li>存储：用 $ $ 存储，第0位存个位，第1位存十位....以此类推。这样存储的好处是：如果相加有进位，刚好加到下一位，尤其是对于最高位，如果最高位有进位，在末位直接补更方便。</li><li>所以在读入数字时，一定要<strong>倒序读入</strong>。运算过后，也要倒序输出。</li><li>因为大数，需要按照字符串读进来，在存入数组时，要将字符转为数字，例如：<code>&quot;6&quot; - &quot;0&quot;</code> 就变成数字6。</li></ol><h2 id="高精度加法">高精度加法</h2><ul><li><span class="math inline">\(C = A + B, len(A / B) &lt;= 10^6\)</span></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406112720.PNG" /></p><h3 id="note">Note</h3><ul><li>注意在算到最后，也就是最高位的计算时，<strong>还要判断 t 是否有进位，如果有还要加进去！</strong></li></ul><h3 id="code">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.size() &lt; B.size()) <span class="hljs-keyword">return</span> add(B, A);<br><br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C;<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span>(i &lt; B.size()) t += B[i];<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.push_back(t);<br>    <span class="hljs-keyword">return</span> C;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a, b;  <span class="hljs-comment">//按字符串形式输入123456</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, B;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br><br>     <span class="hljs-comment">//按照 ‘6’‘5’‘4’‘3’‘2’‘1’ 读入</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) B.push_back(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C = add(A, B);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i -- ) <span class="hljs-built_in">cout</span>&lt;&lt; C[i];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度减法">高精度减法</h2><ul><li><span class="math inline">\(C = A - B, A&gt;= B, A/B &gt;= 0,len(A / B) &lt;= 10^6\)</span></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406143444.png" /></p><h3 id="note-1">Note</h3><ul><li><p>注意 同一位上的两个数相减如果为负，要向前借一位，这里表示为 <span class="math inline">\(t=1\)</span></p></li><li><p>减法存在<strong>前导0</strong>的问题，比如 <span class="math inline">\(13-12=01\)</span>，记得删掉：<code>while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();</code></p></li><li><p>减法要注意 <span class="math inline">\(sub()\)</span> 函数实现的是大的减小的，所以在计算前要先调整 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，实现一个 <span class="math inline">\(cmp\)</span> 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//判断是否有 A &gt;= B</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.size() != B.size()) <span class="hljs-keyword">return</span> A.size() &gt; B.size();<br><br>    <span class="hljs-comment">// 位数相等，从最高位开始 一位一位 倒序比较！</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )&#123;<br>        <span class="hljs-keyword">if</span> (A[i] != B[i]) <br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br>    <span class="hljs-comment">// 如果两数相等，b</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="code-1">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">//判断是否有 A &gt;= B</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.size() != B.size()) <span class="hljs-keyword">return</span> A.size() &gt; B.size();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )&#123;<br>        <span class="hljs-keyword">if</span> (A[i] != B[i]) <br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.size()) t = t - B[i];<br>        C.push_back((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a, b;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, B;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) B.push_back(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);   <br><br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C;<br><br>    <span class="hljs-keyword">if</span>(cmp(A, B)) C = sub(A, B);<br>    <span class="hljs-keyword">else</span>&#123;<br>        C = sub(B, A);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度乘法">高精度乘法</h2><ul><li><span class="math inline">\(C = A * b, A &gt;= 0, b &gt; 0\)</span>，这里的高精乘是指<strong>高精度乘以低精度</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406162613.png" /></p><h3 id="note-2">Note</h3><ul><li>也要判断 t 是否有进位，<strong>t 如果非0 需要进位</strong>！</li><li>乘法也存在<strong>前导0问题</strong>，比如 <span class="math inline">\(13 * 0 = 00\)</span>，要删掉。</li></ul><h3 id="code-2">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t += A[i] * b;<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        <br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(t) C.push_back(t);<br>    <br>    <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();  <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, C;<br>    <span class="hljs-built_in">string</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;0&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <br><br>        C = mul (A, b);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )  <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度除法">高精度除法</h2><ul><li><span class="math inline">\(A / b = C ... r, A &gt;= 0, b &gt; 0\)</span></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406163042.png" /></p><h3 id="note-3">Note</h3><ul><li>除法存在一个和其他三种不一样的问题：其他三种都是倒序读入从低位开始算。但是，除法需要从高位开始算，这个不能变。所以还要<strong>倒序变回正序计算</strong>！然后因为通用的输出还是倒序输出，又得把刚计算得到的结果再变成倒序，再倒序输出就是正序啦！</li><li>除法也存在前导0的问题。</li></ul><h3 id="code-3">code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;r)</span>  <span class="hljs-comment">// y</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.push_back(r / b);<br>        r %= b;<br>    &#125;<br>    <br>    reverse(C.begin(),C.end());<br>    <br>    <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    <span class="hljs-keyword">int</span> r;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C = div(A, b, r);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2022/03/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/03/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找">二分查找</h1><h2 id="思路">思路</h2><p><strong>二分关键词：“最大值最小”，“最小值最大”，“平均值最大/最小”</strong></p><p>一个题目，如果一个区间具有单调性质，那么一定可以二分，但是如果说这道题目没有单调性质，而是具有某种区间性质的话，我们同样可以使用二分.<strong>（不用单调性，有二段性：满足一段而不满足另一段，两段连上！）</strong></p><p>每次都要选择答案所在区间进行下一步处理：</p><ol type="1"><li>确定一个区间，使得目标一定在区间中。</li><li>找一个性质，满足：<ol type="1"><li>性质具有二段性（答案是性质的边界）所有二分都成立</li><li><strong>答案是二段性的分界点</strong></li></ol></li></ol><p>Note：一定要好好分析 <code>check()</code> 函数</p><h2 id="整数二分">整数二分</h2><h3 id="整数二分思路">整数二分思路</h3><p>在一个范围内，查找一个数字，要求找到这个元素的起始位置和结束位置，请注意这个范围内的数字都是单调递增的，即具有单调性质.</p><h3 id="模板code">模板code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l; <br>&#125;<br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 一定要加1</span><br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题">例题</h3><h4 id="acwing-789.-数的范围"><a href="https://www.acwing.com/problem/content/description/791/">1. Acwing 789. 数的范围</a></h4><blockquote><p>模板题</p></blockquote><h5 id="思路-1">思路</h5><p>需要写两个二分，一个需要找到 &gt;=x 的第一个数，另一个需要找到 &lt;=x 的最后一个数</p><p>1、<strong>查找大于等于x的第一个位置</strong></p><p>就是看 mid 是否满足右区间</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220401141638.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br><span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br><span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、<strong>查找小于等于x的第一个位置（查找大于等于x的最后一个位置）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220401141701.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br><span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 一定要加1！</span><br><span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为什么这里一定要 <strong>加 1</strong> 呢？</li></ul><p>答：因为如果按照上一个二分的写法，循环判断条件还是l &lt; r，当只有两个元素比如“2 2”时，l指向第一个元素，r指向第二个元素，mid指向第一个元素即 mid = l，q[mid] &lt;= x，l = mid还是指向第一个元素，指针不移动了，陷入死循环了，此刻 l + 1 == r，未能退出循环。</p><ul><li>为什么查找大于等于x的第一个位置不会死循环？</li></ul><p>因为这时就算只有两个元素，l + 1 = r，mid = l，q[mid] &lt; x 时 l 是会+1的，不小于 x 时r = mid也会缩小区间。而查找小于等于x的第一个位置之所以会死循环是因为编程语言里面除以2的下取整性，试想下如果l + 1 = r时， mid = r 呢，q[mid] &lt;= x，l = mid = r，区间缩小；否则r = mid - 1 = l 区间缩小，l都会与r相遇。就不会死循环。</p><h5 id="code">code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> q[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        <br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 找左端点，即: 大于等于x的第一个位置</span><br>        <span class="hljs-keyword">while</span>(l &lt; r)<br>        &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果找到的这个&gt;=x 的最小整数 不是x，说明数组里就没有x</span><br>        <span class="hljs-keyword">if</span> (q[l] != x) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-1 -1&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            r = n - <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-comment">// 找右端点，即: 小于等于x的第一个位置</span><br>            <span class="hljs-keyword">while</span>(l &lt; r)<br>            &#123;<br>                <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span>&gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <br>            <span class="hljs-built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><h3 id="浮点数二分思路">浮点数二分思路</h3><ul><li><p>将区间 <code>[l, r]</code> 划分成 <code>[l, mid]</code> 和 <code>[mid, r]</code></p></li><li><p>当区间长度足够小时就停止。一般是<strong>多2位</strong>！</p><p>比如题目要求小数点后六位，你就写 <code>while(r - l &gt; 1e-8)</code></p></li></ul><h3 id="模板code-1">模板code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l, <span class="hljs-keyword">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> ((r - l) &gt; eps)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题-1">例题</h3><h4 id="acwing-790.-数的三次方根"><a href="https://www.acwing.com/problem/content/792/">1. AcWing 790. 数的三次方根</a></h4><blockquote><p>模板题</p></blockquote><h5 id="code-1">code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>    <br>    <span class="hljs-keyword">double</span> l = <span class="hljs-number">-10000</span>, r = <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-keyword">while</span> ((r - l) &gt; <span class="hljs-number">1e-8</span>)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid * mid &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在-stl-中的二分查找">在 stl 中的二分查找</h2><p><code>lower_bound( )</code> 和 <code>upper_bound( )</code>都是利用二分查找的方法在一个<u>排好序的数组中</u>进行查找的。</p><p>在从小到大的排序数组中，</p><p><strong>lower_bound( begin,end,num)</strong>：从数组的begin位置到end-1位置二分查找<strong>第一个<u>大于或等于</u>num的数字，找到返回该数字的地址</strong>，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><strong>upper_bound( begin,end,num)</strong>：从数组的begin位置到end-1位置二分查找<strong>第一个<u>大于</u>num的数字，找到返回该数字的地址，</strong>不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2022/03/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><p>归并排序思路：</p><ol start="0" type="1"><li><strong>注意递归要退出！记得写退出条件！</strong></li><li>确定分界点：<code>int mid = l + r &gt;&gt; 1 ;</code> (下标的中心值)</li><li>递归排序 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code></li><li>归并：将左右两个有序序列 合并成一个有序序列</li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331113606.png" style="zoom: 60%;" /></p><p><strong>归并排序和快速排序的区别：</strong></p><ol type="1"><li><p>归并排序的分界点是整个区间的中心位置，下标的中间值</p><p>而快排的分界点是从当前这个区间随机一个数组的<strong>值</strong>(一般我们选取数组中间位置的<strong>数</strong>)</p></li><li><p>归并的关键是：合二为一</p><p>快排的关键是：划分成两段</p></li><li><p>归并：稳定</p><p>快排：不稳定（可以改为稳定的，按照 &lt;<span class="math inline">\(a_i, i\)</span>&gt; ，变成 pair，双关键字进行排序）</p></li></ol><blockquote><p>稳定是指：原序列中的两个相同的数，排序后，相对位置不发生变化。</p></blockquote><p><strong>模板code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_sort(q, l, mid);          <span class="hljs-comment">// 递归排序左右边</span><br>    merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// k是当前tmp数组里有多少数</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br>    &#125;<br><br>    <span class="hljs-comment">// 左半边或右半边可能没有循环完，只要拿过来放入就行</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-comment">// 结果存入tmp里面去了，得拿回来</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331113325.png" /></p><h2 id="例题">例题</h2><h3 id="acwing-787.-归并排序"><a href="https://www.acwing.com/problem/content/789/">1. AcWing 787. 归并排序</a></h3><blockquote><p>模板题</p></blockquote><h3 id="acwing-788.-逆序对的数量"><a href="https://www.acwing.com/problem/content/790/">2. AcWing 788. 逆序对的数量</a></h3><h4 id="题目">题目</h4><p>给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</p><p><strong>样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><h4 id="思路">思路</h4><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331141954.png" /></p><p>这个题可以使用分治法解决问题：将序列从中间分开，将逆序对分成三类(如上图所示)：</p><ol type="1"><li>两个元素都在左边；</li><li>两个元素都在右边；</li><li>两个元素一个在左 一个在右</li></ol><p><strong>我觉得其实递归到最深处，只有第三种情况，前两个就是描述这个递归的过程，只是用来帮助理解，事实上不存在。归并排序的递归过程的边界就是区间只有1个数，所以就是第三种情况。</strong><font color='red'>通过代码验证，确实不需要相加，将 res 定义为全局变量，直接递归左边和右边，不需要将二者加和，也可以ac。</font></p><p>可以注意到一个重要的性质，左右半边的元素在各自区间任意调换顺序，是不影响第三步计数的，因为第三步是左右区间各取一个数进行比较。因此我们可以数完就给它排序。这么做的好处在于，如果序列是有序的，会让第三步计数很容易。其实这个双指针还是归并排序中“归并”的过程，只不过在归并时，顺便计算他后面有几个数，即：<code>mid - i + 1</code></p><p>如果无序暴力数的话这一步是 <span class="math inline">\(O(n^2)\)</span> 的。</p><p><strong>Note</strong></p><ol type="1"><li>注意结果数据范围会爆int，所以 <code>res</code> 和 <code>merge_sort()</code> 要用 <code>long long</code> 数据类型。</li></ol><p><strong>code</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N], tmp[N];<br>LL res;<br><br><span class="hljs-function">LL <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_sort(q, l, mid);<br>    merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tmp[k ++ ] = q[j ++ ];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>, i = l; i &lt;= r; i ++ , k ++ ) q[i] = tmp[k];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; merge_sort(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速选择</title>
    <link href="/2022/03/18/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/"/>
    <url>/2022/03/18/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p><strong>快速选择算法</strong>是快速排序的一种变形。通常用在<strong>未排序的数组中寻找第k小/第k大的元素</strong>。快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是<strong>只递归进入一边的元素中继续寻找</strong>。这降低了平均时间复杂度，从 <span class="math inline">\(O(n logn)\)</span> 至 <span class="math inline">\(O(n)\)</span> ，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span> 。</p><p><em><a id="more"></a></em></p><h1 id="快速选择算法">快速选择算法</h1><p>快速选择算法是快速排序的一种变形。通常用<strong>在未排序的数组中寻找第k小/第k大的元素</strong>。</p><h2 id="思路">思路</h2><p>快速选择的总体思路与快速排序一致。（先快排）</p><ol type="1"><li><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</li><li><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</li><li><strong>递归处理k在的一端</strong>：快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。直至 <code>if (l &gt;= r) return q[l];</code> 。其中 <code>q[l]</code> 或者 <code>q[r]</code> 都可以，因为最后一次递归数组里只有一个数，就是要找的数。</li></ol><h2 id="快速选择模板">快速选择模板</h2><p><strong>快速选择算法：类似快排+二分，k在哪半部分，就递归哪个部分。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quick_select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];  <span class="hljs-comment">// q[l]/q[r]都可以，因为最后一次递归数组里只有一个数</span><br>    <br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> left_num = j - l + <span class="hljs-number">1</span>;  <span class="hljs-comment">// left_num: 左边的数有多少个</span><br>    <br>    <span class="hljs-keyword">if</span> (k &lt;= left_num) quick_select(q, l, j, k);  <span class="hljs-comment">// 递归左半边</span><br>    <span class="hljs-keyword">else</span> quick_select(q, j + <span class="hljs-number">1</span>, r, k - left_num);  <span class="hljs-comment">// 递归右半边</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间复杂度">时间复杂度</h2><p>快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 <span class="math inline">\(O(n logn)\)</span> 至 <span class="math inline">\(O(n)\)</span> ，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span> 。</p><p>第一层：<span class="math inline">\(O(n)\)</span></p><p>第二层：<span class="math inline">\(O(n/2)\)</span></p><p>第三层：<span class="math inline">\(O(n/4)\)</span></p><p>...</p><p>所以：<span class="math inline">\(O(n·(1 + \frac{1}{2}+ \frac{1}{4} + ... + \frac{1}{n})) &lt;= O(2n) = O(n)\)</span></p><h2 id="例题">例题</h2><h3 id="acwing-786.-第k个数"><a href="https://www.acwing.com/problem/content/788/">1. AcWing 786. 第k个数</a></h3><p>给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span>。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个整数（所有整数均在 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(10^9\)</span>范围内），表示整数数列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示数列的第k小数。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(1≤n≤100000\)</span>, <span class="math inline">\(1≤k≤n\)</span></p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><blockquote><p>模板题</p></blockquote><p><strong>code</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;algorithm&gt;</span><br><br>using namespace std;<br><br>const <span class="hljs-built_in">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">int</span> q[N];<br><span class="hljs-built_in">int</span> n, k;<br><br><span class="hljs-built_in">int</span> quick_select(<span class="hljs-built_in">int</span> q[], <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r, <span class="hljs-built_in">int</span> k)<br>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];  // q[l]/q[r]都可以，因为最后一次递归数组里只有一个数<br>    <br>    <span class="hljs-built_in">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        do i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        do j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">int</span> left_num = j - l + <span class="hljs-number">1</span>;  // left_num: 左边的数有多少个<br>    <br>    <span class="hljs-keyword">if</span> (k &lt;= left_num) quick_select(q, l, j, k);  // 递归左半边<br>    <span class="hljs-keyword">else</span> quick_select(q, j + <span class="hljs-number">1</span>, r, k - (j - l + <span class="hljs-number">1</span>));  // 递归右半边<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];<br>    <br>    cout &lt;&lt; quick_select(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acwing-104.-货仓选址"><a href="https://www.acwing.com/problem/content/106/">2. AcWing 104. 货仓选址</a></h3><p>题意是：在一条数轴上，有很多商店，选一个点，让其到所有商店距离最小。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330144746.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> res;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    sort(a, a + n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res += <span class="hljs-built_in">abs</span>(a[i] - a[(n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
      <tag>快速选择</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2022/03/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>第一次是在数据结构课学的快速排序。基本思路是：令 <code>i = l; j = r</code> ，选最左边的数为pivot。<code>j --</code> 从后向前找比它小的数，找到后与pivot交换。再 <code>i ++</code> 从前往后找比它大的数，找到后与pivot交换。再重复执行这一过程，直到 <code>i == j</code> 时，就找到了pivot的位置。再分别递归直至顺序。学了y总的方法感觉更聪明，是一种双指针快排的思路。</p><p><em><a id="more"></a></em></p><h1 id="快速排序算法双指针排序">快速排序算法(双指针排序)</h1><h2 id="思路">思路</h2><p>快排属于分治算法，一般分三步：</p><ol start="0" type="1"><li><p><strong>注意递归要退出！记得写退出条件！<code>if(l &gt;= r)</code> 时退出</strong></p></li><li><p><strong>分成子问题</strong>：</p><ul><li><p><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</p></li><li><p><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</p></li></ul></li><li><p><strong>递归处理子问题</strong>：即递归处理左右两端 (又回到0)</p></li><li><p>子问题合并. 快排这一步不需要操作，但归并排序的核心在这一步骤</p></li></ol><div class="note note-info">            <p>分治算法都有三步：</p><ol start="0" type="1"><li>确定递归退出条件</li><li>分成子问题</li><li>递归处理子问题</li><li>子问题合并</li></ol>          </div><h2 id="快排模板">快排模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 0. 循环退出条件</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;  <br><span class="hljs-comment">// 1. 分成子问题。</span><br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意值和下角标的区别。</span><br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 2. 递归处理子问题</span><br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);  <span class="hljs-comment">// 边界不要写错</span><br>    <span class="hljs-comment">// 3. 子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间复杂度">时间复杂度</h2><p>平均时间复杂度 <span class="math inline">\(O(nlogn)\)</span>，最坏情况下 <span class="math inline">\(O(n^2)\)</span>，在数组已排好序的情况下出现，可以通过随机化或者取中点来避免最差情况。</p><blockquote><p>数学推导证明过程挺复杂的。算法导论上有，用主定理证明的，很详细。但是没法简化</p></blockquote><h2 id="注意">注意</h2><h3 id="待证问题">1. 待证问题</h3><p>while循环结束后，<code>q[l..j] &lt;= x</code>, <code>q[j+1..r] &gt;= x</code></p><p>注: <code>q[l..j] &lt;= x</code> 意为 <code>q[l],q[l+1]...q[j-1],q[j]</code> 的所有元素都 <code>&lt;= x</code></p><p><strong>证明:</strong> 循环不变式：<code>q[l..i] &lt;= x q[j..r] &gt;= x</code></p><ol type="1"><li><p>初始化</p><p>循环开始之前 <code>i = l - 1, j = r + 1</code></p><p>则 <code>q[l..i]</code>, <code>q[j..r]</code> 为空，循环不变式显然成立</p></li><li><p>保持</p><p>假设某轮循环开始前循环不变式成立，即<code>q[l..i] &lt;= x, q[j..r] &gt;= x</code></p><p>执行循环体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>会使得 q[l..i<span class="hljs-number">-1</span>] &lt;= x, q[i] &gt;= x<br><br><span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>会使得 q[j+<span class="hljs-number">1.</span>.r] &gt;= x, q[j] &lt;= x<br><br><span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>会使得 q[l..i] &lt;= x, q[j..r] &gt;= x<br></code></pre></td></tr></table></figure><p>所以，i 和 j 更新之后，下一次循环开始之前，循环不变式依然成立</p><p>注意: 由于使用 do-while 循环,所以 <code>i</code> 和 <code>j</code> 一定会!!!自增!!!使得循环会继续下去,但是如果采用while循环(<code>i</code> 和 <code>j</code> 的初始化做出对应的变更), <code>i</code> 和 <code>j</code> 在特殊情况下不自增的话,循环就会卡死</p><p>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(q[i] &lt; x) i++;<br><span class="hljs-keyword">while</span>(q[j] &gt; x) j--;<br></code></pre></td></tr></table></figure><p>当 <code>q[i]</code> 和 <code>q[j]</code> 都为 x 时, i 和 j 都不会更新, 导致 while 陷入死循环</p></li><li><p>终止</p><p>循环结束时，<code>i &gt;= j</code></p><p>正常情况下，按照循环不变式，我们应该会觉得结果已经显然了</p><p>因为<code>i &gt;= j, q[l..i] &lt;= x, q[j..r] &gt;= x</code></p><p>所以按照 <code>j</code> 来划分的话，<code>q[l..j] &lt;= x, q[j+1..r] &gt;= x</code>是显然的</p><p>可是，最后一轮循环有点特殊，因为<strong>最后一轮循环的 if 语句一定不会执行</strong></p><p>因为最后一轮循环一定满足 i &gt;= j, 不然不会跳出 while 循环的，所以 if 语句一定不执行</p><p><strong>正确分析</strong>：</p><p>由于最后一轮的 if 语句一定不执行</p><p>所以，只能保证 <code>i &gt;= j</code> 和 <code>q[l..i-1] &lt;= x, q[i] &gt;= x</code>和<code>q[j+1..r] &gt;= x, q[j] &lt;= x</code></p><p>由 <code>q[l..i-1] &lt;= x，i &gt;= j(i-1 &gt;= j-1)</code> 和 <code>q[j] &lt;= x</code> 可以得到 <code>q[l..j] &lt;= x</code></p><p>又因为 <code>q[j+1..r] &gt;= x</code></p><p>所以，<code>q[l..j] &lt;= x,q[j+1..r] &gt;= x</code>, <strong>问题得证</strong></p><p><strong>总结</strong>: 只有最后一轮循环结束时，循环不变式不成立，其余的循环都是成立的, 但最终要求的问题还是解决了</p><p><strong>注意</strong>: 循环结束时要记得检查是否存在数组越界/无限递归的情况</p><p>所以还需要证明 <code>j</code> 最终的取值范围是 <code>[l..r-1]</code> (即不存在<code>n</code>划分成<code>0</code>和<code>n</code>的无限递归情况), 分析过程在分析<code>2.5</code></p></li></ol><h3 id="边界情况分析">2. 边界情况分析</h3><p>快排属于<strong>分治算法</strong>，最怕的就是 <code>n分成0和n</code>，或 <code>n分成n和0</code>，这会造成<strong>无限划分</strong>(死循环)</p><ol type="1"><li><p><strong>以 <code>j</code> 为划分时，<code>x</code> 不能选 <code>q[r]</code> (若以 <code>i</code> 为划分,则 <code>x</code> 不能选 <code>q[l]</code> )</strong></p><p>假设 <code>x = q[r]</code>：关键句子 <code>quick_sort(q, l, j), quick_sort(q, j + 1, r)</code></p><p>因为 <code>j</code> 的最小值是 <code>l</code>，所以 <code>[j + 1, r]</code> 不会造成无限划分，</p><p>但<code>[l..j]</code>(即 <code>quick_sort(q, l, j)</code> )却可能造成无限划分，因为 <code>j</code> 可能为 <code>r</code></p><p>举例来说，若 <code>x</code> 选为 <code>q[r]</code> ，数组中 <code>q[l..r-1] &lt; x</code> ，</p><p>那么这一轮循环结束时 <code>i = r, j = r</code>，这就造成了无限划分。</p><p>以 <code>0, 1</code> 这组数据为例，<code>x = q[r] = 1</code>，<code>do i ++ ; while(q[i] &lt; x)</code> ，</p><p>则 <code>i = 1 = r</code> ，<code>do j -- ; while(q[j] &gt; x)</code> ，则 <code>j = 1 = r</code> 。</p><p>则 <code>[0, 1]</code> 被划分成 <code>[0, 1]</code> 和 <code>[2, 1]</code> ，这就造成无限划分，即死循环。</p><blockquote><p>边界情况复杂，建议 <code>x = q[l + r &gt;&gt; 1]</code> 。</p></blockquote></li><li><p><strong><code>do i++; while(q[i] &lt; x)</code> 和 <code>do j--; while(q[j] &gt; x)</code> 不能用 <code>q[i] &lt;= x</code> 和 <code>q[j] &gt;= x</code>。</strong></p><p>举个栗子，比如 取的 <code>x</code> 刚好是数据里的最大值，执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>i+1</code>，交换的时候就是 <code>q[i + 1]</code> 和 <code>q[j]</code> 交换了，这显然不对。</p><p>或者举个极端情况，假设 <code>q[l..r]</code> 全相等，则执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>r+1</code>，然后继续执行 <code>q[i] &lt;= x</code> 判断条件，造成数组下标越界(但这貌似不会报错)。</p><p>并且如果之后的 <code>q[i] &lt;= x</code> (此时 <code>i &gt; r</code> ) 条件也不幸成立，就会造成一直循环下去(亲身实验)，造成内存超限 <code>(Memory Limit Exceeded)</code></p></li><li><p><code>if(i &lt; j) swap(q[i], q[j])</code> 能否使用 <code>i &lt;= j</code> ？</p><p><strong>可以使用 <code>if(i &lt;= j) swap(q[i], q[j]);</code></strong></p><p>因为 i = j 时，交换一下 <code>q[i],q[j]</code> 也就是交换自己，无影响，马上就会跳出循环了</p></li><li><p>最后一句能否改用 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 作为划分(用 <code>i</code> 做划分时也是同样的道理,)</p><p><strong>不能</strong>。根据之前的证明，最后一轮循环可以得到这些结论</p><ul><li><code>q[l..i-1] &lt;= x, q[i...r] &gt;= x</code></li><li><code>q[l...j] &lt;= x, q[j+1..r] &gt;= x</code></li><li><code>j &lt;= i</code></li></ul><p>所以，<code>q[l..j-1] &lt;= x</code> 是显然成立的，</p><p>但 <code>quick_sort(q, j, r)</code> 中的 <code>q[j]</code> 却是 <code>q[j] &lt;= x</code> ，这不符合快排的要求</p><p>另外一点，注意 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 可能会造成无线划分</p><p>当 <code>x</code> 选为 <code>q[l]</code> 时会造成无限划分，报错为(MLE),</p><p>如果手动改为 <code>x = q[r]</code>，可以避免无限划分。</p><p>但是上面所说的 <code>q[j] &lt;= x</code> 的问题依然不能解决，这会造成 <code>WA (Wrong Answer)</code></p></li><li><p><strong><code>j</code> 的取值范围为 <code>[l..r-1]</code></strong> (这块还是不太懂....)</p><p>证明：<strong>反证法</strong></p><p>假设 <code>j</code> 最终的值为 <code>r</code> ,说明只有一轮循环(两轮的话 <code>j</code> 至少会自减两次)</p><p>说明 <code>q[r] &lt;= x</code> (因为要跳出 <code>do-while</code> 循环)</p><p>说明 <code>i &gt;= r</code>( <code>while</code> 循环的结束条件), <code>i</code> 为 <code>r</code> 或 <code>r + 1</code>(必不可能成立)</p><p>说明 <code>i</code> 自增到了 <code>r</code> , 说明 <code>q[r] &gt;= x</code> 和 <code>q[l..r-1] &lt; x</code>，</p><p>得出 <code>q[r] = x</code> 和 <code>q[l..r-1] &lt; x</code> 的结论，但这与 <code>x = q[l + r &gt;&gt; 1]</code> 矛盾</p><p><strong>反证法</strong>得出 <code>j &lt; r</code></p><p>假设 <code>j</code> 可能小于 <code>l</code> 说明 <code>q[l..r] &gt; x</code> ,矛盾</p><p><strong>反证法</strong>得出 <code>j &gt;= l</code></p><p>所以 <code>j</code> 的取值范围为 <code>[l..r-1]</code> ，不会造成无限划分和数组越界</p></li></ol><p>顺带一提用 <code>i</code> 做划分时的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];  <span class="hljs-comment">// 注意是向上取整,因为向下取整可能使得x取到q[l]</span><br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    quick_sort(q, l, i - <span class="hljs-number">1</span>), quick_sort(q, i, r);  <span class="hljs-comment">// 不用q[l..i],q[i+1..r]划分的道理和分析4中j的情况一样</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还有从大到小排序的模板(仅仅改两个地方的判断符号)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &gt; x);  <span class="hljs-comment">// 这里和下面</span><br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &lt; x);  <span class="hljs-comment">// 这行的判断条件改一下</span><br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);<br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="元素值-和-q角标-的区别">3. <code>元素值</code> 和 <code>q[角标]</code> 的区别</h3><p>我之前一直搞错了角标的问题。正确写法是 <code>x = q[l + r &gt;&gt; 1]</code> ，我总是写成 <code>x = l + r &gt;&gt; 1; ...q[i] &lt; q[x]</code>。好蠢，一直没弄清楚 <strong><code>元素值</code> 和 <code>q[角标]</code> 的区别</strong>。<code>元素值</code> 就是一个数字，而 <code>q[角标]</code> 表示角标所在位置的值，相当于一个坑。快排在交换元素时，可能这个坑里的元素会有变化，而快排想要的仅仅是一个作为比较的值，模板里选了中间位置的元素值，而不是这个位置的数(也就是位置的角标)。之前一直没想通这个问题，直到模拟了一个错误样例才想明白。</p><blockquote><p>错误样例为：49，59，88，37，98，97，68，54，31，3</p></blockquote><p>以后遇到错误也要<u>多模拟样例</u>，自己想明白才是真的明白，不然也不会背了四五遍模板也记不清楚。</p><hr /><h2 id="例题">例题</h2><h3 id="acwing-785.-快速排序"><a href="https://www.acwing.com/problem/content/787/">1. AcWing 785. 快速排序</a></h3><p>模板题。</p><p><strong>code</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;    <br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ;i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    quick_sort(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TextCNN 的 PyTorch 实现</title>
    <link href="/2022/03/15/TextCNN%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/15/TextCNN%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="textcnn-的-pytorch-实现">TextCNN 的 PyTorch 实现</h1><p>本文主要介绍一篇将 CNN 应用到 NLP 领域的一篇论文 <a href="https://www.aclweb.org/anthology/D14-1181.pdf">Convolutional Neural Networks for Sentence Classification</a>，然后给出 PyTorch 实现。</p><p>论文比较短，总体流程不太复杂，最主要的是下面这张图，只要理解了这张图，就知道如何写代码了。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131223.png" /></p><p>下图的 feature map 是将一句话中的各个词通过 Word Embedding 得到的，feature map 的宽为 embedding 的维度，长为一句话的单词数量。例如下图中，很明显就是用一个 6 维的向量去编码每个词，并且一句话中有 9 个词。</p><p>之所以有两张 feature map，可以理解为 batchsize 为 2。</p><p>其中，红色的框代表的就是卷积核。而且很明显可以看出，这是一个长宽不等的卷积核。有意思的是，卷积核的宽可以认为是 n-gram，比方说下图卷积核宽为 2，所以同时考虑了 &quot;wait&quot; 和 &quot;for&quot; 两个单词的词向量，因此可以认为该卷积是一个类似于 bigram 的模型</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131248.png" style="zoom: 50%;" /></p><p>后面的部分就是传统 CNN 的步骤，激活、池化、Flatten</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131333.png" style="zoom: 50%;" /></p><h3 id="代码实现pytorch-版">代码实现（PyTorch 版）</h3><p>源码来自于 <a href="https://github.com/graykode/nlp-tutorial">nlp-tutorial</a>，<a href="https://wmathor.com/index.php/archives/1445/">王铃鑫同学</a>在其基础上进行了修改。</p><p>导入库.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br>dtype = torch.FloatTensor<br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br></code></pre></td></tr></table></figure><p>定义一些数据，以及设置一些常规参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 3 words sentences (=sequence_length is 3)</span><br>sentences = [<span class="hljs-string">&quot;i love you&quot;</span>, <span class="hljs-string">&quot;he loves me&quot;</span>, <span class="hljs-string">&quot;she likes baseball&quot;</span>, <span class="hljs-string">&quot;i hate you&quot;</span>, <span class="hljs-string">&quot;sorry for that&quot;</span>, <span class="hljs-string">&quot;this is awful&quot;</span>]<br>labels = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 1 is good, 0 is not good.</span><br><br><span class="hljs-comment"># TextCNN</span><br>embedding_size = <span class="hljs-number">2</span><br>sequence_length = <span class="hljs-built_in">len</span>(sentences[<span class="hljs-number">0</span>])  <span class="hljs-comment"># every sentences contains sequence_length(=3) words</span><br>num_classes =<span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels))  <span class="hljs-comment"># 几分类，这里是二分类</span><br>batch_size = <span class="hljs-number">3</span><br><br>word_list = <span class="hljs-string">&quot; &quot;</span>.join(sentences).split()<br>vocab = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(word_list))<br>vocab_size = <span class="hljs-built_in">len</span>(vocab)<br>word2idx = &#123;w:i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(vocab)&#125;<br></code></pre></td></tr></table></figure><p>数据预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_data</span>(<span class="hljs-params">sentences, labels</span>):</span><br>    inputs = []<br>    <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> sentences:<br>        inputs.append([word2idx[word] <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> sen.split()])  <span class="hljs-comment"># 把sentences中的每个句子拿出来，分成单词，找到对应idx加入 inputs</span><br>        <br>    targets = []<br>    <span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> labels:<br>        targets.append(out)   <span class="hljs-comment"># To using Torch Softmax Loss function</span><br>        <br>    <span class="hljs-keyword">return</span> inputs, targets<br><br>input_batch, targets_batch = make_data(sentences, labels)<br>input_batch, targets_batch = torch.LongTensor(input_batch), torch.LongTensor(targets_batch)<br><br>dataset = Data.TensorDataset(input_batch, targets_batch)<br>loader = Data.DataLoader(dataset, batch_size, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div class="note note-primary">            <ul><li><code>TensorDataset</code> 可以用来对 tensor 进行打包，把数据放在数据库中, 就好像 python 中的 zip 功能。该类通过每一个 tensor 的第一个维度进行索引。</li><li><code>DataLoader</code> 从数据库中每次抽出 batch size 个样本</li></ul>          </div><p>构建 TextCNN 模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextCNN</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TextCNN, self).__init__()<br>        self.W = nn.Embedding(vocab_size, embedding_size)<br>        output_channel = <span class="hljs-number">3</span><br>        self.conv = nn.Sequential(<br>            <span class="hljs-comment"># conv : [input_channel(=1), output_channel, (filter_height, filter_width), stride=1]</span><br>            nn.Conv2d(<span class="hljs-number">1</span>, output_channel, (<span class="hljs-number">2</span>, embedding_size)),  <span class="hljs-comment"># [batch_size, output_channel * 2 * 1]</span><br>            nn.ReLU(),<br>            <span class="hljs-comment"># pool : ((filter_height, filter_width))</span><br>            nn.MaxPool2d((<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)),<br>        )<br>        <span class="hljs-comment"># fc</span><br>        self.fc = nn.Linear(output_channel, num_classes)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        X: [batch_size, sequence_length]</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        batch_size = X.shape[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 因为测试的时候不知道有几个句子，所以在这里动态的获取一下</span><br>        embedding_X = self.W(X)  <span class="hljs-comment"># [batch_size, sequence_length, embedding_size]</span><br>        <br>        embedding_X = embedding_X.unsqueeze(<span class="hljs-number">1</span>)  <span class="hljs-comment"># add channel(=1) [batch, channel(=1), sequence_length, embedding_size]</span><br>        conved = self.conv(embedding_X)  <span class="hljs-comment"># 卷积之后：[batch_size, output_channel，1，1]</span><br>        <br>        flatten = conved.view(batch_size, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># [batch_size, output_channel * 1 * 1]</span><br>        output = self.fc(flatten)<br>        <br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><p>详细介绍一下数据在网络中流动的过程中维度的变化:</p><p>输入数据是个矩阵，矩阵维度为 <code>[batch_size, sequence_length]</code>，输入矩阵的数字代表的是某个词在整个词库中的索引（下标）</p><p>首先通过 Embedding 层，也就是查表，将每个索引转为一个向量，比方说 <code>12</code> 可能会变成 <code>[0.3,0.6,0.12,...]</code>，因此整个数据无形中就增加了一个维度，变成了 <code>[batch_size, sequence_length, embedding_size]</code></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144253.png" style="zoom: 67%;" /></p><p>之后使用 <code>unsqueeze(1)</code> 函数使数据增加一个维度，变成 <code>[batch_size, 1, sequence_length, embedding_size]</code>。现在的数据才能做卷积，因为在传统 CNN 中，输入数据就应该是 <code>[batch_size, in_channel, height, width]</code> 这种维度</p><p><code>[batch_size, 1, 3, 2]</code> 的输入数据通过 <code>nn.Conv2d(1, 3, (2, 2))</code> 的卷积之后，得到的就是 <code>[batch_size, 3, 2, 1]</code> 的数据，由于经过 ReLU 激活函数是不改变维度的，所以就没画出来。最后经过一个 <code>nn.MaxPool2d((2, 1))</code> 池化，得到的数据维度就是 <code>[batch_size, 3, 1, 1]</code></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144327.png" style="zoom:80%;" /></p><p>训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">model = TextCNN().to(device)<br>criterion = nn.CrossEntropyLoss().to(device)<br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    <span class="hljs-keyword">for</span> batch_x, batch_y <span class="hljs-keyword">in</span> loader:<br>        batch_x, batch_y = batch_x.to(device), batch_y.to(device)<br>        pred = model(batch_x)<br>        loss = criterion(pred, batch_y)<br>        <br>        <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>) % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">&#x27;Epoch:&#x27;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch + <span class="hljs-number">1</span>), <span class="hljs-string">&#x27;loss=&#x27;</span>, <span class="hljs-string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(loss))<br>            <br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Test</span><br>test_text = <span class="hljs-string">&#x27;i hate me&#x27;</span><br>tests = [[word2idx[n] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> test_text.split()]]<br>test_batch = torch.LongTensor(tests).to(device)<br><br><span class="hljs-comment"># Predict</span><br>model = model.<span class="hljs-built_in">eval</span>()<br>predict = model(test_batch).data.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> predict[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>    print(test_text,<span class="hljs-string">&quot;is Bad Mean...&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(test_text,<span class="hljs-string">&quot;is Good Mean!!&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Word2Vec 的 PyTorch 实现（乞丐版）</title>
    <link href="/2022/03/10/Word2Vec%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B9%9E%E4%B8%90%E7%89%88%EF%BC%89/"/>
    <url>/2022/03/10/Word2Vec%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B9%9E%E4%B8%90%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="word2vec-的-pytorch-实现乞丐版">Word2Vec 的 PyTorch 实现（乞丐版）</h1><p>自然语言处理问题中，一般以词作为基本单元，例如我们想要分析 &quot;我去过华盛顿州&quot; 这句话的情感，一般的做法是先将这句话进行分词，变成<code>我</code>，<code>去过</code>，<code>华盛顿州</code>，由于神经网络无法处理词，所以我们需要将这些词通过某些办法映射成词向量。词向量是用来表示词的向量，也可被认为是词的特征向量。<strong>把词映射为实数域向量的技术也叫词嵌入（word embedding）</strong></p><p>源码来自于 <a href="https://github.com/graykode/nlp-tutorial">nlp-tutorial</a>，<a href="https://wmathor.com/index.php/archives/1443/">王铃鑫大佬</a>在其基础上进行了修改：</p><p>导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optimizer<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>dtype = torch.FloatTensor<br></code></pre></td></tr></table></figure><p>文本预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">sentences = [<span class="hljs-string">&quot;jack like dog&quot;</span>, <span class="hljs-string">&quot;jack like cat&quot;</span>, <span class="hljs-string">&quot;jack like animal&quot;</span>,<br>  <span class="hljs-string">&quot;dog cat animal&quot;</span>, <span class="hljs-string">&quot;banana apple cat dog like&quot;</span>, <span class="hljs-string">&quot;dog fish milk like&quot;</span>,<br>  <span class="hljs-string">&quot;dog cat animal like&quot;</span>, <span class="hljs-string">&quot;jack like apple&quot;</span>, <span class="hljs-string">&quot;apple like&quot;</span>, <span class="hljs-string">&quot;jack like banana&quot;</span>,<br>  <span class="hljs-string">&quot;apple banana jack movie book music like&quot;</span>, <span class="hljs-string">&quot;cat dog hate&quot;</span>, <span class="hljs-string">&quot;cat dog like&quot;</span>]<br><br>sentence_list = <span class="hljs-string">&quot; &quot;</span>.join(sentences).split()  <br><span class="hljs-comment"># [&#x27;jack&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;, &#x27;jack&#x27;, &#x27;like&#x27;, &#x27;cat&#x27;, &#x27;animal&#x27;,...]</span><br><span class="hljs-comment">#     0      1       2       0      1       3       4</span><br><br><span class="hljs-comment"># 去个重，构建词汇的语料库</span><br>vocab = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(sentence_list))<br><span class="hljs-comment"># vocab = sorted(set(sentence_list), key=sentence_list.index)  # 我自己写的，为了保持原句子的顺序</span><br><br>word2idx = &#123;w:i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(vocab)&#125;<br><span class="hljs-comment"># &#123;&#x27;hate&#x27;: 0, &#x27;cat&#x27;: 1,...</span><br>vocab_size = <span class="hljs-built_in">len</span>(vocab)<br></code></pre></td></tr></table></figure><p>模型相关参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Word2Vec Parameters</span><br>C = <span class="hljs-number">2</span> <span class="hljs-comment"># window size</span><br>batch_size = <span class="hljs-number">8</span><br>embedding_size = <span class="hljs-number">2</span>  <span class="hljs-comment"># 2 dim vector represent one word</span><br></code></pre></td></tr></table></figure><p>数据预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">skip_grams = []<br><span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(C, <span class="hljs-built_in">len</span>(sentence_list) - C):<br>    center = word2idx[sentence_list[idx]]  <span class="hljs-comment"># 中心词的位置</span><br>    context_idx = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(idx - C, idx)) + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(idx + <span class="hljs-number">1</span>, idx + C + <span class="hljs-number">1</span>))  <span class="hljs-comment"># 左边的背景词 + 右边的背景词</span><br>    context = [word2idx[sentence_list[i]] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> context_idx]  <span class="hljs-comment"># 这个地方是 背景词索引 找出 背景词</span><br><span class="hljs-comment">#     print(context)</span><br>    <br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> context:<br>        skip_grams.append([center, w])<br></code></pre></td></tr></table></figure><p>假设所有文本分词，转为索引之后的 list 如下图所示. 根据论文所述，设定 window size=2，即每个中心词左右各取 2 个词作为背景词，那么对于上面的 list，窗口每次滑动，选定的中心词和背景词如下图.</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328130934.png" /></p><p>那么 skip_grams 变量里存的就是中心词和背景词一一配对后的 list，例如中心词 <code>2</code>，有背景词 <code>0,1,0,1，</code>一一配对以后就会产生 <code>[2,0],[2,1],[2,0],[2,1]</code>。skip_grams 如下图所示.</p><p>输入的是 one-hot 向量，“1”的位置就是中心词. 由于 Word2Vec 的输入是 one-hot 表示，所以我们先构建一个对角全 1 的矩阵，利用 <code>np.eye(rows)</code> 方法，其中的参数 rows 表示全 1 矩阵的行数，对于这个问题来说，语料库中总共有多少个单词，就有多少行</p><p>然后根据 skip_grams 每行第一列的值，取出相应全 1 矩阵的行。将这些取出的行，append 到一个 list 中去，最终的这个 list 就是所有的样本 X。标签不需要 one-hot 表示，只需要类别值，所以只用把 skip_grams 中每行的第二列取出来存起来即可</p><p>最后就是构建 dataset，然后定义 DataLoader</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131035.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用中心词生成背景词的概率</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_data</span>(<span class="hljs-params">skip_grams</span>):</span><br>    input_data = []<br>    output_data = []<br>    <br>    <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> skip_grams:<br>        input_data.append(np.eye(vocab_size)[a])  <span class="hljs-comment"># 就是数组里的数相当于在onehot数组里的位置是1</span><br>        output_data.append(b)<br><br>    <span class="hljs-keyword">return</span> input_data, output_data<br><br><br>input_data, output_data = make_data(skip_grams)<br>input_data, output_data = torch.Tensor(input_data), torch.LongTensor(output_data)<br>dataset = Data.TensorDataset(input_data, output_data)<br>loader = Data.DataLoader(dataset, batch_size, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><code>np.eye()</code> 的函数，除了生成对角阵外，还可以将一个label数组，大小为(1,m)或者(m,1)的数组，转化成one-hot数组。</p><p>例如 可以将类别总数为6的 <code>labels=[1,2,3,0,1,1]</code> 的数组转化成数组 <code>[[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0],[0,0,0,0,0,0],[0,1,0,0,0,0],[0,1,0,0,0,0]]</code> 这就是所谓的one-hot的形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">labels=np.array([[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>]])<br>print(<span class="hljs-string">&quot;labels的大小：&quot;</span>,labels.shape,<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>因为我们的类别是从0-2，所以这里是3个类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a=np.eye(<span class="hljs-number">3</span>)[<span class="hljs-number">1</span>]<br>print(<span class="hljs-string">&quot;如果对应的类别号是1，那么转成one-hot的形式&quot;</span>,a,<span class="hljs-string">&quot;\n&quot;</span>)<br>--&gt; 如果对应的类别号是1，那么转成one-hot的形式 [0. 1. 0.]<br></code></pre></td></tr></table></figure>          </div><p>定义模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义模型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Word2Vec</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(Word2Vec, self).__init__()<br>        self.W = nn.Parameter(torch.randn(vocab_size, embedding_size).<span class="hljs-built_in">type</span>(dtype))<br>        self.V = nn.Parameter(torch.randn(embedding_size, vocab_size).<span class="hljs-built_in">type</span>(dtype))<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-comment"># X: [batch_size, vocab_size]</span><br>        hidden = torch.mm(X, self.W)  <span class="hljs-comment"># [batch_size, m]</span><br>        output = torch.mm(hidden, self.V)  <span class="hljs-comment"># [batch_size, vocab_size]</span><br>        <span class="hljs-keyword">return</span> output<br>    <br>    <br>model = Word2Vec().to(device)<br>loss_fn = nn.CrossEntropyLoss().to(device)<br>optim = optimizer.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br></code></pre></td></tr></table></figure><p>训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># train</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000</span>):<br>    <span class="hljs-keyword">for</span> i, (batch_x, batch_y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(loader):<br>        <span class="hljs-comment"># 先移到cuda上去</span><br>        batch_x = batch_x.to(device)<br>        batch_y = batch_y.to(device)<br>        pred = model(batch_x)<br>        loss = loss_fn(pred, batch_y)<br>        <br>        <span class="hljs-keyword">if</span>(epoch + <span class="hljs-number">1</span>) % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            print(epoch + <span class="hljs-number">1</span>, i, loss.item())<br>            <br>        optim.zero_grad()<br>        loss.backward()<br>        optim.step()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NNLM 的 PyTorch 实现</title>
    <link href="/2022/03/10/NNLM%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/10/NNLM%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="nnlm-的-pytorch-实现">NNLM 的 PyTorch 实现</h1><h2 id="a-neural-probabilistic-language-model">A Neural Probabilistic Language Model</h2><p>本文算是训练语言模型的经典之作，Bengio 将神经网络引入语言模型的训练中，并得到了词向量这个副产物。词向量对后面深度学习在自然语言处理方面有很大的贡献，也是获取词的语义特征的有效方法</p><p>其主要架构为三层神经网络，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330140630.png" style="zoom:50%;" /></p><p>现在的任务是输入 <span class="math inline">\(w_{t−n+1},...,w_{t−1}\)</span> 这前 n-1 个单词，然后预测出下一个单词 <span class="math inline">\(w_t\)</span></p><p>数学符号说明：</p><ul><li><span class="math inline">\(C(i)\)</span>：单词 <span class="math inline">\(w\)</span> 对应的词向量，其中 <span class="math inline">\(i\)</span> 为词 <span class="math inline">\(w\)</span> 在整个词汇表中的索引</li><li><span class="math inline">\(C\)</span>：词向量，大小为 <span class="math inline">\(|V|×m\)</span> 的矩阵</li><li><span class="math inline">\(|V|\)</span>：词汇表的大小，即预料库中去重后的单词个数</li><li><span class="math inline">\(m\)</span>：词向量的维度，一般大于 50</li><li><span class="math inline">\(H\)</span>：隐藏层的 weight</li><li><span class="math inline">\(d\)</span>：隐藏层的 bias</li><li><span class="math inline">\(U\)</span>：输出层的 weight</li><li><span class="math inline">\(b\)</span>：输出层的 bias</li><li><span class="math inline">\(W\)</span>：输入层到输出层的 weight</li><li><span class="math inline">\(h\)</span>：隐藏层神经元个数</li></ul><p>计算流程：</p><ol type="1"><li>首先将输入的 <span class="math inline">\(n−1\)</span> 个单词索引转为词向量，然后将这 <span class="math inline">\(n−1\)</span> 个向量进行 concat，形成一个 <span class="math inline">\((n−1)×w\)</span> 的矩阵，用 <span class="math inline">\(X\)</span> 表示</li><li>将 <span class="math inline">\(X\)</span> 送入隐藏层进行计算，<span class="math inline">\(hidden_{out}=tanh⁡(d+X∗H)\)</span></li><li>输出层共有 <span class="math inline">\(|V|\)</span> 个节点，每个节点 <span class="math inline">\(y_i\)</span> 表示预测下一个单词 <span class="math inline">\(i\)</span> 的概率，<span class="math inline">\(y\)</span> 的计算公式为 <span class="math inline">\(y=b+X∗W+hidden_{out}∗U\)</span></li></ol><h2 id="代码实现pytorch">代码实现（PyTorch）</h2><p>导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><br>dtype = torch.FloatTensor<br></code></pre></td></tr></table></figure><p>数据预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">sentences = [ <span class="hljs-string">&quot;i like dog&quot;</span>, <span class="hljs-string">&quot;i love coffee&quot;</span>, <span class="hljs-string">&quot;i hate milk&quot;</span>]<br><br><span class="hljs-comment"># 将空格加入到单词之间，然后按空格隔开组成一个list</span><br>word_list = <span class="hljs-string">&quot; &quot;</span>.join(sentences).split()  <span class="hljs-comment"># [&#x27;i&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;, &#x27;i&#x27;, &#x27;love&#x27;, &#x27;coffee&#x27;, &#x27;i&#x27;, &#x27;hate&#x27;, &#x27;milk&#x27;]</span><br><br><span class="hljs-comment"># 构建词汇表，词汇表需要去重，再转换成list</span><br>word_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(word_list))  <span class="hljs-comment"># [&#x27;i&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;, &#x27;love&#x27;, &#x27;coffee&#x27;, &#x27;hate&#x27;, &#x27;milk&#x27;]</span><br><br><br>word_dict = &#123;w: i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word_list)&#125;  <span class="hljs-comment"># &#123;&#x27;i&#x27;:0, &#x27;like&#x27;:1, &#x27;dog&#x27;:2, &#x27;love&#x27;:3, &#x27;coffee&#x27;:4, &#x27;hate&#x27;:5, &#x27;milk&#x27;:6&#125;</span><br>number_dict = &#123;i: w <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word_list)&#125;  <span class="hljs-comment"># &#123;0:&#x27;i&#x27;, 1:&#x27;like&#x27;, 2:&#x27;dog&#x27;, 3:&#x27;love&#x27;, 4:&#x27;coffee&#x27;, 5:&#x27;hate&#x27;, 6:&#x27;milk&#x27;&#125;</span><br>n_class = <span class="hljs-built_in">len</span>(word_dict)  <span class="hljs-comment"># number of Vocabulary, just like |V|, in this task n_class=7（维度，有多少词就是多少行）</span><br><br><br><span class="hljs-comment"># NNLM(Neural Network Language Model) Parameter</span><br><span class="hljs-comment"># n_step = 2  # 输入数据的长度，这里就是两个单词</span><br>n_step = <span class="hljs-built_in">len</span>(sentences[<span class="hljs-number">0</span>].split())-<span class="hljs-number">1</span>  <span class="hljs-comment"># n-1 in paper, look back n_step words and predict next word. In this task n_step=2</span><br>n_hidden = <span class="hljs-number">2</span>  <span class="hljs-comment"># h in paper</span><br>m = <span class="hljs-number">2</span>  <span class="hljs-comment"># m in paper, word embedding dim</span><br></code></pre></td></tr></table></figure><p>由于 PyTorch 中输入数据是以 mini-batch 小批量进行的，下面的函数首先将原始数据（词）全部转为索引，然后通过 <code>TensorDataset()</code> 和 <code>DataLoader()</code> 编写一个实用的 mini-batch 迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_batch</span>(<span class="hljs-params">sentences</span>):</span><br>    input_batch = []<br>    target_batch = []<br>    <br>    <span class="hljs-comment"># 遍历每一条句子</span><br>    <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> sentences:<br>        word = sen.split()  <span class="hljs-comment"># [&#x27;i&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;]</span><br>        <span class="hljs-comment"># 只要前两个词作为输入，最后一个词是预测的</span><br>        <span class="hljs-built_in">input</span> = [word_dict[n] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> word[:-<span class="hljs-number">1</span>]]  <span class="hljs-comment"># [0, 1], [0, 3], [0, 5]</span><br>        target = word_dict[word[-<span class="hljs-number">1</span>]]  <span class="hljs-comment"># 2, 4, 6</span><br><br>        input_batch.append(<span class="hljs-built_in">input</span>)  <span class="hljs-comment"># [[0, 1], [0, 3], [0, 5]]</span><br>        target_batch.append(target)  <span class="hljs-comment"># [2, 4, 6]</span><br><br>    <span class="hljs-keyword">return</span> input_batch, target_batch<br><br><br>input_batch, target_batch = make_batch(sentences)<br><span class="hljs-comment"># 需要将 list 转换为 tensor</span><br>input_batch = torch.LongTensor(input_batch)<br>target_batch = torch.LongTensor(target_batch)<br><br>dataset = Data.TensorDataset(input_batch, target_batch)<br><br>loader = Data.DataLoader(dataset=dataset, batch_size=<span class="hljs-number">16</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>定义网络结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义网络结构</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NNLM</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(NNLM, self).__init__()<br>        self.C = nn.Embedding(n_class, m)  <span class="hljs-comment"># 有多少行，</span><br>        self.H = nn.Parameter(torch.randn(n_step * m, n_hidden).<span class="hljs-built_in">type</span>(dtype))<br>        self.W = nn.Parameter(torch.randn(n_step * m, n_class).<span class="hljs-built_in">type</span>(dtype))<br>        self.d = nn.Parameter(torch.randn(n_hidden).<span class="hljs-built_in">type</span>(dtype))<br>        self.U = nn.Parameter(torch.randn(n_hidden, n_class).<span class="hljs-built_in">type</span>(dtype))<br>        self.b = nn.Parameter(torch.randn(n_class).<span class="hljs-built_in">type</span>(dtype))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        X: [batch_size, n_step]  batch_size：选几个数据，n_step 列</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        X = self.C(X) <span class="hljs-comment"># [batch_size, n_step] =&gt; [batch_size, n_step, m]</span><br>        X = X.view(-<span class="hljs-number">1</span>, n_step * m)  <span class="hljs-comment"># [batch_size, n_step * m] 维度变为2维</span><br>        hidden_out = torch.tanh(self.d + torch.mm(X, self.H))  <span class="hljs-comment"># [batch_size, n_hidden]</span><br>        output = self.b + torch.mm(X, self.W) + torch.mm(hidden_out, self.U)  <span class="hljs-comment"># [batch_size, n_class]</span><br>        <span class="hljs-keyword">return</span> output<br><br>    <br>model = NNLM()<br>criterion = nn.CrossEntropyLoss()<br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br></code></pre></td></tr></table></figure><p><code>nn.Parameter()</code> 的作用是将该参数添加进模型中，使其能够通过 <code>model.parameters()</code> 找到、管理、并且更新。更具体的来说就是：</p><ol type="1"><li><code>nn.Parameter()</code> 与 <code>nn.Module</code> 一起使用时会有一些特殊的属性，其会被自动加到 Module 的 <code>parameters()</code> 迭代器中</li><li>使用很简单：<code>torch.nn.Parameter(data, requires_grad=True)</code>，其中 data 为 tensor</li></ol><p>简单解释一下执行 <code>X=self.C(X)</code> 这一步之后 <code>X</code> 发生了什么变化，假设初始 <code>X=[[0, 1], [0, 3]]</code></p><p>通过 <code>Embedding()</code> 之后，会将每一个词的索引，替换为对应的词向量，例如 <code>love</code> 这个词的索引是 <code>3</code>，通过查询 Word Embedding 表得到行索引为 3 的向量为 <code>[0.2, 0.1]</code>，于是就会将原来 <code>X</code> 中 <code>3</code> 的值替换为该向量，所有值都替换完之后，<code>X=[[[0.3, 0.8], [0.2, 0.4]], [[0.3, 0.8], [0.2, 0.1]]]</code></p><p>训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Training</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    <span class="hljs-keyword">for</span> batch_x, batch_y <span class="hljs-keyword">in</span> loader:<br>        output = model(batch_x)  <span class="hljs-comment"># 预测值 pred</span><br>        optimizer.zero_grad()  <span class="hljs-comment"># 梯度清零</span><br><br>        <span class="hljs-comment"># output : [batch_size, n_class], batch_y : [batch_size] (LongTensor, not one-hot)</span><br>        <span class="hljs-comment"># 中间打印一下loss</span><br>        loss = criterion(output, batch_y)<br>        <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>)%<span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">&#x27;Epoch:&#x27;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch + <span class="hljs-number">1</span>), <span class="hljs-string">&#x27;cost =&#x27;</span>, <span class="hljs-string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(loss))<br><br>        loss.backward()  <span class="hljs-comment"># 误差反向传播</span><br>        optimizer.step()  <span class="hljs-comment"># 更新参数</span><br><br><br><span class="hljs-comment"># Predict</span><br>predict = model(input_batch).data.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)[<span class="hljs-number">1</span>]<br><br><br><span class="hljs-comment"># Test</span><br>print([sen.split()[:n_step] <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> sentences], <span class="hljs-string">&#x27;-&gt;&#x27;</span>, [number_dict[n.item()] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> predict.squeeze()])        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用指令记录</title>
    <link href="/2021/10/13/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/10/13/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>以后学某一项技术，可以去看官方文档入门教程。以后边写边查即可。(from y总)</p><p>不定时更新。努力学习记录中...:p</p>          </div><h2 id="文件管理命令">文件管理命令</h2><p><code>.</code>：当前目录（也是文件）</p><p><code>..</code>：上层目录</p><p>绝对路径 以 <code>/</code> 开头，相对路径直接是文件夹名</p><p>常用命令介绍</p><ol type="1"><li><p><code>ctrl c</code>：取消命令，并且换行（比如说你不想打这行或者打错了，直接 crtl c 换一行，就是 换行＋清空）</p></li><li><p><code>ctrl u</code>：清空本行命令</p></li><li><p><code>tab键</code>：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p><code>ls</code>: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p><ul><li><code>-a</code> 显示所有文件及目录 (. 开头的隐藏文件也会列出)</li><li><code>-l</code> 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<ul><li><code>-lh</code> 加个 h，可以人性化输出，比如 30952字节，就会写成 31k，方便看~</li></ul></li><li><code>-A</code> 同 <code>-a</code> ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录)</li><li><code>-t</code> 按建立时间</li></ul></li><li><p><code>pwd</code>：显示当前路径</p></li><li><p><code>cd XXX</code>： 进入XXX目录下，<code>cd ..</code> 返回上层目录</p></li><li><p><code>cp XXX YYY</code>：将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如 ../dir_c/a.txt，表示上层目录下的 dir_c 文件夹下的文件 a.txt</p><p><code>cp</code> = 复制 + 粘贴 + 重命名</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144435.png" /></p><p>可以将一个文件夹整个复制到另一个文件夹下面：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144452.png" /></p><p>也可以将一个文件夹复制到当前目录下：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144507.png" /></p><p>Note：复制文件夹一定要加 <code>-r</code> （r 是递归的缩写）</p></li><li><p><code>mkdir XXX</code>：创建目录XXX</p><blockquote><p>遇到文件夹名称有空格，转义字符就行 <code>/</code>。eg <code>cp a y/ c</code></p></blockquote></li><li><p><code>rm XXX</code>：删除普通文件;</p><p><code>rm XXX -r</code>：删除文件夹</p><p>可以删掉整个文件夹连带着里面的文件</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144526.png" /></p><p>也可以只删除文件夹下面的文件而保留文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144539.png" /></p></li><li><p><code>mv XXX YYY</code>：剪切+粘贴+重命名。将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144603.png" /></p><p>重命名也是用这个命令</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144627.png" /></p><blockquote><p>cp：是拷贝一份</p><p>mv：是移动一份</p></blockquote></li><li><p><code>touch XXX</code>：创建一个文件</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144733.png" /></p></li><li><p><code>cat XXX</code>：展示文件XXX中的内容</p></li><li><p>复制文本 windows/Linux下：<code>Ctrl + insert</code>，Mac下：<code>command + c</code></p></li><li><p>粘贴文本 windows/Linux下：<code>Shift + insert</code>，Mac下：<code>command + v</code></p></li></ol><blockquote><p>笔记本上需要加 fn 键，复制是 <code>ctrl + fn + insert</code>，粘贴是 <code>shift + fn +insert</code></p></blockquote><h2 id="tmux">tmux</h2><p>tmux主要是用来远程ssh上去服务器交互用</p><h3 id="功能">功能</h3><ol type="1"><li>分屏。</li><li><strong>允许断开Terminal连接后，继续运行进程</strong>。</li></ol><h3 id="结构">结构</h3><p>一个 tmux 可以包含多个 session，一个 session 可以包含多个 window，一个 window 可以包含多个 pane。</p><h3 id="实例">实例</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">tmux:<br>session <span class="hljs-number">0</span>:<br><span class="hljs-built_in">window</span> <span class="hljs-number">0</span>:<br>pane <span class="hljs-number">0</span><br>pane <span class="hljs-number">1</span><br>pane <span class="hljs-number">2</span><br>...<br><span class="hljs-built_in">window</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">window</span> <span class="hljs-number">2</span><br>...<br>session <span class="hljs-number">1</span><br>session <span class="hljs-number">2</span><br>...<br></code></pre></td></tr></table></figure><h3 id="常用的操作">常用的操作</h3><ol type="1"><li><code>tmux</code>：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</li><li><code>tmux new -s name</code>：新建一个名为 name 的 session</li><li><code>tmux ls</code>：显示已有tmux列表</li><li><code>tmux attach -t name</code>：从终端打开之前挂起的session。</li><li><code>ctrl + b</code>，再按<code>d</code> 挂起session，就是退化该会话，但不会关闭会话。</li><li><code>tmux kill-session -t name</code>：关闭名为 name 会话（销毁会话）</li><li><code>tmux rename -t name newname</code>：更名</li></ol><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406155813.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406155817.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406155830.png" /></p><h3 id="tmux使用时出现的问题">tmux使用时出现的问题</h3><p>1、conda 的环境用不了</p><p>首先退出并关闭会话，在终端退出conda环境，新建进入会话，在tmux会话中激活所需conda环境方可生效。</p><h3 id="操作-在ubuntu都是-ctrl-b">操作 （在ubuntu都是 <code>ctrl + b</code>）</h3><ol type="1"><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>%</code>：将当前pane左右平分成两个pane。</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>&quot;</code>（注意是双引号&quot;）：将当前pane上下平分成两个pane。</p></li><li><p><code>Ctrl + d</code>：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</p></li><li><p>鼠标点击可以选pane。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按方向键：选择相邻的pane。</p></li><li><p>鼠标拖动pane之间的分割线，可以调整分割线的位置。</p></li><li><p>按住<code>ctrl + a</code>的同时按方向键，可以调整pane之间分割线的位置。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>z</code>：将当前pane全屏/取消全屏。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>d</code>：挂起当前session。</p></li><li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>s</code>：选择其它session。 方向键 —— 上：选择上一项 session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键 —— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>c</code>：在当前session中创建一个新的window。</p></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>w</code>：选择其他window，操作方法与(12)完全相同。</p><blockquote><p>每个 session 开一个 window 这样清楚些..</p></blockquote></li><li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>PageUp</code>：翻阅当前pane内的内容。</p></li><li><p><code>鼠标滚轮</code>：翻阅当前pane内的内容。</p></li><li><p>在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</p></li><li><p>tmux中复制/粘贴文本的通用方式：</p></li><li><p>按下<code>Ctrl + a</code>后松开手指，然后按<code>[</code></p></li><li><p>用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</p></li><li><p>按下Ctrl + a后松开手指，然后按<code>]</code>，会将剪贴板中的内容粘贴到光标处</p></li></ol><h2 id="vim-教程">vim 教程</h2><h3 id="功能-1">功能</h3><ol type="1"><li><p>命令行模式下的文本编辑器。</p></li><li><p>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</p></li><li><p>使用方式：<code>vim filename</code> 如果已有该文件，则打开它。 如果没有该文件，则打开个一个新的文件，并命名为filename</p></li></ol><h3 id="模式">模式</h3><ol type="1"><li><p>一般命令模式</p><p>默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</p></li><li><p>编辑模式</p><p>在一般命令模式里按下<code>i</code>，会进入编辑模式。 按下<code>ESC</code>会退出编辑模式，返回到一般命令模式。</p></li><li><p>命令行模式</p><p>在一般命令模式里按下<code>: / ?</code>三个字母中的任意一个，会进入命令行模式。命令行在最下面。 可以查找、替换、保存、退出、配置编辑器等。</p></li></ol><h3 id="操作">操作</h3><ol type="1"><li><p><code>i</code>：进入编辑模式</p></li><li><p><code>ESC</code>：进入一般命令模式</p></li><li><p><code>h</code> 或 <code>左箭头键</code>：光标向左移动一个字符</p></li><li><p><code>j</code> 或 <code>向下箭头</code>：光标向下移动一个字符</p></li><li><p><code>k</code> 或 <code>向上箭头</code>：光标向上移动一个字符</p></li><li><p><code>l</code> 或 <code>向右箭头</code>：光标向右移动一个字符</p></li><li><p><code>n&lt;Space&gt;</code>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</p></li><li><p><code>0</code> 或 <code>功能键[Home]</code>：光标移动到本行开头</p></li><li><p><code>$</code> 或 <code>功能键[End]</code>：光标移动到本行末尾</p></li><li><p><code>G</code>：光标移动到最后一行</p></li><li><p><code>:n</code> 或 <code>nG</code>：n为数字，光标移动到第n行</p></li><li><p><code>gg</code>：光标移动到第一行，相当于1G</p></li><li><p><code>n&lt;Enter&gt;</code>：n为数字，光标向下移动n行</p></li><li><p><code>/word</code>：向光标之下寻找第一个值为word的字符串。7</p></li><li><p><code>?word</code>：向光标之上寻找第一个值为word的字符串。</p></li><li><p><code>n</code>：重复前一个查找操作</p></li><li><p><code>N</code>：反向重复前一个查找操作</p></li><li><p><code>:n1,n2s/word1/word2/g</code>：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</p></li><li><p><code>:1,$s/word1/word2/g</code>：将全文的word1替换为word2</p></li><li><p><code>:1,$s/word1/word2/gc</code>：将全文的word1替换为word2，且在替换前要求用户确认。</p></li><li><p><code>v</code>：选中文本</p></li><li><p><code>d</code>：删除选中的文本.其实是剪切，可以粘贴回来的.</p></li><li><p><code>dd</code>：删除当前行</p></li><li><p><code>y</code>：复制选中的文本</p></li><li><p><code>yy</code>：复制当前行</p></li><li><p><code>p</code>：将复制的数据在光标的下一行/下一个位置粘贴</p></li><li><p><code>u</code>：撤销</p></li><li><p><code>Ctrl + r</code>：取消撤销</p></li><li><p><code>大于号 &gt;</code>：将选中的文本整体向右缩进一次</p></li><li><p><code>小于号 &lt;</code>：将选中的文本整体向左缩进一次</p></li><li><p><code>:w</code> 保存</p></li><li><p><code>:w!</code> 强制保存</p></li><li><p><code>:q</code> 退出</p></li><li><p><code>:q!</code> 强制退出</p></li><li><p><code>:wq</code> 保存并退出</p></li><li><p><code>:set paste</code> 设置成粘贴模式，取消代码自动缩进</p></li><li><p><code>:set nopaste</code> 取消粘贴模式，开启代码自动缩进</p></li><li><p><code>:set nu</code> 显示行号</p></li><li><p><code>:set nonu</code> 隐藏行号(为了复制文本时没有行号)</p></li><li><p><code>gg=G</code>：将全文代码格式化。</p><p><code>ggdG</code>：全删</p></li><li><p><code>:noh</code> 关闭查找关键词高亮</p></li><li><p><code>Ctrl + q</code>：当vim卡死时，可以取消当前正在执行的命令</p></li></ol><h3 id="异常处理">异常处理：</h3><p>每次用vim编辑文件时，会自动创建一个<code>.filename.swp</code>的临时文件。</p><p>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</p><ol type="1"><li>找到正在打开该文件的程序，并退出</li><li>直接删掉该swp文件即可</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小张同学的2020年度总结</title>
    <link href="/2020/12/31/%E5%B0%8F%E5%BC%A0%E2%80%98s2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/31/%E5%B0%8F%E5%BC%A0%E2%80%98s2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ed03a36c773264b24335a4bf6c650abbf9e4122c55e31683e7fcb6e3bf171fce">2c3eb40cbd03027ad9e37b5ead0a8959ee5c19daf66ddf9423535ad275743aac339b96d3c0da3e42bd38116cbba3b545fa36a0c479e99ced9e0daefe07036f6f41f6ca7ef0b27dd77c74a49acf9cf7a6258d5cd47d8248a8242e603da1280f2b2a3125d49a8b17a980391bb57bf238624f93c429978d59ae48c88f2bc66367fe663da4b1318d5d4108f46d5752f4b0b28013951204571262795c38a2f3526667ede2b39a53c595a57d3ff13061f4e21d661f9da3f998379bb864b9789647e9d7248cc5a75789f6d90a520f8ea151c83ad57dd9860cba196eb1f49d642274b133e7790311b0bbf86d09849469ac6d09f3b8b105dbd565d04d42a0c48703bff05ef32f14a261f0b57b67968c4585c6d027b2e2162ade9a5de65c5ac939b7eaa0bdb3e67a24ba2c44526d19d39277c8e84d43f298d6d10e7e3d970a9c339a0bcb632ecb7824f2e1cf55982bf2e20049fbed5c8c8c7818990a6be94ab2f9ac0e2fc24f29e65f22c35abd68aa7221a43463465fd0e61c6cc22ea2a7bd6366df74123b3776c1a02bd4f7c29fb975102074db2179cf4410e990292086c9d8585fe8f08806a777677d6da0a40245de3b5438d8d81c9788a057fdb805623aa46d1ad352d48a72e44221a58b7844e8dd890c13d56916b9981c99239afecf79348d37a1f1411bf5e367fd004968ebb54b5a82df1f4126c5f5b2d2629219ea799398f86ceba5383ee65f4eed80389922906e1435309d9ef8d149506736f85ab958062e681303d125bb1c9e97a613ac3edcb10c31adbefb51775bc575efcd185550977fa1b4f5e0feb5c73070c5c8b061d5347ad2c9f13b3a9a9419da129ddfd294f625bdebfd371463b78af18c01e3e8fc0680b8ea02e64a01b00936b8eb9fc2492d2f591384a63d87fd343ef9c0d16b2045819356e207a99e473e81536ae0f42523e8fde7a26c03935d418b31153316d2bdca36d6de50fa179bdb00ea3fc915d4164291eb205d3cfe023d2594cc492296af4419aa4cdcea8f113429fbe6441214031f9bb61863d6e882cfdd17912ca6412d260bacf103401b4883ab0d38f603379c6d6a40a181d04561d01bb910050d8ccd654449b89e25a574e51feac0a3020f4f6ee1b0d1f8cfd8f57002e7a0685c177eb1ec24cc7701beaa57c6387f6a97dbacb39d293ee60739f89c7c355773d2570e7c2b545fa9545e8781b99e0931c7f812fad26a29d4053bf01729564c196b5b58fda252283e669b85265a6b749011377f5d398cdcbea63e1fc0d197c3a9fad9b0b60319e0066554cd7db995809745cab568e35b8f6e6b0c6e76071c03ec056f597910c84ba740ca08399b26bbbbb09b81ae6cd8ab57b90b18e2531501708df07e296101577d548bdcc8d4fdaab8718802318acc5893c78c464c0a77dc0c54e4eaeba4004e50386f6756e38efdf108dfad00e8930c4d6d31a49d35a1563035890c048d948d9c0683225c3605c30a6cf2ac3a81d86169d1de9e78dcd685c925f20ced1af9631437d49f6b75903934c04c940ad07b336fb88a902e84bed353575114bd95838c98c321057df97a109b117f89213b50e5b710799739e8b7dcfa3f11d9bc46f3b4fbf3a2d102903bf28e5cab6d8545286024347972bc186600836c80d3626fec2755af9f9f92662ad94b27dbc91edfb1ea49642d27f26dc794203750a8faeba471d90a5e5dac7dfdde0131d38fb144d089bea1f94f9d8d0957da2746214b15a877f68ca4dcb349e21b8885ec6f143b15a488ea18bd848a7a6e1c27da5748bc265b3048d8a88f06f03a0c989e55d452b5157a3b58e0280c9f557e44401cfa54041636ac3c67ed34df492359449e512034140f528c17a84057f496148e58fa740fa487a8907d40355a9e78d59cf08c50b216fa9b2851647ec75f3d34644a83bb77392c89b2e9759aac18884217a9ecfc8666a227dd03a8559a81cd55a6f47eb20b95649ec65ddf07b0843ca59ab9dc44103b4b87f0eb1febdc86c898890bf711e887d37e78754d5ffa366e759ad654d6f82856ccb2b535d9ba7b98cc88cc658b1a1eba1e340d2bbfb413e810b55850b01b530a1dd4fbd937d560d17ee03df69352a15cbe1d7186aa5485f6144ddc6c6ab09b51cfb9ac07da8a5aadee92603ef9cac09fc84b54d74b758334255dc85203e17e36661870c34871c992016bc2a730fb42ad6d1d3e482c70cba1359258a74e238f998f1c59c9e768c8bc9e0fbdef8b98fa5a74918fc6db83e359fbdc31d6d026cdb202e718c9fd981cfef8d01fcde31c00ca5b75611d3713176085d003c1ec4fa8e83fb2a1436881beeb04462c30d2fa8a9f4e878ddc2a0f594d465728d381d1d80e599b476f1b9f5a91f11153f362dfcba0456c43c71fb4f70c48c91410dfb16b18d066ae4a06f223ed8cf4fa53654cead8293cde8275572b8838507d21732ca2f700fd1660236b0be53430a3da5156d4d19407f424f753a0b3f4cb19c2f087684749369c29e9daf20623ae525c5f74c0874f5cc6ff2d155416ab5a810beba4ad3dfecd036a27aa9c94d98ea54f8fc6a80d059459090c5bc9e712543566728a864b505c08bff6bac63eb3752fafff8fe32145dea5caff55bf7c83d562fe61c2a93d8fc9d3b32d0618ea8bd7dd86df76d79358c1977022b8505353f56b868c4484bab4628a6fb9c851b4b9c4788a6d2fc39f75ae8d019c5b01816679c95f17e7b6c3c39a190187ddc820443e1fb9bf6efb813c35d9e7d63b8a593317cf17121eb6e4fd01ea54bde115843d1346933c734c474e5d00c24d29ba32ff22973c84b4ce33c60ef1f629211d1208dbc36aab2ebb540538e0b416872a7dbdaa0d2b9b8c9831df92faf5471a77dc7cf44c0fa7cf770efd0c5b6e076d71aed1a8b8b0bd7be13c3994dce97c12a56bf5d1af4a2d3ae5d973b5223500bde618bba864044fec110adb7837268cd05b73a4f8a6599ee66f19a0ca64e032f085758e4c4e4802c3dd6d47df4a23a50e23ccfdc3bd7a716237534f1f3b1d3cc3a15e878345c5f130904f1e8248df5120f82e9255c0cdf991d3456cade65f2e6230f8292c3cdb8a01b4b8ffbf4de2f56a27af7805ff0e302e16c692f150854dc9f8867d8fe86565f3ec162600662467c9663751be66659b27666662a58181fceaca371e75fd006d39672c8aca13948d69c733c0fc58570aa73a6fca0ed5ba5866d5d520b10f084ca199574eec5070239c0e666c5fb8926c4ec9579405e9565728476122875d303c8fd23887789b60e0ed76d030a21362448896a56fbcd912f00fdf2da35047b9a50a8183661ced1f027e14fc2cf8c7dfe1c6fe65304e4f796bdc54e35e7d16a990c1ace4b1362e67b9d8fa097b3073f7ef35792f3f6d6b7b5af74356fe7dbe66a104f042ac0c7cea568ab25af426e8f61cd1aa7b6e8e2e952ea23a82f76f70659c0fb404f1b90a42cbd510cabc20e0768ed5b25f2af511d3bfaf07ab5903975a727edaa52db581151bb8364493ac697a7e3e18ce5d18101b66094f2e5768977eb834fad97afb9ebd1427041822dd84d1415f13eed5ab4646eff2720a4bff88dca2a3e6b5ad59eec0a771091171b770b6225b0746dc28ac7bb63a0909dc4d2a80b6c8b03593c5f416d4a9f1ba4a84a431c36e5f662ea314cd0bba9b956cc4a76079be932dbb63193b01778c9d6456b69c7927cd7791fd533f258f00f8333037704e560f0b86762dcd17cb3e19ad7cd8d9681d2e68c538b0e1188ba4e9a84286b1fff1bf5008daf19a578021df1142c86d92a262def50a0e01f2033ed06c27db187d574a7e591b8ad554b4881170437a0a192b36c708d93f5e2dae6e2e43a79e3f287ba313c60d641f3f218c42201576a107b7de664ed9ee5056820fec9c32a4e1aa5f4b19e9af9dc823e6a958e0da051a3e179ccfeb02f91225e306b1b4c06e910163db3dc9abe6f6bf83d1b5f125c3081a2ec2490d9cc8190a2f9198602a213d015e5d1a56fe015d3d0780a893068f5876bd7e77eb76c882234d9b86a2d0a0db22a24364f560892ee5dbdaefb586397ac3fa2fb6a56d59279f41e35eb9204c90d4d7b6c9ec3d7829662af25bc542adb1793051934838abbd3659b13d1cbe1d2d45a3ff3b449ce0e00ff3f9decbe9a6792f0f70d308368ae5d002e0abb3391c58d185d65db671e3a7e00556c2099777ed7262b154d9b898d8f53b6e24233d68304e10a95434b23f91019d452675fb23880a5d1af95486b599e0f5e9e026c2da2f070db577e0941f0a0655622d2655ebdf3709655c160bd8b77f8fcf778332618b77b13f8adf6c3e397186f217f25c8dc3bf3247d4a7d70ccaa4b6b9a5ae9c16e6d594c9d8105e3273764ffe7c27514e6f2004a44cf7a3b18a6ef6f48366e02f7bd2071867511c228d39e65b021d5b1cb3467e622650a96d76c36fad0fe61f485648a62e4dcffaaed20b89f20f28bdf0a2dcb66250e3abb7abcbc85cffe0d2ca6ea94d7760988c194fb5d7fd3837d49a58b5dfae136d10a7b230f0f8e836fd535856be5d31fbcc23483ee666240753cc01004eb775915d370b7e5e61f4e853d56a0b7189670b3954efb60d995302edc49c2812b6e23d4fdd003d7d860ed2167b5704cc0cd0e9cef0679f8223ceb6e1fe4698c38b54fa126553d64183c731c64db3e60d5162d6433cbb804e62597d76509d5c9685320a3fbf49b32695faa7db6228c9f9b0b4a35defd7290a624fe93a6fb9c741fee7b62a8fa45b74cab83641714aa2367e0d01fe47bf32beb898ec07231b3aa1b38688d5a04353531e0d7da723f96865e3bfa61f5ac0e62126d06b7ce6dccae33c18a5422b830281b314e79907248c44e07d688044611554e92332f63ddcb727f2351d2b1b2009a838580a916212340207a0ccd8fe54d534654121bc3eb5bf92594cb09e9f6e3ff9b04d46aed3323c815443821eb3ea4152ba3296fbfa304b27a4eedbd50166dc05cd931901576f825c67b806648d1b5fab0792cb932c9da18f63b813a8d6dba749ca42014f5855bc5ff3b046798d541727f14c7382724d3c913f3d7c50fd35500cd2bd9bd8587cab6588ab610f50e74e30fdbadff6d384d526543e2d3aa338d4afa13e40d8e2123c4084b4f8b7798d16720605fc9af5ada1406f77d8ac8b59ce3be48432bed2f274927df7958cd4e06b66faa1913db32d8900b40e56a548d6fc4e232ea1b74311a7710248377e733c48bd0d46887792f0a9b0e7d216cd2b21f4e638ac66ecdf677d3e91cbcc4d731943df03046db506f5837ca22c22b3aed78c1b0aab77221292b89056ef4d888dd85237a25e59524d7624dc388aa6cd5cf554852d2b36430a234ef1e6ab3da2031fe405b93f736d127e09935f20ebcb555f343bb5fae103a1fc4b9e3ec3ce0af6e5e85a9d86326dc0030da46eac988abc866112866ebe84199cdecad96d36c987224ef98b22a9d270a4013389be65ce55d484cef5c801138a960ebec44c4aef8ae5b8718d1abb891bf5ca2584b65d96091bca1488971dfee8f627e3212c8d103eb45302b9fc8f6c2419380a522b6bced03a5988ec24ec36763a75494918d92b4e653b58716e8180e47ecd2b678ef79003998119e29e52a50c2a74fb5100ea7a1a5fa67bb67ca846afa6b864b1b468820bd8ae4231acb5ddc015a3cd963d9666de06474f43ad90667be20c710c3b033ef72a4ffb481cd729411d923db2e38c3341d5ba0ed3a27f7193ed5956d66f1483c0144d6e1454a327924d6b629d49386439151bbb4c1306a00979079464cac3fe33e8b6e09137b9ec093c018623b04a308fea6878402ee070a3f7c26217eb6c7fc6406cf64187cf87083c7d9940a80e5b13cc7bb55407552c13fa79ef5a1445328e0e9bc18da94f2a575f9f04230b6967123161dbc6922a2bc31a82b75260aa7e056648396d2aeab1242f94f14eaf324ef45d7f8e03cf7a028e001bdff9a9da6554002d4ca100d87fbcc2532d28408632aa7b942deba55be67d88bcfef468779f1e335ed95325c115a8775b2db5b17781d40eff96dca6b005ef725d12c7aa40452009c41ecc064f08adce799f6c992b06d3f2122b7158c37078cd386f1ee858841492cd6e437ec73ec54f1aca0ff95222195d8467cd2bdcdd122892eb69dcd0e7cd2f806e466783e6e87ac2de142e0eeed00d986c5c377d118381f823b1fb9cfbc33cf9249a2dd3d02600bcaa9caa9681c68e6abfda69d853d2659695883a4900f57745843ba8b1e7bdfd5016648db753808e4f4a79bcc7e97e226ecc11a0cbaac86cd402635015535e7d669e848ab830c5c1d0a40f5bc674f50a4012d2f95335b2e565f825a4c8fbd0e4a5fd8516f27f631ff6a8e91d61e8f01c03951c823c02df0947d144b6c74e0e61079aef2b2edc156ff6cae495bb2c3b4d89ab8b5415987fdf1cca52a1f9109dad56c26e607a0cb982686839c0a87389b56aaa7da630aba41504a2434421aaf83e89998085abfb4e0a9e5bab7662df045b7ebcc64419bd2297d6109328215fcec8d3be12b15ee8d23ad4bbe5a2cf289b1b0a98abe4b50d878fb6487faed9573c8dedf75b5518ebc0d89f374c5022ce8a3e8614b2efcdf55ece387c541c5315bed2a101b64f68be28e36b5f4453bcf66f958977b5f4c71948a42a13a6d3686513c895a8e788a7a11715c7924772c8b95292559d71f60578ca573c56ce6d865cc93988be901b91ae3e7cd709afaac5dd8deba9668ef27d7644320c8035f03645d6d14e392b1a33e9ca1952904557c625355b96b4ef6038c278d24541c29dfc9220ed49a46b35bbeb2c1d9e93afd0cd3797350e0b96d0466f8a0d1da843c8f0609e74e13bca039770814cfe253defbedc6265ec280770e5bc490c3d97d8c81049974a3e062d66b74a028e6847736a16caeed3c915c7f32796eaf974abc59fb554a7a709e614a4203ecf88da8ee63ba35b12cc1d9207e71e4732d57d66dc7e8e08bd067ad7e9a1106e35e287acdc344d423a197f69293cb8660f3579d867e2f172fc6195283c0d0ac5c31ee47f241b8e5f177d5198eb340fd565fe845b294fe08861a780ca56b48dc24027dcd3111cffa564f6e1854f801593e14b3cbdb436c1ec2fa42631fac10b8039a2f0699b4befe61ad49e67b84b84068a9ea8e4590e2830ea462bc69c8069ceab80cddb22b56926a01035fb0f60a0487bcde2d90bd7d4e7a0566d4f3906472d6f970a88e6fca0f9d130f6d498012988e90fa38630c34e329eafdf49e0263fa8328a926dd40da1a711a219e6c037993f9c8739711a4cfcc111834a3df91540b3c559bbd9307b5f58c975a10fcfaee8d90ea412605545d3b34062c224bdc83f1c3231036a4d7e6fe3638a64231d223bac37c5857223a096150eff6156205b43886e4168d3371b5541db0160a9e5385bf931cddf910e08b8ee728abb0558801aebc51400b8913e052953535ce576074bff8156e522fcc43542369f542241ef1c61e6f7ee4e2a97b306d44a3f7dc8123b6f9b49e10c06f1a283d12d6ea6c2f397b14aaf5e4899c33a58fa2a89adc4977433fa4fb8835100e36bcc916079e007331880be8029c867449a28d77d1a5dfe96e59fd6e085f536aca50d431d844d3bc8852f5f322f9629fb56a31ef7dcacd05cad53c6a5874548fc3b24584c8da26ab035d23b82bfb288355e2ae68ff9746ad4f2e80f6b970763b6cda25298b9f623515da12a89138e0b797e8d572860b9214bf3159f2dca5ad867ce89c5e0c7d79bd4622660571095121fc2283a3097569e144bd2e53ed47daa9924c7b6f61c0fb5bb8e828127c4ca1d9e49559edfa89d10e10faaa5d2c9e4d74050c71a0b2ff54bd15309b6068cf0e157c7eaabc00abb80c4da8e861caf96b8af0e7ba3a42bdb558b421b9a5f81b0cff6113677a20ff69e760ad960f1b4ac0b9f6810d7f3a87af589a5bece5149e3e9be2af87d894d7718e9f5c991757fa92575b49c1d874d4d0f8534cdc0026bf3839f92d35b0fa3cc2f8b4578cb252391f3b876ca90bdc783d1c211d35de3596bf66371d6a17310e0a31f9392cdbd3041a19ef1383805b9ba029f03abdbe4deed5a9cae4bde78cbb925eed30c62d3cea346a97914f1e980e2982d3c5a45142b364fa7105cadfca4d59b0145bfc1265d22a5b6c64961536619c3e5c839d66d5b33a59438c20817cbbc034e67d5443a148c88fd024c88cf262a84fd7a5ab2e9c9775be50fa7ea5c00fd2cd7b388dff47be25fe03d83b922a9b06f7a0d0c89aba526f5131d8000472809d506d14f5abba119bbcd041be3ee98353668d322b154929952997654a5424ef57c572f250c10ff72b2c364f079753309b77f5f0e7fa8cba9a2a91cda72d09cc4ca40b19685a682efb522596cb3f9aee0893335916fb4e163f008cd5e89ac560c6cc43de23744de4b5fdf9a850bca0643a0627309f7fd61ad6a1406123365c519d44a0fb44bc1534f8b117545684a49c0bed64ddb9a96af5e1ea936fbde1998df50e0623623eab7981b05878fb10d5f3b3aafd7f93a7710033afa686c6c099fe0d6294b904b2104e9836a52b62530a25823f313e27c995b2712fa5628bd22e1b7a0184adb1d877e7ba0fdb8b3cb053471064c23178a67163553a4302e680404ce474c58e4f403a9a292edf909673cd904f79cf8b2030653d285d2aedfda55f15f32dc4a01ddcc7c0e5306c9624db24d4bee319a94c373a0cded66bfc032c6b4aa15036761fbf988ceb93e08bab8d69dcf9006afa3a27f36727f4eefc3e85d92a6c012ab492e25cc96658080f17b0082c4bfb479ee0796005f1c7c875f44829bd67aeed1d789a18829b98b70f7dd2d0a06cf09ffc4d012987ed0a6b62ef2e2e947cd54838c9979acf29efbaabe3b0857e015c7d501630ebeec2e7a2399fa6267471529105df52383cc24e7d7f8c779624fb72ae69a05bd17526c651c37ab825c11d29a9be306a2d699cc0746f62445db568cbf298b09c09f6e9723ba55f238ee348593338749600f32d076268714265897c21b43c7b97bd1d4f8218cbc516ba8b80d61f564cef4193183a94dc0958aa39b5db6103798b00f8b6ea6093dce4ba6b75b01dd4388ab7138022e3ed8780a3b9a24cb6d8b5e7a5e8c93ad25420616347589b77a983d3b2a9180ded5ef1e0c05a9ec287fe27ab10106df284312b7245b21fb429a708170f55299469ac2c592ca1fde23fb804b60ff340681b2fa50045a4a6d83aa4df8d765e18d9617806b87fda8c978586cca69c613daf6d1858eb170fb33e2e9d15d55622159663d11a57bd07e2f0b391c09a1ea3a04155cbcf0ab0f7ba7fe2dbc212c02efe02b025ddb8ce92212e03664cc35e8df514c3d76a0030875bc8ce0034c7a71ced3db5e5a8b1231bec224e41e95dcca83767ebe4a75884e8440dc48450e7edfec9f3eadebec6fb559fb0df23b5384bdc80ccef51e62c3ee21c4a62a14052ca1817d202049f3fe78cd2c190e47a5aa7d0f14a28544a7e5d626681ca55f1a41d643df1d75e46301b4352d009de7ef16835de9250c98a5491a755da1427ed35681ba72564c2e10a16d420d80f85d5b3ad38273c91164e2564344cc8dae262676adb17c135767049a82d991e1ff9de590ff865c672ed2872f29435f0eaff633ed07736f5f5266c69bc4e0b2700f90ecfccf4db3077e69e0a2219cf8f1cb2d9ad84865a5801756afb2144605d649832d533729de003ae35050a2cece01c5933de11503ebc25613f081205b967e58082abe6020050a10f1cb4c0e0179af9e5a9ebdca1f29711e69f20522b4311859c2906773a4bf89a875da65f3e833a6e8149ad8f4000d018f75efc733d31ea16b58297b06be70286589b4e905fb633acc05b57547af3c4cf593de0083dd42bc8de4ddc071eafcb6af523ea115ffe5ff90f0755093ee3a35fc3c2b4074ddc233b74fdda69995de6795aa1ca6d9e4e4b06970f81ccb5c92d154715eaae5634a1799b799a3f1a71b5f4f5248c52eec9e3045d08367b5fac05b26aec17a65323d3fab2749f3b4d71a40f2978a43935d52c31a4f52e6aecc85e3f979f918d427ae7d1cc9acf00b66f20ff2aa59001008812e11bf204ba042a2225bd2159870457b0c580c6ef6a85909c3460261f6bb9492dd7710d135e029da1aad2350352cbe04b221016543e3b323769c7b691296eb1b4ee98a206808969fa8930ea4a6af46ee36ab616e8e634eba0ecf2bee49ab2562a11cb1ea4475bcac4e217df71dfb4d954d02c16f4c2a0e9b9b994299f8bb97d096a2b2687905b9e21e0491adfede9c081156385ac90284ddaabf241861ccd1e30d84de97e3c523f614203d863bc763c4e78839744678d52e5123cee98dd7dfc568d0b21287fc3dd2266902f7378684a5196b18278069d60cd8ff3d16963c35c366fc020bd7043287a98edfc0bf9fa7eccd7bd89b4aef8baa59e91a50a86f99216ad174147883d5fb97fcdacd312512b9f83c36aceb871af4459b5647cf2ab500201cb717e9035be4b10c125f3d4967af0942baba11b3facc4310b448e79c755d8c8f62d5620d1a4bc1e1098bdffdc9d3e70bb9db8ddb5f95f0f0f4e4c3cc5454a6893cfebf91ac0e1c18683f5bbcac554a1c31e082c89725ba99d9f0313f8120fba322ba34601e9fa7870e4a8c2b6e977288587e62cb5535a3684daa1043abd72776b0a46149e6d89e59b4939a10aa96399287647622f39dd8e648ab8ffcb7f433972c7d73abf1444002a1917a1cd57c5a86e10001a49dc2399c8dc93fd4653fb9a79bd6b13bdd31849daaa4addc9087c41e824de5935a99421c29bb6a8c1260baeb341bc1b736a9a949d7032ecc021ab0cff0354779a320002b05cca9980a9b730e05b660a334c2682e764434b3c58f7c2621de5e1ccd65e0da0b196c1b10364a8ee18b6a35ffaa3e6dbe78af058201c8dca634f151d0f2b706036ad3f8629be0f3586bfaa7c830f2cac07b53d92f0e555ad136d5ff79dab83f4d975a31397f7a6bb1ed7c05692614dcf54d50faad339df004f714ced17f1ec9b0a74bebb7b94e7c185c1a36f22d9cf3c0c92bb8ea0703b788a2aabd82a5a3a96457323451f4b8d5a2cff8a67766b5be45707ab4b2a1dab015d4740ad24be6ef2130036e18e41c2b7917a6dbabcb89422282a3989081db7a4b73bde287aaa6df8985e9c02bc30e61af1303acbc31f5c1936ea76cde739b8f83aeafa833e816dca3bf5ad2982decaad10b6cb25229ee6d146d1a731f82afa1fe0e19364f6215df32fb20417ff3552763cdc5d3e45db8e0a7a2352b92ff50c97c14acc4d5191ead153d4bf068f60cfa96412dd6c33926d30e5c269505</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>小张日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小张日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 基础语法</title>
    <link href="/2020/11/14/Python%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/11/14/Python%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>这里记录了 Python 的一些基本知识点。</p><p><em><a id="more"></a></em></p><h1 id="基础知识">1. 基础知识</h1><h2 id="编译器与解释器">1.1 编译器与解释器</h2><p>编译器/解释器：<strong>高级语言与机器之间的翻译官</strong></p><p>都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程有不同而已。</p><p>用一个通俗的例子进行比喻：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。</p><ul><li>程序入口的编写：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    print(<span class="hljs-string">&quot;hello world&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="标识符就是变量名">1.2 标识符(就是变量名)</h2><p>所谓的标识符就是对变量、常量、函数、类等对象起的名字，变量名。</p><p>Python对于标识符的命名有如下规定：</p><ul><li><p>第一个字符必须是字母表中的字母或下划线 **‘_’** ，标识符的其他的部分由字母、数字和下划线组成</p></li><li>标识符对大小写敏感，严格区分大小写！</li><li><p>变量的命名不要用关键字和内置函数的名字</p></li></ul><p>一些代码规范：</p><ul><li>变量名全部小写，常量名全部大写</li><li>函数和方法名用小写加下划线， <code>count_star</code></li><li>类名用大写驼峰，每个单词的首字母大写， <code>ThreadMixIn</code></li><li>模块和包的名字用小写</li></ul><h2 id="变量与常量">1.3 变量与常量</h2><ul><li><p>Python 中的变量不需要声明类型。变量可以直接使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">4</span><br>b = <span class="hljs-string">&quot;xiaozhang&quot;</span><br>c = []<br>d = <span class="hljs-number">9</span>-<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li><p>用“=”号来给变量赋值，从右往左的计算顺序。</p></li><li><p>每个变量在使用前都必须赋值，变量赋值以后才会被创建。</p></li><li><p>在Python中，变量本身没有数据类型的概念，通常所说的“变量类型”是变量所引用的对象的类型，或者说是变量的值的类型。</p></li><li><p>Python允许同时为多个变量赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = b = c = <span class="hljs-number">1</span>，最终大家都是<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure></li><li><p>也可以同时为多个变量赋值，用逗号分隔，逐一对应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>，最后a是<span class="hljs-number">1</span>，b是<span class="hljs-number">2</span>，c是<span class="hljs-number">3.</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Python中，一切事物都是对象，变量引用的是对象或者说是对象在内存中的地址。</strong></p><ul><li><p>栗子：a = 'ABC'时，Python解释器干了两件事情：</p><ul><li>在内存中创建了一个‘ABC’的字符串对象；</li><li>在内存中创建了一个名为a的变量，并把它指向'ABC'。</li></ul></li><li><p>栗子：a和b是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;Jack&#x27;</span><br>b = a<br>a = <span class="hljs-string">&#x27;Tom&#x27;</span><br>print(b)<br>print(a)<br></code></pre></td></tr></table></figure><ul><li>执行a = ‘Jack’，解释器创建字符串‘Jack’对象和变量a，并把a指向‘Jack’对象；</li><li>执行b = a,解释器创建变量b，并且将其指向变量a指向的字符串‘Jack’对象。</li><li>执行a = ‘Tom’,解释器创建字符串‘Tom’对象，并把a改为指向‘Tom’对象，与b无关。</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141413.png" /></p><h2 id="输入输出">1.4 输入输出</h2><h3 id="input输入函数">1.4.1 input输入函数</h3><p>input函数：获取用户输入，保存成一个<strong>字符串</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>inp  = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input your name: &quot;</span>)<br>please <span class="hljs-built_in">input</span> your name: jack<br><span class="hljs-meta">&gt;&gt;&gt; </span>inp<br><span class="hljs-string">&#x27;jack&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(inp)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><span class="hljs-class"></span><br>&gt;&gt;&gt; age  = input(&quot;please input your age: &quot;)<br>please <span class="hljs-built_in">input</span> your age: <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age<br><span class="hljs-string">&#x27;18&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(age)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><span class="hljs-class"></span><br>&gt;&gt;&gt; a = input(&quot;请输入一个字符：&quot;)<br>请输入一个字符：<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>)<br>请输入一个字符：   前后带有空白   <br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;   前后带有空白   &#x27;</span><br></code></pre></td></tr></table></figure><h3 id="print-输出函数">1.4.2 print 输出函数</h3><p>普通的输出没啥可说的。</p><p>说一下 <code>print</code> 格式化输出。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141451.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141504.png" style="zoom: 67%;" /></p><p>下面是一些经典的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;i am %s&quot;</span> % <span class="hljs-string">&quot;jack&quot;</span><br><span class="hljs-comment">#i am jack</span><br>s = <span class="hljs-string">&quot;i am %s age %d&quot;</span> % (<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-comment">#i am jack age 18</span><br>s = <span class="hljs-string">&quot;i am %(name)s age %(age)d&quot;</span> % &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;<br><span class="hljs-comment">#i am jack age 18</span><br>s = <span class="hljs-string">&quot;percent %.2f&quot;</span> % <span class="hljs-number">99.97623</span><br><span class="hljs-comment">#percent 99.98</span><br>s = <span class="hljs-string">&quot;i am %(pp).2f&quot;</span> % &#123;<span class="hljs-string">&quot;pp&quot;</span>: <span class="hljs-number">123.425556</span>, &#125;<br><span class="hljs-comment">#i am 123.43</span><br>s = <span class="hljs-string">&quot;i am %.2f %%&quot;</span> % <span class="hljs-number">123.425556</span><br><span class="hljs-comment">#i am 123.43 %</span><br></code></pre></td></tr></table></figure><blockquote><p>注：如果你想在print中打印一个%百分符号本身，那么你需要使用%%，两个百分符转义出一个百分符，也就是print(&quot;%%&quot;)。</p></blockquote><h1 id="数据类型">2. 数据类型</h1><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141519.png" /></p><h2 id="数字类型">2.1 数字类型</h2><p>数字类型用于存储数学意义上的数值。</p><p>数字类型是不可变类型。所谓的不可变类型，指的是类型的值一旦有不同了，那么它就是一个全新的对象。数字1和2分别代表两个不同的对象，对变量重新赋值一个数字类型，会新建一个数字对象。</p><p>还是要强调一下Python的变量和数据类型的关系，变量只是对某个对象的引用或者说代号、名字、调用等等，变量本身没有数据类型的概念。类似1，[2, 3, 4]，“haha”这一类对象才具有数据类型的概念。</p><blockquote><p>例如：</p><p>a = 1 # 创建数字对象1</p><p>a = 2 # 创建数字对象2，并将2赋值给变量a，a不再指向数字对象1</p><p>这里，发生了变化的是变量a的指向，而不是数字对象1变成了数字对象2。</p></blockquote><p>Python 支持三种不同的数字类型：整数、浮点数和复数。</p><h2 id="字符串">2.2 字符串</h2><p><strong>字符串是不可变的序列数据类型</strong>，不能直接修改字符串本身，和数字类型一样</p><blockquote><p>注：中文符号 &gt; 字母 &gt; 数字 &gt;英文符号</p><p>例: <code>print(min('今天是个好日子！'))</code> 返回 ”！“</p></blockquote><ul><li>字符串的拼接，用 ”+“ 这个符号</li></ul><h3 id="常用函数">常用函数</h3><table><colgroup><col style="width: 34%" /><col style="width: 65%" /></colgroup><thead><tr class="header"><th>函数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>upper()</td><td>函数的作用是将字符串中所有的字母大写，只针对字母。</td></tr><tr class="even"><td>lower()</td><td>函数的作用是将字符串中所有的字母小写，只针对字母。</td></tr><tr class="odd"><td>capitalize()</td><td>将字符串的第一个字母变成大写，其它字母变小写。</td></tr><tr class="even"><td>swapcase()</td><td>将字符串的小写变大写，大写变小写。</td></tr><tr class="odd"><td>zfill(参数=新字符串希望的宽度)</td><td>返回指定长度的字符串，原字符串右对齐，前面填充0。</td></tr><tr class="even"><td>count(参数=查询某个元素的元素)</td><td>返回当前字符串中某个元素的个数。</td></tr><tr class="odd"><td>startswith(参数=字符串)</td><td>判断字符串开始位是否为某个元素，返回布尔值</td></tr><tr class="even"><td>endswith(参数=字符串)</td><td>判断字符串结尾为是否为某个元素，返回布尔值</td></tr><tr class="odd"><td>find(参数=查询某个元素的元素)</td><td>用于获取子字符串出现的位置，如果存在则返回子字符串中<u>第一个字符</u>的索引值，如果没有找到则返回-1</td></tr><tr class="even"><td>index(参数=查询某个元素的元素 )</td><td>用于获取子字符串出现的位置，如果存在则返回子字符串中<u>第一个字符</u>的索引值，如果index找不到元素，会导致程序报错</td></tr><tr class="odd"><td>strip(参数=想去掉的某个元素)</td><td>去掉字符串开头与结尾指定元素，默认是空格</td></tr><tr class="even"><td>lstrip()</td><td>仅去掉字符串开头指定元素或空格</td></tr><tr class="odd"><td>rstrip()</td><td>仅去掉字符串结尾指定元素或空格</td></tr><tr class="even"><td>replace()</td><td>用于将字符串中旧元素替换成新元素，并能指定替换的数量</td></tr><tr class="odd"><td>isspace()</td><td>判断字符串是否是只由空格组成的字符串</td></tr><tr class="even"><td>istitle()</td><td>判断字符串是否是一个标题类型,所有单词的首字母大写才属于标题</td></tr><tr class="odd"><td>isupper()/islower()</td><td>判断字符串的所有字母是否都是大写或者小写</td></tr><tr class="even"><td>split()</td><td>连接字符串</td></tr><tr class="odd"><td>join()</td><td>拆分字符串</td></tr></tbody></table><ul><li><code>spilt(str=&quot;&quot;, num=string.count(str))</code><ul><li>str -- 分隔符，默认为所有的空字符，包括空格、换行()、制表符()等。</li><li>num -- 分割次数。默认为 -1, 即分隔所有。</li></ul></li><li><code>str.join(sequence)</code><ul><li>sequence -- 要连接的元素序列。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">li = [<span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>]<br>print(<span class="hljs-string">&#x27; &#x27;</span>.join(li))<br><br>b = <span class="hljs-string">&#x27;my job is a teacher&#x27;</span><br>print(b.split())<br><br>b = <span class="hljs-string">&#x27;my_name_is_bob&#x27;</span><br>print(b.split(<span class="hljs-string">&#x27;_&#x27;</span>))<br>print(b.split(<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>字符串和bytes转换：</p><ul><li><code>encode(encoding='UTF-8,errors='strict')</code> ：将字符串内容转换为bytes类型的数据</li><li><code>decode(encoding='UTF-8,errors='strict')</code> ：以 <em>encoding</em> 指定的编码格式解码字符串。</li></ul><h3 id="编码格式">编码格式</h3><p>对语言的解析识别/标准</p><ul><li>gbk中文编码</li><li>ASCII英文编码</li><li>utf-8国际通用编码</li></ul><h3 id="格式化输出">格式化（输出）</h3><ol type="1"><li>字符符串格式化用操作符 <code>%</code> 来实现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;my name is %s&#x27;</span><br>name = <span class="hljs-string">&#x27;xz&#x27;</span><br>print(info % name)<br></code></pre></td></tr></table></figure><ul><li>格式化符</li></ul><table><thead><tr class="header"><th>符号</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>%s</td><td>格式化字符串，通用类型</td></tr><tr class="even"><td>%d</td><td>格式化整型</td></tr><tr class="odd"><td>%f</td><td>格式化浮点型</td></tr><tr class="even"><td>%u</td><td>格式化无符号整型（正整型）</td></tr><tr class="odd"><td>%c</td><td>格式化字符</td></tr><tr class="even"><td>%o</td><td>格式化无符号八进制数</td></tr><tr class="odd"><td>%x</td><td>格式化无符号16进制数</td></tr><tr class="even"><td>%e</td><td>科学计数法格式化浮点数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&#x27;%u&#x27;</span> % -<span class="hljs-number">1</span>)  <span class="hljs-comment"># -1</span><br>print(<span class="hljs-string">&#x27;%f&#x27;</span> % <span class="hljs-number">3.14</span>)  <span class="hljs-comment"># 3.140000</span><br>print(<span class="hljs-string">&#x27;%d&#x27;</span> % <span class="hljs-number">10</span>)  <span class="hljs-comment"># 10</span><br>print(<span class="hljs-string">&#x27;%d&#x27;</span> % <span class="hljs-number">1.2</span>)  <span class="hljs-comment">#1</span><br>print(<span class="hljs-string">&#x27;%s&#x27;</span> % <span class="hljs-string">&#x27;123&#x27;</span> )  <span class="hljs-comment"># 123</span><br><br>print(<span class="hljs-string">&#x27;&#123;:f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1.2</span>))  <span class="hljs-comment"># 1.200000</span><br><br>print(<span class="hljs-string">&#x27;%o&#x27;</span> % <span class="hljs-number">8</span>)  <span class="hljs-comment"># 10</span><br>print(<span class="hljs-string">&#x27;%x&#x27;</span> % <span class="hljs-number">32</span>)  <span class="hljs-comment"># 20</span><br><span class="hljs-comment"># print(&#x27;%x&#x27; % &#x27;123ab&#x27;)</span><br>number = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;123ab&#x27;</span>, <span class="hljs-number">16</span>)<br>print(number)<br>print(<span class="hljs-string">&#x27;%x&#x27;</span> % number)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>字符串格式化函数 - <code>format</code></li></ol><ul><li>使用 format的字符串主体使用 <code>&#123;&#125; 大括号</code> 来代替格式符，可以不取下标，取的话从0开始</li><li><code>string.format(data, data...)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;my name is &#123;&#125;&#x27;</span><br>name = <span class="hljs-string">&#x27;xz&#x27;</span><br>print(info.<span class="hljs-built_in">format</span>(name))<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>f-strings</code> <em>新方法</em></li></ol><ul><li>定义一个变量</li><li>字符串前加 f 符号</li><li>需要格式化的位置使用 <code>&#123;变量名&#125;</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;xz&#x27;</span>  <span class="hljs-comment"># 一定要先定义变量名</span><br>info = <span class="hljs-string">f&#x27;my name is <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span><br>print(info)<br></code></pre></td></tr></table></figure><ul><li>转义字符</li></ul><table><thead><tr class="header"><th>符号</th><th>说明</th></tr></thead><tbody><tr class="odd"><td></td><td>换行，一般用于末尾，strip对其也有效</td></tr><tr class="even"><td></td><td>横向制表符</td></tr><tr class="odd"><td></td><td>响铃</td></tr><tr class="even"><td></td><td>退格符，光标前移，覆盖（删除前一个）</td></tr><tr class="odd"><td></td><td>回车</td></tr><tr class="even"><td> '</td><td>转义字符串中的单引号</td></tr><tr class="odd"><td> '‘</td><td>转义字符串中的双引号</td></tr><tr class="even"><td>\</td><td>转移斜杠</td></tr></tbody></table><ul><li>在字符串前加 r 来将当前字符串的转义字符无效化</li></ul><h2 id="布尔类型">2.3 布尔类型</h2><ul><li><p><code>0、0.0、-0.0、空字符串、空列表、空元组、空字典</code>，这些都被判定为False。而<code>-1、&quot;False&quot;</code>也被判断为True。</p></li><li><p><code>None</code> 也不是布尔类型，而是<code>NoneType</code>。</p></li></ul><blockquote><p>平时最容易犯的错误就是获得了一个None值，却对它进行各种方法调用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-literal">None</span>]<br><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> list1:<br>    print(char.join(<span class="hljs-string">&quot;A&quot;</span>))<br><br>    <br>AttributeError: <span class="hljs-string">&#x27;NoneType&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;join&#x27;</span>        <br></code></pre></td></tr></table></figure></blockquote><h2 id="列表-list">2.4 列表 List</h2><p>Python的列表是一个有序可重复的元素集合，可嵌套、迭代、修改、分片、追加、删除，成员判断。</p><p>从数据结构角度看，Python的列表是一个可变长度的顺序存储结构，每一个位置存放的都是对象的指针。</p><p>比如，对于这个列表 <code>alist = [1, “a”, [11,22], &#123;“k1”:”v1”&#125;]</code>，其在内存内的存储方式是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141602.png" /></p><h3 id="索引">索引</h3><p>索引是最左边记录的位置。用数字表示，从0开始，<code>len(list)-1</code> 结束。</p><ul><li>创建</li></ul><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表内的元素，可以是其它任意类型的数据，可多层嵌套列表，元素个数无限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = []        <span class="hljs-comment"># 创建一个空列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>], &#123;<span class="hljs-string">&#x27;k1&#x27;</span>:<span class="hljs-string">&#x27;v1&#x27;</span>&#125;]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><ul><li>访问</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;b&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;c&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">3</span>]<br><span class="hljs-comment">###########</span><br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><ul><li>修改：直接对元素进行重新赋值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;d&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>字符串不可以通过索引修改或删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;comprehensive&quot;</span><br>a[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;a&#x27;</span><br><br><span class="hljs-comment">############</span><br>TypeError: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br></code></pre></td></tr></table></figure></blockquote><ul><li>删除：使用 <code>del</code> 语句或者 <code>remove()</code> ，<code>pop()</code> 方法删除指定的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> lis[<span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis.remove(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[<span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis.pop()<br><span class="hljs-string">&#x27;c&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[]<br></code></pre></td></tr></table></figure><ul><li>常用函数</li></ul><table><thead><tr class="header"><th>函数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>len(list)</td><td>返回列表元素个数，也就是获取列表长度</td></tr><tr class="even"><td>max(list)</td><td>返回列表元素最大值</td></tr><tr class="odd"><td>min(list)</td><td>返回列表元素最小值</td></tr><tr class="even"><td>list(seq)</td><td>将序列转换为列表</td></tr><tr class="odd"><td>in/not in</td><td>判断某个元素是否在列表中</td></tr></tbody></table><h3 id="切片">切片</h3><p>切片指的是对序列进行截取，选取序列中的某一段。</p><p>切片的语法是： <code>list[start:end]</code>，注意，<strong>区间是左闭右开的</strong>！</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141634.png" /></p><ul><li>如果下标是负数，从后往前数，是 <code>-1 ~ -len(list)</code></li></ul><h3 id="列表的常见方法">列表的常见方法</h3><table><colgroup><col style="width: 39%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>函数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>append(item)</td><td>将一个元素添加到当前原有列表的末尾</td></tr><tr class="even"><td>insert(index, new_item)</td><td>插入新的元素，在什么位置。如果插入位置不存在，则加在结尾。如果插入位置存在元素，则该元素往后移，将插入元素放入该位置。</td></tr><tr class="odd"><td>count(item)</td><td>返回当前列表中某个元素的个数</td></tr><tr class="even"><td>remove(item)</td><td>删除列表的指定元素。如不存在，会报错。如有多个，只删第一个。</td></tr><tr class="odd"><td>del item</td><td>删掉整个列表</td></tr><tr class="even"><td>reverse()</td><td>反转当前列表</td></tr><tr class="odd"><td>sort(cmp=None, key=None, reverse=False)</td><td>对当前列表按照一定规律进行排序且list中的元素必须是统一类型，否则程序就会报错。</td></tr><tr class="even"><td>clear()</td><td>将list中的元素都清除，将其变成一个空列表即[]</td></tr><tr class="odd"><td>copy()/deepcopy()</td><td><strong>浅拷贝/深拷贝</strong></td></tr><tr class="even"><td>extend()</td><td>将其他list中的元素导入到当前的list</td></tr></tbody></table><blockquote><p>例：append()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">books = [<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>]<br>book = [<span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>]<br>books.append(book)<br>print(books)<br><br>---------------------------------<br>[<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, [<span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>]]<br></code></pre></td></tr></table></figure><ul><li>extend()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&quot;name&quot;</span>]<br>tuplee=(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>)<br><br>list1.extend(tuplee)<br>print(list1)<br><br>---------------------------------<br>[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>]<br></code></pre></td></tr></table></figure></blockquote><p>注意：</p><ol type="1"><li><p>其中的类似 append，insert, remove 等方法会修改列表本身，并且没有返回值（严格的说是返回None）。</p></li><li><p><font color='red'>浅拷贝与深拷贝</font></p><p>使用浅拷贝，当原容器对象中可变对象中有元素发生变化，拷贝得到的对象也会变化。而使用深拷贝时，不会有这种问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>]<br>list2 = list1.copy()<br><br>print(<span class="hljs-built_in">id</span>(list1), <span class="hljs-built_in">id</span>(list2))<br>list2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">123</span><br>list2[<span class="hljs-number">2</span>] = <span class="hljs-number">77</span><br>print(list1, list2)<br><br>---------------------------------<br><span class="hljs-number">1904206959560</span> <span class="hljs-number">1904227747656</span><br>[[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>] [[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>   <br>list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>]<br>list2 = copy.deepcopy(list1)<br>   <br>print(<span class="hljs-built_in">id</span>(list1), <span class="hljs-built_in">id</span>(list2))<br>list2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">123</span><br>list2[<span class="hljs-number">2</span>] = <span class="hljs-number">77</span><br>print(list1, list2)<br>   <br>---------------------------------<br><span class="hljs-number">1563824640968</span> <span class="hljs-number">1563844713928</span><br>[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>] [[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure><blockquote><p>可以理解为：浅拷贝对于一个复杂对象的子对象并不会完全复制，复杂对象的子对象是指比如序列中的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，python会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。</p></blockquote></li></ol><blockquote><p>例题：使用给定的整数n，编写一个程序生成一个包含(i, i*i)的字典，该字典包含1到n之间的整数(两者都包含)。然后程序应该打印字典。 假设向程序提供以下输入:8，则输出为:{1:1，2:4，3:9，4:16，5:25，6:36，,7:49，8:64}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">8</span><br>d = <span class="hljs-built_in">dict</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    d[i] = i * i<br>print(d)<br></code></pre></td></tr></table></figure></blockquote><h2 id="元组-tuple">2.5 元组 Tuple</h2><p>用圆括号括起来的是元组。</p><p>元组也是序列结构，但是是一种<strong>不可变序列</strong>，可以<strong>简单的理解为内容不可变的列表。除了在内部元素不可修改的区别外</strong>，元组和列表的用法差不多。</p><blockquote><p>因为元组是不可变的，所以不能在原来的数据基础上再添加数据，因此元组占用的资源会比列表更小。</p></blockquote><p><strong>元组与列表相同的操作</strong>：</p><ul><li>使用方括号加下标访问元素</li><li>切片（形成新元组对象）</li><li>count()/index()</li><li>len()/max()/min()/tuple()</li></ul><p><strong>元组中不允许的操作，确切的说是元组没有的功能</strong>：</p><ul><li><p>修改、新增元素</p><blockquote><p><strong>元组只保证它的一级子元素不可变，对于嵌套的元素内部，不保证不可变！</strong>所以，在使用元组的时候，请尽量使用数字、字符串和元组这种不可变的数据类型作为元组的元素，这样就能确保元组不发生变化。</p></blockquote></li><li><p>删除某个元素（但可以删除整个元组）</p></li><li><p>所有会对元组内部元素发生修改动作的方法。例如，元组没有remove，append，pop等方法。</p></li></ul><h2 id="字典-dic">2.6 字典 Dic</h2><p>字典可精确描述为<strong>不定长、可变、散列的集合类型</strong>。</p><p>字典数据类型是基于hash散列算法实现的，采用<strong>键值对(key:value)</strong>的形式，根据key的值计算value的地址，具有非常快的查取和插入速度。</p><p>字典包含的元素个数不限，值的类型可以是任何数据类型！但是字典的key必须是不可变的对象，例如数字、字符串、bytes和元组，最常见的还是将字符串作为key。列表、字典、集合等就不可以作为key。同时，同一个字典内的key必须是唯一的，但值则不必。</p><blockquote><p>字典类型的数据不支持累乘。</p></blockquote><ul><li>创建</li></ul><ol type="1"><li><code>dic = &#123;&#125;</code> # 创建空字典</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;&#125;    <span class="hljs-comment"># 创建空字典</span><br>dic = &#123;<span class="hljs-string">&#x27;Alice&#x27;</span>: <span class="hljs-string">&#x27;2341&#x27;</span>, <span class="hljs-string">&#x27;Beth&#x27;</span>: <span class="hljs-string">&#x27;9102&#x27;</span>, <span class="hljs-string">&#x27;Cecil&#x27;</span>: <span class="hljs-string">&#x27;3258&#x27;</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>([(<span class="hljs-string">&#x27;sape&#x27;</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">4098</span>)])<br>&#123;<span class="hljs-string">&#x27;sape&#x27;</span>: <span class="hljs-number">4139</span>, <span class="hljs-string">&#x27;jack&#x27;</span>: <span class="hljs-number">4098</span>, <span class="hljs-string">&#x27;guido&#x27;</span>: <span class="hljs-number">4127</span>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p><code>update()</code> ：在update函数里传入一个新的字典key和value就可以。存在就覆盖。</p></li><li><p><code>setdefault()</code>：传入一个字典key和value，如果键不存在于字典中，将会添加见并键值设为默认值，如果字典中包含有给定键，则返回该键对应的值，若不包含则返回为该键设置的值。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;&#125;<br>dic.setdefault(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;haha&#x27;</span>)<br>dic.setdefault(<span class="hljs-string">&#x27;sex&#x27;</span>)<br>print(dic)<br><br>---------------------------------<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>访问</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;Name&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;Name&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;Age&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;Age&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;address&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;address&#x27;</span>])<br><br>---------------------------------<br>KeyError: <span class="hljs-string">&#x27;address&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>增加和修改</li></ul><p>增加就是往字典插入新的键值对，修改就是给原有的键赋予新的值。由于一个key只能对应一个值，所以，多次对一个key赋值，后面的值会把前面的值冲掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;Shanghai&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;Beijing&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;Age&quot;</span>] = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic<br>&#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>删除字典元素、清空字典和删除字典</li></ul><p>使用 <code>del</code> 关键字删除字典元素或者字典本身，使用字典的 <code>clear()</code> 方法清空字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-keyword">del</span> dic[<span class="hljs-string">&#x27;Name&#x27;</span>]<br>print(dic)<br>a = dic.pop(<span class="hljs-string">&#x27;Class&#x27;</span>)  <span class="hljs-comment"># 弹出并返回指定键对应的值。必须提供参数！</span><br>print(a)<br>dic.clear()<br>print(dic)<br><span class="hljs-keyword">del</span> dic<br>print(dic)<br><br>---------------------------------<br>NameError: name <span class="hljs-string">&#x27;dic&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br>&#123;<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>First<br>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="字典的常见方法">字典的常见方法</h3><table><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><strong>get(key)</strong></td><td><strong>返回指定键的值，如果键不在字典中，则返回default值</strong></td></tr><tr class="even"><td><strong>items()</strong></td><td><strong>以列表返回可遍历的(键, 值) 元组对</strong></td></tr><tr class="odd"><td><strong>keys()</strong></td><td><strong>以列表返回字典所有的键，假列表，不可对其操作，可以通过list(dict.keys())变为真列表</strong></td></tr><tr class="even"><td><strong>values()</strong></td><td><strong>以列表返回字典所有的值，同上</strong></td></tr><tr class="odd"><td>pop(key)</td><td>删除并返回指定key的值</td></tr><tr class="even"><td>popitem()</td><td>删除并返回字典的最后一个键值对的(key,value)形式，不接受参数。且字典如果是空则直接报错</td></tr><tr class="odd"><td>setdefault(key, default=None)</td><td>和get()类似,但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr class="even"><td>update(dict2)</td><td>把字典dict2的键/值对更新到dict里</td></tr><tr class="odd"><td>copy()</td><td>将当前字典复制到一个新的字典</td></tr></tbody></table><p>注：</p><ol type="1"><li><code>get()</code> 和 <code>[]</code> 的区别</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>values = []<br>values.append(dic[<span class="hljs-string">&#x27;Name&#x27;</span>])<br>values.append(dic[<span class="hljs-string">&#x27;Age&#x27;</span>])<br>print(values)<br><span class="hljs-comment"># values.append(dic[&#x27;grade&#x27;])  # KeyError: &#x27;grade&#x27;</span><br>values.append(dic.get(<span class="hljs-string">&#x27;grade&#x27;</span>))<br>print(values)<br><br>---------------------------------<br>[<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;20&#x27;</span>]<br>[<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-literal">None</span>]<br></code></pre></td></tr></table></figure><blockquote><p>字典中获取key的方法[]如果获取不到key会直接报错，而get如果获取不到key会返回默认值，在开发中优先考虑get方法来获取key</p></blockquote><ol start="2" type="1"><li><code>get()</code> 与 <code>in</code> 判断的区别</li></ol><p>字典中的成员判断 in 和not in是判断是否有value，有对、无错，并不判断value是不是空。</p><p>而get判断值的结果，如果value是None就会返回False</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_1 = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-literal">None</span>&#125;  <br>bool(dict_1.get(&quot;name&quot;)) --&gt; False<br></code></pre></td></tr></table></figure><h3 id="遍历字典">遍历字典</h3><p><strong>遍历字典获得的键值对是有序的！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><br><span class="hljs-comment"># 1  直接遍历字典获取键，根据键取值</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic:<br>    print(key, dic[key])<br><br><span class="hljs-comment"># 2  利用items方法获取键值，速度很慢，少用！</span><br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> dic.items():<br>    print(key,value)<br><br><span class="hljs-comment">#3  利用keys方法获取键</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic.keys():<br>    print(key, dic[key])<br><br><span class="hljs-comment">#4  利用values方法获取值，但无法获取对应的键。</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> dic.values():<br>    print(value)<br></code></pre></td></tr></table></figure><h2 id="集合-set">2.7 集合 set</h2><p><strong>集合是一个无序不重复元素的集</strong>，基本功能包括关系测试和消除重复元素。集合使用大括号 <code>&#123;&#125;</code> 框定元素，并以逗号进行分隔。成员是不可变类型。</p><p>但是注意：<u>如果要创建一个空集合，必须用 set() 而不是 {} ，因为后者创建的是一个空字典</u>。集合除了在形式上最外层用的也是花括号外，其它的和字典没有一毛钱关系。</p><p>集合数据类型的核心在于<strong>自动去重</strong>。很多时候能省不少事。</p><ul><li>增加</li></ul><ol type="1"><li>通过add(key)方法可以添加一个元素到set中，可以重复添加，但不会有效果</li><li>可以通过update()方法，将另一个对象更新到已有的集合中，这一过程同样会进行去重。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>s.add(<span class="hljs-number">5</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5&#125;</span><br><br>s.update(<span class="hljs-string">&quot;hello&quot;</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>删除</li></ul><p>通过remove(key)方法删除指定元素，或者使用pop()方法。注意，集合的pop方法无法设置参数，删除指定的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br>s.remove(<span class="hljs-string">&#x27;l&#x27;</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br>s.pop(<span class="hljs-number">3</span>)  <span class="hljs-comment"># TypeError: pop() takes no arguments (1 given)</span><br></code></pre></td></tr></table></figure><p><strong>不能从集合取某个元素。因为集合既不支持下标索引也不支持字典那样的通过键获取值。</strong></p><h3 id="集合的常用方法">集合的常用方法</h3><table><thead><tr class="header"><th>方法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>difference() / -</td><td>返回集合的差集</td></tr><tr class="even"><td>intersection()</td><td>返回集合的交集</td></tr><tr class="odd"><td>union()</td><td>返回集合的并集</td></tr><tr class="even"><td>isdisjoint()</td><td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr class="odd"><td>issubset()</td><td>判断指定集合是否为该方法参数集合的子集。</td></tr><tr class="even"><td>add()</td><td>为集合添加一个元素</td></tr><tr class="odd"><td>update()</td><td>给集合添加元素</td></tr><tr class="even"><td>pop()</td><td>移除元素</td></tr><tr class="odd"><td>remove()</td><td>移除指定元素</td></tr></tbody></table><h1 id="函数">3. 函数</h1><p>总结函数的传参方式，有以下四种：</p><ul><li>位置参数</li><li>默认参数</li><li>关键参数</li><li>非固定参数<ul><li><code>*args</code></li><li><code>**kwargs</code></li></ul></li></ul><h2 id="位置参数">3.1 位置参数</h2><p>位置参数就是调用函数时穿的实参与形参位置上一一对应的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country</span>):</span><br>print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;CN&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="默认参数">3.2 默认参数</h2><p>默认参数就是在函数形参中定义好的，当是惨重未穿对应的参数时，参数就会以默认值为准。</p><p>注：默认参数必须放在位置参数之后，否则会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country = <span class="hljs-string">&#x27;CN&#x27;</span></span>):</span><br>print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="关键参数">3.3 关键参数</h2><p>正常情况下，给函数传参数要按照顺序，如果不按顺序就可以用关键参数，只需指定参数名即可（指定参数名的参数叫关键参数）</p><p>注：关键参数必须放在位置参数（以位置顺序确定对应关系的参数）之后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country = <span class="hljs-string">&#x27;CN&#x27;</span></span>):</span><br>print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, country = <span class="hljs-string">&#x27;UK&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="非固定参数">3.4 非固定参数</h2><p><code>*args</code>与 <code>**kwargs</code> 是可变类型且 <code>*args</code> 将参数封装成元组类型给函数体调用，<code>**kwargs</code> 将参数封装成字典类型给函数体调用</p><blockquote><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">seq</span>(<span class="hljs-params">num, num1, num2</span>):</span><br>    <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">88</span> :<br>        print(num1 * num2)<br>    <span class="hljs-keyword">else</span>:<br>        print(num1 + num2)<br>        <br><span class="hljs-comment"># 定义变量tuple1的值为(5,2,1)</span><br>tuple1 = (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 调用函数，传入参数tuple1，并打印函数返回值</span><br>seq(*tuple1)  <span class="hljs-comment"># *tuple1可实现对元组tuple1的解包</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="args">3.4.1 <code>*args</code></h3><p>可同时指定多个用户，传过来的所有参数打包成元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_args</span>(<span class="hljs-params">first, *args</span>):</span><br>    print(<span class="hljs-string">&#x27;Required argument: &#x27;</span>, first)<br>    print(<span class="hljs-built_in">type</span>(args))<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> args:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument: &#x27;</span>, v)<br><br>test_args(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>第一个参数是必须要传入的参数，所以使用了第一个形参，而后面三个参数则作为可变参数列表传入了实参，并且是作为元组tuple来使用的。代码的运行结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Required argument:  <span class="hljs-number">1</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">tuple</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">Optional</span> <span class="hljs-title">argument</span>:</span>  <span class="hljs-number">2</span><br>Optional argument:  <span class="hljs-number">3</span><br>Optional argument:  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="kwargs">3.4.2 <code>**kwargs</code></h3><p>可同时指定多个用户，传过来的所有参数打包成元组或字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_kwargs</span>(<span class="hljs-params">first, *args, **kwargs</span>):</span><br>   print(<span class="hljs-string">&#x27;Required argument: &#x27;</span>, first)<br>   print(<span class="hljs-built_in">type</span>(kwargs))<br>   <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> args:<br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument (args): &#x27;</span>, v)<br>   <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items():<br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument %s (kwargs): %s&#x27;</span> % (k, v))<br><br>test_kwargs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, k1=<span class="hljs-number">5</span>, k2=<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>正如前面所说的，<code>args</code> 类型是一个tuple，而 <code>kwargs</code> 则是一个字典 <code>dict</code>，并且 <code>args</code> 只能位于 <code>kwargs</code> 的前面。代码的运行结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Required argument:  <span class="hljs-number">1</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">dict</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">Optional</span> <span class="hljs-title">argument</span> (<span class="hljs-params">args</span>):</span>  <span class="hljs-number">2</span><br>Optional argument (args):  <span class="hljs-number">3</span><br>Optional argument (args):  <span class="hljs-number">4</span><br>Optional argument k1 (kwargs): <span class="hljs-number">5</span><br>Optional argument k2 (kwargs): <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="综合练习函数的使用">综合练习：函数的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    学生信息库</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>students = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;dewei&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小木&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">5</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小安&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 检查位置参数的判断</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_info</span>(<span class="hljs-params">**kwargs</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生姓名&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生年龄&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生性别&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生班级&#x27;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_students</span>():</span><br>    <span class="hljs-keyword">for</span> id_, value <span class="hljs-keyword">in</span> students.items():<br>        print(<span class="hljs-string">&#x27;学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>            id_, value[<span class="hljs-string">&#x27;name&#x27;</span>], value[<span class="hljs-string">&#x27;age&#x27;</span>], value[<span class="hljs-string">&#x27;sex&#x27;</span>], value[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>        ))<br>    <span class="hljs-keyword">return</span> students<br><br><span class="hljs-comment"># result = get_all_students()</span><br><span class="hljs-comment"># print(&#x27;---&#x27;, result)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_student</span>(<span class="hljs-params">**kwargs</span>):</span><br>    check = check_user_info(**kwargs)<br>    <span class="hljs-keyword">if</span> check != <span class="hljs-literal">True</span>:<br>        print(check)<br>        <span class="hljs-keyword">return</span><br><br>    id_ = <span class="hljs-built_in">max</span>(students) + <span class="hljs-number">1</span>  <span class="hljs-comment"># 不在长度上加1，会覆盖以前删掉的号码</span><br><br>    students[id_] = &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: kwargs[<span class="hljs-string">&#x27;name&#x27;</span>],<br>        <span class="hljs-string">&#x27;age&#x27;</span>: kwargs[<span class="hljs-string">&#x27;age&#x27;</span>],<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: kwargs[<span class="hljs-string">&#x27;sex&#x27;</span>],<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: kwargs[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>    &#125;<br><br><span class="hljs-comment"># add_student(name=&#x27;小章鱼&#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span><br><span class="hljs-comment"># get_all_students()</span><br><br><span class="hljs-comment"># 删除</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_student</span>(<span class="hljs-params">student_id</span>):</span><br>    <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> students:<br>        print(<span class="hljs-string">&#x27;学号是&#123;&#125;号的同学的信息不存在&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br>    <span class="hljs-keyword">else</span>:<br>        user_info = students.pop(student_id)<br>        print(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br><span class="hljs-comment"># delete_student(2)</span><br><span class="hljs-comment"># add_student(name=&#x27;小章鱼&#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span><br><span class="hljs-comment"># get_all_students()</span><br><br><span class="hljs-comment"># 修改</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_student</span>(<span class="hljs-params">student_id, **kwargs</span>):</span><br>    <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> students:<br>        print(<span class="hljs-string">&#x27;不存在学号：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br><br>    check = check_user_info(**kwargs)<br>    <span class="hljs-keyword">if</span> check != <span class="hljs-literal">True</span>:<br>        print(check)<br>        <span class="hljs-keyword">return</span><br><br>    students[student_id] = kwargs<br>    print(<span class="hljs-string">&#x27;&#123;&#125;同学信息更新完毕&#x27;</span>.<span class="hljs-built_in">format</span>(kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>update_student(<span class="hljs-number">2</span>, name=<span class="hljs-string">&#x27;2小木&#x27;</span>, age=<span class="hljs-number">11</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>,class_number=<span class="hljs-string">&#x27;B&#x27;</span>)<br>get_all_students()<br><br><span class="hljs-comment"># 查找，通过学号</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_id</span>(<span class="hljs-params">student_id</span>):</span><br>    <span class="hljs-keyword">return</span> students.get(student_id)<br><br>print(get_user_by_id(<span class="hljs-number">3</span>))<br><br><span class="hljs-comment">#</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_users</span>(<span class="hljs-params">**kwargs</span>):</span><br>    values = <span class="hljs-built_in">list</span>(students.values())<br>    key = <span class="hljs-literal">None</span><br>    value = <span class="hljs-literal">None</span><br>    result = []<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;name&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;age&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;sex&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;class_number&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;没有发现搜索的关键字&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> values:<br>        <span class="hljs-keyword">if</span> user[key] == value:<br>            result.append(user)<br><br>    <span class="hljs-keyword">return</span> result<br><br>print(<span class="hljs-string">&#x27;--------------------&#x27;</span>)<br>users = search_users(sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>print(users)<br></code></pre></td></tr></table></figure><h1 id="面向对象编程">4. 面向对象编程</h1><p>基本概念：</p><ul><li>面向对象：是一种以对象为核心的编程思想。主要是找出问题中的共性问题，作为对象进行操作。</li><li>类：类可以创建实例。</li><li>对象：类不能直接使用。通过类创建实例，也就是对象，才能使用。</li><li>属性：类中的所有变量都称为属性。</li><li>方法：类中的所有函数都成为方法。不过，和函数有所不同的是，类方法至少要包含一个 <code>self</code> 参数。类方法不能单独使用，需要和类的对象一起使用。创建对象后就可以直接调用类中的方法和属性。</li></ul><h2 id="类的-self-参数">4.1 类的 self 参数</h2><ul><li><code>self</code> 是类函数中的必传参数，且必须定义在第一个参数位置</li><li><code>self</code> 是一个对象，他代表实例化的变量自身</li><li><code>self</code> 可以直接通过点 <strong><code>.</code></strong> 来定义一个类变量</li></ul><p><code>self</code> 的举例说明：</p><p><strong>1、属性</strong></p><ol type="1"><li>如果变量定义在类下面而不是类的方法下面，那这个变量既是类的属性也是类实例的属性。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    name = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>    age = <span class="hljs-string">&#x27;21&#x27;</span><br><br>ps = Person()<br>print(ps.name)<br><br>---------------------<br>xiaozhang<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>如果变量定义在类的方法下面，如果加了 <code>self</code> ，那这个变量就是<u>类实例</u>的属性，而不是类的属性；如果没加 <code>self</code> ，那这个变量就是这个方法的局部变量，既不是类的属性也不是类实例的属性。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.name = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>        age = <span class="hljs-string">&#x27;21&#x27;</span><br><br>ps = Person()<br>print(ps.name)<br>print(ps.age)<br><br>---------------------------------<br>xiaozhang<br>Traceback (most recent call last):<br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;age&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>2、方法</strong></p><ol type="1"><li>如果在类中定义函数时<u>加了</u> <code>self</code> ，那这个函数就是类实例的方法，而不是类的方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小张爱跑步&#x27;</span>)<br><br><br>ps = Person()<br>ps.run()<br><span class="hljs-comment"># Person.run()</span><br><br>---------------------------------<br>小张爱跑步<br><span class="hljs-comment"># TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>如果在类中定义函数时<u>没加</u> <code>self</code> ，那这个函数就只是类的方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>        print(<span class="hljs-string">&#x27;小张爱跑步&#x27;</span>)<br><br><br>ps = Person()<br><span class="hljs-comment"># ps.run()</span><br>Person.run()<br><br>---------------------------------<br><span class="hljs-comment"># TypeError: run() takes 0 positional arguments but 1 was given</span><br>小张爱跑步<br><br></code></pre></td></tr></table></figure><h2 id="私有函数与私有变量">4.2 私有函数与私有变量</h2><ul><li>只希望类内部业务调用使用，不希望被使用者调用</li><li>私有函数与变量无法被实例化后的对象所调用</li><li><p>而类内部可以调用私有函数与变量</p></li><li><p>在变量或者函数前添加两个下横线 <code>__</code></p></li></ul><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __cat_type = <span class="hljs-string">&#x27;cat&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, sex</span>):</span><br>        self.name = name<br>        self.__sex = sex<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        tmp = self.__run()<br>        print(tmp)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="hljs-subst">&#123;self.name&#125;</span> <span class="hljs-subst">&#123;self.__sex&#125;</span> 开心的奔跑着&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span>(<span class="hljs-params">self</span>):</span><br>        tmp = self.__jump()<br>        print(tmp)                                        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__jump</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="hljs-subst">&#123;self.name&#125;</span> <span class="hljs-subst">&#123;self.__sex&#125;</span> 开心的跳着&#x27;</span><br><br>cat = Cat(name = <span class="hljs-string">&#x27;米粒&#x27;</span>, sex = <span class="hljs-string">&#x27;boy&#x27;</span>)<br>cat.run()<br>cat.jump()<br><span class="hljs-comment"># cat.__run()</span><br>print(<span class="hljs-built_in">dir</span>(cat))  <span class="hljs-comment"># dir() 可以查看实例化对象有哪些方法</span><br>print(cat._Cat__jump())  <span class="hljs-comment"># 实例化对象调用私有函数也可以行得通，但是最好不要这样做</span><br>print(cat._Cat__cat_type)<br><br>---------------------------------<br>cat, 小猫 米粒 boy 开心的奔跑着<br>cat, 小猫 米粒 boy 开心的跳着<br>[<span class="hljs-string">&#x27;_Cat__cat_type&#x27;</span>, <span class="hljs-string">&#x27;_Cat__jump&#x27;</span>, <span class="hljs-string">&#x27;_Cat__run&#x27;</span>, <span class="hljs-string">&#x27;_Cat__sex&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;jump&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;run&#x27;</span>]<br>cat, 小猫 米粒 boy 开心的跳着<br>cat<br><br></code></pre></td></tr></table></figure><h3 id="举个栗子----编程练习">举个栗子----编程练习：</h3><p>自定义一个交通工具类(Vehicle)，并根据提示对该类进行进一步封装，使其拥有工具类型、速度、体积等属性值。通过自定义实例方法实现交通工具的前移、速度设置、获取当前速度、加速行驶、减速行驶、实例信息展示、实例类型判别等功能。</p><p>任务 1、自定义一个交通工具类(Vehicle) 2、设置类属性trans_type（固定值为'SUV'）和实例属性速度speed（int 类型，单位为 km/h）、体积size（tuple类型，单位为米。） 3、自定义方法 show_info( )，打印实例的所属类型和速度、体积的值； 4、自定义实例方法如下： （1）定义move( )方法，实现打印“我已向前移动了50米” （2）定义set_speed(new_speed)方法，设置对应实例的速度为new_speed km/h （3）定义get_speed()方法，如果（2）中设置了速度值则打印出来，打印格式为'我的时速为：设置的速度值 km/h' （4）定义speed_up()方法，设置每次调用时实例的速度都增加10km/h，并打印“我的速度由xx km/提升到了xx km/h” （5）定义speed_down()方法，设置每次调用时实例的速度都降低15km/h，并打印“我的速度由xx km/下降到了xx km/h” 5、自定义方法 transport_identify( )，判断实例是否为Vehicle类型。若是则打印‘类型匹配’，反之则打印‘类型不匹配’ 6、初始化实例对象tool_1</p><p>任务提示 类的初始化方法中所传参数size是元组类型，直接传入实例的长，宽，高即可，如size=(10,10,10)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 自定义Vehicle类属性</span><br>    trans_type = <span class="hljs-string">&#x27;SUV&#x27;</span><br><br>    <span class="hljs-comment"># 自定义实例的初始化方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, speed, size</span>):</span><br>        self.speed = speed<br>        self.size = size<br><br>    <span class="hljs-comment"># 自定义实例方法show_info，打印实例的速度和体积</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我的所属类型为: &#123;&#125;, 我的速度: &#123;&#125; km/h, 我的体积: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.trans_type, self.speed, self.size))<br><br>    <span class="hljs-comment"># 自定义实例方法move,打印“我已向前移动了50米”</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我已向前移动了50米&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义实例方法set_speed，设置对应的速度值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_speed</span>(<span class="hljs-params">self, new_speed</span>):</span><br>        self.speed = new_speed  <span class="hljs-comment"># 在这里将旧速度与新设置的速度进行统一。</span><br><br>    <span class="hljs-comment"># 自定义实例方法get_speed，打印当前的速度值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_speed</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我的时速为 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(self.speed))<br><br>    <span class="hljs-comment"># 自定义实例方法speed_up，实现对实例的加速</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speed_up</span>(<span class="hljs-params">self</span>):</span><br>        old_speed = self.speed<br>        self.speed += <span class="hljs-number">10</span><br>        print(<span class="hljs-string">&quot;我的时速由 &#123;&#125; km/h 提升到了 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(old_speed, self.speed))<br><br><span class="hljs-comment"># 自定义实例方法speed_down，实现对实例的减速</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speed_down</span>(<span class="hljs-params">self</span>):</span><br>        old_speed = self.speed<br>        self.speed -= <span class="hljs-number">15</span><br>        print(<span class="hljs-string">&quot;我的时速由 &#123;&#125; km/h 下降到了 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(old_speed, self.speed))<br><br><span class="hljs-comment"># 自定义实例方法transport_identify，实现对实例所属类型的判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transport_identify</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.trans_type == <span class="hljs-string">&#x27;SUV&#x27;</span>:<br>            print(<span class="hljs-string">&quot;类型匹配&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;类型不匹配&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    tool_1 = Vehicle(<span class="hljs-number">20</span>, (<span class="hljs-number">3.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">1.75</span>))<br><br>    <span class="hljs-comment"># 调用实例方法 打印实例的速度和体积</span><br>    tool_1.show_info()<br><br>    <span class="hljs-comment"># 调用实例方法 实现实例的前移</span><br>    tool_1.move()<br><br>    tool_1.set_speed(<span class="hljs-number">40</span>)<br>    <span class="hljs-comment"># 调用实例方法 打印当前速度</span><br>    tool_1.get_speed()<br><br>    <span class="hljs-comment"># 调用实例方法 对实例进行加速</span><br>    tool_1.speed_up()<br><br>    <span class="hljs-comment"># 调用实例方法 对实例进行减速</span><br>    tool_1.speed_down()<br><br>    <span class="hljs-comment"># 调用实例方法 判断当前实例的类型</span><br>    tool_1.transport_identify()<br>    <br>---------------------------------------------    <br>我的所属类型为: SUV, 我的速度: <span class="hljs-number">20</span> km/h, 我的体积: (<span class="hljs-number">3.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">1.75</span>)<br>我已向前移动了<span class="hljs-number">50</span>米<br>我的时速为 <span class="hljs-number">40</span> km/h<br>我的时速由 <span class="hljs-number">40</span> km/h 提升到了 <span class="hljs-number">50</span> km/h<br>我的时速由 <span class="hljs-number">50</span> km/h 下降到了 <span class="hljs-number">35</span> km/h<br>类型匹配<br></code></pre></td></tr></table></figure><h2 id="类的封装">4.3 类的封装</h2><p><strong>封装</strong>：将<u>不对外的私有属性或方法</u>通过<u>可对外使用的函数</u>而使用（类中定义私有的，只有类内部使用，外部无法访问）</p><ul><li>这样做的原因：保护隐私，明确区分内外</li></ul><blockquote><p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。 对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者self间接获取被封装的内容。</p></blockquote><h2 id="装饰器">4.4 装饰器</h2><p><strong>装饰器</strong>：装饰器本质上就是一个python函数，他可以让其他函数在<strong>不需要做任何代码变动的前提下，增加额外的功能</strong>，装饰器的<strong>返回值也是一个函数对象</strong>。他们有助于让代码更简短，也更Pythonic（Python范儿）。装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等等场景。有了装饰器，我们可以抽离出大量与函数功能本身无关的雷同代码。</p><p>我们知道，在python中，我们可以像使用变量一样使用函数，这主要依赖于以下几点：</p><ul><li>函数可以被赋值给其他变量</li><li>函数可以被删除</li><li>可以在函数里面再定义函数，函数嵌套。</li><li><strong>函数可以作为参数传递给另外一个函数</strong></li><li>函数可以作为另一个函数的返回值</li></ul><p>为了更好的理解装饰器，先从对一个简单的函数进行装饰，假设有下面这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world!&quot;</span><br></code></pre></td></tr></table></figure><p>现在我们的需求是要增强 <code>hello()</code> 函数的功能，希望给返回加上HTML标签，比如<code>&lt;i&gt;he不得改变</code>hello()` 函数原来的定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span>+fun()+<span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个函数 <code>makeitalic</code>，该函数有一个参数 <code>fun</code>，它是一个函数；在 <code>makeitalic</code> 函数里面我们又定义了一个内部函数 <code>wrapped</code> ，并将该函数作为返回。</p><p>现在我们就达到了我们的需求，不改变 <code>hello()</code> 函数的定义，但实现了我们想要的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>          <span class="hljs-keyword">return</span> wrapped<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br>hello = makeitalic(hello)<br>print(hello()) <span class="hljs-comment"># &lt;i&gt;hello world&lt;/i&gt;</span><br></code></pre></td></tr></table></figure><p>在上面，我们将 <code>hello</code> 函数传入 <code>makeitalic</code> ，再将返回赋值给 <code>hello</code> ，此时，调用 <code>hello()</code> 函数就可以得到我们想要的结果。 不过需要注意的是，由于我们将 <code>makeitalic</code> 的返回赋值给 <code>hello</code> ，此时，<code>hello()</code> 函数仍然存在，但它已不在指向原来定义的 <code>hello()</code> 函数了，而是指向了 <code>wrapped</code>。</p><p>现在我们来总结一下，上面例子为了增强原函数 <code>hello</code> 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，在这个返回的函数中，执行了原函数，并对原函数的功能进行了增强。完整的代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>          <span class="hljs-keyword">return</span> wrapped<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br>hello = makeitalic(hello)<br>print(hello())<br>print(hello.__name__)<span class="hljs-number">123456789101112</span><br></code></pre></td></tr></table></figure><p>事实上，<code>makeitalic</code> 就是一个装饰器（<code>decorator</code>），它封装了原函数 <code>hello</code>，并返回了一个新函数，用于增强原函数的功能，并将其赋值给 <code>hello</code>。</p><p>一般情况下，我们使用装饰器提供的<strong><span class="citation" data-cites="语法糖">@语法糖</span>（Syntactic Sugar）</strong>，来简化上面的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-meta">@makeitalic</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><p>这种做法是我们在平时写程序时，常见的操作，但前面例子中的讲解才是内部的实现原理。</p><p>像上面的情况，可以动态的修改函数（或类的）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 <code>hello</code>）为参数，并返回一个包装后的函数（比如上面的 <code>wrapped</code>）给被修饰函数（<code>hello</code>）。</p><blockquote><p>之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，<strong>糖在不改变其所在位置的语法结构的前提下，实现了运行时等价</strong>。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。</p><p>之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：<strong>代码更简洁流畅，代码更语义自然</strong>... 写得爽，看着爽，就像吃了糖hhh。据说还有语法盐hhh反人类的代码</p></blockquote><p>举个简单的栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_str</span>(<span class="hljs-params">func</span>):</span><br>    print(<span class="hljs-string">&#x27;func:&#x27;</span>, func)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        print(<span class="hljs-string">&#x27;args:&#x27;</span>, args, kwargs)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-keyword">if</span> result == <span class="hljs-string">&#x27;okk&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is %s&#x27;</span> % result<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is failed:%s &#x27;</span> % result<br><br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@check_str</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">return</span> data<br><br>result = test(<span class="hljs-string">&#x27;no&#x27;</span>)<br>print(result)<br><br>result = test(<span class="hljs-string">&#x27;okk&#x27;</span>)<br>print(result)<br><br>-------------------------------------<br>func: &lt;function test at <span class="hljs-number">0x00000191FC0A9168</span>&gt;<br>args: (<span class="hljs-string">&#x27;no&#x27;</span>,) &#123;&#125;<br>result <span class="hljs-keyword">is</span> failed:no <br>args: (<span class="hljs-string">&#x27;okk&#x27;</span>,) &#123;&#125;<br>result <span class="hljs-keyword">is</span> okk<br></code></pre></td></tr></table></figure><blockquote><p>小练习：</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141840.png" style="zoom:60%;" /></p><p>输出：</p><p>​ 2018-11-27</p><p>​ call hello()</p><p>​ hello world</p><p>​ 本题考查的是装饰器的应用。代码中函数的执行顺序为先执行now函数再执行hello函数，执行now函数时输出2018-11-27，当执行hello函数时，发现了装饰器log函数，因此要先执行装饰器，输出call hello(): ，然后执行传入的hello函数，输出hello world</p></blockquote><h2 id="常用的装饰器">4.5 常用的装饰器</h2><ul><li><code>classmethod</code></li><li><code>staticmethod</code></li><li><code>property</code></li></ul><h3 id="classmethod-的功能">4.5.1 <code>classmethod</code> 的功能</h3><p><code>classmethod</code> ：将类函数可以不经过实例化而直接被调用。</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, a</span>):</span><br>        self.a = a<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;run&#x27;</span>)<br>        self.jump()  <span class="hljs-comment"># # &gt;&gt;&gt; run/n jump 证明普通的self函数可以调用带有classmethod装饰器的类函数</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span>(<span class="hljs-params">cls</span>):</span><br>        print(<span class="hljs-string">&#x27;jump&#x27;</span>)<br>        <span class="hljs-comment"># cls.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br>                   <span class="hljs-comment"># 证明带有classmethod装饰器的类函数无法调用self函数</span><br><br>t = Test(<span class="hljs-string">&#x27;aa&#x27;</span>)<br><span class="hljs-comment"># t.run()</span><br><span class="hljs-comment"># Test.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br>            <span class="hljs-comment"># 因为没有实例化！(这时就可以用classmethod)</span><br><span class="hljs-comment"># Test.jump()  # &gt;&gt;&gt; jump</span><br>t.run()   <span class="hljs-comment"># &gt;&gt;&gt; run/n jump</span><br></code></pre></td></tr></table></figure><h3 id="staticmethod-的功能">4.5.2 <code>staticmethod</code> 的功能</h3><p><code>staticmethod</code> ：可以将类函数不经过实例化而直接被调用，被该装饰器调用的函数<strong>不许传递 <code>self</code> 或 <code>cls</code> 参数</strong>，且无法在该函数内调用其它类函数或类变量。</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, a</span>):</span><br>        self.a = a<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;run&#x27;</span>)<br>        self.sleep()  <span class="hljs-comment"># 证明普通的self函数可以调用带有staticmethod装饰器的类函数</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span>():</span><br>        print(<span class="hljs-string">&#x27;i wanna sleep&#x27;</span>)<br>        self....  <span class="hljs-comment"># 直接报错，都没有self参数</span><br><br>t = Test(<span class="hljs-string">&#x27;aa&#x27;</span>)<br>Test.sleep()  <span class="hljs-comment"># &gt;&gt;&gt; i wanna sleep</span><br>t.sleep()  <span class="hljs-comment"># &gt;&gt;&gt; i wanna sleep</span><br>t.run()  <span class="hljs-comment"># &gt;&gt;&gt; run\n i wanna sleep</span><br><br></code></pre></td></tr></table></figure><h3 id="property-的功能">4.5.3 <code>property</code> 的功能</h3><p><code>property</code> ：将类含糊的执行免去括弧，类似于调用属性(变量)</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.__name = name<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__name<br><br><span class="hljs-meta">    @name.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self, value</span>):</span><br>        self.__name = value<br><br>t = Test(name=<span class="hljs-string">&#x27;xiaozhang&#x27;</span>)<br>print(t.name)<br><br>t.name = <span class="hljs-string">&#x27;xiaohong&#x27;</span>  <span class="hljs-comment"># AttributeError: can&#x27;t set attribute</span><br>print(t.name)<br></code></pre></td></tr></table></figure><h2 id="类的继承">4.6 类的继承</h2><p>1、什么是继承？</p><ul><li>通过继承基类来得到基类的功能</li><li>被继承的类称作父类或基类，继承者称作子类</li><li><strong>代码重用</strong></li></ul><p>2、父类和子类的关系？</p><ul><li>子类拥有父类的<strong>所有属性和方法</strong></li><li>父类不具备子类<strong>自有</strong>的属性和方法</li></ul><p>3、继承的用法：</p><ul><li>定义子类时，将父类传入子类参数内</li><li>子类实例化可以调用自己与父类的函数与变量</li><li>父类无法调用子类的函数与变量</li></ul><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, sex</span>):</span><br>        self.name = name<br>        self.sex = sex<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is talking&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_sex</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.sex == <span class="hljs-string">&#x27;boy&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is a boy&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is a girl&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildOne</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play_football</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is playing football&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildTwo</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play_pingpong</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is playing pingpong&#x27;</span><br><br>c_one = ChildOne(name=<span class="hljs-string">&#x27;小张&#x27;</span>, sex=<span class="hljs-string">&#x27;girl&#x27;</span>)<br>result = c_one.play_football()<br>print(result)<br>result = c_one.talk()<br>print(result)<br><br>c_two = ChildTwo(name=<span class="hljs-string">&#x27;小红&#x27;</span>, sex=<span class="hljs-string">&#x27;girl&#x27;</span>)<br>result = c_two.play_pingpong()<br>print(result)<br>result = c_two.talk()<br>print(result)<br><br>p = Parent(name=<span class="hljs-string">&#x27;父亲&#x27;</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>result = p.talk()<br>print(result)<br>result = p.is_sex()<br>print(result)<br>result = p.playing()  <span class="hljs-comment"># AttributeError: &#x27;Parent&#x27; object has no attribute &#x27;playing&#x27;</span><br><br></code></pre></td></tr></table></figure><p>4、<strong><code>super</code> 函数</strong>的作用 (<strong>单继承</strong>)</p><p><code>super</code> ：是python子类继承父类的方法而使用的关键字，当子类继承父类后，就可以使用父类的方法。</p><blockquote><p>注：一般适用于<strong>单继承</strong>。</p></blockquote><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, p</span>):</span><br>        print(<span class="hljs-string">&#x27;hello i am parent %s&#x27;</span> % p)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, c, p</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(p)<br>        print(<span class="hljs-string">&#x27;hello i am child %s&#x27;</span> % c)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    c = Child(c=<span class="hljs-string">&#x27;小张&#x27;</span>, p=<span class="hljs-string">&#x27;老张&#x27;</span>)<br>    <br>----------------------------------------------------<br>hello i am parent 老张<br>hello i am child 小张<br></code></pre></td></tr></table></figure><h3 id="举个栗子----编程练习-1">举个栗子----编程练习：</h3><p>自定义两个类Person和Student，且Student继承自Person。Person类主要描述人的姓名和性别两大基本特征。Student类除了保持父类的基本属性之外还具有分数、主修两个公有属以及一个私有属性（学号）。请根据上述的基本说明，对stu和stu_2两个对象的信息进行综 合展示。</p><p>任务 1、自定义Person类，并重写其构造（初始化）方法<code>__init__( )</code>，将name和gender参数赋值给实例对象的属性 2、自定义实例方法<code>speak( )</code>，功能：打印“hello ! 我是xxx”。<code>relaton( )</code>方法主要是占位作用，无其他实质性功能 3、自定义Student类，继承自Person类，并重写其构造（初始化）方法<code>__init__( )</code>，name、gender参数通过调用父类的构造函数进行赋值，score和major通过子类重写的<code>__init__( )</code>进行赋值。 4、自定义实例方法<code>speak( )</code>，功能：打印 '我的学号为xxxxxxxxxx，很高兴认识大家'; 5、自定义实例方法<code>identify_stu( )</code>，功能：判断Student对象的学号。若学号为2018014002，则打印‘我的分组已经完成’，反之则打印‘请稍后，马上为你自动分组’； 6、自定义实例方法<code>set_num( new_num)</code>，功能：将学号重写设置为new_num； 7、自定义实例方法<code>relation( )</code>，功能：判断Student是否为Person的子类。若成立，则打印‘我的父类是Person’，反之则打印‘父类在查询中······’ 8、初始化实例对象stu和stu_2，并根据上述效果图调用对应方法</p><p>任务提示 Person类中的实例方法<code>relation( )</code>为占位功能时，其方法体可用pass语句代替</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 重写实例对象的构造（初始化）方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, gender</span>):</span><br>        self.name = name<br>        self.gender = gender<br><br>    <span class="hljs-comment"># 自定义实例方法，格式化打印实例属性name的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;hello! 我是 %s 。&quot;</span> % self.name)<br><br>    <span class="hljs-comment"># 自定义实例方法，占位作用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relation</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">Person</span>):</span><br>    <span class="hljs-comment"># 重写实例对象的构造（初始化）方法，并调用父类构造方法，实现对实例属性的赋值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, gender, score, major, __stu_num = <span class="hljs-string">&#x27;2018014002&#x27;</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__( name, gender)<br>        self.score = score<br>        self.major = major<br>        self.__stu_num = __stu_num<br><br>    <span class="hljs-comment"># 自定义实例方法，格式化打印实例属性stu_num的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;我的学号为 %s，很高兴认识大家&#x27;</span> % self.__stu_num)<br><br>    <span class="hljs-comment"># 自定义实例方法，判断学号是否为既定值，并根据判断结构 进行分类打印</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identify_stu</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.__stu_num == <span class="hljs-string">&#x27;2018014002&#x27;</span>:<br>            print(<span class="hljs-string">&quot;我的分组已经完成&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;请稍后，马上为你自动分组&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义实例方法，设置实例对象的学号为传入的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_num</span>(<span class="hljs-params">self, new_num</span>):</span><br>        self.__stu_num = new_num<br><br>    <span class="hljs-comment"># 自定义实例方法，判断该类是否为Person类的子类，并进行分类打印</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relation</span>(<span class="hljs-params">self, cls_son, cls_fa</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(cls_son, cls_fa):<br>            print(<span class="hljs-string">&quot;我的父类是Person&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;父类正在查询中....&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    stu = Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;数学&#x27;</span>)<br>    <span class="hljs-comment"># 调用speak方法 打印stu对应的值</span><br>    stu.speak()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别学号是否为指定值</span><br>    stu.identify_stu()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别实例对象所属的类的父类是否为Person</span><br>    stu.relation(Student, Person)<br><br>    print(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">12</span>)<br><br>    stu_2 = Student(<span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>)<br>    <span class="hljs-comment"># 调用实例方法 设置stu_2的学号为&#x27;2018040625&#x27;</span><br>    stu_2.set_num(<span class="hljs-string">&#x27;2018040625&#x27;</span>)<br><br>    <span class="hljs-comment"># 调用实例方法 打印stu_2对应的值</span><br>    stu_2.speak()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别学号是否为指定值</span><br>    stu_2.identify_stu()<br><br>---------------------------------------------------------<br>我的学号为 <span class="hljs-number">2018014002</span>，很高兴认识大家<br>我的分组已经完成<br>我的父类是Person<br>------------------------------------<br>我的学号为 <span class="hljs-number">2018040625</span>，很高兴认识大家<br>请稍后，马上为你自动分组<br><br></code></pre></td></tr></table></figure><h2 id="类的多态">4.7 类的多态</h2><p>1、什么是多态？</p><p>多态是指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承）</p><blockquote><p>注：多态和多态性不是同一概念。</p><p>什么是多态性？</p><ul><li><p>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。<strong>子类继承父类；子类重写父类方法</strong></p></li><li><p>多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的爸爸说了一句话&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brother</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的哥哥在奔跑...&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的哥哥在说话...&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明也说话&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    b = Brother()<br>    b.run()<br>    b.talk()<br><br>    p = Parent()<br>    p.talk()<br><br>    c = Child()<br>    c.talk()<br>    <br>----------------------------------------------------<br>小明的哥哥在奔跑...<br>小明的哥哥在说话...<br>小明的爸爸说了一句话<br>小明也说话<br></code></pre></td></tr></table></figure><p>2、为什么要使用多态？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">metaclass=abc.ABCMeta</span>):</span> <span class="hljs-comment">#同一类事物:动物</span><br><span class="hljs-meta">    @abc.abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之一:猫</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say miaomiao&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之二:狗</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say wangwang&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之三:猪</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say aoao&#x27;</span>)<br><br>c = Cat()<br>d = Dog()<br>p = Pig()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">obj</span>):</span><br>    obj.talk()<br><br>func(c)<br>func(d)<br>func(p)<br><br>------------------------------<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>say miaomiao<br><span class="hljs-meta">&gt;&gt;&gt; </span>say wangwang<br><span class="hljs-meta">&gt;&gt;&gt; </span>say aoao<br></code></pre></td></tr></table></figure><p>仅仅是用了一个 <code>func(obj)</code> 函数，不同的对象就实现了不同的功能。综上可以说，多态性是 : <strong>一个接口，多种实现</strong></p><p><strong>多态性的好处:</strong></p><ul><li>增加了程序的<strong>灵活性</strong>，以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如 <code>func(obj)</code></li><li>增加了程序额<strong>可扩展性</strong>，通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用 <code>func(obj)</code> 去调用</li></ul><h2 id="类的多重继承">4.8 类的多重继承</h2><p>1、什么是多重继承？</p><p>我理解为一个子类可以继承多个父类。</p><p>2、多重继承的方法？</p><p><code>class Child(Parent1, Parent 2, Parent 3...)</code>，从左往右依次继承</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tool</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;tool work&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;car will run&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;food work&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cake</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;i like cake&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">Tool, Food</span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Person()<br>    print(p.car(), <span class="hljs-string">&#x27; &#x27;</span>, p.cake())<br>    print(p.work())  <span class="hljs-comment"># 继承的第一个类</span><br>    print(Person.__mro__)  <span class="hljs-comment"># 得到类的继承顺序</span><br><br>------------------------------<br>car will run   i like cake<br>tool work<br>(&lt;class &#x27;__main__.Person&#x27;&gt;, &lt;class &#x27;__main__.Tool&#x27;&gt;, &lt;class &#x27;__main__.Food&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)<br><br></code></pre></td></tr></table></figure><blockquote><p>注：继承关系可以延续。例，孙子继承父亲，父亲继承爷爷，则孙子也继承爷爷。</p></blockquote><h3 id="举个栗子----编程练习-2">举个栗子----编程练习：</h3><p>圆形、长方形除了是几何学科中的基本图形之外，也还是我们日常生活中最常见的平面图形。请根据面向对象的相关知识，将上述两种平面图形用Python语言进行表示，使得我们的程序可以正常对其使用。</p><p>任务 1、自定义Point类，并重写其构造（初始化）方法 <code>__init__( )</code>，将参数x和y赋值给实例对象的属性 2、自定义该类实例方法<code>string( )</code>，功能：打印“{X：xx, Y：xx}” 3、自定义Circle类，继承自Point类，并重写其构造（初始化）方法<code>__init__( )</code>，x、y参数通过调用父类的构造函数进行赋值，radius通过子类重写的<code>__init__( )</code>进行赋值。 4、自定义该类实例方法<code>string( )</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; {半径为：xx}” 5、自定义Size类，并重写其构造（初始化）方法<code>__init__( )</code>，将参数width和height赋值给实例对象的属性 6、自定义该类实例方法<code>string( )</code>，功能：打印“{Width：xx, Height：xx}” 7、自定义Rectangle类，继承自Point类和Size类，并重写其构造（初始化）方法<code>__init__( )</code>，x、y、width、height 4个参数全部通过调用父类的构造函数进行赋值 8、自定义该类实例方法<code>string( )</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; 长宽分别为：{Width：xx, Height：xx} 9、初始化Circle类的对象c，并调用其格式化输出函数<code>string( )</code> 10、初始化Rectangle类的对象r1、r2,并分别调用其格式化输出函数<code>string( )</code></p><p>任务提示 1、在自定义Rectangle类的构造方法时，调用父类方法必须按照<code>类名.__init__(参数列表)</code>的方式进行调用，如<code>Point.__init__(self, x, y)</code> 2、自定义Rectangle类格式化输出方法时，调用父类的格式化输出函数<code>string()</code>时，应按照<code>类名.string(参数)</code>的方式进行调用，如<code>Point.string(self)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    x = <span class="hljs-number">1.0</span><br>    y = <span class="hljs-number">1.0</span><br><br>    <span class="hljs-comment"># 自定义Point类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y</span>):</span><br>        self.x = x<br>        self.y = y<br>        print(<span class="hljs-string">&quot;Point 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Point类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;X: %s, Y: %s&#125;&quot;</span>  % (self.x, self.y))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">Point</span>):</span><br>    <span class="hljs-comment"># 自定义Circle类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, radius</span>):</span><br>        Point.__init__(self, x, y)<br>        self.radius = radius<br>        print(<span class="hljs-string">&quot;Circle 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Circle类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;该图形初始化点为: &#123;X: &quot;</span> + <span class="hljs-built_in">str</span>(self.x) + <span class="hljs-string">&quot;, Y: &quot;</span> + <span class="hljs-built_in">str</span>(self.y) \<br>               + <span class="hljs-string">&quot;&#125;, &#123;半径为: &quot;</span> + <span class="hljs-built_in">str</span>(self.radius) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 自定义Size类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br>        print(<span class="hljs-string">&quot;Size 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Size类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;Height: &quot;</span> + <span class="hljs-built_in">str</span>(self.width) + <span class="hljs-string">&quot;, Width: &quot;</span> + <span class="hljs-built_in">str</span>(self.height) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">Point, Size</span>):</span><br>    <span class="hljs-comment"># 自定义Rectangle类的构造(初始化)方法，并在方法中调用父类的初始化方法以完成初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, width, height</span>):</span><br>        Point.__init__(self, x, y)<br>        Size.__init__(self, width, height)<br><br>    <span class="hljs-comment"># 自定义Rectangle类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;该图形初始化点为: &#123;X: &quot;</span> + <span class="hljs-built_in">str</span>(self.x) + <span class="hljs-string">&quot;, Y: &quot;</span> + <span class="hljs-built_in">str</span>(self.y) + <span class="hljs-string">&quot;&#125;&quot;</span> + \<br>              <span class="hljs-string">&quot;, 长宽分别为: &#123;Height: &quot;</span> + <span class="hljs-built_in">str</span>(self.width) + <span class="hljs-string">&quot;, Width: &quot;</span> + <span class="hljs-built_in">str</span>(self.height) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 实例化Point对象，点位置为（3, 3）</span><br>    p = Point(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>    p.string()<br><br>    <span class="hljs-comment"># 实例化Circle对象，圆心为（5,5），半径为8</span><br>    c = Circle(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br>    c.string()<br><br>    <span class="hljs-comment"># 实例化Rectangle对象，顶点位置（15,30），长和宽分别为20和10</span><br>    r = Rectangle(<span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)<br>    r.string()<br><br>------------------------------------------------------------------------------------------------------<br>Point 构造函数被调用...<br>&#123;X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">3</span>&#125;<br><br>Point 构造函数被调用...<br>Circle 构造函数被调用...<br>该图形初始化点为: &#123;X: <span class="hljs-number">5</span>, Y: <span class="hljs-number">5</span>&#125;, &#123;半径为: <span class="hljs-number">8</span>&#125;<br><br>Point 构造函数被调用...<br>Size 构造函数被调用...<br>该图形初始化点为: &#123;X: <span class="hljs-number">15</span>, Y: <span class="hljs-number">30</span>&#125;, 长宽分别为: &#123;Height: <span class="hljs-number">20</span>, Width: <span class="hljs-number">10</span>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>该案例如果用super()调用拥有同名方法的父类，就只会调用最靠前的拥有同名方法的类，后面的类中同名方法也就无法被调用。</strong></p><p><strong>因此本案例多继承中进行父类调用时采用“<code>类名.__init__</code>”的形式。</strong></p></blockquote><h2 id="类的高级函数">4.9 类的高级函数</h2><ul><li><code>__str__</code> 函数</li><li><code>__gtrattr()__</code> 函数</li><li><code>__setattr__</code> 函数</li><li><code>__call__</code> 函数</li></ul><h3 id="str__-函数">4.9.1 <code>__str__</code> 函数</h3><p>如果定义了该函数，当print当前实例化对象时候，会返回该函数的 return信息。</p><ul><li>通常会返回一个字符串作为类的描述信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 一般会定义一些类的描述信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;this is a test class&#x27;</span><br><br>t = Test()<br>print(t)<br></code></pre></td></tr></table></figure><h3 id="gtrattr__-函数">4.9.2 <code>__gtrattr__</code> 函数</h3><p>当调用的属性或者方法不存在时，会返回该方法定义的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这个key: &#123;&#125; 并不存在&#x27;</span>.<span class="hljs-built_in">format</span>(key)<br><br><span class="hljs-comment"># print(t.a)  # AttributeError: &#x27;Test&#x27; object has no attribute &#x27;a&#x27;</span><br>print(t.a )  <span class="hljs-comment"># &gt;&gt;&gt; 这个key: a 并不存在</span><br></code></pre></td></tr></table></figure><h3 id="setattr__.-函数">4.9.3 <code>__setattr__.</code> 函数</h3><p>拦截当前类中不存在的属性与值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span>(<span class="hljs-params">self, key, value</span>):</span><br>        <span class="hljs-comment"># print(key, value)</span><br>        self.__dict__[key] = value<br>        print(self.__dict__)<br><br>t = Test()<br>t.name = <span class="hljs-string">&#x27;小明&#x27;</span><br>print(t.name)<br><br>-----------------------------------------------<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小明&#x27;</span>&#125;<br>小明<br></code></pre></td></tr></table></figure><h3 id="call__-函数">4.9.4 <code>__call__</code> 函数</h3><p>本质是将一个类变成一个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, a</span>):</span><br>        print(<span class="hljs-string">&#x27;call func will start&#x27;</span>)<br>        print(a)<br><br>t = Test()<br>t(<span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br>-----------------------------------------------<br>call func will start<br>xiaoming<br></code></pre></td></tr></table></figure><h1 id="异常">5. 异常</h1><ul><li>异常就是错误</li><li><p>异常会导致程序崩溃并停止运行</p></li><li><p>python中的异常机制能监控并捕获异常，将异常部位的程序进行修理使得程序继续正常运行</p></li></ul><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    &lt;代码块<span class="hljs-number">1</span>&gt; 被<span class="hljs-keyword">try</span>关键字检查并保护的业务代码<br><span class="hljs-keyword">except</span> &lt;异常的类型&gt;:<br>    &lt;代码块<span class="hljs-number">2</span>&gt; <span class="hljs-comment"># 代码块1出现错误后执行的代码块</span><br></code></pre></td></tr></table></figure><p>1、捕获通用异常</p><ul><li>无法确定是在哪种异常情况下使用的捕获方法</li></ul><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    &lt;代码块&gt; <br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    &lt;异常代码块&gt; <br></code></pre></td></tr></table></figure><p>2、捕获具体异常</p><ul><li><p>确定是哪种异常的情况下使用的捕获方法</p></li><li><p><code>exceppt &lt;具体的异常类型&gt; as e</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">UPPER</span>(<span class="hljs-params">str_data</span>):</span><br>    new_str = <span class="hljs-string">&#x27;None&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        new_str = str_data.upper()<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e :<br>        print(<span class="hljs-string">&#x27;程序出错了:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(e))<br>    <span class="hljs-keyword">return</span> new_str<br><br>result = UPPER(<span class="hljs-string">&#x27;xiaohong&#x27;</span>)<br>result1 = UPPER(<span class="hljs-number">1</span>)<br>print(<span class="hljs-string">&#x27;result1 is&#x27;</span>, result1)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>        print(<span class="hljs-string">&#x27;hello&#x27;</span>)  <span class="hljs-comment"># 遇到错误立刻进入except，所以错误后的代码全都不会执行</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><br>test()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        print(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>        print(name)  <span class="hljs-comment"># except 里没有对应的异常类型，所以报错了</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><br>test1()<br></code></pre></td></tr></table></figure><p>3、捕获多个异常</p><ol type="1"><li>可以有多个except并列。但当第一个异常捕获到之后，不会再继续往下捕获。</li><li>写一个 <code>except (异常类型1, 异常类型2) as e</code> 。当except代码后边的异常类型使用<strong>元组</strong>包裹起来，捕获到哪种就抛哪种</li></ol><h2 id="常用异常类型">5.1 常用异常类型</h2><table><thead><tr class="header"><th style="text-align: left;">异常名称</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Exception</td><td style="text-align: left;">通用异常类型（基类）</td></tr><tr class="even"><td style="text-align: left;">ZeroDivisionError</td><td style="text-align: left;">不能整除0</td></tr><tr class="odd"><td style="text-align: left;">AttributeError</td><td style="text-align: left;">对象没有这个属性</td></tr><tr class="even"><td style="text-align: left;">IOError</td><td style="text-align: left;">输入输出操作失败</td></tr><tr class="odd"><td style="text-align: left;">IndexError</td><td style="text-align: left;">没有当前的索引</td></tr><tr class="even"><td style="text-align: left;">KeyError</td><td style="text-align: left;">没有这个键值（key）</td></tr><tr class="odd"><td style="text-align: left;">NameError</td><td style="text-align: left;">没有这个变量（未初始化对象）</td></tr><tr class="even"><td style="text-align: left;">SyntaxError</td><td style="text-align: left;">Python语法错误</td></tr><tr class="odd"><td style="text-align: left;">SystemError</td><td style="text-align: left;">解释器的系统错误</td></tr><tr class="even"><td style="text-align: left;">ValueError</td><td style="text-align: left;">传入的参数错误</td></tr></tbody></table><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br>t = Test()<br><span class="hljs-keyword">try</span>:<br>    t.name<br><span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># &#x27;Test&#x27; object has no attribute &#x27;name&#x27;</span><br><br>d = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小明&#x27;</span>&#125;<br><span class="hljs-keyword">try</span>:<br>    d[<span class="hljs-string">&#x27;age&#x27;</span>]<br><span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>    print(<span class="hljs-string">&#x27;没有对应的键: &#x27;</span>, e)  <span class="hljs-comment"># 没有对应的键:  &#x27;age&#x27;</span><br><br>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">try</span>:<br>    l[<span class="hljs-number">5</span>]<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># list index out of range</span><br><br>name = <span class="hljs-string">&#x27;ssss&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(name)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># invalid literal for int() with base 10: &#x27;ssss&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-keyword">return</span> a<br><span class="hljs-keyword">try</span>:<br>    test()<br><span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># test() missing 1 required positional argument: &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="异常中的finally">5.2 异常中的finally</h2><ul><li>无论是否发生异常，只要定义了 <code>finally</code>，就一定会执行其中的代码块。</li><li>在函数中，即便在 <code>try</code> 或 <code>except</code> 中进行了 return 也依然会执行 <code>finally</code> 语法块</li><li><code>try</code> 语法至少要伴随 <code>except</code> 或 <code>finally</code> 中的一个来使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(e)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;finally&#x27;</span><br>t = test1()<br>print(t)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&#x27;1&#x27;</span>)<br>        <span class="hljs-keyword">return</span> e<br>    <span class="hljs-keyword">finally</span>:<br>        print(<span class="hljs-string">&#x27;2&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;finally&#x27;</span>  <span class="hljs-comment"># 即使在try和except中进行return，也依然会执行finally</span><br>    <br>--------------------------------------------------<br>division by zero<br><span class="hljs-keyword">finally</span><br><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span><br></code></pre></td></tr></table></figure><h2 id="自定义异常类型与抛出异常">5.3 自定义异常类型与抛出异常</h2><h3 id="自定义抛出异常-raise">5.3.1 自定义抛出异常 <code>raise</code></h3><p>将信息以报错的形式抛出。</p><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141932.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">if</span> number == <span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;number不可以是100&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> number<br><br>print(test(<span class="hljs-number">50</span>))<br>t = test(<span class="hljs-number">100</span>)  <span class="hljs-comment"># ValueError: number不可以是100</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> test(number)<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> e<br>    <br>t2 = test2(<span class="hljs-number">100</span>)<br>print(t2)<br><br>--------------------------------------------------<br><span class="hljs-number">50</span><br>number不可以是<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="自定义异常类">5.3.2 自定义异常类</h3><ul><li><strong>定义一个基类</strong>，然后继承基类----<code>Exception</code></li><li><strong>在构造函数中定义错误信息</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberLimitError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameLimitError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&#x27;小明&#x27;</span>:<br>        <span class="hljs-keyword">raise</span> NameLimitError(<span class="hljs-string">&#x27;小明不可以被填写&#x27;</span>)<br>    <span class="hljs-keyword">return</span> name<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test0</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">if</span> number &gt; <span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">raise</span> NumberLimitError(<span class="hljs-string">&#x27;数字不可以大于100&#x27;</span>)<br>    <span class="hljs-keyword">return</span> number<br><br><br><span class="hljs-keyword">try</span>:<br>    test(<span class="hljs-string">&#x27;小明&#x27;</span>)<br><span class="hljs-keyword">except</span> NameLimitError <span class="hljs-keyword">as</span> e:<br>    print(e)<br><br><span class="hljs-keyword">try</span>:<br>    test0(<span class="hljs-number">101</span>)<br><span class="hljs-keyword">except</span> NumberLimitError <span class="hljs-keyword">as</span> e:<br>    print(e)<br> <br>--------------------------------------------------<br>小明不可以被填写<br>数字不可以大于<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="断言">5.4 断言</h2><p>断言：用于判断一个表达式，在表达式条件为false的时候触发异常(为true不会触发异常，继续执行)。</p><p><code>assert expression, message</code></p><ul><li><code>expression</code> ：表达式，一般是判断相等，或者判断是某种数据类型的 <code>bool</code> 判断的语句</li><li><code>message</code> ：具体的错误信息</li><li>无返回值</li></ul><h3 id="使用断言对综合案例进行改进">使用断言对综合案例进行改进</h3><p>很好的案例。一定要吃透！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    学生信息库</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>students = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小鱼&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小何&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">5</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小安&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 缺少参数的错误，定义一个基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotArgError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentInfo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, students</span>):</span><br>        self.students = students<br><br>    <span class="hljs-comment"># 查找，通过学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_id</span>(<span class="hljs-params">self, student_id</span>):</span><br>        <span class="hljs-keyword">return</span> self.students.get(student_id)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_students</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># get_all_students</span><br>        <span class="hljs-keyword">for</span> id_, value <span class="hljs-keyword">in</span> self.students.items():<br>            print(<span class="hljs-string">&#x27;学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                id_, value[<span class="hljs-string">&#x27;name&#x27;</span>], value[<span class="hljs-string">&#x27;age&#x27;</span>], value[<span class="hljs-string">&#x27;sex&#x27;</span>], value[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>            ))<br>        <span class="hljs-keyword">return</span> self.students<br><br>    <span class="hljs-comment"># 添加单个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, **student</span>):</span>  <span class="hljs-comment"># add_student</span><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.__add(**student)<br><br>    <span class="hljs-comment"># 添加多个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adds</span>(<span class="hljs-params">self, new_students</span>):</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> new_students:<br>            <span class="hljs-keyword">try</span>:<br>                self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                print(e, student.get(<span class="hljs-string">&#x27;name&#x27;</span>))<br>                <span class="hljs-keyword">continue</span><br>            self.__add(**student)<br><br>    <span class="hljs-comment"># 添加新的学号；并将新的学生入库</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add</span>(<span class="hljs-params">self, **student</span>):</span><br>        new_id = <span class="hljs-built_in">max</span>(self.students) + <span class="hljs-number">1</span><br>        self.students[new_id] = student<br><br>    <span class="hljs-comment"># 删除</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, student_id</span>):</span>  <span class="hljs-comment"># delete_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;号的同学的信息不存在&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br>        <span class="hljs-keyword">else</span>:<br>            user_info = self.students.pop(student_id)<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>    <span class="hljs-comment"># 批量删除，删除学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deletes</span>(<span class="hljs-params">self, ids</span>):</span><br>        <span class="hljs-keyword">for</span> id_ <span class="hljs-keyword">in</span> ids:  <span class="hljs-comment"># id_防止和函数id()冲突</span><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;id_&#125;</span> 不存在学生库中&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br>            student_info = students.pop(id_)<br>            print(<span class="hljs-string">f&#x27;学号<span class="hljs-subst">&#123;id_&#125;</span> 学生<span class="hljs-subst">&#123;student_info[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span> 已被移除&#x27;</span>)<br><br><br>    <span class="hljs-comment"># 修改</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, student_id, **kwargs</span>):</span>  <span class="hljs-comment"># update_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;不存在学号：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**kwargs)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.students[student_id] = kwargs<br>        print(<span class="hljs-string">&#x27;&#123;&#125;同学信息更新完毕&#x27;</span>.<span class="hljs-built_in">format</span>(kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>    <span class="hljs-comment"># 批量更新，key是学号，value是信息  # todo:添加异常捕获 17&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updates</span>(<span class="hljs-params">self, update_students</span>):</span>  <span class="hljs-comment"># update_students是一个列表</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> update_students:<br>            <span class="hljs-keyword">try</span>:<br>                id_ = <span class="hljs-built_in">list</span>(student.keys())[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 不加list()是假列表  # todo：添加异常捕获  # list可能没有0索引</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续循环列表</span><br><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;学号 <span class="hljs-subst">&#123;id_&#125;</span> 不存在&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br><br>            user_info = student[id_]<br>            <span class="hljs-keyword">try</span>:<br>                check = self.check_user_info(**user_info)  <span class="hljs-comment"># todo：添加异常捕获</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span><br>            self.students[id_] = user_info<br>        print(<span class="hljs-string">&#x27;所有信息更新完成&#x27;</span>)<br><br>    <span class="hljs-comment"># 查询</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_users</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;参数数量传递错误&#x27;</span>  <span class="hljs-comment"># 参数不能为空，长度必须是1</span><br><br>        values = <span class="hljs-built_in">list</span>(self.students.values())<br>        key = <span class="hljs-literal">None</span><br>        value = <span class="hljs-literal">None</span><br>        result = []<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;name&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;age&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;sex&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;class_number&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;没有发现搜索的关键字&#x27;</span>)<br><br>        <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> values:  <span class="hljs-comment"># 吐过想用年龄字段模糊查询，需要把年龄改成str类型</span><br>            <span class="hljs-comment"># print(user[key])</span><br>            <span class="hljs-comment"># print(value)</span><br>            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">in</span> user[key]:  <span class="hljs-comment"># in 替代 = 实现模糊查找</span><br>                result.append(user)<br><br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-comment"># 验证参数是否合法，检查位置参数的判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_info</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-comment"># 判断长度是否为4；判断是否我们要的四个参数；判断参数类型是否正确</span><br>        <span class="hljs-comment"># 判断长度是否为4</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;参数必须是4个&#x27;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生姓名参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生年龄参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生性别参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生班级参数&#x27;</span>)<br><br>        <span class="hljs-comment"># 确认四个参数是不是想要的数据类型</span><br>        <span class="hljs-comment"># 先取出数据</span><br>        name_value = kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]<br>        age_value = kwargs[<span class="hljs-string">&#x27;age&#x27;</span>]<br>        sex_value = kwargs[<span class="hljs-string">&#x27;sex&#x27;</span>]<br>        class_number_value = kwargs[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br><br>        <span class="hljs-comment"># isinstance(对比的数据, 数据类型) isinstance(1, str)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(name_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;name 应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age_value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;age应该是整型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(sex_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;sex应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(class_number_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;class_number应该是字符串类型&#x27;</span>)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    student_info = StudentInfo(students)<br>    user = student_info.get_user_by_id(<span class="hljs-number">1</span>)<br>    student_info.add(name=<span class="hljs-string">&#x27;小绿&#x27;</span>, age=<span class="hljs-number">34</span>, class_number=<span class="hljs-string">&#x27;A&#x27;</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>    print(student_info.students)<br><br>    users = [<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小橙&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小黄&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>    ]<br>    student_info.adds(users)<br>    student_info.get_all_students()<br><br>    student_info.deletes([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>])<br>    student_info.get_all_students()<br><br>    student_info.updates([<br>        &#123;<span class="hljs-number">2</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;何同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span>&#125;&#125;,<br>        &#123;<span class="hljs-number">4</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span>&#125;&#125;<br>    ])<br>    student_info.get_all_students()<br><br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;小&#x27;</span>)<br>    print(result)<br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 会把所有的都打印出来</span><br>    print(result)<br><br></code></pre></td></tr></table></figure><h1 id="bug">6. bug</h1><p>bug 是程序中出现的错误，但有没有通过异常去捕获，以至于直接抛出，导致程序的崩溃。</p><p>如何检查 bug？</p><ol type="1"><li><p>调试工具(eg.pycharm) debug。在想要停止的行的左侧点击一下会出现一个小红点，断点。程序运行到这行会停止(包括这一行)。</p></li><li><p>多打印信息。(多print可以聚焦错误点，简单)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
