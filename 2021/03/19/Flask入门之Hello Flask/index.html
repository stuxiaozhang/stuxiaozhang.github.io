<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/favicon.png"><link rel="icon" href="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="Flask 入门之Hello Flask
追溯到最初，Flask 诞生于 Armin Ronacher 在 2010 年愚人节开的一个玩笑。后来，它逐渐发展成为一个成熟的 Python Web 框架，越来越受到开发者的喜爱。目前它在 GitHub 上是 Star 数量最多的 Python Web 框架，没有之一。
Flask 是典型的微框架，作为 Web 框架来说，它仅保留了核心功能：请求响应"><meta name="author" content="小张同学"><meta name="keywords" content=""><title>Flask入门之Hello Flask - 小张同学的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"stuxiaozhang.github.io",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",app_key:"CgnvRL262D07ied40NiXm2VL",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><header style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>xiaozhang's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/schedule/"><i class="iconfont icon-cliplist"></i> 动态</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Flask入门之Hello Flask"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 小张同学 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-19 09:15" pubdate>2021年3月19日</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 81 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-1"></div><div class="col-lg-9 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Flask入门之Hello Flask</h1><p class="note note-info">本文最后更新于：2021年6月6日</p><div class="markdown-body"><h1 id="flask-入门之hello-flask">Flask 入门之Hello Flask</h1><p>追溯到最初，Flask 诞生于 Armin Ronacher 在 2010 年愚人节开的一个玩笑。后来，它逐渐发展成为一个成熟的 Python Web 框架，越来越受到开发者的喜爱。目前它在 GitHub 上是 Star 数量最多的 Python Web 框架，没有之一。</p><p>Flask 是典型的微框架，作为 Web 框架来说，它仅保留了核心功能：<strong>请求响应处理</strong>和<strong>模板渲染</strong>。这两类功能分别由 Werkzeug（WSGI 工具库）完成和 Jinja（模板渲染库）完成，因为 Flask 包装了这两个依赖，我们暂时不用深入了解它们。</p><h2 id="第一个简单的主页">第一个简单的主页</h2><p><em>app.py：程序主页</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask  <span class="hljs-comment"># 从 flask 包导入 Flask 类</span><br>app = Flask(__name__)  <span class="hljs-comment"># 通过实例化这个类，创建一个程序对象 app</span><br><br><span class="hljs-comment"># 使用 app.route() 装饰器来为这个函数绑定对应的 URL，当用户在浏览器访问这个 URL 的时候，就会触发这个函数，获取返回值，并把返回值显示到浏览器窗口</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)  </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Welcome to My Watchlist!&#x27;</span><br></code></pre></td></tr></table></figure><p>按照惯例，我们把程序保存为 app.py，确保当前目录是项目的根目录，然后在命令行窗口执行 <code>flask run</code> 命令启动程序（按下 Control + C 可以退出）：</p><p>现在打开浏览器，访问 <a target="_blank" rel="noopener" href="http://localhost:8001/">http://localhost:8001</a> 即可访问我们的程序主页，并看到我们在程序里返回的问候语，如下图所示：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/前端/image-20210319224232086.png" srcset="/img/loading.gif" lazyload style="width:70%"></center><h3 id="解剖时间">解剖时间</h3><p>下面我们来分解这个 Flask 程序，了解它的基本构成。</p><p>首先我们从 <code>flask</code> 包导入 <code>Flask</code> 类，通过实例化这个类，创建一个程序对象 <code>app</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br></code></pre></td></tr></table></figure><p>接下来，我们要注册一个处理函数，这个函数是处理某个请求的处理函数，Flask 官方把它叫做<strong>视图函数（view funciton）</strong>，你可以理解为“<strong>请求处理函数</strong>”。</p><p>所谓的“注册”，就是给这个函数戴上一个装饰器帽子。我们使用 <code>app.route()</code> 装饰器来为这个函数绑定对应的 URL，当用户在浏览器访问这个 URL 的时候，就会触发这个函数，获取返回值，并把返回值显示到浏览器窗口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Welcome to My Watchlist!&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>提示</strong> 为了便于理解，你可以把 Web 程序看作是一堆这样的视图函数的集合：编写不同的函数处理对应 URL 的请求。</p></blockquote><p>填入 <code>app.route()</code> 装饰器的第一个参数是 URL 规则字符串，这里的 <code>/</code> 指的是根地址。</p><p>我们只需要写出相对地址，主机地址、端口号等都不需要写出。所以说，这里的 <code>/</code> 对应的是主机名后面的路径部分，完整 URL 就是 http://localhost:8001/。如果我们这里定义的 URL 规则是 <code>/hello</code>，那么完整 URL 就是 http://localhost:8001/hello。</p><p>整个请求的处理过程如下所示：</p><ol type="1"><li>当用户在浏览器地址栏访问这个地址，在这里即 <a target="_blank" rel="noopener" href="http://localhost:8001/" class="uri">http://localhost:8001/</a></li><li>服务器解析请求，发现请求 URL 匹配的 URL 规则是 <code>/</code>，因此调用对应的处理函数 <code>hello()</code></li><li>获取 <code>hello()</code> 函数的返回值，处理后返回给客户端（浏览器）</li><li>浏览器接受响应，将其显示在窗口上</li></ol><h3 id="url-配置及报文显示">URL 配置及报文显示</h3><h4 id="url-及-http-基础知识">URL 及 HTTP 基础知识</h4><ul><li>什么是 URL？<ul><li>Uniformed Resource Locator，统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁表示，是互联网上标准资源的地址</li><li>互联网上的每个文件都有一个唯一的 URL</li></ul></li><li>常见的网络协议有哪些？<ul><li>http：超文本传输协议</li><li>https：用安全套接字层传送的超文本传输协议</li><li>ftp：文件传输协议</li></ul></li><li>常见的 HTTP 请求方式有哪些？有什么区别？<ul><li>GET 请求：<ul><li>可以用浏览器直接访问</li><li>请求可以携带参数，但是有长度限制</li><li>请求参数直接放在 URL 后面</li></ul></li><li>POST 请求<ul><li>不能使用浏览器直接访问</li><li>对请求参数的长度没有限制</li><li>可以用来上传文件等需求</li></ul></li></ul></li><li>不同的 HTTP 响应状态码有什么含义？<ul><li>2xx：请求成功</li><li>3xx：重定向</li><li>4xx：请求错误</li><li>5xx：服务器错误</li></ul></li></ul><p>详细的网络相关知识可以看这篇文章<a href="https://stuxiaozhang.github.io/2020/09/30/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络课堂笔记总结</a>。</p><h4 id="路由配置">路由配置</h4><h5 id="使用装饰器">1. 使用装饰器</h5><p><strong><code>@app.route(url_name, methods)</code></strong></p><ul><li>url：匹配的 URL 地址</li><li>methods：所支持的请求方式（[‘GET’, ‘POST’]）</li></ul><p>栗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br></code></pre></td></tr></table></figure><h5 id="使用-api-配置">2. 使用 API 配置</h5><p><strong><code>@app.add_url_rule(url, url_name, view_name)</code></strong></p><ul><li>url：匹配的 URL 地址</li><li>url_name：给 URL 的命名</li><li>view_name：视图函数</li></ul><p>栗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">app.add_url_rule(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-string">&#x27;home&#x27;</span>, hello)  <span class="hljs-comment"># url, url名字, 视图函数</span><br></code></pre></td></tr></table></figure><h3 id="实验时间">实验时间</h3><h4 id="修改视图函数返回值">修改视图函数返回值</h4><p>首先，可以自由修改视图函数的返回值，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">u&#x27;欢迎来到我的 Watchlist！&#x27;</span><br></code></pre></td></tr></table></figure><p>返回值作为响应的主体，默认会被浏览器作为 HTML 格式解析，所以我们可以添加一个 HTML 元素标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello Totoro!&lt;/h1&gt;&lt;img src=&quot;http://helloflask.com/totoro.gif&quot;&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>保存修改后，只需要在浏览器里刷新页面，就会看到页面上的内容也会随之变化。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/Hello Totoro.png" srcset="/img/loading.gif" lazyload style="width:60%"></center><h4 id="修改-url-匹配规则">修改 URL 匹配规则</h4><h5 id="匹配整个文字">1. 匹配整个文字</h5><p><strong><code>@app.route('/hello')</code></strong></p><p>可以自由修改传入 <code>app.route</code> 装饰器里的 URL 规则字符串，但要注意以斜线 <code>/</code> 作为开头。访问地址也要对应改变。比如下面的视图函数对应的访问地址就应该是：http://localhost:8001/home</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/home&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Welcome to My Watchlist!&#x27;</span><br></code></pre></td></tr></table></figure><p>一个视图函数也可以绑定多个 URL，这通过附加多个装饰器实现，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/index&#x27;</span></span>)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/home&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Welcome to My Watchlist!&#x27;</span><br></code></pre></td></tr></table></figure><p>现在无论是访问 http://localhost:8001/、http://localhost:8001/home 还是 http://localhost:8001/index 都可以看到返回值。</p><h5 id="传递参数">2. 传递参数</h5><p><strong><code>@app.route('/user/&lt;username&gt;')</code></strong></p><p>在前面，我们之所以把传入 <code>app.route</code> 装饰器的参数称为 URL 规则，是因为我们也可以在 URL 里定义变量部分。比如下面这个视图函数会处理所有类似 <code>/user/&lt;username&gt;</code> 的请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&lt;username&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_page</span>(<span class="hljs-params">username</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;User page&#x27;</span><br></code></pre></td></tr></table></figure><p>不论你访问 http://localhost:8001/user/greyli，还是 http://localhost:8001/user/peter，抑或是 http://localhost:8001/user/，都会触发这个函数。通过下面的方式，我们也可以在视图函数里获取到这个变量值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> escape<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&lt;username&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_page</span>(<span class="hljs-params">username</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;User: %s&#x27;</span> % escape(username)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 用户输入的数据会包含恶意代码，所以不能直接作为响应返回，需要使用 Flask 提供的 escape() 函数对 name 变量进行转义处理，比如把 <code>&lt;</code> 转换成 <code>&amp;lt;</code>。这样在返回响应时浏览器就不会把它们当做代码执行。</p></blockquote><h5 id="指定参数类型">3. 指定参数类型</h5><p><strong><code>@app.route('/post/&lt;int:post_id&gt;')</code></strong></p><p>URL 参数类型：</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/URL 参数类型.png" srcset="/img/loading.gif" lazyload style="width:70%"></center><p>对于 URL 变量，Flask 还支持在 URL 规则字符串里对变量设置处理器，对变量进行预处理。比如 <code>/user/&lt;int:number&gt;</code> 会将 URL 中的 number 部分处理成整型，同时这个变量值接收传入数字。</p><h3 id="请求-响应及上下文对象">请求-响应及上下文对象</h3><h4 id="请求-响应">请求-响应</h4><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/请求-响应.png" srcset="/img/loading.gif" lazyload style="width:80%"></center><p>Flask从客户端收到请求时，需让试图函数能访问一些对象，才能处理请求。请求对象是一个很好的例子，它封装了客户端发送的HTTP请求。</p><p>让视图函数能够访问请求对象最直接的方式，是将其作为参数传入视图函数。 缺点：导致应用中每个视图函数都多处一个参数。</p><blockquote><p>除了访问请求对象，如果视图函数在处理请求时还要访问其他对象，就更乱了。</p></blockquote><p>Flask使用上下文临时把某些对象变为全局可访问。</p><p>Flask的两种上下文：应用上下文和请求上下文。</p><ul><li><p>应用上下文</p><ul><li>current_app：当前应用的应用实例（指：FLask实例化的app对象）</li><li>g：处理请求时用作临时存储的对象，每次请求都会重设它。</li></ul></li><li><p>请求上下文</p><ul><li><p>request：请求对象，封装了客户端发出的HTTP请求中的内容。</p></li><li><p>session：用户会话，值为一个字典，存储请求之间(前？)需要”记住“的值</p></li></ul></li></ul><p>Flask 在分派请求之前激活（或推送）应用和请求上下文，请求处理完成后再将其删除。</p><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/index&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    print(app)<br>    print(current_app)  <span class="hljs-comment"># 应用上下文对象</span><br>    print(app == current_app)  <span class="hljs-comment"># True：里面的东西是一样的</span><br>    print(app <span class="hljs-keyword">is</span> current_app)  <span class="hljs-comment"># False：但是不是同一个引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;index&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test/req&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_request</span>():</span><br>    get_args = request.args<br>    print(get_args)<br>    <span class="hljs-comment"># 页码一定是正整数</span><br>    page = request.args.get(<span class="hljs-string">&#x27;page&#x27;</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 默认第1页</span><br>    print(page)<br><br>    <span class="hljs-comment"># 服务器所在的主机地址</span><br>    headers = request.headers<br>    print(headers)<br>    print(<span class="hljs-string">&#x27;服务器所在的主机地址&#x27;</span>, headers.get(<span class="hljs-string">&#x27;host&#x27;</span>))<br><br>    <span class="hljs-comment"># 获取ip地址</span><br>    ip = request.remote_addr<br>    print(<span class="hljs-string">&#x27;远程ip地址&#x27;</span>, ip)<br><br>    <span class="hljs-comment"># 获取 user-agent</span><br>    user_agent = request.headers.get(<span class="hljs-string">&#x27;User-Agent&#x27;</span>, <span class="hljs-literal">None</span>)<br>    print(<span class="hljs-string">&#x27;User_Agent&#x27;</span>, user_agent)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;request success&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="请求分派">请求分派</h4><p>URL 映射是 URL 和视图函数之间的对应关系。</p><center><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/编程语言/Flask/请求分派.png" srcset="/img/loading.gif" lazyload style="width:90%"></center><h4 id="请求钩子">请求钩子</h4><p>在请求开始时，可能需要创建数据库连接或者验证发起请求的用户身份。为避免在每个视图函数中都重复编写代码，Flask 提供了注册通用函数功能，注册的函数可在请求被分派视图函数之前或之后调用。</p><p>请求钩子通过装饰器实现。Flask支持以下4种钩子：</p><ul><li><p><strong><code>@app.before_first_request</code></strong></p><p>注册一个函数，只在处理第一个请求之前运行。</p></li><li><p><strong><code>@app.before_request</code></strong></p><p>注册一个函数，在每次请求之前运行。</p></li><li><p><strong><code>@app.after_request</code></strong></p><p>注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。</p></li><li><p><strong><code>@app.teardown_request</code></strong></p><p>注册一个函数，即使有未处理的异常抛出，在每次请求之后运行。</p></li></ul><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.before_first_request</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">first_request</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 服务器启动后第一个请求到达 &quot;&quot;&quot;</span><br>    print(<span class="hljs-string">&#x27;first_request&#x27;</span>)<br><br><br><span class="hljs-meta">@app.before_request</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">per_request</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 每一个请求到达前 &quot;&quot;&quot;</span><br>    print(<span class="hljs-string">&#x27;before_request&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="cookie-和-session">cookie 和 session</h4><ol type="1"><li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li><li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li><li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</li></ol><p>所以，总结一下： <strong>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</strong> <strong>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</strong></p><p><strong>要处理Session，则必须为 <em>app</em> 实例设置SECRET_KEY 配置随机数生成器（Session ID），再使用session函数进行操作</strong></p><blockquote><p><code>app.config['SECRET_KEY'] = os.urandom(24)</code> #生成随机数种子，用于产生sessionID</p></blockquote><p><strong>要处理Cookie，需要使用 <em>response</em> 对象来往HTTP的响应中写入满足HTTP协议的Cookie要求的信息（key，value，Age有效期）</strong></p><p>session栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;session-func&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">session_func</span>():</span><br>    session[<span class="hljs-string">&#x27;username&#x27;</span>] = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>    session[<span class="hljs-string">&#x27;nickname&#x27;</span>] = <span class="hljs-string">&#x27;zhang&#x27;</span><br>    session[<span class="hljs-string">&#x27;role&#x27;</span>] = <span class="hljs-string">&#x27;editor&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span><br>    <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/sc/read&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scread</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;你当前的昵称为：%s&#x27;</span> % session.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>cookie栗子：</p><p>利用自定义相应的方式来往浏览器设置cookie</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/cookie&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cookie</span>():</span><br>    response = make_response(<span class="hljs-string">&quot;这是设置cookie的操作&quot;</span>)  <span class="hljs-comment"># 构建一个响应对象</span><br>    response.set_cookie(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;xiaozhang&#x27;</span>, max_age=<span class="hljs-number">60</span>)<br>    response.set_cookie(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-string">&#x27;1234&#x27;</span>, max_age=<span class="hljs-number">60</span>)<br>    <span class="hljs-keyword">return</span> response<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/sc/read&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scread</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;你当前的昵称为：%s&#x27;</span> % request.cookies.get(<span class="hljs-string">&#x27;username&#x27;</span>)  <span class="hljs-comment"># cookie从请求中来？</span><br><br></code></pre></td></tr></table></figure><p>==<strong>cookie从请求中来？</strong>==</p><h4 id="请求报文">请求报文</h4><p>Flask 通过上下文变量 request 对外开放请求对象，它包含客户端发送的 HTTP 请求的全部信息。</p><p>一些请求报文常用参数：</p><ul><li>method：请求的类型（GET/POST等）</li><li><strong>form：POST 请求的数据dict</strong></li><li><strong>args：GET 请求数据dict</strong></li><li>values：POST 请求和 GET 请求数据集合 dict</li><li>files：上传的文件数据 dict</li><li>cookies：请求中的 cookie dict</li><li>headers：HTTP 请求头</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 请求参数的问题：</span><br><span class="hljs-comment"># 1. URL地址自带的查询参数： http://127.0.0.1:5000/test?username=xz&amp;psd=xz</span><br><span class="hljs-comment"># 2. 通过flask自定义的路由规则和参数：http://127.0.0.1:5000/article/&lt;articleid&gt;  可变的部分用&lt;&gt;表示</span><br><span class="hljs-comment"># 3. POST请求的参数，通过POST正文传输。</span><br><br><span class="hljs-comment"># 查询参数：(GET用request.args)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    username = request.args.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.args.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;用户名为 %s, 密码为 %s&#x27;</span> % (username, password)<br><br><br><span class="hljs-comment"># 路由地址参数，路由地址参数必须同步定义接口函数里面作为该参数的形参</span><br><span class="hljs-comment"># 由于articleid是一个整数，所以可以在定义路由参数时，直接用int进行类型限制</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article/&lt;int:articleid&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">article</span>(<span class="hljs-params">articleid</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;你正在访问编号为： <span class="hljs-subst">&#123;articleid&#125;</span> 的文章&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    username = request.form.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.form.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&#x27;xz&#x27;</span> &amp; password == <span class="hljs-string">&#x27;xz&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success2&#x27;</span><span class="hljs-comment"># 请求参数的问题：</span><br><span class="hljs-comment"># 1. URL地址自带的查询参数： http://127.0.0.1:5000/test?username=xz&amp;psd=xz</span><br><span class="hljs-comment"># 2. 通过flask自定义的路由规则和参数：http://127.0.0.1:5000/article/&lt;articleid&gt;  可变的部分用&lt;&gt;表示</span><br><span class="hljs-comment"># 3. POST请求的参数，通过POST正文传输。</span><br><br><span class="hljs-comment"># 查询参数：(GET用request.args)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    username = request.args.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.args.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;用户名为 %s, 密码为 %s&#x27;</span> % (username, password)<br><br><br><span class="hljs-comment"># 路由地址参数，路由地址参数必须同步定义接口函数里面作为该参数的形参</span><br><span class="hljs-comment"># 由于articleid是一个整数，所以可以在定义路由参数时，直接用int进行类型限制</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article/&lt;int:articleid&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">article</span>(<span class="hljs-params">articleid</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;你正在访问编号为： <span class="hljs-subst">&#123;articleid&#125;</span> 的文章&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    username = request.form.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.form.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&#x27;xz&#x27;</span> &amp; password == <span class="hljs-string">&#x27;xz&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success2&#x27;</span><span class="hljs-comment"># 请求参数的问题：</span><br><span class="hljs-comment"># 1. URL地址自带的查询参数： http://127.0.0.1:5000/test?username=xz&amp;psd=xz</span><br><span class="hljs-comment"># 2. 通过flask自定义的路由规则和参数：http://127.0.0.1:5000/article/&lt;articleid&gt;  可变的部分用&lt;&gt;表示</span><br><span class="hljs-comment"># 3. POST请求的参数，通过POST正文传输。</span><br><br><span class="hljs-comment"># 查询参数：(GET用request.args)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    username = request.args.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.args.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;用户名为 %s, 密码为 %s&#x27;</span> % (username, password)<br><br><br><span class="hljs-comment"># 路由地址参数，路由地址参数必须同步定义接口函数里面作为该参数的形参</span><br><span class="hljs-comment"># 由于articleid是一个整数，所以可以在定义路由参数时，直接用int进行类型限制</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article/&lt;int:articleid&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">article</span>(<span class="hljs-params">articleid</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;你正在访问编号为： <span class="hljs-subst">&#123;articleid&#125;</span> 的文章&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    username = request.form.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.form.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&#x27;xz&#x27;</span> &amp; password == <span class="hljs-string">&#x27;xz&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success2&#x27;</span><span class="hljs-comment"># 请求参数的问题：</span><br><span class="hljs-comment"># 1. URL地址自带的查询参数： http://127.0.0.1:5000/test?username=xz&amp;psd=xz</span><br><span class="hljs-comment"># 2. 通过flask自定义的路由规则和参数：http://127.0.0.1:5000/article/&lt;articleid&gt;  可变的部分用&lt;&gt;表示</span><br><span class="hljs-comment"># 3. POST请求的参数，通过POST正文传输。</span><br><br><span class="hljs-comment"># 查询参数：(GET用request.args)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    username = request.args.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.args.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;用户名为 %s, 密码为 %s&#x27;</span> % (username, password)<br><br><br><span class="hljs-comment"># 路由地址参数，路由地址参数必须同步定义接口函数里面作为该参数的形参</span><br><span class="hljs-comment"># 由于articleid是一个整数，所以可以在定义路由参数时，直接用int进行类型限制</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article/&lt;int:articleid&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">article</span>(<span class="hljs-params">articleid</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;你正在访问编号为： <span class="hljs-subst">&#123;articleid&#125;</span> 的文章&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    username = request.form.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    password = request.form.get(<span class="hljs-string">&#x27;password&#x27;</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&#x27;xz&#x27;</span> &amp; password == <span class="hljs-string">&#x27;xz&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success2&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="响应报文">响应报文</h4><p>Flask 调用视图函数后，会将其返回值作为响应的内容。多数情况下，响应就是一个简单的字符串，作为 HTML 页面回送客户端。</p><p>响应对象最常使用的属性和方法表：</p><table><thead><tr class="header"><th>属性或方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>status_code</td><td>HTTP 状态码</td></tr><tr class="even"><td>headers</td><td>类似字典的对象，包含随机响应发送的所有首部</td></tr><tr class="odd"><td>set_cookie()</td><td>为响应添加一个cookie</td></tr><tr class="even"><td>delete_cookie()</td><td>删除一个cookie</td></tr><tr class="odd"><td>content_length</td><td>响应主体的长度</td></tr><tr class="even"><td>content_type</td><td>响应主体的媒体类型</td></tr><tr class="odd"><td>set_data()</td><td>使用字符串或字节值设定响应</td></tr><tr class="even"><td>get_data()</td><td>获取响应主体</td></tr></tbody></table><p>栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test/resp&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_response</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot; 测试响应 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;response success&#x27;</span>, <span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;user_id&#x27;</span>: <span class="hljs-string">&#x27;my_user_id&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment">#通过 make_response 构造一个响应对象，和上面是一样的</span><br>    resp = make_response(<span class="hljs-string">&#x27;这是一个响应对象&#x27;</span>, <span class="hljs-number">403</span>, &#123;<br>        <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-string">&#x27;123&#x27;</span><br>    &#125;)<br>    <span class="hljs-comment"># 同上，添加响应头和改变状态码</span><br>    resp.headers[<span class="hljs-string">&#x27;user_id&#x27;</span>] = <span class="hljs-string">&#x27;myid_123&#x27;</span><br>    <span class="hljs-comment"># resp.status_code = 201</span><br><br>    <span class="hljs-comment"># 响应html</span><br>    html = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1 style=&#x27;color:#f00&#x27;&gt;一段文本显示&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span><br>    resp = make_response(html)<br>    <span class="hljs-keyword">return</span> resp<br><br></code></pre></td></tr></table></figure><h5 id="重定向-redirct">重定向 redirct()</h5><p>响应有一个特殊的类型，称为重定向。这种响应无页面文档，只会告诉浏览器一个URL，用以加载新页面。重定向经常在Web表单中使用。</p><p>重定向的状态码通常是302。</p><p>Flask提供了 <code>redirect()</code> 辅助函数，用于生成这种响应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> redirect<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h5 id="处理错误-abort">处理错误 abort()</h5><p>有一种特殊的响应由 <code>abort()</code> 函数生成，用于处理错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;视图函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 处理错误/触发了异常，跳转到指定的页面。不需要return</span><br>    ip_blacklist = [<span class="hljs-string">&#x27;127.0.0.2&#x27;</span>]<br>    ip = request.remote_addr<br>    <br>    <span class="hljs-keyword">if</span> ip <span class="hljs-keyword">in</span> ip_blacklist:<br>        abort(<span class="hljs-number">403</span>)<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Python/">Python</a> <a class="hover-with-bg" href="/tags/Flask/">Flask</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处来源：<a href="https://stuxiaozhang.github.io/">小张的宇宙空间站</a></p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2021/03/20/Flask%E5%85%A5%E9%97%A8%E4%B9%8B%E6%A8%A1%E6%9D%BF/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Flask入门之模板</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2021/03/16/ECharts%E4%BB%8B%E7%BB%8D/"><span class="hidden-mobile">ECharts介绍</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",function(){var e=Object.assign({appId:"81O1jSOqY3veRxOg71BDYfri-gzGzoHsz",appKey:"CgnvRL262D07ied40NiXm2VL",placeholder:"快来评论鸭~",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:"https://cdn.bootcdn.net/ajax/libs/emojione/4.5.0/lib/js/emojione.min.js",emojiMaps:null,enableQQ:!0,requiredFields:["nick"]},{el:"#valine",path:window.location.pathname});new Valine(e)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://stuxiaozhang.github.io" target="_blank" rel="nofollow noopener"><span>小张同学的宇宙空间站</span></a> 已经运转了<span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{renderActions:{findScript:[10,a=>{document.querySelectorAll('script[type^="math/tex"]').forEach(e=>{var t=!!e.type.match(/; *mode=display/);const n=new a.options.MathItem(e.textContent,a.inputJax[0],t);t=document.createTextNode("");e.parentNode.replaceChild(t,e),n.start={node:t,delim:"",n:0},n.end={node:t,delim:"",n:0},a.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>