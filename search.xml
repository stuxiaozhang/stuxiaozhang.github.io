<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux 常用指令记录</title>
    <url>/2021/10/13/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<div class="note note-info">
            <p>以后学某一项技术，可以去看官方文档入门教程。以后边写边查即可。(from y总)</p><p>不定时更新。努力学习记录中...:p</p>
          </div>
<h2 id="文件管理命令">文件管理命令</h2>
<p><code>.</code>：当前目录（也是文件）</p>
<p><code>..</code>：上层目录</p>
<p>绝对路径 以 <code>/</code> 开头，相对路径直接是文件夹名</p>
<p>常用命令介绍</p>
<ol type="1">
<li><p><code>ctrl c</code>：取消命令，并且换行（比如说你不想打这行或者打错了，直接 crtl c 换一行，就是 换行＋清空）</p></li>
<li><p><code>ctrl u</code>：清空本行命令</p></li>
<li><p><code>tab键</code>：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li>
<li><p><code>ls</code>: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p>
<ul>
<li><code>-a</code> 显示所有文件及目录 (. 开头的隐藏文件也会列出)</li>
<li><code>-l</code> 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出
<ul>
<li><code>-lh</code> 加个 h，可以人性化输出，比如 30952字节，就会写成 31k，方便看~</li>
</ul></li>
<li><code>-A</code> 同 <code>-a</code> ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录)</li>
<li><code>-t</code> 按建立时间</li>
</ul></li>
<li><p><code>pwd</code>：显示当前路径</p></li>
<li><p><code>cd XXX</code>： 进入XXX目录下，<code>cd ..</code> 返回上层目录</p></li>
<li><p><code>cp XXX YYY</code>：将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如 ../dir_c/a.txt，表示上层目录下的 dir_c 文件夹下的文件 a.txt</p>
<p><code>cp</code> = 复制 + 粘贴 + 重命名</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144435.png" /></p>
<p>可以将一个文件夹整个复制到另一个文件夹下面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144452.png" /></p>
<p>也可以将一个文件夹复制到当前目录下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144507.png" /></p>
<p>Note：复制文件夹一定要加 <code>-r</code> （r 是递归的缩写）</p></li>
<li><p><code>mkdir XXX</code>：创建目录XXX</p>
<blockquote>
<p>遇到文件夹名称有空格，转义字符就行 <code>/</code>。eg <code>cp a y/ c</code></p>
</blockquote></li>
<li><p><code>rm XXX</code>：删除普通文件;</p>
<p><code>rm XXX -r</code>：删除文件夹</p>
<p>可以删掉整个文件夹连带着里面的文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144526.png" /></p>
<p>也可以只删除文件夹下面的文件而保留文件夹</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144539.png" /></p></li>
<li><p><code>mv XXX YYY</code>：剪切+粘贴+重命名。将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144603.png" /></p>
<p>重命名也是用这个命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144627.png" /></p>
<blockquote>
<p>cp：是拷贝一份</p>
<p>mv：是移动一份</p>
</blockquote></li>
<li><p><code>touch XXX</code>：创建一个文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144733.png" /></p></li>
<li><p><code>cat XXX</code>：展示文件XXX中的内容</p></li>
<li><p>复制文本 windows/Linux下：<code>Ctrl + insert</code>，Mac下：<code>command + c</code></p></li>
<li><p>粘贴文本 windows/Linux下：<code>Shift + insert</code>，Mac下：<code>command + v</code></p></li>
</ol>
<blockquote>
<p>笔记本上需要加 fn 键，复制是 <code>ctrl + fn + insert</code>，粘贴是 <code>shift + fn +insert</code></p>
</blockquote>
<h2 id="tmux">tmux</h2>
<p>tmux主要是用来远程ssh上去服务器交互用</p>
<h3 id="功能">功能</h3>
<ol type="1">
<li>分屏。</li>
<li><strong>允许断开Terminal连接后，继续运行进程</strong>。</li>
</ol>
<h3 id="结构">结构</h3>
<p>一个 tmux 可以包含多个 session，一个 session 可以包含多个 window，一个 window 可以包含多个 pane。</p>
<h3 id="实例">实例</h3>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">tmux:<br>	session <span class="hljs-number">0</span>:<br>		<span class="hljs-built_in">window</span> <span class="hljs-number">0</span>:<br>			pane <span class="hljs-number">0</span><br>			pane <span class="hljs-number">1</span><br>			pane <span class="hljs-number">2</span><br>			...<br>		<span class="hljs-built_in">window</span> <span class="hljs-number">1</span><br>		<span class="hljs-built_in">window</span> <span class="hljs-number">2</span><br>		...<br>	session <span class="hljs-number">1</span><br>	session <span class="hljs-number">2</span><br>	...<br></code></pre></td></tr></table></figure>
<h3 id="常用的操作">常用的操作</h3>
<ol type="1">
<li><code>tmux</code>：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</li>
<li><code>tmux new -s name</code>：新建一个名为 name 的 session</li>
<li><code>tmux ls</code>：显示已有tmux列表</li>
<li><code>tmux attach -t name</code>：从终端打开之前挂起的session。</li>
<li><code>ctrl + b</code>，再按<code>d</code> 挂起session，就是退化该会话，但不会关闭会话。</li>
<li><code>tmux kill-session -t name</code>：关闭名为 name 会话（销毁会话）</li>
<li><code>tmux rename -t name newname</code>：更名</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406155813.png" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406155817.png" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406155830.png" /></p>
<h3 id="tmux使用时出现的问题">tmux使用时出现的问题</h3>
<p>1、conda 的环境用不了</p>
<p>首先退出并关闭会话，在终端退出conda环境，新建进入会话，在tmux会话中激活所需conda环境方可生效。</p>
<h3 id="操作-在ubuntu都是-ctrl-b">操作 （在ubuntu都是 <code>ctrl + b</code>）</h3>
<ol type="1">
<li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>%</code>：将当前pane左右平分成两个pane。</p></li>
<li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>&quot;</code>（注意是双引号&quot;）：将当前pane上下平分成两个pane。</p></li>
<li><p><code>Ctrl + d</code>：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</p></li>
<li><p>鼠标点击可以选pane。</p></li>
<li><p>按下<code>ctrl + a</code>后手指松开，然后按方向键：选择相邻的pane。</p></li>
<li><p>鼠标拖动pane之间的分割线，可以调整分割线的位置。</p></li>
<li><p>按住<code>ctrl + a</code>的同时按方向键，可以调整pane之间分割线的位置。</p></li>
<li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>z</code>：将当前pane全屏/取消全屏。</p></li>
<li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>d</code>：挂起当前session。</p></li>
<li><p>按下<code>ctrl + a</code>后手指松开，然后按<code>s</code>：选择其它session。 方向键 —— 上：选择上一项 session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键 —— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window</p></li>
<li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>c</code>：在当前session中创建一个新的window。</p></li>
<li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>w</code>：选择其他window，操作方法与(12)完全相同。</p>
<blockquote>
<p>每个 session 开一个 window 这样清楚些..</p>
</blockquote></li>
<li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>PageUp</code>：翻阅当前pane内的内容。</p></li>
<li><p><code>鼠标滚轮</code>：翻阅当前pane内的内容。</p></li>
<li><p>在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</p></li>
<li><p>tmux中复制/粘贴文本的通用方式：</p></li>
<li><p>按下<code>Ctrl + a</code>后松开手指，然后按<code>[</code></p></li>
<li><p>用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</p></li>
<li><p>按下Ctrl + a后松开手指，然后按<code>]</code>，会将剪贴板中的内容粘贴到光标处</p></li>
</ol>
<h2 id="vim-教程">vim 教程</h2>
<h3 id="功能-1">功能</h3>
<ol type="1">
<li><p>命令行模式下的文本编辑器。</p></li>
<li><p>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</p></li>
<li><p>使用方式：<code>vim filename</code> 如果已有该文件，则打开它。 如果没有该文件，则打开个一个新的文件，并命名为filename</p></li>
</ol>
<h3 id="模式">模式</h3>
<ol type="1">
<li><p>一般命令模式</p>
<p>默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</p></li>
<li><p>编辑模式</p>
<p>在一般命令模式里按下<code>i</code>，会进入编辑模式。 按下<code>ESC</code>会退出编辑模式，返回到一般命令模式。</p></li>
<li><p>命令行模式</p>
<p>在一般命令模式里按下<code>: / ?</code>三个字母中的任意一个，会进入命令行模式。命令行在最下面。 可以查找、替换、保存、退出、配置编辑器等。</p></li>
</ol>
<h3 id="操作">操作</h3>
<ol type="1">
<li><p><code>i</code>：进入编辑模式</p></li>
<li><p><code>ESC</code>：进入一般命令模式</p></li>
<li><p><code>h</code> 或 <code>左箭头键</code>：光标向左移动一个字符</p></li>
<li><p><code>j</code> 或 <code>向下箭头</code>：光标向下移动一个字符</p></li>
<li><p><code>k</code> 或 <code>向上箭头</code>：光标向上移动一个字符</p></li>
<li><p><code>l</code> 或 <code>向右箭头</code>：光标向右移动一个字符</p></li>
<li><p><code>n&lt;Space&gt;</code>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</p></li>
<li><p><code>0</code> 或 <code>功能键[Home]</code>：光标移动到本行开头</p></li>
<li><p><code>$</code> 或 <code>功能键[End]</code>：光标移动到本行末尾</p></li>
<li><p><code>G</code>：光标移动到最后一行</p></li>
<li><p><code>:n</code> 或 <code>nG</code>：n为数字，光标移动到第n行</p></li>
<li><p><code>gg</code>：光标移动到第一行，相当于1G</p></li>
<li><p><code>n&lt;Enter&gt;</code>：n为数字，光标向下移动n行</p></li>
<li><p><code>/word</code>：向光标之下寻找第一个值为word的字符串。7</p></li>
<li><p><code>?word</code>：向光标之上寻找第一个值为word的字符串。</p></li>
<li><p><code>n</code>：重复前一个查找操作</p></li>
<li><p><code>N</code>：反向重复前一个查找操作</p></li>
<li><p><code>:n1,n2s/word1/word2/g</code>：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</p></li>
<li><p><code>:1,$s/word1/word2/g</code>：将全文的word1替换为word2</p></li>
<li><p><code>:1,$s/word1/word2/gc</code>：将全文的word1替换为word2，且在替换前要求用户确认。</p></li>
<li><p><code>v</code>：选中文本</p></li>
<li><p><code>d</code>：删除选中的文本.其实是剪切，可以粘贴回来的.</p></li>
<li><p><code>dd</code>：删除当前行</p></li>
<li><p><code>y</code>：复制选中的文本</p></li>
<li><p><code>yy</code>：复制当前行</p></li>
<li><p><code>p</code>：将复制的数据在光标的下一行/下一个位置粘贴</p></li>
<li><p><code>u</code>：撤销</p></li>
<li><p><code>Ctrl + r</code>：取消撤销</p></li>
<li><p><code>大于号 &gt;</code>：将选中的文本整体向右缩进一次</p></li>
<li><p><code>小于号 &lt;</code>：将选中的文本整体向左缩进一次</p></li>
<li><p><code>:w</code> 保存</p></li>
<li><p><code>:w!</code> 强制保存</p></li>
<li><p><code>:q</code> 退出</p></li>
<li><p><code>:q!</code> 强制退出</p></li>
<li><p><code>:wq</code> 保存并退出</p></li>
<li><p><code>:set paste</code> 设置成粘贴模式，取消代码自动缩进</p></li>
<li><p><code>:set nopaste</code> 取消粘贴模式，开启代码自动缩进</p></li>
<li><p><code>:set nu</code> 显示行号</p></li>
<li><p><code>:set nonu</code> 隐藏行号(为了复制文本时没有行号)</p></li>
<li><p><code>gg=G</code>：将全文代码格式化。</p>
<p><code>ggdG</code>：全删</p></li>
<li><p><code>:noh</code> 关闭查找关键词高亮</p></li>
<li><p><code>Ctrl + q</code>：当vim卡死时，可以取消当前正在执行的命令</p></li>
</ol>
<h3 id="异常处理">异常处理：</h3>
<p>每次用vim编辑文件时，会自动创建一个<code>.filename.swp</code>的临时文件。</p>
<p>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</p>
<ol type="1">
<li>找到正在打开该文件的程序，并退出</li>
<li>直接删掉该swp文件即可</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>小张同学的2020年度总结</title>
    <url>/2020/12/31/%E5%B0%8F%E5%BC%A0%E2%80%98s2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ed03a36c773264b24335a4bf6c650abbf9e4122c55e31683e7fcb6e3bf171fce">2c3eb40cbd03027ad9e37b5ead0a8959ee5c19daf66ddf9423535ad275743aac339b96d3c0da3e42bd38116cbba3b545fa36a0c479e99ced9e0daefe07036f6f41f6ca7ef0b27dd77c74a49acf9cf7a6258d5cd47d8248a8242e603da1280f2b2a3125d49a8b17a980391bb57bf238624f93c429978d59ae48c88f2bc66367fe663da4b1318d5d4108f46d5752f4b0b28013951204571262795c38a2f3526667ede2b39a53c595a57d3ff13061f4e21d661f9da3f998379bb864b9789647e9d7248cc5a75789f6d90a520f8ea151c83ad57dd9860cba196eb1f49d642274b133e7790311b0bbf86d09849469ac6d09f3b8b105dbd565d04d42a0c48703bff05ef32f14a261f0b57b67968c4585c6d027b2e2162ade9a5de65c5ac939b7eaa0bdb3e67a24ba2c44526d19d39277c8e84d43f298d6d10e7e3d970a9c339a0bcb632ecb7824f2e1cf55982bf2e20049fbed5c8c8c7818990a6be94ab2f9ac0e2fc24f29e65f22c35abd68aa7221a43463465fd0e61c6cc22ea2a7bd6366df74123b3776c1a02bd4f7c29fb975102074db2179cf4410e990292086c9d8585fe8f08806a777677d6da0a40245de3b5438d8d81c9788a057fdb805623aa46d1ad352d48a72e44221a58b7844e8dd890c13d56916b9981c99239afecf79348d37a1f1411bf5e367fd004968ebb54b5a82df1f4126c5f5b2d2629219ea799398f86ceba5383ee65f4eed80389922906e1435309d9ef8d149506736f85ab958062e681303d125bb1c9e97a613ac3edcb10c31adbefb51775bc575efcd185550977fa1b4f5e0feb5c73070c5c8b061d5347ad2c9f13b3a9a9419da129ddfd294f625bdebfd371463b78af18c01e3e8fc0680b8ea02e64a01b00936b8eb9fc2492d2f591384a63d87fd343ef9c0d16b2045819356e207a99e473e81536ae0f42523e8fde7a26c03935d418b31153316d2bdca36d6de50fa179bdb00ea3fc915d4164291eb205d3cfe023d2594cc492296af4419aa4cdcea8f113429fbe6441214031f9bb61863d6e882cfdd17912ca6412d260bacf103401b4883ab0d38f603379c6d6a40a181d04561d01bb910050d8ccd654449b89e25a574e51feac0a3020f4f6ee1b0d1f8cfd8f57002e7a0685c177eb1ec24cc7701beaa57c6387f6a97dbacb39d293ee60739f89c7c355773d2570e7c2b545fa9545e8781b99e0931c7f812fad26a29d4053bf01729564c196b5b58fda252283e669b85265a6b749011377f5d398cdcbea63e1fc0d197c3a9fad9b0b60319e0066554cd7db995809745cab568e35b8f6e6b0c6e76071c03ec056f597910c84ba740ca08399b26bbbbb09b81ae6cd8ab57b90b18e2531501708df07e296101577d548bdcc8d4fdaab8718802318acc5893c78c464c0a77dc0c54e4eaeba4004e50386f6756e38efdf108dfad00e8930c4d6d31a49d35a1563035890c048d948d9c0683225c3605c30a6cf2ac3a81d86169d1de9e78dcd685c925f20ced1af9631437d49f6b75903934c04c940ad07b336fb88a902e84bed353575114bd95838c98c321057df97a109b117f89213b50e5b710799739e8b7dcfa3f11d9bc46f3b4fbf3a2d102903bf28e5cab6d8545286024347972bc186600836c80d3626fec2755af9f9f92662ad94b27dbc91edfb1ea49642d27f26dc794203750a8faeba471d90a5e5dac7dfdde0131d38fb144d089bea1f94f9d8d0957da2746214b15a877f68ca4dcb349e21b8885ec6f143b15a488ea18bd848a7a6e1c27da5748bc265b3048d8a88f06f03a0c989e55d452b5157a3b58e0280c9f557e44401cfa54041636ac3c67ed34df492359449e512034140f528c17a84057f496148e58fa740fa487a8907d40355a9e78d59cf08c50b216fa9b2851647ec75f3d34644a83bb77392c89b2e9759aac18884217a9ecfc8666a227dd03a8559a81cd55a6f47eb20b95649ec65ddf07b0843ca59ab9dc44103b4b87f0eb1febdc86c898890bf711e887d37e78754d5ffa366e759ad654d6f82856ccb2b535d9ba7b98cc88cc658b1a1eba1e340d2bbfb413e810b55850b01b530a1dd4fbd937d560d17ee03df69352a15cbe1d7186aa5485f6144ddc6c6ab09b51cfb9ac07da8a5aadee92603ef9cac09fc84b54d74b758334255dc85203e17e36661870c34871c992016bc2a730fb42ad6d1d3e482c70cba1359258a74e238f998f1c59c9e768c8bc9e0fbdef8b98fa5a74918fc6db83e359fbdc31d6d026cdb202e718c9fd981cfef8d01fcde31c00ca5b75611d3713176085d003c1ec4fa8e83fb2a1436881beeb04462c30d2fa8a9f4e878ddc2a0f594d465728d381d1d80e599b476f1b9f5a91f11153f362dfcba0456c43c71fb4f70c48c91410dfb16b18d066ae4a06f223ed8cf4fa53654cead8293cde8275572b8838507d21732ca2f700fd1660236b0be53430a3da5156d4d19407f424f753a0b3f4cb19c2f087684749369c29e9daf20623ae525c5f74c0874f5cc6ff2d155416ab5a810beba4ad3dfecd036a27aa9c94d98ea54f8fc6a80d059459090c5bc9e712543566728a864b505c08bff6bac63eb3752fafff8fe32145dea5caff55bf7c83d562fe61c2a93d8fc9d3b32d0618ea8bd7dd86df76d79358c1977022b8505353f56b868c4484bab4628a6fb9c851b4b9c4788a6d2fc39f75ae8d019c5b01816679c95f17e7b6c3c39a190187ddc820443e1fb9bf6efb813c35d9e7d63b8a593317cf17121eb6e4fd01ea54bde115843d1346933c734c474e5d00c24d29ba32ff22973c84b4ce33c60ef1f629211d1208dbc36aab2ebb540538e0b416872a7dbdaa0d2b9b8c9831df92faf5471a77dc7cf44c0fa7cf770efd0c5b6e076d71aed1a8b8b0bd7be13c3994dce97c12a56bf5d1af4a2d3ae5d973b5223500bde618bba864044fec110adb7837268cd05b73a4f8a6599ee66f19a0ca64e032f085758e4c4e4802c3dd6d47df4a23a50e23ccfdc3bd7a716237534f1f3b1d3cc3a15e878345c5f130904f1e8248df5120f82e9255c0cdf991d3456cade65f2e6230f8292c3cdb8a01b4b8ffbf4de2f56a27af7805ff0e302e16c692f150854dc9f8867d8fe86565f3ec162600662467c9663751be66659b27666662a58181fceaca371e75fd006d39672c8aca13948d69c733c0fc58570aa73a6fca0ed5ba5866d5d520b10f084ca199574eec5070239c0e666c5fb8926c4ec9579405e9565728476122875d303c8fd23887789b60e0ed76d030a21362448896a56fbcd912f00fdf2da35047b9a50a8183661ced1f027e14fc2cf8c7dfe1c6fe65304e4f796bdc54e35e7d16a990c1ace4b1362e67b9d8fa097b3073f7ef35792f3f6d6b7b5af74356fe7dbe66a104f042ac0c7cea568ab25af426e8f61cd1aa7b6e8e2e952ea23a82f76f70659c0fb404f1b90a42cbd510cabc20e0768ed5b25f2af511d3bfaf07ab5903975a727edaa52db581151bb8364493ac697a7e3e18ce5d18101b66094f2e5768977eb834fad97afb9ebd1427041822dd84d1415f13eed5ab4646eff2720a4bff88dca2a3e6b5ad59eec0a771091171b770b6225b0746dc28ac7bb63a0909dc4d2a80b6c8b03593c5f416d4a9f1ba4a84a431c36e5f662ea314cd0bba9b956cc4a76079be932dbb63193b01778c9d6456b69c7927cd7791fd533f258f00f8333037704e560f0b86762dcd17cb3e19ad7cd8d9681d2e68c538b0e1188ba4e9a84286b1fff1bf5008daf19a578021df1142c86d92a262def50a0e01f2033ed06c27db187d574a7e591b8ad554b4881170437a0a192b36c708d93f5e2dae6e2e43a79e3f287ba313c60d641f3f218c42201576a107b7de664ed9ee5056820fec9c32a4e1aa5f4b19e9af9dc823e6a958e0da051a3e179ccfeb02f91225e306b1b4c06e910163db3dc9abe6f6bf83d1b5f125c3081a2ec2490d9cc8190a2f9198602a213d015e5d1a56fe015d3d0780a893068f5876bd7e77eb76c882234d9b86a2d0a0db22a24364f560892ee5dbdaefb586397ac3fa2fb6a56d59279f41e35eb9204c90d4d7b6c9ec3d7829662af25bc542adb1793051934838abbd3659b13d1cbe1d2d45a3ff3b449ce0e00ff3f9decbe9a6792f0f70d308368ae5d002e0abb3391c58d185d65db671e3a7e00556c2099777ed7262b154d9b898d8f53b6e24233d68304e10a95434b23f91019d452675fb23880a5d1af95486b599e0f5e9e026c2da2f070db577e0941f0a0655622d2655ebdf3709655c160bd8b77f8fcf778332618b77b13f8adf6c3e397186f217f25c8dc3bf3247d4a7d70ccaa4b6b9a5ae9c16e6d594c9d8105e3273764ffe7c27514e6f2004a44cf7a3b18a6ef6f48366e02f7bd2071867511c228d39e65b021d5b1cb3467e622650a96d76c36fad0fe61f485648a62e4dcffaaed20b89f20f28bdf0a2dcb66250e3abb7abcbc85cffe0d2ca6ea94d7760988c194fb5d7fd3837d49a58b5dfae136d10a7b230f0f8e836fd535856be5d31fbcc23483ee666240753cc01004eb775915d370b7e5e61f4e853d56a0b7189670b3954efb60d995302edc49c2812b6e23d4fdd003d7d860ed2167b5704cc0cd0e9cef0679f8223ceb6e1fe4698c38b54fa126553d64183c731c64db3e60d5162d6433cbb804e62597d76509d5c9685320a3fbf49b32695faa7db6228c9f9b0b4a35defd7290a624fe93a6fb9c741fee7b62a8fa45b74cab83641714aa2367e0d01fe47bf32beb898ec07231b3aa1b38688d5a04353531e0d7da723f96865e3bfa61f5ac0e62126d06b7ce6dccae33c18a5422b830281b314e79907248c44e07d688044611554e92332f63ddcb727f2351d2b1b2009a838580a916212340207a0ccd8fe54d534654121bc3eb5bf92594cb09e9f6e3ff9b04d46aed3323c815443821eb3ea4152ba3296fbfa304b27a4eedbd50166dc05cd931901576f825c67b806648d1b5fab0792cb932c9da18f63b813a8d6dba749ca42014f5855bc5ff3b046798d541727f14c7382724d3c913f3d7c50fd35500cd2bd9bd8587cab6588ab610f50e74e30fdbadff6d384d526543e2d3aa338d4afa13e40d8e2123c4084b4f8b7798d16720605fc9af5ada1406f77d8ac8b59ce3be48432bed2f274927df7958cd4e06b66faa1913db32d8900b40e56a548d6fc4e232ea1b74311a7710248377e733c48bd0d46887792f0a9b0e7d216cd2b21f4e638ac66ecdf677d3e91cbcc4d731943df03046db506f5837ca22c22b3aed78c1b0aab77221292b89056ef4d888dd85237a25e59524d7624dc388aa6cd5cf554852d2b36430a234ef1e6ab3da2031fe405b93f736d127e09935f20ebcb555f343bb5fae103a1fc4b9e3ec3ce0af6e5e85a9d86326dc0030da46eac988abc866112866ebe84199cdecad96d36c987224ef98b22a9d270a4013389be65ce55d484cef5c801138a960ebec44c4aef8ae5b8718d1abb891bf5ca2584b65d96091bca1488971dfee8f627e3212c8d103eb45302b9fc8f6c2419380a522b6bced03a5988ec24ec36763a75494918d92b4e653b58716e8180e47ecd2b678ef79003998119e29e52a50c2a74fb5100ea7a1a5fa67bb67ca846afa6b864b1b468820bd8ae4231acb5ddc015a3cd963d9666de06474f43ad90667be20c710c3b033ef72a4ffb481cd729411d923db2e38c3341d5ba0ed3a27f7193ed5956d66f1483c0144d6e1454a327924d6b629d49386439151bbb4c1306a00979079464cac3fe33e8b6e09137b9ec093c018623b04a308fea6878402ee070a3f7c26217eb6c7fc6406cf64187cf87083c7d9940a80e5b13cc7bb55407552c13fa79ef5a1445328e0e9bc18da94f2a575f9f04230b6967123161dbc6922a2bc31a82b75260aa7e056648396d2aeab1242f94f14eaf324ef45d7f8e03cf7a028e001bdff9a9da6554002d4ca100d87fbcc2532d28408632aa7b942deba55be67d88bcfef468779f1e335ed95325c115a8775b2db5b17781d40eff96dca6b005ef725d12c7aa40452009c41ecc064f08adce799f6c992b06d3f2122b7158c37078cd386f1ee858841492cd6e437ec73ec54f1aca0ff95222195d8467cd2bdcdd122892eb69dcd0e7cd2f806e466783e6e87ac2de142e0eeed00d986c5c377d118381f823b1fb9cfbc33cf9249a2dd3d02600bcaa9caa9681c68e6abfda69d853d2659695883a4900f57745843ba8b1e7bdfd5016648db753808e4f4a79bcc7e97e226ecc11a0cbaac86cd402635015535e7d669e848ab830c5c1d0a40f5bc674f50a4012d2f95335b2e565f825a4c8fbd0e4a5fd8516f27f631ff6a8e91d61e8f01c03951c823c02df0947d144b6c74e0e61079aef2b2edc156ff6cae495bb2c3b4d89ab8b5415987fdf1cca52a1f9109dad56c26e607a0cb982686839c0a87389b56aaa7da630aba41504a2434421aaf83e89998085abfb4e0a9e5bab7662df045b7ebcc64419bd2297d6109328215fcec8d3be12b15ee8d23ad4bbe5a2cf289b1b0a98abe4b50d878fb6487faed9573c8dedf75b5518ebc0d89f374c5022ce8a3e8614b2efcdf55ece387c541c5315bed2a101b64f68be28e36b5f4453bcf66f958977b5f4c71948a42a13a6d3686513c895a8e788a7a11715c7924772c8b95292559d71f60578ca573c56ce6d865cc93988be901b91ae3e7cd709afaac5dd8deba9668ef27d7644320c8035f03645d6d14e392b1a33e9ca1952904557c625355b96b4ef6038c278d24541c29dfc9220ed49a46b35bbeb2c1d9e93afd0cd3797350e0b96d0466f8a0d1da843c8f0609e74e13bca039770814cfe253defbedc6265ec280770e5bc490c3d97d8c81049974a3e062d66b74a028e6847736a16caeed3c915c7f32796eaf974abc59fb554a7a709e614a4203ecf88da8ee63ba35b12cc1d9207e71e4732d57d66dc7e8e08bd067ad7e9a1106e35e287acdc344d423a197f69293cb8660f3579d867e2f172fc6195283c0d0ac5c31ee47f241b8e5f177d5198eb340fd565fe845b294fe08861a780ca56b48dc24027dcd3111cffa564f6e1854f801593e14b3cbdb436c1ec2fa42631fac10b8039a2f0699b4befe61ad49e67b84b84068a9ea8e4590e2830ea462bc69c8069ceab80cddb22b56926a01035fb0f60a0487bcde2d90bd7d4e7a0566d4f3906472d6f970a88e6fca0f9d130f6d498012988e90fa38630c34e329eafdf49e0263fa8328a926dd40da1a711a219e6c037993f9c8739711a4cfcc111834a3df91540b3c559bbd9307b5f58c975a10fcfaee8d90ea412605545d3b34062c224bdc83f1c3231036a4d7e6fe3638a64231d223bac37c5857223a096150eff6156205b43886e4168d3371b5541db0160a9e5385bf931cddf910e08b8ee728abb0558801aebc51400b8913e052953535ce576074bff8156e522fcc43542369f542241ef1c61e6f7ee4e2a97b306d44a3f7dc8123b6f9b49e10c06f1a283d12d6ea6c2f397b14aaf5e4899c33a58fa2a89adc4977433fa4fb8835100e36bcc916079e007331880be8029c867449a28d77d1a5dfe96e59fd6e085f536aca50d431d844d3bc8852f5f322f9629fb56a31ef7dcacd05cad53c6a5874548fc3b24584c8da26ab035d23b82bfb288355e2ae68ff9746ad4f2e80f6b970763b6cda25298b9f623515da12a89138e0b797e8d572860b9214bf3159f2dca5ad867ce89c5e0c7d79bd4622660571095121fc2283a3097569e144bd2e53ed47daa9924c7b6f61c0fb5bb8e828127c4ca1d9e49559edfa89d10e10faaa5d2c9e4d74050c71a0b2ff54bd15309b6068cf0e157c7eaabc00abb80c4da8e861caf96b8af0e7ba3a42bdb558b421b9a5f81b0cff6113677a20ff69e760ad960f1b4ac0b9f6810d7f3a87af589a5bece5149e3e9be2af87d894d7718e9f5c991757fa92575b49c1d874d4d0f8534cdc0026bf3839f92d35b0fa3cc2f8b4578cb252391f3b876ca90bdc783d1c211d35de3596bf66371d6a17310e0a31f9392cdbd3041a19ef1383805b9ba029f03abdbe4deed5a9cae4bde78cbb925eed30c62d3cea346a97914f1e980e2982d3c5a45142b364fa7105cadfca4d59b0145bfc1265d22a5b6c64961536619c3e5c839d66d5b33a59438c20817cbbc034e67d5443a148c88fd024c88cf262a84fd7a5ab2e9c9775be50fa7ea5c00fd2cd7b388dff47be25fe03d83b922a9b06f7a0d0c89aba526f5131d8000472809d506d14f5abba119bbcd041be3ee98353668d322b154929952997654a5424ef57c572f250c10ff72b2c364f079753309b77f5f0e7fa8cba9a2a91cda72d09cc4ca40b19685a682efb522596cb3f9aee0893335916fb4e163f008cd5e89ac560c6cc43de23744de4b5fdf9a850bca0643a0627309f7fd61ad6a1406123365c519d44a0fb44bc1534f8b117545684a49c0bed64ddb9a96af5e1ea936fbde1998df50e0623623eab7981b05878fb10d5f3b3aafd7f93a7710033afa686c6c099fe0d6294b904b2104e9836a52b62530a25823f313e27c995b2712fa5628bd22e1b7a0184adb1d877e7ba0fdb8b3cb053471064c23178a67163553a4302e680404ce474c58e4f403a9a292edf909673cd904f79cf8b2030653d285d2aedfda55f15f32dc4a01ddcc7c0e5306c9624db24d4bee319a94c373a0cded66bfc032c6b4aa15036761fbf988ceb93e08bab8d69dcf9006afa3a27f36727f4eefc3e85d92a6c012ab492e25cc96658080f17b0082c4bfb479ee0796005f1c7c875f44829bd67aeed1d789a18829b98b70f7dd2d0a06cf09ffc4d012987ed0a6b62ef2e2e947cd54838c9979acf29efbaabe3b0857e015c7d501630ebeec2e7a2399fa6267471529105df52383cc24e7d7f8c779624fb72ae69a05bd17526c651c37ab825c11d29a9be306a2d699cc0746f62445db568cbf298b09c09f6e9723ba55f238ee348593338749600f32d076268714265897c21b43c7b97bd1d4f8218cbc516ba8b80d61f564cef4193183a94dc0958aa39b5db6103798b00f8b6ea6093dce4ba6b75b01dd4388ab7138022e3ed8780a3b9a24cb6d8b5e7a5e8c93ad25420616347589b77a983d3b2a9180ded5ef1e0c05a9ec287fe27ab10106df284312b7245b21fb429a708170f55299469ac2c592ca1fde23fb804b60ff340681b2fa50045a4a6d83aa4df8d765e18d9617806b87fda8c978586cca69c613daf6d1858eb170fb33e2e9d15d55622159663d11a57bd07e2f0b391c09a1ea3a04155cbcf0ab0f7ba7fe2dbc212c02efe02b025ddb8ce92212e03664cc35e8df514c3d76a0030875bc8ce0034c7a71ced3db5e5a8b1231bec224e41e95dcca83767ebe4a75884e8440dc48450e7edfec9f3eadebec6fb559fb0df23b5384bdc80ccef51e62c3ee21c4a62a14052ca1817d202049f3fe78cd2c190e47a5aa7d0f14a28544a7e5d626681ca55f1a41d643df1d75e46301b4352d009de7ef16835de9250c98a5491a755da1427ed35681ba72564c2e10a16d420d80f85d5b3ad38273c91164e2564344cc8dae262676adb17c135767049a82d991e1ff9de590ff865c672ed2872f29435f0eaff633ed07736f5f5266c69bc4e0b2700f90ecfccf4db3077e69e0a2219cf8f1cb2d9ad84865a5801756afb2144605d649832d533729de003ae35050a2cece01c5933de11503ebc25613f081205b967e58082abe6020050a10f1cb4c0e0179af9e5a9ebdca1f29711e69f20522b4311859c2906773a4bf89a875da65f3e833a6e8149ad8f4000d018f75efc733d31ea16b58297b06be70286589b4e905fb633acc05b57547af3c4cf593de0083dd42bc8de4ddc071eafcb6af523ea115ffe5ff90f0755093ee3a35fc3c2b4074ddc233b74fdda69995de6795aa1ca6d9e4e4b06970f81ccb5c92d154715eaae5634a1799b799a3f1a71b5f4f5248c52eec9e3045d08367b5fac05b26aec17a65323d3fab2749f3b4d71a40f2978a43935d52c31a4f52e6aecc85e3f979f918d427ae7d1cc9acf00b66f20ff2aa59001008812e11bf204ba042a2225bd2159870457b0c580c6ef6a85909c3460261f6bb9492dd7710d135e029da1aad2350352cbe04b221016543e3b323769c7b691296eb1b4ee98a206808969fa8930ea4a6af46ee36ab616e8e634eba0ecf2bee49ab2562a11cb1ea4475bcac4e217df71dfb4d954d02c16f4c2a0e9b9b994299f8bb97d096a2b2687905b9e21e0491adfede9c081156385ac90284ddaabf241861ccd1e30d84de97e3c523f614203d863bc763c4e78839744678d52e5123cee98dd7dfc568d0b21287fc3dd2266902f7378684a5196b18278069d60cd8ff3d16963c35c366fc020bd7043287a98edfc0bf9fa7eccd7bd89b4aef8baa59e91a50a86f99216ad174147883d5fb97fcdacd312512b9f83c36aceb871af4459b5647cf2ab500201cb717e9035be4b10c125f3d4967af0942baba11b3facc4310b448e79c755d8c8f62d5620d1a4bc1e1098bdffdc9d3e70bb9db8ddb5f95f0f0f4e4c3cc5454a6893cfebf91ac0e1c18683f5bbcac554a1c31e082c89725ba99d9f0313f8120fba322ba34601e9fa7870e4a8c2b6e977288587e62cb5535a3684daa1043abd72776b0a46149e6d89e59b4939a10aa96399287647622f39dd8e648ab8ffcb7f433972c7d73abf1444002a1917a1cd57c5a86e10001a49dc2399c8dc93fd4653fb9a79bd6b13bdd31849daaa4addc9087c41e824de5935a99421c29bb6a8c1260baeb341bc1b736a9a949d7032ecc021ab0cff0354779a320002b05cca9980a9b730e05b660a334c2682e764434b3c58f7c2621de5e1ccd65e0da0b196c1b10364a8ee18b6a35ffaa3e6dbe78af058201c8dca634f151d0f2b706036ad3f8629be0f3586bfaa7c830f2cac07b53d92f0e555ad136d5ff79dab83f4d975a31397f7a6bb1ed7c05692614dcf54d50faad339df004f714ced17f1ec9b0a74bebb7b94e7c185c1a36f22d9cf3c0c92bb8ea0703b788a2aabd82a5a3a96457323451f4b8d5a2cff8a67766b5be45707ab4b2a1dab015d4740ad24be6ef2130036e18e41c2b7917a6dbabcb89422282a3989081db7a4b73bde287aaa6df8985e9c02bc30e61af1303acbc31f5c1936ea76cde739b8f83aeafa833e816dca3bf5ad2982decaad10b6cb25229ee6d146d1a731f82afa1fe0e19364f6215df32fb20417ff3552763cdc5d3e45db8e0a7a2352b92ff50c97c14acc4d5191ead153d4bf068f60cfa96412dd6c33926d30e5c269505</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>小张日记</category>
      </categories>
      <tags>
        <tag>小张日记</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2022/03/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>第一次是在数据结构课学的快速排序。基本思路是：令 <code>i = l; j = r</code> ，选最左边的数为pivot。<code>j --</code> 从后向前找比它小的数，找到后与pivot交换。再 <code>i ++</code> 从前往后找比它大的数，找到后与pivot交换。再重复执行这一过程，直到 <code>i == j</code> 时，就找到了pivot的位置。再分别递归直至顺序。学了y总的方法感觉更聪明，是一种双指针快排的思路。</p>
<p><em><a id="more"></a></em></p>
<h1 id="快速排序算法双指针排序">快速排序算法(双指针排序)</h1>
<h2 id="思路">思路</h2>
<p>快排属于分治算法，一般分三步：</p>
<ol start="0" type="1">
<li><p><strong>注意递归要退出！记得写退出条件！<code>if(l &gt;= r)</code> 时退出</strong></p></li>
<li><p><strong>分成子问题</strong>：</p>
<ul>
<li><p><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</p></li>
<li><p><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</p></li>
</ul></li>
<li><p><strong>递归处理子问题</strong>：即递归处理左右两端 (又回到0)</p></li>
<li><p>子问题合并. 快排这一步不需要操作，但归并排序的核心在这一步骤</p></li>
</ol>
<div class="note note-info">
            <p>分治算法都有三步：</p><ol start="0" type="1"><li>确定递归退出条件</li><li>分成子问题</li><li>递归处理子问题</li><li>子问题合并</li></ol>
          </div>
<h2 id="快排模板">快排模板</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 0. 循环退出条件</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;  <br>	<span class="hljs-comment">// 1. 分成子问题。</span><br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意值和下角标的区别。</span><br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 2. 递归处理子问题</span><br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);  <span class="hljs-comment">// 边界不要写错</span><br>    <span class="hljs-comment">// 3. 子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="时间复杂度">时间复杂度</h2>
<p>平均时间复杂度 <span class="math inline">\(O(nlogn)\)</span>，最坏情况下 <span class="math inline">\(O(n^2)\)</span>，在数组已排好序的情况下出现，可以通过随机化或者取中点来避免最差情况。</p>
<blockquote>
<p>数学推导证明过程挺复杂的。算法导论上有，用主定理证明的，很详细。但是没法简化</p>
</blockquote>
<h2 id="注意">注意</h2>
<h3 id="待证问题">1. 待证问题</h3>
<p>while循环结束后，<code>q[l..j] &lt;= x</code>, <code>q[j+1..r] &gt;= x</code></p>
<p>注: <code>q[l..j] &lt;= x</code> 意为 <code>q[l],q[l+1]...q[j-1],q[j]</code> 的所有元素都 <code>&lt;= x</code></p>
<p><strong>证明:</strong> 循环不变式：<code>q[l..i] &lt;= x q[j..r] &gt;= x</code></p>
<ol type="1">
<li><p>初始化</p>
<p>循环开始之前 <code>i = l - 1, j = r + 1</code></p>
<p>则 <code>q[l..i]</code>, <code>q[j..r]</code> 为空，循环不变式显然成立</p></li>
<li><p>保持</p>
<p>假设某轮循环开始前循环不变式成立，即<code>q[l..i] &lt;= x, q[j..r] &gt;= x</code></p>
<p>执行循环体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>会使得 q[l..i<span class="hljs-number">-1</span>] &lt;= x, q[i] &gt;= x<br><br><span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>会使得 q[j+<span class="hljs-number">1.</span>.r] &gt;= x, q[j] &lt;= x<br><br><span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>会使得 q[l..i] &lt;= x, q[j..r] &gt;= x<br></code></pre></td></tr></table></figure>
<p>所以，i 和 j 更新之后，下一次循环开始之前，循环不变式依然成立</p>
<p>注意: 由于使用 do-while 循环,所以 <code>i</code> 和 <code>j</code> 一定会!!!自增!!!使得循环会继续下去,但是如果采用while循环(<code>i</code> 和 <code>j</code> 的初始化做出对应的变更), <code>i</code> 和 <code>j</code> 在特殊情况下不自增的话,循环就会卡死</p>
<p>例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(q[i] &lt; x) i++;<br><span class="hljs-keyword">while</span>(q[j] &gt; x) j--;<br></code></pre></td></tr></table></figure>
<p>当 <code>q[i]</code> 和 <code>q[j]</code> 都为 x 时, i 和 j 都不会更新, 导致 while 陷入死循环</p></li>
<li><p>终止</p>
<p>循环结束时，<code>i &gt;= j</code></p>
<p>正常情况下，按照循环不变式，我们应该会觉得结果已经显然了</p>
<p>因为<code>i &gt;= j, q[l..i] &lt;= x, q[j..r] &gt;= x</code></p>
<p>所以按照 <code>j</code> 来划分的话，<code>q[l..j] &lt;= x, q[j+1..r] &gt;= x</code>是显然的</p>
<p>可是，最后一轮循环有点特殊，因为<strong>最后一轮循环的 if 语句一定不会执行</strong></p>
<p>因为最后一轮循环一定满足 i &gt;= j, 不然不会跳出 while 循环的，所以 if 语句一定不执行</p>
<p><strong>正确分析</strong>：</p>
<p>由于最后一轮的 if 语句一定不执行</p>
<p>所以，只能保证 <code>i &gt;= j</code> 和 <code>q[l..i-1] &lt;= x, q[i] &gt;= x</code>和<code>q[j+1..r] &gt;= x, q[j] &lt;= x</code></p>
<p>由 <code>q[l..i-1] &lt;= x，i &gt;= j(i-1 &gt;= j-1)</code> 和 <code>q[j] &lt;= x</code> 可以得到 <code>q[l..j] &lt;= x</code></p>
<p>又因为 <code>q[j+1..r] &gt;= x</code></p>
<p>所以，<code>q[l..j] &lt;= x,q[j+1..r] &gt;= x</code>, <strong>问题得证</strong></p>
<p><strong>总结</strong>: 只有最后一轮循环结束时，循环不变式不成立，其余的循环都是成立的, 但最终要求的问题还是解决了</p>
<p><strong>注意</strong>: 循环结束时要记得检查是否存在数组越界/无限递归的情况</p>
<p>所以还需要证明 <code>j</code> 最终的取值范围是 <code>[l..r-1]</code> (即不存在<code>n</code>划分成<code>0</code>和<code>n</code>的无限递归情况), 分析过程在分析<code>2.5</code></p></li>
</ol>
<h3 id="边界情况分析">2. 边界情况分析</h3>
<p>快排属于<strong>分治算法</strong>，最怕的就是 <code>n分成0和n</code>，或 <code>n分成n和0</code>，这会造成<strong>无限划分</strong>(死循环)</p>
<ol type="1">
<li><p><strong>以 <code>j</code> 为划分时，<code>x</code> 不能选 <code>q[r]</code> (若以 <code>i</code> 为划分,则 <code>x</code> 不能选 <code>q[l]</code> )</strong></p>
<p>假设 <code>x = q[r]</code>：关键句子 <code>quick_sort(q, l, j), quick_sort(q, j + 1, r)</code></p>
<p>因为 <code>j</code> 的最小值是 <code>l</code>，所以 <code>[j + 1, r]</code> 不会造成无限划分，</p>
<p>但<code>[l..j]</code>(即 <code>quick_sort(q, l, j)</code> )却可能造成无限划分，因为 <code>j</code> 可能为 <code>r</code></p>
<p>举例来说，若 <code>x</code> 选为 <code>q[r]</code> ，数组中 <code>q[l..r-1] &lt; x</code> ，</p>
<p>那么这一轮循环结束时 <code>i = r, j = r</code>，这就造成了无限划分。</p>
<p>以 <code>0, 1</code> 这组数据为例，<code>x = q[r] = 1</code>，<code>do i ++ ; while(q[i] &lt; x)</code> ，</p>
<p>则 <code>i = 1 = r</code> ，<code>do j -- ; while(q[j] &gt; x)</code> ，则 <code>j = 1 = r</code> 。</p>
<p>则 <code>[0, 1]</code> 被划分成 <code>[0, 1]</code> 和 <code>[2, 1]</code> ，这就造成无限划分，即死循环。</p>
<blockquote>
<p>边界情况复杂，建议 <code>x = q[l + r &gt;&gt; 1]</code> 。</p>
</blockquote></li>
<li><p><strong><code>do i++; while(q[i] &lt; x)</code> 和 <code>do j--; while(q[j] &gt; x)</code> 不能用 <code>q[i] &lt;= x</code> 和 <code>q[j] &gt;= x</code>。</strong></p>
<p>举个栗子，比如 取的 <code>x</code> 刚好是数据里的最大值，执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>i+1</code>，交换的时候就是 <code>q[i + 1]</code> 和 <code>q[j]</code> 交换了，这显然不对。</p>
<p>或者举个极端情况，假设 <code>q[l..r]</code> 全相等，则执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>r+1</code>，然后继续执行 <code>q[i] &lt;= x</code> 判断条件，造成数组下标越界(但这貌似不会报错)。</p>
<p>并且如果之后的 <code>q[i] &lt;= x</code> (此时 <code>i &gt; r</code> ) 条件也不幸成立，就会造成一直循环下去(亲身实验)，造成内存超限 <code>(Memory Limit Exceeded)</code></p></li>
<li><p><code>if(i &lt; j) swap(q[i], q[j])</code> 能否使用 <code>i &lt;= j</code> ？</p>
<p><strong>可以使用 <code>if(i &lt;= j) swap(q[i], q[j]);</code></strong></p>
<p>因为 i = j 时，交换一下 <code>q[i],q[j]</code> 也就是交换自己，无影响，马上就会跳出循环了</p></li>
<li><p>最后一句能否改用 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 作为划分(用 <code>i</code> 做划分时也是同样的道理,)</p>
<p><strong>不能</strong>。根据之前的证明，最后一轮循环可以得到这些结论</p>
<ul>
<li><code>q[l..i-1] &lt;= x, q[i...r] &gt;= x</code></li>
<li><code>q[l...j] &lt;= x, q[j+1..r] &gt;= x</code></li>
<li><code>j &lt;= i</code></li>
</ul>
<p>所以，<code>q[l..j-1] &lt;= x</code> 是显然成立的，</p>
<p>但 <code>quick_sort(q, j, r)</code> 中的 <code>q[j]</code> 却是 <code>q[j] &lt;= x</code> ，这不符合快排的要求</p>
<p>另外一点，注意 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 可能会造成无线划分</p>
<p>当 <code>x</code> 选为 <code>q[l]</code> 时会造成无限划分，报错为(MLE),</p>
<p>如果手动改为 <code>x = q[r]</code>，可以避免无限划分。</p>
<p>但是上面所说的 <code>q[j] &lt;= x</code> 的问题依然不能解决，这会造成 <code>WA (Wrong Answer)</code></p></li>
<li><p><strong><code>j</code> 的取值范围为 <code>[l..r-1]</code></strong> (这块还是不太懂....)</p>
<p>证明：<strong>反证法</strong></p>
<p>假设 <code>j</code> 最终的值为 <code>r</code> ,说明只有一轮循环(两轮的话 <code>j</code> 至少会自减两次)</p>
<p>说明 <code>q[r] &lt;= x</code> (因为要跳出 <code>do-while</code> 循环)</p>
<p>说明 <code>i &gt;= r</code>( <code>while</code> 循环的结束条件), <code>i</code> 为 <code>r</code> 或 <code>r + 1</code>(必不可能成立)</p>
<p>说明 <code>i</code> 自增到了 <code>r</code> , 说明 <code>q[r] &gt;= x</code> 和 <code>q[l..r-1] &lt; x</code>，</p>
<p>得出 <code>q[r] = x</code> 和 <code>q[l..r-1] &lt; x</code> 的结论，但这与 <code>x = q[l + r &gt;&gt; 1]</code> 矛盾</p>
<p><strong>反证法</strong>得出 <code>j &lt; r</code></p>
<p>假设 <code>j</code> 可能小于 <code>l</code> 说明 <code>q[l..r] &gt; x</code> ,矛盾</p>
<p><strong>反证法</strong>得出 <code>j &gt;= l</code></p>
<p>所以 <code>j</code> 的取值范围为 <code>[l..r-1]</code> ，不会造成无限划分和数组越界</p></li>
</ol>
<p>顺带一提用 <code>i</code> 做划分时的模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];  <span class="hljs-comment">// 注意是向上取整,因为向下取整可能使得x取到q[l]</span><br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    quick_sort(q, l, i - <span class="hljs-number">1</span>), quick_sort(q, i, r);  <span class="hljs-comment">// 不用q[l..i],q[i+1..r]划分的道理和分析4中j的情况一样</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>还有从大到小排序的模板(仅仅改两个地方的判断符号)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &gt; x);  <span class="hljs-comment">// 这里和下面</span><br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &lt; x);  <span class="hljs-comment">// 这行的判断条件改一下</span><br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);<br>&#125;    <br></code></pre></td></tr></table></figure>
<h3 id="元素值-和-q角标-的区别">3. <code>元素值</code> 和 <code>q[角标]</code> 的区别</h3>
<p>我之前一直搞错了角标的问题。正确写法是 <code>x = q[l + r &gt;&gt; 1]</code> ，我总是写成 <code>x = l + r &gt;&gt; 1; ...q[i] &lt; q[x]</code>。好蠢，一直没弄清楚 <strong><code>元素值</code> 和 <code>q[角标]</code> 的区别</strong>。<code>元素值</code> 就是一个数字，而 <code>q[角标]</code> 表示角标所在位置的值，相当于一个坑。快排在交换元素时，可能这个坑里的元素会有变化，而快排想要的仅仅是一个作为比较的值，模板里选了中间位置的元素值，而不是这个位置的数(也就是位置的角标)。之前一直没想通这个问题，直到模拟了一个错误样例才想明白。</p>
<blockquote>
<p>错误样例为：49，59，88，37，98，97，68，54，31，3</p>
</blockquote>
<p>以后遇到错误也要<u>多模拟样例</u>，自己想明白才是真的明白，不然也不会背了四五遍模板也记不清楚。</p>
<hr />
<h2 id="例题">例题</h2>
<h3 id="acwing-785.-快速排序"><a href="https://www.acwing.com/problem/content/787/">1. AcWing 785. 快速排序</a></h3>
<p>模板题。</p>
<p><strong>code</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;    <br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ;i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    quick_sort(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>TextCNN 的 PyTorch 实现</title>
    <url>/2022/03/15/TextCNN%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="textcnn-的-pytorch-实现">TextCNN 的 PyTorch 实现</h1>
<p>本文主要介绍一篇将 CNN 应用到 NLP 领域的一篇论文 <a href="https://www.aclweb.org/anthology/D14-1181.pdf">Convolutional Neural Networks for Sentence Classification</a>，然后给出 PyTorch 实现。</p>
<p>论文比较短，总体流程不太复杂，最主要的是下面这张图，只要理解了这张图，就知道如何写代码了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131223.png" /></p>
<p>下图的 feature map 是将一句话中的各个词通过 Word Embedding 得到的，feature map 的宽为 embedding 的维度，长为一句话的单词数量。例如下图中，很明显就是用一个 6 维的向量去编码每个词，并且一句话中有 9 个词。</p>
<p>之所以有两张 feature map，可以理解为 batchsize 为 2。</p>
<p>其中，红色的框代表的就是卷积核。而且很明显可以看出，这是一个长宽不等的卷积核。有意思的是，卷积核的宽可以认为是 n-gram，比方说下图卷积核宽为 2，所以同时考虑了 &quot;wait&quot; 和 &quot;for&quot; 两个单词的词向量，因此可以认为该卷积是一个类似于 bigram 的模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131248.png" style="zoom: 50%;" /></p>
<p>后面的部分就是传统 CNN 的步骤，激活、池化、Flatten</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131333.png" style="zoom: 50%;" /></p>
<h3 id="代码实现pytorch-版">代码实现（PyTorch 版）</h3>
<p>源码来自于 <a href="https://github.com/graykode/nlp-tutorial">nlp-tutorial</a>，<a href="https://wmathor.com/index.php/archives/1445/">王铃鑫同学</a>在其基础上进行了修改。</p>
<p>导入库.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br>dtype = torch.FloatTensor<br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>定义一些数据，以及设置一些常规参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 3 words sentences (=sequence_length is 3)</span><br>sentences = [<span class="hljs-string">&quot;i love you&quot;</span>, <span class="hljs-string">&quot;he loves me&quot;</span>, <span class="hljs-string">&quot;she likes baseball&quot;</span>, <span class="hljs-string">&quot;i hate you&quot;</span>, <span class="hljs-string">&quot;sorry for that&quot;</span>, <span class="hljs-string">&quot;this is awful&quot;</span>]<br>labels = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 1 is good, 0 is not good.</span><br><br><span class="hljs-comment"># TextCNN</span><br>embedding_size = <span class="hljs-number">2</span><br>sequence_length = <span class="hljs-built_in">len</span>(sentences[<span class="hljs-number">0</span>])  <span class="hljs-comment"># every sentences contains sequence_length(=3) words</span><br>num_classes =<span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels))  <span class="hljs-comment"># 几分类，这里是二分类</span><br>batch_size = <span class="hljs-number">3</span><br><br>word_list = <span class="hljs-string">&quot; &quot;</span>.join(sentences).split()<br>vocab = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(word_list))<br>vocab_size = <span class="hljs-built_in">len</span>(vocab)<br>word2idx = &#123;w:i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(vocab)&#125;<br></code></pre></td></tr></table></figure>
<p>数据预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_data</span>(<span class="hljs-params">sentences, labels</span>):</span><br>    inputs = []<br>    <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> sentences:<br>        inputs.append([word2idx[word] <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> sen.split()])  <span class="hljs-comment"># 把sentences中的每个句子拿出来，分成单词，找到对应idx加入 inputs</span><br>        <br>    targets = []<br>    <span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> labels:<br>        targets.append(out)   <span class="hljs-comment"># To using Torch Softmax Loss function</span><br>        <br>    <span class="hljs-keyword">return</span> inputs, targets<br><br>input_batch, targets_batch = make_data(sentences, labels)<br>input_batch, targets_batch = torch.LongTensor(input_batch), torch.LongTensor(targets_batch)<br><br>dataset = Data.TensorDataset(input_batch, targets_batch)<br>loader = Data.DataLoader(dataset, batch_size, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<div class="note note-primary">
            <ul><li><code>TensorDataset</code> 可以用来对 tensor 进行打包，把数据放在数据库中, 就好像 python 中的 zip 功能。该类通过每一个 tensor 的第一个维度进行索引。</li><li><code>DataLoader</code> 从数据库中每次抽出 batch size 个样本</li></ul>
          </div>
<p>构建 TextCNN 模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextCNN</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TextCNN, self).__init__()<br>        self.W = nn.Embedding(vocab_size, embedding_size)<br>        output_channel = <span class="hljs-number">3</span><br>        self.conv = nn.Sequential(<br>            <span class="hljs-comment"># conv : [input_channel(=1), output_channel, (filter_height, filter_width), stride=1]</span><br>            nn.Conv2d(<span class="hljs-number">1</span>, output_channel, (<span class="hljs-number">2</span>, embedding_size)),  <span class="hljs-comment"># [batch_size, output_channel * 2 * 1]</span><br>            nn.ReLU(),<br>            <span class="hljs-comment"># pool : ((filter_height, filter_width))</span><br>            nn.MaxPool2d((<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)),<br>        )<br>        <span class="hljs-comment"># fc</span><br>        self.fc = nn.Linear(output_channel, num_classes)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        X: [batch_size, sequence_length]</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        batch_size = X.shape[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 因为测试的时候不知道有几个句子，所以在这里动态的获取一下</span><br>        embedding_X = self.W(X)  <span class="hljs-comment"># [batch_size, sequence_length, embedding_size]</span><br>        <br>        embedding_X = embedding_X.unsqueeze(<span class="hljs-number">1</span>)  <span class="hljs-comment"># add channel(=1) [batch, channel(=1), sequence_length, embedding_size]</span><br>        conved = self.conv(embedding_X)  <span class="hljs-comment"># 卷积之后：[batch_size, output_channel，1，1]</span><br>        <br>        flatten = conved.view(batch_size, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># [batch_size, output_channel * 1 * 1]</span><br>        output = self.fc(flatten)<br>        <br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure>
<p>详细介绍一下数据在网络中流动的过程中维度的变化:</p>
<p>输入数据是个矩阵，矩阵维度为 <code>[batch_size, sequence_length]</code>，输入矩阵的数字代表的是某个词在整个词库中的索引（下标）</p>
<p>首先通过 Embedding 层，也就是查表，将每个索引转为一个向量，比方说 <code>12</code> 可能会变成 <code>[0.3,0.6,0.12,...]</code>，因此整个数据无形中就增加了一个维度，变成了 <code>[batch_size, sequence_length, embedding_size]</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144253.png" style="zoom: 67%;" /></p>
<p>之后使用 <code>unsqueeze(1)</code> 函数使数据增加一个维度，变成 <code>[batch_size, 1, sequence_length, embedding_size]</code>。现在的数据才能做卷积，因为在传统 CNN 中，输入数据就应该是 <code>[batch_size, in_channel, height, width]</code> 这种维度</p>
<p><code>[batch_size, 1, 3, 2]</code> 的输入数据通过 <code>nn.Conv2d(1, 3, (2, 2))</code> 的卷积之后，得到的就是 <code>[batch_size, 3, 2, 1]</code> 的数据，由于经过 ReLU 激活函数是不改变维度的，所以就没画出来。最后经过一个 <code>nn.MaxPool2d((2, 1))</code> 池化，得到的数据维度就是 <code>[batch_size, 3, 1, 1]</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331144327.png" style="zoom:80%;" /></p>
<p>训练</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">model = TextCNN().to(device)<br>criterion = nn.CrossEntropyLoss().to(device)<br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    <span class="hljs-keyword">for</span> batch_x, batch_y <span class="hljs-keyword">in</span> loader:<br>        batch_x, batch_y = batch_x.to(device), batch_y.to(device)<br>        pred = model(batch_x)<br>        loss = criterion(pred, batch_y)<br>        <br>        <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>) % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">&#x27;Epoch:&#x27;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch + <span class="hljs-number">1</span>), <span class="hljs-string">&#x27;loss=&#x27;</span>, <span class="hljs-string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(loss))<br>            <br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Test</span><br>test_text = <span class="hljs-string">&#x27;i hate me&#x27;</span><br>tests = [[word2idx[n] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> test_text.split()]]<br>test_batch = torch.LongTensor(tests).to(device)<br><br><span class="hljs-comment"># Predict</span><br>model = model.<span class="hljs-built_in">eval</span>()<br>predict = model(test_batch).data.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> predict[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>    print(test_text,<span class="hljs-string">&quot;is Bad Mean...&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(test_text,<span class="hljs-string">&quot;is Good Mean!!&quot;</span>)<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>NNLM 的 PyTorch 实现</title>
    <url>/2022/03/10/NNLM%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="nnlm-的-pytorch-实现">NNLM 的 PyTorch 实现</h1>
<h2 id="a-neural-probabilistic-language-model">A Neural Probabilistic Language Model</h2>
<p>本文算是训练语言模型的经典之作，Bengio 将神经网络引入语言模型的训练中，并得到了词向量这个副产物。词向量对后面深度学习在自然语言处理方面有很大的贡献，也是获取词的语义特征的有效方法</p>
<p>其主要架构为三层神经网络，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330140630.png" style="zoom:50%;" /></p>
<p>现在的任务是输入 <span class="math inline">\(w_{t−n+1},...,w_{t−1}\)</span> 这前 n-1 个单词，然后预测出下一个单词 <span class="math inline">\(w_t\)</span></p>
<p>数学符号说明：</p>
<ul>
<li><span class="math inline">\(C(i)\)</span>：单词 <span class="math inline">\(w\)</span> 对应的词向量，其中 <span class="math inline">\(i\)</span> 为词 <span class="math inline">\(w\)</span> 在整个词汇表中的索引</li>
<li><span class="math inline">\(C\)</span>：词向量，大小为 <span class="math inline">\(|V|×m\)</span> 的矩阵</li>
<li><span class="math inline">\(|V|\)</span>：词汇表的大小，即预料库中去重后的单词个数</li>
<li><span class="math inline">\(m\)</span>：词向量的维度，一般大于 50</li>
<li><span class="math inline">\(H\)</span>：隐藏层的 weight</li>
<li><span class="math inline">\(d\)</span>：隐藏层的 bias</li>
<li><span class="math inline">\(U\)</span>：输出层的 weight</li>
<li><span class="math inline">\(b\)</span>：输出层的 bias</li>
<li><span class="math inline">\(W\)</span>：输入层到输出层的 weight</li>
<li><span class="math inline">\(h\)</span>：隐藏层神经元个数</li>
</ul>
<p>计算流程：</p>
<ol type="1">
<li>首先将输入的 <span class="math inline">\(n−1\)</span> 个单词索引转为词向量，然后将这 <span class="math inline">\(n−1\)</span> 个向量进行 concat，形成一个 <span class="math inline">\((n−1)×w\)</span> 的矩阵，用 <span class="math inline">\(X\)</span> 表示</li>
<li>将 <span class="math inline">\(X\)</span> 送入隐藏层进行计算，<span class="math inline">\(hidden_{out}=tanh⁡(d+X∗H)\)</span></li>
<li>输出层共有 <span class="math inline">\(|V|\)</span> 个节点，每个节点 <span class="math inline">\(y_i\)</span> 表示预测下一个单词 <span class="math inline">\(i\)</span> 的概率，<span class="math inline">\(y\)</span> 的计算公式为 <span class="math inline">\(y=b+X∗W+hidden_{out}∗U\)</span></li>
</ol>
<h2 id="代码实现pytorch">代码实现（PyTorch）</h2>
<p>导入包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><br>dtype = torch.FloatTensor<br></code></pre></td></tr></table></figure>
<p>数据预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sentences = [ <span class="hljs-string">&quot;i like dog&quot;</span>, <span class="hljs-string">&quot;i love coffee&quot;</span>, <span class="hljs-string">&quot;i hate milk&quot;</span>]<br><br><span class="hljs-comment"># 将空格加入到单词之间，然后按空格隔开组成一个list</span><br>word_list = <span class="hljs-string">&quot; &quot;</span>.join(sentences).split()  <span class="hljs-comment"># [&#x27;i&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;, &#x27;i&#x27;, &#x27;love&#x27;, &#x27;coffee&#x27;, &#x27;i&#x27;, &#x27;hate&#x27;, &#x27;milk&#x27;]</span><br><br><span class="hljs-comment"># 构建词汇表，词汇表需要去重，再转换成list</span><br>word_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(word_list))  <span class="hljs-comment"># [&#x27;i&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;, &#x27;love&#x27;, &#x27;coffee&#x27;, &#x27;hate&#x27;, &#x27;milk&#x27;]</span><br><br><br>word_dict = &#123;w: i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word_list)&#125;  <span class="hljs-comment"># &#123;&#x27;i&#x27;:0, &#x27;like&#x27;:1, &#x27;dog&#x27;:2, &#x27;love&#x27;:3, &#x27;coffee&#x27;:4, &#x27;hate&#x27;:5, &#x27;milk&#x27;:6&#125;</span><br>number_dict = &#123;i: w <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word_list)&#125;  <span class="hljs-comment"># &#123;0:&#x27;i&#x27;, 1:&#x27;like&#x27;, 2:&#x27;dog&#x27;, 3:&#x27;love&#x27;, 4:&#x27;coffee&#x27;, 5:&#x27;hate&#x27;, 6:&#x27;milk&#x27;&#125;</span><br>n_class = <span class="hljs-built_in">len</span>(word_dict)  <span class="hljs-comment"># number of Vocabulary, just like |V|, in this task n_class=7（维度，有多少词就是多少行）</span><br><br><br><span class="hljs-comment"># NNLM(Neural Network Language Model) Parameter</span><br><span class="hljs-comment"># n_step = 2  # 输入数据的长度，这里就是两个单词</span><br>n_step = <span class="hljs-built_in">len</span>(sentences[<span class="hljs-number">0</span>].split())-<span class="hljs-number">1</span>  <span class="hljs-comment"># n-1 in paper, look back n_step words and predict next word. In this task n_step=2</span><br>n_hidden = <span class="hljs-number">2</span>  <span class="hljs-comment"># h in paper</span><br>m = <span class="hljs-number">2</span>  <span class="hljs-comment"># m in paper, word embedding dim</span><br></code></pre></td></tr></table></figure>
<p>由于 PyTorch 中输入数据是以 mini-batch 小批量进行的，下面的函数首先将原始数据（词）全部转为索引，然后通过 <code>TensorDataset()</code> 和 <code>DataLoader()</code> 编写一个实用的 mini-batch 迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_batch</span>(<span class="hljs-params">sentences</span>):</span><br>    input_batch = []<br>    target_batch = []<br>    <br>    <span class="hljs-comment"># 遍历每一条句子</span><br>    <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> sentences:<br>        word = sen.split()  <span class="hljs-comment"># [&#x27;i&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;]</span><br>        <span class="hljs-comment"># 只要前两个词作为输入，最后一个词是预测的</span><br>        <span class="hljs-built_in">input</span> = [word_dict[n] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> word[:-<span class="hljs-number">1</span>]]  <span class="hljs-comment"># [0, 1], [0, 3], [0, 5]</span><br>        target = word_dict[word[-<span class="hljs-number">1</span>]]  <span class="hljs-comment"># 2, 4, 6</span><br><br>        input_batch.append(<span class="hljs-built_in">input</span>)  <span class="hljs-comment"># [[0, 1], [0, 3], [0, 5]]</span><br>        target_batch.append(target)  <span class="hljs-comment"># [2, 4, 6]</span><br><br>    <span class="hljs-keyword">return</span> input_batch, target_batch<br><br><br>input_batch, target_batch = make_batch(sentences)<br><span class="hljs-comment"># 需要将 list 转换为 tensor</span><br>input_batch = torch.LongTensor(input_batch)<br>target_batch = torch.LongTensor(target_batch)<br><br>dataset = Data.TensorDataset(input_batch, target_batch)<br><br>loader = Data.DataLoader(dataset=dataset, batch_size=<span class="hljs-number">16</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>定义网络结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义网络结构</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NNLM</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(NNLM, self).__init__()<br>        self.C = nn.Embedding(n_class, m)  <span class="hljs-comment"># 有多少行，</span><br>        self.H = nn.Parameter(torch.randn(n_step * m, n_hidden).<span class="hljs-built_in">type</span>(dtype))<br>        self.W = nn.Parameter(torch.randn(n_step * m, n_class).<span class="hljs-built_in">type</span>(dtype))<br>        self.d = nn.Parameter(torch.randn(n_hidden).<span class="hljs-built_in">type</span>(dtype))<br>        self.U = nn.Parameter(torch.randn(n_hidden, n_class).<span class="hljs-built_in">type</span>(dtype))<br>        self.b = nn.Parameter(torch.randn(n_class).<span class="hljs-built_in">type</span>(dtype))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        X: [batch_size, n_step]  batch_size：选几个数据，n_step 列</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        X = self.C(X) <span class="hljs-comment"># [batch_size, n_step] =&gt; [batch_size, n_step, m]</span><br>        X = X.view(-<span class="hljs-number">1</span>, n_step * m)  <span class="hljs-comment"># [batch_size, n_step * m] 维度变为2维</span><br>        hidden_out = torch.tanh(self.d + torch.mm(X, self.H))  <span class="hljs-comment"># [batch_size, n_hidden]</span><br>        output = self.b + torch.mm(X, self.W) + torch.mm(hidden_out, self.U)  <span class="hljs-comment"># [batch_size, n_class]</span><br>        <span class="hljs-keyword">return</span> output<br><br>    <br>model = NNLM()<br>criterion = nn.CrossEntropyLoss()<br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br></code></pre></td></tr></table></figure>
<p><code>nn.Parameter()</code> 的作用是将该参数添加进模型中，使其能够通过 <code>model.parameters()</code> 找到、管理、并且更新。更具体的来说就是：</p>
<ol type="1">
<li><code>nn.Parameter()</code> 与 <code>nn.Module</code> 一起使用时会有一些特殊的属性，其会被自动加到 Module 的 <code>parameters()</code> 迭代器中</li>
<li>使用很简单：<code>torch.nn.Parameter(data, requires_grad=True)</code>，其中 data 为 tensor</li>
</ol>
<p>简单解释一下执行 <code>X=self.C(X)</code> 这一步之后 <code>X</code> 发生了什么变化，假设初始 <code>X=[[0, 1], [0, 3]]</code></p>
<p>通过 <code>Embedding()</code> 之后，会将每一个词的索引，替换为对应的词向量，例如 <code>love</code> 这个词的索引是 <code>3</code>，通过查询 Word Embedding 表得到行索引为 3 的向量为 <code>[0.2, 0.1]</code>，于是就会将原来 <code>X</code> 中 <code>3</code> 的值替换为该向量，所有值都替换完之后，<code>X=[[[0.3, 0.8], [0.2, 0.4]], [[0.3, 0.8], [0.2, 0.1]]]</code></p>
<p>训练</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Training</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    <span class="hljs-keyword">for</span> batch_x, batch_y <span class="hljs-keyword">in</span> loader:<br>        output = model(batch_x)  <span class="hljs-comment"># 预测值 pred</span><br>        optimizer.zero_grad()  <span class="hljs-comment"># 梯度清零</span><br><br>        <span class="hljs-comment"># output : [batch_size, n_class], batch_y : [batch_size] (LongTensor, not one-hot)</span><br>        <span class="hljs-comment"># 中间打印一下loss</span><br>        loss = criterion(output, batch_y)<br>        <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>)%<span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">&#x27;Epoch:&#x27;</span>, <span class="hljs-string">&#x27;%04d&#x27;</span> % (epoch + <span class="hljs-number">1</span>), <span class="hljs-string">&#x27;cost =&#x27;</span>, <span class="hljs-string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(loss))<br><br>        loss.backward()  <span class="hljs-comment"># 误差反向传播</span><br>        optimizer.step()  <span class="hljs-comment"># 更新参数</span><br><br><br><span class="hljs-comment"># Predict</span><br>predict = model(input_batch).data.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)[<span class="hljs-number">1</span>]<br><br><br><span class="hljs-comment"># Test</span><br>print([sen.split()[:n_step] <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> sentences], <span class="hljs-string">&#x27;-&gt;&#x27;</span>, [number_dict[n.item()] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> predict.squeeze()])        <br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Word2Vec 的 PyTorch 实现（乞丐版）</title>
    <url>/2022/03/10/Word2Vec%20%E7%9A%84%20PyTorch%20%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B9%9E%E4%B8%90%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="word2vec-的-pytorch-实现乞丐版">Word2Vec 的 PyTorch 实现（乞丐版）</h1>
<p>自然语言处理问题中，一般以词作为基本单元，例如我们想要分析 &quot;我去过华盛顿州&quot; 这句话的情感，一般的做法是先将这句话进行分词，变成<code>我</code>，<code>去过</code>，<code>华盛顿州</code>，由于神经网络无法处理词，所以我们需要将这些词通过某些办法映射成词向量。词向量是用来表示词的向量，也可被认为是词的特征向量。<strong>把词映射为实数域向量的技术也叫词嵌入（word embedding）</strong></p>
<p>源码来自于 <a href="https://github.com/graykode/nlp-tutorial">nlp-tutorial</a>，<a href="https://wmathor.com/index.php/archives/1443/">王铃鑫大佬</a>在其基础上进行了修改：</p>
<p>导入包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optimizer<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>dtype = torch.FloatTensor<br></code></pre></td></tr></table></figure>
<p>文本预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sentences = [<span class="hljs-string">&quot;jack like dog&quot;</span>, <span class="hljs-string">&quot;jack like cat&quot;</span>, <span class="hljs-string">&quot;jack like animal&quot;</span>,<br>  <span class="hljs-string">&quot;dog cat animal&quot;</span>, <span class="hljs-string">&quot;banana apple cat dog like&quot;</span>, <span class="hljs-string">&quot;dog fish milk like&quot;</span>,<br>  <span class="hljs-string">&quot;dog cat animal like&quot;</span>, <span class="hljs-string">&quot;jack like apple&quot;</span>, <span class="hljs-string">&quot;apple like&quot;</span>, <span class="hljs-string">&quot;jack like banana&quot;</span>,<br>  <span class="hljs-string">&quot;apple banana jack movie book music like&quot;</span>, <span class="hljs-string">&quot;cat dog hate&quot;</span>, <span class="hljs-string">&quot;cat dog like&quot;</span>]<br><br>sentence_list = <span class="hljs-string">&quot; &quot;</span>.join(sentences).split()  <br><span class="hljs-comment"># [&#x27;jack&#x27;, &#x27;like&#x27;, &#x27;dog&#x27;, &#x27;jack&#x27;, &#x27;like&#x27;, &#x27;cat&#x27;, &#x27;animal&#x27;,...]</span><br><span class="hljs-comment">#     0      1       2       0      1       3       4</span><br><br><span class="hljs-comment"># 去个重，构建词汇的语料库</span><br>vocab = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(sentence_list))<br><span class="hljs-comment"># vocab = sorted(set(sentence_list), key=sentence_list.index)  # 我自己写的，为了保持原句子的顺序</span><br><br>word2idx = &#123;w:i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(vocab)&#125;<br><span class="hljs-comment"># &#123;&#x27;hate&#x27;: 0, &#x27;cat&#x27;: 1,...</span><br>vocab_size = <span class="hljs-built_in">len</span>(vocab)<br></code></pre></td></tr></table></figure>
<p>模型相关参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Word2Vec Parameters</span><br>C = <span class="hljs-number">2</span> <span class="hljs-comment"># window size</span><br>batch_size = <span class="hljs-number">8</span><br>embedding_size = <span class="hljs-number">2</span>  <span class="hljs-comment"># 2 dim vector represent one word</span><br></code></pre></td></tr></table></figure>
<p>数据预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">skip_grams = []<br><span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(C, <span class="hljs-built_in">len</span>(sentence_list) - C):<br>    center = word2idx[sentence_list[idx]]  <span class="hljs-comment"># 中心词的位置</span><br>    context_idx = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(idx - C, idx)) + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(idx + <span class="hljs-number">1</span>, idx + C + <span class="hljs-number">1</span>))  <span class="hljs-comment"># 左边的背景词 + 右边的背景词</span><br>    context = [word2idx[sentence_list[i]] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> context_idx]  <span class="hljs-comment"># 这个地方是 背景词索引 找出 背景词</span><br><span class="hljs-comment">#     print(context)</span><br>    <br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> context:<br>        skip_grams.append([center, w])<br></code></pre></td></tr></table></figure>
<p>假设所有文本分词，转为索引之后的 list 如下图所示. 根据论文所述，设定 window size=2，即每个中心词左右各取 2 个词作为背景词，那么对于上面的 list，窗口每次滑动，选定的中心词和背景词如下图.</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328130934.png" /></p>
<p>那么 skip_grams 变量里存的就是中心词和背景词一一配对后的 list，例如中心词 <code>2</code>，有背景词 <code>0,1,0,1，</code>一一配对以后就会产生 <code>[2,0],[2,1],[2,0],[2,1]</code>。skip_grams 如下图所示.</p>
<p>输入的是 one-hot 向量，“1”的位置就是中心词. 由于 Word2Vec 的输入是 one-hot 表示，所以我们先构建一个对角全 1 的矩阵，利用 <code>np.eye(rows)</code> 方法，其中的参数 rows 表示全 1 矩阵的行数，对于这个问题来说，语料库中总共有多少个单词，就有多少行</p>
<p>然后根据 skip_grams 每行第一列的值，取出相应全 1 矩阵的行。将这些取出的行，append 到一个 list 中去，最终的这个 list 就是所有的样本 X。标签不需要 one-hot 表示，只需要类别值，所以只用把 skip_grams 中每行的第二列取出来存起来即可</p>
<p>最后就是构建 dataset，然后定义 DataLoader</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220328131035.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用中心词生成背景词的概率</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_data</span>(<span class="hljs-params">skip_grams</span>):</span><br>    input_data = []<br>    output_data = []<br>    <br>    <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> skip_grams:<br>        input_data.append(np.eye(vocab_size)[a])  <span class="hljs-comment"># 就是数组里的数相当于在onehot数组里的位置是1</span><br>        output_data.append(b)<br><br>    <span class="hljs-keyword">return</span> input_data, output_data<br><br><br>input_data, output_data = make_data(skip_grams)<br>input_data, output_data = torch.Tensor(input_data), torch.LongTensor(output_data)<br>dataset = Data.TensorDataset(input_data, output_data)<br>loader = Data.DataLoader(dataset, batch_size, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p><code>np.eye()</code> 的函数，除了生成对角阵外，还可以将一个label数组，大小为(1,m)或者(m,1)的数组，转化成one-hot数组。</p><p>例如 可以将类别总数为6的 <code>labels=[1,2,3,0,1,1]</code> 的数组转化成数组 <code>[[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0],[0,0,0,0,0,0],[0,1,0,0,0,0],[0,1,0,0,0,0]]</code> 这就是所谓的one-hot的形式。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">labels=np.array([[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>]])<br>print(<span class="hljs-string">&quot;labels的大小：&quot;</span>,labels.shape,<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>因为我们的类别是从0-2，所以这里是3个类</p><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs python">a=np.eye(<span class="hljs-number">3</span>)[<span class="hljs-number">1</span>]<br>print(<span class="hljs-string">&quot;如果对应的类别号是1，那么转成one-hot的形式&quot;</span>,a,<span class="hljs-string">&quot;\n&quot;</span>)<br>--&gt; 如果对应的类别号是1，那么转成one-hot的形式 [0. 1. 0.]<br></code></pre></td></tr></table></figure>
          </div>
<p>定义模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义模型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Word2Vec</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(Word2Vec, self).__init__()<br>        self.W = nn.Parameter(torch.randn(vocab_size, embedding_size).<span class="hljs-built_in">type</span>(dtype))<br>        self.V = nn.Parameter(torch.randn(embedding_size, vocab_size).<span class="hljs-built_in">type</span>(dtype))<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-comment"># X: [batch_size, vocab_size]</span><br>        hidden = torch.mm(X, self.W)  <span class="hljs-comment"># [batch_size, m]</span><br>        output = torch.mm(hidden, self.V)  <span class="hljs-comment"># [batch_size, vocab_size]</span><br>        <span class="hljs-keyword">return</span> output<br>    <br>    <br>model = Word2Vec().to(device)<br>loss_fn = nn.CrossEntropyLoss().to(device)<br>optim = optimizer.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br></code></pre></td></tr></table></figure>
<p>训练</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># train</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000</span>):<br>    <span class="hljs-keyword">for</span> i, (batch_x, batch_y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(loader):<br>        <span class="hljs-comment"># 先移到cuda上去</span><br>        batch_x = batch_x.to(device)<br>        batch_y = batch_y.to(device)<br>        pred = model(batch_x)<br>        loss = loss_fn(pred, batch_y)<br>        <br>        <span class="hljs-keyword">if</span>(epoch + <span class="hljs-number">1</span>) % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            print(epoch + <span class="hljs-number">1</span>, i, loss.item())<br>            <br>        optim.zero_grad()<br>        loss.backward()<br>        optim.step()<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>快速选择</title>
    <url>/2022/03/18/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p><strong>快速选择算法</strong>是快速排序的一种变形。通常用在<strong>未排序的数组中寻找第k小/第k大的元素</strong>。快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是<strong>只递归进入一边的元素中继续寻找</strong>。这降低了平均时间复杂度，从 <span class="math inline">\(O(n logn)\)</span> 至 <span class="math inline">\(O(n)\)</span> ，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p><em><a id="more"></a></em></p>
<h1 id="快速选择算法">快速选择算法</h1>
<p>快速选择算法是快速排序的一种变形。通常用<strong>在未排序的数组中寻找第k小/第k大的元素</strong>。</p>
<h2 id="思路">思路</h2>
<p>快速选择的总体思路与快速排序一致。（先快排）</p>
<ol type="1">
<li><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</li>
<li><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</li>
<li><strong>递归处理k在的一端</strong>：快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。直至 <code>if (l &gt;= r) return q[l];</code> 。其中 <code>q[l]</code> 或者 <code>q[r]</code> 都可以，因为最后一次递归数组里只有一个数，就是要找的数。</li>
</ol>
<h2 id="快速选择模板">快速选择模板</h2>
<p><strong>快速选择算法：类似快排+二分，k在哪半部分，就递归哪个部分。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quick_select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];  <span class="hljs-comment">// q[l]/q[r]都可以，因为最后一次递归数组里只有一个数</span><br>    <br>    <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> left_num = j - l + <span class="hljs-number">1</span>;  <span class="hljs-comment">// left_num: 左边的数有多少个</span><br>    <br>    <span class="hljs-keyword">if</span> (k &lt;= left_num) quick_select(q, l, j, k);  <span class="hljs-comment">// 递归左半边</span><br>    <span class="hljs-keyword">else</span> quick_select(q, j + <span class="hljs-number">1</span>, r, k - left_num);  <span class="hljs-comment">// 递归右半边</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="时间复杂度">时间复杂度</h2>
<p>快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 <span class="math inline">\(O(n logn)\)</span> 至 <span class="math inline">\(O(n)\)</span> ，不过最坏情况仍然是 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p>第一层：<span class="math inline">\(O(n)\)</span></p>
<p>第二层：<span class="math inline">\(O(n/2)\)</span></p>
<p>第三层：<span class="math inline">\(O(n/4)\)</span></p>
<p>...</p>
<p>所以：<span class="math inline">\(O(n·(1 + \frac{1}{2}+ \frac{1}{4} + ... + \frac{1}{n})) &lt;= O(2n) = O(n)\)</span></p>
<h2 id="例题">例题</h2>
<h3 id="acwing-786.-第k个数"><a href="https://www.acwing.com/problem/content/788/">1. AcWing 786. 第k个数</a></h3>
<p>给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span>。</p>
<p>第二行包含 <span class="math inline">\(n\)</span> 个整数（所有整数均在 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(10^9\)</span>范围内），表示整数数列。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示数列的第k小数。</p>
<p><strong>数据范围</strong></p>
<p><span class="math inline">\(1≤n≤100000\)</span>, <span class="math inline">\(1≤k≤n\)</span></p>
<p><strong>输入样例</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure>
<blockquote>
<p>模板题</p>
</blockquote>
<p><strong>code</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;algorithm&gt;</span><br><br>using namespace std;<br><br>const <span class="hljs-built_in">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">int</span> q[N];<br><span class="hljs-built_in">int</span> n, k;<br><br><span class="hljs-built_in">int</span> quick_select(<span class="hljs-built_in">int</span> q[], <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r, <span class="hljs-built_in">int</span> k)<br>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];  // q[l]/q[r]都可以，因为最后一次递归数组里只有一个数<br>    <br>    <span class="hljs-built_in">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        do i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        do j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">int</span> left_num = j - l + <span class="hljs-number">1</span>;  // left_num: 左边的数有多少个<br>    <br>    <span class="hljs-keyword">if</span> (k &lt;= left_num) quick_select(q, l, j, k);  // 递归左半边<br>    <span class="hljs-keyword">else</span> quick_select(q, j + <span class="hljs-number">1</span>, r, k - (j - l + <span class="hljs-number">1</span>));  // 递归右半边<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];<br>    <br>    cout &lt;&lt; quick_select(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="acwing-104.-货仓选址"><a href="https://www.acwing.com/problem/content/106/">2. AcWing 104. 货仓选址</a></h3>
<p>题意是：在一条数轴上，有很多商店，选一个点，让其到所有商店距离最小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330144746.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> res;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    sort(a, a + n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res += <span class="hljs-built_in">abs</span>(a[i] - a[(n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
        <tag>快速选择</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 基础语法</title>
    <url>/2020/11/14/Python%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>这里记录了 Python 的一些基本知识点。</p>
<p><em><a id="more"></a></em></p>
<h1 id="基础知识">1. 基础知识</h1>
<h2 id="编译器与解释器">1.1 编译器与解释器</h2>
<p>编译器/解释器：<strong>高级语言与机器之间的翻译官</strong></p>
<p>都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程有不同而已。</p>
<p>用一个通俗的例子进行比喻：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。</p>
<ul>
<li>程序入口的编写：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    print(<span class="hljs-string">&quot;hello world&quot;</span>)<br></code></pre></td></tr></table></figure>
<h2 id="标识符就是变量名">1.2 标识符(就是变量名)</h2>
<p>所谓的标识符就是对变量、常量、函数、类等对象起的名字，变量名。</p>
<p>Python对于标识符的命名有如下规定：</p>
<ul>
<li><p>第一个字符必须是字母表中的字母或下划线 **‘_’** ，标识符的其他的部分由字母、数字和下划线组成</p></li>
<li>标识符对大小写敏感，严格区分大小写！</li>
<li><p>变量的命名不要用关键字和内置函数的名字</p></li>
</ul>
<p>一些代码规范：</p>
<ul>
<li>变量名全部小写，常量名全部大写</li>
<li>函数和方法名用小写加下划线， <code>count_star</code></li>
<li>类名用大写驼峰，每个单词的首字母大写， <code>ThreadMixIn</code></li>
<li>模块和包的名字用小写</li>
</ul>
<h2 id="变量与常量">1.3 变量与常量</h2>
<ul>
<li><p>Python 中的变量不需要声明类型。变量可以直接使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">4</span><br>b = <span class="hljs-string">&quot;xiaozhang&quot;</span><br>c = []<br>d = <span class="hljs-number">9</span>-<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li>
<li><p>用“=”号来给变量赋值，从右往左的计算顺序。</p></li>
<li><p>每个变量在使用前都必须赋值，变量赋值以后才会被创建。</p></li>
<li><p>在Python中，变量本身没有数据类型的概念，通常所说的“变量类型”是变量所引用的对象的类型，或者说是变量的值的类型。</p></li>
<li><p>Python允许同时为多个变量赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = b = c = <span class="hljs-number">1</span>，最终大家都是<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure></li>
<li><p>也可以同时为多个变量赋值，用逗号分隔，逐一对应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>，最后a是<span class="hljs-number">1</span>，b是<span class="hljs-number">2</span>，c是<span class="hljs-number">3.</span><br></code></pre></td></tr></table></figure></li>
<li><p><strong>Python中，一切事物都是对象，变量引用的是对象或者说是对象在内存中的地址。</strong></p>
<ul>
<li><p>栗子：a = 'ABC'时，Python解释器干了两件事情：</p>
<ul>
<li>在内存中创建了一个‘ABC’的字符串对象；</li>
<li>在内存中创建了一个名为a的变量，并把它指向'ABC'。</li>
</ul></li>
<li><p>栗子：a和b是什么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;Jack&#x27;</span><br>b = a<br>a = <span class="hljs-string">&#x27;Tom&#x27;</span><br>print(b)<br>print(a)<br></code></pre></td></tr></table></figure>
<ul>
<li>执行a = ‘Jack’，解释器创建字符串‘Jack’对象和变量a，并把a指向‘Jack’对象；</li>
<li>执行b = a,解释器创建变量b，并且将其指向变量a指向的字符串‘Jack’对象。</li>
<li>执行a = ‘Tom’,解释器创建字符串‘Tom’对象，并把a改为指向‘Tom’对象，与b无关。</li>
</ul></li>
</ul></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141413.png" /></p>
<h2 id="输入输出">1.4 输入输出</h2>
<h3 id="input输入函数">1.4.1 input输入函数</h3>
<p>input函数：获取用户输入，保存成一个<strong>字符串</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>inp  = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input your name: &quot;</span>)<br>please <span class="hljs-built_in">input</span> your name: jack<br><span class="hljs-meta">&gt;&gt;&gt; </span>inp<br><span class="hljs-string">&#x27;jack&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(inp)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><span class="hljs-class"></span><br>&gt;&gt;&gt; age  = input(&quot;please input your age: &quot;)<br>please <span class="hljs-built_in">input</span> your age: <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age<br><span class="hljs-string">&#x27;18&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(age)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><span class="hljs-class"></span><br>&gt;&gt;&gt; a = input(&quot;请输入一个字符：&quot;)<br>请输入一个字符：<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>)<br>请输入一个字符：   前后带有空白   <br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;   前后带有空白   &#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="print-输出函数">1.4.2 print 输出函数</h3>
<p>普通的输出没啥可说的。</p>
<p>说一下 <code>print</code> 格式化输出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141451.png" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141504.png" style="zoom: 67%;" /></p>
<p>下面是一些经典的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;i am %s&quot;</span> % <span class="hljs-string">&quot;jack&quot;</span><br><span class="hljs-comment">#i am jack</span><br>s = <span class="hljs-string">&quot;i am %s age %d&quot;</span> % (<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-comment">#i am jack age 18</span><br>s = <span class="hljs-string">&quot;i am %(name)s age %(age)d&quot;</span> % &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;<br><span class="hljs-comment">#i am jack age 18</span><br>s = <span class="hljs-string">&quot;percent %.2f&quot;</span> % <span class="hljs-number">99.97623</span><br><span class="hljs-comment">#percent 99.98</span><br>s = <span class="hljs-string">&quot;i am %(pp).2f&quot;</span> % &#123;<span class="hljs-string">&quot;pp&quot;</span>: <span class="hljs-number">123.425556</span>, &#125;<br><span class="hljs-comment">#i am 123.43</span><br>s = <span class="hljs-string">&quot;i am %.2f %%&quot;</span> % <span class="hljs-number">123.425556</span><br><span class="hljs-comment">#i am 123.43 %</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：如果你想在print中打印一个%百分符号本身，那么你需要使用%%，两个百分符转义出一个百分符，也就是print(&quot;%%&quot;)。</p>
</blockquote>
<h1 id="数据类型">2. 数据类型</h1>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141519.png" /></p>
<h2 id="数字类型">2.1 数字类型</h2>
<p>数字类型用于存储数学意义上的数值。</p>
<p>数字类型是不可变类型。所谓的不可变类型，指的是类型的值一旦有不同了，那么它就是一个全新的对象。数字1和2分别代表两个不同的对象，对变量重新赋值一个数字类型，会新建一个数字对象。</p>
<p>还是要强调一下Python的变量和数据类型的关系，变量只是对某个对象的引用或者说代号、名字、调用等等，变量本身没有数据类型的概念。类似1，[2, 3, 4]，“haha”这一类对象才具有数据类型的概念。</p>
<blockquote>
<p>例如：</p>
<p>a = 1 # 创建数字对象1</p>
<p>a = 2 # 创建数字对象2，并将2赋值给变量a，a不再指向数字对象1</p>
<p>这里，发生了变化的是变量a的指向，而不是数字对象1变成了数字对象2。</p>
</blockquote>
<p>Python 支持三种不同的数字类型：整数、浮点数和复数。</p>
<h2 id="字符串">2.2 字符串</h2>
<p><strong>字符串是不可变的序列数据类型</strong>，不能直接修改字符串本身，和数字类型一样</p>
<blockquote>
<p>注：中文符号 &gt; 字母 &gt; 数字 &gt;英文符号</p>
<p>例: <code>print(min('今天是个好日子！'))</code> 返回 ”！“</p>
</blockquote>
<ul>
<li>字符串的拼接，用 ”+“ 这个符号</li>
</ul>
<h3 id="常用函数">常用函数</h3>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>upper()</td>
<td>函数的作用是将字符串中所有的字母大写，只针对字母。</td>
</tr>
<tr class="even">
<td>lower()</td>
<td>函数的作用是将字符串中所有的字母小写，只针对字母。</td>
</tr>
<tr class="odd">
<td>capitalize()</td>
<td>将字符串的第一个字母变成大写，其它字母变小写。</td>
</tr>
<tr class="even">
<td>swapcase()</td>
<td>将字符串的小写变大写，大写变小写。</td>
</tr>
<tr class="odd">
<td>zfill(参数=新字符串希望的宽度)</td>
<td>返回指定长度的字符串，原字符串右对齐，前面填充0。</td>
</tr>
<tr class="even">
<td>count(参数=查询某个元素的元素)</td>
<td>返回当前字符串中某个元素的个数。</td>
</tr>
<tr class="odd">
<td>startswith(参数=字符串)</td>
<td>判断字符串开始位是否为某个元素，返回布尔值</td>
</tr>
<tr class="even">
<td>endswith(参数=字符串)</td>
<td>判断字符串结尾为是否为某个元素，返回布尔值</td>
</tr>
<tr class="odd">
<td>find(参数=查询某个元素的元素)</td>
<td>用于获取子字符串出现的位置，如果存在则返回子字符串中<u>第一个字符</u>的索引值，如果没有找到则返回-1</td>
</tr>
<tr class="even">
<td>index(参数=查询某个元素的元素 )</td>
<td>用于获取子字符串出现的位置，如果存在则返回子字符串中<u>第一个字符</u>的索引值，如果index找不到元素，会导致程序报错</td>
</tr>
<tr class="odd">
<td>strip(参数=想去掉的某个元素)</td>
<td>去掉字符串开头与结尾指定元素，默认是空格</td>
</tr>
<tr class="even">
<td>lstrip()</td>
<td>仅去掉字符串开头指定元素或空格</td>
</tr>
<tr class="odd">
<td>rstrip()</td>
<td>仅去掉字符串结尾指定元素或空格</td>
</tr>
<tr class="even">
<td>replace()</td>
<td>用于将字符串中旧元素替换成新元素，并能指定替换的数量</td>
</tr>
<tr class="odd">
<td>isspace()</td>
<td>判断字符串是否是只由空格组成的字符串</td>
</tr>
<tr class="even">
<td>istitle()</td>
<td>判断字符串是否是一个标题类型,所有单词的首字母大写才属于标题</td>
</tr>
<tr class="odd">
<td>isupper()/islower()</td>
<td>判断字符串的所有字母是否都是大写或者小写</td>
</tr>
<tr class="even">
<td>split()</td>
<td>连接字符串</td>
</tr>
<tr class="odd">
<td>join()</td>
<td>拆分字符串</td>
</tr>
</tbody>
</table>
<ul>
<li><code>spilt(str=&quot;&quot;, num=string.count(str))</code>
<ul>
<li>str -- 分隔符，默认为所有的空字符，包括空格、换行()、制表符()等。</li>
<li>num -- 分割次数。默认为 -1, 即分隔所有。</li>
</ul></li>
<li><code>str.join(sequence)</code>
<ul>
<li>sequence -- 要连接的元素序列。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">li = [<span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>]<br>print(<span class="hljs-string">&#x27; &#x27;</span>.join(li))<br><br>b = <span class="hljs-string">&#x27;my job is a teacher&#x27;</span><br>print(b.split())<br><br>b = <span class="hljs-string">&#x27;my_name_is_bob&#x27;</span><br>print(b.split(<span class="hljs-string">&#x27;_&#x27;</span>))<br>print(b.split(<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>
<p>字符串和bytes转换：</p>
<ul>
<li><code>encode(encoding='UTF-8,errors='strict')</code> ：将字符串内容转换为bytes类型的数据</li>
<li><code>decode(encoding='UTF-8,errors='strict')</code> ：以 <em>encoding</em> 指定的编码格式解码字符串。</li>
</ul>
<h3 id="编码格式">编码格式</h3>
<p>对语言的解析识别/标准</p>
<ul>
<li>gbk中文编码</li>
<li>ASCII英文编码</li>
<li>utf-8国际通用编码</li>
</ul>
<h3 id="格式化输出">格式化（输出）</h3>
<ol type="1">
<li>字符符串格式化用操作符 <code>%</code> 来实现</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;my name is %s&#x27;</span><br>name = <span class="hljs-string">&#x27;xz&#x27;</span><br>print(info % name)<br></code></pre></td></tr></table></figure>
<ul>
<li>格式化符</li>
</ul>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%s</td>
<td>格式化字符串，通用类型</td>
</tr>
<tr class="even">
<td>%d</td>
<td>格式化整型</td>
</tr>
<tr class="odd">
<td>%f</td>
<td>格式化浮点型</td>
</tr>
<tr class="even">
<td>%u</td>
<td>格式化无符号整型（正整型）</td>
</tr>
<tr class="odd">
<td>%c</td>
<td>格式化字符</td>
</tr>
<tr class="even">
<td>%o</td>
<td>格式化无符号八进制数</td>
</tr>
<tr class="odd">
<td>%x</td>
<td>格式化无符号16进制数</td>
</tr>
<tr class="even">
<td>%e</td>
<td>科学计数法格式化浮点数</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&#x27;%u&#x27;</span> % -<span class="hljs-number">1</span>)  <span class="hljs-comment"># -1</span><br>print(<span class="hljs-string">&#x27;%f&#x27;</span> % <span class="hljs-number">3.14</span>)  <span class="hljs-comment"># 3.140000</span><br>print(<span class="hljs-string">&#x27;%d&#x27;</span> % <span class="hljs-number">10</span>)  <span class="hljs-comment"># 10</span><br>print(<span class="hljs-string">&#x27;%d&#x27;</span> % <span class="hljs-number">1.2</span>)  <span class="hljs-comment">#1</span><br>print(<span class="hljs-string">&#x27;%s&#x27;</span> % <span class="hljs-string">&#x27;123&#x27;</span> )  <span class="hljs-comment"># 123</span><br><br>print(<span class="hljs-string">&#x27;&#123;:f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1.2</span>))  <span class="hljs-comment"># 1.200000</span><br><br>print(<span class="hljs-string">&#x27;%o&#x27;</span> % <span class="hljs-number">8</span>)  <span class="hljs-comment"># 10</span><br>print(<span class="hljs-string">&#x27;%x&#x27;</span> % <span class="hljs-number">32</span>)  <span class="hljs-comment"># 20</span><br><span class="hljs-comment"># print(&#x27;%x&#x27; % &#x27;123ab&#x27;)</span><br>number = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;123ab&#x27;</span>, <span class="hljs-number">16</span>)<br>print(number)<br>print(<span class="hljs-string">&#x27;%x&#x27;</span> % number)<br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>字符串格式化函数 - <code>format</code></li>
</ol>
<ul>
<li>使用 format的字符串主体使用 <code>&#123;&#125; 大括号</code> 来代替格式符，可以不取下标，取的话从0开始</li>
<li><code>string.format(data, data...)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;my name is &#123;&#125;&#x27;</span><br>name = <span class="hljs-string">&#x27;xz&#x27;</span><br>print(info.<span class="hljs-built_in">format</span>(name))<br></code></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><code>f-strings</code> <em>新方法</em></li>
</ol>
<ul>
<li>定义一个变量</li>
<li>字符串前加 f 符号</li>
<li>需要格式化的位置使用 <code>&#123;变量名&#125;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;xz&#x27;</span>  <span class="hljs-comment"># 一定要先定义变量名</span><br>info = <span class="hljs-string">f&#x27;my name is <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span><br>print(info)<br></code></pre></td></tr></table></figure>
<ul>
<li>转义字符</li>
</ul>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>换行，一般用于末尾，strip对其也有效</td>
</tr>
<tr class="even">
<td></td>
<td>横向制表符</td>
</tr>
<tr class="odd">
<td></td>
<td>响铃</td>
</tr>
<tr class="even">
<td></td>
<td>退格符，光标前移，覆盖（删除前一个）</td>
</tr>
<tr class="odd">
<td></td>
<td>回车</td>
</tr>
<tr class="even">
<td> '</td>
<td>转义字符串中的单引号</td>
</tr>
<tr class="odd">
<td> '‘</td>
<td>转义字符串中的双引号</td>
</tr>
<tr class="even">
<td>\</td>
<td>转移斜杠</td>
</tr>
</tbody>
</table>
<ul>
<li>在字符串前加 r 来将当前字符串的转义字符无效化</li>
</ul>
<h2 id="布尔类型">2.3 布尔类型</h2>
<ul>
<li><p><code>0、0.0、-0.0、空字符串、空列表、空元组、空字典</code>，这些都被判定为False。而<code>-1、&quot;False&quot;</code>也被判断为True。</p></li>
<li><p><code>None</code> 也不是布尔类型，而是<code>NoneType</code>。</p></li>
</ul>
<blockquote>
<p>平时最容易犯的错误就是获得了一个None值，却对它进行各种方法调用，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-literal">None</span>]<br><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> list1:<br>    print(char.join(<span class="hljs-string">&quot;A&quot;</span>))<br><br>    <br>AttributeError: <span class="hljs-string">&#x27;NoneType&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;join&#x27;</span>        <br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="列表-list">2.4 列表 List</h2>
<p>Python的列表是一个有序可重复的元素集合，可嵌套、迭代、修改、分片、追加、删除，成员判断。</p>
<p>从数据结构角度看，Python的列表是一个可变长度的顺序存储结构，每一个位置存放的都是对象的指针。</p>
<p>比如，对于这个列表 <code>alist = [1, “a”, [11,22], &#123;“k1”:”v1”&#125;]</code>，其在内存内的存储方式是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141602.png" /></p>
<h3 id="索引">索引</h3>
<p>索引是最左边记录的位置。用数字表示，从0开始，<code>len(list)-1</code> 结束。</p>
<ul>
<li>创建</li>
</ul>
<p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表内的元素，可以是其它任意类型的数据，可多层嵌套列表，元素个数无限制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = []        <span class="hljs-comment"># 创建一个空列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>], &#123;<span class="hljs-string">&#x27;k1&#x27;</span>:<span class="hljs-string">&#x27;v1&#x27;</span>&#125;]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure>
<ul>
<li>访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;b&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;c&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">3</span>]<br><span class="hljs-comment">###########</span><br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure>
<ul>
<li>修改：直接对元素进行重新赋值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;d&#x27;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>字符串不可以通过索引修改或删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;comprehensive&quot;</span><br>a[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;a&#x27;</span><br><br><span class="hljs-comment">############</span><br>TypeError: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>删除：使用 <code>del</code> 语句或者 <code>remove()</code> ，<code>pop()</code> 方法删除指定的元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lis = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> lis[<span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis.remove(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[<span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>lis.pop()<br><span class="hljs-string">&#x27;c&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>lis<br>[]<br></code></pre></td></tr></table></figure>
<ul>
<li>常用函数</li>
</ul>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>len(list)</td>
<td>返回列表元素个数，也就是获取列表长度</td>
</tr>
<tr class="even">
<td>max(list)</td>
<td>返回列表元素最大值</td>
</tr>
<tr class="odd">
<td>min(list)</td>
<td>返回列表元素最小值</td>
</tr>
<tr class="even">
<td>list(seq)</td>
<td>将序列转换为列表</td>
</tr>
<tr class="odd">
<td>in/not in</td>
<td>判断某个元素是否在列表中</td>
</tr>
</tbody>
</table>
<h3 id="切片">切片</h3>
<p>切片指的是对序列进行截取，选取序列中的某一段。</p>
<p>切片的语法是： <code>list[start:end]</code>，注意，<strong>区间是左闭右开的</strong>！</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141634.png" /></p>
<ul>
<li>如果下标是负数，从后往前数，是 <code>-1 ~ -len(list)</code></li>
</ul>
<h3 id="列表的常见方法">列表的常见方法</h3>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>append(item)</td>
<td>将一个元素添加到当前原有列表的末尾</td>
</tr>
<tr class="even">
<td>insert(index, new_item)</td>
<td>插入新的元素，在什么位置。如果插入位置不存在，则加在结尾。如果插入位置存在元素，则该元素往后移，将插入元素放入该位置。</td>
</tr>
<tr class="odd">
<td>count(item)</td>
<td>返回当前列表中某个元素的个数</td>
</tr>
<tr class="even">
<td>remove(item)</td>
<td>删除列表的指定元素。如不存在，会报错。如有多个，只删第一个。</td>
</tr>
<tr class="odd">
<td>del item</td>
<td>删掉整个列表</td>
</tr>
<tr class="even">
<td>reverse()</td>
<td>反转当前列表</td>
</tr>
<tr class="odd">
<td>sort(cmp=None, key=None, reverse=False)</td>
<td>对当前列表按照一定规律进行排序且list中的元素必须是统一类型，否则程序就会报错。</td>
</tr>
<tr class="even">
<td>clear()</td>
<td>将list中的元素都清除，将其变成一个空列表即[]</td>
</tr>
<tr class="odd">
<td>copy()/deepcopy()</td>
<td><strong>浅拷贝/深拷贝</strong></td>
</tr>
<tr class="even">
<td>extend()</td>
<td>将其他list中的元素导入到当前的list</td>
</tr>
</tbody>
</table>
<blockquote>
<p>例：append()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">books = [<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>]<br>book = [<span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>]<br>books.append(book)<br>print(books)<br><br>---------------------------------<br>[<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, [<span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>]]<br></code></pre></td></tr></table></figure>
<ul>
<li>extend()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&quot;name&quot;</span>]<br>tuplee=(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>)<br><br>list1.extend(tuplee)<br>print(list1)<br><br>---------------------------------<br>[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>]<br></code></pre></td></tr></table></figure>
</blockquote>
<p>注意：</p>
<ol type="1">
<li><p>其中的类似 append，insert, remove 等方法会修改列表本身，并且没有返回值（严格的说是返回None）。</p></li>
<li><p><font color='red'>浅拷贝与深拷贝</font></p>
<p>使用浅拷贝，当原容器对象中可变对象中有元素发生变化，拷贝得到的对象也会变化。而使用深拷贝时，不会有这种问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>]<br>list2 = list1.copy()<br><br>print(<span class="hljs-built_in">id</span>(list1), <span class="hljs-built_in">id</span>(list2))<br>list2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">123</span><br>list2[<span class="hljs-number">2</span>] = <span class="hljs-number">77</span><br>print(list1, list2)<br><br>---------------------------------<br><span class="hljs-number">1904206959560</span> <span class="hljs-number">1904227747656</span><br>[[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>] [[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>   <br>list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>]<br>list2 = copy.deepcopy(list1)<br>   <br>print(<span class="hljs-built_in">id</span>(list1), <span class="hljs-built_in">id</span>(list2))<br>list2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">123</span><br>list2[<span class="hljs-number">2</span>] = <span class="hljs-number">77</span><br>print(list1, list2)<br>   <br>---------------------------------<br><span class="hljs-number">1563824640968</span> <span class="hljs-number">1563844713928</span><br>[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">66</span>] [[<span class="hljs-number">123</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;fei&#x27;</span>, <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>可以理解为：浅拷贝对于一个复杂对象的子对象并不会完全复制，复杂对象的子对象是指比如序列中的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，python会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。</p>
</blockquote></li>
</ol>
<blockquote>
<p>例题：使用给定的整数n，编写一个程序生成一个包含(i, i*i)的字典，该字典包含1到n之间的整数(两者都包含)。然后程序应该打印字典。 假设向程序提供以下输入:8，则输出为:{1:1，2:4，3:9，4:16，5:25，6:36，,7:49，8:64}</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">8</span><br>d = <span class="hljs-built_in">dict</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    d[i] = i * i<br>print(d)<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="元组-tuple">2.5 元组 Tuple</h2>
<p>用圆括号括起来的是元组。</p>
<p>元组也是序列结构，但是是一种<strong>不可变序列</strong>，可以<strong>简单的理解为内容不可变的列表。除了在内部元素不可修改的区别外</strong>，元组和列表的用法差不多。</p>
<blockquote>
<p>因为元组是不可变的，所以不能在原来的数据基础上再添加数据，因此元组占用的资源会比列表更小。</p>
</blockquote>
<p><strong>元组与列表相同的操作</strong>：</p>
<ul>
<li>使用方括号加下标访问元素</li>
<li>切片（形成新元组对象）</li>
<li>count()/index()</li>
<li>len()/max()/min()/tuple()</li>
</ul>
<p><strong>元组中不允许的操作，确切的说是元组没有的功能</strong>：</p>
<ul>
<li><p>修改、新增元素</p>
<blockquote>
<p><strong>元组只保证它的一级子元素不可变，对于嵌套的元素内部，不保证不可变！</strong>所以，在使用元组的时候，请尽量使用数字、字符串和元组这种不可变的数据类型作为元组的元素，这样就能确保元组不发生变化。</p>
</blockquote></li>
<li><p>删除某个元素（但可以删除整个元组）</p></li>
<li><p>所有会对元组内部元素发生修改动作的方法。例如，元组没有remove，append，pop等方法。</p></li>
</ul>
<h2 id="字典-dic">2.6 字典 Dic</h2>
<p>字典可精确描述为<strong>不定长、可变、散列的集合类型</strong>。</p>
<p>字典数据类型是基于hash散列算法实现的，采用<strong>键值对(key:value)</strong>的形式，根据key的值计算value的地址，具有非常快的查取和插入速度。</p>
<p>字典包含的元素个数不限，值的类型可以是任何数据类型！但是字典的key必须是不可变的对象，例如数字、字符串、bytes和元组，最常见的还是将字符串作为key。列表、字典、集合等就不可以作为key。同时，同一个字典内的key必须是唯一的，但值则不必。</p>
<blockquote>
<p>字典类型的数据不支持累乘。</p>
</blockquote>
<ul>
<li>创建</li>
</ul>
<ol type="1">
<li><code>dic = &#123;&#125;</code> # 创建空字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">dic = &#123;&#125;    <span class="hljs-comment"># 创建空字典</span><br>dic = &#123;<span class="hljs-string">&#x27;Alice&#x27;</span>: <span class="hljs-string">&#x27;2341&#x27;</span>, <span class="hljs-string">&#x27;Beth&#x27;</span>: <span class="hljs-string">&#x27;9102&#x27;</span>, <span class="hljs-string">&#x27;Cecil&#x27;</span>: <span class="hljs-string">&#x27;3258&#x27;</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>([(<span class="hljs-string">&#x27;sape&#x27;</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">4098</span>)])<br>&#123;<span class="hljs-string">&#x27;sape&#x27;</span>: <span class="hljs-number">4139</span>, <span class="hljs-string">&#x27;jack&#x27;</span>: <span class="hljs-number">4098</span>, <span class="hljs-string">&#x27;guido&#x27;</span>: <span class="hljs-number">4127</span>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p><code>update()</code> ：在update函数里传入一个新的字典key和value就可以。存在就覆盖。</p></li>
<li><p><code>setdefault()</code>：传入一个字典key和value，如果键不存在于字典中，将会添加见并键值设为默认值，如果字典中包含有给定键，则返回该键对应的值，若不包含则返回为该键设置的值。</p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">dic = &#123;&#125;<br>dic.setdefault(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;haha&#x27;</span>)<br>dic.setdefault(<span class="hljs-string">&#x27;sex&#x27;</span>)<br>print(dic)<br><br>---------------------------------<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;Name&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;Name&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;Age&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;Age&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dic[&#x27;address&#x27;]: &quot;</span>, dic[<span class="hljs-string">&#x27;address&#x27;</span>])<br><br>---------------------------------<br>KeyError: <span class="hljs-string">&#x27;address&#x27;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>增加和修改</li>
</ul>
<p>增加就是往字典插入新的键值对，修改就是给原有的键赋予新的值。由于一个key只能对应一个值，所以，多次对一个key赋值，后面的值会把前面的值冲掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;Shanghai&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;Beijing&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic[<span class="hljs-string">&quot;Age&quot;</span>] = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic<br>&#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>删除字典元素、清空字典和删除字典</li>
</ul>
<p>使用 <code>del</code> 关键字删除字典元素或者字典本身，使用字典的 <code>clear()</code> 方法清空字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-keyword">del</span> dic[<span class="hljs-string">&#x27;Name&#x27;</span>]<br>print(dic)<br>a = dic.pop(<span class="hljs-string">&#x27;Class&#x27;</span>)  <span class="hljs-comment"># 弹出并返回指定键对应的值。必须提供参数！</span><br>print(a)<br>dic.clear()<br>print(dic)<br><span class="hljs-keyword">del</span> dic<br>print(dic)<br><br>---------------------------------<br>NameError: name <span class="hljs-string">&#x27;dic&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br>&#123;<span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>First<br>&#123;&#125;<br></code></pre></td></tr></table></figure>
<h3 id="字典的常见方法">字典的常见方法</h3>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>get(key)</strong></td>
<td><strong>返回指定键的值，如果键不在字典中，则返回default值</strong></td>
</tr>
<tr class="even">
<td><strong>items()</strong></td>
<td><strong>以列表返回可遍历的(键, 值) 元组对</strong></td>
</tr>
<tr class="odd">
<td><strong>keys()</strong></td>
<td><strong>以列表返回字典所有的键，假列表，不可对其操作，可以通过list(dict.keys())变为真列表</strong></td>
</tr>
<tr class="even">
<td><strong>values()</strong></td>
<td><strong>以列表返回字典所有的值，同上</strong></td>
</tr>
<tr class="odd">
<td>pop(key)</td>
<td>删除并返回指定key的值</td>
</tr>
<tr class="even">
<td>popitem()</td>
<td>删除并返回字典的最后一个键值对的(key,value)形式，不接受参数。且字典如果是空则直接报错</td>
</tr>
<tr class="odd">
<td>setdefault(key, default=None)</td>
<td>和get()类似,但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr class="even">
<td>update(dict2)</td>
<td>把字典dict2的键/值对更新到dict里</td>
</tr>
<tr class="odd">
<td>copy()</td>
<td>将当前字典复制到一个新的字典</td>
</tr>
</tbody>
</table>
<p>注：</p>
<ol type="1">
<li><code>get()</code> 和 <code>[]</code> 的区别</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>values = []<br>values.append(dic[<span class="hljs-string">&#x27;Name&#x27;</span>])<br>values.append(dic[<span class="hljs-string">&#x27;Age&#x27;</span>])<br>print(values)<br><span class="hljs-comment"># values.append(dic[&#x27;grade&#x27;])  # KeyError: &#x27;grade&#x27;</span><br>values.append(dic.get(<span class="hljs-string">&#x27;grade&#x27;</span>))<br>print(values)<br><br>---------------------------------<br>[<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;20&#x27;</span>]<br>[<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-literal">None</span>]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>字典中获取key的方法[]如果获取不到key会直接报错，而get如果获取不到key会返回默认值，在开发中优先考虑get方法来获取key</p>
</blockquote>
<ol start="2" type="1">
<li><code>get()</code> 与 <code>in</code> 判断的区别</li>
</ol>
<p>字典中的成员判断 in 和not in是判断是否有value，有对、无错，并不判断value是不是空。</p>
<p>而get判断值的结果，如果value是None就会返回False</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs python">dict_1 = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-literal">None</span>&#125;  <br>bool(dict_1.get(&quot;name&quot;)) --&gt; False<br></code></pre></td></tr></table></figure>
<h3 id="遍历字典">遍历字典</h3>
<p><strong>遍历字典获得的键值对是有序的！</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br><br><span class="hljs-comment"># 1  直接遍历字典获取键，根据键取值</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic:<br>    print(key, dic[key])<br><br><span class="hljs-comment"># 2  利用items方法获取键值，速度很慢，少用！</span><br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> dic.items():<br>    print(key,value)<br><br><span class="hljs-comment">#3  利用keys方法获取键</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic.keys():<br>    print(key, dic[key])<br><br><span class="hljs-comment">#4  利用values方法获取值，但无法获取对应的键。</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> dic.values():<br>    print(value)<br></code></pre></td></tr></table></figure>
<h2 id="集合-set">2.7 集合 set</h2>
<p><strong>集合是一个无序不重复元素的集</strong>，基本功能包括关系测试和消除重复元素。集合使用大括号 <code>&#123;&#125;</code> 框定元素，并以逗号进行分隔。成员是不可变类型。</p>
<p>但是注意：<u>如果要创建一个空集合，必须用 set() 而不是 {} ，因为后者创建的是一个空字典</u>。集合除了在形式上最外层用的也是花括号外，其它的和字典没有一毛钱关系。</p>
<p>集合数据类型的核心在于<strong>自动去重</strong>。很多时候能省不少事。</p>
<ul>
<li>增加</li>
</ul>
<ol type="1">
<li>通过add(key)方法可以添加一个元素到set中，可以重复添加，但不会有效果</li>
<li>可以通过update()方法，将另一个对象更新到已有的集合中，这一过程同样会进行去重。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>s.add(<span class="hljs-number">5</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5&#125;</span><br><br>s.update(<span class="hljs-string">&quot;hello&quot;</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<p>通过remove(key)方法删除指定元素，或者使用pop()方法。注意，集合的pop方法无法设置参数，删除指定的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br>s.remove(<span class="hljs-string">&#x27;l&#x27;</span>)<br>print(s)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br>s.pop(<span class="hljs-number">3</span>)  <span class="hljs-comment"># TypeError: pop() takes no arguments (1 given)</span><br></code></pre></td></tr></table></figure>
<p><strong>不能从集合取某个元素。因为集合既不支持下标索引也不支持字典那样的通过键获取值。</strong></p>
<h3 id="集合的常用方法">集合的常用方法</h3>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>difference() / -</td>
<td>返回集合的差集</td>
</tr>
<tr class="even">
<td>intersection()</td>
<td>返回集合的交集</td>
</tr>
<tr class="odd">
<td>union()</td>
<td>返回集合的并集</td>
</tr>
<tr class="even">
<td>isdisjoint()</td>
<td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td>
</tr>
<tr class="odd">
<td>issubset()</td>
<td>判断指定集合是否为该方法参数集合的子集。</td>
</tr>
<tr class="even">
<td>add()</td>
<td>为集合添加一个元素</td>
</tr>
<tr class="odd">
<td>update()</td>
<td>给集合添加元素</td>
</tr>
<tr class="even">
<td>pop()</td>
<td>移除元素</td>
</tr>
<tr class="odd">
<td>remove()</td>
<td>移除指定元素</td>
</tr>
</tbody>
</table>
<h1 id="函数">3. 函数</h1>
<p>总结函数的传参方式，有以下四种：</p>
<ul>
<li>位置参数</li>
<li>默认参数</li>
<li>关键参数</li>
<li>非固定参数
<ul>
<li><code>*args</code></li>
<li><code>**kwargs</code></li>
</ul></li>
</ul>
<h2 id="位置参数">3.1 位置参数</h2>
<p>位置参数就是调用函数时穿的实参与形参位置上一一对应的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country</span>):</span><br>	print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;CN&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h2 id="默认参数">3.2 默认参数</h2>
<p>默认参数就是在函数形参中定义好的，当是惨重未穿对应的参数时，参数就会以默认值为准。</p>
<p>注：默认参数必须放在位置参数之后，否则会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country = <span class="hljs-string">&#x27;CN&#x27;</span></span>):</span><br>	print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h2 id="关键参数">3.3 关键参数</h2>
<p>正常情况下，给函数传参数要按照顺序，如果不按顺序就可以用关键参数，只需指定参数名即可（指定参数名的参数叫关键参数）</p>
<p>注：关键参数必须放在位置参数（以位置顺序确定对应关系的参数）之后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stu_ingo</span>(<span class="hljs-params">name, age, major, country = <span class="hljs-string">&#x27;CN&#x27;</span></span>):</span><br>	print(name, age, major, country)<br><br>stu1 = stu_info(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, country = <span class="hljs-string">&#x27;UK&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h2 id="非固定参数">3.4 非固定参数</h2>
<p><code>*args</code>与 <code>**kwargs</code> 是可变类型且 <code>*args</code> 将参数封装成元组类型给函数体调用，<code>**kwargs</code> 将参数封装成字典类型给函数体调用</p>
<blockquote>
<p>栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">seq</span>(<span class="hljs-params">num, num1, num2</span>):</span><br>    <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">88</span> :<br>        print(num1 * num2)<br>    <span class="hljs-keyword">else</span>:<br>        print(num1 + num2)<br>        <br><span class="hljs-comment"># 定义变量tuple1的值为(5,2,1)</span><br>tuple1 = (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 调用函数，传入参数tuple1，并打印函数返回值</span><br>seq(*tuple1)  <span class="hljs-comment"># *tuple1可实现对元组tuple1的解包</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="args">3.4.1 <code>*args</code></h3>
<p>可同时指定多个用户，传过来的所有参数打包成元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_args</span>(<span class="hljs-params">first, *args</span>):</span><br>    print(<span class="hljs-string">&#x27;Required argument: &#x27;</span>, first)<br>    print(<span class="hljs-built_in">type</span>(args))<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> args:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument: &#x27;</span>, v)<br><br>test_args(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>
<p>第一个参数是必须要传入的参数，所以使用了第一个形参，而后面三个参数则作为可变参数列表传入了实参，并且是作为元组tuple来使用的。代码的运行结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Required argument:  <span class="hljs-number">1</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">tuple</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">Optional</span> <span class="hljs-title">argument</span>:</span>  <span class="hljs-number">2</span><br>Optional argument:  <span class="hljs-number">3</span><br>Optional argument:  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<h3 id="kwargs">3.4.2 <code>**kwargs</code></h3>
<p>可同时指定多个用户，传过来的所有参数打包成元组或字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_kwargs</span>(<span class="hljs-params">first, *args, **kwargs</span>):</span><br>   print(<span class="hljs-string">&#x27;Required argument: &#x27;</span>, first)<br>   print(<span class="hljs-built_in">type</span>(kwargs))<br>   <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> args:<br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument (args): &#x27;</span>, v)<br>   <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items():<br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Optional argument %s (kwargs): %s&#x27;</span> % (k, v))<br><br>test_kwargs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, k1=<span class="hljs-number">5</span>, k2=<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure>
<p>正如前面所说的，<code>args</code> 类型是一个tuple，而 <code>kwargs</code> 则是一个字典 <code>dict</code>，并且 <code>args</code> 只能位于 <code>kwargs</code> 的前面。代码的运行结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Required argument:  <span class="hljs-number">1</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">dict</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">Optional</span> <span class="hljs-title">argument</span> (<span class="hljs-params">args</span>):</span>  <span class="hljs-number">2</span><br>Optional argument (args):  <span class="hljs-number">3</span><br>Optional argument (args):  <span class="hljs-number">4</span><br>Optional argument k1 (kwargs): <span class="hljs-number">5</span><br>Optional argument k2 (kwargs): <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<h2 id="综合练习函数的使用">综合练习：函数的使用</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    学生信息库</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>students = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;dewei&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小木&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">5</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小安&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 检查位置参数的判断</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_info</span>(<span class="hljs-params">**kwargs</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生姓名&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生年龄&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生性别&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;没有发现学生班级&#x27;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_students</span>():</span><br>    <span class="hljs-keyword">for</span> id_, value <span class="hljs-keyword">in</span> students.items():<br>        print(<span class="hljs-string">&#x27;学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>            id_, value[<span class="hljs-string">&#x27;name&#x27;</span>], value[<span class="hljs-string">&#x27;age&#x27;</span>], value[<span class="hljs-string">&#x27;sex&#x27;</span>], value[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>        ))<br>    <span class="hljs-keyword">return</span> students<br><br><span class="hljs-comment"># result = get_all_students()</span><br><span class="hljs-comment"># print(&#x27;---&#x27;, result)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_student</span>(<span class="hljs-params">**kwargs</span>):</span><br>    check = check_user_info(**kwargs)<br>    <span class="hljs-keyword">if</span> check != <span class="hljs-literal">True</span>:<br>        print(check)<br>        <span class="hljs-keyword">return</span><br><br>    id_ = <span class="hljs-built_in">max</span>(students) + <span class="hljs-number">1</span>  <span class="hljs-comment"># 不在长度上加1，会覆盖以前删掉的号码</span><br><br>    students[id_] = &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: kwargs[<span class="hljs-string">&#x27;name&#x27;</span>],<br>        <span class="hljs-string">&#x27;age&#x27;</span>: kwargs[<span class="hljs-string">&#x27;age&#x27;</span>],<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: kwargs[<span class="hljs-string">&#x27;sex&#x27;</span>],<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: kwargs[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>    &#125;<br><br><span class="hljs-comment"># add_student(name=&#x27;小章鱼&#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span><br><span class="hljs-comment"># get_all_students()</span><br><br><span class="hljs-comment"># 删除</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_student</span>(<span class="hljs-params">student_id</span>):</span><br>    <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> students:<br>        print(<span class="hljs-string">&#x27;学号是&#123;&#125;号的同学的信息不存在&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br>    <span class="hljs-keyword">else</span>:<br>        user_info = students.pop(student_id)<br>        print(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br><span class="hljs-comment"># delete_student(2)</span><br><span class="hljs-comment"># add_student(name=&#x27;小章鱼&#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span><br><span class="hljs-comment"># get_all_students()</span><br><br><span class="hljs-comment"># 修改</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_student</span>(<span class="hljs-params">student_id, **kwargs</span>):</span><br>    <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> students:<br>        print(<span class="hljs-string">&#x27;不存在学号：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br><br>    check = check_user_info(**kwargs)<br>    <span class="hljs-keyword">if</span> check != <span class="hljs-literal">True</span>:<br>        print(check)<br>        <span class="hljs-keyword">return</span><br><br>    students[student_id] = kwargs<br>    print(<span class="hljs-string">&#x27;&#123;&#125;同学信息更新完毕&#x27;</span>.<span class="hljs-built_in">format</span>(kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>update_student(<span class="hljs-number">2</span>, name=<span class="hljs-string">&#x27;2小木&#x27;</span>, age=<span class="hljs-number">11</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>,class_number=<span class="hljs-string">&#x27;B&#x27;</span>)<br>get_all_students()<br><br><span class="hljs-comment"># 查找，通过学号</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_id</span>(<span class="hljs-params">student_id</span>):</span><br>    <span class="hljs-keyword">return</span> students.get(student_id)<br><br>print(get_user_by_id(<span class="hljs-number">3</span>))<br><br><span class="hljs-comment">#</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_users</span>(<span class="hljs-params">**kwargs</span>):</span><br>    values = <span class="hljs-built_in">list</span>(students.values())<br>    key = <span class="hljs-literal">None</span><br>    value = <span class="hljs-literal">None</span><br>    result = []<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;name&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;age&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;sex&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>        key = <span class="hljs-string">&#x27;class_number&#x27;</span><br>        value = kwargs[key]<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;没有发现搜索的关键字&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> values:<br>        <span class="hljs-keyword">if</span> user[key] == value:<br>            result.append(user)<br><br>    <span class="hljs-keyword">return</span> result<br><br>print(<span class="hljs-string">&#x27;--------------------&#x27;</span>)<br>users = search_users(sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>print(users)<br></code></pre></td></tr></table></figure>
<h1 id="面向对象编程">4. 面向对象编程</h1>
<p>基本概念：</p>
<ul>
<li>面向对象：是一种以对象为核心的编程思想。主要是找出问题中的共性问题，作为对象进行操作。</li>
<li>类：类可以创建实例。</li>
<li>对象：类不能直接使用。通过类创建实例，也就是对象，才能使用。</li>
<li>属性：类中的所有变量都称为属性。</li>
<li>方法：类中的所有函数都成为方法。不过，和函数有所不同的是，类方法至少要包含一个 <code>self</code> 参数。类方法不能单独使用，需要和类的对象一起使用。创建对象后就可以直接调用类中的方法和属性。</li>
</ul>
<h2 id="类的-self-参数">4.1 类的 self 参数</h2>
<ul>
<li><code>self</code> 是类函数中的必传参数，且必须定义在第一个参数位置</li>
<li><code>self</code> 是一个对象，他代表实例化的变量自身</li>
<li><code>self</code> 可以直接通过点 <strong><code>.</code></strong> 来定义一个类变量</li>
</ul>
<p><code>self</code> 的举例说明：</p>
<p><strong>1、属性</strong></p>
<ol type="1">
<li>如果变量定义在类下面而不是类的方法下面，那这个变量既是类的属性也是类实例的属性。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    name = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>    age = <span class="hljs-string">&#x27;21&#x27;</span><br><br>ps = Person()<br>print(ps.name)<br><br>---------------------<br>xiaozhang<br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>如果变量定义在类的方法下面，如果加了 <code>self</code> ，那这个变量就是<u>类实例</u>的属性，而不是类的属性；如果没加 <code>self</code> ，那这个变量就是这个方法的局部变量，既不是类的属性也不是类实例的属性。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.name = <span class="hljs-string">&#x27;xiaozhang&#x27;</span><br>        age = <span class="hljs-string">&#x27;21&#x27;</span><br><br>ps = Person()<br>print(ps.name)<br>print(ps.age)<br><br>---------------------------------<br>xiaozhang<br>Traceback (most recent call last):<br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;age&#x27;</span><br></code></pre></td></tr></table></figure>
<p><strong>2、方法</strong></p>
<ol type="1">
<li>如果在类中定义函数时<u>加了</u> <code>self</code> ，那这个函数就是类实例的方法，而不是类的方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小张爱跑步&#x27;</span>)<br><br><br>ps = Person()<br>ps.run()<br><span class="hljs-comment"># Person.run()</span><br><br>---------------------------------<br>小张爱跑步<br><span class="hljs-comment"># TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br><br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>如果在类中定义函数时<u>没加</u> <code>self</code> ，那这个函数就只是类的方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>        print(<span class="hljs-string">&#x27;小张爱跑步&#x27;</span>)<br><br><br>ps = Person()<br><span class="hljs-comment"># ps.run()</span><br>Person.run()<br><br>---------------------------------<br><span class="hljs-comment"># TypeError: run() takes 0 positional arguments but 1 was given</span><br>小张爱跑步<br><br></code></pre></td></tr></table></figure>
<h2 id="私有函数与私有变量">4.2 私有函数与私有变量</h2>
<ul>
<li>只希望类内部业务调用使用，不希望被使用者调用</li>
<li>私有函数与变量无法被实例化后的对象所调用</li>
<li><p>而类内部可以调用私有函数与变量</p></li>
<li><p>在变量或者函数前添加两个下横线 <code>__</code></p></li>
</ul>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __cat_type = <span class="hljs-string">&#x27;cat&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, sex</span>):</span><br>        self.name = name<br>        self.__sex = sex<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        tmp = self.__run()<br>        print(tmp)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="hljs-subst">&#123;self.name&#125;</span> <span class="hljs-subst">&#123;self.__sex&#125;</span> 开心的奔跑着&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span>(<span class="hljs-params">self</span>):</span><br>        tmp = self.__jump()<br>        print(tmp)                                        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__jump</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="hljs-subst">&#123;self.name&#125;</span> <span class="hljs-subst">&#123;self.__sex&#125;</span> 开心的跳着&#x27;</span><br><br>cat = Cat(name = <span class="hljs-string">&#x27;米粒&#x27;</span>, sex = <span class="hljs-string">&#x27;boy&#x27;</span>)<br>cat.run()<br>cat.jump()<br><span class="hljs-comment"># cat.__run()</span><br>print(<span class="hljs-built_in">dir</span>(cat))  <span class="hljs-comment"># dir() 可以查看实例化对象有哪些方法</span><br>print(cat._Cat__jump())  <span class="hljs-comment"># 实例化对象调用私有函数也可以行得通，但是最好不要这样做</span><br>print(cat._Cat__cat_type)<br><br>---------------------------------<br>cat, 小猫 米粒 boy 开心的奔跑着<br>cat, 小猫 米粒 boy 开心的跳着<br>[<span class="hljs-string">&#x27;_Cat__cat_type&#x27;</span>, <span class="hljs-string">&#x27;_Cat__jump&#x27;</span>, <span class="hljs-string">&#x27;_Cat__run&#x27;</span>, <span class="hljs-string">&#x27;_Cat__sex&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;jump&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;run&#x27;</span>]<br>cat, 小猫 米粒 boy 开心的跳着<br>cat<br><br></code></pre></td></tr></table></figure>
<h3 id="举个栗子----编程练习">举个栗子----编程练习：</h3>
<p>自定义一个交通工具类(Vehicle)，并根据提示对该类进行进一步封装，使其拥有工具类型、速度、体积等属性值。通过自定义实例方法实现交通工具的前移、速度设置、获取当前速度、加速行驶、减速行驶、实例信息展示、实例类型判别等功能。</p>
<p>任务 1、自定义一个交通工具类(Vehicle) 2、设置类属性trans_type（固定值为'SUV'）和实例属性速度speed（int 类型，单位为 km/h）、体积size（tuple类型，单位为米。） 3、自定义方法 show_info( )，打印实例的所属类型和速度、体积的值； 4、自定义实例方法如下： （1）定义move( )方法，实现打印“我已向前移动了50米” （2）定义set_speed(new_speed)方法，设置对应实例的速度为new_speed km/h （3）定义get_speed()方法，如果（2）中设置了速度值则打印出来，打印格式为'我的时速为：设置的速度值 km/h' （4）定义speed_up()方法，设置每次调用时实例的速度都增加10km/h，并打印“我的速度由xx km/提升到了xx km/h” （5）定义speed_down()方法，设置每次调用时实例的速度都降低15km/h，并打印“我的速度由xx km/下降到了xx km/h” 5、自定义方法 transport_identify( )，判断实例是否为Vehicle类型。若是则打印‘类型匹配’，反之则打印‘类型不匹配’ 6、初始化实例对象tool_1</p>
<p>任务提示 类的初始化方法中所传参数size是元组类型，直接传入实例的长，宽，高即可，如size=(10,10,10)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 自定义Vehicle类属性</span><br>    trans_type = <span class="hljs-string">&#x27;SUV&#x27;</span><br><br>    <span class="hljs-comment"># 自定义实例的初始化方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, speed, size</span>):</span><br>        self.speed = speed<br>        self.size = size<br><br>    <span class="hljs-comment"># 自定义实例方法show_info，打印实例的速度和体积</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我的所属类型为: &#123;&#125;, 我的速度: &#123;&#125; km/h, 我的体积: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.trans_type, self.speed, self.size))<br><br>    <span class="hljs-comment"># 自定义实例方法move,打印“我已向前移动了50米”</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我已向前移动了50米&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义实例方法set_speed，设置对应的速度值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_speed</span>(<span class="hljs-params">self, new_speed</span>):</span><br>        self.speed = new_speed  <span class="hljs-comment"># 在这里将旧速度与新设置的速度进行统一。</span><br><br>    <span class="hljs-comment"># 自定义实例方法get_speed，打印当前的速度值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_speed</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;我的时速为 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(self.speed))<br><br>    <span class="hljs-comment"># 自定义实例方法speed_up，实现对实例的加速</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speed_up</span>(<span class="hljs-params">self</span>):</span><br>        old_speed = self.speed<br>        self.speed += <span class="hljs-number">10</span><br>        print(<span class="hljs-string">&quot;我的时速由 &#123;&#125; km/h 提升到了 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(old_speed, self.speed))<br><br><span class="hljs-comment"># 自定义实例方法speed_down，实现对实例的减速</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speed_down</span>(<span class="hljs-params">self</span>):</span><br>        old_speed = self.speed<br>        self.speed -= <span class="hljs-number">15</span><br>        print(<span class="hljs-string">&quot;我的时速由 &#123;&#125; km/h 下降到了 &#123;&#125; km/h&quot;</span>.<span class="hljs-built_in">format</span>(old_speed, self.speed))<br><br><span class="hljs-comment"># 自定义实例方法transport_identify，实现对实例所属类型的判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transport_identify</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.trans_type == <span class="hljs-string">&#x27;SUV&#x27;</span>:<br>            print(<span class="hljs-string">&quot;类型匹配&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;类型不匹配&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    tool_1 = Vehicle(<span class="hljs-number">20</span>, (<span class="hljs-number">3.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">1.75</span>))<br><br>    <span class="hljs-comment"># 调用实例方法 打印实例的速度和体积</span><br>    tool_1.show_info()<br><br>    <span class="hljs-comment"># 调用实例方法 实现实例的前移</span><br>    tool_1.move()<br><br>    tool_1.set_speed(<span class="hljs-number">40</span>)<br>    <span class="hljs-comment"># 调用实例方法 打印当前速度</span><br>    tool_1.get_speed()<br><br>    <span class="hljs-comment"># 调用实例方法 对实例进行加速</span><br>    tool_1.speed_up()<br><br>    <span class="hljs-comment"># 调用实例方法 对实例进行减速</span><br>    tool_1.speed_down()<br><br>    <span class="hljs-comment"># 调用实例方法 判断当前实例的类型</span><br>    tool_1.transport_identify()<br>    <br>---------------------------------------------    <br>我的所属类型为: SUV, 我的速度: <span class="hljs-number">20</span> km/h, 我的体积: (<span class="hljs-number">3.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">1.75</span>)<br>我已向前移动了<span class="hljs-number">50</span>米<br>我的时速为 <span class="hljs-number">40</span> km/h<br>我的时速由 <span class="hljs-number">40</span> km/h 提升到了 <span class="hljs-number">50</span> km/h<br>我的时速由 <span class="hljs-number">50</span> km/h 下降到了 <span class="hljs-number">35</span> km/h<br>类型匹配<br></code></pre></td></tr></table></figure>
<h2 id="类的封装">4.3 类的封装</h2>
<p><strong>封装</strong>：将<u>不对外的私有属性或方法</u>通过<u>可对外使用的函数</u>而使用（类中定义私有的，只有类内部使用，外部无法访问）</p>
<ul>
<li>这样做的原因：保护隐私，明确区分内外</li>
</ul>
<blockquote>
<p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。 对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者self间接获取被封装的内容。</p>
</blockquote>
<h2 id="装饰器">4.4 装饰器</h2>
<p><strong>装饰器</strong>：装饰器本质上就是一个python函数，他可以让其他函数在<strong>不需要做任何代码变动的前提下，增加额外的功能</strong>，装饰器的<strong>返回值也是一个函数对象</strong>。他们有助于让代码更简短，也更Pythonic（Python范儿）。装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等等场景。有了装饰器，我们可以抽离出大量与函数功能本身无关的雷同代码。</p>
<p>我们知道，在python中，我们可以像使用变量一样使用函数，这主要依赖于以下几点：</p>
<ul>
<li>函数可以被赋值给其他变量</li>
<li>函数可以被删除</li>
<li>可以在函数里面再定义函数，函数嵌套。</li>
<li><strong>函数可以作为参数传递给另外一个函数</strong></li>
<li>函数可以作为另一个函数的返回值</li>
</ul>
<p>为了更好的理解装饰器，先从对一个简单的函数进行装饰，假设有下面这个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world!&quot;</span><br></code></pre></td></tr></table></figure>
<p>现在我们的需求是要增强 <code>hello()</code> 函数的功能，希望给返回加上HTML标签，比如<code>&lt;i&gt;he不得改变</code>hello()` 函数原来的定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span>+fun()+<span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了一个函数 <code>makeitalic</code>，该函数有一个参数 <code>fun</code>，它是一个函数；在 <code>makeitalic</code> 函数里面我们又定义了一个内部函数 <code>wrapped</code> ，并将该函数作为返回。</p>
<p>现在我们就达到了我们的需求，不改变 <code>hello()</code> 函数的定义，但实现了我们想要的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>          <span class="hljs-keyword">return</span> wrapped<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br>hello = makeitalic(hello)<br>print(hello()) <span class="hljs-comment"># &lt;i&gt;hello world&lt;/i&gt;</span><br></code></pre></td></tr></table></figure>
<p>在上面，我们将 <code>hello</code> 函数传入 <code>makeitalic</code> ，再将返回赋值给 <code>hello</code> ，此时，调用 <code>hello()</code> 函数就可以得到我们想要的结果。 不过需要注意的是，由于我们将 <code>makeitalic</code> 的返回赋值给 <code>hello</code> ，此时，<code>hello()</code> 函数仍然存在，但它已不在指向原来定义的 <code>hello()</code> 函数了，而是指向了 <code>wrapped</code>。</p>
<p>现在我们来总结一下，上面例子为了增强原函数 <code>hello</code> 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，在这个返回的函数中，执行了原函数，并对原函数的功能进行了增强。完整的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>          <span class="hljs-keyword">return</span> wrapped<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br>hello = makeitalic(hello)<br>print(hello())<br>print(hello.__name__)<span class="hljs-number">123456789101112</span><br></code></pre></td></tr></table></figure>
<p>事实上，<code>makeitalic</code> 就是一个装饰器（<code>decorator</code>），它封装了原函数 <code>hello</code>，并返回了一个新函数，用于增强原函数的功能，并将其赋值给 <code>hello</code>。</p>
<p>一般情况下，我们使用装饰器提供的<strong><span class="citation" data-cites="语法糖">@语法糖</span>（Syntactic Sugar）</strong>，来简化上面的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeitalic</span>(<span class="hljs-params">fun</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-meta">@makeitalic</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>
<p>这种做法是我们在平时写程序时，常见的操作，但前面例子中的讲解才是内部的实现原理。</p>
<p>像上面的情况，可以动态的修改函数（或类的）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 <code>hello</code>）为参数，并返回一个包装后的函数（比如上面的 <code>wrapped</code>）给被修饰函数（<code>hello</code>）。</p>
<blockquote>
<p>之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，<strong>糖在不改变其所在位置的语法结构的前提下，实现了运行时等价</strong>。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。</p>
<p>之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：<strong>代码更简洁流畅，代码更语义自然</strong>... 写得爽，看着爽，就像吃了糖hhh。据说还有语法盐hhh反人类的代码</p>
</blockquote>
<p>举个简单的栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_str</span>(<span class="hljs-params">func</span>):</span><br>    print(<span class="hljs-string">&#x27;func:&#x27;</span>, func)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        print(<span class="hljs-string">&#x27;args:&#x27;</span>, args, kwargs)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-keyword">if</span> result == <span class="hljs-string">&#x27;okk&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is %s&#x27;</span> % result<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result is failed:%s &#x27;</span> % result<br><br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@check_str</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">return</span> data<br><br>result = test(<span class="hljs-string">&#x27;no&#x27;</span>)<br>print(result)<br><br>result = test(<span class="hljs-string">&#x27;okk&#x27;</span>)<br>print(result)<br><br>-------------------------------------<br>func: &lt;function test at <span class="hljs-number">0x00000191FC0A9168</span>&gt;<br>args: (<span class="hljs-string">&#x27;no&#x27;</span>,) &#123;&#125;<br>result <span class="hljs-keyword">is</span> failed:no <br>args: (<span class="hljs-string">&#x27;okk&#x27;</span>,) &#123;&#125;<br>result <span class="hljs-keyword">is</span> okk<br></code></pre></td></tr></table></figure>
<blockquote>
<p>小练习：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141840.png" style="zoom:60%;" /></p>
<p>输出：</p>
<p>​ 2018-11-27</p>
<p>​ call hello()</p>
<p>​ hello world</p>
<p>​ 本题考查的是装饰器的应用。代码中函数的执行顺序为先执行now函数再执行hello函数，执行now函数时输出2018-11-27，当执行hello函数时，发现了装饰器log函数，因此要先执行装饰器，输出call hello(): ，然后执行传入的hello函数，输出hello world</p>
</blockquote>
<h2 id="常用的装饰器">4.5 常用的装饰器</h2>
<ul>
<li><code>classmethod</code></li>
<li><code>staticmethod</code></li>
<li><code>property</code></li>
</ul>
<h3 id="classmethod-的功能">4.5.1 <code>classmethod</code> 的功能</h3>
<p><code>classmethod</code> ：将类函数可以不经过实例化而直接被调用。</p>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, a</span>):</span><br>        self.a = a<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;run&#x27;</span>)<br>        self.jump()  <span class="hljs-comment"># # &gt;&gt;&gt; run/n jump 证明普通的self函数可以调用带有classmethod装饰器的类函数</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span>(<span class="hljs-params">cls</span>):</span><br>        print(<span class="hljs-string">&#x27;jump&#x27;</span>)<br>        <span class="hljs-comment"># cls.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br>                   <span class="hljs-comment"># 证明带有classmethod装饰器的类函数无法调用self函数</span><br><br>t = Test(<span class="hljs-string">&#x27;aa&#x27;</span>)<br><span class="hljs-comment"># t.run()</span><br><span class="hljs-comment"># Test.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span><br>            <span class="hljs-comment"># 因为没有实例化！(这时就可以用classmethod)</span><br><span class="hljs-comment"># Test.jump()  # &gt;&gt;&gt; jump</span><br>t.run()   <span class="hljs-comment"># &gt;&gt;&gt; run/n jump</span><br></code></pre></td></tr></table></figure>
<h3 id="staticmethod-的功能">4.5.2 <code>staticmethod</code> 的功能</h3>
<p><code>staticmethod</code> ：可以将类函数不经过实例化而直接被调用，被该装饰器调用的函数<strong>不许传递 <code>self</code> 或 <code>cls</code> 参数</strong>，且无法在该函数内调用其它类函数或类变量。</p>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, a</span>):</span><br>        self.a = a<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;run&#x27;</span>)<br>        self.sleep()  <span class="hljs-comment"># 证明普通的self函数可以调用带有staticmethod装饰器的类函数</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span>():</span><br>        print(<span class="hljs-string">&#x27;i wanna sleep&#x27;</span>)<br>        self....  <span class="hljs-comment"># 直接报错，都没有self参数</span><br><br>t = Test(<span class="hljs-string">&#x27;aa&#x27;</span>)<br>Test.sleep()  <span class="hljs-comment"># &gt;&gt;&gt; i wanna sleep</span><br>t.sleep()  <span class="hljs-comment"># &gt;&gt;&gt; i wanna sleep</span><br>t.run()  <span class="hljs-comment"># &gt;&gt;&gt; run\n i wanna sleep</span><br><br></code></pre></td></tr></table></figure>
<h3 id="property-的功能">4.5.3 <code>property</code> 的功能</h3>
<p><code>property</code> ：将类含糊的执行免去括弧，类似于调用属性(变量)</p>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.__name = name<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__name<br><br><span class="hljs-meta">    @name.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">self, value</span>):</span><br>        self.__name = value<br><br>t = Test(name=<span class="hljs-string">&#x27;xiaozhang&#x27;</span>)<br>print(t.name)<br><br>t.name = <span class="hljs-string">&#x27;xiaohong&#x27;</span>  <span class="hljs-comment"># AttributeError: can&#x27;t set attribute</span><br>print(t.name)<br></code></pre></td></tr></table></figure>
<h2 id="类的继承">4.6 类的继承</h2>
<p>1、什么是继承？</p>
<ul>
<li>通过继承基类来得到基类的功能</li>
<li>被继承的类称作父类或基类，继承者称作子类</li>
<li><strong>代码重用</strong></li>
</ul>
<p>2、父类和子类的关系？</p>
<ul>
<li>子类拥有父类的<strong>所有属性和方法</strong></li>
<li>父类不具备子类<strong>自有</strong>的属性和方法</li>
</ul>
<p>3、继承的用法：</p>
<ul>
<li>定义子类时，将父类传入子类参数内</li>
<li>子类实例化可以调用自己与父类的函数与变量</li>
<li>父类无法调用子类的函数与变量</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, sex</span>):</span><br>        self.name = name<br>        self.sex = sex<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is talking&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_sex</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.sex == <span class="hljs-string">&#x27;boy&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is a boy&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is a girl&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildOne</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play_football</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is playing football&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildTwo</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play_pingpong</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span> is playing pingpong&#x27;</span><br><br>c_one = ChildOne(name=<span class="hljs-string">&#x27;小张&#x27;</span>, sex=<span class="hljs-string">&#x27;girl&#x27;</span>)<br>result = c_one.play_football()<br>print(result)<br>result = c_one.talk()<br>print(result)<br><br>c_two = ChildTwo(name=<span class="hljs-string">&#x27;小红&#x27;</span>, sex=<span class="hljs-string">&#x27;girl&#x27;</span>)<br>result = c_two.play_pingpong()<br>print(result)<br>result = c_two.talk()<br>print(result)<br><br>p = Parent(name=<span class="hljs-string">&#x27;父亲&#x27;</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>result = p.talk()<br>print(result)<br>result = p.is_sex()<br>print(result)<br>result = p.playing()  <span class="hljs-comment"># AttributeError: &#x27;Parent&#x27; object has no attribute &#x27;playing&#x27;</span><br><br></code></pre></td></tr></table></figure>
<p>4、<strong><code>super</code> 函数</strong>的作用 (<strong>单继承</strong>)</p>
<p><code>super</code> ：是python子类继承父类的方法而使用的关键字，当子类继承父类后，就可以使用父类的方法。</p>
<blockquote>
<p>注：一般适用于<strong>单继承</strong>。</p>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, p</span>):</span><br>        print(<span class="hljs-string">&#x27;hello i am parent %s&#x27;</span> % p)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, c, p</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(p)<br>        print(<span class="hljs-string">&#x27;hello i am child %s&#x27;</span> % c)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    c = Child(c=<span class="hljs-string">&#x27;小张&#x27;</span>, p=<span class="hljs-string">&#x27;老张&#x27;</span>)<br>    <br>----------------------------------------------------<br>hello i am parent 老张<br>hello i am child 小张<br></code></pre></td></tr></table></figure>
<h3 id="举个栗子----编程练习-1">举个栗子----编程练习：</h3>
<p>自定义两个类Person和Student，且Student继承自Person。Person类主要描述人的姓名和性别两大基本特征。Student类除了保持父类的基本属性之外还具有分数、主修两个公有属以及一个私有属性（学号）。请根据上述的基本说明，对stu和stu_2两个对象的信息进行综 合展示。</p>
<p>任务 1、自定义Person类，并重写其构造（初始化）方法<code>__init__( )</code>，将name和gender参数赋值给实例对象的属性 2、自定义实例方法<code>speak( )</code>，功能：打印“hello ! 我是xxx”。<code>relaton( )</code>方法主要是占位作用，无其他实质性功能 3、自定义Student类，继承自Person类，并重写其构造（初始化）方法<code>__init__( )</code>，name、gender参数通过调用父类的构造函数进行赋值，score和major通过子类重写的<code>__init__( )</code>进行赋值。 4、自定义实例方法<code>speak( )</code>，功能：打印 '我的学号为xxxxxxxxxx，很高兴认识大家'; 5、自定义实例方法<code>identify_stu( )</code>，功能：判断Student对象的学号。若学号为2018014002，则打印‘我的分组已经完成’，反之则打印‘请稍后，马上为你自动分组’； 6、自定义实例方法<code>set_num( new_num)</code>，功能：将学号重写设置为new_num； 7、自定义实例方法<code>relation( )</code>，功能：判断Student是否为Person的子类。若成立，则打印‘我的父类是Person’，反之则打印‘父类在查询中······’ 8、初始化实例对象stu和stu_2，并根据上述效果图调用对应方法</p>
<p>任务提示 Person类中的实例方法<code>relation( )</code>为占位功能时，其方法体可用pass语句代替</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 重写实例对象的构造（初始化）方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, gender</span>):</span><br>        self.name = name<br>        self.gender = gender<br><br>    <span class="hljs-comment"># 自定义实例方法，格式化打印实例属性name的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;hello! 我是 %s 。&quot;</span> % self.name)<br><br>    <span class="hljs-comment"># 自定义实例方法，占位作用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relation</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">Person</span>):</span><br>    <span class="hljs-comment"># 重写实例对象的构造（初始化）方法，并调用父类构造方法，实现对实例属性的赋值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, gender, score, major, __stu_num = <span class="hljs-string">&#x27;2018014002&#x27;</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__( name, gender)<br>        self.score = score<br>        self.major = major<br>        self.__stu_num = __stu_num<br><br>    <span class="hljs-comment"># 自定义实例方法，格式化打印实例属性stu_num的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;我的学号为 %s，很高兴认识大家&#x27;</span> % self.__stu_num)<br><br>    <span class="hljs-comment"># 自定义实例方法，判断学号是否为既定值，并根据判断结构 进行分类打印</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identify_stu</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.__stu_num == <span class="hljs-string">&#x27;2018014002&#x27;</span>:<br>            print(<span class="hljs-string">&quot;我的分组已经完成&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;请稍后，马上为你自动分组&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义实例方法，设置实例对象的学号为传入的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_num</span>(<span class="hljs-params">self, new_num</span>):</span><br>        self.__stu_num = new_num<br><br>    <span class="hljs-comment"># 自定义实例方法，判断该类是否为Person类的子类，并进行分类打印</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relation</span>(<span class="hljs-params">self, cls_son, cls_fa</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">issubclass</span>(cls_son, cls_fa):<br>            print(<span class="hljs-string">&quot;我的父类是Person&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;父类正在查询中....&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    stu = Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;数学&#x27;</span>)<br>    <span class="hljs-comment"># 调用speak方法 打印stu对应的值</span><br>    stu.speak()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别学号是否为指定值</span><br>    stu.identify_stu()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别实例对象所属的类的父类是否为Person</span><br>    stu.relation(Student, Person)<br><br>    print(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">12</span>)<br><br>    stu_2 = Student(<span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>)<br>    <span class="hljs-comment"># 调用实例方法 设置stu_2的学号为&#x27;2018040625&#x27;</span><br>    stu_2.set_num(<span class="hljs-string">&#x27;2018040625&#x27;</span>)<br><br>    <span class="hljs-comment"># 调用实例方法 打印stu_2对应的值</span><br>    stu_2.speak()<br><br>    <span class="hljs-comment"># 调用实例方法 鉴别学号是否为指定值</span><br>    stu_2.identify_stu()<br><br>---------------------------------------------------------<br>我的学号为 <span class="hljs-number">2018014002</span>，很高兴认识大家<br>我的分组已经完成<br>我的父类是Person<br>------------------------------------<br>我的学号为 <span class="hljs-number">2018040625</span>，很高兴认识大家<br>请稍后，马上为你自动分组<br><br></code></pre></td></tr></table></figure>
<h2 id="类的多态">4.7 类的多态</h2>
<p>1、什么是多态？</p>
<p>多态是指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承）</p>
<blockquote>
<p>注：多态和多态性不是同一概念。</p>
<p>什么是多态性？</p>
<ul>
<li><p>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。<strong>子类继承父类；子类重写父类方法</strong></p></li>
<li><p>多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的爸爸说了一句话&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brother</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的哥哥在奔跑...&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明的哥哥在说话...&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;小明也说话&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    b = Brother()<br>    b.run()<br>    b.talk()<br><br>    p = Parent()<br>    p.talk()<br><br>    c = Child()<br>    c.talk()<br>    <br>----------------------------------------------------<br>小明的哥哥在奔跑...<br>小明的哥哥在说话...<br>小明的爸爸说了一句话<br>小明也说话<br></code></pre></td></tr></table></figure>
<p>2、为什么要使用多态？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">metaclass=abc.ABCMeta</span>):</span> <span class="hljs-comment">#同一类事物:动物</span><br><span class="hljs-meta">    @abc.abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之一:猫</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say miaomiao&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之二:狗</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say wangwang&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span>(<span class="hljs-params">Animal</span>):</span> <span class="hljs-comment">#动物的形态之三:猪</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">talk</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;say aoao&#x27;</span>)<br><br>c = Cat()<br>d = Dog()<br>p = Pig()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">obj</span>):</span><br>    obj.talk()<br><br>func(c)<br>func(d)<br>func(p)<br><br>------------------------------<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>say miaomiao<br><span class="hljs-meta">&gt;&gt;&gt; </span>say wangwang<br><span class="hljs-meta">&gt;&gt;&gt; </span>say aoao<br></code></pre></td></tr></table></figure>
<p>仅仅是用了一个 <code>func(obj)</code> 函数，不同的对象就实现了不同的功能。综上可以说，多态性是 : <strong>一个接口，多种实现</strong></p>
<p><strong>多态性的好处:</strong></p>
<ul>
<li>增加了程序的<strong>灵活性</strong>，以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如 <code>func(obj)</code></li>
<li>增加了程序额<strong>可扩展性</strong>，通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用 <code>func(obj)</code> 去调用</li>
</ul>
<h2 id="类的多重继承">4.8 类的多重继承</h2>
<p>1、什么是多重继承？</p>
<p>我理解为一个子类可以继承多个父类。</p>
<p>2、多重继承的方法？</p>
<p><code>class Child(Parent1, Parent 2, Parent 3...)</code>，从左往右依次继承</p>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tool</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;tool work&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;car will run&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;food work&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cake</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;i like cake&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">Tool, Food</span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Person()<br>    print(p.car(), <span class="hljs-string">&#x27; &#x27;</span>, p.cake())<br>    print(p.work())  <span class="hljs-comment"># 继承的第一个类</span><br>    print(Person.__mro__)  <span class="hljs-comment"># 得到类的继承顺序</span><br><br>------------------------------<br>car will run   i like cake<br>tool work<br>(&lt;class &#x27;__main__.Person&#x27;&gt;, &lt;class &#x27;__main__.Tool&#x27;&gt;, &lt;class &#x27;__main__.Food&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：继承关系可以延续。例，孙子继承父亲，父亲继承爷爷，则孙子也继承爷爷。</p>
</blockquote>
<h3 id="举个栗子----编程练习-2">举个栗子----编程练习：</h3>
<p>圆形、长方形除了是几何学科中的基本图形之外，也还是我们日常生活中最常见的平面图形。请根据面向对象的相关知识，将上述两种平面图形用Python语言进行表示，使得我们的程序可以正常对其使用。</p>
<p>任务 1、自定义Point类，并重写其构造（初始化）方法 <code>__init__( )</code>，将参数x和y赋值给实例对象的属性 2、自定义该类实例方法<code>string( )</code>，功能：打印“{X：xx, Y：xx}” 3、自定义Circle类，继承自Point类，并重写其构造（初始化）方法<code>__init__( )</code>，x、y参数通过调用父类的构造函数进行赋值，radius通过子类重写的<code>__init__( )</code>进行赋值。 4、自定义该类实例方法<code>string( )</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; {半径为：xx}” 5、自定义Size类，并重写其构造（初始化）方法<code>__init__( )</code>，将参数width和height赋值给实例对象的属性 6、自定义该类实例方法<code>string( )</code>，功能：打印“{Width：xx, Height：xx}” 7、自定义Rectangle类，继承自Point类和Size类，并重写其构造（初始化）方法<code>__init__( )</code>，x、y、width、height 4个参数全部通过调用父类的构造函数进行赋值 8、自定义该类实例方法<code>string( )</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; 长宽分别为：{Width：xx, Height：xx} 9、初始化Circle类的对象c，并调用其格式化输出函数<code>string( )</code> 10、初始化Rectangle类的对象r1、r2,并分别调用其格式化输出函数<code>string( )</code></p>
<p>任务提示 1、在自定义Rectangle类的构造方法时，调用父类方法必须按照<code>类名.__init__(参数列表)</code>的方式进行调用，如<code>Point.__init__(self, x, y)</code> 2、自定义Rectangle类格式化输出方法时，调用父类的格式化输出函数<code>string()</code>时，应按照<code>类名.string(参数)</code>的方式进行调用，如<code>Point.string(self)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    x = <span class="hljs-number">1.0</span><br>    y = <span class="hljs-number">1.0</span><br><br>    <span class="hljs-comment"># 自定义Point类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y</span>):</span><br>        self.x = x<br>        self.y = y<br>        print(<span class="hljs-string">&quot;Point 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Point类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;X: %s, Y: %s&#125;&quot;</span>  % (self.x, self.y))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">Point</span>):</span><br>    <span class="hljs-comment"># 自定义Circle类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, radius</span>):</span><br>        Point.__init__(self, x, y)<br>        self.radius = radius<br>        print(<span class="hljs-string">&quot;Circle 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Circle类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;该图形初始化点为: &#123;X: &quot;</span> + <span class="hljs-built_in">str</span>(self.x) + <span class="hljs-string">&quot;, Y: &quot;</span> + <span class="hljs-built_in">str</span>(self.y) \<br>               + <span class="hljs-string">&quot;&#125;, &#123;半径为: &quot;</span> + <span class="hljs-built_in">str</span>(self.radius) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># 自定义Size类的构造(初始化)方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br>        print(<span class="hljs-string">&quot;Size 构造函数被调用...&quot;</span>)<br><br>    <span class="hljs-comment"># 自定义Size类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;&#123;Height: &quot;</span> + <span class="hljs-built_in">str</span>(self.width) + <span class="hljs-string">&quot;, Width: &quot;</span> + <span class="hljs-built_in">str</span>(self.height) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params">Point, Size</span>):</span><br>    <span class="hljs-comment"># 自定义Rectangle类的构造(初始化)方法，并在方法中调用父类的初始化方法以完成初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, width, height</span>):</span><br>        Point.__init__(self, x, y)<br>        Size.__init__(self, width, height)<br><br>    <span class="hljs-comment"># 自定义Rectangle类对象的格式化输出函数(string())</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">string</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;该图形初始化点为: &#123;X: &quot;</span> + <span class="hljs-built_in">str</span>(self.x) + <span class="hljs-string">&quot;, Y: &quot;</span> + <span class="hljs-built_in">str</span>(self.y) + <span class="hljs-string">&quot;&#125;&quot;</span> + \<br>              <span class="hljs-string">&quot;, 长宽分别为: &#123;Height: &quot;</span> + <span class="hljs-built_in">str</span>(self.width) + <span class="hljs-string">&quot;, Width: &quot;</span> + <span class="hljs-built_in">str</span>(self.height) + <span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 实例化Point对象，点位置为（3, 3）</span><br>    p = Point(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>    p.string()<br><br>    <span class="hljs-comment"># 实例化Circle对象，圆心为（5,5），半径为8</span><br>    c = Circle(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br>    c.string()<br><br>    <span class="hljs-comment"># 实例化Rectangle对象，顶点位置（15,30），长和宽分别为20和10</span><br>    r = Rectangle(<span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)<br>    r.string()<br><br>------------------------------------------------------------------------------------------------------<br>Point 构造函数被调用...<br>&#123;X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">3</span>&#125;<br><br>Point 构造函数被调用...<br>Circle 构造函数被调用...<br>该图形初始化点为: &#123;X: <span class="hljs-number">5</span>, Y: <span class="hljs-number">5</span>&#125;, &#123;半径为: <span class="hljs-number">8</span>&#125;<br><br>Point 构造函数被调用...<br>Size 构造函数被调用...<br>该图形初始化点为: &#123;X: <span class="hljs-number">15</span>, Y: <span class="hljs-number">30</span>&#125;, 长宽分别为: &#123;Height: <span class="hljs-number">20</span>, Width: <span class="hljs-number">10</span>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>该案例如果用super()调用拥有同名方法的父类，就只会调用最靠前的拥有同名方法的类，后面的类中同名方法也就无法被调用。</strong></p>
<p><strong>因此本案例多继承中进行父类调用时采用“<code>类名.__init__</code>”的形式。</strong></p>
</blockquote>
<h2 id="类的高级函数">4.9 类的高级函数</h2>
<ul>
<li><code>__str__</code> 函数</li>
<li><code>__gtrattr()__</code> 函数</li>
<li><code>__setattr__</code> 函数</li>
<li><code>__call__</code> 函数</li>
</ul>
<h3 id="str__-函数">4.9.1 <code>__str__</code> 函数</h3>
<p>如果定义了该函数，当print当前实例化对象时候，会返回该函数的 return信息。</p>
<ul>
<li>通常会返回一个字符串作为类的描述信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 一般会定义一些类的描述信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;this is a test class&#x27;</span><br><br>t = Test()<br>print(t)<br></code></pre></td></tr></table></figure>
<h3 id="gtrattr__-函数">4.9.2 <code>__gtrattr__</code> 函数</h3>
<p>当调用的属性或者方法不存在时，会返回该方法定义的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这个key: &#123;&#125; 并不存在&#x27;</span>.<span class="hljs-built_in">format</span>(key)<br><br><span class="hljs-comment"># print(t.a)  # AttributeError: &#x27;Test&#x27; object has no attribute &#x27;a&#x27;</span><br>print(t.a )  <span class="hljs-comment"># &gt;&gt;&gt; 这个key: a 并不存在</span><br></code></pre></td></tr></table></figure>
<h3 id="setattr__.-函数">4.9.3 <code>__setattr__.</code> 函数</h3>
<p>拦截当前类中不存在的属性与值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span>(<span class="hljs-params">self, key, value</span>):</span><br>        <span class="hljs-comment"># print(key, value)</span><br>        self.__dict__[key] = value<br>        print(self.__dict__)<br><br>t = Test()<br>t.name = <span class="hljs-string">&#x27;小明&#x27;</span><br>print(t.name)<br><br>-----------------------------------------------<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小明&#x27;</span>&#125;<br>小明<br></code></pre></td></tr></table></figure>
<h3 id="call__-函数">4.9.4 <code>__call__</code> 函数</h3>
<p>本质是将一个类变成一个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, a</span>):</span><br>        print(<span class="hljs-string">&#x27;call func will start&#x27;</span>)<br>        print(a)<br><br>t = Test()<br>t(<span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br>-----------------------------------------------<br>call func will start<br>xiaoming<br></code></pre></td></tr></table></figure>
<h1 id="异常">5. 异常</h1>
<ul>
<li>异常就是错误</li>
<li><p>异常会导致程序崩溃并停止运行</p></li>
<li><p>python中的异常机制能监控并捕获异常，将异常部位的程序进行修理使得程序继续正常运行</p></li>
</ul>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    &lt;代码块<span class="hljs-number">1</span>&gt; 被<span class="hljs-keyword">try</span>关键字检查并保护的业务代码<br><span class="hljs-keyword">except</span> &lt;异常的类型&gt;:<br>    &lt;代码块<span class="hljs-number">2</span>&gt; <span class="hljs-comment"># 代码块1出现错误后执行的代码块</span><br></code></pre></td></tr></table></figure>
<p>1、捕获通用异常</p>
<ul>
<li>无法确定是在哪种异常情况下使用的捕获方法</li>
</ul>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    &lt;代码块&gt; <br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    &lt;异常代码块&gt; <br></code></pre></td></tr></table></figure>
<p>2、捕获具体异常</p>
<ul>
<li><p>确定是哪种异常的情况下使用的捕获方法</p></li>
<li><p><code>exceppt &lt;具体的异常类型&gt; as e</code></p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">UPPER</span>(<span class="hljs-params">str_data</span>):</span><br>    new_str = <span class="hljs-string">&#x27;None&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        new_str = str_data.upper()<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e :<br>        print(<span class="hljs-string">&#x27;程序出错了:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(e))<br>    <span class="hljs-keyword">return</span> new_str<br><br>result = UPPER(<span class="hljs-string">&#x27;xiaohong&#x27;</span>)<br>result1 = UPPER(<span class="hljs-number">1</span>)<br>print(<span class="hljs-string">&#x27;result1 is&#x27;</span>, result1)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>        print(<span class="hljs-string">&#x27;hello&#x27;</span>)  <span class="hljs-comment"># 遇到错误立刻进入except，所以错误后的代码全都不会执行</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><br>test()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        print(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>        print(name)  <span class="hljs-comment"># except 里没有对应的异常类型，所以报错了</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><br>test1()<br></code></pre></td></tr></table></figure>
<p>3、捕获多个异常</p>
<ol type="1">
<li>可以有多个except并列。但当第一个异常捕获到之后，不会再继续往下捕获。</li>
<li>写一个 <code>except (异常类型1, 异常类型2) as e</code> 。当except代码后边的异常类型使用<strong>元组</strong>包裹起来，捕获到哪种就抛哪种</li>
</ol>
<h2 id="常用异常类型">5.1 常用异常类型</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">异常名称</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Exception</td>
<td style="text-align: left;">通用异常类型（基类）</td>
</tr>
<tr class="even">
<td style="text-align: left;">ZeroDivisionError</td>
<td style="text-align: left;">不能整除0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">AttributeError</td>
<td style="text-align: left;">对象没有这个属性</td>
</tr>
<tr class="even">
<td style="text-align: left;">IOError</td>
<td style="text-align: left;">输入输出操作失败</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IndexError</td>
<td style="text-align: left;">没有当前的索引</td>
</tr>
<tr class="even">
<td style="text-align: left;">KeyError</td>
<td style="text-align: left;">没有这个键值（key）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NameError</td>
<td style="text-align: left;">没有这个变量（未初始化对象）</td>
</tr>
<tr class="even">
<td style="text-align: left;">SyntaxError</td>
<td style="text-align: left;">Python语法错误</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SystemError</td>
<td style="text-align: left;">解释器的系统错误</td>
</tr>
<tr class="even">
<td style="text-align: left;">ValueError</td>
<td style="text-align: left;">传入的参数错误</td>
</tr>
</tbody>
</table>
<p>举个栗子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br>t = Test()<br><span class="hljs-keyword">try</span>:<br>    t.name<br><span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># &#x27;Test&#x27; object has no attribute &#x27;name&#x27;</span><br><br>d = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小明&#x27;</span>&#125;<br><span class="hljs-keyword">try</span>:<br>    d[<span class="hljs-string">&#x27;age&#x27;</span>]<br><span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>    print(<span class="hljs-string">&#x27;没有对应的键: &#x27;</span>, e)  <span class="hljs-comment"># 没有对应的键:  &#x27;age&#x27;</span><br><br>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">try</span>:<br>    l[<span class="hljs-number">5</span>]<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># list index out of range</span><br><br>name = <span class="hljs-string">&#x27;ssss&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(name)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># invalid literal for int() with base 10: &#x27;ssss&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-keyword">return</span> a<br><span class="hljs-keyword">try</span>:<br>    test()<br><span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> e:<br>    print(e)  <span class="hljs-comment"># test() missing 1 required positional argument: &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="异常中的finally">5.2 异常中的finally</h2>
<ul>
<li>无论是否发生异常，只要定义了 <code>finally</code>，就一定会执行其中的代码块。</li>
<li>在函数中，即便在 <code>try</code> 或 <code>except</code> 中进行了 return 也依然会执行 <code>finally</code> 语法块</li>
<li><code>try</code> 语法至少要伴随 <code>except</code> 或 <code>finally</code> 中的一个来使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(e)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;finally&#x27;</span><br>t = test1()<br>print(t)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&#x27;1&#x27;</span>)<br>        <span class="hljs-keyword">return</span> e<br>    <span class="hljs-keyword">finally</span>:<br>        print(<span class="hljs-string">&#x27;2&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;finally&#x27;</span>  <span class="hljs-comment"># 即使在try和except中进行return，也依然会执行finally</span><br>    <br>--------------------------------------------------<br>division by zero<br><span class="hljs-keyword">finally</span><br><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span><br></code></pre></td></tr></table></figure>
<h2 id="自定义异常类型与抛出异常">5.3 自定义异常类型与抛出异常</h2>
<h3 id="自定义抛出异常-raise">5.3.1 自定义抛出异常 <code>raise</code></h3>
<p>将信息以报错的形式抛出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220330141932.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">if</span> number == <span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;number不可以是100&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> number<br><br>print(test(<span class="hljs-number">50</span>))<br>t = test(<span class="hljs-number">100</span>)  <span class="hljs-comment"># ValueError: number不可以是100</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> test(number)<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> e<br>    <br>t2 = test2(<span class="hljs-number">100</span>)<br>print(t2)<br><br>--------------------------------------------------<br><span class="hljs-number">50</span><br>number不可以是<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>
<h3 id="自定义异常类">5.3.2 自定义异常类</h3>
<ul>
<li><strong>定义一个基类</strong>，然后继承基类----<code>Exception</code></li>
<li><strong>在构造函数中定义错误信息</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberLimitError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameLimitError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&#x27;小明&#x27;</span>:<br>        <span class="hljs-keyword">raise</span> NameLimitError(<span class="hljs-string">&#x27;小明不可以被填写&#x27;</span>)<br>    <span class="hljs-keyword">return</span> name<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test0</span>(<span class="hljs-params">number</span>):</span><br>    <span class="hljs-keyword">if</span> number &gt; <span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">raise</span> NumberLimitError(<span class="hljs-string">&#x27;数字不可以大于100&#x27;</span>)<br>    <span class="hljs-keyword">return</span> number<br><br><br><span class="hljs-keyword">try</span>:<br>    test(<span class="hljs-string">&#x27;小明&#x27;</span>)<br><span class="hljs-keyword">except</span> NameLimitError <span class="hljs-keyword">as</span> e:<br>    print(e)<br><br><span class="hljs-keyword">try</span>:<br>    test0(<span class="hljs-number">101</span>)<br><span class="hljs-keyword">except</span> NumberLimitError <span class="hljs-keyword">as</span> e:<br>    print(e)<br> <br>--------------------------------------------------<br>小明不可以被填写<br>数字不可以大于<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>
<h2 id="断言">5.4 断言</h2>
<p>断言：用于判断一个表达式，在表达式条件为false的时候触发异常(为true不会触发异常，继续执行)。</p>
<p><code>assert expression, message</code></p>
<ul>
<li><code>expression</code> ：表达式，一般是判断相等，或者判断是某种数据类型的 <code>bool</code> 判断的语句</li>
<li><code>message</code> ：具体的错误信息</li>
<li>无返回值</li>
</ul>
<h3 id="使用断言对综合案例进行改进">使用断言对综合案例进行改进</h3>
<p>很好的案例。一定要吃透！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    学生信息库</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>students = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小鱼&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">33</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小何&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;,<br>    <span class="hljs-number">5</span>: &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小安&#x27;</span>,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 缺少参数的错误，定义一个基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotArgError</span>(<span class="hljs-params">Exception</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, message</span>):</span><br>        self.message = message<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentInfo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, students</span>):</span><br>        self.students = students<br><br>    <span class="hljs-comment"># 查找，通过学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_id</span>(<span class="hljs-params">self, student_id</span>):</span><br>        <span class="hljs-keyword">return</span> self.students.get(student_id)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_students</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># get_all_students</span><br>        <span class="hljs-keyword">for</span> id_, value <span class="hljs-keyword">in</span> self.students.items():<br>            print(<span class="hljs-string">&#x27;学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                id_, value[<span class="hljs-string">&#x27;name&#x27;</span>], value[<span class="hljs-string">&#x27;age&#x27;</span>], value[<span class="hljs-string">&#x27;sex&#x27;</span>], value[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br>            ))<br>        <span class="hljs-keyword">return</span> self.students<br><br>    <span class="hljs-comment"># 添加单个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, **student</span>):</span>  <span class="hljs-comment"># add_student</span><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.__add(**student)<br><br>    <span class="hljs-comment"># 添加多个</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adds</span>(<span class="hljs-params">self, new_students</span>):</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> new_students:<br>            <span class="hljs-keyword">try</span>:<br>                self.check_user_info(**student)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                print(e, student.get(<span class="hljs-string">&#x27;name&#x27;</span>))<br>                <span class="hljs-keyword">continue</span><br>            self.__add(**student)<br><br>    <span class="hljs-comment"># 添加新的学号；并将新的学生入库</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add</span>(<span class="hljs-params">self, **student</span>):</span><br>        new_id = <span class="hljs-built_in">max</span>(self.students) + <span class="hljs-number">1</span><br>        self.students[new_id] = student<br><br>    <span class="hljs-comment"># 删除</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, student_id</span>):</span>  <span class="hljs-comment"># delete_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;号的同学的信息不存在&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br>        <span class="hljs-keyword">else</span>:<br>            user_info = self.students.pop(student_id)<br>            print(<span class="hljs-string">&#x27;学号是&#123;&#125;的&#123;&#125;同学的信息已经被删除了&#x27;</span>.<span class="hljs-built_in">format</span>(student_id, user_info[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>    <span class="hljs-comment"># 批量删除，删除学号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deletes</span>(<span class="hljs-params">self, ids</span>):</span><br>        <span class="hljs-keyword">for</span> id_ <span class="hljs-keyword">in</span> ids:  <span class="hljs-comment"># id_防止和函数id()冲突</span><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;id_&#125;</span> 不存在学生库中&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br>            student_info = students.pop(id_)<br>            print(<span class="hljs-string">f&#x27;学号<span class="hljs-subst">&#123;id_&#125;</span> 学生<span class="hljs-subst">&#123;student_info[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span> 已被移除&#x27;</span>)<br><br><br>    <span class="hljs-comment"># 修改</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, student_id, **kwargs</span>):</span>  <span class="hljs-comment"># update_student</span><br>        <span class="hljs-keyword">if</span> student_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>            print(<span class="hljs-string">&#x27;不存在学号：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(student_id))<br><br>        <span class="hljs-keyword">try</span>:<br>            self.check_user_info(**kwargs)  <span class="hljs-comment"># todo: 添加异常捕获</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br>        self.students[student_id] = kwargs<br>        print(<span class="hljs-string">&#x27;&#123;&#125;同学信息更新完毕&#x27;</span>.<span class="hljs-built_in">format</span>(kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>    <span class="hljs-comment"># 批量更新，key是学号，value是信息  # todo:添加异常捕获 17&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updates</span>(<span class="hljs-params">self, update_students</span>):</span>  <span class="hljs-comment"># update_students是一个列表</span><br>        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> update_students:<br>            <span class="hljs-keyword">try</span>:<br>                id_ = <span class="hljs-built_in">list</span>(student.keys())[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 不加list()是假列表  # todo：添加异常捕获  # list可能没有0索引</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续循环列表</span><br><br>            <span class="hljs-keyword">if</span> id_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.students:<br>                print(<span class="hljs-string">f&#x27;学号 <span class="hljs-subst">&#123;id_&#125;</span> 不存在&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br><br>            user_info = student[id_]<br>            <span class="hljs-keyword">try</span>:<br>                check = self.check_user_info(**user_info)  <span class="hljs-comment"># todo：添加异常捕获</span><br>            <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>                print(e)<br>                <span class="hljs-keyword">continue</span><br>            self.students[id_] = user_info<br>        print(<span class="hljs-string">&#x27;所有信息更新完成&#x27;</span>)<br><br>    <span class="hljs-comment"># 查询</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_users</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;参数数量传递错误&#x27;</span>  <span class="hljs-comment"># 参数不能为空，长度必须是1</span><br><br>        values = <span class="hljs-built_in">list</span>(self.students.values())<br>        key = <span class="hljs-literal">None</span><br>        value = <span class="hljs-literal">None</span><br>        result = []<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;name&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;age&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;sex&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">in</span> kwargs:<br>            key = <span class="hljs-string">&#x27;class_number&#x27;</span><br>            value = kwargs[key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;没有发现搜索的关键字&#x27;</span>)<br><br>        <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> values:  <span class="hljs-comment"># 吐过想用年龄字段模糊查询，需要把年龄改成str类型</span><br>            <span class="hljs-comment"># print(user[key])</span><br>            <span class="hljs-comment"># print(value)</span><br>            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">in</span> user[key]:  <span class="hljs-comment"># in 替代 = 实现模糊查找</span><br>                result.append(user)<br><br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-comment"># 验证参数是否合法，检查位置参数的判断</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_user_info</span>(<span class="hljs-params">self, **kwargs</span>):</span><br>        <span class="hljs-comment"># 判断长度是否为4；判断是否我们要的四个参数；判断参数类型是否正确</span><br>        <span class="hljs-comment"># 判断长度是否为4</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(kwargs) == <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;参数必须是4个&#x27;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生姓名参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生年龄参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生性别参数&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;class_number&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kwargs:<br>            <span class="hljs-keyword">raise</span> NotArgError(<span class="hljs-string">&#x27;缺少学生班级参数&#x27;</span>)<br><br>        <span class="hljs-comment"># 确认四个参数是不是想要的数据类型</span><br>        <span class="hljs-comment"># 先取出数据</span><br>        name_value = kwargs[<span class="hljs-string">&#x27;name&#x27;</span>]<br>        age_value = kwargs[<span class="hljs-string">&#x27;age&#x27;</span>]<br>        sex_value = kwargs[<span class="hljs-string">&#x27;sex&#x27;</span>]<br>        class_number_value = kwargs[<span class="hljs-string">&#x27;class_number&#x27;</span>]<br><br>        <span class="hljs-comment"># isinstance(对比的数据, 数据类型) isinstance(1, str)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(name_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;name 应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age_value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;age应该是整型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(sex_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;sex应该是字符串类型&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(class_number_value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;class_number应该是字符串类型&#x27;</span>)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    student_info = StudentInfo(students)<br>    user = student_info.get_user_by_id(<span class="hljs-number">1</span>)<br>    student_info.add(name=<span class="hljs-string">&#x27;小绿&#x27;</span>, age=<span class="hljs-number">34</span>, class_number=<span class="hljs-string">&#x27;A&#x27;</span>, sex=<span class="hljs-string">&#x27;boy&#x27;</span>)<br>    print(student_info.students)<br><br>    users = [<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小橙&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小黄&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;class_number&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span> : <span class="hljs-string">&#x27;boy&#x27;</span>&#125;,<br>    ]<br>    student_info.adds(users)<br>    student_info.get_all_students()<br><br>    student_info.deletes([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>])<br>    student_info.get_all_students()<br><br>    student_info.updates([<br>        &#123;<span class="hljs-number">2</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;何同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;boy&#x27;</span>&#125;&#125;,<br>        &#123;<span class="hljs-number">4</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小张同学&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;class_number&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;girl&#x27;</span>&#125;&#125;<br>    ])<br>    student_info.get_all_students()<br><br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;小&#x27;</span>)<br>    print(result)<br>    result = student_info.search_users(name=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 会把所有的都打印出来</span><br>    print(result)<br><br></code></pre></td></tr></table></figure>
<h1 id="bug">6. bug</h1>
<p>bug 是程序中出现的错误，但有没有通过异常去捕获，以至于直接抛出，导致程序的崩溃。</p>
<p>如何检查 bug？</p>
<ol type="1">
<li><p>调试工具(eg.pycharm) debug。在想要停止的行的左侧点击一下会出现一个小红点，断点。程序运行到这行会停止(包括这一行)。</p></li>
<li><p>多打印信息。(多print可以聚焦错误点，简单)</p></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2022/03/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="归并排序">归并排序</h1>
<p>归并排序思路：</p>
<ol start="0" type="1">
<li><strong>注意递归要退出！记得写退出条件！</strong></li>
<li>确定分界点：<code>int mid = l + r &gt;&gt; 1 ;</code> (下标的中心值)</li>
<li>递归排序 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code></li>
<li>归并：将左右两个有序序列 合并成一个有序序列</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331113606.png" style="zoom: 60%;" /></p>
<p><strong>归并排序和快速排序的区别：</strong></p>
<ol type="1">
<li><p>归并排序的分界点是整个区间的中心位置，下标的中间值</p>
<p>而快排的分界点是从当前这个区间随机一个数组的<strong>值</strong>(一般我们选取数组中间位置的<strong>数</strong>)</p></li>
<li><p>归并的关键是：合二为一</p>
<p>快排的关键是：划分成两段</p></li>
<li><p>归并：稳定</p>
<p>快排：不稳定（可以改为稳定的，按照 &lt;<span class="math inline">\(a_i, i\)</span>&gt; ，变成 pair，双关键字进行排序）</p></li>
</ol>
<blockquote>
<p>稳定是指：原序列中的两个相同的数，排序后，相对位置不发生变化。</p>
</blockquote>
<p><strong>模板code：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_sort(q, l, mid);          <span class="hljs-comment">// 递归排序左右边</span><br>    merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// k是当前tmp数组里有多少数</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br>    &#125;<br><br>    <span class="hljs-comment">// 左半边或右半边可能没有循环完，只要拿过来放入就行</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-comment">// 结果存入tmp里面去了，得拿回来</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331113325.png" /></p>
<h2 id="例题">例题</h2>
<h3 id="acwing-787.-归并排序"><a href="https://www.acwing.com/problem/content/789/">1. AcWing 787. 归并排序</a></h3>
<blockquote>
<p>模板题</p>
</blockquote>
<h3 id="acwing-788.-逆序对的数量"><a href="https://www.acwing.com/problem/content/790/">2. AcWing 788. 逆序对的数量</a></h3>
<h4 id="题目">题目</h4>
<p>给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。</p>
<p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</p>
<p><strong>样例：</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure>
<h4 id="思路">思路</h4>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331141954.png" /></p>
<p>这个题可以使用分治法解决问题：将序列从中间分开，将逆序对分成三类(如上图所示)：</p>
<ol type="1">
<li>两个元素都在左边；</li>
<li>两个元素都在右边；</li>
<li>两个元素一个在左 一个在右</li>
</ol>
<p><strong>我觉得其实递归到最深处，只有第三种情况，前两个就是描述这个递归的过程，只是用来帮助理解，事实上不存在。归并排序的递归过程的边界就是区间只有1个数，所以就是第三种情况。</strong><font color='red'>通过代码验证，确实不需要相加，将 res 定义为全局变量，直接递归左边和右边，不需要将二者加和，也可以ac。</font></p>
<p>可以注意到一个重要的性质，左右半边的元素在各自区间任意调换顺序，是不影响第三步计数的，因为第三步是左右区间各取一个数进行比较。因此我们可以数完就给它排序。这么做的好处在于，如果序列是有序的，会让第三步计数很容易。其实这个双指针还是归并排序中“归并”的过程，只不过在归并时，顺便计算他后面有几个数，即：<code>mid - i + 1</code></p>
<p>如果无序暴力数的话这一步是 <span class="math inline">\(O(n^2)\)</span> 的。</p>
<p><strong>Note</strong></p>
<ol type="1">
<li>注意结果数据范围会爆int，所以 <code>res</code> 和 <code>merge_sort()</code> 要用 <code>long long</code> 数据类型。</li>
</ol>
<p><strong>code</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N], tmp[N];<br>LL res;<br><br><span class="hljs-function">LL <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_sort(q, l, mid);<br>    merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tmp[k ++ ] = q[j ++ ];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>, i = l; i &lt;= r; i ++ , k ++ ) q[i] = tmp[k];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; merge_sort(q, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟链表</title>
    <url>/2022/04/03/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>关于链表的题，一般都是写成结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    Node *next;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>面试用的比较多。每次都需要 new 一个新节点，要调用 new 函数。</p>
<p>算法题中多用数组模拟链表，单链表一般用于存储图和树，双链表用于优化某些题。</p>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><ul>
<li><code>idx</code>：当前节点的下标</li>
<li><code>e[idx]</code>：当前节点的值</li>
<li><code>ne[idx]</code>：下一个节点的位置下标 (节点的next指针)</li>
<li><code>head</code>：头指针（我理解为 <code>ne[头]</code>，头指针指向的下一个节点的下标，初始是指向链表的末尾 <strong>-1</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331104210.png" alt=""></p>
<p>操作命令可能为以下几种：</p>
<ol>
<li><code>H x</code>，表示向链表头插入一个数 x。</li>
<li><code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li>
<li><code>I k x</code>，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li>
</ol>
<p><strong>Note：</strong></p>
<ol>
<li>idx 初始化时从0开始，第1个插入的数下标为0，所以第 k 个插入的数下标为 k - 1</li>
<li>删除头节点可以看成是指向下一个被插入的节点：<code>head = ne[head]</code></li>
</ol>
<p><strong>code:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//往头节点位置插入x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = head;<br>    head = idx;<br>    idx ++ ;<br>&#125;<br><br><span class="hljs-comment">//往idx = k 的位置后插入x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = ne[k];<br>    ne[k] = idx;<br>    idx ++ ;<br>&#125;<br><br><span class="hljs-comment">//删除idx = k 后面的节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m;<br><br>    init();<br><br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> k, x;<br>        <span class="hljs-keyword">char</span> op;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;H&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            add_to_head(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;D&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            <span class="hljs-keyword">if</span> (!k ) head = ne[head];   <span class="hljs-comment">// 删除头节点可以看成是指向下一个被插入的节点</span><br>            <span class="hljs-keyword">else</span> remove(k - <span class="hljs-number">1</span>);         <span class="hljs-comment">// 第 k-1 个输入才是idx</span><br>        &#125;           <br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            insert(k - <span class="hljs-number">1</span>, x);<br>        &#125;<br><br>    &#125;<br>	<span class="hljs-comment">// 从 head 开始，也就是 头的下一个节点开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head; i != <span class="hljs-number">-1</span>; i = ne[i]) <span class="hljs-built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><ul>
<li><code>idx</code>：当前节点的下标</li>
<li><code>e[idx]</code>：当前节点的值</li>
<li><code>r[idx]</code>：当前节点的右边节点的位置下标 (节点的 right 指针)</li>
<li><code>l[idx]</code>：当前节点的左边节点的位置下标 (节点的 left 指针)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220331111811.png" alt=""></p>
<p>作命令可能为以下几种：</p>
<ol>
<li><code>L x</code>，表示在链表的最左端插入数 x。</li>
<li><code>R x</code>，表示在链表的最右端插入数 x。</li>
<li><code>D k</code>，表示将第 k 个插入的数删除。</li>
<li><code>IL k x</code>，表示在第 k 个插入的数左侧插入一个数。</li>
<li><code>IR k x</code>，表示在第 k 个插入的数右侧插入一个数。</li>
</ol>
<p><strong>Note:</strong></p>
<ol>
<li><p>插入 与 删除操作 都是针对 下标为 idx 的节点的右节点。然后对 idx 的左节点的操作都可以写为 <code>l[idx]</code></p>
<blockquote>
<p>例如在下标为 idx 的左边插入一个点相当于在 <code>l[idx]</code>右边插入一个点</p>
</blockquote>
</li>
<li><p>插入操作需要注意顺序：<strong>idx 的 左右指针先与两边节点连上，然后先右节点指向 idx，再 idx 指向左节点</strong>。</p>
</li>
</ol>
<p><strong>code:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> idx, e[N], l[N], r[N];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 0和1已经用过了</span><br>&#125;<br><br><span class="hljs-comment">// 在下标是k的点的右边，插入一个点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    r[idx] = r[k];<br>    l[idx] = k;<br>    l[r[k]] = idx;<br>    r[k] = idx;<br>    idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除第k个店</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br><br>    init();<br><br>    <span class="hljs-keyword">while</span>(n -- )<br>    &#123;<br>        <span class="hljs-built_in">string</span> op;<br>        <span class="hljs-keyword">int</span> x, k;<br><br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;L&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            add(<span class="hljs-number">0</span>, x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;R&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            add(l[<span class="hljs-number">1</span>], x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;D&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            remove(k + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;IL&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            add(l[k + <span class="hljs-number">1</span>], x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            add(k + <span class="hljs-number">1</span>, x);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 从 0 的下一个位置的元素开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">1</span>;i = r[i]) <span class="hljs-built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2022/03/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="二分查找">二分查找</h1>
<h2 id="思路">思路</h2>
<p><strong>二分关键词：“最大值最小”，“最小值最大”，“平均值最大/最小”</strong></p>
<p>一个题目，如果一个区间具有单调性质，那么一定可以二分，但是如果说这道题目没有单调性质，而是具有某种区间性质的话，我们同样可以使用二分.<strong>（不用单调性，有二段性：满足一段而不满足另一段，两段连上！）</strong></p>
<p>每次都要选择答案所在区间进行下一步处理：</p>
<ol type="1">
<li>确定一个区间，使得目标一定在区间中。</li>
<li>找一个性质，满足：
<ol type="1">
<li>性质具有二段性（答案是性质的边界）所有二分都成立</li>
<li><strong>答案是二段性的分界点</strong></li>
</ol></li>
</ol>
<p>Note：一定要好好分析 <code>check()</code> 函数</p>
<h2 id="整数二分">整数二分</h2>
<h3 id="整数二分思路">整数二分思路</h3>
<p>在一个范围内，查找一个数字，要求找到这个元素的起始位置和结束位置，请注意这个范围内的数字都是单调递增的，即具有单调性质.</p>
<h3 id="模板code">模板code</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l; <br>&#125;<br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 一定要加1</span><br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="例题">例题</h3>
<h4 id="acwing-789.-数的范围"><a href="https://www.acwing.com/problem/content/description/791/">1. Acwing 789. 数的范围</a></h4>
<blockquote>
<p>模板题</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>需要写两个二分，一个需要找到 &gt;=x 的第一个数，另一个需要找到 &lt;=x 的最后一个数</p>
<p>1、<strong>查找大于等于x的第一个位置</strong></p>
<p>就是看 mid 是否满足右区间</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220401141638.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br>	<span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br>	<span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2、<strong>查找小于等于x的第一个位置（查找大于等于x的最后一个位置）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220401141701.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br>	<span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 一定要加1！</span><br>	<span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br>	<span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>为什么这里一定要 <strong>加 1</strong> 呢？</li>
</ul>
<p>答：因为如果按照上一个二分的写法，循环判断条件还是l &lt; r，当只有两个元素比如“2 2”时，l指向第一个元素，r指向第二个元素，mid指向第一个元素即 mid = l，q[mid] &lt;= x，l = mid还是指向第一个元素，指针不移动了，陷入死循环了，此刻 l + 1 == r，未能退出循环。</p>
<ul>
<li>为什么查找大于等于x的第一个位置不会死循环？</li>
</ul>
<p>因为这时就算只有两个元素，l + 1 = r，mid = l，q[mid] &lt; x 时 l 是会+1的，不小于 x 时r = mid也会缩小区间。而查找小于等于x的第一个位置之所以会死循环是因为编程语言里面除以2的下取整性，试想下如果l + 1 = r时， mid = r 呢，q[mid] &lt;= x，l = mid = r，区间缩小；否则r = mid - 1 = l 区间缩小，l都会与r相遇。就不会死循环。</p>
<h5 id="code">code</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> q[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; q[i];<br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        <br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 找左端点，即: 大于等于x的第一个位置</span><br>        <span class="hljs-keyword">while</span>(l &lt; r)<br>        &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果找到的这个&gt;=x 的最小整数 不是x，说明数组里就没有x</span><br>        <span class="hljs-keyword">if</span> (q[l] != x) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-1 -1&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            r = n - <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-comment">// 找右端点，即: 小于等于x的第一个位置</span><br>            <span class="hljs-keyword">while</span>(l &lt; r)<br>            &#123;<br>                <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span>&gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <br>            <span class="hljs-built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="浮点数二分">浮点数二分</h2>
<h3 id="浮点数二分思路">浮点数二分思路</h3>
<ul>
<li><p>将区间 <code>[l, r]</code> 划分成 <code>[l, mid]</code> 和 <code>[mid, r]</code></p></li>
<li><p>当区间长度足够小时就停止。一般是<strong>多2位</strong>！</p>
<p>比如题目要求小数点后六位，你就写 <code>while(r - l &gt; 1e-8)</code></p></li>
</ul>
<h3 id="模板code-1">模板code</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l, <span class="hljs-keyword">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> ((r - l) &gt; eps)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="例题-1">例题</h3>
<h4 id="acwing-790.-数的三次方根"><a href="https://www.acwing.com/problem/content/792/">1. AcWing 790. 数的三次方根</a></h4>
<blockquote>
<p>模板题</p>
</blockquote>
<h5 id="code-1">code</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>    <br>    <span class="hljs-keyword">double</span> l = <span class="hljs-number">-10000</span>, r = <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-keyword">while</span> ((r - l) &gt; <span class="hljs-number">1e-8</span>)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid * mid &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="在-stl-中的二分查找">在 stl 中的二分查找</h2>
<p><code>lower_bound( )</code> 和 <code>upper_bound( )</code>都是利用二分查找的方法在一个<u>排好序的数组中</u>进行查找的。</p>
<p>在从小到大的排序数组中，</p>
<p><strong>lower_bound( begin,end,num)</strong>：从数组的begin位置到end-1位置二分查找<strong>第一个<u>大于或等于</u>num的数字，找到返回该数字的地址</strong>，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p><strong>upper_bound( begin,end,num)</strong>：从数组的begin位置到end-1位置二分查找<strong>第一个<u>大于</u>num的数字，找到返回该数字的地址，</strong>不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2022/04/13/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="KMP算法-思路"><a href="#KMP算法-思路" class="headerlink" title="KMP算法 思路"></a>KMP算法 思路</h2><p>KMP 是一个字符串匹配算法。使用场景是这样的：给定一个主串 s，以及一个子串 p。子串 p 在主串 s 中多次作为子串出现。求出子串 p 在 s 中所有出现的位置的起始下标。（n为子串p的长度，m为主串s串的长度）</p>
<p>读完这个题，我们首先能想到的方式就是一个暴力的动作hh。就是两个指针扫就完了。暴力的做法就是对于每一个 i，都去和 j 一起往后扫描看二者是否相等，不等的话就继续下一个 i（把 p串 往后移一位）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[i + j - <span class="hljs-number">1</span>] != p[j])<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>KMP 算法是对暴力的这种一一对比的方法进行了优化，时间复杂度由 $O(n^2)$ 降低为 $O(m + n)$。</p>
<p><strong>KMP 核心思想</strong>：在每次匹配不相等时，不是把 p串 往后移一位，而是把 p串 往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找 Next[ ] 数组确定的。</p>
<p>即，KMP 算法分为两步：</p>
<ol>
<li>计算 Next 数组（针对子串 p 而言）</li>
<li>子串 p 和 主串 s 进行匹配</li>
</ol>
<h3 id="Next-数组的性质"><a href="#Next-数组的性质" class="headerlink" title="Next 数组的性质"></a>Next 数组的性质</h3><p>首先要清楚几个定义：</p>
<ul>
<li>“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。</li>
<li><p>“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。</p>
</li>
<li><p><strong>$Next[i]$ 表示子串 p 中以 j (下标从1开始) 结尾的非平凡后缀能匹配 p 的前缀的最大长度。</strong> (或者说 $j$ 是 p 的每个最长公共前后缀中的前缀的尾坐标)</p>
<p>即 $Next[i]=j$ 表示：<code>p[1, j] = p[i - j + 1, i]</code></p>
</li>
</ul>
<p><strong>Next 数组的性质：</strong></p>
<p><code>Next[i] = j</code>：<code>p[1, j] = p[i - j + 1, i]</code></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/28/6828_2f9f9aa689-KMP_1.png" alt=""></p>
<p> <code>Next[j] = k</code>：<code>p[1, k] = p[j - k + 1, j]</code></p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/28/6828_333abd1289-KMP_2.png" alt=""></p>
<p>就是说，若以 i 结尾的非平凡后缀能匹配 p 的前缀的最大长度为 <code>Next[i]</code>，那么它能匹配的次长前缀长度为 <code>Next[Next[i]]</code>，以此类推，<code>Next[Next[Next[i]]]⋯</code> 直至匹配长度为 0 为止。</p>
<p>这是一条很重要的性质，是KMP算法的关键，它与子串 p 在主串 p 中发生失配时的下一步操作有关。</p>
<h3 id="KMP-匹配过程"><a href="#KMP-匹配过程" class="headerlink" title="KMP 匹配过程"></a>KMP 匹配过程</h3><p>下面模拟 $Next[ ]$ 在匹配过程中的作用。</p>
<p>已知主串 s 和子串 p。且 p 的 $Next[]$ 数组已经求出来了，当前主串 s 匹配到下标 i−1 位置，子串 p 匹配到下标 j 位置，即满足 $S[i−j:i−1]==P[1:j]$，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220404112803.png" alt=""></p>
<ol>
<li><p>$S[i]==P[j+1]$，则 j 后移一位，表示这一位匹配成功.</p>
<ul>
<li><p>此时如果 j 到达了 p 串的末尾，说明 p 在 s 中出现了，在 s 中的起始下标为  $i−|P|+1$。</p>
<p>Note：j 接下来不是回到 p串 起始处重新在 s 中找下一个位置，而是 继续从 $j = Next[j]$ 的位置继续匹配。</p>
<p>举个栗子，比如子串是 $abcdabcd$，主串是 $abcdabcdabfg…$。在匹配到 $s[8] == p[7 + 1]$ 的时候，j 后移一位，刚好 $j == m$，找到一个匹配的输出。此时 j 无需从 p 的起始再开始，而是从 $j = Next[8] = 4$ 开始继续看二者的下一位比较即可。</p>
</li>
<li><p>如果还没到，继续看 s 的下一位，即 <code>i ++</code> </p>
</li>
</ul>
</li>
<li>$S[i]≠P[j+1]$，发生失配，此时不需要从头开始匹配。因为 s 和 p 一路匹配过来的，所以 3串 和 2 串是相同的。通过 Next 数组知道 1串 和 2串 是相同的，所以可以推出 1串和 3串 是相同的。所以下一次匹配完全不用从 s 串的下一位开始，直接从相同缀的下一位开始匹配就行了。如下图所示：</li>
</ol>
<p><img src="https://cdn.acwing.com/media/article/image/2020/04/28/6828_3c59de6e89-KMP_4.png" alt=""></p>
<ul>
<li>如何用代码描述子串 p 移动的过程呢？</li>
</ul>
<p>我理解：大家所说的 <strong>失配后 j 回退的过程，我将其看作将 p 向后移动的过程</strong>。也就是说这两个动作是相反的。</p>
<p>或者说，p 向后移动的过程，看成 j 回退的过程，即 令 $j=Next[j]$。然后我们只需要再比较 $S[i]$ 与 $P[j+1]$ 是否匹配即可。如果不匹配就需要不断回退 $j=Next[j]$，其实就是不断用 p 中已经能与 s 中以  $i−1$ 结尾的后缀匹配的前缀，减少中间多余匹配过程，在不断失配的过程中，所使用的  p 的前缀长度递减，直至为 0。如果经过某次 j 的回退，满足了 $S[i]==P[j+1]$，那么  j 就可以后移了。图中表现的是，经过一次回退，就能成功匹配的情况（都是蓝色的小方块）。</p>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220404153407.png" alt=""></p>
<p>以上就是 KMP 算法的匹配过程，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// n为子串p的长度，m为主串s串的长度 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = Next[j]; <span class="hljs-comment">// 失配j就不断回退</span><br>    <span class="hljs-comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span><br>    <span class="hljs-comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span><br>    <br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j++; <span class="hljs-comment">//当前元素匹配，j移向p串下一位</span><br>    <span class="hljs-keyword">if</span> (j == n)  <span class="hljs-comment">// p在s中完整出现</span><br>    &#123;<br>        <span class="hljs-comment">//匹配成功，进行相关操作</span><br>        j = Next[j];  <span class="hljs-comment">//继续匹配下一个子串</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Next-数组求解"><a href="#Next-数组求解" class="headerlink" title="Next 数组求解"></a>Next 数组求解</h3><p>理解了上述匹配过程，$Next[ ]$ 的求解就不难理解了。我们可以把 $Next[ ]$ 的求解过程看成是两个相同的串 p 匹配的过程。</p>
<p>首先对于 p 串，显然有 $Next[1]=0$（因为只考虑非平凡前/后缀），然后两个指针  $i=2,j=0$ 开始，考虑 $P[i]$ 与 $P[j+1]$ 是否匹配，如果不匹配，那么  $j=Next[j]$ 不断回退，直到回退到匹配长度为 0 或者某一个 j 能满足 $P[i]==P[j+1];$ 如果  $P[i]==P[j+1]$ ，j 后移，说明以 p 中以 i 结尾的非平凡后缀能匹配 p 的前缀的最大长度为  j，因此 $Next[i]=j$。</p>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220403111436.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>&#123;<br>    <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="hljs-number">1</span>]) j = Next[j];<br><br>    <span class="hljs-keyword">if</span>(p[i] == p[j+<span class="hljs-number">1</span>]) j++;<br>    Next[i] = j;  <span class="hljs-comment">// 更新Next</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实 KMP的核心就是匹配的时候不必每次都从下一个 i 开始，只要从后缀（最长的公共串）开始继续匹配即可。而 Next 数组记录了每个 i 对应的最长公共前后缀的长度(也可以说是前缀的尾坐标)。</p>
<p>KMP 模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">char</span> s[N], p[N];<br><span class="hljs-keyword">int</span> ne[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// p+1，s+1是让读入之后字符串的下标会从1开始。也可以写成scanf(“%s”, p + 1)</span><br>    <br>    <span class="hljs-comment">// 求 Next 数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">// 不等于</span><br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <br>        <span class="hljs-comment">// 等于</span><br>        <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        ne[i] = j;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m ; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <br>        <span class="hljs-keyword">if</span>(s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        <span class="hljs-keyword">if</span>(j == n)<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; i - n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/2022/03/23/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="高精度">高精度</h1>
<p>高精度的模板包括高精度的加法、减法、乘法、除法。它们在输入输出时的处理方式是一样的，只是在核心的模拟计算的过程不同，在写板子的时候记得模拟一下过程，并多想想特殊情况，比如乘0这种情况会有前导0，等等。</p>
<p>输入输出：</p>
<ol type="1">
<li>存储：用 $ $ 存储，第0位存个位，第1位存十位....以此类推。这样存储的好处是：如果相加有进位，刚好加到下一位，尤其是对于最高位，如果最高位有进位，在末位直接补更方便。</li>
<li>所以在读入数字时，一定要<strong>倒序读入</strong>。运算过后，也要倒序输出。</li>
<li>因为大数，需要按照字符串读进来，在存入数组时，要将字符转为数字，例如：<code>&quot;6&quot; - &quot;0&quot;</code> 就变成数字6。</li>
</ol>
<h2 id="高精度加法">高精度加法</h2>
<ul>
<li><span class="math inline">\(C = A + B, len(A / B) &lt;= 10^6\)</span></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406112720.PNG" /></p>
<h3 id="note">Note</h3>
<ul>
<li>注意在算到最后，也就是最高位的计算时，<strong>还要判断 t 是否有进位，如果有还要加进去！</strong></li>
</ul>
<h3 id="code">code</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.size() &lt; B.size()) <span class="hljs-keyword">return</span> add(B, A);<br><br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C;<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span>(i &lt; B.size()) t += B[i];<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.push_back(t);<br>    <span class="hljs-keyword">return</span> C;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a, b;  <span class="hljs-comment">//按字符串形式输入123456</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, B;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br>	<br>     <span class="hljs-comment">//按照 ‘6’‘5’‘4’‘3’‘2’‘1’ 读入</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) B.push_back(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C = add(A, B);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i -- ) <span class="hljs-built_in">cout</span>&lt;&lt; C[i];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="高精度减法">高精度减法</h2>
<ul>
<li><span class="math inline">\(C = A - B, A&gt;= B, A/B &gt;= 0,len(A / B) &lt;= 10^6\)</span></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406143444.png" /></p>
<h3 id="note-1">Note</h3>
<ul>
<li><p>注意 同一位上的两个数相减如果为负，要向前借一位，这里表示为 <span class="math inline">\(t=1\)</span></p></li>
<li><p>减法存在<strong>前导0</strong>的问题，比如 <span class="math inline">\(13-12=01\)</span>，记得删掉：<code>while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();</code></p></li>
<li><p>减法要注意 <span class="math inline">\(sub()\)</span> 函数实现的是大的减小的，所以在计算前要先调整 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，实现一个 <span class="math inline">\(cmp\)</span> 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//判断是否有 A &gt;= B</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.size() != B.size()) <span class="hljs-keyword">return</span> A.size() &gt; B.size();<br>	<br>    <span class="hljs-comment">// 位数相等，从最高位开始 一位一位 倒序比较！</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )&#123;<br>        <span class="hljs-keyword">if</span> (A[i] != B[i]) <br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br>    <span class="hljs-comment">// 如果两数相等，b</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="code-1">code</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">//判断是否有 A &gt;= B</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.size() != B.size()) <span class="hljs-keyword">return</span> A.size() &gt; B.size();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )&#123;<br>        <span class="hljs-keyword">if</span> (A[i] != B[i]) <br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.size()) t = t - B[i];<br>        C.push_back((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a, b;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, B;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) B.push_back(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);   <br><br>    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; C;<br><br>    <span class="hljs-keyword">if</span>(cmp(A, B)) C = sub(A, B);<br>    <span class="hljs-keyword">else</span>&#123;<br>        C = sub(B, A);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="高精度乘法">高精度乘法</h2>
<ul>
<li><span class="math inline">\(C = A * b, A &gt;= 0, b &gt; 0\)</span>，这里的高精乘是指<strong>高精度乘以低精度</strong>。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406162613.png" /></p>
<h3 id="note-2">Note</h3>
<ul>
<li>也要判断 t 是否有进位，<strong>t 如果非0 需要进位</strong>！</li>
<li>乘法也存在<strong>前导0问题</strong>，比如 <span class="math inline">\(13 * 0 = 00\)</span>，要删掉。</li>
</ul>
<h3 id="code-2">code</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t += A[i] * b;<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        <br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(t) C.push_back(t);<br>    <br>    <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();  <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A, C;<br>    <span class="hljs-built_in">string</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;0&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <br><br>        C = mul (A, b);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )  <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="高精度除法">高精度除法</h2>
<ul>
<li><span class="math inline">\(A / b = C ... r, A &gt;= 0, b &gt; 0\)</span></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406163042.png" /></p>
<h3 id="note-3">Note</h3>
<ul>
<li>除法存在一个和其他三种不一样的问题：其他三种都是倒序读入从低位开始算。但是，除法需要从高位开始算，这个不能变。所以还要<strong>倒序变回正序计算</strong>！然后因为通用的输出还是倒序输出，又得把刚计算得到的结果再变成倒序，再倒序输出就是正序啦！</li>
<li>除法也存在前导0的问题。</li>
</ul>
<h3 id="code-3">code</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;r)</span>  <span class="hljs-comment">// y</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.push_back(r / b);<br>        r %= b;<br>    &#125;<br>    <br>    reverse(C.begin(),C.end());<br>    <br>    <span class="hljs-keyword">while</span>(C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.push_back(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    <span class="hljs-keyword">int</span> r;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C = div(A, b, r);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = C.size() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">cout</span> &lt;&lt; C[i];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/2022/03/24/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<h1 id="前缀和">前缀和</h1>
<h2 id="一维前缀和计算区域内的和">一维前缀和（计算区域内的和 ）</h2>
<h3 id="思路">思路</h3>
<ul>
<li><p>作用：能快速求出<strong>原数组中一段区间的数字和</strong>。</p></li>
<li><p>计算公式：计算 <span class="math inline">\([l, r]\)</span> 区间和前缀和 <code>S[r] - S[l - 1]</code></p></li>
<li><p><code>a[l] + ... + a[r] = S[r] - S[l - 1]</code></p>
<p>如何推导？ <span class="math display">\[
S_r = a_1 + a_2 + .... +  a_{l-1} + a_l + ... + a_r
\]</span></p>
<p><span class="math display">\[
S_{l-1} = a_1 + a_2 + .... + a_{l-1}
\]</span></p>
<p><span class="math inline">\((1) - (2)\)</span> 得： <span class="math display">\[
S_r - S_{l-1} = a_l + .... + a_r
\]</span></p></li>
<li><p>为什么下标要从 <span class="math inline">\(1\)</span> 开始？</p>
<p>比如 <span class="math inline">\([1, 10] =&gt;\)</span> <span class="math inline">\(S_{10} - S_{0} = S_{10}\)</span> ，这样可以统一处理所有情况。</p></li>
</ul>
<h3 id="注意">注意</h3>
<p><strong>差分操作和前缀和一样数组下标都从1开始。</strong></p>
<h3 id="code">code</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> a[N],S[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) S[i] = S[i - <span class="hljs-number">1</span>] + a[i]; <span class="hljs-comment">// 前缀和的初始化</span><br><br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;    <br>        <span class="hljs-keyword">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,S[r] - S[l<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// 区间和的计算</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二维前缀和">二维前缀和</h2>
<h3 id="思路-1">思路</h3>
<ul>
<li><span class="math inline">\(S [i, j]\)</span> = 第i行j列格子左上部分所有元素的和</li>
</ul>
<ol type="1">
<li><p><strong>如何计算前缀和矩阵？</strong></p>
<p><strong>容斥原理：</strong> <span class="math display">\[
S_{x,y} = S_{x-1,y} +  S_{x,y-1} - S_{x-1,y-1} + a_{x,y}
\]</span> <img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220408215133.png" style="zoom: 33%;" /></p></li>
<li><p><strong>如何利用前缀和矩阵，计算某一子矩阵的和？</strong></p></li>
</ol>
<ul>
<li><p>以 <span class="math inline">\((x1, y1)\)</span> 为左上角，<span class="math inline">\((x2, y2)\)</span> 为右下角的子矩阵的和为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220408215251.png" style="zoom: 50%;" /></p></li>
</ul>
<h3 id="code-1">code</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">int</span> a[N][N], S[N][N];<br><span class="hljs-keyword">int</span> n, m, q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            S[i][j] += S[i - <span class="hljs-number">1</span>][j] + S[i][j - <span class="hljs-number">1</span>] - S[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br>            <br>    <span class="hljs-keyword">while</span>(q -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x1, x2, y1, y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, S[x2][y2] - S[x2][y1 - <span class="hljs-number">1</span>] - S[x1 - <span class="hljs-number">1</span>][y2] + S[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>差分</title>
    <url>/2022/03/25/%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="差分">差分</h1>
<h2 id="一维差分">一维差分</h2>
<h3 id="思路">思路</h3>
<ul>
<li>差分是前缀和的逆运算。</li>
<li>作用：给一段区间内的数加上 c</li>
</ul>
<p><strong>差分数组：</strong></p>
<p>首先给定一个原数组 <span class="math inline">\(a: a[1], a[2], a[3],..., a[n];\)</span></p>
<p>然后构造一个数组 <span class="math inline">\(b: b[1] ,b[2] , b[3],..., b[i];\)</span></p>
<p>使得 <span class="math inline">\(a[i] = b[1] + b[2 ]+ b[3] +... + b[i]\)</span></p>
<p>也就是说，<span class="math inline">\(a\)</span> 数组是 <span class="math inline">\(b\)</span> 数组的前缀和数组，反过来我们把 <span class="math inline">\(b\)</span> 数组叫做 <span class="math inline">\(a\)</span> 数组的<strong>差分数组</strong>。换句话说，每一个 <span class="math inline">\(a[i]\)</span> 都是 <span class="math inline">\(b\)</span> 数组中从头开始的一段区间和。</p>
<p><strong>考虑如何构造差分<span class="math inline">\(b\)</span>数组？</strong></p>
<p>最为直接的方法： <span class="math display">\[
\begin{array}{l}
a[0]=0 \\
b[1]=a[1]-a[0] \\
b[2]=a[2]-a[1] \\
b[3]=a[3]-a[2] \\
\ldots \ldots \\
b[n]=a[n]-a[n-1]
\end{array}
\]</span> <strong>只要有 <span class="math inline">\(b\)</span> 数组，通过前缀和运算，就可以在 <span class="math inline">\(O(n)\)</span> 的时间内得到 <span class="math inline">\(a\)</span> 数组 。</strong></p>
<p>差分数组用于：给定区间<span class="math inline">\([l ,r ]\)</span>，把 <span class="math inline">\(a\)</span> 数组中的<span class="math inline">\([l, r]\)</span>区间中的每一个数都加上，即 <span class="math inline">\(a[l] + c , a[l+1] + c,..., a[r] + c\)</span>;</p>
<p>暴力做法是 <span class="math inline">\(for\)</span> 循环 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(r\)</span> 区间，时间复杂度 <span class="math inline">\(O(n)\)</span>，如果我们需要对原数组执行 <span class="math inline">\(m\)</span> 次这样的操作，时间复杂度就会变成 <span class="math inline">\(O(n*m)\)</span>。有没有更高效的做法吗? <strong>考虑差分做法</strong>：</p>
<ol type="1">
<li><p>首先让差分 $b $ 数组中的 $b[l] + c $ , $a $ 数组变成 <span class="math inline">\(a[l] + c ,a[l+1] + c,..., a[n] + c\)</span></p></li>
<li><p>然后让 $b[r+1] - c $, $a $ 数组变成 <span class="math inline">\(a[r+1] - c,a[r+2] - c,...,a[n] - c\)</span></p></li>
</ol>
<p>画个图理解一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220407130926.png" style="zoom:50%;" /></p>
<p>$b[l] + c $ 使得 $a $ 数组中 $a[l] $ 及以后的数都加上了 $c $ (红色部分)，但只要求 $l $ 到 $r $ 区间加上 <span class="math inline">\(c\)</span>，因此还需要执行 $b[r+1] - c $，让 $a $数组中 $a[r+1] $ 及往后的区间再减去 $c $ (绿色部分)，这样对于 $a[r] $ 以后区间的数相当于没有发生改变。</p>
<p>因此得出<strong>一维差分结论</strong>：给 $a $ 数组中的 $[ l, r] $区间中的每一个数都加上 $c $，只需对差分数组 $b $ 做 $b[l] + = c $， $b[r+1] - = c $。时间复杂度为 $O(1) $，大大提高了效率。</p>
<h3 id="note">Note</h3>
<ul>
<li><p><strong>差分操作和前缀和一样数组下标都从1开始。</strong></p></li>
<li><p><span class="math inline">\(b[l]+c\)</span> 后，<span class="math inline">\(l\)</span> 后面的数组都会加 <span class="math inline">\(c\)</span> 。<span class="math inline">\(r\)</span> 后面的数据也会被改变，要改回来就得 <span class="math inline">\(b[r+1]-c\)</span></p>
<p>核心操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="code">code</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n, q;<br><span class="hljs-keyword">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-comment">// a[i] 是原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];  <br>    <br>    <span class="hljs-comment">// b[i] 是差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">// insert(i, i, a[i]);</span><br>        b[i] = a[i] - a[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(q -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> l, r, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;<br>        insert(l, r, c); <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        a[i] = b[i] + a[i - <span class="hljs-number">1</span>];    <span class="hljs-comment">//前缀和运算</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二维差分">二维差分</h2>
<h3 id="思路-1">思路</h3>
<p><code>a[][]</code>数组是<code>b[][]</code>数组的前缀和数组，那么<code>b[][]</code>是<code>a[][]</code>的差分数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220407133657.png" style="zoom: 50%;" /></p>
<h3 id="note-1">Note</h3>
<ul>
<li><p>核心操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function">  </span>&#123;<br>      b[x1][y1] += c;<br>      b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>      b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>      b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>  &#125;<br><br><br><br><br><br>##<span class="hljs-meta"># code</span><br><br>```c++<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">int</span> n, m, q;<br><span class="hljs-keyword">int</span> a[N][N], b[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[x1][y1] += c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-built_in">cin</span> &gt;&gt; a[i][j];<br>    <br>    <span class="hljs-comment">// 构建差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-comment">// insert(i, j, i, j, a[i][j]);</span><br>            b[i][j] = a[i][j] - a[i - <span class="hljs-number">1</span>][j] - a[i][j - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <br>    <span class="hljs-keyword">while</span>(q -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x1, y1, x2, y2, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;<br>        <br>        insert(x1, y1, x2, y2, c);<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            b[i][j] +=  b[i - <span class="hljs-number">1</span>][j] + b[i][j - <span class="hljs-number">1</span>] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j =<span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            <span class="hljs-built_in">cout</span> &lt;&lt; b[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2022/03/31/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>位运算涉及的两种操作：</p>
<ol>
<li>$x &gt;&gt; k \&amp; 1$：x 的二进制表示中的第 k 位数字是几</li>
<li>返回 x 的最后一位1后面的所有位：<code>lowbit(x) = x &amp; -x</code></li>
</ol>
<h2 id="x-gt-gt-k-amp-1-：x-的二进制表示中的第-k-位"><a href="#x-gt-gt-k-amp-1-：x-的二进制表示中的第-k-位" class="headerlink" title="$x &gt;&gt; k \&amp; 1$：x 的二进制表示中的第 k 位"></a>$x &gt;&gt; k \&amp; 1$：x 的二进制表示中的第 k 位</h2><p>问题：整数 $n$ 的二进制表示中，第 $k$ 位数字是几？</p>
<p>$&gt;&gt;$ 是右移运算符。假设x=5，那么x的二进制为0101，$x&gt;&gt;1$ 表示x右移1位，即把最右边一位的1删掉，变为010，此时x=2； 仍然设x=5，二进制0101，$x&gt;&gt;2$ 表示x右移2位，把最右边两位的01去掉，变为01，此时x=1。$x&gt;&gt;=1$ 等价于 $x=x&gt;&gt;1$，跟 $x+=1$ 等价于 $x=x+1$ 是一个道理</p>
<blockquote>
<p>$x &gt;&gt;= 1$ 相当于 $x = x / 2$</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220409190225.png" style="zoom: 40%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">31</span>; k &gt;= <span class="hljs-number">0</span> ; k -- ) <span class="hljs-built_in">cout</span> &lt;&lt; (x &gt;&gt; k &amp; <span class="hljs-number">1</span>);  =&gt; <span class="hljs-number">1010</span><br></code></pre></td></tr></table></figure>
<p><strong>Note：</strong>注意要倒序输出。</p>
<h2 id="lowbit-x-：返回x的最后一位1后面的所有位"><a href="#lowbit-x-：返回x的最后一位1后面的所有位" class="headerlink" title="lowbit(x)：返回x的最后一位1后面的所有位"></a>lowbit(x)：返回x的最后一位1后面的所有位</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220409192144.png" style="zoom: 50%;" /></p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>例：<br>x = 1010         lowbit(x) = 10<br>x = 101000     lowbit(x) = 1000</p>
</blockquote>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="AcWing-801-二进制中1的个数"><a href="#AcWing-801-二进制中1的个数" class="headerlink" title="AcWing 801. 二进制中1的个数"></a><a href="https://www.acwing.com/problem/content/description/803/">AcWing 801. 二进制中1的个数</a></h3><h4 id="1-用-x-gt-gt-k-amp-1"><a href="#1-用-x-gt-gt-k-amp-1" class="headerlink" title="1.用 $x &gt;&gt; k \&amp; 1$"></a>1.用 $x &gt;&gt; k \&amp; 1$</h4><p>$x &gt;&gt; k \&amp; 1$：x 的二进制表示中的第 k 位数字。遍历每一位即可，如果是 1，<code>res ++</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(n -- )<br>&#123;<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; x;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">31</span>; k &gt;= <span class="hljs-number">0</span>; k -- ) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (x &gt;&gt; k &amp; <span class="hljs-number">1</span>) res ++ ;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-用-lowbit-x"><a href="#2-用-lowbit-x" class="headerlink" title="2. 用 lowbit(x)"></a>2. 用 lowbit(x)</h4><p>lowbit(x)：返回x的最后一位1后面的所有位。每次lowbit操作截取一个数字最后一个1后面的所有位，每次减去lowbit得到的数字，直到数字减到0，就得到了最终1的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">while</span>(n -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        <br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x) &#123;<br>            x -= lowbit(x);<br>            res ++ ;<br>        &#125;<br>        <br>        <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL</title>
    <url>/2022/04/13/C-STL/</url>
    <content><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p><code>include&lt;vector&gt;</code></p>
</li>
<li><p>定义：vector，变长数组，倍增的思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span> &lt; <span class="hljs-keyword">typename</span> &gt; v;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">  <span class="hljs-built_in">vector</span> &lt; <span class="hljs-keyword">typename</span> &gt; arrayname[size];<br><br>&gt; 系统为某一程序分配空间时，所需时间，与空间大小无关，与申请次数有关。<br><br><span class="hljs-built_in">vector</span> 优化的目标是减少申请次数，可以浪费空间。倍增的思想是：每次数组长度不够时，就会把新数组长度设为旧的*<span class="hljs-number">2</span>，然后 copy到新数组。比如说申请一个 $n=<span class="hljs-number">10</span>^<span class="hljs-number">6</span>$ 的数组，大概 copy $<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span>+<span class="hljs-number">8</span>+...+<span class="hljs-number">5</span> \times <span class="hljs-number">10</span>^<span class="hljs-number">5</span> = <span class="hljs-number">10</span>^<span class="hljs-number">6</span>$ 。所以可以看成，平均情况下每插入一个数的时间复杂度是 $o(<span class="hljs-number">1</span>)$ 的。申请空间的次数是 $log_n$。<br><br><br><br>**访问**<br><br><span class="hljs-number">1.</span> 通过下标访问：`v[ i ]`<br><br><span class="hljs-number">2.</span> 通过迭代器访问：<br><br>   ```c++<br>   <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">typename</span>&gt;::iterator i;<br></code></pre></td></tr></table></figure>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator i = a.begin(); i != a.end(); i ++ ) <span class="hljs-built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br></code></pre></td></tr></table></figure>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: a) cput &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>a.begin()</code> 是第0个 <code>a[0]</code></li>
<li><code>a.end()</code> 是最后一个的下一个</li>
</ul>
</li>
</ul>
<p><strong>vector 常用函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">size()  返回元素个数<br>empty()  返回是否为空<br>clear()  清空<br>front()/back()  返回第一个/最后一个<br>push_back()/pop_back()  尾部添加/删除<br>begin()/end()   迭代器：第<span class="hljs-number">0</span>个数/最后一个数的后面一个数<br>[]  随机寻址<br>支持比较运算，按字典序<br></code></pre></td></tr></table></figure>
<p>栗：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vector&lt;int&gt; a(4, 3), b(3, 4);<br><span class="hljs-keyword">if</span>(a &lt; b) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;a &lt; b&quot;</span>);<br></code></pre></td></tr></table></figure>
<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p>存储二元组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br>    <br><span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; p;  <span class="hljs-comment">// 存储三个不同的</span><br></code></pre></td></tr></table></figure>
<p>常见用法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt; p1;  <span class="hljs-comment">// 使用默认构造函数</span><br>p1.first = <span class="hljs-number">1</span>;<br>p1.second = <span class="hljs-number">2.5</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; p1.first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p1.second &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 1 2.5</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>make_pair()</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt; p1;<br>p1 = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>);<br>p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;yxc&quot;</span>);<br>p = &#123;<span class="hljs-number">20</span>, <span class="hljs-string">&quot;abc&quot;</span>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>string，字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span>，字符串<br>    size()/length()  返回字符串长度<br>    empty()<br>    clear()  清空一个字符串<br>    substr(起始下标，(子串长度))  返回子串！！！<br>    c_str()  返回字符串所在字符数组的起始地址！！！<br></code></pre></td></tr></table></figure>
<p>栗:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> a = <span class="hljs-string">&quot;yxc&quot;</span>;<br>a += <span class="hljs-string">&quot;def&quot;</span><br>a += <span class="hljs-string">&quot;c&quot;</span>;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; a ;  <span class="hljs-comment">// yxcdef</span><br></code></pre></td></tr></table></figure>
<p><strong>常用函数</strong></p>
<ul>
<li><p><strong>substr(a, b)</strong>：从第a个字母开始，<strong>长度为b</strong>的子串，如果大于字符串长度，返回整个字符串。</p>
</li>
<li><p><strong>c_str()</strong>： 将 string类型转为 字符数组进行输出。用printf 输出 string。<code>printf(&quot;%s&quot;, a.c_str());</code></p>
</li>
</ul>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>队列。先进先出的容器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">queue</span>, 队列<br>    size()<br>    empty()<br>    push()  向队尾插入一个元素<br>    pop()  弹出队头元素。注意，并不会返回被弹出元素的值。<br>    front()  返回队头元素<br>    back()  返回队尾元素<br></code></pre></td></tr></table></figure>
<ul>
<li>queue队列中没有 <code>clear()</code> 操作：</li>
</ul>
<p>可以重新构造一个 q</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>q = <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;empty;<br>    swap(empty,q);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>priority_queue, 优先队列，默认是大根堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">priority_queue</span>, 优先队列，默认是大根堆<br>	empty() 如果队列为空返回真<br>	size() 返回优先队列中拥有的元素个数<br>    push()  插入一个元素<br>    top()  返回堆顶元素<br>    pop()  弹出堆顶元素<br>    定义成小根堆的方式：<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>priority_queue 中也没有 <code>clear()</code> 操作：</p>
</li>
<li><p>定义成小根堆的方式：<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code></p>
</li>
</ul>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>栈。后进先出的容器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stack</span>, 栈<br>    size()<br>    empty()<br>    push()  向栈顶插入一个元素<br>    top()  返回栈顶元素<br>    pop()  弹出栈顶元素<br></code></pre></td></tr></table></figure>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>deque, 双端队列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">deque</span>, 双端队列<br>    size()<br>    empty()<br>    clear()<br>    front()/back()<br>    push_back()/pop_back()     <span class="hljs-comment">// 尾部插入，删除元素</span><br>    push_front()/pop_front()   <span class="hljs-comment">// 头部插入，删除元素</span><br>    begin()/end()<br>    []<br></code></pre></td></tr></table></figure>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">set</span>, <span class="hljs-built_in">map</span>, <span class="hljs-built_in">multiset</span>, <span class="hljs-built_in">multimap</span>, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size()<br>    empty()<br>    clear()<br>    begin()/end()<br>    ++, -- 返回前驱和后继，时间复杂度 O(logn)<br></code></pre></td></tr></table></figure>
<h2 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">set</span>/<span class="hljs-built_in">multiset</span><br>    insert()  插入一个数<br>    find()  查找一个数<br>    count()  返回某一个数的个数<br>    erase()<br>    	(<span class="hljs-number">1</span>) 输入是一个数x，删除所有<span class="hljs-function">x   <span class="hljs-title">O</span><span class="hljs-params">(k + logn)</span></span><br>    	(2) 输入一个迭代器，删除这个迭代器<br>    lower_bound()/upper_bound()<br>    	lower_bound(x)  返回大于等于x的最小的数的迭代器<br>    	upper_bound(x)  返回大于x的最小的数的迭代器<br></code></pre></td></tr></table></figure>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map，映射。会以键从小到大的顺序自动排序</p>
<p>对map进行遍历：</p>
<ul>
<li>正向迭代器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;::iterator  iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  <br><span class="hljs-built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>; <br></code></pre></td></tr></table></figure>
<h2 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">set</span>, <span class="hljs-built_in">map</span>, <span class="hljs-built_in">multiset</span>, <span class="hljs-built_in">multimap</span>, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size()<br>    empty()<br>    clear()<br>    begin()/end()<br>    ++, -- 返回前驱和后继，时间复杂度 O(logn)<br></code></pre></td></tr></table></figure>
<ul>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">map</span>/<span class="hljs-built_in">multimap</span>. 允许重复元素，<span class="hljs-built_in">map</span>不允许重复元素。<br>    insert()  插入的数是一个<span class="hljs-built_in">pair</span><br>    erase()  输入的参数是<span class="hljs-built_in">pair</span>或者迭代器<br>    find()<br>    []  注意<span class="hljs-built_in">multimap</span>不支持此操作。 时间复杂度是 O(logn)<br>    lower_bound()/upper_bound()<br><br><span class="hljs-built_in">unordered_set</span>, <span class="hljs-built_in">unordered_map</span>, <span class="hljs-built_in">unordered_multiset</span>, <span class="hljs-built_in">unordered_multimap</span>, 哈希表<br>    和上面类似，增删改查的时间复杂度是 O(<span class="hljs-number">1</span>)<br>    不支持 lower_bound()/upper_bound()， 迭代器的++，--<br></code></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">unordered_set</span>, <span class="hljs-built_in">unordered_map</span>, <span class="hljs-built_in">unordered_multiset</span>, <span class="hljs-built_in">unordered_multimap</span>, 哈希表<br>    和上面类似，增删改查的时间复杂度是 O(<span class="hljs-number">1</span>)<br>    不支持 lower_bound()/upper_bound()， 迭代器的++，--<br></code></pre></td></tr></table></figure>
<h1 id="压位"><a href="#压位" class="headerlink" title="压位"></a>压位</h1><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">bitset</span>, 圧位<br>    <span class="hljs-built_in">bitset</span>&lt;10000&gt; s;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    ==, !=<br>    []<br><br>    count()  返回有多少个<span class="hljs-number">1</span><br><br>    any()  判断是否至少有一个<span class="hljs-number">1</span><br>    none()  判断是否全为<span class="hljs-number">0</span><br><br>    <span class="hljs-built_in">set</span>()  把所有位置成<span class="hljs-number">1</span><br>    <span class="hljs-built_in">set</span>(k, v)  将第k位变成v<br>    reset()  把所有位变成<span class="hljs-number">0</span><br>    flip()  等价于~<br>    flip(k) 把第k位取反<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/2022/04/15/Trie%E6%A0%91/</url>
    <content><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>链表，Trie树或是堆，他们的基本单元都是一个个节点连接构成的，可以成为“链”式结构。即，可以<strong>用数组模拟链</strong>。</p>
<p><u>回想一下：</u></p>
<p>链表中会使用到这几个数组来模拟：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头指向的节点，e[]存储节点的值，ne[]存储节点的next指针(下一个节点的位置)，idx表示当前用到了哪个节点</span><br>head, e[N], ne[N], idx;<br></code></pre></td></tr></table></figure>
<p>head 表示头节点指针，一开始初始化指向 -1，每次插入x的操作 <code>idx++;</code>。利用 <code>idx</code> 联系结构体本身的值和 <code>next</code> 指针，因此 <code>e[idx]</code> 可以表示节点的值，<code>ne[idx]</code> 可以作为<code>next</code>指针，存储下一个节点的位置。同理双链表也是如此。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//单链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_to_head</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] =  x;<br>    ne[idx] = head;<br>    head = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">//双链表</span><br><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,  <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br><br>    l[idx] = a;<br>    r[idx] = r[a];<br><br>    l[r[a]] = idx;<br>    r[a] = idx;<br>    <br>    idx ++ ;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>Trie树</strong> 的作用：<strong>快速存储</strong> 和 <strong>查找</strong> 字符串集合 的数据结构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220411163913.png" alt=""></p>
<p>Trie树一般有两个操作：</p>
<ul>
<li>插入：向集合中插入一个字符串</li>
<li>查询：询问一个字符串在集合中出现了多少次</li>
</ul>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>Trie树中有个二维数组 <code>son[N][26]</code>，<strong>表示当前节点的儿子的信息</strong>，如果当前节点没有儿子的话，可以等于 <code>++idx</code>。Trie树本质上是一颗多叉树，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。</p>
<p>比如：</p>
<ul>
<li><p><code>son[0][0] = 1</code> ：表示0节点(当前位置是 根)的子节点的值是0，子节点的坐标是 1节点</p>
</li>
<li><p><code>son[1][1] = 2</code> ：表示1节点(当前位置是 1)的子节点的值是1，子节点的坐标是 2节点</p>
</li>
</ul>
<p>所以说，这里的<strong><code>son[p][u] = x</code> 是描述当前节点的儿子节点的值 $u$ 和坐标 $x$，也记录了本父节点的坐标 $p$</strong>（好神奇!）。</p>
<p><code>son[M][N]</code> 中的 M 是 Trie 树总节点数上限。一共 N 个数，每个数 31 位，从根开始往下存，要 31 个结点，M = 31 * N。</p>
<p>N 是儿子节点的可能性有多少。模板题中是字符串，而题目本身又限定了均为小写字母所以只有26种可能性。比如是存二进制数，那下一位只有0或者1两种情况，所以应为2。</p>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220411163836.png" alt=""></p>
<p><strong>插入操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 从根结点开始遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">// 存映射 类似&#x27;c&#x27; - &#x27;a&#x27;，</span><br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;  <span class="hljs-comment">//没有该子结点就创建一个, 存入本节点，子节点的值，子节点的坐标 先+1</span><br>        p = son[p][u];  <span class="hljs-comment">// 移向下一个节点</span><br>    &#125;<br>    <br>    cnt[p] ++ ;  <span class="hljs-comment">// 以当前节点结尾的点 标记一下</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询字符串是否存在，需要满足两个条件：遍历字符串，需要每一个字符都能找到；还有就是结尾节点要有标记，以防止只是出现局部这种反例，如第一张图举例所示。所以 $cnt[]$ 就是标记字符串尾节点的，<strong>表示以这个节点结尾的字符串的数量</strong>（可能找到的是存在字符串的子串，这种情况就直接是0）</p>
<p><strong>查询操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 从根节点开始找</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 没有这个字符，字符串就不存在</span><br>        p = son[p][u];  <span class="hljs-comment">// 移向下一个节点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cnt[p];  <span class="hljs-comment">// 返回以这个节点结尾的字符串的数量(可能找到的是存在字符串的子串，这种情况就直接是0)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-835-Trie字符串统计"><a href="#1-AcWing-835-Trie字符串统计" class="headerlink" title="1. AcWing 835. Trie字符串统计"></a><a href="https://www.acwing.com/problem/content/837/">1. AcWing 835. Trie字符串统计</a></h3><p>维护一个字符串集合，支持两种操作：</p>
<ol>
<li><code>I x</code> 向集合中插入一个字符串 x；</li>
<li><code>Q x</code> 询问一个字符串在集合中出现了多少次。</li>
</ol>
<p>共有 N 个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。</p>
<blockquote>
<p>模板题</p>
</blockquote>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-keyword">char</span> str[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    <br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 因为有好多测试点会输一些空格，用字符串可以有效避免这些无效字符，所以即使用字符，也用数组存好一点</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, op, str);  <span class="hljs-comment">// scanf(“%s”)会跳过空格、回车，而且测试点会多出一下空格什么的</span><br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) insert(str);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, query(str));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><p>字符串是 “” 号赋值的</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">例:<br>	<span class="hljs-keyword">char</span> a[]=<span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//长度为6  最后加了一个 &#x27;\0&#x27;</span><br>或<br>	<span class="hljs-keyword">char</span> a[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>字符串会自动的在最后加一个 <code>&#39;\0&#39;</code> 的结束符</li></ul><p>字符数组是一个一个的赋值 </p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">例： <span class="hljs-keyword">char</span> a[<span class="hljs-number">5</span>]=&#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>&#125;;  <span class="hljs-comment">//长度为5 不会自动的加 &#x27;\0&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>%s它要求参数是一个指针！！！即： 要求 char * 类型</p><p>%s 字符串的格式输出, 它是一个接一个挨着输出, 直到遇见’\0’才中止</p></blockquote><p><code>char a1[] = “abc”;</code> 下面的结果分别是什么？<br>输出相同，都是数组元素的第一个地址。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cout</span> &lt;&lt; &amp;a1[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><code>char* pa = “abc”;</code> 下面的结果分别是什么？</p><p>pa是指针，就是指向首个元素的地址。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">cout</span> &lt;&lt; &amp;pa &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出pa在栈上的地址</span><br><span class="hljs-built_in">cout</span> &lt;&lt; &amp;pa[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 首地址。</span><br><span class="hljs-built_in">cout</span> &lt;&lt; pa &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 首地址。</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>下面的结果，违反直觉，按道理第5，6行应该输出地址。但是却输出指向的字符串。这有一定的合理性，我们打印char指针，往往是要看指向的内容，而不是要看地址是多少。而且cout很容易做到，只要遇到 <code>\0</code> 就结束。那么问题来了，我想看地址怎么办？使用int强制转化为地址。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a1[] = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">char</span>* pa = <span class="hljs-string">&quot;def&quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="hljs-built_in">endl</span>;          <span class="hljs-comment">// 输出abc</span><br><span class="hljs-built_in">cout</span> &lt;&lt; pa &lt;&lt; <span class="hljs-built_in">endl</span>;          <span class="hljs-comment">// 输出def</span><br><span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">int</span>)a1 &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-comment">// 输出a1地址</span><br><span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">int</span>)pa &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-comment">// 输出pa地址</span><br></code></pre></td></tr></table></figure><p>除此之外，还可以用 $<em> $ <em>*来获取单个字符</em></em></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span>* pa = abcde;<br><span class="hljs-built_in">cout</span> &lt;&lt; *pa &lt;&lt; <span class="hljs-built_in">endl</span>;          <span class="hljs-comment">// 输出a</span><br><span class="hljs-built_in">cout</span> &lt;&lt; *(pa+<span class="hljs-number">2</span>) &lt;&lt;<span class="hljs-built_in">endl</span>;       <span class="hljs-comment">// 输出c</span><br></code></pre></td></tr></table></figure>
          </div>
<h3 id="2-AcWing-143-最大异或对"><a href="#2-AcWing-143-最大异或对" class="headerlink" title="2. AcWing 143. 最大异或对"></a>2. AcWing 143. 最大异或对</h3><p>给定的 $a_1, a_2, …,a_n$ 中选出两个进行 xor（异或）运算，得到的结果最大是多少？</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>这道题的启示是：字典树不单单可以高效存储和查找字符串集合,还可以存储二进制数字</strong></p>
<p>思路：将每个数以二进制方式存入字典树,找的时候从最高位去找有无该位的异(1找0，0找1).</p>
<p>想一下暴力做法：穷举所有的数对, 找到异或运算的最大值 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 二重循环</span><br>res = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to n<br>    <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to i<br>        res = max(res, a[i] ^ a[j])<br></code></pre></td></tr></table></figure>
<p>优化暴力：将暴力做法的内层循环用 $O(1)$ 时间来实现</p>
<p>相当于只有一层循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单重循环</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to n<br>    insert(a[i])<br>    res = max(res, a[i] ^ query(a[i]))<br></code></pre></td></tr></table></figure>
<p><strong>如何把内层循环用 O(1) 时间来实现 ?</strong></p>
<ul>
<li>实现一个 $query()$ 函数，使得 <code>query(a[i])</code> 的值一定是 <code>a[1..i]</code> 中与 <code>a[i]</code> 异或运算结果最大的。</li>
</ul>
<p><strong>如何使得一个数与 <code>a[i]</code> 异或最大？</strong></p>
<ul>
<li><strong><code>query(a[i])</code> 尽可能找二进制高位上与 <code>a[i]</code> 相反的元素, 于是在该位上异或结果尽可能为 1。一定是从高位往低处找，这个数才能尽可能的大。</strong>举个例子：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220413100349.png" alt=""></p>
<ul>
<li>找和 2(010) 异或最大的：先找 0 的相反 1(有)，再找 1 的相反 0(有)，继续找 0 的相反 1(有)。那就找到了，和 2(010) 异或最大的是 5(101)</li>
<li>找和 6(110) 异或最大的：先找 1 的相反 0(有)，再找 1 的相反 0(没有，此时因为没有0的选择，只能选差一点的选择，就是 1)，继续找 0 的相反 1(有)。所以就找到了，和 6(110) 异或最大的是 3(011)</li>
</ul>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">31</span> * N;<br><br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> son[M][<span class="hljs-number">2</span>], idx;  <span class="hljs-comment">// N 是儿子节点的可能性有多少。存二进制数，那下一位只有0或者1两种情况，所以应为2。</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 取X的第i位的二进制数是什么</span><br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// query(x)查找的和x值的最大的异或值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )  <span class="hljs-comment">// 从最大位开始找</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> u = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(son[p][!u])  <span class="hljs-comment">// 如果当前层有对应的 “异”数(相反的数), 就选它</span><br>        &#123;<br>            p = son[p][!u];<br>            res = (res &lt;&lt; <span class="hljs-number">1</span>) + !u;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 没有相反的就只能将就选一样的...</span><br>        &#123;<br>            p = son[p][u];<br>            res = (res &lt;&lt; <span class="hljs-number">1</span>) + u;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>        insert(a[i]);<br>        <br>        res = max(res, a[i] ^ query(a[i]));  <span class="hljs-comment">// query(a[i])查找的是a[i]值的最大异或值</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2022/03/29/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h1><p>双指针的核心思想：<strong>优化</strong>。降低时间复杂度 $O(n^2) -&gt; O(n)$</p>
<p><img src="C:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220410094054260.png" alt="image-20220410094054260" style="zoom:50%;" /></p>
<p>双指针算法的基本应用：输入一串字符串(中间带空格)，把每个单词数出来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220410094744.png" alt="image-20220410094738815" style="zoom:80%;" /></p>
<p>用code表示就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">strlen</span>(str); i ++ )<br>&#123;<br>	<span class="hljs-keyword">int</span> j = i;<br>    <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; str[j] !+ <span class="hljs-string">&#x27; &#x27;</span>) j ++ ;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k ++ ) <span class="hljs-built_in">cout</span> &lt;&lt; str[k];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    i = j;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-AcWing-799-最长连续不重复子序列"><a href="#1-AcWing-799-最长连续不重复子序列" class="headerlink" title="1. AcWing 799. 最长连续不重复子序列"></a><a href="https://www.acwing.com/problem/content/801/">1. AcWing 799. 最长连续不重复子序列</a></h2><p>给定一个长度为 $n$ 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历数组 $a$ 中的每一个元素 $a[i]$，对于每一个 $i$，找到j使得双指针 $[j, i]$ 维护的是<strong>以 $a[i]$ 结尾的</strong>最长连续不重复子序列，长度为 $i - j + 1$，将这一长度与 $res$ 的较大者更新给 $res$。</p>
<p>对于每一个 $i$，如何确定 $j$ 的位置?</p>
<ul>
<li><p>由于 $[j, i - 1]$ 是前一步得到的最长连续不重复子序列，所以如果 $[j, i]$ 中有重复元素，一定是 $a[i]$，因此右移 $j$ 直到 $a[i]$ 不重复为止。</p>
<p>由于 $[j, i - 1]$ 已经是前一步的最优解，此时 $j$ 只可能右移以剔除重复元素 $a[i]$，不可能左移增加元素，因此，$j$ 具有“单调性”、本题可用双指针降低复杂度。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220410105419.png" style="zoom: 50%;" /></p>
<p>总结一下：用数组 $s$ 记录子序列 $a[j$ ~ $i]$ 中各元素出现次数，遍历过程中对于每一个 $i$ 有四步操作：</p>
<ul>
<li>$cin &gt;&gt; a[i] $</li>
<li>将 $a[i]$ 出现次数 $s[a[i]]$ 加1</li>
<li>若 $a[i]$ 重复，则$s[a[j]]$ 要减1，然后右移 $j$</li>
<li>确定 $j$ 及更新当前长度 $i - j + 1$ 给 $res$。</li>
</ul>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><font color='red'><strong>当 $a[i]$ 重复时，先把 $a[j]$ 次数减1，再右移 $j$</strong></font>。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> s[N];  <span class="hljs-comment">// 记录数组元素出现的次数</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        s[a[i]] ++ ;<br>        <span class="hljs-keyword">while</span>(s[a[i]] &gt; <span class="hljs-number">1</span>) <br>        &#123;<br>            s[a[j]] -- ;  <span class="hljs-comment">// 先减次数</span><br>            j ++ ;  <span class="hljs-comment">// 再往后移指针</span><br>        &#125;<br>        <br>        res = max(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-Leetcode-3-无重复字符的最长子串"><a href="#2-Leetcode-3-无重复字符的最长子串" class="headerlink" title="2. Leetcode 3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">2. Leetcode 3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.size(); i ++ )<br>        &#123;<br>            hash[s[i]] ++ ;<br>            <span class="hljs-keyword">while</span>(hash[s[i]] &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                hash[s[j]] -- ;<br>                j ++ ;<br>            &#125;<br>            res = max(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="3-AcWing-800-数组元素的目标和"><a href="#3-AcWing-800-数组元素的目标和" class="headerlink" title="3. AcWing 800. 数组元素的目标和"></a><a href="https://www.acwing.com/problem/content/802/">3. AcWing 800. 数组元素的目标和</a></h2><p>给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。数组下标从 0 开始。</p>
<p>请你求出满足 A[i]+B[j]=x 的数对 (i,j)。数据保证有唯一解。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>从两端往中间逼近答案:</p>
<ul>
<li>i 从 0开始 从前往后遍历</li>
<li>j 从 m - 1开始 从后向前遍历</li>
</ul>
<p>和纯暴力的 $O(n^2)$ 算法的区别就在于 <strong>j 指针不会回退</strong></p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> a[N], b[N];<br><span class="hljs-keyword">int</span> n, m, x;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>; i &lt;n ; i ++ ) <br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j -- ;<br>        <span class="hljs-keyword">if</span>(a[i] + b[j] == x)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, j);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-AcWing-2816-判断子序列"><a href="#4-AcWing-2816-判断子序列" class="headerlink" title="4. AcWing 2816. 判断子序列"></a><a href="https://www.acwing.com/problem/content/2818/">4. AcWing 2816. 判断子序列</a></h2><p>给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。请你判断 a 序列是否为 b 序列的子序列。</p>
<p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>$j$ 指针用来扫描整个b数组，$i$ 指针用来扫描a数组。若发现 $a[i]==b[j]$，则让 $i$ 指针后移一位。</li>
<li>整个过程中，$j$ 指针不断后移，而 $i$ 指针只有当匹配成功时才后移一位，若最后若 $i==n$，则说明匹配成功。</li>
</ol>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; b[j];<br>    <br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; n &amp;&amp; a[i] == b[j]) i ++; <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(i == n) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>最长不重复子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>区间合并</title>
    <url>/2022/04/02/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220412101750.png" alt=""></p>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220412101017.png" alt=""></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;PII&gt; res;<br><br>    sort(segs.begin(), segs.end());  <span class="hljs-comment">// 按左端点排序</span><br><br>    <span class="hljs-keyword">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)  <span class="hljs-comment">// 情况3. 两个区间无法合并</span><br>        &#123;<br>            <span class="hljs-comment">// 循环里面的if语句是为了防止初始的st和ed，也就是st=-2e9 ed=-2e9被记录下来</span><br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);  <span class="hljs-comment">// 将旧区间 存入 res</span><br>            st = seg.first, ed = seg.second;  <span class="hljs-comment">// 更新 新区间的左右端点</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 情况2. 两个区间可以合并：区间包含，区间合并，二者都是选最大的ed（如第一张图所示）</span><br>        <span class="hljs-keyword">else</span> ed = max(ed, seg.second);<br>    &#125;<br><br>    <span class="hljs-comment">// 考虑循环结束时的st,ed变量，此时的st,ed变量不需要继续维护，只需要放进res数组即可。</span><br>    <span class="hljs-comment">// 因为这是最后的一个序列，所以不可能继续进行合并。</span><br>    <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);  <span class="hljs-comment">// if语句则是防止输入空的区间，不对空区间进行记录 </span><br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-803-区间合并"><a href="#1-AcWing-803-区间合并" class="headerlink" title="1. AcWing 803. 区间合并"></a><a href="https://www.acwing.com/problem/content/805/">1. AcWing 803. 区间合并</a></h3><p>给定 n 个区间 $[l_i,r_i]$，要求合并所有有交集的区间。注意如果在端点处相交，也算有交集。输出合并完成后的区间个数。</p>
<p>例如：[1,3] 和 [2,6] 可以合并为一个区间 [1,6]。</p>
<blockquote>
<p>模板题</p>
</blockquote>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">vector</span>&lt;PII&gt; segs;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;PII&gt; res;<br><br>    sort(segs.begin(), segs.end());<br><br>    <span class="hljs-keyword">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-comment">// // 循环里面的if语句是为了防止初始的st和ed，也就是st=-2e9 ed=-2e9被记录下来</span><br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = max(ed, seg.second);<br>    &#125;<br><br>    <span class="hljs-comment">// 防止输入空的区间</span><br>    <br>    <span class="hljs-comment">// 循环外面的if语句则是为了当n=0时，不进行最后一个区间的记录。</span><br>    <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br>    segs = res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <br>    &#123;<br>        <span class="hljs-keyword">int</span> l, r;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r;<br>        segs.push_back(&#123;l, r&#125;);<br>    &#125;<br><br>    merge(segs);<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; segs.size() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>&#125;<br></code></pre></td></tr></table></figure>
<p>也可以输出合并区间。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟哈希表</title>
    <url>/2022/04/23/%E6%A8%A1%E6%8B%9F%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="模拟哈希表-模板"><a href="#模拟哈希表-模板" class="headerlink" title="模拟哈希表 模板"></a>模拟哈希表 模板</h1><p>Hash表又称为散列表，<strong>一般由Hash函数(散列函数)与链表结构共同实现</strong>。与离散化思想类似，当要对若干复杂信息进行统计时，可以<strong>用Hash函数把这些复杂信息映射到一个容易维护的值域内</strong>。因为值域变简单、范围变小，有可能<strong>造成两个不同的原始信息被Hash函数映射为相同的值</strong>，所以需要<strong>处理这种冲突情况</strong>。</p>
<p>Note：离散化和哈希表都是把数据范围大的数，映射到一个小区间内。区别在于离散化强调“保序性”，即映射之前如果具有小于关系，映射之后仍需要保证小于关系。</p>
<h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220417213926.png" style="zoom: 43%;" /></p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>一般定义无穷大数都是 <code>inf=99999999</code>,或者 <code>0x7f ff ff ff</code>，但是有的时候inf过大，虽然保证了没有数超过它，但是在需要加上一个数的时候，<code>inf+a</code> 可能会导致溢出，最终变成一个负数。</p>
<p><code>0x3f3f3f3f</code> 的数量级是1e9的，（一般题不会给超过1e9的数），在把它当成无穷大的时候，两个 <code>0x3f3f3f3f</code> 相加的结果也不会爆int。所以这个数比较合适了。</p>
<p>如果开一个数组，让数组中每个元素的值都为这个无穷大时，可以使用 <code>memset(a, 0x3f, sizeof(a))</code>，它的效果就是int类型的4个字节中每个字节都是0x3f，最终这个元素的值也是 <code>0x3f3f3f3f</code>。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200003</span>, null = <span class="hljs-number">0x3f3f3f3f</span>;  <span class="hljs-comment">// 规定空指针为 null 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> h[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>    &#123;<br>        t ++ ;<br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;  <span class="hljs-comment">// 如果这个位置是空的, 则返回的是他应该存储的位置</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, op, &amp;x);<br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) h[find(x)] = x;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (h[find(x)] == null) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>
<h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>拉链法：建立一个邻接表结构, 以Hash函数的值域作为表头数组head，映射后的值相同的原始信息被分到同一类,构成一个链表接在对应的表头之后,链表的节点上可以保存原始信息。哈希函数相当于把 $10^{-9}～10^9$ 中的一个个数x压缩存放在N(质数)个链表中。因此第一步是对x取模，找到x对应的链表的头指针，再用头插法插入。</p>
<p>Hash表主要包括来两个基本操作:</p>
<ol>
<li>计算Hash函数的值.</li>
<li>定位到对应链表中依次遍历、比较。</li>
</ol>
<p>当Hash函数设计较好时，原始信息会被比较均匀地分配到各个表头之后，从而使每次查找，统计的时间降低到“原始信息总数除以表头数组长度”。若原始信息总数与表头数组长度都是O(N)级别且Hash函数分散均匀，几乎不产生冲突，那么每次查找，统计的时间复杂度期望为O(1).</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220417213906.png" alt=""></p>
<h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>$h[N]$ 我把它看作不同的头指针，记录第一个节点的下标。</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100003</span>;  <span class="hljs-comment">//  取大于1e5的第一个质数，取质数冲突的概率最小</span><br><br><span class="hljs-comment">// 开一个槽 h</span><br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;  <span class="hljs-comment">// 邻接表</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// c++ 中如果是负数 那他取模也是负的，所以 加N 再 %N 就一定是一个正数</span><br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span> (e[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);  <span class="hljs-comment">// 将槽先清空 空指针一般用 -1 来表示</span><br><br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, op, &amp;x);<br><br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) insert(x);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (find(x)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>
<h1 id="字符串哈希-模板"><a href="#字符串哈希-模板" class="headerlink" title="字符串哈希 模板"></a>字符串哈希 模板</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），将p进制转换为10进制，根据 mod Q 的余数，实现不同的字符串映射到不同的数字。</p>
<p>对形如 $X<em>1X_2X_3⋯X</em>{n−1}X_n$ 的字符串，采用字符的 ASCII 码乘上 P 的次方来计算哈希值。</p>
<ul>
<li>hash映射公式：$ (X<em>1×P^{n−1}+X_2×P^{n−2}+⋯+X</em>{n−1}×P^1+X_n×P^0)modQ$</li>
</ul>
<p>注意点：</p>
<ol>
<li>任意字符不可以映射成0，否则会出现不同的字符串都映射成0的情况，比如A，AA，AAA皆为0</li>
<li>冲突问题：通过巧妙设置P (131 或 13331) , Q ($2^{64}$) 的值，一般情况下可以理解为不产生冲突。</li>
</ol>
<p><strong>问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220418114327.png" alt=""></p>
<ul>
<li>$h[i]$ ：前i个字符的hash值</li>
<li>$p[i]$：我觉得是 P 的 i 次幂，e.g. $p[2]$ 是 p 的 2次幂，$p[0]$ 是 p 的 0次幂，要初始化为1</li>
</ul>
<p>求一个字符串的哈希值就相当于求前缀和，初始化前缀和：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];  <span class="hljs-comment">// 前缀和求整个字符串的哈希值</span><br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;  <span class="hljs-comment">// 存P的i次幂，为了后面计算区间和，保持相同最高位。</span><br>&#125; <br></code></pre></td></tr></table></figure>
<p>求一个字符串的子串哈希值就相当于求部分和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>区间和公式 $h[l,r]=h[r]−h[l−1]×p[r−l+1]$</li>
</ul>
<p>区间和公式的理解：举栗，求 DEF 的哈希值，ABCDEF 与 ABC 的前三个字符值是一样，只差三位，乘上 P 的 3次幂 把 ABC 变为 ABC000，再用 ABCDEF - ABC000 得到 DE 的哈希值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220419094029.png" alt=""></p>
<h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ULL;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, P = <span class="hljs-number">131</span>;  <span class="hljs-comment">//131 13331</span><br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">char</span> str[N];<br>ULL h[N], p[N];<br><br><span class="hljs-comment">// h[i]前i个字符的hash值</span><br><span class="hljs-comment">// 使用场景： 两个字符串的子串是否相同</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str + <span class="hljs-number">1</span>);<br><br>    <br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// P的0次幂初始化为1</span><br>    h[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 字符串从1开始编号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];  <span class="hljs-comment">//前缀和求整个字符串的哈希值</span><br>        p[i] = p[i - <span class="hljs-number">1</span>] * P;  <span class="hljs-comment">// 存 P的i次幂，为了后面保持相同位</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> l1, r1, l2, r2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);<br><br>        <span class="hljs-keyword">if</span> (get(l1, r1) == get(l2, r2)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="C-哈希表"><a href="#C-哈希表" class="headerlink" title="C++ 哈希表"></a>C++ 哈希表</h1><p>unordered_map是C++中的哈希表，可以在任意类型与类型之间做映射。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol>
<li>引用头文件(C++11)：<code>#include &lt;unordered_map&gt;</code></li>
<li>定义：<code>unordered_map&lt;int,int&gt;、unordered_map&lt;string, double&gt; ...</code></li>
<li>插入：<code>hash[key] = value</code>；例如将<code>(&quot;ABC&quot; -&gt; 5.45)</code> 插入 <code>unordered_map&lt;string, double&gt; hash</code>中，<code>hash[&quot;ABC&quot;]=5.45</code></li>
<li>查询：<code>hash[&quot;ABC&quot;]</code> 会返回 5.45。(<code>hash[key] = value</code>)</li>
<li>判断key是否存在：<code>hash.count(&quot;ABC&quot;) != 0</code> 或 <code>hash.find(&quot;ABC&quot;) != hash.end()</code></li>
<li>遍历</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : hash)<br>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; item.first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; item.second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">double</span>&gt;::iterator it = hash.begin(); it != hash.end(); it ++ )<br>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><p>如果想让自定义的class作为key（unordered_map<key,value>）来使用unordered_map，需要实现：</p>
<ol>
<li>哈希函数，需要实现一个class重载operator()，将自定义class变量映射到一个size_t类型的数。一般常用std::hash模板来实现。</li>
<li>判断两个自定义class类型的变量是否相等的函数，一般在自定义class里重载operator==。<br>示例代码：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> first;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; second;<br><br>    <span class="hljs-comment">// 重载等号，判断两个Myclass类型的变量是否相等</span><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-keyword">const</span> Myclass &amp;other) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> first == other.first &amp;&amp; second == other.second;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 实现Myclass类的hash函数</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span><br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;&gt;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;</span>Myclass&gt;<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Myclass &amp;k)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">int</span> h = k.first;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : k.second)<br>            &#123;<br>                h ^= x;<br>            &#125;<br>            <span class="hljs-keyword">return</span> h;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">unordered_map</span>&lt;Myclass, <span class="hljs-keyword">double</span>&gt; S;<br>    Myclass a = &#123; <span class="hljs-number">2</span>, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; &#125;;<br>    Myclass b = &#123; <span class="hljs-number">3</span>, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; &#125;;<br>    S[a] = <span class="hljs-number">2.5</span>;<br>    S[b] = <span class="hljs-number">3.123</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; S[a] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; S[b] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">5</span> <span class="hljs-number">3</span>.<span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-LeetCode-1-两数之和"><a href="#1-LeetCode-1-两数之和" class="headerlink" title="1. LeetCode 1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. LeetCode 1. 两数之和</a></h2><blockquote>
<p>题目样例：</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
</blockquote>
<h3 id="算法1-暴力枚举-o-n-2"><a href="#算法1-暴力枚举-o-n-2" class="headerlink" title="算法1 暴力枚举 $o(n^2)$"></a>算法1 暴力枚举 $o(n^2)$</h3><p>暴力枚举方法很简单：两重循环枚举下标 $i,j$，然后判断 $nums[i]+nums[j]$ 是否等于 $target$。</p>
<p>时间复杂度：由于有两重循环，所以复杂度是 $O(n^2)$.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target)<br>                &#123;<br>                    res = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(&#123;j, i&#125;);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (res.size() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="算法2-哈希表-O-n"><a href="#算法2-哈希表-O-n" class="headerlink" title="算法2 (哈希表) $O(n)$"></a>算法2 (哈希表) $O(n)$</h3><p>使用C++中的哈希表——<a href="https://www.acwing.com/blog/content/9/"><code>unordered_map hash</code></a>.</p>
<p>循环一遍 nums 数组，在每步循环中我们做两件事：</p>
<ol>
<li>判断 $target−nums[i]$ 是否在哈希表中；</li>
<li>将 $nums[i]$ 插入哈希表中。<strong>哈希表的key是 $nums[i]$，值是下标位置。</strong></li>
</ol>
<p>解释：由于数据保证有且仅有一组解，假设是 $i,j$，则我们循环到 $j$ 时，$nums[i]$ 一定在哈希表中，且有 $nums[i]+nums[j]==target$， 所以我们一定可以找到解。</p>
<p>时间复杂度：由于只扫描一遍，且哈希表的插入和查询操作的复杂度是 $O(1)$，所以总时间复杂度是 $O(n)$.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> another = target - nums[i];<br>            <span class="hljs-keyword">if</span> (hash.count(another))<br>            &#123;<br>                res = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(&#123;hash[another], i&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            hash[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟堆</title>
    <url>/2022/04/21/%E6%A8%A1%E6%8B%9F%E5%A0%86/</url>
    <content><![CDATA[<h1 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h1><p>堆是一棵完全二叉树。模拟堆用一维数组存储，数组方法可以删除/修改堆中的任意元素，这是相较于 STL 中的优先队列的优势。对于数组，直接在末尾进行添加或者删除更方便，所以可将添加或者删除的数和末尾联系起来。</p>
<p>需要注意的是：由于修改，删除等操作对堆的调整，使得数的坐标与第k个插入对应不上，所以需要额外开<strong>两个数组存储二者之间的对应关系</strong>。</p>
<blockquote>
<p>堆的坐标是一直不动的。(想象成空壳子，我之前搞错了这个T_T)</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>以小根堆为例。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220415133832.png"  style="zoom: 40%;" /></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>关于堆有两个基本操作： $up(u)$ 和 $down(u)$ ，对 堆中 下标为 $u$ 的数上调或者下调。</p>
<h4 id="up-u"><a href="#up-u" class="headerlink" title="$up(u)$"></a>$up(u)$</h4><p>节点向上调整。只要根节点存在，并且 u 这个节点的值 比 根节点小，就需要交换，坐标就上移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        swap(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="down-u"><a href="#down-u" class="headerlink" title="$down(u)$"></a>$down(u)$</h4><p>节点向下调整。该节点与左子节点比较一次，将自己变成较小的。再和右子节点比较一次，将自己变成较小的。经过两次比较和调整，将成为3个节点中最小的。完成了这个小根堆的调整。然后进行递归即可。当 $u == t$，说明这个点已经到了位置，递归就结束了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">int</span> t = u;  <span class="hljs-comment">// t 记录三个点中最小的数的下标</span><br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= heap_size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= heap_size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        swap(u, t);<br>        down(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="1-插入一个数"><a href="#1-插入一个数" class="headerlink" title="1. 插入一个数"></a>1. 插入一个数</h4><p>把这个数加到末尾，然后 up 调整他的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">heap[ ++ size] = x;<br>up(size);<br></code></pre></td></tr></table></figure>
<h4 id="2-求集合中的最小值"><a href="#2-求集合中的最小值" class="headerlink" title="2. 求集合中的最小值"></a>2. 求集合中的最小值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">heap[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>
<h4 id="3-删除最小值"><a href="#3-删除最小值" class="headerlink" title="3. 删除最小值"></a>3. 删除最小值</h4><p>删除数组的头很费劲，但是删除尾很容易。用末尾的值覆盖最小值，然后将末尾的值 down 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">heap[<span class="hljs-number">1</span>] = heap[size];<br>size -- ;<br>down(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<h4 id="4-删除任意元素"><a href="#4-删除任意元素" class="headerlink" title="4. 删除任意元素"></a>4. 删除任意元素</h4><p>同删除头，就是用末尾的值覆盖 idx 位置的元素。idx 位置的元素被替换后，有三种情况：和它相等；比它大，应该往上走；比它小，应该往上走。其实可以不用分情况，直接 down up都做一遍，因为操作里面已经包括了判断条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">heap[idx] = heap[size];<br>size -- ;<br>up(idx);<br>down(idx);<br></code></pre></td></tr></table></figure>
<h4 id="5-修改任意元素"><a href="#5-修改任意元素" class="headerlink" title="5. 修改任意元素"></a>5. 修改任意元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">heap[idx] = x;<br>up(idx);<br>down(idx);<br></code></pre></td></tr></table></figure>
<h3 id="第k个插入的数-和-数组下标-idx-的关系"><a href="#第k个插入的数-和-数组下标-idx-的关系" class="headerlink" title="第k个插入的数 和 数组下标 idx 的关系"></a>第k个插入的数 和 数组下标 idx 的关系</h3><p>Review: </p>
<ul>
<li><p>单链表：头节点初始为 $-1$，所以第1个插入的数下标为0，所以 $k - 1 = idx$</p>
</li>
<li><p>双链表：左右头节点分别初始为 $0$ 和 $1$，所以第1个插入的数下标为2，所以 $k + 1 = idx$</p>
</li>
</ul>
<p>那堆呢？堆排序不需要修改中间元素的值。但，当需要修改中间某个元素的值时，如果我们<strong>需要自己定位中间元素的位置</strong>，那就需要<strong>自己写 heap_swap 维护 数值的坐标 和 第 k 个插入 的映射关系。</strong> </p>
<blockquote>
<p><strong>Note: </strong> 堆数组中的 idx 是不变的。</p>
</blockquote>
<p>比如说：<code>h[k] = x</code>，h 数组存的是结点的值，按理来说应该 <code>h[idx]</code> 来存，但是结点位置总是在变的，因此可以维护 k 和 idx 的映射关系：</p>
<ul>
<li><strong>$ph[k] = idx$：第 k 个插入的数，在堆中的下标为 idx</strong></li>
<li><strong>$hp[idx] = k$：堆中下标为 idx 的，是 第 k 个插入的数</strong></li>
</ul>
<p>这样，节点的下标是 $ph[k]$，值为 $h[ph[k]] = x$，儿子分别是 $ph[k] <em> 2$ 和 $ph[k] </em> 2 + 1$</p>
<p>为什么要有一个 hp 数组呢？</p>
<p>原因就在于在<code>swap</code>操作中我们输入是<u>堆数组的下标</u>，无法知道每个堆数组的 $idx$ 下标对应是 第 k 个插入，所以需要 $hp$ 数组方便查找 $idx$。</p>
<p><strong>Note：</strong> a，b 是堆数组元素的下标。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    swap(ph[hp[a]], ph[hp[b]]); <br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="举例：堆中的插入操作"><a href="#举例：堆中的插入操作" class="headerlink" title="举例：堆中的插入操作"></a>举例：堆中的插入操作</h3><p><strong>注意：</strong> 在堆这个数据结构中，数据的插入都是插入到堆尾，然后再<code>up</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;i&quot;</span>)<br>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    size ++ ;  <span class="hljs-comment">// 整个堆的长度</span><br>    k ++ ;  <span class="hljs-comment">// 第 k 个插入</span><br>    h[size] = x;  <span class="hljs-comment">// 在堆尾添加元素</span><br>    ph[k] = size, hp[size] = k;  <span class="hljs-comment">// 存入映射关系</span><br>    up(size);  <span class="hljs-comment">// 调整堆尾元素的位置</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="举例：删除第-k-个插入元素"><a href="#举例：删除第-k-个插入元素" class="headerlink" title="举例：删除第 k 个插入元素"></a>举例：删除第 k 个插入元素</h3><p>删除操作，三个步骤：</p>
<ol>
<li><p><strong>找到第 k 个插入元素在堆数组中的位置（堆数组下标）：$ph[k]$</strong></p>
</li>
<li><p>与堆尾元素交换：$swap$</p>
</li>
<li><p>在原来第 k 个元素所在的位置进行 down 和 up 操作。<strong>（up，down，swap操作的都输入都是下标）</strong></p>
<p>需要调整的是 <strong>原来第 $k$ 的元素所在的位置</strong>，由于交换完后的 $ph[k]$ 值变了，变为堆尾的下标了，所以必须要在之前保存 $ph[k]$ 的值</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;D&quot;</span>)<br>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;idx);<br>    <span class="hljs-comment">// 第k个插入的数的坐标不是ph[k]了，但是我们要调整的是 原来第k个插入的数的位置，所以需要记录</span><br>    k = ph[k];  <span class="hljs-comment">// origin_k 是之前记录被删除的结点的下标</span><br>    heap_swap(k, size);  <br>    size -- ;<br>    up(k);<br>    down(k);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="举例：修改第-k-个插入元素"><a href="#举例：修改第-k-个插入元素" class="headerlink" title="举例：修改第 k 个插入元素"></a>举例：修改第 k 个插入元素</h3><p>修改第 k 个插入元素：</p>
<ol>
<li><strong>找到 第 k 个插入元素对应的 idx：$ph[k]$</strong></li>
<li>$h[ph[k]] = x$</li>
<li>调整</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;C&quot;</span>)<br>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);<br>    h[ph[k]] = x;<br>    up(ph[k]);<br>    down(ph[k]);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-839-模拟堆"><a href="#1-AcWing-839-模拟堆" class="headerlink" title="1. AcWing 839. 模拟堆"></a><a href="https://www.acwing.com/problem/content/841/">1. AcWing 839. 模拟堆</a></h3><p>考察优先队列（堆）的实现原理（手写）。</p>
<blockquote>
<p>模板题</p>
</blockquote>
<p>模拟一下样例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220415155138.png" style="zoom: 50%;" /></p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> h[N], ph[N], hp[N], cnt;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    swap(ph[hp[a]],ph[hp[b]]);<br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        heap_swap(u, t);<br>        down(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        heap_swap(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">int</span> k, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;I&quot;</span>))<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>            cnt ++ ;<br>            m ++ ;<br>            ph[m] = cnt, hp[cnt] = m;<br>            h[cnt] = x;<br>            up(cnt);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;PM&quot;</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, h[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;DM&quot;</span>))<br>        &#123;<br>            heap_swap(<span class="hljs-number">1</span>, cnt);<br>            cnt -- ;<br>            down(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;D&quot;</span>))<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>            k = ph[k];<br>            heap_swap(k, cnt);<br>            cnt -- ;<br>            up(k);<br>            down(k);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);<br>            k = ph[k];<br>            h[k] = x;<br>            up(k);<br>            down(k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-AcWing-838-堆排序"><a href="#2-AcWing-838-堆排序" class="headerlink" title="2. AcWing 838. 堆排序"></a><a href="https://www.acwing.com/problem/content/840/">2. AcWing 838. 堆排序</a></h3><h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><p>1、堆排序不需要修改中间元素的值。当需要修改中间某个元素的值时，如果我们需要自己定位中间元素的位置，那就需要用heap_swap自己维护数值和堆中节点的映射关系。</p>
<p>2、建堆：从n / 2开始向前。i 为什么从n/2开始down？</p>
<p>从 i 开始的这个 i 节点需要满足的性质：</p>
<ol>
<li><p>左右儿子满足堆的性质。</p>
</li>
<li><p>下标最大（因为要往上遍历）</p>
</li>
<li><p>不是叶结点（叶节点一定满足堆的性质）</p>
</li>
</ol>
<p>这样的节点就是倒数第二层的第n/2个点开始，倒序遍历。</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> h[N];<br><span class="hljs-keyword">int</span> heap_size;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = u;  <span class="hljs-comment">// t是三个点中最小的点的下标</span><br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> &lt;= heap_size &amp;&amp; h[<span class="hljs-number">2</span> * u] &lt; h[t]) t = <span class="hljs-number">2</span> * u;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= heap_size &amp;&amp; h[<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span> *u + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">if</span>(u != t)<br>    &#123;<br>        swap(h[t], h[u]);<br>        down(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">cin</span> &gt;&gt; h[i];  <span class="hljs-comment">//下标从1开始，也就是根节点,下标为1</span><br>    <br>    heap_size = n;<br>    <br>    <span class="hljs-comment">// 建堆</span><br>    <span class="hljs-comment">// 进行down(i)时需要保证i的左右两个儿子都已经满足堆的性质。从n / 2开始向前做，相当于从整棵二叉树的最后一层开始往上做，那么是可以保证这个性质的。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = heap_size / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i -- ) down(i);<br>    <br>    <span class="hljs-comment">// 堆排序就是先输出堆顶，再删掉堆顶</span><br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, h[<span class="hljs-number">1</span>]);<br>        h[<span class="hljs-number">1</span>] = h[heap_size];<br>        heap_size -- ;<br>        down(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/2022/04/01/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    <content><![CDATA[<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>离散化的作用是：是<strong>映射</strong>，<strong>将间隔很大的点，映射到相邻的数组元素中</strong>。减少对空间的需求，也减少计算量。</p>
<ul>
<li>如何映射？ </li>
</ul>
<p>定义一个 $find()$ 函数，输入离散数组的位置(映射前的位置)，返回连续数组的位置(映射后的位置<strong>+1</strong>，为了前缀和数组)</p>
<blockquote>
<p>定义 $x$ 是原下标，$c$ 是在 $x$ 的位置存入的数字。</p>
</blockquote>
<p>如何能够将不连续的点映射到连续的数组的下标？解决办法就是<strong>开辟额外的数组存放原来的数组下标</strong>，然后接下来的操作都是映射后的新坐标和数字的操作。设 $idx$ 是 $x$ 的下标，新映射数组 $alls[idx] = x$ </p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220410163235.png" style="zoom: 50%;" /></p>
<p>找 <code>alls</code> 数组里的数 对应的下标，这不是<strong>二分查找</strong>吗！查找 $&gt;=x$ 的最小值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// “映射”: 把add数组的下标x映射到下标的下标</span><br><span class="hljs-comment">// find(): 输入一个离散数组的位置（映射前的位置）x, 返回连续数组的位置+1（映射后的位置+1）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = alls.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid] &gt;= x) r = mid;  <span class="hljs-comment">// 这个地方总写错！alls数组</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 前缀和从1开始</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><font color='red'>**Note：是 alls 数组，总是写错！**</font>



</li>
</ul>
<p><strong>总结离散化步骤：</strong></p>
<ol>
<li><p>先存 数字和下标 <code>adds&#123;x, c&#125;</code>，把下标存入 <code>alls</code></p>
<p> 再存入 查询区间 <code>query&#123;l, r&#125;</code>，把左右点也放入 <code>alls</code></p>
</li>
<li><p>对 存入的下标和查询左右下标，进行排序</p>
<p>然后删掉重复的点（为了后边计算前缀和）</p>
</li>
<li><p>add，将离散的点 <code>alls[]</code> 通过<strong>二分</strong> <strong>映射</strong>到密集的下标，将数字存入映射后的新下标的数组</p>
</li>
<li><p>计算新的密集坐标对应的前缀和</p>
</li>
<li><p>用前缀和计算区间和，使用映射后的坐标计算 $s[r]-s[l-1]$</p>
</li>
</ol>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-802-区间和"><a href="#1-AcWing-802-区间和" class="headerlink" title="1. AcWing 802. 区间和"></a><a href="https://www.acwing.com/problem/content/804/">1. AcWing 802. 区间和</a></h3><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p>
<p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p>
<p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p>
<blockquote>
<p>模板题</p>
</blockquote>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e6</span> + <span class="hljs-number">10</span>;  <span class="hljs-comment">// 前缀和的原因，还有两个查询的点要存入</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; alls;<br><span class="hljs-built_in">vector</span>&lt;PII&gt; add, query;<br><br><span class="hljs-keyword">int</span> a[N], s[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-comment">// 找alls 数组里的数 对应的下标，这不是二分查找吗！</span><br><span class="hljs-comment">// “映射”：把add数组的下标x映射到下标的下标</span><br><span class="hljs-comment">// find(): 输入一个离散数组的位置（映射前的位置）x, 返回连续数组的位置+1（映射后的位置+1）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = alls.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid] &gt;= x) r = mid;  <span class="hljs-comment">// 这个地方总写错！alls数组</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-comment">// 1. 处理输入，&#123;x, c&#125;存到 add 数组；alls数组存储 x 下标</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; c;<br>        <br>        add.push_back(&#123;x, c&#125;);<br>        <br>        alls.push_back(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 1. 处理查询，&#123;l, r&#125;存到 query 数组；alls数组存储 l, r 下标</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> l, r;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r;<br>        <br>        query.push_back(&#123;l, r&#125;);<br>        <br>        alls.push_back(l);<br>        alls.push_back(r);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 排序；去重</span><br>    sort(alls.begin(), alls.end());<br>    alls.erase(unique(alls.begin(), alls.end()), alls.end());<br>    <br>    <span class="hljs-comment">// 3. 执行“添加”，将数c加入到映射过后的新数组a[x] (新的下标x)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item: add)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x = find(item.first);<br>        a[x] += item.second;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 预处理新数组a[]的前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= alls.size(); i ++ ) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>    <br>    <span class="hljs-comment">// 5. 执行“查询”，通过l，r找到映射后的新坐标，算前缀和即可。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item: query)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l = find(item.first), r = find(item.second);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; s[r] - s[l - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>mySQL</title>
    <url>/2022/04/15/mySQL/</url>
    <content><![CDATA[<h1 id="mySQL"><a href="#mySQL" class="headerlink" title="mySQL"></a>mySQL</h1><h2 id="0-数据库常见概念"><a href="#0-数据库常见概念" class="headerlink" title="0. 数据库常见概念"></a>0. 数据库常见概念</h2><h3 id="0-1-概念"><a href="#0-1-概念" class="headerlink" title="0.1 概念"></a>0.1 概念</h3><p><strong>数据库：</strong>英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。</p>
<p><strong>数据库管理系统：</strong>DataBaseManagement，简称DBMS。数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。</p>
<p><strong>常见的数据库管理系统：</strong>MySQL、Oracle、MS SqlServer、DB2、sybase等….</p>
<p><strong>SQL：结构化查询语言</strong>。通过编写SQL语句，然后DBMS负责执行SQL语句，最终来完成数据库中数据的增删改查操作。</p>
<p>SQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，<br>同时在Oracle中也可以使用，在DB2中也可以使用。</p>
<p><strong>三者之间的关系？</strong>DBMS—&gt; 执行—&gt; SQL —操作—&gt; DB</p>
<h3 id="0-2-SQL语句分类"><a href="#0-2-SQL语句分类" class="headerlink" title="0.2 SQL语句分类"></a>0.2 SQL语句分类</h3><p><strong>DQL：</strong>数据查询语言（凡是带有sel        ect关键字的都是查询语句）</p>
<ul>
<li>select…        </li>
</ul>
<p><strong>DML：</strong>数据操作语言（凡是对表当中的数据进行增删改的都是DML）insert delete update。这个主要是操作表中的数据data。</p>
<ul>
<li>insert 增</li>
<li>delete 删</li>
<li>update 改</li>
</ul>
<p><strong>DDL：</strong>数据定义语言（凡是带有create、drop、alter的都是DDL。）这个增删改和DML不同，这个主要是对表结构进行操作。</p>
<ul>
<li>DDL主要操作的是表的结构。不是表中的数据。</li>
<li>create：新建，等同于增</li>
<li>drop：删除</li>
<li>alter：修改</li>
</ul>
<p><strong>TCL：</strong>事务控制语言。</p>
<ul>
<li>事务提交：commit;</li>
<li>事务回滚：rollback;</li>
</ul>
<p><strong>DCL：</strong>是数据控制语言。</p>
<ul>
<li>授权grant</li>
<li>撤销权限revoke</li>
<li>….</li>
</ul>
<h3 id="0-3-mySQL中的数据类型"><a href="#0-3-mySQL中的数据类型" class="headerlink" title="0.3 mySQL中的数据类型"></a>0.3 mySQL中的数据类型</h3><p><strong>varchar(最长255)</strong>：可变长度的字符串，比较智能，节省空间。会根据实际的数据长度动态分配空间。</p>
<ul>
<li>优点：节省空间</li>
<li>缺点：需要动态分配空间，速度慢。</li>
</ul>
<p><strong>char(最长255)</strong>：定长字符串，不管实际的数据长度是多少，分配固定长度的空间去存储数据。使用不恰当的时候，可能会导致空间的浪费。</p>
<ul>
<li>优点：不需要动态分配空间，<strong>速度快。</strong>​</li>
<li>缺点：使用不当可能会导致空间的浪费。</li>
</ul>
<p><strong>varchar和char我们应该怎么选择？</strong></p>
<ul>
<li>性别字段你选什么？因为性别是固定长度的字符串，所以选择char。<br>​</li>
<li>姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。</li>
</ul>
<p><strong>int(最长11)</strong>：数字中的整数型。等同于java的int。</p>
<p><strong>bigint</strong>：数字中的长整型。等同于java中的long。</p>
<p><strong>float</strong>：单精度浮点型数据</p>
<p><strong>double</strong>：双精度浮点型数据</p>
<p><strong>date</strong>：短日期类型</p>
<p><strong>datetime</strong>：长日期类型</p>
<p><strong>clob</strong>：字符大对象。最多可以存储4G的字符串。<br>比如：存储一篇文章，存储一个说明。超过255个字符的都要采用CLOB字符大对象来存储。<br>Character Large OBject:CLOB</p>
<p><strong>blob</strong>：二进制大对象。Binary Large OBject。专门用来存储图片、声音、视频等流媒体数据。<br>往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，你需要使用IO流才行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">t_movie 电影表（专门存储电影信息的）<br>编号<span class="hljs-keyword">no</span>(<span class="hljs-type">bigint</span>)	名字name(<span class="hljs-type">varchar</span>)		故事情节history(<span class="hljs-type">clob</span>)	<br>上映日期playtime(<span class="hljs-type">date</span>)		时长<span class="hljs-type">time</span>(<span class="hljs-keyword">double</span>)		海报image(<span class="hljs-type">blob</span>)<br>类型type(<span class="hljs-type">char</span>)							<br></code></pre></td></tr></table></figure>
<h3 id="0-4-SQL脚本的执行"><a href="#0-4-SQL脚本的执行" class="headerlink" title="0.4 SQL脚本的执行"></a>0.4 SQL脚本的执行</h3><p>xxxx.sql 这种文件被称为sql脚本文件。</p>
<p>sql脚本文件中编写了大量的sql语句。</p>
<p>我们执行sql脚本文件的时候，该文件中所有的sql语句会全部执行！批量的执行SQL语句，可以使用sql脚本文件。</p>
<p><code>mysql&gt; source D:\course\03-MySQL\document\vip.sql</code></p>
<blockquote>
<p>你在实际的工作中，第一天到了公司，项目经理会给你一个xxx.sql文件，你执行这个脚本文件，你电脑上的数据库数据就有了！</p>
</blockquote>
<h3 id="0-5-数据库和表的导入导出"><a href="#0-5-数据库和表的导入导出" class="headerlink" title="0.5 数据库和表的导入导出"></a>0.5 数据库和表的导入导出</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">数据导出？<br>	注意：在windows的dos命令窗口中：<br>		mysqldump bjpowernode<span class="hljs-operator">&gt;</span>D:\bjpowernode.sql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p123456<br>	可以导出指定的表吗？<br>		mysqldump bjpowernode emp<span class="hljs-operator">&gt;</span>D:\bjpowernode.sql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p123456<br><br>数据导入？<br>	注意：需要先登录到mysql数据库服务器上。<br>	然后创建数据库：<span class="hljs-keyword">create</span> database bjpowernode;<br>	使用数据库：use bjpowernode<br>	然后初始化数据库：source D:\bjpowernode.sql<br></code></pre></td></tr></table></figure>
<h2 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1. 数据库操作"></a>1. 数据库操作</h2><p><strong>show databases;</strong>     查看mysql中有哪些数据库</p>
<p><strong>use test;</strong>    表示正在使用一个名字叫做test的数据库。</p>
<p><strong>create database db01;</strong>    创建数据库</p>
<p><strong>show tables;</strong>     查看某个数据库下有哪些表</p>
<p><strong>select version();</strong>    查看mysql数据库的版本号</p>
<p><strong>select database();</strong>    查看当前使用的是哪个数据库</p>
<p><strong>\c</strong>    用来终止一条命令的输入。</p>
<h2 id="2-建表操作"><a href="#2-建表操作" class="headerlink" title="2. 建表操作"></a>2. 建表操作</h2><h3 id="2-1-创建一个表create"><a href="#2-1-创建一个表create" class="headerlink" title="2.1 创建一个表create"></a>2.1 创建一个表create</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">学号、姓名、年龄、性别、邮箱地址<br>	<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>        <span class="hljs-keyword">no</span> <span class="hljs-type">int</span>,<br>        name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>),<br>        sex <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>        age <span class="hljs-type">int</span>(<span class="hljs-number">3</span>),<br>        email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>    );<br></code></pre></td></tr></table></figure>
<h3 id="2-2-删除一个表drop"><a href="#2-2-删除一个表drop" class="headerlink" title="2.2 删除一个表drop"></a>2.2 删除一个表drop</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_student; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 当这张表不存在的时候会报错！<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 如果这张表存在的话，删除<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_student;<br></code></pre></td></tr></table></figure>
<ul>
<li>对表结构的修改需要使用：<strong>alter</strong>属于DDL语句</li>
<li><strong>desc</strong> t_student    查看表结构</li>
</ul>
<h3 id="2-3-插入数据insert"><a href="#2-3-插入数据insert" class="headerlink" title="2.3 插入数据insert"></a>2.3 插入数据insert</h3><ul>
<li>insert into 表名(字段名1,字段名2,字段名3…) values(值1,值2,值3);</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-keyword">no</span>,name,sex,age,email)<br>	<span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;zhangsan@123.com&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(email,name,sex,age,<span class="hljs-keyword">no</span>)<br>	<span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;lisi@123.com&#x27;</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(<span class="hljs-keyword">no</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>省略字段名<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;lisi@123.com&#x27;</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>insert 语句但凡是执行成功了，那么必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。</li>
</ul>
<p><strong>一次插入多条数据</strong></p>
<ul>
<li>insert into t_user(字段名1,字段名2) values(),(),(),();</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user(id,name,birth,create_time) <span class="hljs-keyword">values</span><br>		(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-string">&#x27;1980-10-11&#x27;</span>,now()), <br>		(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;1981-10-11&#x27;</span>,now()),<br>		(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;wangwu&#x27;</span>,<span class="hljs-string">&#x27;1982-10-11&#x27;</span>,now());<br></code></pre></td></tr></table></figure>
<h3 id="2-4-修改数据update"><a href="#2-4-修改数据update" class="headerlink" title="2.4 修改数据update"></a>2.4 修改数据update</h3><ul>
<li><p>update 表名 set 字段名1=值1,字段名2=值2,字段名3=值3… where 条件;</p>
</li>
<li><p>没有条件限制会导致所有数据全部更新。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> t_user <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;jack&#x27;</span>, birth <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2000-10-11&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">update</span> t_user <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;jack&#x27;</span>, birth <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2000-10-11&#x27;</span>, create_time <span class="hljs-operator">=</span> now() <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>
<h3 id="2-5-删除数据"><a href="#2-5-删除数据" class="headerlink" title="2.5 删除数据"></a>2.5 删除数据</h3><p><strong>delete</strong>语句删除数据的原理？（delete属于DML语句！！！）</p>
<ul>
<li>表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！</li>
<li>这种删除缺点是：删除效率比较低。</li>
<li>这种删除优点是：支持回滚，后悔了可以再恢复数据！！！</li>
</ul>
<p><strong>truncate</strong>语句删除数据的原理？</p>
<ul>
<li>这种删除效率比较高，表被一次截断，物理删除。</li>
<li>这种删除缺点：不支持回滚。</li>
<li>这种删除优点：快速。</li>
</ul>
<h4 id="2-5-1-delete"><a href="#2-5-1-delete" class="headerlink" title="2.5.1 delete"></a>2.5.1 delete</h4><ul>
<li>delete from 表名 where 条件;</li>
<li><p>没有条件，整张表的数据会全部删除！</p>
</li>
<li><p>delete from t_user where id = 2;</p>
</li>
</ul>
<h4 id="2-5-2-truncate"><a href="#2-5-2-truncate" class="headerlink" title="2.5.2 truncate"></a>2.5.2 truncate</h4><ul>
<li>truncate table dept_bak; （这种操作属于DDL操作。）</li>
</ul>
<p>下列演示内容所用表</p>
<p><img src="C:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220415214055230.png" alt="image-20220415214055230"></p>
<h2 id="3-单表查询"><a href="#3-单表查询" class="headerlink" title="3. 单表查询"></a>3. 单表查询</h2><h3 id="3-1-基础条件查询"><a href="#3-1-基础条件查询" class="headerlink" title="3.1 基础条件查询"></a>3.1 基础条件查询</h3><ul>
<li>select  字段1,字段2,字段3….  from   表名  where  条件;</li>
</ul>
<p><strong>= 等于</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询薪资等于<span class="hljs-number">800</span>的员工姓名和编号？<br>	<span class="hljs-keyword">select</span> empno,ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">=</span> <span class="hljs-number">800</span>;<br>查询SMITH的编号和薪资？<br>	<span class="hljs-keyword">select</span> empno,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SMITH&#x27;</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>字符串使用单引号<br></code></pre></td></tr></table></figure>
<p><strong>&lt;&gt;或!= 不等于</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询薪资不等于<span class="hljs-number">800</span>的员工姓名和编号？<br>	<span class="hljs-keyword">select</span> empno,ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">!=</span> <span class="hljs-number">800</span>;<br>	<span class="hljs-keyword">select</span> empno,ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">800</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 小于号和大于号组成的不等号<br></code></pre></td></tr></table></figure>
<p><strong>&lt; 小于</strong>  <strong>&lt;= 小于等于</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询薪资小于等于<span class="hljs-number">3000</span>的员工姓名和编号？<br>	<span class="hljs-keyword">select</span> empno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3000</span>;<br></code></pre></td></tr></table></figure>
<p><strong>(&gt;)大于 </strong>  <strong>(&gt;=) 大于等于</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询薪资大于等于<span class="hljs-number">3000</span>的员工姓名和编号？<br><span class="hljs-keyword">select</span> empno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3000</span>;<br></code></pre></td></tr></table></figure>
<p><strong>between … and ….</strong> 两个值之间, 等同于 &gt;= and &lt;=</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询薪资在<span class="hljs-number">2450</span>和<span class="hljs-number">3000</span>之间的员工信息？包括<span class="hljs-number">2450</span>和<span class="hljs-number">3000</span><br>	第一种方式：<span class="hljs-operator">&gt;=</span> <span class="hljs-keyword">and</span> <span class="hljs-operator">&lt;=</span> （<span class="hljs-keyword">and</span>是并且的意思。）<br>		<span class="hljs-keyword">select</span> empno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2450</span> <span class="hljs-keyword">and</span> sal <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3000</span>;	<br>    第二种方式：<br>    	<span class="hljs-keyword">select</span> empno,ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-keyword">between</span> <span class="hljs-number">2450</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3000</span>;	<br></code></pre></td></tr></table></figure>
<p><strong>is null 为 null（is not null 不为空）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询哪些员工的津贴<span class="hljs-operator">/</span>补助为<span class="hljs-keyword">null</span>？<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> empno,ename,sal,comm <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> comm <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>;<br><br>查询哪些员工的津贴<span class="hljs-operator">/</span>补助不为<span class="hljs-keyword">null</span>？<br>	<span class="hljs-keyword">select</span> empno,ename,sal,comm <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> comm <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure>
<p><strong>and 并且    or 或者</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> <span class="hljs-number">2500</span> <span class="hljs-keyword">and</span> (deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">or</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">20</span>);<br><br><span class="hljs-keyword">and</span>和<span class="hljs-keyword">or</span>同时出现，<span class="hljs-keyword">and</span>优先级较高。如果想让<span class="hljs-keyword">or</span>先执行，需要加“小括号”，以后在开发中，如果不确定优先级，就加小括号就行了。<br></code></pre></td></tr></table></figure>
<p><strong>in 包含，相当于多个 or （not in 不在这个范围中）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询工作岗位是MANAGER和SALESMAN的员工？<br>	<span class="hljs-keyword">select</span> empno,ename,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MANAGER&#x27;</span> <span class="hljs-keyword">or</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SALESMAN&#x27;</span>;<br>	<span class="hljs-keyword">select</span> empno,ename,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;MANAGER&#x27;</span>, <span class="hljs-string">&#x27;SALESMAN&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p><strong>not 可以取非，主要用在 is 或 in 中</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br><span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br><span class="hljs-keyword">in</span><br><span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span><br></code></pre></td></tr></table></figure>
<p><strong>like</strong>     </p>
<p>称为模糊查询，支持%或下划线匹配</p>
<ul>
<li>%匹配任意多个字符</li>
<li>下划线：任意一个字符。</li>
<li>（%是一个特殊的符号，_ 也是一个特殊符号）    </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">找出名字中含有O的？<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%O%&#x27;</span>;<br><br>找出名字中有“_”的？<br>	<span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> t_student <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%_%&#x27;</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>这样不行。<br><br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> t_student <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%\_%&#x27;</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> \转义字符。<br></code></pre></td></tr></table></figure>
<p><strong>distinct</strong></p>
<p>把查询结果去除重复记录【distinct】</p>
<ul>
<li>distinct 只能出现在所有字段的最前方。</li>
<li><p>distinct 出现在 job,deptno 两个字段之前，表示两个字段联合起来去重。</p>
</li>
<li><p>select distinct job from emp;</p>
</li>
<li>select distinct job,deptno from emp;</li>
</ul>
<h3 id="3-2-排序"><a href="#3-2-排序" class="headerlink" title="3.2 排序"></a>3.2 排序</h3><p>查询所有员工薪资，排序？</p>
<ul>
<li>select  ename,sal from emp order by sal; // 默认是升序！！！</li>
</ul>
<p>指定降序：<strong>desc</strong></p>
<ul>
<li>select  ename,sal from emp order by sal desc;</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排列。<br>	<span class="hljs-keyword">select</span> <br>		ename,sal<br>	<span class="hljs-keyword">from</span><br>		emp<br>	<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>		sal <span class="hljs-keyword">asc</span>, ename <span class="hljs-keyword">asc</span>;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。<br></code></pre></td></tr></table></figure>
<h3 id="3-3-分页"><a href="#3-3-分页" class="headerlink" title="3.3 分页"></a>3.3 分页</h3><ul>
<li><strong>limit</strong> 作用：将查询结果集的一部分取出来。通常使用在分页查询当中。<ul>
<li>完整用法：limit startIndex, length        startIndex是起始下标，length是长度。</li>
<li>起始下标从0开始。</li>
<li>缺省用法：limit 5; 这是取前5.</li>
</ul>
</li>
</ul>
<p><strong>按照薪资降序，取出排名在前5名的员工？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">	<span class="hljs-keyword">select</span> <br>		ename,sal<br>	<span class="hljs-keyword">from</span><br>		emp<br>	<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <br>		sal <span class="hljs-keyword">desc</span><br>	limit <span class="hljs-number">5</span>;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>取前<span class="hljs-number">5</span>	 limit <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<br><br>mysql当中limit在<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>之后执行！！！！！！<br></code></pre></td></tr></table></figure>
<p><strong>取出工资排名在[3-5]名的员工？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">	<span class="hljs-keyword">select</span> <br>		ename,sal<br>	<span class="hljs-keyword">from</span><br>		emp<br>	<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>		sal <span class="hljs-keyword">desc</span><br>	limit<br>		<span class="hljs-number">2</span>, <span class="hljs-number">3</span>;<br><span class="hljs-number">2</span>表示起始位置从下标<span class="hljs-number">2</span>开始，就是第三条记录。<br><span class="hljs-number">3</span>表示长度。<br></code></pre></td></tr></table></figure>
<ul>
<li><p>每页显示3条记录</p>
<ul>
<li>第1页：limit 0,3        [0 1 2]</li>
<li>第2页：limit 3,3        [3 4 5]</li>
<li>第3页：limit 6,3        [6 7 8]</li>
</ul>
</li>
<li><p>每页显示pageSize条记录</p>
<ul>
<li>第pageNo页：limit (pageNo - 1) * pageSize  , pageSize</li>
</ul>
</li>
</ul>
<h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><h3 id="4-1-单行处理函数"><a href="#4-1-单行处理函数" class="headerlink" title="4.1 单行处理函数"></a>4.1 单行处理函数</h3><ul>
<li>单行处理函数的特点：一个输入对应一个输出。<ul>
<li>和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">lower 转换小写<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">lower</span>(ename) <span class="hljs-keyword">as</span> ename <span class="hljs-keyword">from</span> emp;<br><br>upper 转换大写<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_student;<br><br>substr 取子串：substr(被截取的字符串, 起始下标, 截取的长度)<br>		<span class="hljs-keyword">select</span> substr(ename, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> ename <span class="hljs-keyword">from</span> emp;<br>		注意：起始下标从<span class="hljs-number">1</span>开始，没有<span class="hljs-number">0.</span><br>        找出员工名字第一个字母是A的员工信息？<br>			第一种方式：模糊查询<br>				<span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;A%&#x27;</span>;<br>			第二种方式：substr函数<br>				<span class="hljs-keyword">select</span> <br>					ename <br>				<span class="hljs-keyword">from</span> <br>					emp <br>				<span class="hljs-keyword">where</span> <br>					substr(ename,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>concat函数进行字符串的拼接<br>		<span class="hljs-keyword">select</span> concat(empno,ename) <span class="hljs-keyword">from</span> emp;<br><br>length 取长度<br>		<span class="hljs-keyword">select</span> length(ename) enamelength <span class="hljs-keyword">from</span> emp;<br><br>trim 去空格<br>		mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;  KING&#x27;</span>;<br><br>str_to_date 将字符串转换成日期<br>date_format 格式化日期<br>format 设置千分位<br>round 四舍五入<br>		<span class="hljs-keyword">select</span> 字段 <span class="hljs-keyword">from</span> 表名;<br>		<span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp;<br>		<span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">from</span> emp; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">select</span>后面直接跟“字面量<span class="hljs-operator">/</span>字面值”<br><br>		mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">as</span> bieming <span class="hljs-keyword">from</span> emp;<br>		<span class="hljs-keyword">select</span> round(<span class="hljs-number">1236.567</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> emp;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 保留<span class="hljs-number">1</span>个小数<br>		<span class="hljs-keyword">select</span> round(<span class="hljs-number">1236.567</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> emp;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 保留<span class="hljs-number">2</span>个小数<br>		<span class="hljs-keyword">select</span> round(<span class="hljs-number">1236.567</span>, <span class="hljs-number">-1</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> emp; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 保留到十位。<br><br>rand() 生成随机数<br>		mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> round(rand() <span class="hljs-operator">*</span> <span class="hljs-number">100</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">from</span> emp; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-number">100</span>以内的随机数<br><br>ifnull 可以将 <span class="hljs-keyword">null</span> 转换成一个具体值<br>		ifnull是空处理函数。专门处理空的。<br>		在所有数据库当中，只要有<span class="hljs-keyword">NULL</span>参与的数学运算，最终结果就是<span class="hljs-keyword">NULL</span>。<br>		mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> ename, sal <span class="hljs-operator">+</span> comm <span class="hljs-keyword">as</span> salcomm <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-分组函数"><a href="#4-2-分组函数" class="headerlink" title="4.2 分组函数"></a>4.2 分组函数</h3><ul>
<li>多行处理函数的特点：输入多行，最终输出一行。<ul>
<li>count    计数</li>
<li>sum    求和</li>
<li>avg    平均值</li>
<li>max    最大值</li>
<li>min    最小值</li>
</ul>
</li>
<li>注意：<pre><code>分组函数在使用的时候必须先进行分组，然后才能用。
如果你没有对数据进行分组，整张表默认为一组。    
</code></pre></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">找出最高工资？<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp;<br>找出最低工资？<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(sal) <span class="hljs-keyword">from</span> emp;<br>计算工资和：<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(sal) <span class="hljs-keyword">from</span> emp;<br>计算平均工资：<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp;<br>计算员工数量？<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(ename) <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure>
<p><strong>分组函数在使用的时候需要注意哪些？</strong>    </p>
<ul>
<li><p>第一点：分组函数自动忽略NULL，你不需要提前对NULL进行处理。</p>
</li>
<li><p>第二点：分组函数中 count(*) 和 count(具体字段) 有什么区别？</p>
<ul>
<li>count(具体字段)：表示统计该字段下所有不为NULL的元素的总数。</li>
<li>count(*)：统计表当中的总行数。（只要有一行数据count则++）<br>因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。</li>
</ul>
</li>
<li><p>第三点：分组函数不能够直接使用在where子句中。<br>找出比最低工资高的员工信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> <span class="hljs-built_in">min</span>(sal);<br>表面上没问题，运行一下？<br>ERROR <span class="hljs-number">1111</span> (HY000): Invalid use <span class="hljs-keyword">of</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">function</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5.分组查询"></a>5.分组查询</h2><h3 id="5-1-group-by"><a href="#5-1-group-by" class="headerlink" title="5.1 group by"></a>5.1 group by</h3><p><strong>找出每个工作岗位的工资和？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">实现思路：按照工作岗位分组，然后对工资求和。<br>		<span class="hljs-keyword">select</span> <br>			job,<span class="hljs-built_in">sum</span>(sal)<br>		<span class="hljs-keyword">from</span><br>			emp<br>		<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>			job;<br><br>以上这个语句的执行顺序？<br>先从emp表中查询数据。根据job字段进行分组。然后对每一组的数据进行<span class="hljs-built_in">sum</span>(sal)<br></code></pre></td></tr></table></figure>
<ul>
<li>在一条select语句当中，如果有group by语句的话，select 后面只能跟：<strong>参加分组的字段，以及分组函数</strong>。其它的一律不能跟。</li>
</ul>
<p><strong>找出每个部门的最高薪资</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">实现思路: 按照部门编号分组，求每一组的最大值。<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> deptno, <span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br></code></pre></td></tr></table></figure>
<h3 id="5-2-联合分组"><a href="#5-2-联合分组" class="headerlink" title="5.2 联合分组"></a>5.2 联合分组</h3><p><strong>找出“每个部门，不同工作岗位”的最高薪资？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">技巧：两个字段联合成<span class="hljs-number">1</span>个字段看。（两个字段联合分组）<br>		<span class="hljs-keyword">select</span> <br>			deptno, job, <span class="hljs-built_in">max</span>(sal)<br>		<span class="hljs-keyword">from</span><br>			emp<br>		<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>			deptno, job;<br></code></pre></td></tr></table></figure>
<h3 id="5-3-having"><a href="#5-3-having" class="headerlink" title="5.3 having"></a>5.3 having</h3><ul>
<li><p>使用having可以对分完组之后的数据进一步过滤。</p>
</li>
<li><p>having不能单独使用，having不能代替where，having必须和group by联合使用。</p>
</li>
</ul>
<p><strong>找出每个部门平均薪资，要求显示平均薪资高于2500的。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	deptno, <span class="hljs-built_in">avg</span>(sal)<br><span class="hljs-keyword">from</span><br>	emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>	deptno<br><span class="hljs-keyword">having</span><br>	<span class="hljs-built_in">avg</span>(sal) <span class="hljs-operator">&gt;</span> <span class="hljs-number">2500</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>where和having，优先选择where，where实在完成不了了，再选择having。</li>
</ul>
<h3 id="5-4-总结sql执行顺序"><a href="#5-4-总结sql执行顺序" class="headerlink" title="5.4 总结sql执行顺序"></a>5.4 总结sql执行顺序</h3><ul>
<li>select  —&gt; from —&gt; where —&gt; group by —&gt; having —&gt; order by —&gt;<br>以上关键字只能按照这个顺序来，不能颠倒。</li>
</ul>
<p>执行顺序？</p>
<ul>
<li>from —&gt; where —&gt; group by —&gt; having —&gt; select —&gt; order by</li>
</ul>
<ol>
<li>从某张表中查询数据，</li>
<li>先经过where条件筛选出有价值的数据。</li>
<li>对这些有价值的数据进行分组。</li>
<li>分组之后可以使用having继续筛选。</li>
<li>select查询出来。</li>
<li>最后排序输出！</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">找出每个岗位的平均薪资，要求显示平均薪资大于<span class="hljs-number">1500</span>的，除MANAGER岗位之外，要求按照平均薪资降序排。<br><br><span class="hljs-keyword">select</span> <br>	job, <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">as</span> avg_sal<br><span class="hljs-keyword">from</span><br>	emp<br><span class="hljs-keyword">where</span><br>	job <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;MANAGER&#x27;</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>	job<br><span class="hljs-keyword">having</span><br>	avg_sal<span class="hljs-operator">&gt;</span> <span class="hljs-number">1500</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>	avgsal <span class="hljs-keyword">desc</span>;  <br></code></pre></td></tr></table></figure>
<h2 id="6-连表查询"><a href="#6-连表查询" class="headerlink" title="6. 连表查询"></a>6. 连表查询</h2><ul>
<li><p>从一张表中单独查询，称为单表查询</p>
</li>
<li><p>emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。</p>
</li>
<li><p>这种跨表查询，多张表联合起来查询数据，被称为连接查询。</p>
<p>select ename,dname from emp, dept;</p>
</li>
<li><p>当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。</p>
</li>
</ul>
<h3 id="6-1-内连接之等值连接"><a href="#6-1-内连接之等值连接" class="headerlink" title="6.1 内连接之等值连接"></a>6.1 内连接之等值连接</h3><p><strong>查询每个员工所在部门名称，显示员工名和部门名？</strong></p>
<ul>
<li>emp e和dept d表进行连接。条件是：e.deptno = d.deptno</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">SQL92语法：<br>	<span class="hljs-keyword">select</span> <br>		e.ename,d.dname<br>	<span class="hljs-keyword">from</span><br>		emp e, dept d<br>	<span class="hljs-keyword">where</span><br>		e.deptno <span class="hljs-operator">=</span> d.deptno;<br>	<br>	sql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了<span class="hljs-keyword">where</span>后面。<br>	<br>SQL99语法：<br>	<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">inner</span>可以省略（带着<span class="hljs-keyword">inner</span>可读性更好！！！一眼就能看出来是内连接）<br>	<span class="hljs-keyword">select</span> <br>		e.ename,d.dname<br>	<span class="hljs-keyword">from</span><br>		emp e<br>	<span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span><br>		dept d<br>	<span class="hljs-keyword">on</span><br>		e.deptno <span class="hljs-operator">=</span> d.deptno; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 条件是等量关系，所以被称为等值连接。<br>	<br>	sql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加<span class="hljs-keyword">where</span><br></code></pre></td></tr></table></figure>
<h3 id="6-2-内连接之非等值连接"><a href="#6-2-内连接之非等值连接" class="headerlink" title="6.2 内连接之非等值连接"></a>6.2 内连接之非等值连接</h3><p><strong>找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	e.ename, e.sal, s.grade<br><span class="hljs-keyword">from</span><br>	emp e<br><span class="hljs-keyword">join</span><br>	salgrade s<br><span class="hljs-keyword">on</span><br>	e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 条件不是一个等量关系，称为非等值连接。<br></code></pre></td></tr></table></figure>
<h3 id="6-3-内连接之自己连接"><a href="#6-3-内连接之自己连接" class="headerlink" title="6.3 内连接之自己连接"></a>6.3 内连接之自己连接</h3><p><strong>查询员工的上级领导，要求显示员工名和对应的领导名？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">技巧：一张表看成两张表。<br><span class="hljs-keyword">select</span> <br>	a.ename <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;员工名&#x27;</span>, b.ename <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;领导名&#x27;</span><br><span class="hljs-keyword">from</span><br>	emp a<br><span class="hljs-keyword">join</span><br>	emp b<br><span class="hljs-keyword">on</span><br>	a.mgr <span class="hljs-operator">=</span> b.empno; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>员工的领导编号 <span class="hljs-operator">=</span> 领导的员工编号<br></code></pre></td></tr></table></figure>
<h3 id="6-4-外连接"><a href="#6-4-外连接" class="headerlink" title="6.4 外连接"></a>6.4 外连接</h3><ul>
<li><p>内连接：（A和B连接，AB两张表没有主次关系。平等的。）</p>
</li>
<li><p>内连接的特点：完成能够匹配上ON后面的条件的数据查询出来。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">outer</span>是可以省略的，带着可读性强。<br><span class="hljs-keyword">select</span> <br>	e.ename,d.dname<br><span class="hljs-keyword">from</span><br>	emp e <br><span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <br>	dept d<br><span class="hljs-keyword">on</span><br>	e.deptno <span class="hljs-operator">=</span> d.deptno;<br></code></pre></td></tr></table></figure>
<ul>
<li>right代表什么：表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表。</li>
<li><strong>在外连接当中，两张表连接，产生了主次关系。</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	e.ename,d.dname<br><span class="hljs-keyword">from</span><br>	dept d <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <br>	emp e<br><span class="hljs-keyword">on</span><br>	e.deptno <span class="hljs-operator">=</span> d.deptno;<br><br>带有<span class="hljs-keyword">right</span>的是右外连接，又叫做右连接。<br>带有<span class="hljs-keyword">left</span>的是左外连接，又叫做左连接。<br>任何一个右连接都有左连接的写法。<br>任何一个左连接都有右连接的写法。<br></code></pre></td></tr></table></figure>
<h3 id="6-5-多表连接"><a href="#6-5-多表连接" class="headerlink" title="6.5 多表连接"></a>6.5 多表连接</h3><p><strong>三张表，四张表怎么连接？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">语法：<br>	<span class="hljs-keyword">select</span> <br>		...<br>	<span class="hljs-keyword">from</span><br>		a<br>	<span class="hljs-keyword">join</span><br>		b<br>	<span class="hljs-keyword">on</span><br>		a和b的连接条件<br>	<span class="hljs-keyword">join</span><br>		c<br>	<span class="hljs-keyword">on</span><br>		a和c的连接条件<br>	<span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span><br>		d<br>	<span class="hljs-keyword">on</span><br>		a和d的连接条件<br></code></pre></td></tr></table></figure>
<p><strong>找出每个员工的部门名称以及工资等级，要求显示员工名、部门名、薪资、薪资等级？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	e.ename,e.sal,d.dname,s.grade<br><span class="hljs-keyword">from</span><br>	emp e<br><span class="hljs-keyword">join</span><br>	dept d<br><span class="hljs-keyword">on</span> <br>	e.deptno <span class="hljs-operator">=</span> d.deptno<br><span class="hljs-keyword">join</span><br>	salgrade s<br><span class="hljs-keyword">on</span><br>	e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 通过薪资所在salgrade表的范围确定薪资等级<br></code></pre></td></tr></table></figure>
<p><strong>找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	e.ename,e.sal,d.dname,s.grade,l.ename<br><span class="hljs-keyword">from</span><br>	emp e<br><span class="hljs-keyword">join</span><br>	dept d<br><span class="hljs-keyword">on</span> <br>	e.deptno <span class="hljs-operator">=</span> d.deptno<br><span class="hljs-keyword">join</span><br>	salgrade s<br><span class="hljs-keyword">on</span><br>	e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span><br>	emp l<br><span class="hljs-keyword">on</span><br>	e.mgr <span class="hljs-operator">=</span> l.empno;<br></code></pre></td></tr></table></figure>
<h2 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7. 子查询"></a>7. 子查询</h2><ul>
<li><p>select 语句中嵌套 select 语句，被嵌套的 select 语句称为子查询。</p>
</li>
<li><p>子查询可以出现在 select 后面，from 后面，where 后面。</p>
</li>
</ul>
<h3 id="7-1-where-子句中的子查询"><a href="#7-1-where-子句中的子查询" class="headerlink" title="7.1 where 子句中的子查询"></a>7.1 where 子句中的子查询</h3><p><strong>找出比最低工资高的员工姓名和工资？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(sal) <span class="hljs-keyword">from</span> emp);<br></code></pre></td></tr></table></figure>
<h3 id="7-2-from-子句中的子查询"><a href="#7-2-from-子句中的子查询" class="headerlink" title="7.2 from 子句中的子查询"></a>7.2 from 子句中的子查询</h3><ul>
<li>from 后面的子查询，可以将子查询的查询结果当做一张临时表。（技巧）</li>
</ul>
<p><strong>找出每个岗位的平均工资的薪资等级。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	t.<span class="hljs-operator">*</span>, s.grade<br><span class="hljs-keyword">from</span><br>	(<span class="hljs-keyword">select</span> job,<span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">as</span> avgsal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job) t<br><span class="hljs-keyword">join</span><br>	salgrade s<br><span class="hljs-keyword">on</span><br>	t.avgsal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;<br></code></pre></td></tr></table></figure>
<h2 id="8-约束"><a href="#8-约束" class="headerlink" title="8. 约束"></a>8. 约束</h2><ul>
<li>在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！</li>
</ul>
<h3 id="8-1-约束类型"><a href="#8-1-约束类型" class="headerlink" title="8.1 约束类型"></a>8.1 约束类型</h3><ul>
<li>非空约束：not null</li>
<li>唯一性约束：unique</li>
<li>主键约束：primary key （简称PK）</li>
<li>外键约束：foreign key（简称FK）</li>
<li>检查约束：check（mysql不支持，oracle支持）</li>
</ul>
<p>重点学习四个约束：<strong>not null，unique，primary key，foreign key。</strong></p>
<h3 id="8-2-not-null"><a href="#8-2-not-null" class="headerlink" title="8.2 not null"></a>8.2 not null</h3><ul>
<li>非空约束 not null 约束的字段不能为 NULL。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>    id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> 只有列级约束，没有表级约束！<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id, name) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>);<br>	ERROR <span class="hljs-number">1364</span> (HY000): Field <span class="hljs-string">&#x27;name&#x27;</span> doesn<span class="hljs-string">&#x27;t have a default value</span><br></code></pre></td></tr></table></figure>
<h3 id="8-3-unique"><a href="#8-3-unique" class="headerlink" title="8.3 unique"></a>8.3 unique</h3><ul>
<li>唯一性约束 unique 约束的字段不能重复，但是<strong>可以为NULL</strong>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>	id <span class="hljs-type">int</span>,<br>	name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">unique</span>,<br>	email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;lisi@123.com&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;wangwu&#x27;</span>,<span class="hljs-string">&#x27;wangwu@123.com&#x27;</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_vip;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;wangwu&#x27;</span>,<span class="hljs-string">&#x27;wangwu@sina.com&#x27;</span>);<br>ERROR <span class="hljs-number">1062</span> (<span class="hljs-number">23000</span>): Duplicate entry <span class="hljs-string">&#x27;wangwu&#x27;</span> <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;name&#x27;</span><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id) <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+------------------+</span><br><span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span> email            <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+------------------+</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span> zhangsan<span class="hljs-variable">@123</span>.com <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span> lisi     <span class="hljs-operator">|</span> lisi<span class="hljs-variable">@123</span>.com     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span> wangwu   <span class="hljs-operator">|</span> wangwu<span class="hljs-variable">@123</span>.com   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+----------+------------------+</span><br>name字段虽然被<span class="hljs-keyword">unique</span>约束了，但是可以为<span class="hljs-keyword">NULL</span>。<br></code></pre></td></tr></table></figure>
<h4 id="8-3-1-联合唯一"><a href="#8-3-1-联合唯一" class="headerlink" title="8.3.1 联合唯一"></a>8.3.1 联合唯一</h4><ul>
<li>name 和 email 两个字段联合起来具有唯一性！！！！</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>	id <span class="hljs-type">int</span>,<br>	name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>	email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>	<span class="hljs-keyword">unique</span>(name,email) <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 约束没有添加在列的后面，这种约束被称为表级约束。<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;zhangsan@123.com&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;zhangsan@sina.com&#x27;</span>);<br>	name 和 email两个字段联合起来唯一！！！<br>	<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;zhangsan@sina.com&#x27;</span>);<br>	ERROR <span class="hljs-number">1062</span> (<span class="hljs-number">23000</span>): Duplicate entry <span class="hljs-string">&#x27;zhangsan-zhangsan@sina.com&#x27;</span> <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>在 mysql 当中，如果一个字段同时被 not null 和 unique 约束的话，该字段自动变成主键字段。（注意：oracle中不一样！）</li>
</ul>
<h3 id="8-4-primary-key"><a href="#8-4-primary-key" class="headerlink" title="8.4 primary key"></a>8.4 primary key</h3><ul>
<li><p>主键值是每一行记录的唯一标识。主键值是每一行记录的身份证号！！！</p>
</li>
<li><p>主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br>		<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-number">1</span>个字段做主键，叫做：单一主键<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>	id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>列级约束<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>(id)  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 表级约束<br>);<br>	<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>);<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>错误：不能重复<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>);<br>ERROR <span class="hljs-number">1062</span> (<span class="hljs-number">23000</span>): Duplicate entry <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;PRIMARY&#x27;</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>错误：不能为<span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhaoliu&#x27;</span>);<br>ERROR <span class="hljs-number">1364</span> (HY000): Field <span class="hljs-string">&#x27;id&#x27;</span> doesn<span class="hljs-string">&#x27;t have a default value</span><br></code></pre></td></tr></table></figure>
<h4 id="8-4-1-复合主键"><a href="#8-4-1-复合主键" class="headerlink" title="8.4.1 复合主键"></a>8.4.1 复合主键</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> id和name联合起来做主键：复合主键！！！！<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>    id <span class="hljs-type">int</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>    <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>(id,name)<br>);<br>        <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;zhangsan@123.com&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;lisi@123.com&#x27;</span>);<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>错误：不能重复<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(id,name,email) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;lisi@123.com&#x27;</span>);<br>	ERROR <span class="hljs-number">1062</span> (<span class="hljs-number">23000</span>): Duplicate entry <span class="hljs-string">&#x27;1-lisi&#x27;</span> <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;PRIMARY&#x27;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>在实际开发中不建议使用：复合主键。建议使用单一主键！</li>
<li>因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">一个表中主键约束能加两个吗？<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>	id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span><br>);<br>	ERROR <span class="hljs-number">1068</span> (<span class="hljs-number">42000</span>): Multiple <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> defined<br></code></pre></td></tr></table></figure>
<ul>
<li>结论：一张表，主键约束只能添加1个。（主键只能有1个。）</li>
</ul>
<p><strong>主键分类</strong></p>
<ul>
<li><p>自然主键：主键值是一个自然数，和业务没关系。</p>
</li>
<li><p>业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！</p>
</li>
</ul>
<h4 id="8-4-2-主键自增"><a href="#8-4-2-主键自增" class="headerlink" title="8.4.2 主键自增"></a>8.4.2 主键自增</h4><ul>
<li>在mysql当中，有一种机制，可以帮助我们自动维护一个主键值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">rop <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> t_vip;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_vip(<br>	id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment, <span class="hljs-operator">/</span><span class="hljs-operator">/</span>auto_increment表示自增，从<span class="hljs-number">1</span>开始，以<span class="hljs-number">1</span>递增！<br>	name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br>		<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br>		<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br>		<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br>		<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br>		<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br>		<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_vip(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br>		<br>		<span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br>		<span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span><br>		<span class="hljs-operator">+</span><span class="hljs-comment">----+----------+</span><br>		<span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br>		<span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br>		<span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br>		<span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br>		<span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> zhangsan <span class="hljs-operator">|</span><br></code></pre></td></tr></table></figure>
<h3 id="8-5-foreign-key"><a href="#8-5-foreign-key" class="headerlink" title="8.5 foreign key"></a>8.5 foreign key</h3><ul>
<li>如果一个实体的某个字段指向另一个实体的主键，就称为外键</li>
<li>被指向的实体，称之为主实体（主表），也叫父实体（父表）。</li>
<li>负责指向的实体，称之为从实体（从表），也叫子实体（子表）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_class(<br>	classno <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,<br>	classname <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>	<span class="hljs-keyword">no</span> <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>	name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),<br>	cno <span class="hljs-type">int</span>,<br>	<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(cno) <span class="hljs-keyword">references</span> t_class(classno)<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_class(classno, classname) <span class="hljs-keyword">values</span>(<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;北京市大兴区亦庄镇第二中学高三1班&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_class(classno, classname) <span class="hljs-keyword">values</span>(<span class="hljs-number">101</span>, <span class="hljs-string">&#x27;北京市大兴区亦庄镇第二中学高三1班&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;lilei&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;hanmeimei&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">101</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student(name,cno) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-number">101</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>外键可以为空，可以理解成 一名学生肯定会关联到一个存在的班级，但来了一个转校生，还没有分班，他现在属于学生子表，但还没有关联到班级主表中的任何一条记录。</li>
</ul>
<p>t_class是父表，t_student是子表</p>
<p>​        <strong>删除表</strong>的顺序？    先删子，再删父。</p>
<p>​        <strong>创建表</strong>的顺序？    先创建父，再创建子。</p>
<p>​        <strong>删除数据</strong>的顺序？先删子，再删父。</p>
<p>​        <strong>插入数据</strong>的顺序？先插入父，再插入子</p>
<ul>
<li>子表中的外键引用的父表中的某个字段，被引用的这个字段不一定是主键，但至少具有unique约束。</li>
</ul>
<h2 id="9-存储引擎"><a href="#9-存储引擎" class="headerlink" title="9. 存储引擎"></a>9. 存储引擎</h2><ul>
<li>存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）</li>
<li>实际上存储引擎是一个表存储/组织数据的方式。</li>
<li>不同的存储引擎，表存储数据的方式不同。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student;<br>可以在建表的时候给表指定存储引擎。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_student` (<br>  `<span class="hljs-keyword">no</span>` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `cno` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`<span class="hljs-keyword">no</span>`),<br>  KEY `cno` (`cno`),<br>  <span class="hljs-keyword">CONSTRAINT</span> `t_student_ibfk_1` <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (`cno`) <span class="hljs-keyword">REFERENCES</span> `t_class` (`classno`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">11</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure>
<p>在建表的时候可以在最后小括号的”)”的右边使用：</p>
<ul>
<li>ENGINE 来指定存储引擎。    mysql默认的存储引擎是：<strong>InnoDB</strong></li>
<li>CHARSET 来指定这张表的字符编码方式。mysql默认的字符编码方式是：<strong>utf8</strong></li>
</ul>
<h3 id="9-1-mysql-支持的存储引擎"><a href="#9-1-mysql-支持的存储引擎" class="headerlink" title="9.1 mysql 支持的存储引擎"></a>9.1 mysql 支持的存储引擎</h3><ul>
<li>show engines \G   查看mysql支持哪些存储引擎</li>
<li>mysql 支持九大存储引擎，当前5.5.36支持8个。版本不同支持情况不同。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220418201608.png" alt=""></p>
<h3 id="9-2-MyISAM存储引擎"><a href="#9-2-MyISAM存储引擎" class="headerlink" title="9.2 MyISAM存储引擎"></a>9.2 MyISAM存储引擎</h3><ul>
<li><p>使用三个文件表示每个表：</p>
<ul>
<li>格式文件 — 存储表结构的定义（mytable.frm）</li>
<li>数据文件 — 存储表行的内容（mytable.MYD）</li>
<li>索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。</li>
</ul>
</li>
<li><p>可被转换为压缩、只读表来节省空间</p>
</li>
<li>MyISAM存储引擎特点：<ul>
<li>可被转换为压缩、只读表来节省空间这是这种存储引擎的优势！！！！</li>
<li>MyISAM不支持事务机制，安全性低。</li>
</ul>
</li>
</ul>
<h3 id="9-3-InnoDB存储引擎"><a href="#9-3-InnoDB存储引擎" class="headerlink" title="9.3 InnoDB存储引擎"></a>9.3 InnoDB存储引擎</h3><ul>
<li>这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。</li>
<li>InnoDB支持事务，支持数据库崩溃后自动恢复机制。</li>
<li><p>InnoDB存储引擎最主要的特点是：非常安全。</p>
</li>
<li><p>它管理的表具有下列主要特征：</p>
<ul>
<li>每个 InnoDB 表在数据库目录中以.frm 格式文件表示</li>
<li>InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）</li>
<li>提供一组用来记录事务性活动的日志文件</li>
<li>用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理</li>
<li>提供全 ACID 兼容</li>
<li>在 MySQL 服务器崩溃后提供自动恢复</li>
<li>多版本（MVCC）和行级锁定</li>
<li>支持外键及引用的完整性，包括级联删除和更新</li>
</ul>
</li>
<li>InnoDB最大的特点就是支持事务：以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，</li>
<li>不能很好的节省存储空间。</li>
</ul>
<h3 id="9-4-MEMORY存储引擎"><a href="#9-4-MEMORY存储引擎" class="headerlink" title="9.4 MEMORY存储引擎"></a>9.4 MEMORY存储引擎</h3><ul>
<li><p>使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得 MEMORY 存储引擎非常<strong>快</strong>。</p>
</li>
<li><p>MEMORY 存储引擎管理的表具有下列特征：</p>
<ul>
<li>在数据库目录内，每个表均以.frm 格式的文件表示。</li>
<li>表数据及索引被存储在内存中。（目的就是快，查询快！）</li>
<li>表级锁机制。</li>
<li>不能包含 TEXT 或 BLOB 字段。</li>
</ul>
</li>
<li><p>MEMORY 存储引擎以前被称为HEAP 引擎。</p>
</li>
<li>MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。</li>
<li>MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</li>
</ul>
<h2 id="10-事务"><a href="#10-事务" class="headerlink" title="10.事务"></a>10.事务</h2><ul>
<li><p>一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。</p>
</li>
<li><p>什么是一个完整的业务逻辑？</p>
<pre><code>假设转账，从A账户向B账户中转账10000.
      将A账户的钱减去10000（update语句）
      将B账户的钱加上10000（update语句）
      这就是一个完整的业务逻辑。
</code></pre></li>
<li>以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。</li>
<li>insert   delete   update  只有以上的三个语句和事务有关系，其它都没有关系。</li>
<li>事务：就是<strong>批量的DML语句同时成功，或者同时失败！</strong></li>
</ul>
<h3 id="10-1-InnoDB-实现事务"><a href="#10-1-InnoDB-实现事务" class="headerlink" title="10.1 InnoDB 实现事务"></a>10.1 InnoDB 实现事务</h3><ul>
<li><p>InnoDB 存储引擎：提供一组用来记录事务性活动的日志文件</p>
</li>
<li><p>在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。</p>
</li>
<li><p>在事务的执行过程中，<strong>我们可以提交事务，也可以回滚事务。</strong></p>
</li>
<li><p>提交事务   <strong>commit</strong>; 语句</p>
<ul>
<li>清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。</li>
<li>提交事务标志着，事务的结束。并且是一种全部成功的结束。</li>
</ul>
</li>
<li><p>回滚事务   <strong>rollback</strong>; 语句（回滚永远都是只能回滚到上一次的<strong>提交点</strong>！）</p>
<ul>
<li>将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件</li>
<li>回滚事务标志着，事务的结束。并且是一种全部失败的结束。</li>
</ul>
</li>
<li><p>将mysql的自动提交机制<strong>关闭</strong>掉   start transaction;</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">事务回滚<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept_bak;<br>	<span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> transaction;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept_bak <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;tj&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept_bak <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;tj&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept_bak;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+------+</span><br><span class="hljs-operator">|</span> DEPTNO <span class="hljs-operator">|</span> DNAME <span class="hljs-operator">|</span> LOC  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> abc   <span class="hljs-operator">|</span> tj   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> abc   <span class="hljs-operator">|</span> tj   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-------+------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">rollback</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept_bak;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>
<h3 id="10-2-事物的四个特性-ACID"><a href="#10-2-事物的四个特性-ACID" class="headerlink" title="10.2 事物的四个特性 ACID"></a>10.2 事物的四个特性 ACID</h3><p><strong>A：原子性</strong><br>        说明事务是最小的工作单元。不可再分。</p>
<p><strong>C：一致性</strong><br>    所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性。</p>
<p><strong>I：隔离性</strong><br>    A事务和B事务之间具有一定的隔离。<br>    教室A和教室B之间有一道墙，这道墙就是隔离性。<br>    A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？</p>
<p><strong>D：持久性</strong><br>    事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据<br>    保存到硬盘上！</p>
<h3 id="10-3-事务的隔离性"><a href="#10-3-事务的隔离性" class="headerlink" title="10.3 事务的隔离性"></a>10.3 事务的隔离性</h3><h4 id="10-3-1-事务和事务之间四个隔离级别"><a href="#10-3-1-事务和事务之间四个隔离级别" class="headerlink" title="10.3.1 事务和事务之间四个隔离级别"></a>10.3.1 事务和事务之间四个隔离级别</h4><p><strong>读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》</strong></p>
<ul>
<li>事务A可以读取到事务B未提交的数据。</li>
<li>这种隔离级别存在的问题就是：<strong>脏读现象</strong>！(Dirty Read)我们称读到了脏数据。</li>
<li>这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！</li>
</ul>
<p><strong>读已提交：read committed《提交之后才能读到》</strong></p>
<ul>
<li>事务A只能读取到事务B提交之后的数据。</li>
<li>这种隔离级别解决了解决了脏读的现象。</li>
<li>这种隔离级别不可重复读取数据。<ul>
<li>在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3不等于4称为不可重复读取。</li>
</ul>
</li>
<li>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。</li>
<li>oracle数据库默认的隔离级别是：read committed</li>
</ul>
<p><strong>可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》</strong></p>
<ul>
<li>事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。</li>
<li>可重复读可能会出现幻影读。每一次读取到的数据都是幻象。不够真实！</li>
<li><p>早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！读到的是假象。不够绝对的真实。</p>
</li>
<li><p>mysql中默认的事务隔离级别就是这个！！！！！！！！！！！</p>
</li>
</ul>
<p><strong>序列化/串行化：serializable（最高的隔离级别）</strong></p>
<ul>
<li>这是最高隔离级别，效率最低。解决了所有的问题。</li>
<li>这种隔离级别表示事务排队，不能并发！</li>
<li>synchronized，线程同步（事务同步）每一次读取到的数据都是最真实的，并且效率是最低的。</li>
</ul>
<h4 id="10-3-2-验证各种隔离级别"><a href="#10-3-2-验证各种隔离级别" class="headerlink" title="10.3.2 验证各种隔离级别"></a>10.3.2 验证各种隔离级别</h4><ul>
<li>mysql 5 查看隔离级别：SELECT @@tx_isolation</li>
<li>mysql 8 查看隔离级别：select @@transaction_isolation;</li>
</ul>
<p><strong>验证：read uncommited</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read uncommitted;<br>事务A													事务B<br><span class="hljs-comment">--------------------------------------------------------------------------------</span><br>use bjpowernode;<br>													use bjpowernode;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br>													<span class="hljs-keyword">start</span> transaction;<br>													<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br></code></pre></td></tr></table></figure>
<p><strong>验证：read commited</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read committed;<br>事务A													事务B<br><span class="hljs-comment">--------------------------------------------------------------------------------</span><br>use bjpowernode;<br>													use bjpowernode;<br><span class="hljs-keyword">start</span> transaction;<br>													<span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br>													<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br>													<span class="hljs-keyword">commit</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br></code></pre></td></tr></table></figure>
<p><strong>验证：repeatable read</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level repeatable read;<br>事务A													事务B<br><span class="hljs-comment">--------------------------------------------------------------------------------</span><br>use bjpowernode;<br>													use bjpowernode;<br><span class="hljs-keyword">start</span> transaction;<br>													<span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br>													<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;lisi&#x27;</span>);<br>													<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;wangwu&#x27;</span>);<br>													<span class="hljs-keyword">commit</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br></code></pre></td></tr></table></figure>
<p><strong>验证：serializable</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level serializable;<br>事务A													事务B<br><span class="hljs-comment">--------------------------------------------------------------------------------</span><br>use bjpowernode;<br>													use bjpowernode;<br><span class="hljs-keyword">start</span> transaction;<br>													<span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);<br></code></pre></td></tr></table></figure>
<h2 id="11-索引"><a href="#11-索引" class="headerlink" title="11. 索引"></a>11. 索引</h2><ul>
<li>索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。</li>
<li>一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。</li>
<li><p>索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。</p>
</li>
<li><p>MySQL在查询方面主要就是两种方式：全表扫描  ；根据索引检索。</p>
</li>
<li><p>在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet</p>
</li>
<li><strong>数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。</strong></li>
<li><strong>遵循左小又大原则存放。采用中序遍历方式遍历取数据。</strong></li>
</ul>
<p><strong>索引的实现原理？</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220418204148.png" style="zoom:90%;" /></p>
<ul>
<li>提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象</li>
<li>提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。</li>
<li>提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式</li>
</ul>
<p><strong>什么条件下，我们会考虑给字段添加索引呢？</strong></p>
<ol>
<li>数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）</li>
<li>该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。</li>
<li>该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）</li>
</ol>
<ul>
<li>建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。</li>
<li>建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。</li>
</ul>
<h3 id="11-1-索引的创建和删除"><a href="#11-1-索引的创建和删除" class="headerlink" title="11.1 索引的创建和删除"></a>11.1 索引的创建和删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">创建索引：<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> index emp_ename_index <span class="hljs-keyword">on</span> emp(ename);<br>	给emp表的ename字段添加索引，起名：emp_ename_index<br><br>删除索引：<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">drop</span> index emp_ename_index <span class="hljs-keyword">on</span> emp;<br>	将emp表上的emp_ename_index索引对象删除。<br>	<br>	查看一个<span class="hljs-keyword">SQL</span>语句是否使用了索引进行检索？<br>	mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;KING&#x27;</span>;<br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br>	<span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+-</span><br>	<span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br>	扫描<span class="hljs-number">14</span>条记录：说明没有使用索引。type<span class="hljs-operator">=</span><span class="hljs-keyword">ALL</span><br><br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> index emp_ename_index <span class="hljs-keyword">on</span> emp(ename);<br><br>	mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;KING&#x27;</span>;<br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+-----------------</span><br>	<span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys   <span class="hljs-operator">|</span> key             <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+-----------------</span><br>	<span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> emp_ename_index <span class="hljs-operator">|</span> emp_ename_index <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+-----------------</span><br></code></pre></td></tr></table></figure>
<h3 id="11-2-索引失效"><a href="#11-2-索引失效" class="headerlink" title="11.2 索引失效"></a>11.2 索引失效</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">失效的第<span class="hljs-number">1</span>种情况：<br>	<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%T&#x27;</span>;<br>	ename上即使添加了索引，也不会走索引，为什么？<br>		原因是因为模糊匹配当中以“<span class="hljs-operator">%</span>”开头了！<br>		尽量避免模糊查询的时候以“<span class="hljs-operator">%</span>”开始。<br>		这是一种优化的手段<span class="hljs-operator">/</span>策略。<br>	myql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%T&#x27;</span>;<br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br>	<span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br>	<span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br><br>失效的第<span class="hljs-number">2</span>种情况：<br>	使用<span class="hljs-keyword">or</span>的时候会失效，如果使用<span class="hljs-keyword">or</span>那么要求<span class="hljs-keyword">or</span>两边的条件字段都要有<br>	索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个<br>	字段上的索引也会实现。所以这就是为什么不建议使用<span class="hljs-keyword">or</span>的原因。<br><br>	mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;KING&#x27;</span> <span class="hljs-keyword">or</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MANAGER&#x27;</span>;<br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+------+---------</span><br>	<span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys   <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+------+---------</span><br>	<span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> emp_ename_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-----------------+------+---------</span><br><br>失效的第<span class="hljs-number">3</span>种情况：<br>	使用复合索引的时候，没有使用左侧的列查找，索引失效<br>	什么是复合索引？<br>		两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。<br>	<br>	<span class="hljs-keyword">create</span> index emp_job_sal_index <span class="hljs-keyword">on</span> emp(job,sal);<br>	<br>	mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MANAGER&#x27;</span>;<br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-------------------+---------------</span><br>	<span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys     <span class="hljs-operator">|</span> key           <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-------------------+---------------</span><br>	<span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> emp_job_sal_index <span class="hljs-operator">|</span> <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+-------------------+---------------</span><br>	<br>	mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">=</span> <span class="hljs-number">800</span>;<br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br>	<span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br>	<span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> emp   <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <br>	<span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------+---------------+------+---------+--</span><br></code></pre></td></tr></table></figure>
<h2 id="12-视图"><a href="#12-视图" class="headerlink" title="12. 视图"></a>12. 视图</h2><ul>
<li>视图view：站在不同的角度去看待同一份数据。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">表复制：<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept2 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept;<br>dept2表中的数据：<br>	mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><span class="hljs-operator">|</span> DEPTNO <span class="hljs-operator">|</span> DNAME      <span class="hljs-operator">|</span> LOC      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span> <span class="hljs-keyword">NEW</span> YORK <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">20</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span> DALLAS   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span> CHICAGO  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">40</span> <span class="hljs-operator">|</span> OPERATIONS <span class="hljs-operator">|</span> BOSTON   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><br>创建视图对象：<br>	<span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> dept2_view <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2;<br><br>删除视图对象：<br>	<span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> dept2_view;<br><br>注意：只有DQL语句才能以<span class="hljs-keyword">view</span>的形式创建。<br>	<span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> view_name <span class="hljs-keyword">as</span> 这里的语句必须是DQL语句;<br></code></pre></td></tr></table></figure>
<h3 id="12-1-视图的作用"><a href="#12-1-视图的作用" class="headerlink" title="12.1 视图的作用"></a>12.1 视图的作用</h3><ul>
<li>我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>面向视图查询<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2_view; <br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 面向视图插入<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept2_view(deptno,dname,loc) <span class="hljs-keyword">values</span>(<span class="hljs-number">60</span>,<span class="hljs-string">&#x27;SALES&#x27;</span>, <span class="hljs-string">&#x27;BEIJING&#x27;</span>);<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 查询原表数据<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><span class="hljs-operator">|</span> DEPTNO <span class="hljs-operator">|</span> DNAME      <span class="hljs-operator">|</span> LOC      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span> <span class="hljs-keyword">NEW</span> YORK <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">20</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span> DALLAS   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span> CHICAGO  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">40</span> <span class="hljs-operator">|</span> OPERATIONS <span class="hljs-operator">|</span> BOSTON   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">60</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span> BEIJING  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+------------+----------+</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 面向视图删除<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> dept2_view;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 查询原表数据<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept2;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 创建视图对象<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> <br>	emp_dept_view<br><span class="hljs-keyword">as</span><br>	<span class="hljs-keyword">select</span> <br>		e.ename,e.sal,d.dname<br>	<span class="hljs-keyword">from</span><br>		emp e<br>	<span class="hljs-keyword">join</span><br>		dept d<br>	<span class="hljs-keyword">on</span><br>		e.deptno <span class="hljs-operator">=</span> d.deptno;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 查询视图对象<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp_dept_view;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------+------------+</span><br><span class="hljs-operator">|</span> ename  <span class="hljs-operator">|</span> sal     <span class="hljs-operator">|</span> dname      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------+------------+</span><br><span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> <span class="hljs-number">2450.00</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> KING   <span class="hljs-operator">|</span> <span class="hljs-number">5000.00</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> <span class="hljs-number">1300.00</span> <span class="hljs-operator">|</span> ACCOUNTING <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span>  <span class="hljs-number">800.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> <span class="hljs-number">2975.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> <span class="hljs-number">3000.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> <span class="hljs-number">1100.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> <span class="hljs-number">3000.00</span> <span class="hljs-operator">|</span> RESEARCH   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> <span class="hljs-number">1600.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> <span class="hljs-number">1250.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> <span class="hljs-number">1250.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> <span class="hljs-number">2850.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> <span class="hljs-number">1500.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span>  <span class="hljs-number">950.00</span> <span class="hljs-operator">|</span> SALES      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------+------------+</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 面向视图更新<br><span class="hljs-keyword">update</span> emp_dept_view <span class="hljs-keyword">set</span> sal <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ACCOUNTING&#x27;</span>;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 原表数据被更新<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-----------+------+------------+---------+---------+----</span><br><span class="hljs-operator">|</span> EMPNO <span class="hljs-operator">|</span> ENAME  <span class="hljs-operator">|</span> JOB       <span class="hljs-operator">|</span> MGR  <span class="hljs-operator">|</span> HIREDATE   <span class="hljs-operator">|</span> SAL     <span class="hljs-operator">|</span> COMM    <span class="hljs-operator">|</span> <br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-----------+------+------------+---------+---------+----</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7369</span> <span class="hljs-operator">|</span> SMITH  <span class="hljs-operator">|</span> CLERK     <span class="hljs-operator">|</span> <span class="hljs-number">7902</span> <span class="hljs-operator">|</span> <span class="hljs-number">1980</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span> <span class="hljs-operator">|</span>  <span class="hljs-number">800.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7499</span> <span class="hljs-operator">|</span> ALLEN  <span class="hljs-operator">|</span> SALESMAN  <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-02</span><span class="hljs-number">-20</span> <span class="hljs-operator">|</span> <span class="hljs-number">1600.00</span> <span class="hljs-operator">|</span>  <span class="hljs-number">300.00</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7521</span> <span class="hljs-operator">|</span> WARD   <span class="hljs-operator">|</span> SALESMAN  <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-02</span><span class="hljs-number">-22</span> <span class="hljs-operator">|</span> <span class="hljs-number">1250.00</span> <span class="hljs-operator">|</span>  <span class="hljs-number">500.00</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7566</span> <span class="hljs-operator">|</span> JONES  <span class="hljs-operator">|</span> MANAGER   <span class="hljs-operator">|</span> <span class="hljs-number">7839</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-04</span><span class="hljs-number">-02</span> <span class="hljs-operator">|</span> <span class="hljs-number">2975.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7654</span> <span class="hljs-operator">|</span> MARTIN <span class="hljs-operator">|</span> SALESMAN  <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-09</span><span class="hljs-number">-28</span> <span class="hljs-operator">|</span> <span class="hljs-number">1250.00</span> <span class="hljs-operator">|</span> <span class="hljs-number">1400.00</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> BLAKE  <span class="hljs-operator">|</span> MANAGER   <span class="hljs-operator">|</span> <span class="hljs-number">7839</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-05</span><span class="hljs-number">-01</span> <span class="hljs-operator">|</span> <span class="hljs-number">2850.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7782</span> <span class="hljs-operator">|</span> CLARK  <span class="hljs-operator">|</span> MANAGER   <span class="hljs-operator">|</span> <span class="hljs-number">7839</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-06</span><span class="hljs-number">-09</span> <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7788</span> <span class="hljs-operator">|</span> SCOTT  <span class="hljs-operator">|</span> ANALYST   <span class="hljs-operator">|</span> <span class="hljs-number">7566</span> <span class="hljs-operator">|</span> <span class="hljs-number">1987</span><span class="hljs-number">-04</span><span class="hljs-number">-19</span> <span class="hljs-operator">|</span> <span class="hljs-number">3000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7839</span> <span class="hljs-operator">|</span> KING   <span class="hljs-operator">|</span> PRESIDENT <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-11</span><span class="hljs-number">-17</span> <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7844</span> <span class="hljs-operator">|</span> TURNER <span class="hljs-operator">|</span> SALESMAN  <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-09</span><span class="hljs-number">-08</span> <span class="hljs-operator">|</span> <span class="hljs-number">1500.00</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0.00</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7876</span> <span class="hljs-operator">|</span> ADAMS  <span class="hljs-operator">|</span> CLERK     <span class="hljs-operator">|</span> <span class="hljs-number">7788</span> <span class="hljs-operator">|</span> <span class="hljs-number">1987</span><span class="hljs-number">-05</span><span class="hljs-number">-23</span> <span class="hljs-operator">|</span> <span class="hljs-number">1100.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7900</span> <span class="hljs-operator">|</span> JAMES  <span class="hljs-operator">|</span> CLERK     <span class="hljs-operator">|</span> <span class="hljs-number">7698</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-12</span><span class="hljs-number">-03</span> <span class="hljs-operator">|</span>  <span class="hljs-number">950.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7902</span> <span class="hljs-operator">|</span> FORD   <span class="hljs-operator">|</span> ANALYST   <span class="hljs-operator">|</span> <span class="hljs-number">7566</span> <span class="hljs-operator">|</span> <span class="hljs-number">1981</span><span class="hljs-number">-12</span><span class="hljs-number">-03</span> <span class="hljs-operator">|</span> <span class="hljs-number">3000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">|</span>  <span class="hljs-number">7934</span> <span class="hljs-operator">|</span> MILLER <span class="hljs-operator">|</span> CLERK     <span class="hljs-operator">|</span> <span class="hljs-number">7782</span> <span class="hljs-operator">|</span> <span class="hljs-number">1982</span><span class="hljs-number">-01</span><span class="hljs-number">-23</span> <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span> <span class="hljs-operator">|</span>    <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+-----------+------+------------+---------+---------+----</span><br></code></pre></td></tr></table></figure>
<h3 id="12-2-视图在开发中的作用"><a href="#12-2-视图在开发中的作用" class="headerlink" title="12.2 视图在开发中的作用"></a>12.2 视图在开发中的作用</h3><ul>
<li><p>假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。<br>每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？</p>
<pre><code>    可以把这条复杂的SQL语句以视图对象的形式新建。
    在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。
    并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要
    修改视图对象所映射的SQL语句。
</code></pre></li>
<li><p>我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。</p>
</li>
<li><p>可以对视图进行增删改查等操作。<strong>视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。</strong></p>
</li>
</ul>
<h2 id="13-数据库三范式"><a href="#13-数据库三范式" class="headerlink" title="13. 数据库三范式"></a>13. 数据库三范式</h2><p><strong>第一范式</strong>：要求任何一张表必须有主键，每一个字段原子性不可再分。</p>
<p><strong>第二范式</strong>：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，<br>不要产生部分依赖。</p>
<p><strong>第三范式</strong>：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，<br>不要产生传递依赖。</p>
<ul>
<li>声明：三范式是面试官经常问的，所以一定要熟记在心！</li>
</ul>
<p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</p>
<h3 id="13-1-第一范式"><a href="#13-1-第一范式" class="headerlink" title="13.1 第一范式"></a>13.1 第一范式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">学生编号 学生姓名 联系方式<br>	<span class="hljs-comment">------------------------------------------</span><br>	<span class="hljs-number">1001</span>		张三		zs<span class="hljs-variable">@gmail</span>.com,<span class="hljs-number">1359999999</span><br>	<span class="hljs-number">1002</span>		李四		ls<span class="hljs-variable">@gmail</span>.com,<span class="hljs-number">13699999999</span><br>	<span class="hljs-number">1001</span>		王五		ww<span class="hljs-variable">@163</span>.net,<span class="hljs-number">13488888888</span><br>	<br>以上是学生表，满足第一范式吗？<br>	不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话<br><br>学生编号(pk) 学生姓名	邮箱地址			联系电话<br><span class="hljs-comment">----------------------------------------------------</span><br><span class="hljs-number">1001</span>				张三		zs<span class="hljs-variable">@gmail</span>.com	<span class="hljs-number">1359999999</span><br><span class="hljs-number">1002</span>				李四		ls<span class="hljs-variable">@gmail</span>.com	<span class="hljs-number">13699999999</span><br><span class="hljs-number">1003</span>				王五		ww<span class="hljs-variable">@163</span>.net		<span class="hljs-number">13488888888</span><br></code></pre></td></tr></table></figure>
<h3 id="13-2-第二范式"><a href="#13-2-第二范式" class="headerlink" title="13.2 第二范式"></a>13.2 第二范式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">	学生编号 		学生姓名 	教师编号 教师姓名<br>	<span class="hljs-comment">----------------------------------------------------</span><br>	<span class="hljs-number">1001</span>			张三		<span class="hljs-number">001</span>		王老师<br>	<span class="hljs-number">1002</span>			李四		<span class="hljs-number">002</span>		赵老师<br>	<span class="hljs-number">1003</span>			王五		<span class="hljs-number">001</span>		王老师<br>	<span class="hljs-number">1001</span>			张三		<span class="hljs-number">002</span>		赵老师<br>这张表描述了学生和老师的关系：（<span class="hljs-number">1</span>个学生可能有多个老师，<span class="hljs-number">1</span>个老师有多个学生）<br>这是非常典型的：多对多关系！<br><br>分析以上的表是否满足第一范式？<br>	不满足第一范式。<br><br>怎么满足第一范式呢？修改<br><br>学生编号<span class="hljs-operator">+</span>教师编号(pk)		学生姓名  教师姓名<br><span class="hljs-comment">----------------------------------------------------</span><br><span class="hljs-number">1001</span>			<span class="hljs-number">001</span>				张三			王老师<br><span class="hljs-number">1002</span>			<span class="hljs-number">002</span>				李四			赵老师<br><span class="hljs-number">1003</span>			<span class="hljs-number">001</span>				王五			王老师<br><span class="hljs-number">1001</span>			<span class="hljs-number">002</span>				张三			赵老师<br><br>学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号<span class="hljs-operator">+</span>教师编号）<br>经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？<br>	不满足，“张三”依赖<span class="hljs-number">1001</span>，“王老师”依赖<span class="hljs-number">001</span>，显然产生了部分依赖。<br>	产生部分依赖有什么缺点？<br>		数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。<br><br>为了让以上的表满足第二范式，你需要这样设计：<br>	使用三张表来表示多对多的关系！！！！<br>	学生表<br>	学生编号(pk)		学生名字<br>	<span class="hljs-comment">------------------------------------</span><br>	<span class="hljs-number">1001</span>					张三<br>	<span class="hljs-number">1002</span>					李四<br>	<span class="hljs-number">1003</span>					王五<br>	<br>	教师表<br>	教师编号(pk)		教师姓名<br>	<span class="hljs-comment">--------------------------------------</span><br>	<span class="hljs-number">001</span>					王老师<br>	<span class="hljs-number">002</span>					赵老师<br><br>	学生教师关系表<br>	id(pk)			学生编号(fk)			教师编号(fk)<br>	<span class="hljs-comment">------------------------------------------------------</span><br>	<span class="hljs-number">1</span>						<span class="hljs-number">1001</span>						<span class="hljs-number">001</span><br>	<span class="hljs-number">2</span>						<span class="hljs-number">1002</span>						<span class="hljs-number">002</span><br>	<span class="hljs-number">3</span>						<span class="hljs-number">1003</span>						<span class="hljs-number">001</span><br>	<span class="hljs-number">4</span>						<span class="hljs-number">1001</span>						<span class="hljs-number">002</span><br></code></pre></td></tr></table></figure>
<ul>
<li>多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！</li>
</ul>
<h3 id="13-3-第三范式"><a href="#13-3-第三范式" class="headerlink" title="13.3 第三范式"></a>13.3 第三范式</h3><p>​    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">	学生编号（PK） 			学生姓名  班级编号  	班级名称<br><span class="hljs-comment">---------------------------------------------------------</span><br><br>​		<span class="hljs-number">1001</span>				张三		<span class="hljs-number">01</span>			一年一班<br>​		<span class="hljs-number">1002</span>				李四		<span class="hljs-number">02</span>			一年二班<br>​		<span class="hljs-number">1003</span>				王五		<span class="hljs-number">03</span>			一年三班<br>​		<span class="hljs-number">1004</span>				赵六		<span class="hljs-number">03</span>			一年三班<br><br>以上表的设计是描述：班级和学生的关系。很显然是<span class="hljs-number">1</span>对多关系！<br>一个教室中有多个学生。<br><br>分析以上表是否满足第一范式？<br>	满足第一范式，有主键。<br><br>分析以上表是否满足第二范式？<br>	满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。<br><br>分析以上表是否满足第三范式？<br>	第三范式要求：不要产生传递依赖！<br>	一年一班依赖<span class="hljs-number">01</span>，<span class="hljs-number">01</span>依赖<span class="hljs-number">1001</span>，产生了传递依赖。<br>	不符合第三范式的要求。产生了数据的冗余。<br><br>那么应该怎么设计一对多呢？<br><br>	班级表：一<br>	班级编号(pk)				班级名称<br>	<span class="hljs-comment">----------------------------------------</span><br>	<span class="hljs-number">01</span>								一年一班<br>	<span class="hljs-number">02</span>								一年二班<br>	<span class="hljs-number">03</span>								一年三班<br><br>	学生表：多<br><br>	学生编号（PK） 学生姓名 班级编号(fk)<br>	<span class="hljs-comment">-------------------------------------------</span><br>	<span class="hljs-number">1001</span>				张三			<span class="hljs-number">01</span>			<br>	<span class="hljs-number">1002</span>				李四			<span class="hljs-number">02</span>			<br>	<span class="hljs-number">1003</span>				王五			<span class="hljs-number">03</span>			<br>	<span class="hljs-number">1004</span>				赵六			<span class="hljs-number">03</span>		<br></code></pre></td></tr></table></figure>
<ul>
<li>一对多，两张表，多的表加外键！！！！！！！！！！！！</li>
</ul>
<p><strong>关于三范式的实际使用</strong></p>
<p>数据库设计三范式是理论上的，实践和理论有的时候有偏差。</p>
<p>最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。</p>
<p>因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）</p>
<p>有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。</p>
<p>面试的时候把这句话说上：他就不会认为你是初级程序员了！</p>
]]></content>
      <tags>
        <tag>mySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2022/04/09/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h1 id="单调栈思路"><a href="#单调栈思路" class="headerlink" title="单调栈思路"></a>单调栈思路</h1><p><strong>单调栈：在一个序列中，每个数左边/右边离它最近的”比它小/大“大的数在哪？</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220423105624.png" style="zoom: 67%;" /></p>
<p>首先想到的暴力做法就是双指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j; j -- )<br>        <span class="hljs-keyword">if</span>(a[i] &lt; a[j]) <br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; a[j] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>可以使用单调栈进行优化。为什么会想到单调栈呢？</p>
<p>双指针暴力的思路是确定一个点，找另一个点。这个点：</p>
<ol>
<li>刚好是往回找另一个点</li>
<li>往回找一个点是第一个比这个点小的，其余的数，对后面用不到（就可以删掉）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220423105637.png" alt=""></p>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220423105643.png" alt=""></p>
<p>流程：</p>
<ol>
<li>$stk[tt] &gt;= x$ 的话，出栈，一直出栈，直到找到栈顶 $stk[tt] &lt; x$</li>
<li>此时，这个数一定是第一个比它小的数（当然也可能栈空），判断栈的情况<ol>
<li>栈空，栈顶就是0，说明没有比它小的值，输出 $-1$</li>
<li>非空，输出栈顶</li>
</ol>
</li>
<li>把这个数 $x$ 存入栈</li>
</ol>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> stk[N], tt;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;  <span class="hljs-comment">// 如果栈顶元素大于当前待入栈元素，则出栈</span><br>        <span class="hljs-keyword">if</span> (!tt) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 &quot;</span>);  <span class="hljs-comment">// 如果栈空，则没有比该元素小的值。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, stk[tt]);  <span class="hljs-comment">// 栈顶元素就是左侧第一个比它小的元素。</span><br>        stk[ ++ tt] = x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Neural Architecture Search with reinforcement learning</title>
    <url>/2022/04/05/Neural%20Architecture%20Search%20with%20reinforcement%20learning/</url>
    <content><![CDATA[<h1 id="Neural-Architecture-Search-with-reinforcement-learning"><a href="#Neural-Architecture-Search-with-reinforcement-learning" class="headerlink" title="Neural Architecture Search with reinforcement learning"></a>Neural Architecture Search with reinforcement learning</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>超参数：指的是搭建神经网络之前需要手动设置的一些数值。</p>
<ul>
<li>神经网络结构超参数：比如卷积层数，卷积核数量，卷积核大小…</li>
<li>优化算法超参数：SGD/Adam等等，学习率，batch大小，epoches的数量…</li>
</ul>
<p>神经结构搜索的早期方法主要是基于强化学习或进化算法，指导神经网络的搜索。大体的过程如图中的早期NAS架构所示，首先定义好搜索空间，通过搜索策略采样得到一个网络结构，进行性能评估并反馈给搜索策略，重复上述过程，直至得到一个表现最佳的神经网络结构。近年来，基于权重共享(weight-sharing)的结构搜索方法兴起，在这类方法中，搜索策略和性能评估是高度相关的。于是，现阶段的NAS架构主要是在搜索空间定义好的基础上，进行结构搜索与优化，继而得到性能最优的网络结构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405184326.png" style="zoom: 80%;" /></p>
<p>NAS：寻找最优的网络结构使得验证集准确率最大化。</p>
<h3 id="搜索空间-search-space"><a href="#搜索空间-search-space" class="headerlink" title="搜索空间 search space"></a>搜索空间 search space</h3><p>Search Space：包含所有可能的结构，如：卷积，池化，跳跃连接等等。需要先指定搜索空间，然后做搜索。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405185525.png" style="zoom: 33%;" /></p>
<p>输出每一层的结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405175857.png" style="zoom: 33%;" /></p>
<h3 id="搜索策略-search-strategy"><a href="#搜索策略-search-strategy" class="headerlink" title="搜索策略 search strategy"></a>搜索策略 search strategy</h3><p>搜索策略(search strategy)：寻找到一个神经网络，并能够最大化性能指标，例如在验证集上的准确率。</p>
<p>现阶段的搜索策略主要包含5种方法，分别为随机搜索、贝叶斯优化、进化算法、强化学习和基于梯度的方法。从历史上看，前4种搜索方式在一定程度上实现了神经结构搜索，但无法满足大多数研究人员的要求。于是，基于梯度的方法是目前的主流方向，革命性地将离散的结构搜索方式建模为一种连续松弛的搜索方式。尤其是，同以往在某个特定层固定操作相比，这种基于梯度的方法能够计算一系列操作的凸组合，灵活性更高。</p>
<p>下图是随机搜索的图例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195632.png" style="zoom:33%;" /></p>
<h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h3><p>神经网络结构搜索的巨大计算量主要来自对神经网络的性能进行评估,很多工作都在尝试解决该问题,主要方法大致可以分为以下 4类:</p>
<ol>
<li>低置信度的预测。降低训练步数，在部分数据集上进行训练或者在分辨率更低的数据集上进行训练。</li>
<li>在现有预训练模型的基础上进行结构改动，并在训练时继承原模型的权重。</li>
<li>对学习曲线进行插值,对精度进行预测。</li>
<li>将搜索到的所有结构都当做某个更大的超网络结构的子结构,所有子结构都继承超网络的权重，这种方式通常称为 one-shot。</li>
</ol>
<h2 id="NAS-via-RNN-RL"><a href="#NAS-via-RNN-RL" class="headerlink" title="NAS via RNN + RL"></a>NAS via RNN + RL</h2><p>介绍一篇论文：Neural Architecture Search with reinforcement learning，ICLR 2017。主要是用了 RNN + RL 来做 NAS。</p>
<p>初始状态 $h_0$ 向量和初始输入 $x_0$ 向量输入到 RNN 网络里，输出一个 向量 $h_1 = tanh(W \cdot[h_0;x_0] + b)$，$h_1$ 输入到 一个 softmax 分类器。softmax分类器是指1个或多个全连接层+softmax函数。输出 $p_1$ 得到这一步任务的输出，就是几个概率值。选出最大的概率值，对应的方案就是这一步的输出。然后将结果进行 one hot 表示，得到了这一步的输出 $a_1$.</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195642.png" style="zoom: 33%;" /></p>
<p>接下来做 embedding，将 one hot 向量映射成一个稠密向量。embedding 的结果记作 $x_1$。通过 embedding 层的过程就是将 one hot 向量 通过一个参数矩阵，映射成一个稠密向量。参数矩阵刚开始随机初始化，之后根据训练数据进行学习。 embedding 层的参数可以在相同任务中重复利用。这是一步的过程。将上一层的隐藏状态 $h_1$ 和 $a_1$ 作为下一步的输入，就进行了下一步的动作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195650.png" style="zoom: 33%;" /></p>
<p>关于 softmax 分类器：每一步的 softmax 分类器都是独立的，不可以和其他步的公用。任务不一样不应该共用softmax分类器，因为1. 每一步的任务是不同的，2. 输出的向量维度都不一样。</p>
<p>第一步运行完后，得到了第一层的超参数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195659.png" style="zoom: 33%;" /></p>
<p>RNN 如此运行60步，每一步生成一个超参数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405195712.png" style="zoom: 33%;" /></p>
<p>这个东西就叫做 Controller RNN。接下来训练它，目的是让生成的CNN 结构能最大化验证集的准确率。</p>
<h3 id="训练-Controller-RNN"><a href="#训练-Controller-RNN" class="headerlink" title="训练 Controller RNN"></a>训练 Controller RNN</h3><p>Controller RNN 运行60步，生成20个卷积层的超参数。按照超参数来搭建一个CNN。假设只搜索卷积层的超参数，其他类型的层都手动设置。搭建好CNN后进行训练。训练后计算验证集上的准确率。用准确率来更新 Controller RNN 的参数。</p>
<p>整体的流程表示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220406165703.png" style="zoom:33%;" /></p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>一个优化问题：对于目标函数 $r$，$\theta$ 是它的参数，优化目标是找 $\theta$ 使得目标函数的值最大。如果目标函数 $r$ 是 $\theta$ 的可微函数，就很容易，计算函数 $r$ 关于 $\theta$ 的梯度，然后梯度上升就好了。但是 函数 $r$ 关于 $\theta$ 不可微，就无法计算函数 $r$ 关于 $\theta$ 的梯度。</p>
<p>在我们的问题中，目标函数 $r$ 是 CNN 在验证集上的准确率，而优化的变量 $\theta$ 是 Controller RNN 的参数， $r$ 不是关于 $\theta$ 的函数，也就不可微。</p>
<p>所以想到了 强化学习，但是 RL 也有问题，需要大量的训练才能收集奖励。</p>
<h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>目标：改进 Controller RNN 使得验证集准确率逐渐提高。</p>
<p><strong>Reward</strong>：验证集准确率</p>
<p><strong>Policy function</strong>：Controller RNN。用 policy gradient ascent 来更新策略函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220405180218.png"  style="zoom: 33%;" /></p>
<p>在前59步看不到验证集准确率，在第60步后才能看到，所以让前59步奖励都是0，第60步的奖励为准确率。</p>
<p>Return (aka cumulative reward)：$ u<em>t = r_t+r</em>{t+1} + … + r<em>{59} + r</em>{60}$</p>
<p>所以，所有 return 都相等： $u_1=u_2=…=u_60=ValAcc$</p>
<h3 id="REINFORCE-Algorithm"><a href="#REINFORCE-Algorithm" class="headerlink" title="REINFORCE Algorithm"></a>REINFORCE Algorithm</h3><p>近似策略梯度：</p>
<script type="math/tex; mode=display">
\frac{\partial \log \pi\left(\mathbf{a}_{t+1} \mid\left[\mathbf{h}_{t}, \mathbf{x}_{t}\right] ; \boldsymbol{\theta}\right)}{\partial \boldsymbol{\theta}} \cdot u_{t}</script><p>用近似策略梯度更新参数 $\theta$</p>
<script type="math/tex; mode=display">
\boldsymbol{\theta} \leftarrow \boldsymbol{\theta}+\beta \cdot \sum_{t=1}^{60} \frac{\partial \log \pi\left(\mathbf{a}_{t+1} \mid\left[\mathbf{h}_{t}, \mathbf{x}_{t}\right] ; \boldsymbol{\theta}\right)}{\partial \boldsymbol{\theta}} \cdot u_{t}</script><h3 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h3><ul>
<li>用  Controller RNN 生成20个卷积层的超参数（20*3=60个）。</li>
<li>搭建出CNN；训练CNN；在验证集计算CNN准确率；把准确率作为 reward</li>
<li>REINFORCE Algorithm 用 reward 来更新策略函数 Controller RNN</li>
<li>将这个过程重复上万次 </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>更新一次 Controller RNN，需要从头训练 CNN，训练一次就很长时间了。想要训练好 RNN，至少得训练 10000+ 次CNN。</li>
<li>用 RNN 训练 CNN 找超参数，但 RNN 自己本身就有很多超参数，比如循环层的层数， $x/h$ 向量的维度。调RNN 的超参数也需要很多时间。</li>
</ol>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>RLNAS</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列</title>
    <url>/2022/04/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="单调队列思路"><a href="#单调队列思路" class="headerlink" title="单调队列思路"></a>单调队列思路</h1><p>单调队列可以用来解决滑动窗口问题。</p>
<p>举个例子，从数组中第一个元素开始遍历，由于窗口的大小是<code>3</code>，因此当遍历到第三个元素时，窗口就形成了。之后，继续遍历元素时，为了保持窗口的大小为3，左侧元素就需要从窗口中剔除。这样使得窗口一直在向右移动，直到考察到最后一个元素结束，这就是所谓的滑动窗口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424142653.png" alt="image-20220424142349088" style="zoom:60%;" /></p>
<p>解题思路（以最小值为例）：</p>
<p>由于我们需要求出的是滑动窗口的最小值。</p>
<ul>
<li><p>如果当前的滑动窗口中有两个下标 <code>i</code> 和 <code>j</code> ，其中<code>i</code>在<code>j</code>的左侧（<code>i</code>&lt;<code>j</code>），并且<code>i</code>对应的元素不大于j对应的元素（<code>a[i]≤a[j]</code>），则：</p>
<p>当滑动窗口向右移动时，只要 <code>i</code> 还在窗口中，那么 <code>j</code> 一定也还在窗口中。这是由于 <code>i</code> 在 <code>j</code> 的左侧所保证的。</p>
<p><strong>因此，由于 <code>a[j]</code> 的存在，<code>a[i]</code> 一定不会是滑动窗口中的最大值了，我们可以将<code>a[i]</code>永久地移除。</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424151349.png" alt=""></p>
<ul>
<li><p>因此我们可以使用一个<strong>队列</strong>存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组<code>a[]</code>中对应的值是严格单调递增的。</p>
</li>
<li><p>当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。</p>
</li>
<li><p>为了保持<strong>队列的单调性的性质</strong>，我们会不断地将新的元素与队尾的元素相比较，如果新元素小于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。</p>
</li>
<li><p>由于队列中下标对应的元素是严格单调递增的，因此此时队首下标对应的元素就是滑动窗口中的最大值。</p>
</li>
<li><p>窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。</p>
</li>
</ul>
<p>滑动窗口思路：</p>
<ol>
<li>队首已经出窗口：<code>if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ;</code></li>
<li>解决队尾与当前元素 <code>a[i]</code> 不满足单调性的问题：<code>while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;</code></li>
<li>将当前元素下标加入队尾：<code>q[++ tt] = i;</code></li>
<li>如果满足条件则输出结果：<code>if(i + 1&gt; = k) cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;</code></li>
</ol>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-AcWing-154-滑动窗口"><a href="#1-AcWing-154-滑动窗口" class="headerlink" title="1. AcWing 154. 滑动窗口"></a><a href="https://www.acwing.com/problem/content/156/">1. AcWing 154. 滑动窗口</a></h2><p>模板题。</p>
<p>求滑动窗口内的最小值和最大值。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-keyword">int</span> a[N], q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) hh ++ ;   <span class="hljs-comment">// 若队首出窗口，hh加1</span><br><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;  <span class="hljs-comment">// 若队尾不单调，tt减1</span><br>        q[ ++ tt] = i;  <span class="hljs-comment">// 下标加到队尾</span><br><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);  <span class="hljs-comment">// 输出结果</span><br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) hh ++ ;<br><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt -- ;<br>        q[ ++ tt] = i;<br><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2022/04/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集思路"><a href="#并查集思路" class="headerlink" title="并查集思路"></a>并查集思路</h1><p>并查集：</p>
<ol>
<li><p><strong>将两个集合合并</strong></p>
</li>
<li><p><strong>询问两个元素是否在一个集合中</strong></p>
<p>基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存它的父节点，<code>p[x]</code> 表示 x 的父节点</p>
</li>
</ol>
<p>问题：</p>
<ol>
<li>如何判断树根：<code>if(p[x] == x)</code>，x 的父节点是x自己，说明它是根节点</li>
<li>如何求 x 的集合编号：<code>while(p[x] != x) x = p[x];</code>，如果 x 的父节点不是x自己(x不是根节点)，让x上移变为父节点，递归寻找到最终的根节点，就是x的集合编号</li>
<li>如何合并两个集合：<code>p[x] = y</code>。其中，<code>p[x]</code> 是 x 的集合编号，<code>p[y]</code> 是 y 的集合编号。</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化就是将当前数据的父节点指向自己：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i ++) p[i] = i;<br></code></pre></td></tr></table></figure>
<p>上面的代码实现的结果如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220420115154.png" alt=""></p>
<h2 id="查找-路径压缩"><a href="#查找-路径压缩" class="headerlink" title="查找 + 路径压缩"></a>查找 + 路径压缩</h2><p>$find()$ 函数的功能是用于查找祖先节点 和 路径压缩。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回x的祖先节点 + 路径压缩</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 祖先节点的父节点是自己本身</span><br>    <span class="hljs-comment">// 如果x的父节点不是自己(说明x不是祖先节点)</span><br>    <span class="hljs-keyword">if</span>(p[x] != x) <br>        <span class="hljs-comment">// 就将x的父节点置为x的父节点的祖先节点，实现路径压缩</span><br>        p[x] = find(p[x]);<br>    <br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>路径压缩的过程，举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220420115343.png" alt=""></p>
<p>针对 x = 1：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220420180107.png" alt=""></p>
<p>这个递归过程，将所有的1，2，3的父节点全部置为了4，实现路径压缩；同时也实现了1的父节点的返回。</p>
<p>Note：这个找祖宗节点的写法更好理解一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fa[x] = find(fa[x]);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-AcWing-836-合并集合"><a href="#1-AcWing-836-合并集合" class="headerlink" title="1. AcWing 836. 合并集合"></a><a href="https://www.acwing.com/problem/content/838/">1. AcWing 836. 合并集合</a></h2><blockquote>
<p>模板题</p>
</blockquote>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> p[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = find(p[x]);<br>    <br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        p[i] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;M&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>            p[find(a)] = find(b);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>            <span class="hljs-keyword">if</span>(find(a) == find(b)) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-AcWing-837-连通块中点的数量"><a href="#2-AcWing-837-连通块中点的数量" class="headerlink" title="2. AcWing 837. 连通块中点的数量"></a><a href="https://www.acwing.com/problem/content/839/">2. AcWing 837. 连通块中点的数量</a></h2><p>给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。</p>
<p>现在要进行 m 个操作，操作共有三种：</p>
<ol>
<li><code>C a b</code>，在点 a 和点 b 之间连一条边，a 和 b 可能相等；</li>
<li><code>Q1 a b</code>，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；</li>
<li><code>Q2 a</code>，询问点 a 所在连通块中点的数量；</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>也是模板题，加了一点点小变形。</p>
</blockquote>
<ol>
<li><p>初始化：注意Size数组，只在祖节点有意义，表示这棵树的节点数量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        fa[i] = i;<br>        Size[i] = <span class="hljs-number">1</span>;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>找祖源（我觉得这个写法挺好理解）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fa[x] = find(fa[x]);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>合并：<strong>注意如果没有提前定义变量，要先把祖宗节点数量加过去，再合并子树。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = find(a);<br>    <span class="hljs-keyword">int</span> y = find(b);<br>    fa[x] = y;<br>    size[y] += size[x];  <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>询问是否连通</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> find(a)==find(b);<br>   &#125;<br><br>##<span class="hljs-meta"># code</span><br><br>```c++<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> p[N], Size[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b;<br>    <span class="hljs-keyword">char</span> op[<span class="hljs-number">5</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <br>    &#123;<br>        p[i] = i;<br>        Size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;C&#x27;</span>) <br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br><br>            <span class="hljs-keyword">if</span>(find(b) != find(a))<br>            &#123;<br>                Size[find(b)] += Size[find(a)];  <span class="hljs-comment">// 注意这里一定是先加长度，加集合！动脑子思考一下</span><br>                p[find(a)] = find(b);<br>            &#125;    <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>            <span class="hljs-keyword">if</span> (find(a) == find(b)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;   <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, Size[find(b)]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-AcWing-240-食物链"><a href="#3-AcWing-240-食物链" class="headerlink" title="3. AcWing 240. 食物链"></a><a href="https://www.acwing.com/problem/content/description/242/">3. AcWing 240. 食物链</a></h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220428151447.png"  style="zoom: 80%;" /></p>
<blockquote>
<p>思路还不是太清晰。。等遇到并查集再回来看</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟队列</title>
    <url>/2022/04/07/%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="模拟队列思路"><a href="#模拟队列思路" class="headerlink" title="模拟队列思路"></a>模拟队列思路</h1><p>用数组模拟队列：</p>
<ul>
<li>用 $hh$ 表示队头的索引，$tt$ 表示队尾的索引。初始时，<code>hh = 0, tt = -1</code>。表示没有元素，队列为空。</li>
<li><code>push x</code>：队尾所在索引往后移动一格，然后放入x。<code>q[ ++ top] = x;</code>。</li>
<li><code>pop</code>：队头 hh 往后移动一格。<code>hh ++ ;</code></li>
<li><code>empty</code>：<code>hh &gt; tt ? “YES” : “NO”</code>。$hh&lt;=tt$ 时，队列有元素。</li>
<li><code>query</code>：返回队头元素。<code>q[hh];</code></li>
</ul>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(n -- )<br>    &#123;<br>        <span class="hljs-built_in">string</span> op;<br>        <span class="hljs-keyword">int</span> x;<br>        <br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            q[ ++ tt] = x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;empty&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(hh &lt;= tt) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;query&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; q[hh] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;pop&quot;</span>) hh ++ ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟栈</title>
    <url>/2022/04/05/%E6%A8%A1%E6%8B%9F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="模拟栈思路"><a href="#模拟栈思路" class="headerlink" title="模拟栈思路"></a>模拟栈思路</h1><p>用数组模拟栈：</p>
<ul>
<li>用 $top$ 表示栈顶所在的索引。初始时，<code>top = -1</code>。表示没有元素。</li>
<li><code>push x</code>：栈顶所在索引往后移动一格，然后放入x。<code>stk[ ++ top] = x;</code>。</li>
<li><code>pop</code>: top 往前移动一格。<code>top --;</code></li>
<li><code>empty</code>：top 大于等于 0 栈非空，小于 0 栈空。<code>top == -1 ? “YES” : “NO”</code></li>
<li><code>query</code>：返回栈顶元素。<code>stk[top]</code></li>
</ul>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> stk[N];<br><span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n -- )<br>    &#123;<br>        <span class="hljs-built_in">string</span> s;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br><br>        <span class="hljs-comment">//栈顶所在索引往后移动一格，然后放入x。</span><br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> a;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; a;<br>            stk[ ++ top] = a;<br>        &#125;<br><br>        <span class="hljs-comment">//往前移动一格</span><br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)<br>        &#123;<br>            top --;<br>        &#125;<br>        <span class="hljs-comment">//返回栈顶元素</span><br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; stk[top] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>        <span class="hljs-comment">//大于等于 0 栈非空，小于 0 栈空</span><br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; (top == <span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-AcWing-3302-表达式求值"><a href="#1-AcWing-3302-表达式求值" class="headerlink" title="1. AcWing 3302. 表达式求值"></a><a href="https://www.acwing.com/problem/content/3305/">1. AcWing 3302. 表达式求值</a></h3><p>题目：给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>“表达式求值”问题，两个核心关键点：</p>
<ol>
<li><p>双栈，一个操作数栈，一个运算符栈；</p>
</li>
<li><p>运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：</p>
</li>
</ol>
<ul>
<li><p><strong>栈顶运算符的优先级低的话，就直接入栈新的运算符。</strong></p>
</li>
<li><p><strong>栈顶运算符的优先级高的话，必须出栈计算，才能入栈新的运算符，</strong></p>
<ul>
<li><strong>相同操作符的话，也认为栈顶的优先级高，先进行运算，再入栈新的运算符。</strong></li>
</ul>
</li>
</ul>
<p>这个方法的时间复杂度为O(n)，整个字符串只需要扫描一遍。</p>
<hr>
<p>举个例子：</p>
<p>开始，初始化好输入的字符串，以及操作数栈，运算符栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100554.png" style="zoom:70%;" /></p>
<p>一步步，扫描字符串，操作数一个个入栈，运算符也入栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100557.png" style="zoom:70%;" /></p>
<p>下一个操作符要入栈时，需要先比较优先级。栈内的优先级高，必须先计算，才能入栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100620.png" style="zoom:70%;" /></p>
<p>计算的过程为：(<code>eval()</code> 函数)</p>
<ol>
<li>操作数出栈，作为num2；</li>
<li>操作数出栈，作为num1；</li>
<li>运算符出栈，作为op；</li>
<li>根据运算符计算出结果；</li>
<li>将结果入栈</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100628.png" style="zoom:70%;" /></p>
<p>接下来，运算符和操作数继续入栈。</p>
<p>下一个操作符要入栈时，继续比较与栈顶的优先级。栈内的优先级低，可以直接入栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100639.png" style="zoom:70%;" /></p>
<p>字符串继续移动。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100646.png" style="zoom:70%;" /></p>
<p>需要比较优先级了。栈内的优先级高，先计算（3*4=12），再入栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100659.png" style="zoom:67%;" /></p>
<p>继续将数字和操作符入栈。操作符要比较优先级，栈顶优先级低，操作符入栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100707.png" style="zoom:67%;" /></p>
<p>此时字符串扫描完毕。</p>
<p>开始出栈操作符，直至操作符都出栈，12 * 5 = 60, 3 + 60 = 63，所有数计算完毕。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220421100721.png" style="zoom:67%;" /></p>
<h4 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h4><ul>
<li><code>(</code> 不在map中默认对应的值是0</li>
</ul>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; num;<br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; op;<br><br><span class="hljs-comment">// 优先级表</span><br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; pr&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> b = num.top(); num.pop();  <span class="hljs-comment">// 第二个操作数</span><br>    <span class="hljs-keyword">auto</span> a = num.top(); num.pop();  <span class="hljs-comment">// 第一个操作数</span><br>    <span class="hljs-keyword">auto</span> c = op.top(); op.pop();    <span class="hljs-comment">// 运算符 </span><br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span>) x = a + b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) x = a - b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span>) x = a * b;<br>    <span class="hljs-keyword">else</span> x = a / b;<br>    <br>    num.push(x);  <span class="hljs-comment">// 结果入栈 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> str;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; str;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.size(); i ++ )<br>    &#123;<br>        <span class="hljs-keyword">auto</span> c = str[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))  <span class="hljs-comment">// 把这个数取出来(可能是多位)</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; str.size() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[j]))<br>                x = x * <span class="hljs-number">10</span> + str[j ++ ] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            i = j - <span class="hljs-number">1</span>;<br>            num.push(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) op.push(c);  <span class="hljs-comment">// 左括号无优先级，直接入栈</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.top() != <span class="hljs-string">&#x27;(&#x27;</span>) eval();  <span class="hljs-comment">// 一直计算到左括号</span><br>            op.pop();  <span class="hljs-comment">// 左括号出栈</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 待入栈运算符优先级低，则先计算</span><br>            <span class="hljs-keyword">while</span> (op.size() &amp;&amp; op.top() != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; pr[op.top()] &gt;= pr[c]) eval();  <br>            op.push(c);  <span class="hljs-comment">// 操作符入栈</span><br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">while</span> (op.size()) eval();  <span class="hljs-comment">// 剩余的进行计算</span><br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; num.top() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>【CGP-CNN】A Genetic Programming Approach to Designing Convolutional Neural Network  Architectures</title>
    <url>/2022/05/30/%E3%80%90CGP-CNN%E3%80%91A%20Genetic%20Programming%20Approach%20to%20Designing%20Convolutional%20Neural%20Network%20%20Architectures/</url>
    <content><![CDATA[<h1 id="cgp-cnna-genetic-programming-approach-to-designing-convolutional-neural-network-architectures">【CGP-CNN】A Genetic Programming Approach to Designing Convolutional Neural Network Architectures</h1>
<ul>
<li>GECCO 2017</li>
</ul>
<p>在本文中，作者设计基于遗传编程的CNN架构。使用笛卡尔遗传编程（CGP）编码方案，一种直接编码方案，来表示CNN的结构和连通性。这种表示法的优点是它的灵活性；它可以表示可变长度的网络结构和跳跃连接。此外，作者采用了功能相对较高的模块，如卷积块和张量拼接，作为CGP中的节点函数，以减少搜索空间。为了评估CGP所代表的体系结构，以普通方式使用训练数据集训练网络。</p>
<h2 id="cgp-编码">CGP 编码</h2>
<p>遗传规划(Genetic Programming，GP) ：是在遗传算法基础上发展起来的优化算法，属于进化算法中的一种。GP 模拟达尔文生物进化的基本原理，采用树形结构来表示个体，采用选择、交叉、变异作为操作算子，动态地改变个体所代表的程序结构，根据个体适应度筛选、演化，在庞大的解空间中寻找最优解。</p>
<p>笛卡尔遗传规划 CGP：GP 个体在演化过程中存在基因型意外增长的情况，即膨胀问题。然后出现了笛卡尔遗传规划(Cartesian Genetic Programming，CGP)。CGP 是一种不受程序膨胀影响的多输入多输出模型。CGP 中的个体，不再采用树形结构，而是使用二维有向图表示，每个 CGP 个体具有定长基因型。</p>
<p>标准 CGP 中，个体采用二维有向无环图的形式来表示。在个体基因型中，图中的每一个节点都被一组整数来表示。这组整数指明了该节点的操作函数，以及节点数据的传送方向。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220505163022.png" style="zoom:67%;" /></p>
<p>图 2-1 表示了 CGP 个体中一个节点的编码，第一个整数基因 Function ID 被用来表示该节点的函数基因(function gene)，其余的基因：Connect ID 1、Connect ID 2 被称为连接基因(connection gene)。函数基因处的数字代表该节点处进行的函数运算，在个体初始化时随机从用户设置的可选函数列表中选出。连接基因处的数字代表与该节点相连的前向节点的位置，即指明该节点该从哪里获取输入数据。节点以前馈方式，随机从前一列中的节点输出或程序输入中获得输入，确定连接。CGP 个体中网络节点的基因型长度是有限制的，这取决于计算函数能够允许的最大输入。如图 2-1 中，该节点所在的网络中，计算函数允许的最大输入数为 2。</p>
<p>由于 CGP 个体初始化及其演化过程的随机性，不能保证每一个节点都被后继节点连接，故而在 CGP 个体在从基因型编译成表现型的过程中，会有一部分网络节点被忽略，不在表现型中体现作用。在这种情况下，在表现型中起作用的节点被称之为活跃节点(active node)，反之则被称为非活跃节点(inactive node)。有研究认为这种非活跃节点的冗余，非常有益于进化搜索的过程</p>
<p>在标准 CGP 中，有三个可以由用户选择的参数：列数(columns)、行数(rows)和连接度(level-back)，分别用 Nc，Nr，l 表示。列数 Nc 和行数 Nr 决定 CGP 个体网络的排布方式，和基因型长度：Ln=Nr×Nr。连接度𝑙决定了这个二维有向图的连接性，𝑙表示当前节点最多能够与前 l 列的节点相连，即如果 l=1，则该图中每个节点都只能与前列节点相连，如果 l=2，则每个节点只能与它左侧最近两列中的节点相连。当 l=Nc 时，全图的节点能够与任何一个位于自己前列的节点相连。标准 CGP 中，不允许节点的同列连接。</p>
<p>CGP的问题：在标准 CGP 中，仅使用点突变作为操作算子，种群多样性较低，种群演化结果依赖初始化个体优劣、搜索能力不足。标准 CGP 个体采用定长基因型，基因型的长度依靠经验值，无法适应未知规模的问题。由此两点分析，标准 CGP 种群的演化效率，存在提升的空间。</p>
<h2 id="cgp-cnn">CGP-CNN</h2>
<p>CGP-CNN 中，使用二维拓扑结构的 CGP 表示 CNN 结构，并采用一系列功能强大的 CNN 模块作为每个节点可选用的函数。CGP 编码的 CNN 在演化过程中解码并搭建 CNN，并使用训练集数据进行训练，将验证集上的 CNN 精度作为演化过程中 CGP 个体的适应度值 fitness。在演化过程中，通过操作算子，CGP 个体不断演化迭代，所表示的 CNN 也逐步提升在验证集上的进度。在达到演化停止条件后，终止演化进程，解码得到的 CNN 即为最佳个体，对其进行再训练，在测试集上测试最终精度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220429173524.png" style="zoom: 67%;" /></p>
<p>作者使用CGP编码方案，将程序表示为在计算节点上定义有向无环图，用于CNN架构表示。</p>
<p>在 CGP 中，个体基因型为一系列整数，它们被用来表示二维图中节点的操作、节点之间的链接以及输入与输出的指向。</p>
<p>genotype 基因型由固定长度的整数组成，每个基因都有关于节点类型和连接的信息。genotype 第一位表示选用的节点类型，23位表示的是节点的输入。若该节点处的函数只需要一个输入，则只有第一个连接基因生效。虽然 CGP 中的基因型是固定长度的表示，但 phenotype 网络中的节点数量不同，因为并非所有节点都连接到输出节点。图2左侧的5号节点是一个非活动节点。</p>
<p>下图所示为一种 CGP-CNN 的编码方式，其中左边是 Genotype，右边是CNN架构图，节点5是一个未激活的节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220429173545.png" /></p>
<h3 id="cgp-cnn的节点类型">CGP-CNN的节点类型</h3>
<p>CGP-CNN算法中包括 6 种节点类型，分别是 ConvBlock、ResBlock、Max Pooling、Average Pooling、Concatenation 和 Summation。这些节点操作由行、列 和通道的大小定义成三维(3D)张量。</p>
<ol type="1">
<li>ConvBlock 由标准卷积处理组成，步长为1，然后是批量归一化和ReLU激活函数，其中，卷积块不进行降维，因此，采用零值填充来保持前后特征图维度不变，并且具有不同大小的 KernelSize 和不同的 Channel 数。</li>
<li>ResBlock 由卷积处理、批量归一化、ReLU函数和张量求和组成。ResBlock 架构如图所示，输入的行和列大小与卷积后的 ConvBlock 保持一致。在 ResBlock 中，M×N×C的输入特征映射被变换为M×N×C'的输出映射，并且具有不同大小的KernelSize和不同的输出Channel数。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220429173536.png" style="zoom:50%;" /></p>
<ol start="3" type="1">
<li>Pooling 池化层执行 Max Pooling 和 Average Pooling 的操作，使用 2 × 2 的 Kernel，步长 Stride = 2。</li>
<li>Concatenation 将不同特征图进行合并，如果特征图大小不同，则对更大的特征图进行 MaxPooling 完成下采样，从而实现特征图大小一致。</li>
<li>Summation 主要用于 skip-connection 的特征图元素两两相加，当特征图大小不同时，对更大的特征图进行最大池化完成下采样，从而实现特征图大小一致。</li>
</ol>
<h3 id="cgp-cnn-的编码方式">CGP-CNN 的编码方式</h3>
<p>基于进化算法的神经网络架构在应用时，通常有直接编码和间接编码2种编码形式。直接编码主要将神经元的数量和链接情况作为基因类型，而间接编码主要表达网络架构的生成规则。</p>
<p>CGP-CNN 算法采用笛卡尔基因编程这种直接编码的方式，从而表示CNN的结构和连通性。CGP-CNN 算法具有灵活性，可以表示可变长度的网络结构和跳远链接。</p>
<h3 id="cgp-cnn-的进化过程">CGP-CNN 的进化过程</h3>
<p>CGP-CNN算法的变异方式有2种：第1种是强制突变，为了有效地使用计算资源，需要在每一代并行地评估一些候选解决方案，因此，在使用变异操作时，要保证至少有一个活动节点改变之后出现后选解，此时称为强制突变。第2种是中性突变，为了维持对CGP进化的有效性，如果后代的适应度值没有得到改善，可以通过使用中性突变的方式重新对父代执行变异操作，在中性突变过程中，只改变非活动节点的基因而不改变Phenotype。</p>
<p>使用点突变（point mutation）作为遗传算子，方法与标准CGP相同。每个节点的类型和连接根据突变率随机更改为有效值。标准的CGP突变可能只影响非活动的node。在这种情况下，phenotype表型（代表CNN结构）不会因突变而改变，也不需要再次进行适应性评估。</p>
<p>在上述策略中使用了改进的（1+λ）进化策略（实验中λ=2）。改进算法的步骤如下：</p>
<ol type="1">
<li>随机生成一个初始个体作为父代个体P，训练以P表示的CNN，然后指定验证精度作为适应度。</li>
<li>通过将强制突变应用于P，生成一组λ子代C。</li>
<li>并行训练子代C代表的λ CNN，并将验证精度指定为适应度。</li>
<li>将中性突变应用于亲本P。</li>
<li>从P和C集合中选择一个精英个体，然后用精英个体替换P。</li>
<li>返回步骤2，直到满足停止条件。</li>
</ol>
<h2 id="summary">Summary</h2>
<p>CGP-CNN算法验证了在自动构建CNN架构时，可以使用笛卡尔基因编程的方式，并且基本单元可以采用如 ConvBlock、ＲesBlock 这样的构建块。</p>
<p>但是，为了得到效果更好的网络结构，在进化过程中，CGP-CNN 算法需要消耗很多资源，因此，后续将重点研究降低计算资源消耗的方法，或者在进化过程中通过减少多余的CNN结构来实现进化算法的优化。例如，随着生成的进行，增加神经网络的训练数据。此外，为了简化CNN结构，可以考虑将<strong>正则化</strong>技术应用到优化过程中。此外，还可以通过<strong>删除冗余或效率较低的层</strong>来手动简化获得的CNN架构。另一个未来的工作是将所提出的方法应用于其他图像数据集和任务。</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>CGP-CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis笔记</title>
    <url>/2022/06/16/MyBatis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="mybatis笔记">MyBatis笔记</h1>
<h2 id="一搭建mybatis">一、搭建MyBatis</h2>
<h3 id="创建maven工程">创建maven工程</h3>
<ul>
<li>打包方式：jar</li>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- Mybatis核心 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- junit测试 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="创建mybatis的核心配置文件">创建MyBatis的核心配置文件</h3>
<blockquote>
<p>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以可以直接复制、粘贴。</p>
</blockquote>
<ul>
<li><p>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</p></li>
<li><p>核心配置文件存放的位置是 <code>src/main/resources</code> 目录下</p></li>
<li><p><strong>注意：引入映射文件时，一定是 <code>/</code></strong>，例如：<code>&lt;mapper resource=&quot;com/atguigu/mybatis/mapper/ParameterMapper.xml&quot;/&gt;</code></p>
<blockquote>
<p>跌坑里了...</p>
</blockquote></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>  <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span>  </span><br><span class="hljs-meta">PUBLIC <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span><br><span class="hljs-meta"><span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <br>	<span class="hljs-comment">&lt;!--设置连接数据库的环境--&gt;</span>  <br>	<span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>  <br>		<span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>  <br>			<span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>  <br>			<span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>  <br>				<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  <br>				<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span>  <br>				<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>  <br>				<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span>  <br>			<span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>  <br>		<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>  <br>	<span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>  <br>    <br>	<span class="hljs-comment">&lt;!--引入映射文件--&gt;</span>  <br>	<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>		<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span>  <br>	<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="创建mapper接口">1. 创建mapper接口</h3>
<p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类</p>
<p>Mybatis面向接口编程的两个一致：</p>
<ol type="1">
<li><p>映射文件的 namespace 要和 mapper 接口中全类名 <code>com.atguiu.mybatis.mapper.UserMapper</code> 保持一致</p></li>
<li><p>映射文件中SQL语句的 id 要和 mapper 接口中的方法名一致</p>
<p>表--实体类--mapper接口--映射文件</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mybatis.mapper;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123; <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Mybatis面向接口编程的两个一致：</span><br><span class="hljs-comment">     * 1. 映射文件的namespace要和mapper接口中全类名（com.atguigu.mybatis.mapper.UserMapper）保持一致</span><br><span class="hljs-comment">     * 2. 映射文件中SQL语句的id要和mapper接口中的方法名一致</span><br><span class="hljs-comment">     * 表--实体类--mapper接口--映射文件</span><br><span class="hljs-comment">     */</span><br>    <br>	<span class="hljs-comment">// 添加用户信息   </span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertUser</span><span class="hljs-params">()</span></span>;  <br>    <br>    <span class="hljs-comment">// 修改用户信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 删除用户信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 根据id查询用户信息</span><br>    <span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 查询所有的用户信息</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="创建mybatis的映射文件">2. 创建MyBatis的映射文件</h3>
<ul>
<li>相关概念：ORM（Object Relationship Mapping）对象关系映射。<br />
</li>
<li>对象：Java的实体类对象
<ul>
<li>关系：关系型数据库<br />
</li>
<li>映射：二者之间的对应关系</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th>Java概念</th>
<th>数据库概念</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>类</td>
<td>表</td>
</tr>
<tr class="even">
<td>属性</td>
<td>字段/列</td>
</tr>
<tr class="odd">
<td>对象</td>
<td>记录/行</td>
</tr>
</tbody>
</table>
<p>映射文件的命名规则：</p>
<ul>
<li>表所对应的实体类的类名 + Mapper.xml
<ul>
<li>例如：表t_user，映射的实体类为 User，所对应的映射文件为 UserMapper.xml</li>
<li>因此一个映射文件对应一个实体类，对应一张表的操作</li>
<li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li>
<li>MyBatis映射文件存放的位置是src/main/resources/mappers目录下</li>
</ul></li>
<li>MyBatis中可以面向接口操作数据，要保证两个一致</li>
<li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致
<ul>
<li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>  <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span>  </span><br><span class="hljs-meta">PUBLIC <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><br><span class="hljs-meta"><span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span>  <br>	<span class="hljs-comment">&lt;!--int insertUser();--&gt;</span>  <br>	<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span>  <br>		insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)  <br>	<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="通过junit测试功能">3. 通过junit测试功能</h3>
<ul>
<li><strong>SqlSession：代表Java程序和数据库之间的会话。</strong>（HttpSession是Java程序和浏览器之间的会话）</li>
<li>SqlSessionFactory：是“生产”SqlSession的“工厂”</li>
<li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsertUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 1. 读取MyBatis的核心配置文件,获取字节输入流</span><br>        InputStream is = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <br>        <span class="hljs-comment">// 2. 获取SqlSessionFactoryBuilder对象</span><br>        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        <br>        <span class="hljs-comment">// 3. 通过核心配置文件所对应的字节输入流,通过bulid()方法创建工厂类SqlSessionFactory，生产SqlSession对象</span><br>        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);<br>        <br>        <span class="hljs-comment">// 4. 获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span><br>        <span class="hljs-comment">// SqlSession sqlSession = sqlSessionFactory.openSession();</span><br>	    <span class="hljs-comment">// 创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  </span><br>		SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>);<br>        <br>        <span class="hljs-comment">//5. 通过代理模式创建UserMapper接口的代理实现类对象</span><br>        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>        <br>        <span class="hljs-comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span><br>        <span class="hljs-keyword">int</span> result = userMapper.insertUser();<br>        System.out.println(<span class="hljs-string">&quot;result:&quot;</span> + result);<br>        <br>        <span class="hljs-comment">//提交事务</span><br>        <span class="hljs-comment">//sqlSession.commit();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用<code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code>，传入一个Boolean类型的参数，值为true，这样就可以自动提交</li>
</ul>
<h3 id="加入log4j日志功能">加入log4j日志功能</h3>
<ol type="1">
<li><p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- log4j日志 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>加入log4j的配置文件</p>
<ul>
<li>log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下</li>
<li>日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">log4j</span>:configuration <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;log4j.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">log4j:configuration</span> <span class="hljs-attr">xmlns:log4j</span>=<span class="hljs-string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Encoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ConversionPattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.ibatis&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">log4j:configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="二核心配置文件详解">二、核心配置文件详解</h2>
<p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)： properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span> /&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--开启延迟加载--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        typeAlias：设置某个具体的类型的别名</span><br><span class="hljs-comment">        属性：</span><br><span class="hljs-comment">        	type：需要设置别名的类型的全类名</span><br><span class="hljs-comment">        	alias：设置此类型的别名，且别名不区分大小写。 若不设置此属性，该类型拥有默认的别名，即:类名!</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt; --&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; --&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    environments：设置多个连接数据库的环境</span><br><span class="hljs-comment">    属性：</span><br><span class="hljs-comment">	    default：设置默认使用的环境的id</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql_test&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        environment：设置具体的连接数据库的环境信息</span><br><span class="hljs-comment">        属性：</span><br><span class="hljs-comment">	        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql_test&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            transactionManager：设置事务管理方式</span><br><span class="hljs-comment">            属性：</span><br><span class="hljs-comment">	            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span><br><span class="hljs-comment">	            type=&quot;JDBC&quot;：原生的事务管理方式。设置当前环境的事务管理都必须手动处理，提交或者回滚。。</span><br><span class="hljs-comment">	            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <br>            <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            dataSource：设置数据源</span><br><span class="hljs-comment">            属性：</span><br><span class="hljs-comment">	            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span><br><span class="hljs-comment">	            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span><br><span class="hljs-comment">	            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span><br><span class="hljs-comment">	            type=&quot;JNDI&quot;：表示调用上下文中的数据源</span><br><span class="hljs-comment">            --&gt;</span><br>            <br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的驱动类的全类名--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的连接地址--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的用户名--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的密码--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--引入映射文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserMapper.xml&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span><br><span class="hljs-comment">        注意：</span><br><span class="hljs-comment">			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span><br><span class="hljs-comment">			2. mapper接口要和mapper映射文件的名字一致</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="三mybatis的增删改查">三、MyBatis的增删改查</h2>
<ol type="1">
<li><p>添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertUser();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>	insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int deleteUser();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span>&gt;</span><br>    delete from t_user where id = 6<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int updateUser();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span><br>    update t_user set username = &#x27;张三&#x27; where id = 5<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>查询一个实体类对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserById();--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.pojo.User&quot;</span>&gt;</span>  <br>	select * from t_user where id = 2  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>查询集合</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.pojo.User&quot;</span>&gt;</span><br>	select * from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>注意：</strong></p></li>
<li><p><strong>查询的标签select必须设置属性 resultType 或 resultMap，用于设置实体类和数据库表的映射关系</strong></p>
<blockquote>
<p>将查询出来的结果处理成什么样的结果类型，然后把最终的结果作为返回值返回给当前的方法</p>
</blockquote>
<ul>
<li>resultType：自动映射，即设置默认的映射关系，用于属性名和表中字段名一致的情况<br />
</li>
<li>resultMap：自定义映射，即设置自定义的映射关系，用于一对多或多对一或字段名和属性名不一致的情况</li>
</ul></li>
<li><p>当查询的数据为多条时，不能使用实体类作为返回值，只能使用<strong>集合</strong>，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</p>
<p>栗：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;User&gt; userList = mapper.getAllUser();<br>userList.forEach(user -&gt; System.out.println(user));<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="四mybatis获取参数值的两种方式重点">四、MyBatis获取参数值的两种方式（重点）</h2>
<ul>
<li>MyBatis获取参数值的两种方式：<code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code></li>
<li><strong><code>$&#123;&#125;</code>的本质就是字符串拼接，<code>#&#123;&#125;</code> 的本质就是占位符赋值</strong><br />
</li>
<li><code>$&#123;&#125;</code> 使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是 <code>#&#123;&#125;</code> 使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</li>
</ul>
<h3 id="单个字面量类型的参数">1. 单个字面量类型的参数</h3>
<ul>
<li>若mapper接口中的方法参数为单个的字面量类型，此时可以使用 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code> 以任意的名称(最好见名识意)获取参数的值，注意 <code>$&#123;&#125;</code> 需要手动加单引号</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByUsername(String username);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user where username = #&#123;username&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>就是说如果是单个参数， <code>#&#123;&#125;</code> 以任意的名称获取参数的值，<code>#&#123;&#125;</code> 里面写啥都行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserByUsername(String username);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>  <br>	select * from t_user where username = &#x27;$&#123;username&#125;&#x27;  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>注意 <code>$&#123;&#125;</code> 需要手动加单引号</p>
<h3 id="多个字面量类型的参数">2. 多个字面量类型的参数</h3>
<p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中，以两种方式存储：</p>
<ol type="1">
<li>以arg0, arg1...为键，以参数为值；</li>
<li>以param1, param2...为键，以参数为值；</li>
</ol>
<p>因此只需要通过 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code> 以map集合的键的方式获取相应的值，注意 <code>$&#123;&#125;</code> 需要手动加单引号。</p>
<ul>
<li>使用arg或者param都行。要注意的是，arg是从arg0开始的，param是从param1开始的</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLogin(String username, String password);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>  <br>	select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLogin(String username, String password);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="map集合类型的参数">3. map集合类型的参数</h3>
<p>若mapper接口中的方法需要的<strong>参数为多个时，此时可以手动创建map集合</strong>，将这些数据放在map中只需要通过 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code> 访问map集合的键就可以获取相对应的值，注意 <code>$&#123;&#125;</code> 需要手动加单引号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLoginByMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkLoginByMap</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);<br>    <br>	Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>	map.put(<span class="hljs-string">&quot;usermane&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>	map.put(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>	User user = mapper.checkLoginByMap(map);<br>	System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="实体类类型的参数">4. 实体类类型的参数</h3>
<p>若mapper接口中的方法<strong>参数为实体类对象时此时可以使用 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code>，通过访问实体类对象中的属性名获取属性值</strong>，注意 <code>$&#123;&#125;</code> 需要手动加单引号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertUser(User user);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>	insert into t_user values(null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;sex&#125;, #&#123;email&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertUser</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);<br>	User user = <span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;123@321.com&quot;</span>);<br>	mapper.insertUser(user);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="使用param标识参数">5. 使用@Param标识参数</h3>
<p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中</p>
<ol type="1">
<li><strong>以@Param注解的value属性值为键，以参数为值；</strong></li>
<li><strong>以param1,param2...为键，以参数为值；</strong></li>
</ol>
<ul>
<li>只需要通过 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code> 访问map集合的键就可以获取相对应的值，注意 <code>$&#123;&#125;</code> 需要手动加单引号</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;CheckLoginByParam&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkLoginByParam</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);<br>	mapper.CheckLoginByParam(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>建议分成两种情况进行处理</p>
<ol type="1">
<li>实体类类型的参数</li>
<li>使用@Param标识参数</li>
</ol>
<h2 id="五mybatis的各种查询功能">五、MyBatis的各种查询功能</h2>
<p>5.1 如果查询出的数据只有一条，可以通过</p>
<ol type="1">
<li>实体类对象接收</li>
<li>List集合接收</li>
<li>Map集合接收，结果 <code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li>
</ol>
<p>5.2 如果查询出的数据有<u>多条，一定不能用实体类对象接收</u>，会抛异常 TooManyResultsException，可以通过</p>
<ol type="1">
<li>实体类类型的List集合接收</li>
<li>Map类型的List集合接收</li>
<li>在mapper接口的方法上添加@MapKey注解，此时就可以将每条数据转换的map集合作为值，以某个字段的值作为键，放在同一个map集合中</li>
</ol>
<h3 id="如果查询出的数据只有一条">5.1 如果查询出的数据只有一条</h3>
<h4 id="查询一个实体类对象">1. 查询一个实体类对象</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据用户id查询用户信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="查询单个数据">查询单个数据</h4>
<p>在MyBatis中，对于Java中常用的类型都设置了类型别名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 查询用户的总记录数  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment"> * 在MyBatis中，对于Java中常用的类型都设置了类型别名  </span><br><span class="hljs-comment"> * 例如：java.lang.Integer--&gt;int | integer  </span><br><span class="hljs-comment"> * 例如：int--&gt;_int | _integer  </span><br><span class="hljs-comment"> * 例如：Map--&gt;map, List--&gt;list  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int getCount();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;_integer&quot;</span>&gt;</span><br>	select count(id) from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="查询一个list集合">2. 查询一个List集合</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="查询一条数据为map集合">3. 查询一条数据为map集合</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 根据用户id查询用户信息为map集合  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function">Map&lt;String, Object&gt; <span class="hljs-title">getUserToMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>	select * from t_user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="如果查询出的数据有多条">5.2 如果查询出的数据有多条</h3>
<h4 id="实体类类型的list集合接收">1. 实体类类型的List集合接收</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="map类型的list集合接收">2. Map类型的List集合接收</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 查询所有用户信息为map集合  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  </span><br><span class="hljs-comment"> */</span>  <br>List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span>  <br>	select * from t_user  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">	结果：</span><br><span class="hljs-comment">	[&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span><br><span class="hljs-comment">	&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span><br><span class="hljs-comment">	&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="在mapper接口的方法上添加mapkey注解">3. 在mapper接口的方法上添加@MapKey注解</h4>
<p>若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户信息为map集合</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；</span><br><span class="hljs-comment"> * 若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过<span class="hljs-doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的map集合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@MapKey(&quot;id&quot;)</span><br><span class="hljs-function">Map&lt;String, Object&gt; <span class="hljs-title">getAllUserToMap</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>	select * from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">	结果：</span><br><span class="hljs-comment">	&#123;</span><br><span class="hljs-comment">	1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span><br><span class="hljs-comment">	2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span><br><span class="hljs-comment">	3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="六特殊sql的执行">六、特殊SQL的执行</h2>
<h3 id="模糊查询">1. 模糊查询</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据用户名进行模糊查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByLike</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;  <br>	select * from t_user where username like concat(&#x27;%&#x27;, #&#123;mohu&#125;, &#x27;%&#x27;)<br>	select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>据说第二种： <code>select * from t_user where username like concat('%', #&#123;mohu&#125;, '%')</code> 比较好</p>
<h3 id="批量删除">2. 批量删除</h3>
<p><strong>只能使用 <code>$&#123;&#125;</code></strong></p>
<ul>
<li>如果使用#{}，则解析后的sql语句为<code>delete from t_user where id in ('1,2,3')</code>，这样是将<code>1,2,3</code>看做是一个整体，只有id为 <code>1,2,3</code> 的数据会被删除。正确的语句应该是 <code>delete from t_user where id in (1,2,3)</code>，或者 <code>delete from t_user where id in ('1','2','3')</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据id批量删除</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ids </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> int </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteMore</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> String ids)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMore&quot;</span>&gt;</span><br>	delete from t_user where id in ($&#123;ids&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试类</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMore</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);<br>	<span class="hljs-keyword">int</span> result = mapper.deleteMore(<span class="hljs-string">&quot;1,2,3,8&quot;</span>);<br>	System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="动态设置表名">3. 动态设置表名</h3>
<p>表名不固定，由当前传过来的参数决定</p>
<ul>
<li>只能使用 <code>$&#123;&#125;</code>，因为表名不能加单引号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询指定表中的数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> tableName </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByTable</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;tableName&quot;)</span> String tableName)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByTable&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>	select * from $&#123;tableName&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="添加功能获取自增的主键">4. 添加功能获取自增的主键</h3>
<p>使用场景：</p>
<ul>
<li><p>t_clazz(clazz_id, clazz_name)</p>
<ul>
<li>t_student(student_id,student_name,clazz_id)</li>
</ul>
<ol type="1">
<li>添加班级信息<br />
</li>
<li>获取新添加的班级的id<br />
</li>
<li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li>
</ol></li>
</ul>
<p>在mapper.xml中设置两个属性：</p>
<ul>
<li><strong>useGeneratedKeys</strong>：设置当前标签中的SQL使用了自增的主键</li>
<li><strong>keyProperty</strong>：将自增的主键的值赋值给传输到映射文件中参数的某个属性</li>
</ul>
<blockquote>
<p>用useGeneratedKeys表示能返回主键，用keyproperty表示主键返回到什么属性上</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加用户信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(User user)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--void insertUser(User user);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>	insert into t_user values (null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;sex&#125;, #&#123;email&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试类</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertUser</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);<br>	User user = <span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;ton&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;123@321.com&quot;</span>);<br>	mapper.insertUser(user);<br>	System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>//输出：<code>user&#123;id=10, username='ton', password='123', age=23, sex='男', email='123@321.com'&#125;</code>，自增主键存放到了user的id属性中</p>
<h2 id="七自定义映射resultmap">七、自定义映射resultMap</h2>
<h3 id="resultmap-处理字段和属性的映射关系">1. resultMap 处理字段和属性的映射关系</h3>
<p>resultMap：设置自定义映射</p>
<ul>
<li>resultMap 属性：<code>&lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&gt;</code>
<ul>
<li>id：表示自定义映射的唯一标识，不能重复（一个名字，为了和sql语句联系上）</li>
<li>type：查询的数据要映射的实体类的类型<br />
</li>
<li>子标签： <code>&lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;</code>
<ul>
<li>id：设置主键的映射关系<br />
</li>
<li>result：设置普通字段的映射关系<br />
</li>
</ul></li>
<li>子标签属性： <code>&lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;</code>
<ul>
<li>property：设置映射关系中<strong>实体类中的属性名</strong><br />
</li>
<li>column：设置映射关系中<strong>表中的字段名</strong></li>
</ul></li>
</ul></li>
</ul>
<p>若字段名和实体类中的属性名不一致，三种解决办法：</p>
<ul>
<li>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系</li>
</ul>
<h4 id="为字段起别名">1. 为字段起别名</h4>
<p>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllEmp&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>    select eid,emp_name empName,age,sex,email from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="全局配置信息mapunderscoretocamelcase">2. 全局配置信息mapUnderscoreToCamelCase</h4>
<p>可以在MyBatis的核心配置文件中的<code>setting</code>标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。<a href="#核心配置文件详解">核心配置文件详解</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>    <br></code></pre></td></tr></table></figure>
<h4 id="resultmap设置自定义映射">3. resultMap设置自定义映射</h4>
<ul>
<li>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来
<ul>
<li>property：设置映射关系中<strong>实体类中的属性名</strong><br />
</li>
<li>column：设置映射关系中<strong>表中的字段名</strong></li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllEmp&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empResultMap&quot;</span>&gt;</span><br>	select * from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="八多对一映射处理">八、多对一映射处理</h2>
<blockquote>
<p>查询员工信息以及员工所对应的部门信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;  <br>	<span class="hljs-keyword">private</span> Integer eid;  <br>	<span class="hljs-keyword">private</span> String empName;  <br>	<span class="hljs-keyword">private</span> Integer age;  <br>	<span class="hljs-keyword">private</span> String sex;  <br>	<span class="hljs-keyword">private</span> String email;  <br>	<span class="hljs-keyword">private</span> Dept dept;<br>	<span class="hljs-comment">//...构造器、get、set方法等</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="级联方式处理映射关系">1. 级联方式处理映射关系</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empAndDeptResultMapOne&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept.did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <br>    这：<br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept.deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpAndDept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span><br>	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="使用association处理映射关系">2. 使用association处理映射关系</h3>
<ul>
<li>association：处理多对一的映射关系
<ul>
<li><strong>property</strong>：需要处理多对的映射关系的属性名</li>
<li><strong>javaType</strong>：该属性的类型</li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empAndDeptResultMapTwo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    这：<br>	<span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Dept&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpAndDept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span><br>	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="分步查询">3. 分步查询</h3>
<h4 id="第一步-查询员工信息">第一步 查询员工信息</h4>
<p>第一步通过分步查询，员工及所对应的部门信息</p>
<ul>
<li>select：设置分布查询的sql的唯一标识（namespace.SQL的Id或mapper接口的全类名.方法名）</li>
<li>column：设置分步查询的条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//EmpMapper里的方法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过分步查询，员工及所对应的部门信息</span><br><span class="hljs-comment"> * 分步查询第一步：查询员工信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Emp <span class="hljs-title">getEmpAndDeptByStepOne</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;eid&quot;)</span> Integer eid)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <br>	<span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span><br>	select * from t_emp where eid = #&#123;eid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="第二步-查询部门信息">第二步 查询部门信息</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DeptMapper里的方法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过分步查询，员工及所对应的部门信息</span><br><span class="hljs-comment"> * 分步查询第二步：通过did查询员工对应的部门信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Dept <span class="hljs-title">getEmpAndDeptByStepTwo</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;did&quot;)</span> Integer did)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Dept&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span>&gt;</span><br>	select * from t_dept where did = #&#123;did&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>多对一是对象，一对多是集合</strong></p>
<h2 id="九一对多映射处理">九、一对多映射处理</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer did;<br>    <span class="hljs-keyword">private</span> String deptName;<br>    <span class="hljs-keyword">private</span> List&lt;Emp&gt; emps;<br>	<span class="hljs-comment">//...构造器、get、set方法等</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="collection">1. collection</h3>
<ul>
<li><strong>collection</strong>：用来处理一对多的映射关系
<ul>
<li><strong>property</strong>：需要处理映射关系的属性名</li>
<li><strong>ofType</strong>：表示该属性对应的集合中存储的数据的类型</li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DeptAndEmpResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Dept&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    这：<br>	<span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDeptAndEmp&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;DeptAndEmpResultMap&quot;</span>&gt;</span><br>	select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="分步查询-1">2. 分步查询</h3>
<h4 id="第一步-查询部门信息">第一步 查询部门信息</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过分步查询，查询部门及对应的所有员工信息</span><br><span class="hljs-comment"> * 分步查询第一步：查询部门信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> did </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.atguigu.mybatis.pojo.Dept</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Dept <span class="hljs-title">getDeptAndEmpByStepOne</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;did&quot;)</span> Integer did)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DeptAndEmpByStepOneResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Dept&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;did&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;emps&quot;</span></span><br><span class="hljs-tag">				<span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span><br><span class="hljs-tag">				<span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;DeptAndEmpByStepOneResultMap&quot;</span>&gt;</span><br>	select * from t_dept where did = #&#123;did&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="第二步-根据部门id查询部门中的所有员工">第二步 根据部门id查询部门中的所有员工</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过分步查询，查询部门及对应的所有员工信息</span><br><span class="hljs-comment"> * 分步查询第二步：根据部门id查询部门中的所有员工</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> did</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt; </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;Emp&gt; <span class="hljs-title">getDeptAndEmpByStepTwo</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;did&quot;)</span> Integer did)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp where did = #&#123;did&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="十延迟加载">十、延迟加载</h2>
<ul>
<li><strong>分步查询的优点：可以实现延迟加载</strong>，但是必须在核心配置文件中设置全局配置信息：</li>
<li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载
<ul>
<li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载<br />
</li>
</ul></li>
<li>此时就可以<strong>实现按需加载，获取的数据是什么，就只会执行相应的sql</strong>。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，
<ul>
<li>fetchType属性：<code>fetchType=&quot;lazy(延迟加载)|eager(立即加载)&quot;</code> 。当开启了全局的延迟加载之后，可通过此属性手动控制延迟加载的效果</li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>	<span class="hljs-comment">&lt;!--开启延迟加载--&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getEmpAndDeptByStepOne</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);<br>	Emp emp = mapper.getEmpAndDeptByStepOne(<span class="hljs-number">1</span>);<br>	System.out.println(emp.getEmpName());<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>关闭延迟加载，两条SQL语句都运行了</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220616203513.png" /></p>
<ul>
<li>开启延迟加载，只运行获取emp的SQL语句</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220616203505.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getEmpAndDeptByStepOne</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);<br>	Emp emp = mapper.getEmpAndDeptByStepOne(<span class="hljs-number">1</span>);<br>	System.out.println(emp.getEmpName());<br>	System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);<br>	System.out.println(emp.getDept());<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>开启后，需要用到查询dept的时候才会调用相应的SQL语句</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220616203449.png" /></p>
<p>fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType=&quot;lazy(延迟加载)|eager(立即加载)&quot;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span></span><br><span class="hljs-tag">				 <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="十一动态sql">十一、动态SQL</h2>
<ul>
<li>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题</li>
</ul>
<h3 id="if">1. if</h3>
<p>if标签：根据标签中test属性（即传递过来的数据）所对应的表达式决定标签中的内容是否需要拼接到SQL中。通过表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</p>
<ul>
<li>在where后面添加一个恒成立条件 <code>1=1</code>，这个恒成立条件并不会影响查询的结果
<ul>
<li>这个<code>1=1</code>可以用来拼接<code>and</code>语句，例如：当empName为null时</li>
<li>如果不加上恒成立条件，则SQL语句为<code>select * from t_emp where and age = ? and sex = ? and email = ?</code>，此时<code>where</code>会与<code>and</code>连用，SQL语句会报错</li>
<li>如果加上一个恒成立条件，则SQL语句为<code>select * from t_emp where 1 = 1 and age = ? and sex = ? and email = ?</code>，此时不报错</li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp where 1=1<br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span><br>		and emp_name = #&#123;empName&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span><br>		and age = #&#123;age&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span><br>		and sex = #&#123;sex&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span><br>		and email = #&#123;email&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="where">2. where</h3>
<p>where和if一般结合使用：</p>
<ul>
<li>若where标签中的if条件都不满足，即where标签中没有内容时，则where标签没有任何功能，即不会添加where关键字<br />
</li>
<li>若where标签中的if条件满足，即where标签中有内容时，则where标签会自动添加where关键字，并将条件最<strong>前方</strong>多余的and/or去掉<br />
</li>
<li>Note：where标签不能将其中内容后的 多余的 and/or 去掉</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp<br>    <br>	<span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span><br>			emp_name = #&#123;empName&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span><br>			and age = #&#123;age&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span><br>			and sex = #&#123;sex&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span><br>			and email = #&#123;email&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>注意：where标签不能去掉条件后多余的and/or</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span><br>	emp_name = #&#123;empName&#125; and<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span><br>	age = #&#123;age&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="trim">3. trim</h3>
<p>trim用于去掉或添加标签中的内容</p>
<p>常用属性：</p>
<ul>
<li>prefix：在trim标签中的内容的 前面 添加某些内容<br />
</li>
<li>suffix：在trim标签中的内容的 后面 添加某些内容</li>
<li>prefixOverrides：在trim标签中的内容的 前面去掉某些内容<br />
</li>
<li>suffixOverrides：在trim标签中的内容的 后面去掉某些内容</li>
</ul>
<p>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp<br>	<span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span><br>			emp_name = #&#123;empName&#125; and<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span><br>			age = #&#123;age&#125; and<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span><br>			sex = #&#123;sex&#125; or<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span><br>			email = #&#123;email&#125;<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试类</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getEmpByCondition</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);<br>	List&lt;Emp&gt; emps= mapper.getEmpByCondition(<span class="hljs-keyword">new</span> Emp(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>));<br>	System.out.println(emps);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="choosewhenotherwise">4. choose、when、otherwise</h3>
<ul>
<li><code>choose、when、otherwise</code> 相当于 <code>if...else if..else</code></li>
<li>choose 是父标签，when 和 otherwise 是子标签（写在 choose 里面）。when至少要有一个，otherwise至多只有一个</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select * from t_emp<br>	<span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span><br>				emp_name = #&#123;empName&#125;<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span><br>				age = #&#123;age&#125;<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span><br>				sex = #&#123;sex&#125;<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span><br>				email = #&#123;email&#125;<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>				did = 1<br>			<span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getEmpByChoose</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);<br>	List&lt;Emp&gt; emps = mapper.getEmpByChoose(<span class="hljs-keyword">new</span> Emp(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;123@qq.com&quot;</span>, <span class="hljs-keyword">null</span>));<br>	System.out.println(emps);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>相当于<code>if&#123;a&#125; else if&#123;b&#125; else if&#123;c&#125; else&#123;d&#125;</code>，只会执行其中一个</p>
<h3 id="foreach">5. foreach</h3>
<p>属性：</p>
<ul>
<li>collection：设置要循环的<strong>数组或集合</strong><br />
</li>
<li>item：表示集合或数组中的每一个数据<br />
</li>
<li>separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如<code>,</code></li>
<li>open：设置foreach标签中的内容的开始符<br />
</li>
<li>close：设置foreach标签中的内容的结束符</li>
</ul>
<h4 id="批量删除-1">批量删除</h4>
<p>通过<strong>数组</strong>批量删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int deleteMoreByArray(@Param(&quot;eids&quot;) Integer[] eids);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMoreByArray&quot;</span>&gt;</span><br>	delete from t_emp where eid in<br>    1. <br>	<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>		#&#123;eid&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    2. <br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>		#&#123;eid&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMoreByArray</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);<br>	<span class="hljs-keyword">int</span> result = mapper.deleteMoreByArray(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;);<br>	System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="批量添加">批量添加</h4>
<p>通过<strong>集合</strong>批量添加。访问集合中的员工的信息，所以是：<code>emp.empName</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertMoreByList&quot;</span>&gt;</span><br>	insert into t_emp values<br>	<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>		(null, #&#123;emp.empName&#125;, #&#123;emp.age&#125;, #&#123;emp.sex&#125;, #&#123;emp.email&#125;,null)<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertMoreByList</span><span class="hljs-params">()</span> </span>&#123;<br>	SqlSession sqlSession = SqlSessionUtils.getSqlSession();<br>	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);<br>	Emp emp1 = <span class="hljs-keyword">new</span> Emp(<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;123@321.com&quot;</span>,<span class="hljs-keyword">null</span>);<br>	Emp emp2 = <span class="hljs-keyword">new</span> Emp(<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;123@321.com&quot;</span>,<span class="hljs-keyword">null</span>);<br>	Emp emp3 = <span class="hljs-keyword">new</span> Emp(<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-string">&quot;123@321.com&quot;</span>,<span class="hljs-keyword">null</span>);<br>	List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);<br>	<span class="hljs-keyword">int</span> result = mapper.insertMoreByList(emps);<br>	System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="sql片段">6. SQL片段</h3>
<p>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</p>
<ul>
<li>声明sql片段：<code>&lt;sql&gt;</code>标签</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empColumns&quot;</span>&gt;</span>eid, emp_name, age, sex, email<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>引用sql片段：<code>&lt;include&gt;</code>标签</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>	select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empColumns&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span> from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="十二mybatis的缓存">十二、MyBatis的缓存</h2>
<h3 id="mybatis的一级缓存">1. MyBatis的一级缓存</h3>
<ul>
<li><p><strong>一级缓存是SqlSession级别的</strong>，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</p></li>
<li><p>使一级缓存失效的四种情况：</p>
<ol type="1">
<li><p>不同的SqlSession对应不同的一级缓存</p></li>
<li>同一个SqlSession但是查询条件不同</li>
<li>同一个SqlSession两次查询期间执行了任何一次增删改操作（后MyBatis会清空缓存）</li>
<li><p>同一个SqlSession两次查询期间手动清空了缓存 <code>sqlSession.clearCache()</code></p></li>
</ol></li>
</ul>
<h3 id="mybatis的二级缓存">2. MyBatis的二级缓存</h3>
<ul>
<li><strong>二级缓存是SqlSessionFactory级别</strong>，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取<br />
</li>
<li>二级缓存开启的条件：
<ol type="1">
<li>在核心配置文件中，设置全局配置属性 <code>cacheEnabled=&quot;true&quot;</code>，默认为true，不需要设置</li>
<li>在映射文件中设置标签 <code>&lt;cache /&gt;</code></li>
<li>二级缓存必须在SqlSession关闭或提交之后有效 <code>sqlSession().close()</code></li>
<li>查询的数据所转换的实体类类型必须实现序列化的接口（在实体类 <code>class xxx implements Serializable</code>）</li>
</ol></li>
<li>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</li>
</ul>
<h3 id="二级缓存的相关配置">3. 二级缓存的相关配置</h3>
<p>在mapper配置文件中添加的cache标签可以设置一些属性</p>
<ul>
<li><p>eviction属性：缓存回收策略</p>
<ul>
<li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。<br />
</li>
<li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。<br />
</li>
<li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。<br />
</li>
<li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
<li>默认的是 LRU</li>
</ul></li>
<li><p>flushInterval属性：刷新间隔，单位毫秒</p>
<p>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</p></li>
<li><p>size属性：引用数目，正整数</p>
<p>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</p></li>
<li><p>readOnly属性：只读，true/false</p>
<p>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。</p>
<p>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false</p></li>
</ul>
<h3 id="mybatis缓存查询的顺序">4. MyBatis缓存查询的顺序</h3>
<ul>
<li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用<br />
</li>
<li>如果二级缓存没有命中，再查询一级缓存<br />
</li>
<li>如果一级缓存也没有命中，则查询数据库<br />
</li>
<li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li>
</ul>
<h2 id="十三mybatis的逆向工程">十三、MyBatis的逆向工程</h2>
<ul>
<li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的</li>
<li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：<br />
</li>
<li>Java实体类
<ul>
<li>Mapper接口<br />
</li>
<li>Mapper映射文件</li>
</ul></li>
</ul>
<h3 id="qbc">QBC</h3>
<h4 id="查询">查询</h4>
<ul>
<li><code>selectByExample</code>：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据</li>
<li><code>example.createCriteria().xxx</code>：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</li>
<li><code>example.or().xxx</code>：将之前添加的条件通过or拼接其他条件 <img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220616203221.png" /></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMBG</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>	InputStream is = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);<br>	SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>);<br>	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);<br>	EmpExample example = <span class="hljs-keyword">new</span> EmpExample();<br>	<span class="hljs-comment">//名字为张三，且年龄大于等于20</span><br>	example.createCriteria().andEmpNameEqualTo(<span class="hljs-string">&quot;张三&quot;</span>).andAgeGreaterThanOrEqualTo(<span class="hljs-number">20</span>);<br>	<span class="hljs-comment">//或者did不为空</span><br>	example.or().andDidIsNotNull();<br>	List&lt;Emp&gt; emps = mapper.selectByExample(example);<br>	emps.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220616203332.png" /></p>
<h4 id="增改">增改</h4>
<ul>
<li><p><code>updateByPrimaryKey</code>：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null</p></li>
<li><p><code>mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3));</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220616203352.png" /></p></li>
<li><p><code>updateByPrimaryKeySelective()</code>：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段</p></li>
<li><p><code>mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3));</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220616203408.png" /></p></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring笔记</title>
    <url>/2022/06/24/Spring%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="spring笔记">Spring笔记</h1>
<blockquote>
<p>视频看的是<a href="https://www.bilibili.com/video/BV1q94y1o7ts?p=1">动力节点spring</a>。</p>
</blockquote>
<h2 id="一什么是spring">一、什么是Spring？</h2>
<h3 id="介绍">1、介绍</h3>
<p>Spring它是一个容器，也是一个框架，它是整合其它框架的框架。Spring看到其他什么框架好用，它就会把它整合进来，比如MyBatis框架就被Spring看上了，然后就整合进Spring里面。</p>
<p>Spring的核心是 <strong>控制反转IOC</strong> 和 <strong>面向切面编程AOP。</strong>它由20多个模块构成，它在很多领域都提供优秀的解决方案。</p>
<p>Spring 根据代码的功能特点，使用 Ioc 降低业务对象之间耦合度。IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”，注入即赋值。 而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”。</p>
<h3 id="spring的特点">2、Spring的特点</h3>
<ol type="1">
<li><p>轻量级 由20多个模块构成，每个模块jar包都很小，小于1M，Spring核心包也就3M左右。 编写代码比较自由，不用像MyBatis那样一定要写什么什么配置文件。</p></li>
<li><p>面向接口编程 使用接口，就是面向灵活，项目的可扩展性好，可维护性都极高。接口不关心实现类的类型。使用时接口指向实现类，只要切换实现类即可切换整个功能。</p></li>
<li><p>AOP：面向切面编程 就是将公共的，通用的，重复的代码单独开发在一个切面中，在需要的时候再从切面中反织回去。底层的原理是动态代理。</p></li>
<li><p>整合其它框架</p>
<p>它整合后使其它框架更易用，比如整合了MyBatis框架</p></li>
</ol>
<h2 id="二控制反转ioc">二、控制反转IOC</h2>
<h3 id="什么是iocinversion-of-control">1、什么是IOC（Inversion of Control）</h3>
<p>控制反转IOC（Inversion of Control）是一个概念，是一种思想。由Spring容器进行对象的创建和依赖注入.程序员在使用时直接取出使用。<strong>由容器集中进行对象和创建和依赖管理。</strong></p>
<p>Spring 根据代码的功能特点，使用 Ioc 降低业务对象之间耦合度。IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”,注入即赋值。</p>
<p><strong>正转</strong>：由程序员进行对象的创建和依赖注入称为正转.程序员说了算.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Student stu = <span class="hljs-keyword">new</span> Student();  ===&gt; 程序员自己创建对象<br>stu.setName(<span class="hljs-string">&quot;张三&quot;</span>);      ===&gt; 程序员自己进行赋值（依赖注入）<br>stu.setAge(<span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure>
<p><strong>反转</strong>：由Spring容器进行创建对象和依赖注入称为反转，将控制权从程序员手中夺走，由Spring容器进行控制，称为反转。 容器说了算.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.pojo.Student&quot;</span>&gt;</span>   ===&gt; Spring容器负责对象的创建<br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span>           ===&gt; Spring容器依赖注入值<br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="基于xml的ioc">2、基于xml的IOC</h3>
<p>对象的创建和注入依赖都在 <code>applicationContext.xml</code> 文件中的指定设置好。创建Spring容器的时候指明这个xml文件，Spring就会自动创建这个xml文件的对象并且注入好值。</p>
<p>基于xml的IOC：</p>
<ol type="1">
<li>创建对象 和 依赖注入，交给Spring容器管理完成</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.pojo.Student&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>id：就是指明创建对象的名称</li>
<li>class：就是对象对应的全类名，Spring底层会通过反射创建对象（只能是类，不能是接口）</li>
</ul>
<ol start="2" type="1">
<li><p>当启动Spring容器的时候：</p>
<ol type="1">
<li><p>默认就会调用无参构造器创建此xml文件中的所有对象,所以<strong>必须提供无参构造器。</strong></p></li>
<li><p>相当于 <code>Student stu = new Student();</code></p></li>
</ol></li>
<li>同时会给创建的对象赋值
<ol type="1">
<li><strong>使用setter注入依赖</strong></li>
<li><strong>使用构造器注入依赖</strong></li>
</ol></li>
</ol>
<h4 id="使用setter注入依赖">1. 使用setter注入依赖</h4>
<p>第一种：注入基本数据类型，使用 value 属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>第二种：注入引用数据类型的数据，使用 ref 属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;school&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;school&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>此引用数据类型必须在此配置文件.xml种配置过bean，在此文件中的bean实例对象。</p>
<p><strong>注意：使用setter注入必须提供无参的构造方法 和 <code>setXXX()</code> 方法。</strong></p>
<h4 id="使用构造器注入依赖">2. 使用构造器注入依赖</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure>
<ol type="1">
<li>使用构造方法的参数名称进行注入值</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;school&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.pojo3.School&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;清华大学&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;海淀区&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用构造方法参数的下标注入值</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.pojo3.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;钱七&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;school&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用默认的构造方法的参数的<u>顺序</u>注入值</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuSequence&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.pojo3.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;陈十&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;school&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="基于注解的ioc">3、基于注解的IOC</h3>
<p>也称为DI(Dependency Injection)，它是IOC的具体实现的技术.</p>
<p><strong>基于注解的IOC,必须要在Spring的核心配置文件中添加包扫描.</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">“com.bjpowernode.s01”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>药: 创建对象并依赖注入</li>
<li>汤: xml 注解annotation</li>
</ul>
<blockquote>
<p>换汤不换药~</p>
</blockquote>
<h4 id="创建对象的注解">1. 创建对象的注解</h4>
<ul>
<li><code>@Component</code>:可以创建任意对象.创建的对象的默认名称是类名的驼峰命名法.也可以指定对象的名称 <code>@Component(“指定名称”)</code></li>
<li><code>@Controller</code>:专门用来创建控制器的对象(Servlet),这种对象可以接收用户的请求,可以返回处理结果给客户端.</li>
<li><code>@Service</code>:专门用来创建业务逻辑层的对象,负责向下访问数据访问层,处理完毕后的结果返回给界面层.</li>
<li><code>@Repository</code>:专门用来创建数据访问层的对象,负责数据库中的增删改查所有操作.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">案例:<br><span class="hljs-meta">@Component(&quot;stu&quot;)</span>  <span class="hljs-comment">// 交给Spring去创建对象,就是在容器启动时创建</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;张三&quot;)</span>  ===&gt; 简单类型的值注入<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-meta">@Value(&quot;22&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="依赖注入的注解">2. 依赖注入的注解</h4>
<h5 id="简单类型8种基本类型string的注入">简单类型(8种基本类型+String)的注入</h5>
<ul>
<li><code>@Value</code>：用来给简单类型注入值</li>
</ul>
<h5 id="引用类型的注入">引用类型的注入</h5>
<ol type="1">
<li><p><code>@Autowired</code>:使用<u>类型</u>注入值,从整个Bean工厂中搜索同源类型的对象进行注入. 同源类型也可注入.</p>
<p>什么是同源类型:</p>
<ol type="1">
<li>被注入的类型(Student中的school)与注入的类型是<u>完全相同的类型</u><br />
</li>
<li>被注入的类型(Student中的school：父)与注入的类型(子)是<u>父子类</u><br />
</li>
<li>被注入的类型(Student中的school接口)与注入的类型(实现类)是<u>接口和实现类的类型</u></li>
</ol></li>
</ol>
<p>注意：在有父子类的情况下,使用按类型注入,就意味着有多个可注入的对象.此时按照名称进行二次筛选,选中<strong>与被注入对象相同名称的对象进行注入</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220620103521.png" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220620103434.png" /></p>
<ol start="2" type="1">
<li><code>@Autowired</code></li>
</ol>
<p><code>@Qualifier(&quot;名称&quot;)</code>：使用<u>名称</u>注入值,从整个Bean工厂中搜索相同名称的对象进行注入.</p>
<p><strong>注意:如果有父子类的情况下,直接按名称进行注入值.</strong></p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建School对象</span><br><span class="hljs-meta">@Component(&quot;schoolNew&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">School</span> </span>&#123;<br>    <span class="hljs-comment">// 简单类型的数据注入</span><br>    <span class="hljs-meta">@Value(&quot;清华大学&quot;)</span><br>    <span class="hljs-keyword">private</span> String schoolName;<br>    <span class="hljs-meta">@Value(&quot;北京&quot;)</span><br>    <span class="hljs-keyword">private</span> String address;<br>    ...<br>&#125;<br>    <br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;测试&quot;)</span><br>    <span class="hljs-keyword">private</span> String stuName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 引用数据类型的数据注入采用 @Autowired和@Qualifier(&quot;名称&quot;)注解</span><br><span class="hljs-comment">     * Spring会自动去bean工厂中找@Qualifier(&quot;名称&quot;)指定名称的对象进行注入，赋值给school引用</span><br><span class="hljs-comment">     * 我们已经使用注解创建了School对象。</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;schoolNew&quot;)</span><br>    <span class="hljs-keyword">private</span> School school;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220620104852.png" /></p>
<h4 id="添加包扫描的方式">添加包扫描的方式</h4>
<p>1)单个包扫描(推荐使用)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.service.impl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>2)多个包扫描,多个包之间以逗号或空格或分号分隔</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller com.bjpowernode.service ,com.bjpowernode.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>3)扫描根包(不推荐)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>会降低容器启动的速度,导致多做无用功.</p>
<h2 id="三三层架构项目的分析">三、三层架构项目的分析</h2>
<blockquote>
<p>界面层view和controller</p>
<p>业务逻辑层service</p>
<p>数据持久层bean和dao/mapper</p>
</blockquote>
<p><strong>controller 调用业务逻辑层，业务逻辑层调用数据访问层，数据访问层插入数据到数据库中</strong></p>
<h3 id="普通的三层项目">1、 普通的三层项目</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数据访问层的实现类</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users u)</span> </span>&#123;<br>        System.out.println(u.getUname() + <span class="hljs-string">&quot;用户增加成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 业务逻辑层的实现类</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersService</span> </span>&#123;<br><br>    <span class="hljs-comment">// 切记：在所有的业务逻辑层中都必定有数据访问层的对象！</span><br>    <span class="hljs-keyword">private</span> UsersMapper usersMapper = <span class="hljs-keyword">new</span> UsersMapperImpl();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-comment">// 调用数据持久层将注册的信息插入到底层数据库</span><br>        <span class="hljs-keyword">return</span> usersMapper.insert(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之界面层的controller</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersController</span> </span>&#123;<br><br>    <span class="hljs-comment">// 如何去访问业务逻辑层？ 就是创建对象</span><br>    <span class="hljs-comment">// 切记：所有的界面层都会有业务逻辑层的对象</span><br>    <span class="hljs-keyword">public</span> UsersService usersService = <span class="hljs-keyword">new</span> UsersServiceImpl();<br><br>    <span class="hljs-comment">// 界面层的功能实现，对外提供访问的功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> usersService.insert(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="基于xml的ioc三层架构项目spring接管对象">2、基于xml的IOC三层架构项目（Spring接管对象）</h3>
<p>由Spring管理三层架构项目中的对象创建，包含界面层、业务逻辑层和数据访问层的对象创建。要创建的对象以及依赖信息在 <code>applicationContext.xml</code> 文件中配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之数据访问层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersMapper</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users u)</span> </span>&#123;<br>        System.out.println(u.getUname() + <span class="hljs-string">&quot;用户增加成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之业务逻辑层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersService</span></span>&#123;<br> <br>    <span class="hljs-comment">// 这个数据访问层的对象userMapper交给Spring创建了,因此这个依赖也交给Spring注入(需要提供setXXX方法)</span><br>    <span class="hljs-comment">// private UserMapper userMapper = new UserMapperImpl();</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br> <br>    <span class="hljs-comment">// 交给Spring去依赖注入值，必须提供无参构造方法和setXXX()方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserMapper</span><span class="hljs-params">(UserMapper userMapper)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userMapper = userMapper;<br>    &#125;<br><br>	<span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-comment">// 调用数据持久层将注册的信息插入到底层数据库</span><br>        <span class="hljs-keyword">return</span> usersMapper.insert(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之界面层的controller</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 面向接口编程</span><br>    <span class="hljs-comment">// 这个业务逻辑层的对象userService交给Spring创建了,因此这个依赖也交给Spring注入(需要提供setXXX方法)</span><br>    <span class="hljs-comment">// private UserService userService = new UserServiceImpl();</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserService</span><span class="hljs-params">(UserService userService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userService = userService;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 界面层的功能实现，对外提供访问的功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> usersService.insert(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>applicationContext.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建项目中需要的各种对象--&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建数据访问层的对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.mapper.UsersMapperImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建业务逻辑层的对象，实现类对象赋给接口引用（多态）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.service.impl.UsersServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usersMapper&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;uMapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建界面层的对象--&gt;</span><br>    <span class="hljs-comment">&lt;!--创建界面层的对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersController&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usersService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;uService&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建Spring容器对象同时启动容器,创建里面的所有对象</span><br>    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>    <span class="hljs-comment">// 从Spring容器中获取界面控制层的userController对象</span><br>    UserServlet uerController = (UserServlet) ac.getBean(<span class="hljs-string">&quot;uerController&quot;</span>);<br>    <br>    <span class="hljs-comment">// 测试功能</span><br>    <span class="hljs-keyword">int</span> num = usersController.insert(<span class="hljs-keyword">new</span> Users(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">12</span>));<br>    System.out.println(num);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="基于注解的ioc三层架构项目spring接管对象">3、基于注解的IOC三层架构项目（Spring接管对象）</h3>
<p>由Spring管理三层架构项目中的对象创建，包含界面层、业务逻辑层和数据访问层的对象创建。要创建的对象以及依赖信息都直接使用注解配置即可。</p>
<p>Note：<strong>基于注解的IOC,必须要在Spring的核心配置文件中添加包扫描.</strong></p>
<ul>
<li><code>@Component</code>:可以创建任意对象.创建的对象的默认名称是类名的驼峰命名法.也可以指定对象的名称 <code>@Component(“指定名称”)</code></li>
<li><code>@Controller</code>:专门用来创建控制器的对象(Servlet),这种对象可以接收用户的请求,可以返回处理结果给客户端.</li>
<li><code>@Service</code>:专门用来创建业务逻辑层的对象,负责向下访问数据访问层,处理完毕后的结果返回给界面层.</li>
<li><code>@Repository</code>:专门用来创建数据访问层的对象,负责数据库中的增删改查所有操作.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之数据访问层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Repository</span> <span class="hljs-comment">// 此注解说明交给Spring用来创建数据访问层的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UsersMapper</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users u)</span> </span>&#123;<br>        System.out.println(u.getUname() + <span class="hljs-string">&quot;用户增加成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsersMapperImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UsersMapperImpl的无参构造方法。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之业务逻辑层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span> <span class="hljs-comment">// 此注解说明交给Spring来专门创建Service业务逻辑层的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 依赖注入也交给Spring</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>	<span class="hljs-comment">// private UserMapper userMapper = new UserMapperImpl();</span><br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-comment">// 调用数据持久层将注册的信息插入到底层数据库</span><br>        <span class="hljs-keyword">return</span> usersMapper.insert(users);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsersServiceImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UsersServiceImpl的无参构造方法。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三层架构之界面层的controller</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Controller</span> <span class="hljs-comment">// 此注解说明交给Spring专门用来创建界面层之控制层的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersController</span> </span>&#123;<br>    <span class="hljs-comment">// 面向接口编程</span><br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>	<span class="hljs-comment">// private UserService userService = new UserServiceImpl();</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Users users)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> usersService.insert(users);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsersController</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UsersController的无参构造方法。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--指明要Spring扫描的包--&gt;</span><br>    <span class="hljs-comment">&lt;!--只要是基于注解开发，必须包扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建并启动容器</span><br>    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    <span class="hljs-comment">// 取出对象</span><br>    UsersController usersController = (UsersController) ac.getBean(<span class="hljs-string">&quot;usersController&quot;</span>);<br>    <br>    usersController.insert(<span class="hljs-keyword">new</span> Users(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;haha&quot;</span>, <span class="hljs-number">23</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220620115551.png" /></p>
<h2 id="四添加包扫描的方式">四、添加包扫描的方式</h2>
<ol type="1">
<li>单个包扫描(推荐使用)</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.service.impl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>多个包扫描,多个包之间以逗号或空格或分号分隔</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller com.bjpowernode.service ,com.bjpowernode.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>扫描根包(不推荐)</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>​ 会降低容器启动的速度,导致多做无用功.</p>
<h2 id="五为应用指定多个-spring-配置文件">五、为应用指定多个 Spring 配置文件</h2>
<p>当项目越来越大,需要多人合作开发,一个配置就存在很大隐患.</p>
<ol type="1">
<li>拆分配置文件的策略</li>
</ol>
<p>按层拆</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">applicationContext_controller.xml<br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersController&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookController&quot;</span>&gt;</span><br>applicationContext_service.xml<br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersService&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookService&quot;</span>&gt;</span><br>applicationContext_mapper.xml<br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersMapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookMapper&quot;</span>&gt;</span>    <br></code></pre></td></tr></table></figure>
<p>按功能拆</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">applicationContext_users.xml        <br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersController&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersService&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.UsersMapper&quot;</span>&gt;</span><br>applicationContext_book.xml      <br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookController&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookService&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.controller.BookMapper&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="六spring-配置文件的整合">六、Spring 配置文件的整合</h2>
<ol type="1">
<li>单个文件导入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.mapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.service&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>批量导入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext_*.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="七面向切面编程aop">七、面向切面编程AOP</h2>
<p>AOP（Aspect Orient Programming），面向切面编程。</p>
<p>切面：公共的，通用的，重复的功能称为切面，面向切面编程就是将切面提取出来，单独开发，在需要调用的方法中通过动态代理的方式进行织入。</p>
<h3 id="手写aop框架">1、手写AOP框架</h3>
<p>业务：图书购买业务</p>
<p><strong>切面：事务</strong></p>
<ol type="1">
<li><p>第一个版本：业务和切面紧耦合在一起,没有拆分.</p></li>
<li><p>第二个版本：使用子类代理的方式拆分业务和切面.</p></li>
<li><p>第三个版本：使用静态代理拆分业务和切面.业务和业务接口已拆分.此时切面紧耦合在业务中.</p>
<blockquote>
<p>静态代理：同样的业务接口，目标对象实现业务接口，代理对象和目标对象实现同一个业务接口）</p>
</blockquote></li>
<li>第四个版本：使用静态代理拆分业务和业务接口,切面和切面接口.</li>
<li><p>第五个版本：使用动态代理完成第四个版本的优化.</p></li>
</ol>
<h4 id="第一个版本业务和切面紧耦合在一起没有拆分.">第一个版本：业务和切面紧耦合在一起,没有拆分.</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy1;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 图书购买业务和事务切面耦合在一起</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;事务开启......&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;图书购买业务功能实现......&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;事务提交......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;事务回滚......&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="第二个版本使用子类代理的方式拆分业务和切面.">第二个版本：使用子类代理的方式拆分业务和切面.</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy2;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用子类代理的方式进行图书业务和事务切面的拆分</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> </span>&#123;<br>    <span class="hljs-comment">// 在父类中只有干干净净的任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;图书购买功能实现......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy2;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  子类就是代理类，将父类的图书购买功能添加业务切面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubBookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BookServiceImpl</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 事务切面</span><br>            System.out.println(<span class="hljs-string">&quot;事务开启......&quot;</span>);<br>            <span class="hljs-comment">// 主业务实现</span><br>            <span class="hljs-keyword">super</span>.buy();<br>            <span class="hljs-comment">// 事务切面</span><br>            System.out.println(<span class="hljs-string">&quot;事务提交......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;事务回滚......&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="第三个版本使用静态代理拆分业务和切面.业务和业务接口已拆分.此时切面紧耦合在业务中.">第三个版本：使用静态代理拆分业务和切面.业务和业务接口已拆分.此时切面紧耦合在业务中.</h4>
<p>静态代理：同样的业务接口，目标对象实现业务接口，代理对象和目标对象实现同一个业务接口）</p>
<p><em>Service.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy3;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-comment">// 规定业务功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>BookServiceImpl.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy3;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  目标对象：业务功能的具体实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Service</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;图书购买业务功能实现......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>ProductServiceImpl.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy3;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  目标对象：业务功能的具体实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Service</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;商品购买业务功能实现......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>Agent.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy3;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  静态代理实现了目标对象的灵活切换</span><br><span class="hljs-comment"> *  图书购买业务，商品购买业务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-comment">// 类中的成员变量的类型设计为接口，为了灵活切换目标对象</span><br>    <span class="hljs-keyword">public</span> Service service;<br><br>    <span class="hljs-comment">// 使用构造方法传入目标对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Agent</span><span class="hljs-params">(Service service)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.service = service;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 事务切面</span><br>            System.out.println(<span class="hljs-string">&quot;事务开启......&quot;</span>);<br>            <span class="hljs-comment">// 主业务实现</span><br>            service.buy();<br>            <span class="hljs-comment">// 事务切面</span><br>            System.out.println(<span class="hljs-string">&quot;事务提交......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="第四个版本使用静态代理拆分业务和业务接口切面和切面接口.">第四个版本：使用静态代理拆分业务和业务接口,切面和切面接口.</h4>
<p><em>AOP.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy4;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AOP</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接口默认方法：关键字default默认方法在接口的实现类中，不强制重写，但是也可以被重写，而且在接口中，这个默认方法可以有方法体内容.....</span><br><span class="hljs-comment">     * 如果实现类没有重新默认方法，但是会继承这个默认方法</span><br><span class="hljs-comment">     * 所以创建实现类对象后，可以调用默认方法。跟继承一样，如果实现类没有重写，那就调用的是接口中的方法体</span><br><span class="hljs-comment">     */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>LogAOP.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy4;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAOP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AOP</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置日志输出......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>TransAOP.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy4;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransAOP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AOP</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;事务开启......&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;事务提交......&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exception</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;事务回滚......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>Agent.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy4;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Service</span> </span>&#123;<br><br>    <span class="hljs-comment">// 传入目标（业务）对象，切面对象</span><br>    Service target;<br>    AOP aop;<br><br>    <span class="hljs-comment">// 使用构造方法初始化业务对象和切面对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Agent</span><span class="hljs-params">(Service target, AOP aop)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>        <span class="hljs-keyword">this</span>.aop = aop;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 切面</span><br>            aop.before();  <span class="hljs-comment">// 事务  日志</span><br>            <span class="hljs-comment">// 业务</span><br>            target.buy();  <span class="hljs-comment">// 图书  商品</span><br>            <span class="hljs-comment">// 切面</span><br>            aop.after();  <span class="hljs-comment">// 事务</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 切面</span><br>            aop.exception();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220624165919.png" /></p>
<h4 id="第五个版本使用动态代理完成第四个版本的优化.">第五个版本：使用动态代理完成第四个版本的优化.</h4>
<p><em>ProxyFactory.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy5;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getAgent</span><span class="hljs-params">(Service service, AOP aop)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回的是生成的动态代理对象</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>                <span class="hljs-comment">// 类加载器</span><br>                service.getClass().getClassLoader(),<br>                <span class="hljs-comment">// 目标对象实现的所有的接口</span><br>                service.getClass().getInterfaces(),<br>                <span class="hljs-comment">// 代理功能实现</span><br>                <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-comment">//               生成的代理对象，正在被调用的目标方法buy() show()  ，目标方法的参数</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                        Object obj = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 切面</span><br>                            aop.before();<br>                            <span class="hljs-comment">// 业务</span><br>                            obj = method.invoke(service, args);<br>                            <span class="hljs-comment">// 切面</span><br>                            aop.after();<br>                        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                            aop.exception();<br>                        &#125;<br><br>                        <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// 目标方法的返回值</span><br>                    &#125;<br>                &#125;<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220624170553.png" /></p>
<h3 id="spring支持的aop的实现">2、Spring支持的AOP的实现</h3>
<p>Spring支持AOP的编程，常用的有以下几种：</p>
<ol type="1">
<li>Before通知：在目标方法被调用前调用，涉及接口org.springframework.aop.MethodBeforeAdvice;</li>
<li>After通知：在目标方法被调用后调用，涉及接口为org.springframework.aop.AfterReturningAdvice;</li>
<li>Throws通知：目标方法抛出异常时调用，涉及接口org.springframework.aop.ThrowsAdvice;</li>
<li>Around通知：拦截对目标对象方法调用，涉及接口为org.aopalliance.intercept.MethodInterceptor。</li>
</ol>
<h3 id="aop常用的术语">3、AOP常用的术语</h3>
<ol type="1">
<li><strong>切面</strong>：就是那些重复的，公共的，通用的功能称为切面，例如：日志,事务,权限.</li>
<li><strong>连接点</strong>：就是目标方法。因为在目标方法中要实现目标方法的功能和切面功能.</li>
<li><strong>切入点(Pointcut)</strong>：指定切入的位置，多个连接点的集合构成切入点。切入点可以是一个目标方法，可以是一个类中的所有方法，可以是某个包下的所有类中的方法。</li>
<li>目标对象：操作谁，谁就是目标对象。</li>
<li><strong>通知(Advice)</strong>：来指定切入的时机。是在目标方法执行前还是执行后还是出错时，还是环绕目标方法切入切面功能.</li>
</ol>
<h2 id="八aspectj-基于注解的-aop-实现">八、AspectJ 基于注解的 AOP 实现</h2>
<p>AspectJ 是一个优秀面向切面的框架，它扩展了 Java 语言，提供了强大的切面实现。它因为是基于java语言开发的,所以无缝扩展。</p>
<h3 id="aspectj常见通知类型">1、AspectJ常见通知类型</h3>
<p>AspectJ 中常用的通知有四种类型：</p>
<ol type="1">
<li>前置通知@Before</li>
<li>后置通知@AfterReturning</li>
<li>环绕通知@Around</li>
<li>最终通知@After</li>
<li>定义切入点@Pointcut(了解)</li>
</ol>
<h3 id="aspectj-的切入点表达式掌握">2、AspectJ 的切入点表达式(掌握)</h3>
<ul>
<li><p>规范的公式:</p>
<p><code>execution(访问权限 方法返回值 方法声明(参数) 异常类型)</code></p>
<p>访问权限和异常类型可省略，但是方法返回值和方法声明(参数)是不可省略的</p></li>
<li><p>简化后的公式:</p>
<p><code>execution(方法返回值 方法声明(参数) )</code></p></li>
<li><p>用到的符号:</p>
<p><code>*</code>： 代表任意个任意的字符(通配符) <code>..</code>： 如果出现在方法的参数中,则代表任意参数；如果出现在路径中,则代表本路径及其所有的子路径</p></li>
</ul>
<h4 id="示例">示例</h4>
<ul>
<li><code>execution(public * *(..))</code>：任意的公共方法</li>
<li><code>execution(* set*(..))</code>：任何一个以“set”开始的方法</li>
<li><code>execution(* com.xyz.service.impl.*.*(..))</code>：任意的返回值类型，在 <code>com.xyz.service.impl</code> 包下的任意类的任意方法的任意参数</li>
<li><code>execution(* com.xyz.service..*.*(..))</code>：任意的返回值类型，在 <code>com.xyz.service</code> <u>及其子包下的</u>任意类的任意方法的任意参数 。比如可以是：<code>com.xyz.service.a.b.*.*(..)</code>， <code>com.xyz.service.*.*(..)</code></li>
<li><code>execution(* *..service.*.*(..))</code>：service之前可以有任意的子包</li>
<li><code>execution(* *.service.*.*(..))</code>：service之前只有一个包</li>
</ul>
<h3 id="aspectj-的前置通知-before">3、AspectJ 的前置通知 <span class="citation" data-cites="Before">@Before</span></h3>
<p><strong>前置通知在目标方法执行前切入切面功能。</strong>在切面方法中不可以获得目标方法的返回值，只能通过<strong>JoinPoint类型</strong>得到目标方法的签名（即访问权限，返回值，方法名以及参数，这些叫做目标方法的签名）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(value = &quot;execution( * com.bjpowernode.s01.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">(JoinPoint jp)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;目标方法的签名:&quot;</span>+jp.getSignature());<br>        System.out.println(<span class="hljs-string">&quot;目标方法的参数:&quot;</span>+ Arrays.toString(jp.getArgs()));<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="前置通知的切面方法的规范">前置通知的切面方法的规范</h4>
<ol type="1">
<li><p>访问权限是public</p></li>
<li><p>方法的返回值是void</p></li>
<li><p>方法名称自定义</p></li>
<li><p>方法没有参数,如果有也只能是JoinPoint类型</p></li>
<li><p>必须使用@Before注解来声明切入的时机是前切功能 和 切入点</p>
<p>参数：value 指定切入点表达式</p></li>
</ol>
<h4 id="实现的步骤">实现的步骤：</h4>
<ol type="1">
<li>创建业务接口</li>
<li>创建业务实现</li>
<li>创建切面类，实现切面方法</li>
<li>在applicationContext.xml文件中绑定业务和切面</li>
</ol>
<h4 id="创建业务接口">1. 创建业务接口</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义各种业务功能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SomeService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showName</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="创建业务实现类">2. 创建业务实现类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 具体业务实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SomeService</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showName</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;showName方法执行&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="创建切面类实现切面方法">3. 创建切面类，实现切面方法</h4>
<p>所有切面的功能都是由切面方法来实现的，可以将各种切面都在此类中进行开发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 指明这是一个切面，交给AspectJ框架管理，扫描到这个注解就会知道这个是一个切面类然后进行切面的操作</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 创建切面对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br><br>    <span class="hljs-comment">// 前置通知，在目标方法执行之前执行。</span><br>    <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 切面方法，前置通知</span><br><span class="hljs-comment">     * 1)访问权限是public</span><br><span class="hljs-comment">     * 2)方法的返回值是void</span><br><span class="hljs-comment">     * 3)方法名称自定义</span><br><span class="hljs-comment">     * 4)方法没有参数,如果有也只能是JoinPoint类型</span><br><span class="hljs-comment">     * 5)必须使用<span class="hljs-doctag">@Before</span>注解来声明切入的时机是前置通知和切入点</span><br><span class="hljs-comment">     *   参数:value  指定切入点表达式，</span><br><span class="hljs-comment">     *   这里是切入点就是一个连接点com.lin.aspectj1.UserServiceImpl.showName（方法名）</span><br><span class="hljs-comment">     *   在此showName方法执行前执行这个前置通知。</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">// 业务方法</span><br>    <span class="hljs-comment">// public String showName(String name, int age)</span><br>    <span class="hljs-meta">@Before(value  = &quot;execution(public String com.bjpowernode.s01.SomeServiceImpl.*(String,int))&quot;)</span> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Before(value = &quot;execution(public * com.bjpowernode.s01.SomeServiceImpl.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Before(value = &quot;execution( * com.bjpowernode.s01.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">(JoinPoint jp)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;目标方法的签名:&quot;</span>+jp.getSignature());<br>        System.out.println(<span class="hljs-string">&quot;目标方法的参数:&quot;</span>+ Arrays.toString(jp.getArgs()));<br>    &#125;<br>    <br>    <span class="hljs-meta">@Before(value = &quot;execution( * com.bjpowernode.s01..*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Before(value = &quot;execution( * *(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myBefore</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;切面方法中的前置通知功能实现............&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="在applicationcontext.xml文件中绑定业务和切面">4. 在applicationContext.xml文件中绑定业务和切面</h4>
<h2 id="section"><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--创建业务对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lin.aspectj.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--创建切面对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;LogAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lin.aspectj.LogAspect&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>	<span class="hljs-comment">&lt;!--绑定--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></h2>
<h4 id="关于aspectj框架切换jdk动态代理和cglib动态代理">关于AspectJ框架切换JDK动态代理和CGLib动态代理</h4>
<p><code>&lt;aop:aspectj-autoproxy &gt;&lt;/aop:aspectj-autoproxy&gt;</code> 默认是JDK动态代理,取时必须使用接口类型</p>
<p><code>&lt;aop:aspectj-autoproxy proxy-target-class=“true”&gt;&lt;/aop:aspectj-autoproxy&gt;</code>设置为CGLib子类代理,可以使用接口和实现类接</p>
<p>记住：使用接口来接,永远不出错.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">当业务实现类没有父接口时，可以使用CGLib子类代理，然后用实现类接代理对象。<br>SomeServiceImpl service = (SomeServiceImpl)ac.getBean(<span class="hljs-string">&quot;someServiceImpl&quot;</span>);<br>当业务实现类有父接口时，就直接用jdk动态代理，用接口接收代理对象。<br>SomeService service = (SomeService)ac.getBean(<span class="hljs-string">&quot;someServiceImpl&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>说白了就是JDK动态代理只能用接口来接，但是CGLIB动态代理可以用接口的实现类（子类）来接</p>
<hr />
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// 启动容器</span><br>    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;aspectj1/applicationContext.xml&quot;</span>);<br><br>    SomeService userService = (SomeService) ac.getBean(<span class="hljs-string">&quot;UserService&quot;</span>);<br><br>    <span class="hljs-comment">// 底层aspectj通过动态代理将业务对象的代理对象创建了</span><br>    System.out.println(userService.getClass());<span class="hljs-comment">// 输出：class com.sun.proxy.$Proxy12</span><br><br>    <span class="hljs-comment">// 这个业务方法绑定了一个前置通知</span><br>    userService.showName(<span class="hljs-string">&quot;dfd&quot;</span>,<span class="hljs-number">34</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220624175155.png" style="zoom: 50%;" /></p>
<h3 id="aspectj-的后置通知-afterreturning">4、AspectJ 的后置通知 <span class="citation" data-cites="AfterReturning">@AfterReturning</span></h3>
<p><strong>后置通知是在目标方法执行后切入切面功能</strong>。可以得到目标方法的返回值。如果目标方法的返回值是简单类型(8种基本类型+String)则不可改变。如果目标方法的返回值是引用类型则可以改变。</p>
<ul>
<li><p>基本数据类型是值传递的，是将基本数据类型复制一份传递给下面的，它无法更改人家本来的</p></li>
<li><p>引用数据类型保存的是内存地址，把内存地址给了下边以后，下边一改变，那上面的也会改变</p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220625200516.png" /></p>
<h4 id="后置通知的方法的规范">后置通知的方法的规范</h4>
<ol type="1">
<li><p>访问权限是public</p></li>
<li><p>方法没有返回值void</p></li>
<li><p>方法名称自定义</p></li>
<li><p>方法有参数(也可以没有参数,如果目标方法没有返回值，则可以写无参的方法，但一般会写有参，这样可以处理无参可以处理有参)，这个切面方法的参数就是目标方法的返回值</p></li>
<li><p>使用 <span class="citation" data-cites="AfterReturning">@AfterReturning</span> 注解表明是后置通知</p>
<p>参数:</p>
<ul>
<li><p>value：指定切入点表达式</p></li>
<li><p>returning：指定目标方法的返回值的名称,则名称必须与切面方法的参数名称一致.</p></li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>  <br><span class="hljs-meta">@Component</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 后置通知</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@AfterReturning(value  = &quot;execution(  com.bjpowernode.s02..*(..))&quot;,returning = &quot;obj&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myAfterReturning</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后置通知功能实现..............&quot;</span>);<br>        <span class="hljs-keyword">if</span>(obj != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> String)&#123;<br>                obj = obj.toString().toUpperCase();<br>                System.out.println(<span class="hljs-string">&quot;在切面方法中目标方法的返回值:&quot;</span>+obj);<br>            &#125;<br>        <br>            <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> Student)&#123;<br>                Student stu = (Student) obj;<br>                stu.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;在切面方法中目标方法的返回值:&quot;</span>+stu);<br>            &#125;<br>       	&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220625202106.png" /></p>
<blockquote>
<p>目标方法的返回值是Student类型，切面方法和测试方法返回值相同，都是改变后的。</p>
</blockquote>
<h3 id="aspectj-的环绕通知-around">5、AspectJ 的环绕通知 <span class="citation" data-cites="Around">@Around</span></h3>
<p><strong>环绕通知是通过拦截目标方法的方式，在目标方法前后增强功能的通知。</strong>它是功能最强大的通知，一般事务使用此通知。它可以轻易的改变目标方法的返回值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220626105306.png" /></p>
<h4 id="环绕通知方法的规范">环绕通知方法的规范</h4>
<ol type="1">
<li><p>访问权限是public</p></li>
<li><p>切面方法有返回值,此返回值就是目标方法的返回值</p></li>
<li><p>方法名称自定义</p></li>
<li><p>方法有参数,此参数就是目标方法</p></li>
<li><p>回避异常Throwable</p></li>
<li><p>使用@Around注解声明是环绕通知</p>
<p>参数:</p>
<ul>
<li>value:指定切入点表达式</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(value = &quot;execution(* com.bjpowernode.s03.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">myAround</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">// 前切功能实现</span><br>        System.out.println(<span class="hljs-string">&quot;环绕功能中的前置功能实现...&quot;</span>);<br>        <span class="hljs-comment">// 目标方法调用</span><br>        Object obj = pjp.proceed(pjp.getArgs());<br>        System.out.println(<span class="hljs-string">&quot;    在切面方法中，目标方法的返回值:&quot;</span> + obj);<br>        <span class="hljs-comment">// 后切功能实现</span><br>        System.out.println(<span class="hljs-string">&quot;环绕功能中的后置功能实现...&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj.toString().toUpperCase();  <span class="hljs-comment">// 改变了目标方法的返回值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220626112059.png" /></p>
<h3 id="aspectj-的最终通知-after">6、AspectJ 的最终通知 <span class="citation" data-cites="After">@After</span></h3>
<p><strong>无论目标方法是否正常执行，最终通知的代码都会被执行。</strong></p>
<p>可以理解为 <code>try catch finally</code> 中的 <code>finally</code>。</p>
<p>​</p>
<h4 id="最终通知方法的规范">最终通知方法的规范</h4>
<ol type="1">
<li><p>访问权限是public</p></li>
<li><p>方法没有返回值</p></li>
<li><p>方法名称自定义</p></li>
<li><p>方法没有参数,如果有也只能是 JoinPoint</p></li>
<li><p>使用 <span class="citation" data-cites="After">@After</span> 注解表明是最终通知</p>
<p>参数：</p>
<ul>
<li>value：指定切入点表达式</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最终通知方法的规范</span><br><span class="hljs-comment">     * 1)访问权限是public</span><br><span class="hljs-comment">     * 2)方法没有返回值</span><br><span class="hljs-comment">     * 3)方法名称自定义</span><br><span class="hljs-comment">     * 4)方法没有参数,如果有也只能是JoinPoint</span><br><span class="hljs-comment">     * 5)使用<span class="hljs-doctag">@After</span>注解表明是最终通知</span><br><span class="hljs-comment">     *   参数:</span><br><span class="hljs-comment">     *     value:指定切入点表达式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@After(&quot;execution(* com.bjpowernode.s04.*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myAfter</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;最终通知:释放资源........&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="给切入点表达式起别名-pointcut">7、给切入点表达式起别名 <span class="citation" data-cites="Pointcut">@Pointcut</span></h3>
<p>如果多个切面切入到同一个切入点，可以使用别名简化开发。</p>
<p>使用 <span class="citation" data-cites="Pointcut">@Pointcut</span> 注解，创建一个空方法，此方法的名称就是别名。</p>
<h2 id="九sm整合的步骤">九、SM整合的步骤</h2>
<ol type="1">
<li>建表</li>
<li>新建项目,选择quickstart模板</li>
<li>修改目录</li>
<li>修改pom.xml文件,添加相关的依赖(使用老师提供)</li>
<li>添加MyBatis相应的模板(SqlMapConfig.xml和XXXMapper.xml文件)</li>
<li>添加SqlMapConfig.xml文件(MyBatis核心配置文件),并拷贝jdbc.propertiest属性文件到resources目录下</li>
<li>添加applicationContext_mapper.xml</li>
<li>添加applicationContext_service.xml</li>
<li>添加Users实体类,Accounts实体类</li>
<li>添加mapper包,添加UsersMapper接口和UsersMapper.xml文件并开发</li>
<li>添加service包,添加UsersService接口和UsersServiceImpl实现类</li>
<li>添加测试类进行功能测试</li>
</ol>
<h2 id="十事务">十、事务</h2>
<h3 id="spring-中添加事务的两种方式">1、Spring 中添加事务的两种方式</h3>
<p><strong>正常是使用事务，一旦出错就回滚，撤销出错前的代码。</strong></p>
<p>Spring能够自动提交事务，但是不能自动回滚，所以需要手动添加。</p>
<p>Spring 中添加事务的两种方式：</p>
<p><strong>1) 注解式的事务</strong> 使用@Transactional注解完成事务控制，此注解可添加到类上，则对类中所有的方法执行事务的设定。此注解也可添加到方法上，只是对此方法执行事务的处理。</p>
<p>此方式有缺点，事务一般用于增删改操作，有出错则回滚增删改操作。倘若一个类中有查询方法的话，<span class="citation" data-cites="Transactional注解声明在类上的话">@Transactional注解声明在类上的话</span>，就不合适了，因为查询方法不需要事务，这样就得在每个增删改方法上面声明@Transactional注解，代码量太大，如果只有增删改方法，则可以用用。</p>
<p><strong>2) 声明式事务(必须掌握)，在配置文件中添加一次，整个项目遵循事务的设定.</strong></p>
<h4 id="通过-transactional-注解添加事务">1. 通过 <span class="citation" data-cites="Transactional">@Transactional</span> 注解添加事务</h4>
<p><span class="citation" data-cites="Transactional">@Transactional</span> 注解参数详解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED,  // 事务的传播特性</span><br><span class="hljs-meta">            noRollbackForClassName = &quot;ArithmeticException&quot;,  // 指定发生什么异常不回滚,使用的是异常的名称</span><br><span class="hljs-meta">            noRollbackFor = ArithmeticException.class,  // 指定发生什么异常不回滚,使用的是异常的类型</span><br><span class="hljs-meta">            rollbackForClassName = &quot;&quot;,  // 指定发生什么异常必须回滚</span><br><span class="hljs-meta">            rollbackFor = ArithmeticException.class,  // 指定发生什么异常必须回滚</span><br><span class="hljs-meta">            timeout = -1,  // 连接超时设置,默认值是-1,表示永不超时</span><br><span class="hljs-meta">            readOnly = false,  // 默认是false。如果是查询操作,必须设置为true.</span><br><span class="hljs-meta">            isolation = Isolation.DEFAULT  // 使用数据库默认的隔离级别        </span><br><span class="hljs-meta">    )</span><br></code></pre></td></tr></table></figure>
<h4 id="为什么要添加事务管理器">为什么要添加事务管理器？</h4>
<ul>
<li><p>JDBC 的事务处理: <code>Connection</code> <code>con.commit();</code> <code>con.rollback();</code></p></li>
<li><p>MyBatis 的事务处理: <code>SqlSession</code> <code>sqlSession.commit();</code> <code>sqlSession.rollback();</code></p></li>
<li><p>Hibernate 的事务处理: <code>Session</code> <code>session.commit();</code> <code>session.rollback();</code></p></li>
</ul>
<p><strong>事务管理器用来生成相应技术的连接+执行语句的数据库操作对象.</strong></p>
<ul>
<li>如果使用MyBatis框架，必须使用 <code>DataSourceTransactionManager</code> 类完成处理，用于生成SqlSession对象。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加事务管理器对象，用于生成数据库操作对象。--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--因为事务必须关联数据库处理,所以要配置数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><font color="red"><strong>项目中的所有事务,必须添加到业务逻辑层上.</strong></font></p>
<h4 id="声明式事务">2. 声明式事务</h4>
<p>Spring非常有名的事务处理方式，声明式事务。</p>
<p>要求项目中的方法命名有规范：</p>
<ol type="1">
<li>完成增加操作包含 add save insert set</li>
<li>更新操作包含 update change modify</li>
<li>删除操作包含 delete drop remove clear</li>
<li>查询操作包含 select find search get</li>
</ol>
<p>配置事务切面时可以使用通配符 * 来匹配所有方法</p>
<h4 id="声明式事务的实现">声明式事务的实现</h4>
<p>Spring配置文件：</p>
<p>此配置文件与 applicationContext_service.xml 功能一样，只是事务配置不同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br> <br> <br>    <span class="hljs-comment">&lt;!--添加包扫描，告知Spring哪些包中包含要交给Spring创建对象的类--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode.service.impl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--导入Spring整合MyBatis的配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext_mapper.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--Spring的声明式事务处理--&gt;</span><br>    <span class="hljs-comment">&lt;!--1.创建事务管理器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--事务管理器需要配合数据库操作，所以需要添加数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--2.配置事务切面功能--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCut&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--指定哪些业务方法拥有此事务切面功能--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*insert*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--只要方法名包含insert的方法，都拥有传播特性属性为REQUIRED的事务--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*add*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*Register*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*delete*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*remove*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*update*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*modify*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*select*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*get*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--只要方法名包含get的方法，都拥有只读属性为true的事务--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!--3.将 事务切面 和 切入点 绑定，指定哪些接入点拥有上面的事务切面--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--给切入点起个id标识--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myServiceCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bjpowernode.service.impl.*.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--绑定--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;myCut&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myServiceCut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><em>UserServiceImpl.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <br><span class="hljs-meta">@Service</span><span class="hljs-comment">// 交给Spring创建对象</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountService accountService;<br> <br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * userRegister这个方法可以看成事务A，在事务A中包含事务B</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">userRegister</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-comment">// 调用数据持久层的方法将用户的信息保存到底层数据库</span><br>        <span class="hljs-keyword">int</span> count = userMapper.insertUser(user);<br>        System.out.println(<span class="hljs-string">&quot;用户注册成功&quot;</span>);<br> <br>        <span class="hljs-comment">// 增加账户，包含事务B addAccount</span><br>        accountService.addAccount(<span class="hljs-keyword">new</span> Account(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;user5&quot;</span>,<span class="hljs-string">&quot;用户5&quot;</span>));<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>AccountServiceImpl.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccountService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountMapper accountMapper;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * addAccount可以看成事务B</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> influencedRows = <span class="hljs-number">0</span>;<br>        influencedRows = accountMapper.insertAccount(account);<br>        System.out.println(<span class="hljs-string">&quot;增加账户成功，influencedRows=&quot;</span>+influencedRows);<br> <br>        <span class="hljs-comment">// 手动抛出一个异常,模拟网络出错,出错的话应该不要让数据插入到底层数据库</span><br>        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);<br> <br>        <span class="hljs-keyword">return</span> influencedRows;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUserByTrans</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建并启动Spring容器</span><br>    ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext_serviceTrans.xml&quot;</span>);<br><br>    <span class="hljs-comment">// 取出userServiceImpl对象</span><br>    UserService userServiceImpl = (UserService) ac.getBean(<span class="hljs-string">&quot;userServiceImpl&quot;</span>);<br>    System.out.println(userServiceImpl.getClass());<br><br>    <span class="hljs-comment">// 要注册的用户</span><br>    User bat = <span class="hljs-keyword">new</span> User(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;bat&quot;</span>, <span class="hljs-string">&quot;234&quot;</span>);<br><br>    <span class="hljs-comment">// 注册业务实现</span><br>    <span class="hljs-keyword">int</span> count = userServiceImpl.userRegister(bat);<br>    System.out.println(count);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220626234738.png" /></p>
<p>可以看到，声明式事务起作用了，底层数据没有插入。即使在执行完插入数据库的代码后，在出错后，也能回滚事务。</p>
<h4 id="设置事务处理的优先级">设置事务处理的优先级</h4>
<p>当我们使用了声明式注解，又想使用注解式注解，就是某些不想受声明式事务管理。</p>
<p>就可以开启注解式事务，然后将注解式事务的优先级设置的比声明式事务的高，就会优先使用注解式事务。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注解式事务的驱动，开启注解式事务。优先级order=&quot;100&quot;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:annotation-driven</span>&gt;</span><br> <br> <span class="hljs-comment">&lt;!--3.将事务切面 和 切入点 绑定，指定哪些接入点拥有上面的事务切面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--给切入点起个id标识--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myServiceCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.lin.sm.service.impl.*.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--绑定 advice-ref切面 pointcut-ref切入点--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;myCut&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myServiceCut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-comment">// 不使用声明式事务，使用自己的注解式事务</span><br><span class="hljs-meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccountService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountMapper accountMapper;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * addAccount可以看成事务B</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> influencedRows = <span class="hljs-number">0</span>;<br>        influencedRows = accountMapper.insertAccount(account);<br>        System.out.println(<span class="hljs-string">&quot;增加账户成功，influencedRows=&quot;</span>+influencedRows);<br> <br>        <span class="hljs-comment">// 手动抛出一个异常,模拟网络出错,出错的话应该不要让数据插入到底层数据库</span><br>        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);<br> <br>        <span class="hljs-keyword">return</span> influencedRows;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="事务的隔离级别">2、事务的隔离级别</h3>
<ul>
<li><p><strong>MySQL中默认的隔离级别：repeatable read可重复读</strong></p></li>
<li><p>Oracle中默认的隔离级别：read committed读取已提交的</p></li>
</ul>
<ol type="1">
<li><p>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</p></li>
<li><p>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</p></li>
<li><p>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读，但是innoDB解决了幻读</p></li>
<li><p>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</p></li>
<li><p>isolation = Isolation.DEFAULT // 使用数据库默认的隔离级别</p></li>
</ol>
<blockquote>
<p>对于同时运行的多个事务，当这些事务同时操作同一个数据库中相同的数据时， 如果没有采取必要的隔离机制，就会导致各种并发问题，事务就相当于一个线程。(类似于Java中的线程安全问题，数据库就是共享数据)：</p>
<ul>
<li><p>脏读: 对于两个事务T1, T2；T1读取了T2 还没提交的数据，读到的是T2更新的数据. 之后, 若T2 回滚, T1读取的内容就是临时且无效的。</p></li>
<li><p>不可重复读: 对于两个事务T1, T2；T1 读取了一个字段, 然后T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了。</p></li>
<li><p>幻读: 对于两个事务T1, T2； T1在T2提交插入语句之前对表进行查询, 然后T2 在该表中插入了一些新的行。 之后, 如果T1 再次查询这个表, 就会多出几行，读到插入的数据，简单说就是在同一个事务T1中，两次查询的结果不一样</p></li>
</ul>
<p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.</p>
<p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别,</p>
<p>不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱，效率越低</p>
<p>通过设置隔离级别来解决并发问题</p>
<p>事务的隔离级别：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>read uncommitted 读取未提交的</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>read committed 读取已提交的</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>repeatable read 可重复读</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr class="even">
<td>serializable 串行化</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="spring-事务的传播特性">3、Spring 事务的传播特性</h3>
<p>多个事务之间的合并，互斥等都可以通过设置事务的传播特性来解决。</p>
<p><strong>常用</strong></p>
<ul>
<li><code>PROPAGATION_REQUIRED</code>：必被包含事务（增删改必用）</li>
<li><code>PROPAGATION_REQUIRES_NEW</code>：自己新开事务，不管之前是否有事务</li>
<li><code>PROPAGATION_SUPPORTS</code>：支持事务，如果加入的方法有事务，则支持事务，如果没有，单开事务（跟外面的事务保持一致？）</li>
<li><code>PROPAGATION_NEVER</code>：不能运行中事务中，如果包在事务中，抛异常</li>
<li><code>PROPAGATION_NOT_SUPPORTED</code>：不支持事务，<u>运行在非事务</u>的环境</li>
</ul>
<p><strong>不常用</strong></p>
<ul>
<li><code>PROPAGATION_MANDATORY</code>：必须包在事务中，没有事务则抛异常</li>
<li><code>PROPAGATION_NESTED</code>：嵌套事务</li>
</ul>
<h4 id="事务传播特性解析">事务传播特性解析</h4>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220626230847.png" style="zoom: 50%;" /></p>
<ul>
<li>场景8：底层直接报异常，方法都没执行。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>A Survey of Advances in Evolutionary Neural Architecture Search</title>
    <url>/2022/06/24/A%20Survey%20of%20Advances%20in%20Evolutionary%20Neural%20Architecture%20Search/</url>
    <content><![CDATA[<h1 id="A-Survey-of-Advances-in-Evolutionary-Neural-Architecture-Search"><a href="#A-Survey-of-Advances-in-Evolutionary-Neural-Architecture-Search" class="headerlink" title="A Survey of Advances in Evolutionary Neural Architecture Search"></a>A Survey of Advances in Evolutionary Neural Architecture Search</h1><p>深度神经网络（DNNs）在目标检测、自然语言理解和语音识别等智能系统中得到了广泛的应用。对于一个特定的问题，我们总是致力于构建最合适的DNN来解决它，这需要选择最合适的模型体系结构并寻求最佳的模型参数值。然而，现有的大多数工作集中于模型参数学习，前提是可以根据先验知识和/或试错实验手动指定模型体系结构。为了克服这一问题，进化算法（EAs）被广泛用于自动设计模型体系结构。此外，EAs用于神经网络优化已有30多年的历史。因此，本文从先进技术的角度对进化神经结构搜索（ENAS）进行了综述。我们希望这项工作能够为读者提供对EAs角色的全面理解，并将自己的注意力集中在ENA上。</p>
<p>神经结构搜索（NAS）来自动设计神经网络[5]。NAS可以被视为一个优化问题，在这个问题上，找出最佳的模型体系结构，以在特定任务上实现最佳性能。由于通常很难用连续参数表示模型结构，并且模型结构与其性能之间没有明确的公式，因此该优化问题通常具有非凸和黑盒特性。</p>
<h2 id="Neural-Architectural-Search"><a href="#Neural-Architectural-Search" class="headerlink" title="Neural Architectural Search"></a>Neural Architectural Search</h2><h3 id="Problem-statement"><a href="#Problem-statement" class="headerlink" title="Problem statement"></a>Problem statement</h3><p>两个方面决定了神经网络的性能，即模型结构 $M_a$ 和模型参数 $M_p$。前者是指网络中的基本单元，包括单元类型（如卷积层、池层和全连接层）、单元数量以及这些单元之间的连接，定义了模型的能力。后者是关于这些单元中的可训练参数，即连接权重和biases。因此，要为特定任务设计最佳模型，NAS需要搜索与模型参数相关的最佳模型体系结构。它可以表示为方程中的优化问题：</p>
<p><img src="C:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220624225100788.png" style="zoom:50%;" /></p>
<p>这是一个双层优化问题。上层优化问题意味着在Pareto  Front上找到最优模型结构，以最小化验证数据集上的（可能）多个目标函数。下层优化问题是指优化模型参数以最小化训练数据集上的损失函数。还有各种各样的限制：</p>
<ol>
<li>一是限制候选解决方案的搜索空间，包括预定义可能单元的类型，以及确定网络中单元的最大数量 </li>
<li>另一个问题是防止发现无效的解决方案，包括无效的架构（例如完全连接的层后面是卷积层）和不满足特定要求的架构，例如模型大小</li>
</ol>
<p>NAS是一个极具挑战性的优化问题。具体而言，该问题的性质总结如下：</p>
<ul>
<li>巨大的搜索空间，其中候选模型体系结构随着可能的连接、单元数量和单元类型呈指数增长；</li>
<li>一个黑盒优化问题，因为模型体系结构的性能无法公式化；</li>
<li>一个非凸和不可微的搜索环境，因为模型架构很难用连续参数表示</li>
<li>可能是一个具有各种约束的多目标优化问题。</li>
</ul>
<h3 id="Existing-methods"><a href="#Existing-methods" class="headerlink" title="Existing methods"></a>Existing methods</h3><p>优化问题（1）通常是迭代求解的。通过这种方式，设计了一个优化器，从搜索空间中对候选模型体系结构进行采样；然后，采用基于梯度的方法在训练数据集上对这些候选对象进行训练，并在验证数据集上进行评估；对每个模型的评估都是作为反馈，以帮助优化器以更高的性能再现模型体系结构。目前有三种主流的优化方法，即基于RL的方法、基于EA的方法和基于梯度的方法。</p>
<h4 id="Reinforcement-learning-based-methods"><a href="#Reinforcement-learning-based-methods" class="headerlink" title="Reinforcement learning based methods."></a>Reinforcement learning based methods.</h4>]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>EANAS</tag>
      </tags>
  </entry>
  <entry>
    <title>【AE-CNN】Completely Automated CNN Architecture Design Based on Blocks</title>
    <url>/2022/06/22/%E3%80%90AE-CNN%E3%80%91/</url>
    <content><![CDATA[<h1 id="ae-cnncompletely-automated-cnn-architecture-design-based-on-blocks">AE-CNN：Completely Automated CNN Architecture Design Based on Blocks</h1>
<ul>
<li>IEEE-TNNLS 2019</li>
</ul>
<p>本文主要的思路是使用基于 ResNet 和 DenseNet 块的遗传算法自动进化CNN结构。</p>
<h2 id="basic-idea">Basic Idea</h2>
<ol type="1">
<li><p>AE-CNN 是自动设计网络结构。</p></li>
<li><p>该算法基于ResNet块（RB）和DenseNet块（DB）设计了一种新编码策略。</p></li>
<li><p>采用变长编码方案搜索CNN的最佳深度。为了采用变长编码，设计了一种新的交叉算子和变异算子，并将其融入到所提出的算法中，以共同开发和探索最佳CNN结构中的搜索空间。</p></li>
</ol>
<h2 id="background">Background</h2>
<p>基于进化算法的CNN体系结构设计算法仅利用了进化算法的部分优点，导致发现的CNN通常对所研究的问题没有很好的性能。例如，genetic CNN <u>采用固定长度编码方案</u>来表示CNN。但 CNN 在解决新问题方面的最佳深度是未知的。</p>
<p>large-scale evolution 利用可变长度编码方案，其中 CNN 可以自适应地改变其问题深度。但是该算法在搜索过程中只使用变异算子，而不使用任何交叉算子。在进化算法中，交叉算子和变异算子起着局部搜索和全局搜索的互补作用。在不使用交叉算子的情况下，变异算子就像在不同的起始位置进行随机搜索一样。然而，large-scale evolution 不使用交叉算子并不奇怪，因为交叉算子最初是为固定长度编码方案设计的。</p>
<h3 id="ga">GA</h3>
<p>遗传算法的流程：</p>
<p>1：初始化一组个体，每个个体通过所采用的编码策略代表问题的候选解决方案。</p>
<p>2：根据编码信息和适应度函数评估群体中每个个体的适应度。</p>
<p>3：从当前群体中选择有希望的亲本个体进行交配，然后使用交叉和变异算子生成后代。</p>
<p>4：评估所产生后代的fitness值。</p>
<p>5：从当前种群中选择一个表现良好的种群，然后用所选种群替换当前种群。</p>
<p>6：如果不符合终止条件，则转到步骤3；否则，返回具有最佳适应度的个人作为问题的最佳解决方案。</p>
<h3 id="resnet-block">Resnet block</h3>
<p>Resnet block 由三个卷积层和一个跳跃连接组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623182034.png" style="zoom: 33%;" /></p>
<p>在conv1上，使用1×1大小的滤波器减少了输入的空间大小和参数，以降低conv2的计算复杂度。</p>
<p>在conv2上，使用较大尺寸的过滤器（如3×3）来学习具有相同空间尺寸的特征。</p>
<p>在conv3上，再次使用大小为1×1的过滤器，并增加空间大小以生成更多特征。</p>
<p>conv3之后，添加输入，将conv3的输出作为 RB 的最终输出。注意，如果输入和conv3的输出的空间大小不相等，则对输入应用一组1×1卷积运算以实现与conv3的输出相同的空间大小，用于加法。</p>
<div class="note note-info">
            <p><strong>1×1 卷积作用：</strong></p><ol type="1"><li><p>跨通道的特征整合</p><p>例子：使用1 ∗ 1卷积核，实现降维和升维的操作其实就是channel间信息的线性组合变化，3 ∗ 3∗64channels的输入后面添加一个 1∗1∗28 channels的卷积核，就变成了3 ∗ 3 ∗ 28 channels的输出，原来的64个channels就可以理解为跨通道线性组合变成了28channels，这就是通道间的信息交互。</p></li><li><p>特征通道的升、降维</p></li><li><p>保持feature map尺度不变，增加非线性</p><p>1*1卷积核，可以在保持feature map尺度不变的（即不损失分辨率）的前提下大幅增加非线性特性（利用后接的非线性激活函数），把网络做的很deep。</p></li><li><p>减少卷积核参数（简化模型）</p></li></ol><p><strong>和全连接层的关系：</strong></p><p>当输入的feature map的尺寸是1×1时，两者从数学原理上来看，没有区别。假设输入为c×1×1，输出为n×1×1，那么全连接可以认为是一个c维的向量和n×c大小的矩阵相乘。卷积层可以理解为n个c×1×1的卷积核，分别与输入做内积，跟计算矩阵向量乘没有区别。</p><p>当输入为c×w×h时，卷积层和全连接层的输出尺寸就不一样了，1×1的卷积输出为n×w×h，全连接的输出是n×1×1。此时，全连接可以等价于n个c×w×h卷积核的卷积层。</p><p>全连接层和卷积层最大的区别就是输入尺寸是否可变，全连接层的输入尺寸是固定的，卷积层的输入尺寸是任意的。</p>
          </div>
<h3 id="dense-block">Dense block</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623182045.png" style="zoom:33%;" /></p>
<p>在DB中，每个卷积层不仅接收来自输入数据的输入，还接收来自所有先前卷积层的输出。</p>
<p>此外，还有一个参数k用于控制同一卷积层的输入和输出的空间大小。如果输入的空间大小是a，那么输出的空间大小是a+k，这是通过使用相应数量的滤波器进行卷积运算来实现的。</p>
<p>RBs和DBs能够缓解梯度消失问题的不利影响，基于此，深层架构能够有效学习输入数据的层次表示，进而提高最终分类精度。此外，DBs中的密集连接也能够重用低级特征，以提高对CNN顶层学习到的特征的辨别能力。主要基于这些优良特性，选择RBs和DBs作为该算法的构建块。</p>
<h2 id="ae-cnn">AE-CNN</h2>
<p>AE-CNN 算法的整体流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220622131240.png"  style="zoom: 60%;" /></p>
<ol type="1">
<li>首先，使用预定义的大小N随机初始化总体。</li>
<li>然后，评估初始化总体中的个体的fitness。</li>
<li>种群中的所有个体参与遗传算法的进化过程 ：
<ol type="1">
<li>初始化一个空种群以包含子代</li>
<li>通过二元锦标赛选择两个父代</li>
<li>通过交叉和变异操作从选定的父代中生成两个新的子代</li>
</ol></li>
<li>评估种群中个体的fitness</li>
<li>通过环境选择操作从当前种群（包含当前个体和生成的后代）中选择一个新种群，作为存活到下一个进化过程（即下一代）的父代解</li>
<li>最后，从最终种群中选择的最佳个体，解码出来的就是最佳的CNN架构</li>
</ol>
<h3 id="population-initialization">1. Population Initialization</h3>
<p>种群初始化为以下进化过程提供了一个包含多个个体的基本种群。通常，所有个体以均匀分布的随机方式初始化，每个个体都应该代表一个CNN体系结构。</p>
<p>个体从三种不同类型的单元：RB单元（RBU）、DB单元（DBU）和池化层单元（PU），随机生成。注意池化层只能跟在其他两个单元的后面。生成了一个网络结构后，对网络进行编码。</p>
<hr />
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623182105.png" style="zoom: 60%;" /></p>
<blockquote>
<p>第2行：CNN中的池化层对其输入数据执行降维，最常用的池化操作是将输入大小减半。为此，所使用的池化层数量需要限制为 <span class="math inline">\(\left\lfloor\log _{2}(d)\right\rfloor\)</span>。例如，如果输入大小为32×32，使用的池层数不能大于6，因为6个池层会将输入数据的维数减少到1×1，而1×1维数上的一个额外池层会导致逻辑错误。</p>
</blockquote>
<p>在该算法中没有考虑全连接层。原因是，全连接层由于其完全连接的性质，容易导致过拟合现象。为了减少这种现象，必须采用其他技术，如dropout。然而，这些技术也会产生需要仔细调整的参数，这将增加所提出算法的计算复杂性。</p>
<p>具体而言，RBU和DBU分别包含多个RBs和DBs，而PU仅由单个池化层组成。理由是：</p>
<ol type="1">
<li>通过将多个RBs或DBs放入RBU或DBU，与逐个堆叠RBs或DBs相比，CNN的深度可以显著改变，这将通过轻松改变CNN的深度来加速所提出算法的启发式搜索；</li>
<li>一个由单个池层组成的PU比由多个池层组成的PU更灵活，因为多个后续池层的效果可以通过堆叠多个PU来实现。</li>
</ol>
<p>此外，为了便于算法实现，还添加了一个参数来表示单元类型。</p>
<hr />
<h4 id="编码策略">编码策略</h4>
<p>根据提出的三种构建的单元设计了编码策略。RBU的编码信息是类型、RBs的数量、输入空间大小和输出空间大小，它们分别表示为type, amount, in, and out。另一方面，除了附加参数k之外，DBU的编码信息与RBU的编码信息相同。PU中只需要一个参数来编码池化类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623182114.png"  style="zoom: 50%;" /></p>
<p>图3展示在编码包含九个单元的CNN时所提出的算法的示例。具体来说，块左上角的每个数字表示单元在CNN中的位置。如果类型分别为1、2或3，则单位为RBU、DBU或PU。注意，所提出的编码策略不限制每个个体的最大长度，这意味着可以通过所设计的可变长度编码策略自适应地找到具有适当深度的最佳CNN结构。</p>
<h3 id="fitness-evaluation">2. Fitness Evaluation</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623103614.png" style="zoom:40%;" /></p>
<p>首先，将个体解码成对应的CNN架构。初始化CNN的权重，然后进行训练。在验证集上评估其精度。将精度作为fitness值。</p>
<h3 id="offspring-generation">3. Offspring Generation</h3>
<h4 id="crossover-operation">Crossover Operation</h4>
<p>交叉操作一般是指GA的局部搜索能力。</p>
<p>正常来说应该选择一个种群中性能最好的个体。然而，采用最好的作为父代很容易导致种群多样性的丧失，进而导致过早收敛，因此，由于陷入局部极小值，无法实现种群的最佳性能。所以使用二元锦标赛选择算法。二元锦标赛选择从群体中随机选择两个个体，并选择一个具有较高fitness的个体作为一个父个体。通过再次重复此过程，选择另一个父个体，然后这两个父个体执行交叉操作。注意，在每个交叉操作之后生成两个后代，并且在每个epoch中生成N个后代，即，在每个epoch期间执行N/2次交叉操作，其中N表示种群大小。</p>
<blockquote>
<p>锦标赛选择（Tournament Selection）：每次从种群中取一定数量（n）的个体(放回抽样)，选择其中适应度较好的进入子代种群。重复该操作直到种群规模到和原来的种群规模一样。几元锦标赛就代表一次性从总体中抽取几个个体，然后从中选择最优的个体保留到下一代种群。</p>
</blockquote>
<p><strong>二元锦标赛选择算法选出两个个体，然后执行交叉操作。</strong>在传统的GAs中，交叉操作是在两个长度相同的个体上进行的。AE-CNN 算法中的个体具有不同的长度，即对应的CNN具有不同的深度。所以不能使用传统的交叉算子。于是采用了<u>单点交叉算子</u>。原因是单点交叉在GP中得到了广泛应用。GP是另一类重要的进化算法，GP中的个体具有不同的长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623182125.png" style="zoom:40%;" /></p>
<p>图4展示了一个交叉的例子，其中图4（a）展示了两个父代个体。假设这两个父个体的分离位置分别为第三和第四个单元，然后，图4（b）显示了相应的生成子个体，红色数字表示CNN的结构在交叉操作后所需的相应变化，包括单元的编号；输入输出维度的调整；因为<u>当前单元的输入应等于前一单元的输出</u>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623182211.png" style="zoom: 50%;" /></p>
<h4 id="mutation-operation">Mutation Operation</h4>
<p>变异操作通常在GAs中执行全局搜索。通过预定义的概率和允许的突变类型生成后代。根据提出的编码策略设计了可用的变异类型。在该算法中，可用的变异类型如下 ：</p>
<ol type="1">
<li>添加（添加RBU、添加DBU或向所选位置添加PU）</li>
<li>移除（在选定位置 remove unit）</li>
<li>修改（在所选位置修改unit的编码信息）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623164628.png" style="zoom:40%;" /></p>
<p>举一个“添加”的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623182403.png" style="zoom:50%;" /></p>
<h3 id="environmental-selection">4. Environmental Selection</h3>
<blockquote>
<p><strong>在环境选择中，将从当前种群中选择N大小的个体种群，作为下一代的父代个体。</strong>理论上，一个好的种群同时具有收敛性和多样性的特征，以防止陷入局部极小值和过早收敛。在实践中，父代个体应由最适合收敛的个体和适合度差异显著的个体组成。通过二元锦标赛算法选择的个体，作为父个体，为新群体产生后代。 选择最好的一个作为下一代的父代是GAs中“精英主义”机制的一种实现，这可以防止种群的性能随着进化的进展而下降。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623182240.png" style="zoom: 40%;" /></p>
<p>给定当前种群 <span class="math inline">\(P_t\)</span> 和生成的后代种群 <span class="math inline">\(Q_t\)</span>，首先用二元锦标赛选择来选择N个个体组成下一代 <span class="math inline">\(P_{t+1}\)</span>。</p>
<p>然后，从 <span class="math inline">\(P_t\)</span> 中选择最佳个体 <span class="math inline">\(p_{best}\)</span>，然后检查 <span class="math inline">\(p_{best}\)</span>是否已经在 <span class="math inline">\(P_{t+1}\)</span>。如果 <span class="math inline">\(P_{t+1}\)</span> 中不存在，就从<span class="math inline">\(P_{t+1}\)</span>中随机选择一个替换为最佳个体 <span class="math inline">\(p_{best}\)</span>。</p>
<blockquote>
<p>注意到 <span class="math inline">\(Q_t\)</span> 中的后代应该在环境选择之前评估其 fitness，因为二元锦标赛选择基于 fitness。</p>
</blockquote>
<div class="note note-info">
            <p>精英策略：即保留父代（上代），然后让父代和经过选择、交叉、变异后产生的子代共同组成一个群体，其目的就是为了防止父代中可能存在的最优解被遗落，最后经过再次选择操作，获得与初始种群同样规模的群落。</p>
          </div>
<h2 id="experiments">Experiments</h2>
<p>实验的模型主要分为三类：完全手工设计，半自动设计和自动设计。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220623182306.png" /></p>
<ul>
<li><p>AE-CNN的表现优于为手动设计的所有一流同行竞争对手。</p></li>
<li><p>半自动的设计：</p>
<ul>
<li>好于Genetic CNN；稍差于Hierarchical Evolution，但是只消耗了1/10GPUdays。</li>
<li>Block-QNN-S在CIFAR10上的性能稍差，但在CIFAR100上的性能略好于AE-CNN，而AE-CNN消耗的GPU天数是Block-QNN-S消耗的GPU天数的1/3，而且AE-CNN发现的最佳CNN的参数数量比Block-QNN-S少。</li>
<li>EAS和AE-CNN在CIFAR10上的分类错误几乎相同，而AE-CNN进化出的最佳CNN只有2.0M的参数，仅为EAS的1/11。</li>
</ul>
<p>总之，与半自动同行竞争对手相比，AE-CNN显示了竞争性能，但参数数量明显较少。</p></li>
<li><p>自动设计的模型中，在CIFAR10和CIFAR100数据集上，AE-CNN在分类错误、参数数量和GPU使用天数方面表现最佳。</p>
<ul>
<li>Large-scale Evolution 不应用交叉算子，交叉算子可以提供局部搜索能力。</li>
<li>CGP-CNN采用固定长度编码策略来设计最佳的CNN架构。为了使编码策略有效，CGP-CNN必须在架构设计期间预先定义CNN的最大长度。事实上，CGP-CNN的预定义最大长度小于AE-CNN确定的最佳长度。</li>
<li>基于强化学习设计了NAS和Meta-QNN。由于使用强化学习方法时不会计算fitness值，因此基于强化学习的方法通常比遗传算法消耗更多的计算资源，以获得相同的性能。预计，在可用计算资源的情况下，NAS和Meta-QNN的性能比AE-CNN差。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>AE-CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>【EvoCNN】Evolving Deep Convolutional Neural Networks for Image Classification</title>
    <url>/2022/06/27/%E3%80%90EvoCNN%E3%80%91/</url>
    <content><![CDATA[<p><strong>目前平台：正在调整算法的进程池。因为这个服务器内存不够，目前还跑不动，正在改进多进程的问题。</strong></p>
<p>针对算法目前设计好了算法的整个流程。xxx。服务器内存不够，目前还跑不动，正在改进。</p>
<ul>
<li>还调不通怎么办？</li>
</ul>
<p>还在想办法拍查，如果最后还是完整的跑不起来的话，那可能考虑用新框架重新写一个模型实现一下。因为这些模型的代码都比较老。</p>
<ul>
<li>在改什么？</li>
</ul>
<p>只能用这个服务器的话，思考怎么样让它跑起来。</p>
<ol type="1">
<li><p>改进化涉及的参数，比如长度设定太长了，或者输入通道数，输出通道数太大了，或者给的选择太多了。</p></li>
<li><p>设计了个体的生成方式。</p></li>
</ol>
<p>还有个问题，就是如果迁就着改了这些的话，可能就算法跑起来的话，这个精度就达不到原论文那么高。那么这个工作算是失败的工作吗？</p>
<ul>
<li>你都干嘛了？</li>
</ul>
<ol type="1">
<li><p>这个代码，因为代码的框架太老了，一直在报各种错，然后我就在改bug</p></li>
<li><p>后来发现有一些工具包不适配 导致服务器都进不去了 原因是因为那个服务器太老了 跟新装的工具包不兼容 服务器用不了。最后服务器恢复正常了。</p></li>
<li><p>驱动程序出现了问题。重新调整了一下。</p></li>
<li><p>能运行，但是跑一会就失败了，开始报错。</p>
<p>思考了一些解决办法。。。接上</p></li>
<li><p>多进程的进程池<em>的传参</em>有问题。目前正在改。</p></li>
</ol>
<hr />
<h1 id="evolving-deep-convolutional-neural-networks-for-image-classification">Evolving Deep Convolutional Neural Networks for Image Classification</h1>
<ul>
<li>IEEE 2019</li>
</ul>
<h2 id="basic-idea">Basic Idea</h2>
<ol type="1">
<li><p>设计了一种可变长度基因编码策略来表示CNN中不同的构建块和潜在的最佳深度。</p></li>
<li><p>研究连接权重编码策略，该策略能够高效地表示大量的连接权重。有效地优化CNN中的权值连接初始化问题。</p></li>
<li><p>设计相关的选择（包括环境选择）、Slack Binary Tournament Selection、交叉和变异操作符，这些操作符可以处理设计的架构和连接权重的基因编码策略。</p></li>
<li><p>对代表不同CNN的个体提出一个有效的适应度度量。</p></li>
</ol>
<h2 id="background">Background</h2>
<p>通过直接使用<strong>遗传算法</strong>进行CNN的架构设计，会出现几个问题：</p>
<ol type="1">
<li>评估一个个体的性能需要很长的时间，在基于种群的算法中，因为其中存在多个个体，将需要更多的时间和算力。</li>
<li>对于一个特定的问题，CNN的最佳深度是未知的，因此很难限制架构优化的搜索空间。在这方面，可变长度基因编码策略可能是最佳选择，但如何为不同的构建块分配交叉操作是一个新产生的问题。</li>
<li>权重初始化值严重影响结果体系结构的性能，但解决此问题需要良好的基因编码策略和成千上万决策变量的优化。</li>
</ol>
<hr />
<p>通常，初始化方法分为三个不同的类别：</p>
<ol type="1">
<li><p>第一种是使用常量来初始化所有连接权重，例如零初始值设定项、一个初始值设定项和其他固定值初始值设定项。</p>
<p>由于CNN中的连接权重众多，因此不必所有连接权重都以相同的值开始，这是第一类初始化方法的已知主要缺陷。</p></li>
<li><p>第二种是分布初始值设定项，例如使用高斯分布或均匀分布来初始化权重。</p>
<p>在第二种初始化方法中，解决了第一种设计的不足，但在选择分布参数方面存在主要困难，如均匀分布的范围、高斯分布的平均值以及标准推导。</p></li>
<li><p>第三种介绍了一些先验知识的初始化方法，著名的<strong>Xavier initializer</strong>设定项属于这一类。</p></li>
</ol>
<p>为了解决这个问题，Xavier初始值设定项在使用sigmoid激活函数之前，基于神经元饱和，提出了一个均匀采样范围。</p>
<p>仍然存在两个主要问题：</p>
<ol type="1">
<li>如果没有找到网络的最佳架构，则得到的初始化参数性能也很差。</li>
<li>Xavier初始化器介绍了sigmoid激活的用法，而CNN中广泛使用的激活函数是ReLU。据我们所知，尚未开发任何进化算法来搜索深度学习算法（包括CNN）的连接权重初始化。</li>
</ol>
<p>在该算法中，通过使用GA进化高斯分布的适当平均值和标准导数来实现这一目标。</p>
<h2 id="evocnn">EvoCNN</h2>
<h3 id="overview">Overview</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220627222313.png" style="zoom:45%;" /></p>
<ol type="1">
<li>用提出的编码策略初始化种群。</li>
<li>在未达到最大进化代数时：
<ol type="1">
<li>用提出的fitness值评估函数，评估个体</li>
<li>选择父代个体，用提出的 松弛的二进制锦标赛选择算法</li>
<li>用 设计的遗传算子生成新的子代</li>
<li>从现有个体和新产生的后代中选出代表，形成下一代群体</li>
</ol></li>
<li>选择最佳个体并解码到相应的CNN（第10行）进行最终训练</li>
</ol>
<h3 id="gene-encoding-strategy">Gene Encoding Strategy</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220712130157.png" style="zoom:50%;" /></p>
<p>图2中示出了三条长度不同于 EvoCNN 的染色体的示例，这三层中所有表示的信息在表I中。</p>
<p>编码的个体有三种类型的单元：卷积，池化，全连接。每种单元存放与之功能对应的一些参数，包括连接权重矩阵中的值。通常，一个卷积或全连接层中可能存在成千上万的连接权重，这些连接权重不能全部由染色体显式表示，也不能通过GA有效优化。因此，在 EvoCNN 中，仅使用两个实数统计指标<font color="red">（<strong>即连接权重的标准差和平均值</strong>）</font>来表示众多权重参数，这可以通过GA轻松实现。当收到最佳平均值和标准差时，从相应的高斯分布中采样连接权重。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220712130210.png" style="zoom: 50%;" /></p>
<h3 id="population-initialization">Population Initialization</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220627225941.png" style="zoom: 77%;" /></p>
<p>种群初始化将每条个体（染色体）分为两部分。第一部分初始化卷积层和池化层单元，第二部分是全连接层单元。第一部分从一个卷积层开始。第二部分只能添加在第一部分的末尾。</p>
<p>在第一部分的初始化过程中，首先添加卷积层。然后，由随机确定卷积层或池化层，然后将其添加到结尾，重复该操作直到达到该部分的预定义长度。第二部分，选择并添加全连接层。完成这两部分后，它们结合并作为一个个体返回。</p>
<hr />
<p>算法2中的初始化个体具有混合的长度？而不是之前多个工作所做的最小长度（<a href="https://stuxiaozhang.github.io/2022/07/12/%E3%80%90Large-Scale%20Evolution%E3%80%91Large-Scale%20Evolution%20of%20Image%20Classifiers/">来自 Large_Scale 这篇论文</a>）。这种设计背后的动机是：</p>
<ol type="1">
<li>由最小长度的个体表示的CNN无法处理大多数大型数据集，包括本文使用的基准数据集</li>
<li>将个体从最小长度进化到更长长度将需要不必要的时间；</li>
<li>作者设计的变异算子具有相应缩短个体长度的功能。</li>
</ol>
<hr />
<h3 id="fitness-evaluation">Fitness Evaluation</h3>
<p>Fitness Evaluation 旨在提供一个定量的衡量标准，确定哪些个体有资格作为父代。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220627225932.png"  style="zoom:80%;" /></p>
<p>Fitness Evaluation 分为两部分，第一部分是训练个体代表的CNN，第二部分是计算 fitness 值。</p>
<ol type="1">
<li>第一部分是训练个体代表的CNN：
<ol type="1">
<li>在训练期间，首先，根据个体的信息对每个CNN进行解码。</li>
<li>其次，通过使用在编码进个体的相应平均值和标准差，基于高斯分布<u>初始化关于卷积层和全连接层的权重。</u></li>
<li>使用训练集中的batch数据（第7-12行），对CNN进行训练。(在每个训练步骤中：
<ol type="1">
<li>根据当前权重和batch数据计算所用分类器的目标函数（第9行）</li>
<li>然后通过减去学习率和梯度的乘积来更新权重（第10行）。请注意，更新权重的过程遵循标准 batch SGD的例程，该例程通常用于训练深度神经网络。</li>
</ol></li>
</ol></li>
<li>第二部分是计算 fitness 值。
<ol type="1">
<li>分类误差是根据经过训练的权重和验证数据集中的批次数据计算的，即每个batch数据都有自己的分类误差</li>
<li><u>计算权重的参数量</u>。（根据奥卡姆剃刀原理，作为额外的衡量指标）</li>
<li><u>计算这些批次数据分类错误的平均值和标准差</u>（方差开平方）</li>
<li>这三个元素共同被视为个体的 fitness 值。</li>
</ol></li>
</ol>
<hr />
<p>个体的 fitness 值在评估中使用了三个指标，即均值、标准差和参数数量的原因：</p>
<ol type="1">
<li>看个体的性能的趋势就足够了。如果个体在CNN的前几个训练阶段表现更好，他们可能会在接下来的训练阶段表现更好，信心更大。</li>
<li>均值和标准差是统计显著性指标，因此适合看这种个体的性能的趋势，最终分类误差可以是仅用 提出的 EvoCNN 方法进化出的最佳个体来得到。</li>
</ol>
<h3 id="slack-binary-tournament-selection">Slack Binary Tournament Selection</h3>
<p>标准二进制锦标赛选择的松弛版本，用于为所提出的 EvoCNN 方法中，<strong>给交叉操作选择几个父代个体。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220712130243.png" style="zoom:60%;" /></p>
<p>作者采用Slack Binary Tournament Selection来选择下一代个体的双亲。适应度有三个方面：连接权重矩阵参数个数，分类的平均错误率和其标准差。选择的时候要兼顾。</p>
<p>在选择时首先考虑分类误差的平均错误率，如果两个个体的分类误差之差大于给定的阈值，那么就将分类误差较低的个体放入匹配池，否则考虑权值参数的数量，如果两个个体的权值参数的数量之差大于给定的阈值，那么就将参数数量较少的个体放入匹配池，最后考虑分类误差的标准差，优先选择标准差小的那个个体。</p>
<h3 id="offspring-generation">Offspring Generation</h3>
<p>在遗传算法中，子代由交叉和变异算子产生。交叉算子进行局部搜索，变异算子进行全局搜索。生成子代的步骤如下:</p>
<ol type="1">
<li>从匹配池中随机选择两个父代个体。</li>
<li>对选定的两个父代个体，使用交叉算子生成子代。</li>
<li>对生成的子代使用变异算子。</li>
<li>储存子代，从匹配池中取出父代个体，并执行步骤1-3，直到匹配池清空。</li>
</ol>
<h4 id="crossover">Crossover</h4>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220712130259.png" /></p>
<p>Crossover 的四个操作：</p>
<ol type="a">
<li><p>Unit Collection phase（UC）：在交叉的第一步，从每个个体收集卷积层、池化层和全连接层，并在每个个体（a）中以相同的顺序对它们进行堆叠，收集到三个不同的列表中。</p></li>
<li><p>Unit Alignment &amp; Crosserover phase（UA &amp; Crosserover）：在第二步中，从顶部开始对齐具有相同单元类型的单元列表。当这些单元列表完成对齐时，两个列表中相同位置的单元配对并执行交叉操作 Crosserover。</p></li>
<li><p>Unit Restore phase（UR）：最后，这些单元列表中的单元将根据它们来自（b）的原始位置进行恢复。</p></li>
</ol>
<p>经历过交叉操作的单元用斜体和下划线字体突出显示。对于由于没有配对而不执行交叉操作的其余单元，它们保持在相同的位置。</p>
<h4 id="mutation">Mutation</h4>
<p>突变操作可以在一个个体的每个单位位置上进行。对于选定的突变点，可以添加、删除或修改一个单元，每个单元都具有相同的概率。在单元添加的情况下，可以以1/3的相等概率添加卷积层、池化层或全连接层。如果变异是为了修改现有单元，则特定的修改取决于单元类型。所有编码信息在单元中会发生变化（表一中可以看到每种单元类型的编码信息）。请注意，所有编码的构成都用实数表示，采用了==模拟二进制交叉（SBX）和多项式变异。==</p>
<h3 id="environmental-selection">Environmental Selection</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220712130313.png" style="zoom:45%;" /></p>
<p>环境选择中，强调了精英主义和多样性。</p>
<p>首先选择一部分具有良好平均值的个体，然后改进的二元锦标赛选择来选择剩余个体。通过这两种策略，同时考虑了精英主义和多样性，这将共同提高 EvoCNN 方法的性能。</p>
<p>请注意，在锦标赛选择开始之前（算法5的第3行），选定的精英将被移除，而出于多样性目的而选定的个体将保留在当前群体中，以便根据社区惯例进行下一轮锦标赛选择（算法5的第4–8行）。</p>
<h3 id="best-individual-selection-and-decoding">Best Individual Selection and Decoding</h3>
<p>在进化结束时，多个个体可能具有有希望的平均值，但架构和连接权重初始化值不同。在这方面，将有多种选择来选择“最佳个体”。例如，如果我们只关心最佳性能，我们可以忽略它们的体系结构配置，只考虑分类精度。否则，如果我们强调参数数量较少，则可以做出相应的决策。一旦确定了最佳个体，将根据编码的架构和连接权重初始化信息对相应的CNN进行解码，然后SGD将使用更多的 epoches 对解码后的CNN进行深度训练，以备将来使用。</p>
<blockquote>
<p>注意，在将个体解码到相应的CNN期间，将ReLU非线性层添加到每个卷积层和完全连接层。</p>
</blockquote>
<h2 id="experiments">Experiments</h2>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220712130325.png" style="zoom: 43%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220712130337.png" /></p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>EvoCNN</tag>
      </tags>
  </entry>
  <entry>
    <title>【Genetic CNN】</title>
    <url>/2022/05/25/%E3%80%90Genetic%20CNN%E3%80%91/</url>
    <content><![CDATA[<h1 id="genetic-cnn">Genetic CNN</h1>
<ul>
<li>ICCV 2017</li>
</ul>
<p>Genetic CNN 将遗传算法用于神经网络架构搜索，论文首先提出了一种能表示神经网络架构的编码方案，在此编码方案上初始化种群，对种群进行选择、变异、交叉，从而抛弃性能差的神经网络架构并产生新的神经网络架构，论文将训练好的架构在验证集上的准确率作为评判网络性能好坏的指标。</p>
<h2 id="basic-idea">Basic Idea</h2>
<p>核心思想是提出一种编码方法，用固定长度的二进制字符串表示每个网络结构。通过生成一组随机个体来初始化遗传算法。在每一次生成中，定义标准的遗传操作，例如选择，变异和交叉，以产生有竞争能力的个体并消除弱势的个体。每个个体的（适应度函数）取决于参考数据集上的识别准确率。为此，对每个个体（即网络结构）执行独立于遗传算法的完整训练过程。在固定次数的迭代之后，遗传过程就结束了。</p>
<h2 id="background">Background</h2>
<p>传统的遗传算法往往具有下列步骤</p>
<ol type="1">
<li>定义个体的基因编码方案</li>
<li>初始化种群</li>
<li>衡量个体生存竞争能力的适应度（通常是一个函数，函数值表示个体的生存竞争能力）</li>
<li>淘汰适应度低的个体，选择适应度高的个体构成种群下一代的成员（选择）</li>
<li>按一定概率对下一代成员进行基因的交叉与变异（交叉与变异），产生新个体的基因编码方案</li>
<li>评估新种群的适应度</li>
</ol>
<p>可以看到，遗传算法其实就是模仿生物进化的过程。</p>
<h2 id="method">Method</h2>
<h3 id="二进制网络表示">二进制网络表示</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220422150322.png" /></p>
<p>许多常见的state-of-the-art神经网络架构都可以分为几个stage，两个stage之间通过池化操作连接，同个stage内的所有卷积操作都有相同的过滤器数目，基于上述观察，论文得出了神经网络架构的基因编码方案，具体如下：</p>
<ol type="1">
<li>每个神经网络架构由S个阶段构成，阶段与阶段之间通过池化操作连接</li>
<li>每个阶段stage都有 <span class="math inline">\(K_s\)</span> 个节点组成，这 <span class="math inline">\(K_s\)</span> 个节点其实是卷积 + BN + ReLU的操作，<span class="math inline">\(K_s\)</span> 个节点编号并由小到大顺序排序</li>
<li>使用有向边连接一个阶段中的节点，每个节点只能连接比自己编号要大的节点，用 <span class="math inline">\(v_{s,k_s}\)</span> 表示第 <span class="math inline">\(s\)</span> 阶段的第 <span class="math inline">\(k_s\)</span> 个节点，其中 <span class="math inline">\(k_s=1,2...,K_S\)</span></li>
</ol>
<p>为了使每个二进制字符串有效，在每个阶段定义两个默认节点。<strong>默认输入节点</strong>（表示为 <span class="math inline">\(v_{s,0}\)</span>）从上一阶段接收数据，执行卷积并将其输出发送到每个节点，而无需前置节点（例如 <span class="math inline">\(v_{s,1}\)</span>）。<strong>默认输出节点</strong>（表示为 <span class="math inline">\(v_{s,K_s+1}\)</span>）从所有节点接收数据并对其求和，然后进行卷积，然后将其输出发送到池化层，同样也没有后继节点，例如 <span class="math inline">\(v_{s,K_s}\)</span>。注意，普通节点和默认节点之间的连接未被编码。</p>
<p><strong>有两种特殊情况</strong>。首先，如果一个普通节点 <span class="math inline">\(v_{s,i}\)</span> 是孤立的（即它没有连接到任何其他普通节点 <span class="math inline">\(v_{s,j},i \ne j\)</span>），那么它将被简单地忽略，即它没有连接到默认输入节点 也没有默认输出节点（请参见图1中的B2节点）。这是为了确保具有更多节点的阶段可以模拟由具有较少节点的阶段表示的所有结构。其次，如果某个阶段没有连接，即二进制字符串中的所有位均为0，则卷积运算仅执行一次，而不是执行两次（一个由默认输入节点执行，另一个由默认输出节点执行） 。</p>
<p>使用所提出的编码方案可以表示许多流行的网络结构。示例包括 VGGNet，ResNet 和 DenseNet 的改进版本，如图2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424155115.png" style="zoom: 80%;" /></p>
<p>存在的局限性：</p>
<ul>
<li>当前，编码的结构仅涉及卷积和池化操作，无法生成某些棘手的网络模块，例如 Maxout。</li>
<li>卷积核的大小和通道的数量在每个阶段都是固定的，这限制了网络无法像初始模块一样合并多维度信息。</li>
</ul>
<h3 id="遗传操作">遗传操作</h3>
<p>遗传过程的流程图如算法1所示。该过程从具有N个随机个体的初始化种群开始。然后，执行T轮迭代代，每次迭代包括三个操作，即选择，突变和交叉。通过在参考数据集中进行从头训练来评估每个个体的性能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220422155522.png" /></p>
<h4 id="初始化种群">1 初始化种群</h4>
<p>初始化一个随机模型集合 <span class="math inline">\(\left\{\mathbb{M}_{0, n}\right\}_{n=1}^{N}\)</span>，每个模型是长度为L的二进制串，串上每位服从伯努利分布 <span class="math inline">\(b_{0,n}^l \sim \mathcal{B}(0.5), l=1,2,...,L\)</span>，然后训练并测试每个模型的准确率，这里<strong>不同的初始化策略不会对遗传性能产生太大影响</strong>。即使从最简单的初始化开始（所有个体都是零字符串），遗传过程仍可以通过交叉和突变发现相当有竞争性的结构。</p>
<h4 id="选择">2 选择</h4>
<p>在每一代种群生成前都会进行选择操作，在t-th代前，个体 <span class="math inline">\(\mathbb{M}_{t-1,n}\)</span> 的适应性为 <span class="math inline">\(r_{t-1,n}\)</span>，直接影响 <span class="math inline">\(\mathbb{M}_{t-1,n}\)</span> 在选择阶段存活的概率。具体选择使用俄罗斯轮盘选择法(Russian roulette)，每个个体选取的概率与 <span class="math inline">\(r_{t-1,n}-r_{t-1,0}\)</span> 成比例，<span class="math inline">\(r_{t-1,0}\)</span> 为上一代的最低适应性。选择后的保持种群总数不变，所以一个个体可能会被选择多次</p>
<h4 id="变异和交叉">3 变异和交叉</h4>
<p>单个 <span class="math inline">\(\mathbb M_{t,n}\)</span> 的变异的操作包含对二进制串每个位进行概率为 <span class="math inline">\(q_M\)</span> 的反转。在实验中，<span class="math inline">\(q_M\)</span> 通常很小，例如0.05，因此变异不太可能使一个个体改变太多。这是为了保留一个个体的良好信息，同时提供尝试新可能性的机会。</p>
<p>交叉过程涉及同时更改两个个体，每对阶段以很小的概率 <span class="math inline">\(q_C\)</span> 交换。<strong>交叉中的基本单元是一个阶段stage，而不是单独考虑每个位</strong>，这是由于需要将局部结构保留在每个阶段内。</p>
<h4 id="评价">4 评价</h4>
<p>在上述过程之后，对每个单独的 <span class="math inline">\(\mathbb M_{t,n}\)</span> 进行训练和测试来获得适应度函数值。如果先前对 <span class="math inline">\(\mathbb M_{t,n}\)</span> 进行过评估，只需再次对其进行评估，然后求所有发生次数的平均。这样减轻了训练过程中随机性引起的不稳定性。</p>
<h2 id="experiments">Experiments</h2>
<h3 id="mnist">MNIST</h3>
<ol type="1">
<li><p>通过遗传操作，可以找到具有竞争力的网络结构，达到较高的精度。虽然在很短的时间内，最佳个体的识别率没有提高，但平均和中等准确率通常会随着代代而提高。这是非常重要的，因为它保证了遗传算法提高了个体的整体素质。</p></li>
<li>实验验证了：一个更好的个体更有可能通过变异或交叉产生一个好的个体。</li>
<li><p>做了对比试验不同初始化网络的影响。验证了不同的初始化策略不会对遗传性能产生太大影响。</p></li>
</ol>
<h3 id="cifar10">CIFAR10</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424151857.png" /></p>
<p>图5绘制了从两个单独的遗传过程中学习到的网络结构。通过遗传算法学习的结构与人工设计的结构有很大不同，尽管观察到一些人工设计的局部结构，如链状网络、多径网络和公路网络。我们强调这两个网络是通过独立的遗传过程获得的，这表明我们的遗传过程通常会收敛到类似的网络结构。</p>
<h3 id="svhn">SVHN</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220424155207.png" style="zoom: 80%;" /></p>
<p>可以看到虽然GeNet（17层）的识别错误率较高，但是可以看到中使用的结构(后4个)都很深......由于密集连接通常不是最佳选择，作者认为可以使用遗传算法来优化网络中使用的连接 。</p>
<h2 id="summary">Summary</h2>
<p>本文将遗传算法应用于神经网络的结构设计。首先提出了一种编码方法，用固定长度的二进制字符串来表示每个网络结构，然后使用一些遗传操作，如变异和交叉，来有效地探索搜索空间（基本相当于只搜索节点间的连接方式=_=）。不同的初始化策略对遗传过程影响不大。使用一个相对较小的参考数据集（CIFAR10）进行遗传算法，发现生成的结构可以很好地转移到其他任务，包括大规模的ILSVRC2012数据集。</p>
<p>这样的编码形式可以编码目前的主流分类结构，但也有很多局限性：</p>
<ul>
<li>目前的连接方式只有卷积和池化，不能使用其它比较tricky的模块，例如Maxout。</li>
<li>每个阶段的卷积核是固定的，阻碍了multi-scale特征的融合。</li>
</ul>
<p>所以说最大的问题就是能生成这样类似的网络结构，但是参数是定死的，这样子就会失去它的灵活性，搜索出的网络结构比较局限。</p>
<p>在目前的工作中，遗传算法仅用于探索网络结构，而网络训练过程是单独进行的。未来工作可以将遗传算法结合起来同时训练网络结构和权重。</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>Genetic CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>【CNN-GA】Automatically Designing CNN Architectures Using Genetic Algorithm for Image  Classification</title>
    <url>/2022/06/08/%E3%80%90CNN-GA%E3%80%91/</url>
    <content><![CDATA[<h1 id="cnn-gaautomatically-designing-cnn-architectures-using-genetic-algorithm-for-image-classification">CNN-GA：Automatically Designing CNN Architectures Using Genetic Algorithm for Image Classification</h1>
<p>Genetic CNN 的问题：</p>
<ol type="1">
<li><strong>阶段的数量是手动预定义的</strong>。从这种编码策略中可以清楚地看到，<u>需要多次手动干预</u>，例如每个阶段和总阶段中构建块的数量。由于这些数字与发现的CNN的深度有关，因此需要预定义这些参数，以获得CNN的适当深度。</li>
<li><strong>每个阶段的构建块参数都不能改变</strong>。这种编码策略只能在发现给定CNN的连接时进行查看，不能改变给定CNN的深度。</li>
</ol>
<h2 id="basic-idea">Basic Idea</h2>
<ol type="1">
<li><p>提出了一种<strong>变长编码策略和相应的变长交叉算子</strong>。</p></li>
<li><p><strong>引入了跳跃连接</strong>（The skip connection）增加CNN的深度，从而提高CNN的表现，避免梯度消失问题。此外，这种设计还可以减少搜索空间，以便在有限的时间内获得最佳性能。此外，与其他性能相似的模型相比，该算法所改进的体系结构具有更少的参数。</p></li>
<li><p>完全自动化，不需要人工干预的CNN架构。</p></li>
<li><p>设计一个异步计算组件来加速计算，一个cache组件来缩短适应度评估时间。</p></li>
</ol>
<h2 id="background">Background</h2>
<p>现有的CNN架构设计算法可分为两类。首先是“自动+手动调整”CNN架构设计，这意味着仍然需要基于设计CNN架构的专业知识进行手动调整。这一类别包括</p>
<ul>
<li><a href="https://stuxiaozhang.github.io/2022/04/26/Genetic%20CNN/">Genetic CNN</a></li>
<li>层次表示方法（Hierarchical Evolution）</li>
<li>高效架构搜索方法（EAS）</li>
<li>块设计方法（block-QNN-S）</li>
<li>高级神经架构搜索方法（NSANet）</li>
</ul>
<p>另一种是“自动”CNN架构设计，使用时不需要用户手动调整。</p>
<ul>
<li>大规模进化方法（Large-scale Evolution）</li>
<li><a href="https://stuxiaozhang.github.io/2022/04/28/%E3%80%90CGP-CNN%E3%80%91A%20Genetic%20Programming%20Approach%20to%20Designing%20Convolutional%20Neural%20Network%20%20Architectures/">CGP-CNN</a></li>
<li>神经架构搜索方法（NAS）</li>
<li>元建模方法（MetaQNN）</li>
</ul>
<p>根据所采用的技术，CNN架构设计也可以分为基于进化算法的架构设计和基于强化学习的架构设计。</p>
<ul>
<li><p>基于进化算法：Genetic CNN, Large-scale Evolution, Hierarchical Evolution and CGP-CNN</p></li>
<li><p>基于强化学习：NAS、MetaQNN、EAS、Block-QNN-S 和 NSANet</p></li>
</ul>
<h3 id="genetic-cnn">Genetic CNN</h3>
<p>编码CNN的整个结构由多个阶段组成。在每个阶段，对一个小型架构进行编码，然后将多个不同的小型架构堆叠起来，形成整个架构。就像NSANet方法一样，为Genetic CNN提供了一个CNN架构框架，而小架构取代了所提供框架中的卷积层，形成了最终的CNN。在每个阶段中，CNN的多个预定义构建块被排序，并且它们的连接被编码。对于这些构建块的排序，第一个和最后一个构建块是手动指定的，其余的都是具有相同设置的卷积层。为了对这些有序构建块之间的连接进行编码，使用了<strong>二进制字符串编码方法</strong>。 假设有四个构建块，字符串“111-10-0”表示第一个构建块与所有其他构建块都有连接。第二个与第四个构建块没有连接，第四个构建块与第三个构建块相同。</p>
<p>Genetic CNN 的问题：</p>
<ol type="1">
<li><strong>阶段的数量是手动预定义的</strong>。从这种编码策略中可以清楚地看到，<u>需要多次手动干预</u>，例如每个阶段和总阶段中构建块的数量。由于这些数字与发现的CNN的深度有关，因此需要预定义这些参数，以获得CNN的适当深度。</li>
<li><strong>每个阶段的构建块参数都不能改变</strong>。这种编码策略只能在发现给定CNN的连接时进行查看，不能改变给定CNN的深度。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220608111012.png" /></p>
<h2 id="cnn-ga">CNN-GA</h2>
<h3 id="算法框架">算法框架</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220608114053.png" style="zoom: 80%;" /></p>
<ol type="1">
<li>在进化过程中，用作者提出的变长编码策略对预定义的构建块进行编码，使用预定义的总体大小随机初始化总体。</li>
<li>进化代数初始化为零</li>
<li>开始循环：在计数器未超过预定义的最大生成数之前：
<ol type="1">
<li>在进化过程中，在给定的数据集上评估编码CNN特定架构的每个个体的fitness，使用提出的加速组件。</li>
<li>根据父代个体的 fitness 选择，然后通过包括交叉和变异算子在内的遗传算子生成新的后代。</li>
<li>然后，通过<u>环境选择</u>从当前种群中选择存活到下一代的个体种群。具体而言，当前种群由父种群和后代种群组成。</li>
<li>计数器增加1，并继续进化。</li>
</ol></li>
<li>最终选出最好的 fitness 的个体</li>
</ol>
<h3 id="种群初始化">1. 种群初始化</h3>
<p>作者提出了跳跃层，跳跃层由两个卷积层和一个跳跃连接组成。跳跃连接从第一卷积层的输入连接到第二卷积层的输出。如上所述，卷积层的参数是特征映射数、滤波器大小、步长和卷积运算类型。在所提出的编码策略中，我们分别对滤波器大小、步幅大小和卷积运算使用相同的设置。特别地，滤波器和步幅大小分别设置为3×3和1×1，并且仅使用相同的卷积运算。为此，为跳跃层编码的参数是两个卷积层（分别表示为 F1 和 F2）的特征映射的数目。此外，对于filter大小和步幅大小，该编码策略中使用的池化层设置为2×2。为此，为池化层编码的参数仅为池化类型（表示为 P1）。</p>
<p>算法2显示了种群初始化的详细信息：流程是T个个体用相同的方法初始化，然后存储到 <span class="math inline">\(P_0\)</span> 中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220608114105.png" /></p>
<ol type="1">
<li>开始循环：在未超过预定义的之前：
<ol type="1">
<li>在个体初始化过程中，首先随机初始化个体的长度 L，表示相应CNN的深度。</li>
<li>然后，==创建一个包含L个节点的链表==。
<ol type="1">
<li>之后，配置每个节点：
<ol type="1">
<li>从 (0, 1) 随机生成一个数字 r。</li>
<li>如果 r&lt;0.5，节点类型设置为1，表示为<strong>跳跃层</strong>。在跳跃连接层的情况下，随机生成特征图的编号，然后将其分配给node.F1和node.F2。</li>
<li>否则，节点类型设置为2，表示为<strong>池化层</strong>。池化类型随机决定：随机生成一个q，当q概率低于0.5时，P1设为最大池化，否则设为平均池化。</li>
</ol></li>
<li>将链表存储到 <span class="math inline">\(P_0\)</span> 中。</li>
</ol></li>
</ol></li>
</ol>
<p>举个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220608114119.png" /></p>
<p>该CNN由四个跳跃层和两个池化层组成。表示一个跳跃层的代码是同一跳跃层内相应卷积层的特征图尺寸；而池化层的是表示池化类型的数字：（0，0.5）之间的随机数表示最大池化，而 [0.5，1）之间的随机数表示平均池化。表示整个CNN的代码是表示层的代码的顺序字符串连接。如本例所示，其中每个层的代码都列在其上方，整个CNN的代码为“32-64-0.2-64-256-0.8-512-256-256-512”，表示深度为10的CNN。</p>
<p>在一个跳跃层中使用两个卷积层，丢弃完全连接层的原因：</p>
<ol type="1">
<li><strong>全连接层容易导致过拟合现象</strong>。为了减少过拟合现象，通常使用dropout随机移除部分连接。但是，每个dropout都会引入一个参数。只有正确指定参数才能使相应的CNN具有良好的性能。同时，全连接层的数量和每个全连接层中的神经元数量也是两个难以调整的参数。</li>
<li>如果将全连接层合并到所提出的编码策略中，搜索空间将大大扩大，从而增加找到最佳CNN架构的难度。</li>
</ol>
<h3 id="种群-p_t-中评估个体的-fitness-的流程">2. 种群 <span class="math inline">\(P_t\)</span> 中评估个体的 fitness 的流程</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220608114131.png" style="zoom: 80%;" /></p>
<p>给定包含所有用于评估 fitness 的个体的总体 <span class="math inline">\(P_t\)</span>，以及CNN的最佳架构要在其上发现的图像分类数据集</p>
<p>适应度函数算法以相同的方式评估 <span class="math inline">\(P_t\)</span> 的每个个体，最后返回包含已评估 fitness 的个体的 <span class="math inline">\(P_t\)</span>。</p>
<ol type="1">
<li><p>如果针对初始化的总体即 <span class="math inline">\(P_0\)</span> 进行可行性评估，则会创建一个<u>==全局变量 Cache==，存储不可见体系结构的个体的fitness。</u></p></li>
<li><p>对于 <span class="math inline">\(P_t\)</span> 中的每个个体（由个体表示），如果在 Cache 中 找到个体，则直接从 Cache 中获取其适应度。否则，对个体进行适应性评估。</p>
<blockquote>
<p>从缓存中查询个体是基于个体的标识符的。理论上，可以使用任意标识符，只要它们能够区分编码不同体系结构的个体。在所提出的算法中，224哈希码被用作相应的标识符，该哈希码已由大多数编程语言在编码体系结构方面实现。</p>
</blockquote>
<p>此外，个体被异步放置在可用的GPU上，这意味着不需要等待下一个个体的适应性评估，直到当前个体的适应性评估完成，而是立即将下一个个体放置在可用的GPU上。</p></li>
</ol>
<h3 id="个体的-fitness-评估">个体的 fitness 评估</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220608114143.png" style="zoom:80%;" /></p>
<ol type="1">
<li>首先，对单个CNN进行解码，并基于给定的图像分类数据集向CNN（第1行）添加分类器。 解码CNN时，将 RELU 和 BN 添加到卷积层的输出中。此外，当跳跃层的空间编号不同于输入数据的空间编号时，将卷积层添加到输入数据中，卷积层具有单位filter和单位stride，但具有特征图的特殊编号。然后，在训练数据上使用随机梯度下降（SGD）算法对CNN进行训练，并在评估数据上计算分类精度（第5行）。</li>
<li>当训练阶段结束时，对评估数据的最佳分类精度设置为个体的fitness。</li>
<li>最后，将个体的标识符和fitness关联并放入缓存。</li>
</ol>
<blockquote>
<p>设计这种异步和缓存组件的原因。综上所述，由于CNN上的训练非常耗时，根据特定的体系结构，训练时间从几个小时到几个月不等，因此在所提出的算法中，CNN的设计目的是为了加速安全性评估。具体来说，异步组件是基于GPU的并行计算平台。由于计算梯度的计算性质，深度学习算法通常放置在GPU上以加速训练。事实上，现有的深度学习库 支持在多个GPU上进行计算。然而，他们的并行计算是基于数据并行和模型并行管道。在数据并行管道中，输入数据分为7个小组，每组放在一个GPU上进行计算。原因是一个GPU有限的内存不能同时有效地处理整个数据。在模型并行管道中，一个模型被划分为几个小模型，每个GPU携带一个小模型。原因是一个GPU上有限的计算能力无法运行整个模型。然而，设计的平行管道显然不属于这两条管道中的任何一条，而是基于它们的更高级别。因此，设计这样一个异步组件是为了充分利用GPU计算资源，特别是对于基于种群的算法。此外，如果问题可以划分为几个独立的子问题，则异步组件广泛用于解决大型问题。通过在不同的计算平台上并行执行这些子问题，从而缩短了整个问题的总处理时间。</p>
<p>缓存组件还用于加速可靠性评估，这基于以下考虑：</p>
</blockquote>
<ol type="1">
<li>存活到下一代的个体，如果其架构没有改变，则无需再次评估可靠性</li>
<li>已评估的架构可以通过另一代中的变异和交叉操作重新生成。注意，大规模进化的权重继承不能用于第二个考虑。</li>
</ol>
<p>通常，缓存系统应该认真对待其大小，并提供详细信息来讨论由重复密钥导致的冲突问题。在所提出的算法中，无需进行任何研究。首先，缓存组件类似于地图数据结构，其中该组件中的每个记录都是一个字符串，它将CNN的标识符和适应度值组合在一起。例如，“identifier1=98.12”等记录表示标识符为“identifier1”，其适应值为“98.12”。其次，正如我们所强调的，标识符由224个哈希代码计算，该哈希代码可以生成2224个不同的标识符。在实践中，包括所提出的算法在内的CNN体系结构算法仅评估数千个CNN。显然，我们不需要考虑冲突问题，因为冲突问题不会发生。第三，用于该算法的224哈希码实现将生成长度为32的标识符，而thefitness值是由长度为4的字符串表示的分类精度。缓存组件中的每条记录都是一个长度为37的字符串，使用UTF-8文件编码占据37个字节。显然，即使有数千条记录，缓存文件也只会占用很少的磁盘空间。因此，我们不需要关心缓存组件的大小。</p>
<h3 id="生成子代">3. 生成子代</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220608114159.png" /></p>
<p>生成子代主要的遗传操作是交叉和突变：</p>
<ol start="0" type="1">
<li><p>随机生成一个 <span class="math inline">\(r\)</span>，根据 <span class="math inline">\(r\)</span> 的大小选择操作</p></li>
<li><p>交叉操作：将生成全部 <span class="math inline">\(|P_t|\)</span> 子代。首先选择两个父母，然后选择两个父母中fitness值更高的那个。这种选择被称为 Binary Tournament Selection(二进制锦标赛选择算法)。然后生成一个随机数 <span class="math inline">\(p_c\)</span> 确定是否进行交叉。如果执行交叉操作，将每个父代个体随机分成两部分，并将父代个体的两部分交换以形成两个后代。否则，将这两个父代个体直接作为后代。</p></li>
<li><p>变异操作：生成一个随机数 <span class="math inline">\(p_m\)</span> 确定是否进行变异。突变个体时，从当前个体中随机选择一个位置 <span class="math inline">\(i\)</span>，并根据 选择不同变异操作的概率 <span class="math inline">\(p_l\)</span> 从突变列表 <span class="math inline">\(l_m\)</span> 中选择一个特定的突变操作 <span class="math inline">\(m\)</span>。 然后，在位置 <span class="math inline">\(i\)</span> 上执行 <span class="math inline">\(m\)</span>。在突变列表 <span class="math inline">\(l_m\)</span> 中定义的可用变异操作有：</p>
<ol type="1">
<li>添加带有随机设置的跳跃层；</li>
<li><p>添加具有随机设置的池化层；</p></li>
<li><p>移除选定位置的层；</p></li>
<li><p>在选定位置随机更改构建块的参数值。</p></li>
</ol></li>
</ol>
<blockquote>
<p>Tournament Selection</p>
<p>由于算法执行的效率以及易实现的的特点，锦标赛选择算法是遗传算法中最流⾏的选择策略。在本⼈的实际应⽤中的确此策略⽐基本的轮盘赌效果要好些。他的策略也很直观，就是我们再整个种群中抽取n个个体，让他们进⾏竞争(锦标赛)，抽取其中的最优的个体。参加锦标赛的个体个数成为tournament size。通常当n=2便是最常使⽤的⼤⼩，也称作Binary Tournament Selection.</p>
</blockquote>
<h4 id="交叉算子-变异算子">交叉算子 &amp; 变异算子</h4>
<ol type="1">
<li><p>传统的单点交叉仅为长度相等的个体设计。<strong>设计的交叉算子用于长度不等的个体</strong>。虽然设计的交叉算子很简单，但它可以提高发现CNN结构的性能，实验已证明。</p></li>
<li><p>其次，现有算法使用相同的概率来选择特定的变异操作。在该算法中，<strong>所提供的变异操作以不同的概率进行选择</strong>。具体而言，为1. “添加跳跃层”突变提供了更高的概率，这将有更高的概率增加CNN的深度。对于其他变异操作，仍然使用相同的概率。这种设计的动机是，<u>更深的CNN将拥有更强大的功能</u>。虽然“添加池层”也能够增加CNN的深度，但通过使用一个池化层，输入数据的维数将减少到一半，从而导致发现的CNN不可用。</p></li>
</ol>
<p>我认为总的来说，就是：提供不同的概率选择不同的变异操作集成了一个变异算子。</p>
<h3 id="环境选择">4. 环境选择</h3>
<p>环境选择就是在本代种群中选出个体组成下一代种群。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220608114211.png" style="zoom: 80%;" /></p>
<ol type="1">
<li>首先从当前种群中，通过binary tournament selection选2个个体，选出其中更好的一个fitness更好的存入下一代。</li>
<li>其次，从父代和子代中选出最佳的个体，检查它是否存入下一代 <span class="math inline">\(P_{t + 1}\)</span> ，如果没存就用最佳的个体取代下一代其中的最差的那个。</li>
</ol>
<p>原则上，只为下一代选择最佳个体很容易导致算法陷入局部最优。如果不明确地为下一代选择最佳个体，算法将不会收敛。<u>原则上，理想的种群不仅应该包含好的种群，还应该包含相对较差的种群，以增强多样性</u>。为此，二进制锦标赛选择通常用于此目的。然而，仅使用二进制锦标赛选择可能会错过最佳个体，导致算法没有朝着更好的方向进化。因此，我们明确地将最佳个体添加到下一个种群中，这是进化算法中一种特殊的精英策略</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>CNN-GA</tag>
      </tags>
  </entry>
  <entry>
    <title>SpingMVC笔记</title>
    <url>/2022/07/02/SpingMVC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="springmvc笔记">SpringMVC笔记</h1>
<h1 id="一介绍">一、介绍</h1>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711192028.png" /></p>
<h2 id="什么是springmvc">1、什么是SpringMVC</h2>
<p>SpringMVC是基于Spring的MVC开发模式的一个框架，实际上就是spring的一个模块，专门是做web开发的，理解为servlet的升级。web开发底层是servlet，框架是在servlet基础上面加入一些功能，让开发更方便。</p>
<h3 id="什么是mvc">什么是MVC？</h3>
<p>它是一种开发模式，它是模型视图控制器的简称。所有的web应用都是基于MVC开发。</p>
<ul>
<li><p>M：模型层，包含实体类，业务逻辑层，数据访问层</p></li>
<li><p>V：视图层，html，javaScript，vue等都是视图层，用来显现数据</p></li>
<li><p>C：控制器，它是用来接收客户端的请求，并返回响应到客户端的组件，Servlet就是组件</p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711192904.png" /></p>
<h3 id="spring和springmvc对比">Spring和SpringMVC对比</h3>
<ul>
<li><p>Spring：Spring是容器，ioc能够管理对象， 使用 <code>&lt; bean&gt;</code>，<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code> 标签</p></li>
<li><p>SpringMVC：能够创建对象，放入到容器中（springmvc容器），spring容器中放的是控制器对象</p></li>
</ul>
<h3 id="springmvc简要流程">SpringMVC简要流程</h3>
<p>我们要做的是 <strong>使用 <span class="citation" data-cites="Controller">@Controller</span> 创建控制器对象</strong> ，把对象放入到 SpringMVC容器中，把创建的对象作为控制器使用。这个控制器对象能够接收用户的请求，显示处理结果，就当作是一个servlet使用。</p>
<p><strong>使用 <span class="citation" data-cites="Controller">@Controller</span> 注解创建的是一个普通的对象</strong> ，不是servlet，SpringMVC 赋予了控制器对象一些额外的功能。</p>
<blockquote>
<p>控制器对象他是一个被 SpringMVC 作为控制器, 功能和servlet一样的普通类对象。</p>
</blockquote>
<p>web开发底层是servlet，SpringMVC 中有一个对象是servlet：DispatcherServlet（中央调度器）</p>
<p>DispatcherServlet：负责接收用户的所有请求，用户把请求给了DispatcherServlet，之后DispatcherServlet把请求转发给我们的Controller对象，最后Controller对象处理请求。</p>
<h2 id="开发步骤">2、开发步骤</h2>
<p>index.jsp —&gt; DispatcherServlet（中央调度器，类似servlet） ----&gt; 转发，分配给Controller对象（<span class="citation" data-cites="Controller">@Controller</span> 注解创建的对象）</p>
<p><strong>需求</strong>：用户在页面发起一个请求，请求交给springmvc的控制器对象，并显示请求的处理结果</p>
<p><strong>实现步骤：</strong></p>
<ol type="1">
<li><p>新建web maven工程</p></li>
<li><p>加入依赖，spring-webmvc依赖，间接把spring的依赖加入到项目中，jsp，servlet依赖</p></li>
<li><p>重点：在web.xml中注册springmvc框架的核心对象 DispatcherServlet</p>
<ol type="1">
<li>DispatcherServlet叫做：中央调度器，是一个servlet，他的父类继承 HttpServlet</li>
<li>DispatcherServlet也叫做：前端控制器（from controller）</li>
<li>DispatcherServlet：负责接收用户提交的请求，调用其他控制器对象，并把请求的处理结果显示给用户</li>
</ol></li>
<li><p>创建一个发起请求的页面 index.jsp</p></li>
<li><p>创建控制器(处理器)类</p>
<ol type="1">
<li><p>在类的上面加入@Controller注解，创建对象，并放到springmvc容器中</p>
<ol start="2" type="1">
<li>在类中的方法上面加入@RequestMapping注解</li>
</ol></li>
</ol></li>
<li>创建一个作为结果的jsp，显示请求的处理结果。</li>
<li>创建springmvc的配置文件（和spring的配置文件一样）
<ol type="1">
<li>声明组件扫描器，指定@Controller注解所在的包名</li>
<li>声明视图解析器，帮助处理视图</li>
</ol></li>
</ol>
<p>启动Tomcat后，Tomcat扫描xml文件创建DispatcherServlet，DispatcherServlet在初始化的时候会加载mvc配置文件，创建springmvc容器，controller对象在容器中。*.do方法由中央调度器拿过来根据名字从springmvc容器中找到跟RequestMapping（values）对应的名称调用他的方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711192935.png" /></p>
<h3 id="springmvc-开发流程">springmvc 开发流程：</h3>
<ul>
<li>发起some.do请求</li>
<li>tomcat ( <code>web.xml</code> 从 url-pattern 知道 <code>*.do</code> 的请求给 DispatcherServlet)</li>
<li>DispatcherServlet（根据 <code>springmvc.xml</code> 配置知道 <code>some.do</code>，<code>doSome()</code> 方法）</li>
<li>DispatcherServlet把 <code>some.do</code> 转发给 <code>MyController.doSome()</code> 方法</li>
<li>框架执行 <code>doSome()</code> 把得到的 <code>ModelAndView</code> 进行处理，转发到show.jsp</li>
</ul>
<p>发送some.do请求的页面 index.jsp</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>第一个springmvc项目<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;some.do&quot;</span>&gt;</span>发起some.do请求<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>核心配置文件 web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--声明：注册springmvc的核心对象DispatcherServlet</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        需要在tomcat服务器启动后，创建DispatcherServlet对象实例</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        为什么要创建DispatcherServlet对象的实例呢？</span><br><span class="hljs-comment">        	因为在DispatcherServlet创建过程中，会同时创建springmvc容器对象，</span><br><span class="hljs-comment">        	读取springmvc的配置文件，把这个配置文件中的对象都配置好，</span><br><span class="hljs-comment">        	当用户发起请求时就可以直接使用对象了。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        servlet的初始化会执行init()方法，DispatcherServlet在init()中&#123;</span><br><span class="hljs-comment">            //创建容器，读取配置文件</span><br><span class="hljs-comment">            webApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;springmvc.xml&quot;);</span><br><span class="hljs-comment">            //把容器对象放入到ServletContext中</span><br><span class="hljs-comment">            getServletContext().setAttribute(key,ctx);</span><br><span class="hljs-comment">         &#125;</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--自定义springmvc读取文件的位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--springmvc配置文件的位置属性--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--指定自定义文件的位置--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--表示在tomcat启动后，创建servlet对象</span><br><span class="hljs-comment">            数字表示启动后创建对象的顺序，数值越小，tomcat创建对象越早，要求大于等于0的整数</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">                使用框架的时候，url-pattern可以使用两种值</span><br><span class="hljs-comment">                1.使用扩展名方式，语法 *.xxxx , xxxx时自定义扩展名。常用的方式 *.do, *.action, *.mvc等等</span><br><span class="hljs-comment">                    http://localhost:8080/myweb/some.do</span><br><span class="hljs-comment">                    http://localhost:8080?myweb/other.do</span><br><span class="hljs-comment">                2.使用斜杠&quot;/&quot;</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>tomcat启动，创建DispatcherServlet对象，同时创建springmvc容器对象，读取springmvc配置文件， 这里配置文件的根地址 classpath = springmvc.xml</p>
<p>在 springmvc.xml中声明 <strong>组件扫描器</strong> 和 <strong>视图解析器</strong></p>
<p><em>springmvc.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context </span></span><br><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--声明组件扫描器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.zh.controller&quot;</span>/&gt;</span><br>    <br>     <span class="hljs-comment">&lt;!--声明 springmvc框架中的视图解析器，帮助开发人员设置视图文件的路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前缀：视图文件位置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/view/&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后缀：视图文件的扩展名--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>创建控制器类 <em>MyController.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zh.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @Controller：创建处理器对象，对象放在springmvc容器中</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 能处理请求的都是控制器（处理器）：MyController能处理请求，</span><br><span class="hljs-comment">*                               叫做后端控制器（back controller）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 处理用户提交的请求，springmvc中是使用方法来处理的。</span><br><span class="hljs-comment">    * 方法是自定义的，可以有多种返回值，多种参数，方法名称自定义</span><br><span class="hljs-comment">    * */</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 准备使用doSome方法处理some.do请求。</span><br><span class="hljs-comment">    * @RequestMapping：请求映射，作用是把一个请求地址和一个方法绑定在一起。</span><br><span class="hljs-comment">    *                  一个请求指定一个方法处理。</span><br><span class="hljs-comment">    *             属性：1. value是一个String类型，表示请求的uri地址（这里是：some.do）</span><br><span class="hljs-comment">    *                     value值是唯一的，不能重复</span><br><span class="hljs-comment">    *             说明：使用@RequestMapping修饰的方法叫做处理器方法或者控制器方法</span><br><span class="hljs-comment">    *                   可以处理请求，类似servlet中的doGet,doPost</span><br><span class="hljs-comment">    * */</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 返回值 ModelAndView 表示本次请求的处理结果</span><br><span class="hljs-comment">    *   model:数据，请求处理完后，要显示给用户的数据</span><br><span class="hljs-comment">    *   view：视图，比如jsp等</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doSome</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//处理some.do请求，相当于service调用处理完成了</span><br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        <span class="hljs-comment">//添加数据，框架在请求的最后把数据放入到request作用域</span><br>        <span class="hljs-comment">//request.setAttribute(&quot;msg&quot;,&quot;欢迎使用....&quot;);</span><br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;欢迎使用springmvc做web开发&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;fun&quot;</span>,<span class="hljs-string">&quot;执行的是doSome方法&quot;</span>);<br><br>        <span class="hljs-comment">//指定视图，指定视图的完整路径</span><br>        <span class="hljs-comment">//框架对视图执行的forward操作，request.getRequestDispather(&quot;/show.jsp&quot;).forward(...)</span><br>        mv.setViewName(<span class="hljs-string">&quot;/show.jsp&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">//在springmvc.xml配置视图解析器后，修改 setViewName()</span><br>    <span class="hljs-meta">@RequestMapping(value = &#123;&quot;/other.do&quot;,&quot;/second.do&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doOther</span><span class="hljs-params">()</span></span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;---------欢迎使用springmvc做web开发----------&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;fun&quot;</span>,<span class="hljs-string">&quot;执行的是doOther方法&quot;</span>);<br>        <br>        <span class="hljs-comment">//当配置了视图解析器后，可以使用逻辑名称（文件名），指定视图</span><br>        <span class="hljs-comment">//框架会使用视图解析器的 前缀 + 逻辑名称 +后缀 组成完整路径</span><br>        mv.setViewName(<span class="hljs-string">&quot;other&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对应的 <em>show.jsp</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>show.jsp从request作用域获取数据<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>msg数据:$&#123;msg&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>fun数据:$&#123;fun&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="spirngmvc执行流程">SpirngMVC执行流程</h2>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711192949.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplication(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br>StudentService service = (StudentService)ctx.getBean(<span class="hljs-string">&quot;service&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>SpringMVC内部请求的处理流程：也就是SpringMVC接收请求，到处理完成的过程</p>
<ol type="1">
<li><p>用户发起请求 some.do</p></li>
<li><p>DispatcherServlet 接收请求 some.do，把请求转交给处理器映射器</p>
<ul>
<li><p>处理器映射器：SpringMVC框架中的一种对象，框架把实现了 HandlerMapping 接口的类都叫做映射器（多个）</p></li>
<li>处理器映射器的作用：根据请求，从SpringMVC容器对象中获取处理器对象 <code>MyController controller = ctx.getBean(&quot;some.do&quot;)</code>。框架把找到的处理器对象放到一个叫做处理器执行链 <code>HandlerExecutionChain</code> 的类保存。</li>
<li><code>HandlerExecutionChain</code>：
<ol type="1">
<li>处理器对象 <code>MyController</code></li>
<li>项目中的所有的拦截器 <code>List&lt;HandlerInterceptor&gt; inerceptorList</code></li>
</ol></li>
</ul></li>
<li><p>DispatcherServlet 把2中的 <code>HandlerExecutionChain</code> 中的处理器对象交给了处理器适配器对象（多个）</p>
<ul>
<li>处理器适配器：SpringMVC框架中的对象，需要实现 <code>HandlerAdapter</code> 接口。</li>
<li>处理器适配器的作用：执行处理器方法（调用 <code>MyController.doSome()</code> 得到返回值 <code>ModelAndView</code> ）</li>
</ul></li>
<li><p>DispatcherServlet 把3中的 <code>ModelAndView</code> 交给了视图解析器对象。</p>
<ul>
<li><p>视图解析器：SpringMVC框架中的对象，需要实现 <code>ViewResolver</code> 接口（可以有多个）</p></li>
<li><p>视图解析器的作用：组成视图完整路径，使用前缀，后缀。并创建View对象。</p>
<p>View是一个接口，表示视图的，在框架中jsp，html不是string表示，而是使用View和他的实现类表示视图。</p>
<p><code>InternalResourceView</code>：视图类，表示jsp文件，视图解析器会创建 <code>InternalResourceView</code> 类对象。这个对象的里面，有一个属性 <code>url=/WEB-INF/view/show.jsp</code></p></li>
</ul></li>
<li><p>DispatcherServlet 把4中的创建的View对象获取到，调用View类自己的方法，把Model数据放入到 request 作用域。执行对象视图的 forward。请求结束。</p></li>
</ol>
<h1 id="二springmvc注解式开发">二、SpringMVC注解式开发</h1>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193110.png" /></p>
<h2 id="requestmapping-定义请求规则">1、<span class="citation" data-cites="RequestMapping">@RequestMapping</span> 定义请求规则</h2>
<h3 id="value属性指定模块名称">value属性：指定模块名称</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @RequestMapping</span><br><span class="hljs-comment">* 	value:所有请求的公共部分，叫做模块名称</span><br><span class="hljs-comment">*   位置：在类的上面</span><br><span class="hljs-comment">* */</span><br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-comment">//或者@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doSome</span><span class="hljs-params">()</span></span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;欢迎使用springmvc做web开发&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;fun&quot;</span>,<span class="hljs-string">&quot;执行的是doSome方法&quot;</span>);<br>        mv.setViewName(<span class="hljs-string">&quot;show&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>理解为在该方法在 user或者test模块下</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193135.png" style="zoom: 33%;" /></p>
<h3 id="method属性指定请求方式">method属性：指定请求方式</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * @RequestMapping(value = &quot;&quot;,method = )</span><br><span class="hljs-comment">    * 	属性：method 表示请求的方式，它的值是RequestMethod类枚举值</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * 	get请求方式， method = RequestMethod.GET</span><br><span class="hljs-comment">    * 	post请求方式，method = RequestMethod.POST</span><br><span class="hljs-comment">    * </span><br><span class="hljs-comment">    * */</span><br><br>    <span class="hljs-comment">//指定some.do用get请求获取</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doSome</span><span class="hljs-params">()</span></span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;欢迎使用springmvc做web开发&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;fun&quot;</span>,<span class="hljs-string">&quot;执行的是doSome方法&quot;</span>);<br>        mv.setViewName(<span class="hljs-string">&quot;show&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br><br>    <span class="hljs-comment">//指定other.do 用post请求获取</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/other.do&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doOther</span><span class="hljs-params">()</span></span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;---------欢迎使用springmvc做web开发----------&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;fun&quot;</span>,<span class="hljs-string">&quot;执行的是doOther方法&quot;</span>);<br>        mv.setViewName(<span class="hljs-string">&quot;other&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;p&gt;第一个springmvc项目&lt;/p&gt;<br>    &lt;p&gt;&lt;a href=&quot;test/some.do&quot;&gt;发起some.do的get请求&lt;/a&gt;&lt;/p&gt;<br><br>    &lt;form action=<span class="hljs-string">&quot;test/other.do&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>        &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;post请求other.do&quot;</span>&gt;<br>    &lt;/form&gt;<br>    <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
<h2 id="处理器方法的参数">2、处理器方法的参数</h2>
<p>处理器方法可以包含以下四类参数，这些参数会在系统调用时由系统自动赋值，即程序员可以在方法中直接使用。</p>
<ol type="1">
<li>HttpServletRequest 请求</li>
<li>HttpServletResponse 应答</li>
<li>HttpSession 会话</li>
<li>请求中所携带的请求参数</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193257.png" /></p>
<h3 id="前三类参数使用方式">1. 前三类参数使用方式</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/other.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doOther</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                               HttpServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">                               HttpSession session)</span> </span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;====欢迎使用springmvc开发===：&quot;</span> + request.getParameter(<span class="hljs-string">&quot;name&quot;</span>));<br>        mv.addObject(<span class="hljs-string">&quot;fun&quot;</span>, <span class="hljs-string">&quot;执行的是doOther方法&quot;</span>);<br>        mv.setViewName(<span class="hljs-string">&quot;other&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193316.png" /></p>
<h3 id="逐个参数接收">2. 逐个参数接收</h3>
<p>接收用户提交的参数：<strong>处理器（控制器）方法的形参名和请求中的参数必须一致</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 逐个接收请求参数：</span><br><span class="hljs-comment">    *   要求：处理器（控制器）方法的形参名和请求中的参数必须一致</span><br><span class="hljs-comment">    *         同名的请求参数赋值给同名的参数</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * 框架接收请求参数：</span><br><span class="hljs-comment">    * 1 使用request对象接收请求参数</span><br><span class="hljs-comment">    *   String strName = request.getParameter(&quot;name&quot;);</span><br><span class="hljs-comment">    *   String strAge = request.getParameter(&quot;age&quot;);</span><br><span class="hljs-comment">    * 2 springmvc框架通过dispatcherServlet 调用MyController的doSome方法</span><br><span class="hljs-comment">    *   调用方法时，按名称对应，把接收的参数赋值给形参 doSome(strName,Integer.valueOf(strAge))</span><br><span class="hljs-comment">    *   框架会提供类型转换的功能，把String转换为 int ，long ，float ，double等</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doSome</span><span class="hljs-params">(String name,Integer age)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dosome方法的，name=&quot;</span>+name+<span class="hljs-string">&quot;, age=&quot;</span>+age);<br><br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;myname&quot;</span>,name);<br>        mv.addObject(<span class="hljs-string">&quot;myage&quot;</span>,age);<br>        mv.setViewName(<span class="hljs-string">&quot;show&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;p&gt;提交参数给Controller&lt;/p&gt;<br><br>&lt;form action=<span class="hljs-string">&quot;some.do&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    姓名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;br/&gt;<br>    年龄：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交参数&quot;</span>&gt;<br>&lt;/form&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
<h3 id="请求参数中文乱码问题">3. 请求参数中文乱码问题</h3>
<p>注意：在提交请求参数的时候，get请求方式中文没有乱码；<strong>post请求方式中文有乱码</strong>，需要使用<strong>过滤器 CharacterEncodingFilter</strong> 处理乱码问题。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">//在web.xml配置过滤器<br><span class="hljs-comment">&lt;!--注册声明过滤器，解决post请求乱码的问题--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--设置项目中使用的字符编码--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--强制请求对象（HttpServletRequest）使用encoding编码的值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceRequestEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--强制应答对象（HttpServletResponse）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    /*  : 表示强制所有的请求先通过过滤器处理</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/rl-pattern&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>补充：springMVC 中的 M-model，V-view，C-controller</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193324.png" style="zoom: 50%;" /></p>
<h3 id="校正请求参数名requestparam">4. 校正请求参数名@RequestParam</h3>
<p><strong>请求参数名和处理器方法的形参名不一样，使用 <span class="citation" data-cites="RequestParam">@RequestParam</span> 注解</strong>（在处理方法参数前）</p>
<p>首页 index.jsp 的参数名是 iname 和 iage</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;p&gt;请求参数名和处理器方法的形参名不一样&lt;/p&gt;<br>&lt;form action=<span class="hljs-string">&quot;receiveparam.do&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    姓名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;iname&quot;</span>&gt;&lt;br/&gt;<br>    年龄：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;iage&quot;</span>&gt;&lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交参数&quot;</span>&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure>
<p>控制器方法的 doOther 方法形参为 name 和 age</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 请求参数名和处理器方法的形参名不一样</span><br><span class="hljs-comment">* @RequestParam：定义在处理器方法的形参前面</span><br><span class="hljs-comment">*   属性：1. value，请求参数名，可省略</span><br><span class="hljs-comment">*        2. required，是一个Boolean类型，默认为true，表示必须包含参数</span><br><span class="hljs-comment">* */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/receiveparam.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doOther</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;iname&quot;)</span> String name,</span></span><br><span class="hljs-function"><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(&quot;iage&quot;)</span> Integer age)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;doOther方法的，name=&quot;</span>+name+<span class="hljs-string">&quot;, age=&quot;</span>+age);<br><br>    ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>    mv.addObject(<span class="hljs-string">&quot;myname&quot;</span>,name);<br>    mv.addObject(<span class="hljs-string">&quot;myage&quot;</span>,age);<br>    mv.setViewName(<span class="hljs-string">&quot;show&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时将@RequestParam标签的属性required改为 fslse，不用参数也可以显示show.jsp。 当然我们希望required=true，作为前端限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doOther</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;iname&quot;,required = false)</span> String name,</span></span><br><span class="hljs-function"><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(value = &quot;iage&quot;,required = false)</span> Integer age)</span></span>&#123;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193510.png" /></p>
<h3 id="对象参数接收">5. 对象参数接收</h3>
<p>将处理器方法的参数定义为一个对象，<strong>对象的属性名要求和请求中参数名一致</strong></p>
<p>先在vo包下定义一个Student 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bjpowernode.vo;<br><br><span class="hljs-comment">//保存请求参数值的普通类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-comment">//属性值要和请求参数值一样</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;---------Student的无参构造方法--------&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;setName:&quot;</span> + name);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge:&quot;</span>+age);<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主页index.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;p&gt;使用java对象接收参数&lt;/p&gt;<br>&lt;form action=<span class="hljs-string">&quot;object.do&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    姓名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;br/&gt;<br>    年龄：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交参数&quot;</span>&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure>
<p>处理器方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/object.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">receiveParam</span><span class="hljs-params">(Student std)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;receiveParam, name=&quot;</span> + std.getName() + <span class="hljs-string">&quot; age=&quot;</span> + std.getAge());<br>    ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>    mv.addObject(<span class="hljs-string">&quot;myname&quot;</span>, std.getName());<br>    mv.addObject(<span class="hljs-string">&quot;myage&quot;</span>, std.getAge());<br>    mv.addObject(<span class="hljs-string">&quot;mystudent&quot;</span>, std);<br><br>    mv.setViewName(<span class="hljs-string">&quot;show&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193621.png" /></p>
<p>后台结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193629.png" /></p>
<h2 id="处理器方法的返回值">3、处理器方法的返回值</h2>
<p>使用@Controller注解的处理器的处理器方法，其返回值常用的有4种类型：</p>
<ol type="1">
<li>ModelAndView</li>
<li>String</li>
<li>void</li>
<li>自定义类型对象</li>
</ol>
<p>根据不同的情况，使用不同的返回值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193635.png" /></p>
<h3 id="返回modelandview">1. 返回ModelAndView</h3>
<p>若处理器方法处理完后，需要跳转到其他资源，且又要在跳转的资源间传递数据，此时处理器方法返回 ModelAndView 比较好。当然，若要返回 ModelAndView，则处理器方法中需要定义 ModelAndView对象。</p>
<p>在使用时，若该处理器方法只是进行跳转而不传递数据，或只是传递数据而不向任何资源跳转（如对页面的Ajax异步响应），此时若返回ModelAndView，则将总是有一部分多余，要么Model多余，要么View多余。即此时返回将不合适。</p>
<h3 id="返回string">2. 返回String</h3>
<p>String返回值可以表示逻辑视图名称或完整视图路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 处理器方法返回String,表示逻辑视图名称，需要配置视图解析</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/returnString-view.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doReturnView</span><span class="hljs-params">(HttpServletRequest request,String name, Integer age)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dosome方法的，name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age);<br><br>        <span class="hljs-comment">//手动添加数据到request作用域</span><br>        request.setAttribute(<span class="hljs-string">&quot;myname&quot;</span>,name);<br>        request.setAttribute(<span class="hljs-string">&quot;myage&quot;</span>,age);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * show：逻辑视图名称</span><br><span class="hljs-comment">        * 框架对视图执行forward转发操作</span><br><span class="hljs-comment">        * */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;show&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//处理器方法返回 String，表示完整视图路径，此时不能配置视图解析器</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/returnString-view2.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doReturnView2</span><span class="hljs-params">(HttpServletRequest request,String name, Integer age)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;---doReturnView2方法---，name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age);<br><br>        <span class="hljs-comment">//手动添加数据到request作用域</span><br>        request.setAttribute(<span class="hljs-string">&quot;myname&quot;</span>,name);<br>        request.setAttribute(<span class="hljs-string">&quot;myage&quot;</span>,age);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 完整视图路径，项目中不能配置视图解析器</span><br><span class="hljs-comment">         * 框架对视图执行forward转发操作</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;WEB-INF/view/show.jsp&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我整理：</p>
<ol type="1">
<li><p>要么声明视图解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--前缀：视图文件的路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/view/&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--后缀：视图文件的扩展名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>然后控制器方法就可以写：<code>return &quot;show&quot;;</code></p></li>
<li><p>要么写完整路径即可。（无需视图解析器）直接：<code>return &quot;WEB-INF/view/show.jsp&quot;;</code></p></li>
</ol>
<h3 id="返回void">3. 返回void</h3>
<p>void：不能表示数据，也不能表示视图。</p>
<p>对于处理器方法返回 void 的应用场景，AJAX 响应.</p>
<p>若处理器对请求处理后，无需跳转到其它任何资源，此时可以让处理器方法返回 void。通过HttpServletResponse输出数据响应ajax请求。<strong>ajax请求服务器端返回的就是数据，和视图无关。</strong></p>
<p>Step1：maven 加入 jackson 依赖 由于本项目中服务端向浏览器传回的是 JSON 数据，需要使用一个工具类将字符串包装为 JSON 格式，所以需要导入 JSON 的依赖。</p>
<p>Step2：引入 jQuery 库 由于本项目要使用 jQuery 的 ajax()方法提交 AJAX 请求，所以项目中需要引入 jQuery 的库。在 WebRoot 下新建一个 Folder（文件夹），命名为 js，并将 jquery-3.4.1.js 文件放入其中。</p>
<p>当然，该 jQuery 库文件，需要在使用 ajax()方法的 index 页面中引入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;js/jquery-3.4.1.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure>
<p>Step3：定义 index 页面 index 页面由两部分内容构成：一个是<code>&lt;button/&gt;</code>，用于提交 AJAX 请求；一个是<code>&lt;script/&gt;</code>，用于处理 AJAX 请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//alert(&quot;button click&quot;);</span><br>        $.ajax(&#123;<br>            <span class="hljs-comment">//url:&quot;returnVoid-ajax.do&quot;,</span><br>            <span class="hljs-comment">//url:&quot;returnStudentJsonArray.do&quot;,</span><br>            url:<span class="hljs-string">&quot;returnStringData.do&quot;</span>,<br>            data:&#123;<br>                name:<span class="hljs-string">&quot;zhangsan&quot;</span>,<br>                age:<span class="hljs-number">20</span><br>            &#125;,<br>            type:<span class="hljs-string">&quot;post&quot;</span>,<br>            dataType:<span class="hljs-string">&quot;text&quot;</span>,<br>            <span class="hljs-comment">//dataType:&quot;json&quot;,</span><br>            success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)</span>&#123;<br>                <span class="hljs-comment">//resp从服务器端返回的是json格式的字符串 &#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:20&#125;</span><br>                <span class="hljs-comment">//jquery会把字符串转为json对象， 赋值给resp形参。</span><br><br>                <span class="hljs-comment">// [&#123;&quot;name&quot;:&quot;李四同学&quot;,&quot;age&quot;:20&#125;,&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:28&#125;]</span><br>                <span class="hljs-comment">//alert(resp.name + &quot;    &quot;+resp.age);</span><br><br>                <span class="hljs-comment">/*$.each(resp,function(i,n)&#123;</span><br><span class="hljs-comment">                             alert(n.name+&quot;   &quot;+n.age)</span><br><span class="hljs-comment">                         &#125;)*/</span><br>                alert(<span class="hljs-string">&quot;返回的是文本数据：&quot;</span>+resp);<br><br>            &#125;<br>        &#125;)<br>    &#125;)<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
<p>点击按钮发起请求</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;button id=&quot;btn&quot;&gt;发起ajax请求&lt;/button&gt;<br></code></pre></td></tr></table></figure>
<p>Step4: 定义对象 Student</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-comment">// 属性名和请求中参数名一样</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br></code></pre></td></tr></table></figure>
<p>Step5：修改处理器类 MyController 处理器对于 AJAX 请求中所提交的参数，可以使用逐个接收的方式，也可以以对象的方式整体接收。只要保证 AJAX 请求参数与接收的对象类型属性同名。 以逐个方式接收参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//处理器方法返回void， 响应ajax请求</span><br><span class="hljs-comment">//手工实现ajax，json数据： 代码有重复的 1. java对象转为json； 2. 通过HttpServletResponse输出json数据</span><br><br><span class="hljs-meta">@RequestMapping(value = &quot;/returnVoid-ajax.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReturnVoidAjax</span><span class="hljs-params">(HttpServletResponse response, String name, Integer age)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;===doReturnVoidAjax====, name=&quot;</span> + name + <span class="hljs-string">&quot;   age=&quot;</span> + age);<br>    <span class="hljs-comment">//处理ajax， 使用json做数据的格式</span><br>    <span class="hljs-comment">//service调用完成了， 使用Student表示处理结果</span><br>    Student student  = <span class="hljs-keyword">new</span> Student();<br>    student.setName(<span class="hljs-string">&quot;张飞同学&quot;</span>);<br>    student.setAge(<span class="hljs-number">28</span>);<br><br>    String json = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//把结果的对象转为json格式的数据</span><br>    <span class="hljs-keyword">if</span>(student != <span class="hljs-keyword">null</span>)&#123;<br>        ObjectMapper om  = <span class="hljs-keyword">new</span> ObjectMapper();<br>        json  = om.writeValueAsString(student);<br>        System.out.println(<span class="hljs-string">&quot;student转换的json====&quot;</span>+json);<br>    &#125;<br><br>    <span class="hljs-comment">//输出数据，响应ajax的请求</span><br>    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>    PrintWriter pw  = response.getWriter();<br>    pw.println(json);<br>    pw.flush();<br>    pw.close();<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="返回object">4. 返回Object</h3>
<p>处理器方法也可以返回 Object 对象。这个 Object 可以是 Integer，String，自定义对象，Map，List 等。对象有属性，属性就是数据。所以返回Object表示数据，和视图无关。即，返回的对象不是作为逻辑视图出现的，而是作为直接在页面显示的<strong>数据</strong>出现的。</p>
<p>返回对象，需要使用 <span class="citation" data-cites="ResponseBody">@ResponseBody</span> 注解，将转换后的 JSON 数据放入到响应体中。</p>
<p>现在做 ajax，主要使用 json的数据格式。 <strong>面试：springmvc开发中，返回值是object类型，如何转换为 json ？实现步骤</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">1	加入处理json的工具库的依赖，springmvc默认使用的jackson<br><br>	pom.xml 加入jackson依赖<br><br>	<span class="hljs-comment">&lt;!--jackson依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>2	在springmvc配置文件之间加入 <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span> 注解驱动<br>    <br>    主配置文件 springmvc.xml 加入：<br>    <br>    <span class="hljs-comment">&lt;!--@ResponseBody注解驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br>    <br>3	在处理器方法的上面加上 @ResponseBody<br></code></pre></td></tr></table></figure>
<p><strong>1）返回值是object类型，转换为 json</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span>	在处理器方法的上面加上 <span class="hljs-meta">@ResponseBody</span><br>    <br>控制器方法 MyController.java<br><br><span class="hljs-comment">//处理器方法返回一个Student，通过框架转为json，响应ajax请求</span><br><span class="hljs-comment">//@ResponseBody 作用：把处理器方法返回对象转为json后，通过HttpServletResponse输出给浏览器</span><br><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@RequestMapping(value = &quot;returnStudentJson.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">doStudentJsonObject</span><span class="hljs-params">(String name,Integer age)</span></span>&#123;<br><br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    student.setName(<span class="hljs-string">&quot;lisi&quot;</span>);<br>    student.setAge(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> student;  <span class="hljs-comment">// 会被框架转为json</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2）当返回值是多个参数（用的比较普遍），返回类型改为List集合，其他不变</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value =&quot;returnStudentJsonArray.do&quot; )</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">doStudentJsonObjectArray</span><span class="hljs-params">(String name,Integer age)</span></span>&#123;<br><br>    List&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    student.setName(<span class="hljs-string">&quot;wangwu&quot;</span>);<br>    student.setAge(<span class="hljs-number">22</span>);<br>    list.add(student);<br><br>    student = <span class="hljs-keyword">new</span> Student();<br>    student.setName(<span class="hljs-string">&quot;tianmao&quot;</span>);<br>    student.setAge(<span class="hljs-number">10</span>);<br>    list.add(student);<br><br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前端页面 index.jsp ，返回 json 格式为：<code>[&#123;“name”:“wangwu”,“age”:22&#125;,&#123;“name”:“tianmao”,“age”:10&#125;]</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;<br>    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>        $(function () &#123;<br>            $(<span class="hljs-string">&quot;button&quot;</span>).click(function () &#123;<br>                <span class="hljs-comment">// alert(&quot;button click&quot;);</span><br>               $.ajax(&#123;<br>                   <span class="hljs-comment">// url:&quot;returnVoid-ajax.do&quot;,</span><br>                   <span class="hljs-comment">// url:&quot;returnStudentJson.do&quot;,</span><br>                   url:<span class="hljs-string">&quot;returnStudentJsonArray.do&quot;</span>,<br>                   <br>                   data:&#123;<br>                       name:<span class="hljs-string">&quot;zhangsan&quot;</span>,<br>                       age:<span class="hljs-number">20</span><br>                   &#125;,<br>                   type:<span class="hljs-string">&quot;post&quot;</span>,<br>                   dataType:<span class="hljs-string">&quot;json&quot;</span>,<br>                   success:function(resp) &#123;<br><br>                       <span class="hljs-comment">// alert(resp.name+&quot;   &quot;+resp.age);</span><br><br>                       <span class="hljs-comment">//[&#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;tianmao&quot;,&quot;age&quot;:10&#125;]</span><br>                       $.each(resp,function (i,n) &#123;<br>                            alert(n.name+<span class="hljs-string">&quot;  &quot;</span>+n.age);<br>                       &#125;)<br>                   &#125;<br>               &#125;)<br>            &#125;)<br>        &#125;)<br>    &lt;/script&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure>
<p><strong>3）处理器方法返回的是 String，表示数据</strong>，不是视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 处理器方法返回的是String，String表示数据的，不是视图。</span><br><span class="hljs-comment">* 区分返回值类型String是数据，还是视图，看看有没有@ResponseBody注解</span><br><span class="hljs-comment">* 如果有@ResponseBody注解，返回String就是数据，反之就是视图</span><br><span class="hljs-comment">* */</span><br><br><span class="hljs-meta">@RequestMapping(value = &quot;/returnStringData.do&quot;, produces = &quot;text/palin;charset=utf-8&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doStringData</span><span class="hljs-params">(String name,Integer age)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回对象，表示数据&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：如果有@ResponseBody注解，返回String就是数据。在ajax请求中，此时不是json，要改成：<code>dataType:&quot;text&quot;</code>。</p>
<p>然后，中文会出现乱码问题，解决方法：加上produce：<code>@RequestMapping(value = &quot;/returnStringData.do&quot;, produces = &quot;text/palin;charset=utf-8&quot;)</code></p>
<hr />
<p><strong>springmvc 处理器方法返回 object，可以转为 json输出到浏览器，响应 ajax 的内部原理</strong>（步骤）：</p>
<ol type="1">
<li><p><code>&lt;mvc:annotation-driven&gt;</code> 注解驱动 注解驱动实现的功能是：完成java对象到 json，xml，test，二进制等数据格式的转换 HttpMessageConverter接口：消息转换器 功能：定义了java转json，xml等数据格式的方法。这个接口有很多实现类。这些实现类完成了java对象到json，Java对象到xml，Java对象到二进制数据的转换</p></li>
<li><code>HttpMessageConverter</code>接口的两个方法是：控制器类把结果输出给浏览器时使用的 <code>boolean canWrite(Class&lt;?&gt; var1, @Nullable MediaType var2);</code> <code>void write(T var1, @Nullable MediaType var2, HttpOutputMessage var3)</code>
<ol type="1">
<li>canWrite：检查处理器方法返回值，能不能转为var2的数据格式</li>
<li>write：把处理器方法的返回值对象，调用jackson中的ObjectMapper转为json字符串</li>
</ol></li>
<li><p><code>@ResponseBody</code> 注解 放在处理器方法的上面，通过HttpServletResponse输出结果，响应ajax请求</p></li>
</ol>
<h2 id="解读-url-pattern">4、解读 <code>&lt;url-pattern/&gt;</code></h2>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193656.png" /></p>
<h3 id="配置详解">1. 配置详解</h3>
<p><strong><em>.do</em></strong></p>
<p>在没有特殊要求的情况下，springmvc 的中央调度器 DispatcherServlet 的 <code>&lt; url-pattern/ &gt;</code> 常使用后缀匹配方式，如写为 <code>*.do</code> 或者 <code>*.action</code> ， <code>*.mvc</code> 等</p>
<p><strong>/</strong></p>
<p>可以写为 / ，因为DispatcherServlet会将向静态资源的获取请求，例如 .css .js .jpg .png 等资源的获取请求，作为是一个普通的Controller请求。中央调度器会调用处理器映射器为其查找相应的处理器。当然也是找不到的，所以在这种情况下，所有的静态资源获取请求也均会报404错误。</p>
<hr />
<p>发起的请求是由哪些服务器处理的：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http: <span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/05_url_pattern/i</span>ndex.jsp		tomcat<br>http: <span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/05_url_pattern/im</span>ages/<span class="hljs-number">1</span>.jpg	  tomcat<br>http: <span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/05_url_pattern/</span>html/test.html	tomcat<br>http: <span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/05_url_pattern/</span>some.<span class="hljs-keyword">do</span>	springmvc框架（DispatcherServlet）<br></code></pre></td></tr></table></figure>
<p>tomcat本身能处理静态资源的访问，像html，图片，js文件等都是静态资源</p>
<p>tomcat的web.xml文件有一个 servlet 名称为 default，在服务器启动时创建。如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>listings<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>	// &quot;/&quot; 表示静态资源和未映射的请求都给这个default处理<br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>这个名叫 default 的 servlet 作用：</p>
<ol type="1">
<li>处理静态资源</li>
<li>处理未映射到其它servlet的请求</li>
</ol>
<p><strong>使用 ” / “ 后，无法访问静态资源，可以访问动态资源</strong></p>
<ul>
<li><p>当你的项目使用了 / ，它会替换 tomcat 中的 default。导致所有的静态资源都给DispatcherServlet处理，<u>默认情况下DispatcherServlet没有处理静态资源的能力</u>。没有控制器对象能处理静态资源的访问，所以静态资源（html，js，图片，css）都是404</p></li>
<li><p>动态资源some.do可以访问，原因是我们程序中有MyController控制器对象，能处理some.do请求</p></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">// web.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   		使用框架的时候，url-pattern可以使用两种方式</span><br><span class="hljs-comment">    1.使用扩展名方式，语法 *.xxxx , xxxx时自定义扩展名。常用的方式 *.do, *.action, *.mvc等等</span><br><span class="hljs-comment">        http://localhost:8080/myweb/some.do</span><br><span class="hljs-comment">        http://localhost:8080?myweb/other.do</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    2.使用斜杠 &quot;/&quot;</span><br><span class="hljs-comment">        当你的项目使用了 / ，它会替换 tomcat 中的 default.</span><br><span class="hljs-comment">        导致所有的静态资源都给DispatcherServlet处理，默认情况下DispatcherServlet没有处理静态资源的能力,</span><br><span class="hljs-comment">        没有控制器对象能处理静态资源的访问,所以静态资源（html，js，图片，css）都是404</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        动态资源some.do可以访问，原因是我们程序中有MyController控制器对象，能处理some.do请求</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="静态资源访问">2. 静态资源访问</h3>
<h4 id="使用-mvcdefault-servlet-handler-和-mvcannotation-driven">1）使用 <code>&lt;mvc:default-servlet-handler/&gt;</code> 和 <code>&lt; mvc:annotation-driven/ &gt;</code></h4>
<p>声 明 了 <code>&lt;mvc:default-servlet-handler /&gt;</code> 后 ， springmvc 框 架 会 在 容 器 中 创 建DefaultServletHttpRequestHandler 处理器对象。它会像一个检查员，对进入 DispatcherServlet的 URL 进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的Servlet 处理。一般的服务器都有默认的 Servlet。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">// springmvc.xml<br><br><span class="hljs-comment">&lt;!--@ResponseBody注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--第一种处理静态资源的方式：&lt;mvc:default-servlet-handler/&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    需要在springmvc配置文件加入 &lt;mvc:default-servlet-handler&gt;</span><br><span class="hljs-comment">    原理是：加入这个标签后，框架会创建控制器对象（类似自己创建的MyController）,</span><br><span class="hljs-comment">    这个对象可以把接收到的请求转发给tomcat的名字叫default的servlet</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="使用-mvcresources-需要掌握">2）使用 <code>&lt; mvc:resources /&gt;</code> 需要掌握</h4>
<p>在 Spring3.0 版本后，Spring 定义了专门用于处理静态资源访问请求的处理器 ResourceHttpRequestHandler。并且添加了<code>&lt;mvc:resources/&gt;</code>标签，专门用于解决静态资源无法访问问题。需要在 springmvc 配置文件中添加如下形式的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/images/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/images/&quot;</span></span><br></code></pre></td></tr></table></figure>
<ul>
<li>mapping 表 示 对 该 资 源 的 请 求 （ 以 /images/ 开 始 的 请 求 ， 如 /image/beauty.jpg , /images/car.png 等）。注意，后面是两个星号**。而且，前后两个斜杠不能缺。</li>
<li>location 表示静态资源所在目录。当然，目录不要使用/WEB-INF/及其子目录。</li>
</ul>
<blockquote>
<p>uri的格式：“ /网站名/资源文件名 ”</p>
</blockquote>
<h4 id="声明注解驱动">3）声明注解驱动</h4>
<p><code>&lt;mvc:resources /&gt;</code> 和 <code>@RequestMapping</code> 有一定的冲突。</p>
<p>解决动态资源和静态资源冲突的问题，在 springmvc 配置文件加入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-dirven</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>静态资源都放到同一个文件夹 static 下面，然后就可以写一个通用的配置语句实现多种静态资源的访问：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/&quot;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="地址分类">3. 地址分类</h3>
<p>在jsp ， html中使用的地址， 都是在前端页面中的地址，都是相对地址</p>
<p>1 绝对地址：带有协议名称的，例如：http://www.baidu.com, ftp://202.122.23.1</p>
<p>2 相对地址，没有协议开头的，例如：user/some.do，/user/some.do 相对地址不能独立使用，必须有一个参考地址。通过 参考地址+相对地址本身 才能指定资源</p>
<p>3 参考地址</p>
<p>1）<strong>在你的页面中，访问地址不加 &quot; / &quot;</strong></p>
<p>访问地址：http: //localhost:8080/06_path/index.jsp 路径：http: //localhost:8080/06_path/ 资源：index.jsp</p>
<p>在index.jsp发起 user/some.do请求，访问地址变为 http: //localhost:8080/06_path/test/some.do 在你的地址没有斜杠开头，例如：<code>user/some.do</code>，当你点击链接时，访问地址就是当前页面加上链接的地址 http: //localhost:8080/06_path/ + user/some.do</p>
<p>2）<strong>在你的页面中，访问地址加 &quot; / &quot;</strong></p>
<p>访问地址：http: //localhost:8080/06_path/index.jsp 路径：http: //localhost:8080/06_path/ 资源：index.jsp</p>
<p>点击 <code>/user/some.do</code>，访问地址变为：http: //localhost:8080/test/some.do <strong>参考地址是你的服务器地址，也就是http: //localhost:8080</strong></p>
<p>如果你的资源不能访问，加上：<code>$&#123;pageContext.request.contextPath&#125;</code>，修改如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs jsp"><span class="hljs-comment">//index.jsp</span><br>&lt;body&gt;<br>    &lt;p&gt;第一个springmvc项目&lt;/p&gt;<br>    &lt;p&gt;&lt;a href=&quot;/test/some.do&quot;&gt;发起/test/some.do的get请求&lt;/a&gt;&lt;/p&gt;<br>    &lt;br/&gt;<br>&lt;/body&gt;<br><br><span class="hljs-comment">//修改为</span><br>&lt;body&gt;<br>    &lt;p&gt;第一个springmvc项目&lt;/p&gt;<br>    &lt;p&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/test/some.do&quot;&gt;发起test/some.do的get请求&lt;/a&gt;&lt;/p&gt;<br>    &lt;br/&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>
<h1 id="三springmvc-核心技术">三、SpringMVC 核心技术</h1>
<h2 id="请求重定向和转发">1、请求重定向和转发</h2>
<p>当处理器对请求处理完毕后，向其它资源进行跳转时，有两种跳转方式：请求转发与重定向。而根据所要跳转的资源类型，又可分为两类：跳转到页面与跳转到其它处理器。</p>
<p>注意，对于请求转发的页面，可以是WEB-INF中页面；而重定向的页面，是不能为WEB-INF中页的。因为重定向相当于用户再次发出一次请求，而用户是不能直接访问 WEB-INF 中资源的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193714.png" style="zoom:60%;" /></p>
<p>SpringMVC 框架把原来 Servlet 中的请求转发和重定向操作进行了封装。现在可以使用单的方式实现转发和重定向。</p>
<ul>
<li><p>forward：表示转发，实现 <code>request.getRequestDispatcher(“xx.jsp”).forward()</code></p></li>
<li><p>redirect：：：表示重定向，实现 <code>response.sendRedirect(“xxx.jsp”)</code></p></li>
</ul>
<p><strong><code>setViewName()</code> 默认是forward。</strong></p>
<h3 id="forward-请求转发">forward 请求转发</h3>
<p>有时候你需要转发到不在WEB-INF目录下的jsp界面，但是视图解析器会自动给链接添加WEB-INF的路径</p>
<blockquote>
<p>请求转发相当于：你的请求我处理不了，不过我找到一个能帮你处理请求的人过来</p>
</blockquote>
<p>处理器方法返回 ModelAndView，实现转发 forward操作</p>
<ul>
<li><p>语法：<code>setViewName(&quot;forward:视图文件完整路径&quot;)</code></p></li>
<li><p>forward特点：不和视图解析器一同使用，就当项目中没有视图解析器</p></li>
</ul>
<p>对应控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/doForward.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doSome</span><span class="hljs-params">()</span></span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;-----欢迎使用spring mvc做web开发------&quot;</span> );<br>        mv.addObject(<span class="hljs-string">&quot;fun&quot;</span>,<span class="hljs-string">&quot;执行的是doSome方法&quot;</span>);<br><br>        <span class="hljs-comment">//=====================重点===========================</span><br>        <br>        <span class="hljs-comment">//使用视图解析器</span><br>        <span class="hljs-comment">//mv.setViewName(&quot;show&quot;);</span><br>        <br>        <span class="hljs-comment">//显式转发</span><br>        mv.setViewName(<span class="hljs-string">&quot;forward:WEB-INF/view/show.jsp&quot;</span>);<br>        <br>        <span class="hljs-comment">//=====================重点===========================</span><br>        <br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="redirect-重定向">redirect 重定向</h3>
<p>处理器方法返回ModelAndView，实现转发redirect操作</p>
<ul>
<li>语法：<code>setViewName(&quot;redirect:视图文件完整路径&quot;)</code></li>
<li>redirect特点：也是不和视图解析器一同使用，就当作项目中没有视图解析器</li>
</ul>
<p>框架对重定向的操作：</p>
<ol type="1">
<li>框架会把model中的简单类型的数据，转为String使用，作为hello.jsp的get请求参数使用。目的是在 doRedirect.do 和 hello.jsp 两次请求之间传递参数</li>
<li>在目标hello.jsp可以使用参数集合对象 <code>$(param)</code> 获取请求参数值，格式为：<code>$(param.name)</code></li>
<li>重定向不能访问WEB-INF资源</li>
</ol>
<h2 id="异常处理">2、 异常处理</h2>
<p>springmvc框架采用的是统一，全局的异常处理。把controller中的所有异常处理都集中到一个地方，采用的是 <strong>AOP</strong> 思想，把业务逻辑和异常处理代码分开。也叫解耦合。</p>
<p>使用两个注解：</p>
<ol type="1">
<li><code>@ExceptionHandler</code><br />
</li>
<li><code>@ControllerAdvice</code></li>
</ol>
<p>异常处理主要步骤：</p>
<ol type="1">
<li>新建一个自定义异常类 <code>MyUserException</code>，再定义它的子类 <code>NameException</code>，<code>AgeException</code></li>
<li>在 <code>controller</code> 抛出 <code>NameException</code>，<code>AgeException</code></li>
<li>创建一个普通类，作为 全局异常处理类
<ol type="1">
<li>类上面加上 <code>@ControllerAdvice</code></li>
<li>类中方法上面加上 <code>@ExceptionHandler</code></li>
</ol></li>
<li>创建对应视图。创建组件扫描器，扫描 <code>@Controller</code> 注解 和 <code>@ControllerAdvice</code>所在的包名。声明注解驱动。</li>
</ol>
<hr />
<ul>
<li>springmvc.xml，加入组件扫描器和注解驱动</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--处理异常两个步骤--&gt;</span><br><br><span class="hljs-comment">&lt;!--1、组件扫描器：扫描全局异常处理程序--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bjpowernode..handler&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--2、注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>MyController.java，控制器方法，向 MyUserException 抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doSome</span><span class="hljs-params">(String name, Integer age)</span> <span class="hljs-keyword">throws</span> MyUserException </span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br><br>        <span class="hljs-comment">//根据请求抛出异常</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;zs&quot;</span>.equals(name))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NameException(<span class="hljs-string">&quot;姓名不正确&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (age &lt;= <span class="hljs-number">0</span> || age &gt;= <span class="hljs-number">99</span> || age == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AgeException(<span class="hljs-string">&quot;年龄输入有误&quot;</span>);<br>        &#125;<br>        <br>        mv.addObject(<span class="hljs-string">&quot;name&quot;</span>,name);<br>        mv.addObject(<span class="hljs-string">&quot;age&quot;</span>,age);<br>        mv.setViewName(<span class="hljs-string">&quot;show&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>exception 文件夹下面的自定义异常类 MyUserException.java，继承 Exception</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUserException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyUserException</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyUserException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>子类 NameException.java ：表示当前用户姓名有异常，抛出 NameException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//表示当前用户姓名有异常，抛出NameException</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyUserException</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NameException</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NameException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>下面创建一个GlobalExceptionHandler.java，作为 全局异常处理类</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193741.png" /></p>
<h3 id="controlleradvice"><span class="citation" data-cites="ControllerAdvice">@ControllerAdvice</span></h3>
<p>控制器增强 (可以理解为：给控制器类增加异常处理功能)，放在类上面</p>
<p>特点：必须让框架知道这个注解所在的包名，需要在springmvc配置文件声明 组件扫描器</p>
<p>指定 <span class="citation" data-cites="ControllerAdvice">@ControllerAdvice</span> 所在的全局异常处理类包名</p>
<h3 id="exceptionhandler"><span class="citation" data-cites="ExceptionHandler">@ExceptionHandler</span></h3>
<p><span class="citation" data-cites="ExceptionHandler">@ExceptionHandler</span>(异常的class)：表示异常的类型，当发生此类型的异常时，由当前方法处理。放在方法上面</p>
<p>处理异常的方法和控制器方法的定义一样，可以有多个参数，可以有ModelAndView，String，void，对象类型的返回值</p>
<p>形参：Exception，表示Controller中抛出的异常对象，通过形参可以获取发送的异常信息</p>
<hr />
<p>MyController.java 出现异常，跳转到异常处理程序，找 ExceptionHandler</p>
<ul>
<li>handler 文件夹下面的 GlobalExceptionHandler.java 异常处理程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@ControllerAdvice 增强控制器</span><br><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;<br>	<br>    <span class="hljs-comment">//处理NameException异常</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	异常发生时的处理逻辑：</span><br><span class="hljs-comment">    	1. 需要把异常记录下来。记录到数据库，日志文件。</span><br><span class="hljs-comment">    	2. 发送通知，把异常的信息通过邮件短信微信发送给相关人员。</span><br><span class="hljs-comment">    	3. 给用户友好的提示。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@ExceptionHandler(value = NameException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doNameException</span><span class="hljs-params">(Exception exception)</span></span>&#123;<br><br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;用户名必须是zs，其他用户不能访问&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;ex&quot;</span>, exception);<br>        <span class="hljs-comment">//指定视图</span><br>        mv.setViewName(<span class="hljs-string">&quot;nameError&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br><br>    <span class="hljs-comment">//处理AgeException异常</span><br>    <span class="hljs-meta">@ExceptionHandler(value = AgeException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doAgeException</span><span class="hljs-params">(Exception exception)</span></span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;年龄输入范围有误&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;ex&quot;</span>,exception);<br>        mv.setViewName(<span class="hljs-string">&quot;ageError&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br><br>    &#125;<br><br>    <span class="hljs-comment">//处理NameException，AgeException以外的，不知类型的异常</span><br>    <span class="hljs-meta">@ExceptionHandler</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">doOtherException</span><span class="hljs-params">(Exception exception)</span></span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;其他不知类型的异常&quot;</span>);<br>        <span class="hljs-comment">//指定视图</span><br>        mv.setViewName(<span class="hljs-string">&quot;defaultError&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="拦截器">3、拦截器</h2>
<h4 id="拦截器说明">拦截器说明：</h4>
<ol type="1">
<li><p>拦截器是springmvc中的一种，需要实现 <code>HandlerInterceptor</code> 接口</p></li>
<li><p>拦截器和过滤器类似，功能方向侧重点不同。</p>
<ul>
<li><p><strong>过滤器是用来过滤请求参数，设置编码字符集等工作。</strong></p></li>
<li><p><strong>拦截器是拦截用户的请求，对请求做判断处理的。</strong></p></li>
</ul></li>
<li><p>拦截器是全局的，可以对多个Controller做拦截。</p>
<p>一个项目中可以有0个或多个拦截器，他们在一起拦截用户的请求。</p></li>
<li><p>拦截器常用在：用户登录处理，权限检查，记录日志。</p></li>
</ol>
<h4 id="拦截器的使用步骤">拦截器的使用步骤：</h4>
<ol type="1">
<li>定义普通类实现 <code>HandlerInterceptor</code> 接口，实现接口的三个方法</li>
<li>在springmvc文件中，声明拦截器(让框架知道拦截器的存在)，指定拦截请求的uri地址</li>
</ol>
<h4 id="拦截器的执行时间">拦截器的执行时间：</h4>
<ol type="1">
<li>在请求处理之前，也就是controller类中方法执行之前先被拦截</li>
<li>在控制器方法执行之后也会执行拦截器</li>
<li>在请求处理完成后也会执行拦截器</li>
</ol>
<hr />
<ul>
<li>在主配置文件springmvc.xml中，声明拦截器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--声明拦截器：拦截器可以有0个或者多个--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--声明一个拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        指定拦截请求的uri地址</span><br><span class="hljs-comment">            path：就是uri地址，可以使用通配符 **</span><br><span class="hljs-comment">              **：表示任意字符，文件或者多级目录中的文件</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--声明拦截器对象--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bjpowernode.handler.MyInterceptor&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="prehandle预处理方法重要">preHandle：预处理方法（重要）</h3>
<p>预处理方法：preHandle。重要：是整个项目的入口，门户</p>
<ul>
<li><p>当preHandle返回true，请求可以被处理</p></li>
<li><p>当preHandle返回false，请求到此方法就截止</p></li>
</ul>
<p>参数：Object handler：被拦截的控制器对象</p>
<p>返回值：boolean</p>
<ul>
<li><p><strong>true：请求通过拦截器验证，可以处理拦截器方法</strong></p>
<p>控制台显示结果：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">MyInterceptor拦截器的pre<span class="hljs-constructor">Handle()</span>方法执行了！<br>MyController控制器的<span class="hljs-keyword">do</span><span class="hljs-constructor">Some()</span>方法执行！<br>MyInterceptor拦截器的post<span class="hljs-constructor">Handle()</span>方法执行了！<br>MyInterceptor拦截器的after<span class="hljs-constructor">Completion()</span>方法执行了！<br></code></pre></td></tr></table></figure></li>
<li><p><strong>false：请求没有通过拦截器的验证，请求到达拦截器就截止了。请求没有被处理</strong></p>
<p>控制台显示结果：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">MyInterceptor</span>拦截器的<span class="hljs-function"><span class="hljs-title">preHandle</span>()方法执行了！</span><br></code></pre></td></tr></table></figure>
<p>特点：</p></li>
</ul>
<ol type="1">
<li><p><strong>该方法在控制器方法（MyController的doSome）之前执行，用户请求首先到达该方法</strong></p></li>
<li><p>在该方法中可以获取请求的信息，验证请求是否符合要求。</p>
<p>可以验证用户是否登录，验证用户是否有权访问某个连接地址（url）。如果验证失败，可以截断请求；如果验证成功，可以放行请求，此时控制器方法才能执行</p></li>
</ol>
<hr />
<p>创建一个MyInterceptor.java，作为拦截器类，继承自HandlerInterceptor，实现三个方法：preHandle，postHandle，afterCompletion</p>
<p><strong>拦截器类：看作是多个控制器中公用的功能，集中到拦截器统一处理，使用的是aop思想（面向切面编程）。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//拦截器类：看作是多个控制器中公用的功能，集中到拦截器统一处理，使用的是aop思想（面向切面编程）。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInterceptor拦截器的preHandle()方法执行了！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 后处理方法：postHandle</span><br><span class="hljs-comment">    * 参数：</span><br><span class="hljs-comment">    * Object handler：被拦截的处理器对象MyController</span><br><span class="hljs-comment">    * ModelAndView mv：处理器方法的返回值</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * 特点：</span><br><span class="hljs-comment">    *   1、在处理器方法(MyController.doSome)之后执行</span><br><span class="hljs-comment">    *   2、能够获取到处理器方法的返回值ModelAndView，可以修改ModelAndView中的数据和视图，会影响到最后的输出结果</span><br><span class="hljs-comment">    *   3、主要是对原来的执行结果做第二次修正</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView mv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInterceptor拦截器的postHandle()方法执行了！&quot;</span>);<br>    &#125;<br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 最后执行方法：afterCompletion</span><br><span class="hljs-comment">    * 参数：</span><br><span class="hljs-comment">    *   Object handler：被拦截的处理器对象</span><br><span class="hljs-comment">    *   Exception ex：程序中发生的异常</span><br><span class="hljs-comment">    * 特点：</span><br><span class="hljs-comment">    *   1、在请求处理完成后执行。框架中规定是你的视图处理完成后，对视图执行了forward。就认为请求处理完成。</span><br><span class="hljs-comment">    *   2、一般做资源回收，程序请求中创建的一些对象，在这里删除，回收占用的内存</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInterceptor拦截器的afterCompletion()方法执行了！&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193801.png" style="zoom: 67%;" /></p>
<ul>
<li>多个拦截器时</li>
</ul>
<p>在框架中保存多个拦截器是ArrayList， 按照声明的先后顺序放入ArrayList</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220711193808.png" style="zoom:50%;" /></p>
<p>1、第一个拦截器preHandle=true，第二个拦截器preHandle=true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">第一个拦截器类<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;11111--MyInterceptor拦截器的preHandle()方法执行了！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>        <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(......)</span></span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;11111--MyInterceptor拦截器的postHandle()方法执行了！&quot;</span>);<br>    &#125;<br>        .....<br><br>第二个拦截器类<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;22222--MyInterceptor拦截器的preHandle()方法执行了！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>        <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(......)</span></span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;22222--MyInterceptor拦截器的postHandle()方法执行了！&quot;</span>);<br>    &#125;<br>        .....<br>            <br></code></pre></td></tr></table></figure>
<ul>
<li>配置文件中也要同时声明两个拦截器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--声明一个拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zh.handler.MyInterceptor&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--声明第二个拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zh.handler.MyInterceptor2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>运行结果如下</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">11111</span>--MyInterceptor拦截器的pre<span class="hljs-constructor">Handle()</span>方法执行了！<br><span class="hljs-number">22222</span>--MyInterceptor拦截器的pre<span class="hljs-constructor">Handle()</span>方法执行了！<br>MyController控制器的<span class="hljs-keyword">do</span><span class="hljs-constructor">Some()</span>方法执行！<br><span class="hljs-number">22222</span>--MyInterceptor拦截器的post<span class="hljs-constructor">Handle()</span>方法执行了！<br><span class="hljs-number">11111</span>--MyInterceptor拦截器的post<span class="hljs-constructor">Handle()</span>方法执行了！<br><span class="hljs-number">22222</span>--MyInterceptor拦截器的after<span class="hljs-constructor">Completion()</span>方法执行了！<br><span class="hljs-number">11111</span>--MyInterceptor拦截器的after<span class="hljs-constructor">Completion()</span>方法执行了！<br></code></pre></td></tr></table></figure>
<p>2、第一个拦截器preHandle=true，第二个拦截器preHandle=false</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-number">11111</span><span class="hljs-comment">--MyInterceptor拦截器的preHandle()方法执行了！</span><br><span class="hljs-number">22222</span><span class="hljs-comment">--MyInterceptor拦截器的preHandle()方法执行了！</span><br><span class="hljs-number">11111</span><span class="hljs-comment">--MyInterceptor拦截器的afterCompletion()方法执行了！</span><br></code></pre></td></tr></table></figure>
<p>3、第一个拦截器preHandle=false，第二个拦截器preHandle=true</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-number">11111</span><span class="hljs-comment">--MyInterceptor拦截器的preHandle()方法执行了！</span><br></code></pre></td></tr></table></figure>
<h3 id="拦截器和过滤器的区别">拦截器和过滤器的区别</h3>
<ol type="1">
<li><p>过滤器是servlet中的对象，拦截器是框架中的对象</p></li>
<li><p>拦截器拦截普通类方法执行，过滤器过滤servlet请求响应</p></li>
<li><p>过滤器实现Filter接口，拦截器实现HandlerInterceptor</p></li>
<li><p>过滤器是用来设置request，response的参数，属性，侧重对数据过滤的</p>
<p>拦截器用来验证请求，能截断请求</p></li>
<li><p>过滤器是在拦截器之前先执行</p></li>
<li><p>过滤器是tomcat服务器创建的对象</p>
<p>拦截器是springmvc容器中创建的对象</p></li>
<li><p>过滤器是一个执行时间点</p>
<p>拦截器是三个执行时间点</p></li>
<li><p>过滤器可以处理jsp，js，html等</p>
<p>拦截器是侧重拦截对Controller的对象。如果你的请求不能被DispatcherServlet接收，这个请求不会执行拦截器内容</p></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>【Large-Scale Evolution】Large-Scale Evolution of Image Classifiers</title>
    <url>/2022/07/12/%E3%80%90Large-Scale%20Evolution%E3%80%91Large-Scale%20Evolution%20of%20Image%20Classifiers/</url>
    <content><![CDATA[<h1 id="large-scale-evolution-of-image-classifiers">Large-Scale Evolution of Image Classifiers</h1>
<ul>
<li>ICML 2017</li>
</ul>
<p>论文的思路就是用(稍微)改进的进化算法，使其可以用于 NAS。论文对当前的进化算法少量改造，结合前所未有的算力进行神经网络结构搜索，在CIFAR-10上达到了很不错的准确率。论文十分注重搜索算法的简单性，从性能很差的无卷积模型开始，进化算法需要在一个几乎不受约束的搜索空间中进化成复杂的卷积网络。这篇文章的大概意思是想证明一下，使用进化算法做出来的神经网络结构，在图像分类上不会低于人工精心设计的结构，并且最后结果也给了验证。</p>
<p>只使用了变异，没使用交叉操作，并且tournament selection的时候直接把那个不好的个体给kill掉了。</p>
<h2 id="method">Method</h2>
<h3 id="算法">算法</h3>
<p>改进的进化算法流程： 1. 种群中的每个个体都有基因编码 2. 种群中的每个个体都是训练好的神经网络架构，其适应度为该神经网络架构在验证集上的准确率 3. 选择：使用二元锦标赛算法，每次随机选择两个个体。不同的是，适应度较小的个体直接从种群中移除 4. 变异：从种群中选择两个适应度最高的神经网络架构作为父母，产生两个后代，分别与两个父代的架构⼀致。对产生的两个后代架构进行变异操作 5. 训练新产生的后代，并将其在验证集上的准确率作为适应度函数</p>
<p>为了加速计算，使用massively-parallel, lock-free的并行计算，许多worker在不同电脑上进行独立的异步操作，仅使用共享文件系统来保证种群内容一致，每个个体为一个文件夹。种群数量为1000，worker一般为种群数量的四分之一。</p>
<h3 id="编码和变异">编码和变异</h3>
<p>网络结构编码为图(DNA)，节点表示3维tensor或激活方法，tensor的3维分别表示图片的空间坐标以及channel数，激活方法作用与节点上，可以为BN+RELU或无激活，边表示identity connections（跳跃连接）或卷积(包含可变异参数)。当节点连接多条边时，将其中一条非identity connection的边作为主边，对其它边进行像素的最近邻差值以及维度的裁剪和填充，最后进行element-wise sum。在每次繁衍过程中，随机选取以下一种变异方式：</p>
<ol type="1">
<li>改变学习率 Learning Rate</li>
<li>模型保持不变，但是继续训练一段时间（由于训练继续，模型参数还是会有所变化）</li>
<li>重置所有参数Weights（可能可以逃出局部最优值）</li>
<li>插入卷积层（卷积核大小 3x3， 步长随机1 或 2，通道数和输入通道数一样， 最后在随机决定是否加上 Batch-Normalization 和 ReLU）</li>
<li>移除卷积层</li>
<li>改变卷积层的步长（只能改成2的幂）</li>
<li>随机改变卷积层的通道数（注意与之相连的通道数也要随之一起改变）</li>
<li>卷积核大小</li>
<li>插入一对一层（卷积核大小 1x1， 步长随机1 或 2，通道数和输入通道数一样， 最后在随机决定是否加上 Batch-Normalization 和 ReLU）</li>
<li>Add-skip 加入skip层，注意这个不是真正的跳过了 而是把之前某一层的结果和后来某一层的结果相加输出给后面一层（当然前提是相加的这两层必须size 和 channel 个数要一样）</li>
<li>Remove-skip 移除skip层</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220715115856.png" /></p>
<hr />
<p>感觉论文中对于图的描述不是很清楚，可以阅读代码进一步了解。但是这个就是一个进化算法+NAS的开端，文章思路比较简单。</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>Large-Scale Evolution</tag>
      </tags>
  </entry>
  <entry>
    <title>Understanding and Simplifying One-Shot Architecture Search</title>
    <url>/2022/07/15/Understanding%20and%20Simplifying%20One-Shot%20Architecture%20Search/</url>
    <content><![CDATA[<h1 id="understanding-and-simplifying-one-shot-architecture-search">Understanding and Simplifying One-Shot Architecture Search</h1>
<ul>
<li>ICML 2018</li>
</ul>
<p>本文重在探究<strong>为什么One-Shot模型中的权重能被众多不同的架构共享，并且是有效的</strong>。通过实验分析，证明了在没有超网络或RL的情况下，从复杂的搜索空间中有效地识别有效的网络结构是可能的。</p>
<h2 id="basic-idea">Basic Idea</h2>
<p>这篇论文是基于参数共享的，作者训练了一个可以表述所有子结构的大网络。搜索空间的大小随选择的数量呈指数增长，而one-shot模型的大小仅呈线性增长。相同的权重用于评估许多不同的体系结构，从而将运行体系结构搜索所需的资源减少了数量级。</p>
<p>但是作者基于此也提出了一个问题：<u>为什么不同的结构可以共享一个权重集合？</u>即，一组固定的权重可以在广泛的体系结构中很好地工作的想法也是违反直觉的。SMASH（采用超网）和ENAS（采用RL控制器）也尝试解决这个问题。而本文作者的<strong>目标是了解权重共享在体系结构搜索方法中所起的作用</strong>。而实验表明，要获得好的结果，既不需要超网，也不需要RL控制器。为此作者训练了一个大的one-shot模型，包含了搜索空间里的每个可能的操作。然后剔除一些操作，测量其对模型预测准确率的影响。作者发现网络自动将其能力集中在对产生良好预测最有用的操作上。剔除不太重要的操作对模型的预测的影响很小，而剔除很重要的操作对模型预测的影响很大。实际上，可以通过观察网络结构在训练集中无标签样例的行为，来预测网络在验证集上的准确率。</p>
<h2 id="one-shot-architecture-search">One-Shot Architecture Search</h2>
<p>One-Shot Model 四步：</p>
<ol type="1">
<li>设计一个搜索空间，允许使用单个 One-Shot Model 表示各种架构。</li>
<li>训练 One-Shot Model ，使其预测架构的验证精度。</li>
<li>使用预先训练的 One-Shot Model 评估验证集上的候选架构。</li>
<li>从头开始重新训练最有前途的架构，并在测试集上评估其性能。</li>
</ol>
<h3 id="search-space-design">1. Search Space Design</h3>
<p>给 One-Shot Model 设计一个良好的搜索空间的要求：</p>
<ol type="1">
<li>搜索空间应该足够大和有表现力，以捕获各种候选架构。</li>
<li>One-Shot Model 产生的验证集精度必须能够预测独立模型训练产生的精度。</li>
<li>在有限资源条件（即内存和时间）下，one-shot应该足够小。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220716120154.png" style="zoom: 50%;" /></p>
<p>如上例所示：不同于分别训练三个模型，作者训练一个包括了这三个操作的模型（one-shot model），然后在验证阶段，选择性地剔除其中两个操作的输出，来模拟仅包含输入2的网络。一般而言，可以选择enable或disable输入连接的任何组合。这样，搜索空间的大小随输入的跨连接的数量呈指数增长，而one-shot模型的大小呈线性增长。在concat后总是进行 <span class="math inline">\(1×1\)</span> 卷积，无论有多少输入跨连接，卷积中的输出滤波器的数量都保持不变。之后对 <span class="math inline">\(1×1\)</span> 卷积的输出运用不同的操作，并将结果sum起来。在评估阶段，可以将其中的一些操作置零或者从网络中删除。在上例中，操作方式有3x3卷积、5x5卷积、最大池化和Identity，但只有5x5卷积操作留了下来。</p>
<p>这个方法对于更大的模型也是适用的，如下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220716103322.png" /></p>
<p>网络可以看做有几个相同的cell堆叠在一起组成的（图左1），每一个cell中有固定数目的<em>choice block</em>（图左2），这些<em>choice block</em>的输入来自于前驱cell的输出和同一个cell下前驱<em>choice block</em>的输出。作者设置的cell中有4个<em>choice block</em>，即 <span class="math inline">\(N_{choice}= 4\)</span>（图里好像只画了3个），每个<em>choice block</em>最多可以从五个可能的输入中进行选择：两个来自前驱cell的输出，最多三个来自同一个cell下前驱<em>choice block</em>的输出（例如图左2最下面五个输入进行concat）。每个<em>choice block</em>包括七种操作（图左3），有identity(应该是跳跃连接)，3x3深度可分离卷积，5x5深度可分离卷积，7x7深度可分离卷积、1x7卷积跟7x1卷积，最大池化，平均池化。</p>
<h3 id="training-the-one-shot-model">2. Training the One-Shot Model</h3>
<p>One-shot模型是用带动量的SGD训练的标准大型神经网络。为了确保特定架构的one-shot模型精度与stand-alone模型精度之间良好关联，需要讨论以下几个方面。</p>
<p><strong>互相适应的鲁棒性（Robustness to Co-adaptation）</strong>： 在评估阶段，我们通过zero out一些连接，得到了一些特定的结构。尽管移除了不重要的操作，也可能会导致模型的预测性能严重下降，one-shot模型和独立模型之间的准确率的关系也会退化。为了解决这个问题，作者引入了<strong>path dropout机制</strong>，训练one-shot模型的时候，在每一批次中随机将一些操作剔除。在训练开始 disable path dropout，随着训练的进行逐步线性的增加 dropout rate，这样可以达到了一个较好的结果。在训练结束时dropout rate 设置为 <span class="math inline">\(r^{1/k}\)</span>，其中 <span class="math inline">\(0&lt;r&lt;1\)</span> 为一个超参数，<span class="math inline">\(k\)</span> 为给定一个操作下输入路径的数量。<u>fan-in的值越大，dropout rate越高</u>。对于一个cell，不同的operation的都是彼此独立的剔除（这样有益处），对于一个model包含多个cell，则相同的operation将被一并剔除。</p>
<p><strong>Stabilizing Model Training</strong>：在早期实验中，模型的训练非常的不稳定，作者发现小心的使用BN可以使训练稳定，文章中采用了BN-Relu-Conv这种规则。因为在评估阶段会剔除一些操作，这样就是BN统计量发生了变化，因此批BN在评估时的应用方式与在训练时完全相同——动态计算batch的统计信息。</p>
<p>作者发现如果在单个批处理中为每个示例剔除掉相同的路径，one-shot模型训练就会变得不稳定。相反如果每个示例剔除不同路径，它是可以稳定的。因此对于不同的样本子集，作者dropout不同的操作：作者将一个batch的样本分成多个小batch（文中称为ghost batch），一个batch有1024个样本，分成32个ghost batch，每个有32个样本，每个ghost batch剔除不同的操作。</p>
<p><strong>Preventing Over-regularization</strong>：让L2正则化只对选择的子模型做正则化。</p>
<h3 id="evaluating-candidate-architectures">3. Evaluating Candidate Architectures</h3>
<p>训练了one-shot模型后，使用它来评估许多不同架构在held-out验证集的性能。作者在实验中， 按照论文 <code>SMASH:One-shot model architecture search through hypernet-works</code> 的方法，从固定的概率分布中进行独立的结构采样。作者也注意到，随机采样也可以用进化算法和基于神经网络的强化学习代替。</p>
<h3 id="final-model-selection-and-training">4. Final Model Selection and Training</h3>
<p>完成搜索之后，从头训练表现最好的结构，同时也可以扩展架构以增加其性能，也可以缩小架构以减少计算成本。作者在实验中，增加了过滤器的数量来扩展架构。</p>
<h2 id="experiments">Experiments</h2>
<h3 id="dropout-rate的影响">1. Dropout Rate的影响</h3>
<p>和vanilla SGD相比，仅引入了一个新的超参数 Dropout Rate，需要细心调节以实现one-shot模型与stand-alone模型之间精度的良好关系。为了证明其重要性，为此作者训练了具有不同Dropout Rate的One shot模型，且在训练过程中Dropout Rate保持稳定。结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220716140704.png" /></p>
<p>从图中可以发现当Dropout Rate过低时（大多数路径在训练步骤都保留了），少数架构的准确度比较高，大多数的架构的精度非常低，One-shot模型准备不足，无法在评估时将模型的大部分路径清零。</p>
<p>当Dropout Rate过高时，尽管架构的准确率有所增加，但是one-shot模型将最有用的capacity集中到最有用路径上的程度大大降低了。模型较浅时，高Dropout Rate会产生不错的结果，然而，随着搜索空间越来越复杂，模型越来越深，使用高Dropout Rate变得越来越成问题。</p>
<h3 id="实验结果对比">2. 实验结果对比</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220716144029.png" style="zoom: 60%;" /></p>
<p>实验结果可以看到，与SMASH和除一种ENAS变体外的所有ENAS，算是具有竞争力，效果还不错。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220716181907.png" style="zoom: 33%;" /></p>
<h2 id="理解-one-shot-模型">理解 One-shot 模型</h2>
<blockquote>
<p>这一块来自于 https://www.cnblogs.com/marsggbo/p/13195496.html</p>
</blockquote>
<p>由上图我们可以看到（以最左图为例），one-shot模型的准确率从0.1~0.8， 而stand-alone（即retrain之后的子模型）的准确率范围却只是0.92~0.945。为什么one-shot模型之间的准确率差别会更大呢？</p>
<p>文章对此给出了一个猜想：<strong>one-shot模型会学习哪一个操作对模型更加有用，而且最终的准确率也是依赖于这些操作的</strong>。换句话说：</p>
<ul>
<li>在移除一些不太重要的操作时，可能会使one-shot模型准确率有所降低，但是最后对stand-alone模型性能的预测影响不大。</li>
<li>而如果把一些最重要的操作移除之后，不仅对one-shot模型影响很大，对最后的stand-alone模型性能的预测影响也大。</li>
</ul>
<p>为了验证这一猜想，文章做了如下实验：</p>
<p>首先将几乎保留了所有操作的(dropout概率是 <span class="math inline">\(r=10^{−8}\)</span>)模型叫做<strong>reference architectures</strong>，注意这里用的是复数，也就是说这个reference architectures有很多种，即有的是移除了不太重要的操作后的结构，有的时移除了非常重要的操作候的结构，那么不同结构的准确率应该是不一样的。不过在没有retrain的情况下，什么操作都没有移除的one-shot模型（All on）应该是最好的（或者是表现靠前的，这里我们认为是最好的）。</p>
<p>注意这里的移除某些操作后得到的模型还是One-shot模型，而不是采样后的模型。采样后的模型是指从这个完整的one-shot中按照某种策略得到的模型。文中把这种模型叫做<strong>candidate architectures</strong>。</p>
<p>我们以分类任务为例，假设<strong>reference architectures</strong>对某个样本的预测输出是 <span class="math inline">\((p_1,p_2,...,p_n)\)</span>，其中 <span class="math inline">\(n\)</span> 表示类别数量；而<strong>candidate architectures</strong>的输出为 <span class="math inline">\((q_1,q_2,...,q_n)\)</span>。注意candidate architecture的输出应该是没有retrain的结果。</p>
<p>所以如果上面的猜想是正确的，那么表现最好的<strong>candidate architecture</strong>的预测应该要和所有操作都保留的one-shot模型的预测结果要十分接近。文中使用<strong>对称散度</strong>来判断相似性，散度公式为 <span class="math inline">\(D_{\mathrm{KL}}(p \| q)=\sum_{i=1}^{n} p_{i} \log \frac{p_{i}}{q_{i}}\)</span> ，那么对称散度就是<span class="math inline">\(D_{\mathrm{KL}}(p \| q)+D_{\mathrm{KL}}(q \| p)\)</span>。对称散度结果是在64个随机样本上得到的平均值，散度值越接近于0，表示二者输出越相近。</p>
<p>最后的结果如图示，可以看到在训练集上散度值低的模型（即预测值和保留大多数操作的完整模型很接近），在验证集上的准确率也相对高一些。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220716181807.png" style="zoom: 40%;" /></p>
<blockquote>
<p>这块也没太理解。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>papers</category>
      </categories>
      <tags>
        <tag>G-NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>【NASNet】Learning transferable architectures for scalable image recognition</title>
    <url>/2022/07/16/%E3%80%90NASNet%E3%80%91Learning%20transferable%20architectures%20for%20scalable%20image%20recognition/</url>
    <content><![CDATA[<h1 id="learning-transferable-architectures-for-scalable-image-recognition">Learning transferable architectures for scalable image recognition</h1>
<ul>
<li>CVPR 2018</li>
</ul>
<p>这篇文章出自Google Brain，是对他们之前发表在ICLR2017的论文《<a href="https://arxiv.org/abs/1611.01578v2">Neural Architecture Search with Reinforcement Learning</a>》的改进.</p>
<blockquote>
<p><a href="https://stuxiaozhang.github.io/2022/04/05/Neural%20Architecture%20Search%20with%20reinforcement%20learning/">简单的阅读笔记在这。</a></p>
</blockquote>
<blockquote>
<p>我的想法：</p>
<ol type="1">
<li><p>为什么NASNet的cell必须是5个(小)块组成？这是不是有些局限？</p>
<p>NASNet的基础单元是两种Cell，Cell中由5个blocks构成，block由两个输入进行op后的组合运算，很像ResNet的残差结构。是不是也可以创造一种类似DenseNet的block；或者说不限制输入个数。或者block的形式可以再多些其他种类的。</p></li>
<li><p>改进的ScheduledDropPath中，cell中的每个路径以一个在训练中呈线性增加的概率被丢弃。这块能不能有些改进？</p></li>
</ol>
</blockquote>
<h2 id="basic-idea">Basic Idea</h2>
<p>这篇文章研究了一种新的卷积结构设计范式，并描述了一种优化卷积结构的可扩展方法。作者认为直接将NAS或任何其他搜索方法应用于大型数据集的计算代价比较昂贵，所以文章建议先在一个代理数据集（例如较小的CIFAR-10数据集）上搜索一个好的体系结构，然后再迁移到ImageNet这样的大数据集上去。作者通过设计了一个NASNet搜索空间来实现这种可迁移性，使得体系结构的复杂性与网络的深度和输入图像的大小无关。更具体地说，搜索空间中的所有卷积网络都是由具有相同结构但不同权重的卷积层（或cell）组成的。所以说，搜索最佳卷积结构被简化为搜索最佳cell结构。这么做的优势在于比搜索整个网络结构快得多，而且更容易泛化到其他问题上去。</p>
<p>总的来说本文贡献如下：</p>
<ol type="1">
<li><p>这篇文章关键的贡献在于设计了一种新的搜索空间，即NASNet搜索空间。不像之前的工作直接搜索整个网络结构，这篇文章是先搜索一个最好的网络层（或者叫卷积cell）然后再将其堆叠起来构建网络。</p>
<blockquote>
<p>作者的灵感来自于：SOTA的CNN架构设计往往是由重复的motifs组成的，包括卷积滤波器组、非线性以及谨慎选择的连接的一个组合，比如ResNet中的残差模块，Inception中的Inception模块等。</p>
</blockquote></li>
<li><p>文章中还提出了一种新的正则化技术ScheduledDropPath以提高NASNet模型的泛化能力。ScheduledDropPath中，cell中的每个路径以一个在训练过程中呈线性增加的概率被丢弃。</p></li>
<li><p>NASNet学到的特征也可以迁移到其他任务上，比如在目标检测上同样超过了SOTA。</p></li>
</ol>
<h2 id="method">Method</h2>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717101629.png" style="zoom:50%;" /></p>
<p>这篇文章采用的主要搜索方法还是<a href="https://arxiv.org/abs/1611.01578v2">他们团队前一篇论文《Neural Architecture Search with Reinforcement Learning》</a>提出的如图1所示的NAS框架。控制器为一个RNN，其采样不同结构的子网络。通过训练子网络直至收敛得到在验证集上的精度<span class="math inline">\(R\)</span>，用此精度更新控制器，从而控制器随着时间的推移可以生成更好的体系结构。这里控制器权重使用策略梯度（policy gradient）进行更新。</p>
<p>这篇文章的主要贡献是设计了一个新的搜索空间NASNet，以便在CIFAR-10数据集上找到的最佳架构可以扩展到更大、更高分辨率的图像数据集上去。至于NASNet搜索空间的灵感来源，则是因为SOTA的CNN架构设计往往是由重复的motifs组成的，包括卷积滤波器组、非线性以及谨慎选择的连接的一个组合，比如ResNet中的残差模块，Inception中的Inception模块等。这些观察表明，控制器RNN可能预测用这些motifs表达的一般卷积cell。这个cell可以串联起来处理任意空间尺寸和滤波器深度的输入。本文的方法中，CNN的总体架构是手动预先确定的，它们由多次重复的卷积cell组成，每个卷积cell具有相同的结构，但权重不同。文中也提出了两种motifs，分别是Normal Cell和Reduction Cell，区别就是一个不用池化、一个用了：</p>
<ol type="1">
<li>Normal Cell：输出Feature Map和输入Feature Map的尺寸相同</li>
<li>Reduction Cell：输出Feature Map对输入Feature Map进行了一次降采样，其中特征图高度和宽度减少了两倍（用了stride=2）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717102839.png" style="zoom: 70%;" /></p>
<p>如图2所示，以CIFAR-10和ImageNet为例给了两种结构，因为ImageNet的图片尺寸更大，所以用了更多的Reduction Cell。而且每当空间尺寸减小时，输出中的滤波器数量加倍，以保持大致恒定的隐藏状态的维度。重要的是，文中将motif重复次数<span class="math inline">\(N\)</span>和初始卷积滤波器的数量视为自由参数（人为事先指定的），可以根据图像分类问题的规模进行调整。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717140400.png" /></p>
<p>如图为NASNet搜索空间示意图。网络的motifs是在称为block的阶段中递归构建的。每个block由控制器RNN选择一对隐藏状态（深灰色）、对这些隐藏状态执行的操作（黄色）和组合操作（绿色）组成。生成的隐藏状态保留在将在后续块上选择的潜在隐藏状态集中。</p>
<p>所以实际中改变的就只是Normal和Reduction Cell的结构，这个正好可以用RNN进行搜索。cell的结构可以在如下定义的搜索空间内搜索。</p>
<p>在NASNet的搜索空间中，每个cell接收两个初始隐藏状态<span class="math inline">\(h_i\)</span>和<span class="math inline">\(h_{i-1}\)</span>作为输入，这两个状态是前两个较低层或输入图像中两个cell的输出。给定这两个初始隐藏状态，控制器RNN递归预测卷积cell的其余结构（图3）。控制器对每个单元的预测被分组为B块，其中每个块有5个预测步骤，由5个不同的softmax分类器进行，对应于块元素的离散选择：</p>
<p><strong>Step 1.</strong> 从<span class="math inline">\(h_{i}\)</span>、<span class="math inline">\(h_{i-1}\)</span>或在先前块中创建的隐藏状态集中选择隐藏状态。</p>
<p><strong>Step 2.</strong> 从与Step 1相同的选项中选择第二个隐藏状态。</p>
<p><strong>Step 3.</strong> 选择要应用于在Step 1中选择的隐藏状态的操作</p>
<p><strong>Step 4.</strong> 选择要应用于在Step 2中选择的隐藏状态的操作</p>
<p><strong>Step 5.</strong> 选择一种方法来组合Step 3和4的输出以创建新的隐藏状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717154853.png" /></p>
<p>上图是用于递归构造卷积cell的一个block的控制器模型体系结构。 每个模块需要选择5个离散参数，每个参数对应于softmax层的输出。 右侧显示的示例构造块。 卷积cell包含B个块，因此控制器包含5B个softmax层，用于预测卷积cell的体系结构。实验中，B=5。</p>
<p>该算法将新创建的隐藏状态附加到现有的隐藏状态集，作为后续块中的潜在输入。控制器RNN将上述5个预测步骤重复B次，对应于卷积cell中的B个块。在步骤3和4中，控制器RNN选择要应用于隐藏状态的操作从下面的操作中选择：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717132223.png" style="zoom:80%;" /></p>
<p>在步骤5中，控制器RNN选择一种方法来组合两个隐藏状态，或者（1）两个隐藏状态之间的element-wise相加，或者（2）沿滤波器维度两个隐藏状态之间的级联。为了使控制器RNN能够同时预测Normal Cell和Reduction Cell，只需使控制器总共有2×5B个预测，其中第一个5B预测用于Normal Cell，第二个5B预测用于Reduction Cell。最后，这项工作还是用了之前工作用到的强化学习方案。</p>
<h2 id="experiments">Experiments</h2>
<p>首先所有架构搜索都是在CIFAR-10分类任务上进行的。然后跟前一篇论文一样，还是用近端策略优化（PPO）训练RNN。实验用500个GPU（P100）跑了超过4天。</p>
<p>如图5所示是搜索得到的Normal Cell和Reduction Cell，可以看到深度可分离卷积的大量使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717155130.png" /></p>
<p>图5. 用CIFAR-10确定的B = 5个块的最佳卷积cell（NASNet-A）的体系结构。每个卷积单元都是B个块的结果。 单个块对应于两个基本操作（黄色）和一个组合操作（绿色）。</p>
<p>在学习了卷积cell之后，可以探索几个超参数来为给定任务构建最终网络：（1）cell重复次数N和（2）初始卷积cell中的滤波器数。 选择初始滤波器的数量之后，只要stride为2，就将滤波器的数量加倍。</p>
<p>然后作者在训练NASNet时，又发现了ScheduledDropPath，作为DropPath的一个改进版本，是NASNet的一种有效的正则化方法。在Drop-Path中，训练过程中每条路径以固定的概率被随机丢弃。 在这个<u>改进版本的ScheduledDropPath中，cell中的每个路径以一个在训练过程中呈线性增加的概率被丢弃。</u></p>
<blockquote>
<p>这块有没有可能试着改进一下？</p>
</blockquote>
<h3 id="cifar-10分类任务结果">CIFAR-10分类任务结果</h3>
<p>如表1所示是实验结果，可以看到带cutout的大模型NASNet-A实现了SOTA的准确率</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717155624.png" style="zoom:50%;" /></p>
<h3 id="imagenet分类任务结果">ImageNet分类任务结果</h3>
<p>作者强调他们还是使用了CIFAR-10上的最优网络，只是在ImageNet上从头重新开始训练。表2、表3和图5分别展示了结果。基本上NASNet都实现了新的SOTA（不管是大模型亦或是轻量级模型），也实现了更好的trade-off。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717155710.png" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717155723.png" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717155818.png" /></p>
<h3 id="架构搜索方法的效率">架构搜索方法的效率</h3>
<p>文章还研究了强化学习在CIFAR-10图像分类问题上用于架构搜索的有效性，并将其与暴力随机搜索进行了比较（基于等量计算资源）。结果如图7所示，用RL获得的最佳模型明显优于RS发现的最佳模型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220717155925.png" style="zoom: 40%;" /></p>
<h2 id="summary">Summary</h2>
<p>本文提出的方法的关键见解是设计一个搜索空间，该空间将架构的复杂性与网络的深度分离。 由此产生的搜索空间可以在小型数据集（即CIFAR-10）上识别出良好的架构，并将学习到的架构迁移到一系列具有不同数据和计算规模的图像分类任务中去。与人工设计的架构相比，最终的架构在CIFAR-10和ImageNet数据集中的性能都达到或超过了SOTA的性能。同时，可以以更少的计算预算使用学习到的架构来执行ImageNet分类，并且超过了针对移动和嵌入式平台的简化架构。</p>
]]></content>
      <categories>
        <category>papers</category>
      </categories>
      <tags>
        <tag>RL-NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Aging Evolution】Regularized Evolution for Image Classifier Architecture Search</title>
    <url>/2022/07/17/%E3%80%90Aging%20Evolution%E3%80%91Regularized%20Evolution%20for%20Image%20Classifier%20Architecture%20Search/</url>
    <content><![CDATA[<h1 id="Regularized-Evolution-for-Image-Classifier-Architecture-Search"><a href="#Regularized-Evolution-for-Image-Classifier-Architecture-Search" class="headerlink" title="Regularized Evolution for Image Classifier Architecture Search"></a>Regularized Evolution for Image Classifier Architecture Search</h1><ul>
<li>AAAI 2019</li>
</ul>
<p>本文提出了老化进化Aging Evolution/Regularized Evolution。对标准锦标赛选择算法进行了修改，个体根据年龄被杀死，使得遗传算法更加偏爱年轻个体，本质就是一种正则化。实现了一组简单的突变，允许在NASNet搜索空间中进化，突变包括改变hidden state，或者改变option(conv、pool…)</p>
<h2 id="Thinking…"><a href="#Thinking…" class="headerlink" title="Thinking…"></a>Thinking…</h2><p>算法一开始需要随机初始化一批网络架构，有可能此类网络结构都是很糟糕的，没有利用任何先验知识，可能导致算法的运行结果很糟糕.</p>
<p>作者发现，output顶点中的入边数越高，架构性能越好。可以作为未来改进方向？</p>
<h2 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h2><ol>
<li>本文提出了老化进化Aging Evolution/Regularized Evolution。对标准锦标赛选择算法进行了修改，个体根据年龄被杀死，使得遗传算法更加偏爱年轻个体。</li>
<li>实现了一组简单的突变，允许在NASNet搜索空间中进化。该搜索空间将卷积神经网络结构与小有向图相关联，其中顶点表示隐藏状态，边表示常用的网络操作（如卷积或池化）。变异的操作有两种：改变hidden state，或者改变option。</li>
</ol>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Search-Space—NASNet"><a href="#Search-Space—NASNet" class="headerlink" title="Search Space—NASNet"></a>Search Space—NASNet</h3><p>这篇用了NASNet作为搜索空间。NASNet主要有两种motifis：</p>
<ol>
<li>Normal Cell：输出Feature Map和输入Feature Map的尺寸相同</li>
<li>Reduction Cell：输出Feature Map对输入Feature Map进行了一次降采样，其中特征图高度和宽度减少了两倍（用了stride=2）</li>
</ol>
<p>NASNet主要由这两种cell构成。它们之间的唯一区别是Reduction Cell 减小了图像大小，而Normal Cell 保留了图像大小。每个cell接收来自上一个cell的直接输入和来自上上一个cell的跳跃输入。架构搜索过程的目标是这两种cell的架构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220718130522.png" style="zoom:50%;" /></p>
<p>右图，每个cell有两个input activation tensors和一个output。cell由5个blocks组成，以虚线圈为例。1个block有两个隐藏状态作为输入，两个输入最开始是input images的两个copies，之后的cell的输入就是前两个cell的输出。两个隐藏状态分别选择两个操作op，op在一个固定集合中。最后选择一种方法来组合两个op的输出以创建新的隐藏状态。这就是一个block的过程。重复5次，也就是5个blocks后，就产生了一个cell。最后生成的网络体系结构就是由两种cell组成。一旦指定了结构，该模型仍然有两个自由参数可用于改变其大小（及其精度）：Normal Cell数（N）和卷积运算的输出滤波器数（F）。N和F是手动确定的。</p>
<blockquote>
<p>关于NASNet的详细介绍可以看<a href="https://stuxiaozhang.github.io/2022/07/16/%E3%80%90NASNet%E3%80%91Learning%20transferable%20architectures%20for%20scalable%20image%20recognition/">这篇笔记</a>。</p>
</blockquote>
<h4 id="Cell结构的理解"><a href="#Cell结构的理解" class="headerlink" title="Cell结构的理解"></a>Cell结构的理解</h4><p>为什么要选择两个特征图（隐藏状态），对其进行op操作后相加呢？</p>
<p>在某些情况下，这其实是一个残差结构，意味着在NASNet Search Space中进行搜索时，算法会自动探索如何添加残差结构，但是这种残差结构不一定就是何凯明大佬论文中所说的直接映射后相加，而是更加的灵活，可以是直接映射相加，也可以是施加了op操作相加，例如右图所示的0、1、3节点，就是经典的残差结构（0号节点比1号节点浅，1号节点通过avg操作得到一个新的特征图，设为temp，temp与比自己要浅的0号节点相加，就是一个经典的残差结构）</p>
<blockquote>
<p>什么时候我能有这样的理解呢？唉</p>
</blockquote>
<h3 id="Evolutionary-Algorithm"><a href="#Evolutionary-Algorithm" class="headerlink" title="Evolutionary Algorithm"></a>Evolutionary Algorithm</h3><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220718161652.png" style="zoom: 67%;" /></p>
<ol>
<li><p>首先，随机初始化种群，（完全）随机生成P个网络结构。然后生成size为P大小的种群。训练并评估。</p>
</li>
<li><p>然后，每个cycle，从种群中随机选择S个个体形成候选父代种群Sample。</p>
</li>
<li>从这个候选父代种群中，选择适应度值最高的作为父代个体。进行mutate的操作。生成新的子代个体，对其进行训练和评估适应度值。将其加入到种群中，即队列的最右侧</li>
<li>去除种群中年龄“最大”的神经网络，其实就是队列最左边的元素</li>
</ol>
<h4 id="Aging-Evolution"><a href="#Aging-Evolution" class="headerlink" title="Aging Evolution"></a>Aging Evolution</h4><p>原始的锦标赛选择算法是，移除候选父代种群Sample中最差的模型，作者把这种方法称为 non-aging evolution。作者改进了锦标赛选择算法，移除种群中最老的模型，把这种方法称为 aging evolution。老化进化允许更多地探索搜索空间，而不是像非老化进化那样过早地放大 好的模型。关于改进的锦标赛选择算法选择几个，$S=1$ 时简化为随机搜索，$2\le S \le P$ 导致不同贪婪程度的进化。 </p>
<p>Aging evolution算法模拟了自然界中的物种繁衍的操作</p>
<ol>
<li>自然界中，表现优异的个体往往更加容易留下后代。Aging evolution算法通过采样形成一个候选集，选择候选集中准确率最高的神经网络（表现最优异的个体）进行繁衍，以此模拟这个过程</li>
<li>在自然界中，年轻的个体相比于年老的个体一般具有更好的潜能，更有可能留下后代。Aging evolution算法每次会去除种群中一个最老的个体，并加入一个新个体，以此模拟这个过程</li>
<li>在自然界中，后代往往会遗传父母的一些特征，并在此基础上进行变异。Aging evolution算法选定一个神经网络，对该神经网络进行MUTATE操作，得到的新神经网络的结构既有与父母神经网络相同的部分（遗传），又有不同的部分（变异），以此模拟这个过程</li>
</ol>
<h4 id="为什么Aging-Evolution表现好"><a href="#为什么Aging-Evolution表现好" class="headerlink" title="为什么Aging Evolution表现好"></a>为什么Aging Evolution表现好</h4><p>作者认为Aging Evolution有利于抵抗训练噪声，训练噪声是指某些模型由于运气好，达到了较高的准确率，这种准确率并不是由于网络架构好引起的，在锦标赛算法中，此类模型可能存在于整个算法运行过程中，留下大量后代，由于后代更多，算法会更加偏好于此类架构，从而减少对于搜索空间的充分探索，而在Aging Evolution中，模型不断更新换代，即使某一类架构由于运气好达到了较好的准确率，最终也会被淘汰，并且采样数S的存在意味着运气好的架构不一定就能留下后代。</p>
<p>由于种群更新换代的速度很快，种群整体更新频繁，只有让自己的后代不断保持较好的准确率，该类网络架构才能长期存在于种群之中，一定程度上抵抗训练噪声，即正则化。因此，Aging Evolution更加关注模型的架构，而不是模型本身，因为再高准确率的模型最终也会被淘汰</p>
<p>论文构造了一个Toy Search space，在该搜索空间上使用了Aging Evolution，最终取得了较好的结果，由此证明了上述猜测</p>
<blockquote>
<p>所以这个Aging Evolution又叫Regularized Evolution，就是一种正则化方式。</p>
</blockquote>
<h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>关于突变主要有两种hidden state mutation，op mutation。其实还有identity（应该是保持不变吧）。</p>
<ul>
<li>hidden state mutation：首先随机选择是normal cell or reduction cell。选中后，在该cell的5个blocks中随机选择一个，再在该block中随机选择一个hidden state，被cell中的其他hidden state代替，注意不会形成环loop。</li>
<li>op mutation：选择方式同上，只是这回在block中随机选择一个option，在option集合中随机一个替换。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220718170620.png" style="zoom:50%;" /></p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220718172828.png" alt=""></p>
<p>Reinforcement Learning (RL)、Random Search (RS)和本文的进化方法对比：</p>
<ul>
<li><p>右图可以看到，aging evolution的速度比RL和RS要快，并且探索到的模型准确率较高</p>
</li>
<li><p>左图展示的是测试精度和模型计算成本。与RS相比，进化后的体系结构有类似的浮点运算量，但是精度更高。与RL相比，进化后的体系结构有类似的精度，但是有更低的浮点运算量。</p>
</li>
</ul>
<p>将验证精度最高的进化架构成为AmoebaNet-A，结构如下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220718172922.png" alt=""></p>
<p>作者说AmoebaNet-A在CIFAR-10的验证精度最高。将AmoebaNet-A与其他模型在ImageNet数据集上一同比较：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220718172933.png" alt=""></p>
<p>AmoebaNet-A与相同数量的参数下的baseline表现相当。</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>Aging Evolution</tag>
      </tags>
  </entry>
  <entry>
    <title>生成对抗网络 GAN</title>
    <url>/2021/09/17/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%20GAN/</url>
    <content><![CDATA[<h1 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h1><p>生成对抗网络（GAN），是深度学习模型之一，2014年 lan Goodfellow 的开篇之作 <a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1406.2661">Generative Adversarial Network</a>，GAN 是一种无监督学习方法，它巧妙地利用“对抗”的思想来学习生成式模型，一旦训练完成后可以生成全新的数据样本。DCGAN 将 GAN 的概念扩展到卷积神经网络中，可以生成质量较高的图片样本。</p>
<h2 id="GAN-概述"><a href="#GAN-概述" class="headerlink" title="GAN 概述"></a>GAN 概述</h2><p>GAN包括两个模型，一个是<strong>生成模型 G</strong>（Generator），一个是<strong>判别模型 D</strong>（Discriminator）。他们分别的功能是：</p>
<ul>
<li>Generator 负责生成图片，他接收一个随机的噪声 z，通过该噪声生成图片，将生成的图片记为 G(z)</li>
<li>Discriminator 负责判别一张图片是不是“真实的”。它的输入是xx，xx 代表一张图片，输出 D(x) 表示 x 为真实图片的概率，如果为1，代表是真实图片的概率为100%，而输出为0，代表不可能是真实的图片（真实实例来源于数据集，伪造实例来源于生成模型）</li>
</ul>
<p>在训练过程中，生成模型 G 的目标是尽量生成看起来真的和原始数据相似的图片去欺骗判别模型 D。而判别模型 D 的目标是尽量把生成模型 G 生成的图片和真实的图片区分开来。这样，生成器试图欺骗判别器，判别器则努力不被生成器欺骗。两个模型经过交替优化训练，互相提升，G和 D 构成了一个动态的“<strong>博弈</strong>”，这是 GAN 的基本思想。</p>
<p>最后博弈的结果是什么？在最理想的状态下，G 可以生成足以“以假乱真”的图片 G(z)。对于 D 来说，它难以判定 G 生成的图片究竟是不是真实的，因此 D(G(z))=0.5。此时得到了一个生成式的模型 G，它可以用来生成图片。</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210917222743285.png" style="zoom:67%;" /></p>
<p>如上图所示，我们有两个网络，生成网络G（Generator）和判别网络D（Discriminator）。生成网络接收一个（符合简单分布如高斯分布或者均匀分布的）随机噪声输入，通过这个噪声输出图片，记做 G(z)。判别网络的输入是x，x代表一张图片，输出 D(x) 代表 x 为真实图片的概率。</p>
<h1 id="GAN模型优化训练"><a href="#GAN模型优化训练" class="headerlink" title="GAN模型优化训练"></a>GAN模型优化训练</h1><p><strong>目的</strong>：将一个随机高斯噪声zz通过一个生成网络G得到一个和真实数据分布 $p<em>data(x)$ 差不多的生成数据分布 $p_G(x;θ)$，其中 $θ$ 是网络参数，我们希望找到 $θ$ 使得 $p_G(x;θ)$ 和 $p</em>{data}(x)$ 尽可能的接近。</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210917220129102.png" style="zoom: 80%;" /></p>
<p>我们站在判别网络的角度想问题，首先判别器要能识别真实数据，同样也能识别出生成数据，在数学式子上的表达为 D(x)=1 和 D(G(z))=0。我们通过这两个式子，分别来构造 <strong>[正类]</strong>(判别出x属于真实数据) 和 <strong>[负类]</strong>(判别出G(z)属于生成数据) 的对数损失函数。</p>
<ul>
<li><strong>生成网络G的损失函数为 $log⁡(1−D(G(z)))$ 或者 $−logD(G(z))−log⁡D(G(z))$。</strong></li>
<li><strong>判别网络D的损失函数为 $−(log⁡D(x)+log⁡(1−D(G(z))))$。</strong></li>
</ul>
<p>我们从式子中解释对抗，损失函数的图像是一个类似于 y=log(x) 函数图形，x<0时，y>0，x=1时，y=0。生成网络和判别网络对抗（训练）的目的是使得各自的损失函数最小，生成网络G的训练希望 $D(G(z))$ 趋近于1，也就是正类，这样生成网络 G 的损失函数 $log⁡(1−D(G(z)))$ 就会最小。而判别网络的训练就是一个2分类，目的是让真实数据x的判别概率 D 趋近于1，而生成数据 G(z) 的判别概率 $D(G(z))$ 趋近于0，这是负类。</p>
<ul>
<li><strong>当判别网络遇到真实数据时</strong>：$E_{x∼pdata(x)}[log⁡D(x)]$，这个期望要取最大，只有当 D(x)=1 的时候，也就是判别网络判别出真实数据是真的。</li>
<li><strong>当判别网络遇到生成数据时</strong>：$E_{z∼Pz(z)}[log⁡(1−D(G(z)))]$，因为0&lt;概率&lt;1，且x&lt;1的对数为负，这个数学期望要想取最大值，则需要令 D(G(z))=0，D(G(z))=0 是判别器发现了生成数据 G(z) 是假的，</li>
</ul>
<p>结合以上两个概念，判别网络最大化目标函数为：</p>
<script type="math/tex; mode=display">
E_{x \sim p_{d a t}(x)}[\log D(x)]+E_{z \sim P z(z)}[\log (1-D(G(z)))]</script><p>然后我们将最优化式子表述为：$D<em>{G}^{*}=\arg \max </em>{D} V(G, D)$</p>
<p>现在剧情大反转，对于判别网络 D 而言，希望目标函数(判别公式 $V(D,G)$ 最大化，但对于生成网络 G，希望目标函数（判别公式 $V(D,G)$ 最小化，即你判别网络判别不出我是真数据还是生成数据。有趣的事情来了，那到底是希望这个目标函数最大化好呢，还是最小化好呢？</p>
<p>来打一架吧。整个训练的过程是一个迭代的过程，其实当我们求得最优的 $D_G^∗$ 即 $D=D_G^∗$，我们反过来把 $D=D_G^∗$ 代入上面的式子，来求最优(最小)的 G，即 $D_G^∗$。整个训练优化过程就是一个循环迭代过程。在原论文中 lan J.Goodfellow 更喜欢求解最优化价值函数的G和D以求解极大极小博弈：</p>
<script type="math/tex; mode=display">
\min _{G} \max _{D} V(D, G)=E_{\left.x \sim p_{d a t \&} x\right)}[\log D(x)]+E_{z \sim P z(z)}[\log (1-D(G(z)))]</script><p>式中：D是判别函数，x是真实数据，D(x)：判别真实数据的概率，D(G(z))：判别生成数据的概率</p>
<p>最后将最优化问题表达为：</p>
<script type="math/tex; mode=display">
G_{D}^{*}=\arg \max _{G} V\left(G, D_{G}^{*}\right)</script><p>其实极小极大博弈可以分开理解，即在给定 G 的情况下先最大化 $V(D,G)$ 而取 $D_G^∗$，然后固定 D，并最小化 $V(D,G)$ 而得到 $D_G^∗$。其中给定G，最大化 $V(D,G)$ 评估了真实数据和生成数据之间的差异或距离。</p>
<p>在这样的对抗过程中，会有几个过程，原论文中的图如下：</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20210917221654676.png" style="zoom:80%;" /></p>
<p>黑色线表示真实数据的分布，绿色线表示生成数据的分布，蓝色线表示生成数据在判别器中的分布效果.</p>
<p>对每个图逐一进行分析</p>
<p>（a）判别网络D还未经过训练，分类能力有限，有波动，但是真实数据x和生成数据G(z)还是可以的</p>
<p>（b）判别网络D训练的比较好，可以明显区分出生成数据G(z)。</p>
<p>（c）绿色的线与黑色的线偏移了，蓝色线下降了，也就是判别生成数据的概率下降了。</p>
<p>由于绿色线的目标是提升提升概率，因此会往蓝色线高的方向引动。那么随着训练的持续，由于G网络的提升，生成网络G也反过来影响判别网络D的分布。在不断循环训练判别网络D的过程中，判别网络的判别能力会趋于一个收敛值，从而达到最优。</p>
<script type="math/tex; mode=display">
D_{G}^{*}(x)=\frac{p_{d a t a}(x)}{p_{d a t a}(x)+p_{g}(x)}</script><p>因此随着 $p<em>g(x)$ 趋近于 $p</em>{data}(x)$，$D_G^*(x)$ 会趋近于 $\frac 1 2$，$\frac 1 2$ 的意思就是模棱两可，判别器已经分不清随是真实数据谁是生成数据，也就是图 d。</p>
<h2 id="GAN-的算法推导"><a href="#GAN-的算法推导" class="headerlink" title="GAN 的算法推导"></a>GAN 的算法推导</h2><p>深入了解，可继续阅读<a href="https://unclestrong.github.io/DeepLearning_LHY21_Notes/Notes_html/16_GAN_P3.html">李宏毅老师的课</a></p>
<p>想要深入时阅读这篇博客：<a href="https://www.cnblogs.com/LXP-Never/p/9706790.html">神经网络结构：生成式对抗网络（GAN）</a></p>
]]></content>
      <tags>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络入门</title>
    <url>/2021/12/27/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>按照飞桨训练营中对图学习的划分, 图学习算法可以分为三大类:</p>
<ol>
<li><strong>图游走类算法</strong>(图嵌入算法): DeepWalk, Node2Vec 等.</li>
<li><strong>图神经网络算法</strong>: GCN, GAT, GraphSAGE 等.</li>
<li><strong>知识图谱嵌入算法</strong>: TransE, TransR, RotatE 等.</li>
</ol>
<h2 id="图游走类模型"><a href="#图游走类模型" class="headerlink" title="图游走类模型"></a>图游走类模型</h2><p>获得 Node embeddings 后进行下游任务。那如何获得 Node embeddings？</p>
<p>图中的节点可以看作 NLP 中的词，节点序列可以联想成 NLP 中的句子。</p>
<h3 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Word2vec"></a>Word2vec</h3><p>图游走类模型最开始参考的就是 NLP 领域中的 Word2vec 算法。所以介绍一下 Word2vec ：</p>
<p>在 Word2Vec 中, <strong>中心词语义可以由周围上下文的词语义</strong>来”决定”。Word2Vec 包含：</p>
<ul>
<li><strong>两个算法模型</strong>：<strong>continuous bag-of-words（CBOW）</strong>和 <strong>skip-gram</strong>。CBOW 是根据中心词周围的上下文单词来预测该词的词向量。skip-gram 则相反，是根据中心词预测周围上下文的词的概率分布。</li>
<li><strong>两个训练方法</strong>：<strong>负采样（negative sampling）</strong>和<strong>层序 softmax（hierarchical softmax）</strong>。Negative sampling 通过抽取负样本来定义目标，hierarchical softmax 通过使用一个有效的树结构来计算所有词的概率来定义目标。</li>
</ul>
<blockquote>
<p>详情可以参考 <a href="https://stuxiaozhang.github.io/2021/07/29/CS224n%2001%20Introduction%20and%20Word%20Vectors/">这篇博客</a>。</p>
</blockquote>
<p>图游走类算法更多用到的是 Skip Gram 模型. Skip Gram 是一种根据中心词预测周围上下文的词的方法：</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105151021578.png" alt=""></p>
<p>在 Word2Vec 中, <strong>中心词语义可以由周围上下文的词语义</strong>来”决定”。同样，在图中的节点也可能受到邻居节点的影响。所以想到将 Word2Vec 算法迁移到图嵌入领域。</p>
<p>Word2Vec 整体框架如下：</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105151057686.png"   style="zoom: 50%;" /></p>
<h3 id="DeepWalk"><a href="#DeepWalk" class="headerlink" title="DeepWalk"></a>DeepWalk</h3><p>将 NLP 领域的思想运用到图嵌入领域。图的节点对应 NLP 的单词，图的节点序列对应 NLP 句子。通过在图上游走获得图的节点序列。</p>
<p>DeepWalk 就是简单的在图中做<strong>随机游走</strong>(Random Walk)，即在当前节点的邻近节点(包括<strong>自身</strong>)随机游走，当游走到<strong>最大长度</strong>时停止，所以它本质上就是在无向图上<strong>可以重复遍历的DFS</strong>。</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105151118597.png"  style="zoom: 50%;" /></p>
<p>对于一般的 随机游走公式：</p>
<script type="math/tex; mode=display">
{P}\left(c_{i}=x \mid c_{i-1}=v\right)=\left\{\begin{array}{cc}
\frac{\pi_{vx}}{Z}, & \text { if }(v, x) \in E \\
0, & \text { otherwise }
\end{array}\right.</script><p>其中，$v$ 是当前节点，$x$ 是选择的下一个节点，$Z$ 是归一化因子，$\pi<em>{vx}$ 是原始的概率分布，$\frac{\pi</em>{vx}}{Z}$ 是归一化后的转移概率分布。</p>
<p>对于 DeepWalk 来说，只要与节点 v 相邻，节点概率是相等的，所以有:</p>
<script type="math/tex; mode=display">
P\left(c_{i}=x \mid c_{i-1}=v\right)=\left\{\begin{array}{cc}
\frac{1}{|N(v)|}, & \text { if }(v, x) \in E \\
0, & \text { otherwise }
\end{array}\right.</script><p>DeepWalk 中，$\pi_{vx}=1$，$Z=|N(v)|$ 是节点的邻居个数。</p>
<p>DeepWalk 的框架与 Word2Vec 的区别就是多了一个随机游走的过程，随机游走后拿到了这个图的遍历序列，就能将它作为一个序列输入到 Word2Vec 中，就得到了节点的表示。</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105151138312.png"  style="zoom:50%;" /></p>
<p>对于图游走类算法，可以更多的关注图游走的方式这块。</p>
<h3 id="Node2vec"><a href="#Node2vec" class="headerlink" title="Node2vec"></a>Node2vec</h3><p>DeepWalk 存在一个问题：随机游走的方式比较简单直接，就是可以回头的 DFS 游走的一个过程。然而图是一个复杂结构，需要考虑很多因素。在 DeepWalk 中, 只考虑了使用 DFS 游走的方式。而在数据结构中可知，图的游走方式是有<strong>DFS</strong>和<strong>BFS</strong>两种的:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104164002009.png"  style="zoom: 67%;" /></p>
<p>在 Node2Vec 中，考虑了上述问题，希望能够让游走的方式更加丰富一点。只需要将图游走的一般公式做如下替换:</p>
<script type="math/tex; mode=display">
\pi_{vx} =\alpha_{pq}(t, x) \cdot w_{vx}</script><p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104164947865.png" style="zoom: 60%;" /></p>
<p>$v$ 为当前节点, $t$ 为上一个节点, $w<em>{vx}$ 为 $v$ 和 $x$ 之间的权值, 其中 $\alpha</em>{pq}(t, x)$ 为:</p>
<script type="math/tex; mode=display">
\alpha_{p q}(t, x)=\left\{\begin{array}{ll}
\frac{1}{p}, & \text { if } d_{t x}=0 \\
1, & \text { if } d_{t x}=1 \\
\frac{1}{q}, & \text { if } d_{t x}=2
\end{array}\right.</script><p>$d_{tx}$ 代表节点 $t$ 到 $x$ 的距离, 即当前节点 $v$ 的一阶邻居。而 $p,q$ 则是两个参数，它们能控制如何游走:</p>
<ul>
<li>$p$ 能控制有多大的概率”回头”, 即从当前节点 $v$ 重新回到前一节点 $t$, 如下图 $v→t$).</li>
<li>$q$ 控制游走策略倾向于 DFS 或是 BFS:<ul>
<li>$q&gt;1$ 时倾向于 BFS, 如下图 $v→x_1$.</li>
<li>$q&lt;1$ 时倾向于 DFS, 如下图 $v→x_2$.</li>
</ul>
</li>
<li>$p=q=1$ 时, $\pi<em>{vx}=w</em>{vx}$.</li>
</ul>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104173315702.png" alt=""></p>
<p>Node2Vec 的框架如下：</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105152305229.png"  style="zoom: 50%;" /></p>
<p>Node2Vec 这样游走有如下好处:</p>
<ol>
<li>结合了图的<strong>权重</strong>对游走的影响.</li>
<li>能够让模型<strong>自己学习</strong>如何游走合适(不是仅仅执行DFS, 也在某些时候BFS).</li>
</ol>
<h2 id="GNN"><a href="#GNN" class="headerlink" title="GNN"></a>GNN</h2><h3 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h3><p>在CV中的卷积被定义为: <strong>将某个像素点周围的像素以不同权重叠加起来</strong>. 那么扩展到图结构中, 对应的像素应该变为<strong>节点</strong>, <strong>即将某个节点周围的邻居以不同权重叠加起来</strong></p>
<p>二者区别在于：对于图像来说，周围像素点的个数是固定的。而对于图来说，节点周围的邻居节点数量是不固定的，这也是它复杂的原因。</p>
<p>于是就出现了两种方式来提取图的特征。一是空间域卷积（spatial domain)，二是频域卷积（spectral domain）。第一种方式由于每个顶点提取出来的 neighbors 不同，处理上比较麻烦，同时它的效果没有频域卷积效果好，没有做深究。因此，现在比较流行、工程上应用较多的为频域卷积。</p>
<p>以下图中的右上角的 graph 为例：</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104173713462.png" alt=""></p>
<p>其中：</p>
<ul>
<li><p>$\hat A$ 为图的自邻接矩阵(有节点自身的闭环, 即 $\tilde{A} = A + I$</p>
</li>
<li><p>$D$ 为度矩阵。（Note：矩阵的度的计算 包括入度和出度。）</p>
</li>
<li><p>$H^{(l)}$ 为第 $l$ 层的 GCN 的节点表示</p>
</li>
<li>$W^{(l)}$ 是权重矩阵（DNN）</li>
</ul>
<p>则 graph 所对应的邻接矩阵 $\tilde{A}$, 度矩阵 $\tilde{D}$ 分别为:</p>
<script type="math/tex; mode=display">
\tilde{A}=\begin{bmatrix}\color{red}{1}&\color{red}{1}&\color{red}{1}&0&0&0&0\\\color{red}{1}&\color{red}{1}&\color{red}{1}&0&0&0&0\\\color{red}{1}&\color{red}{1}&\color{red}{1}&\color{red}{1}&0&0&0\\0&0&\color{red}{1}&\color{red}{1}&\color{red}{1}&\color{red}{1}&\color{red}{1}\\0&0&0&\color{red}{1}&\color{red}{1}&\color{red}{1}&\color{red}{1}\\0&0&0&\color{red}{1}&\color{red}{1}&\color{red}{1}&0\\0&0&0&\color{red}{1}&\color{red}{1}&0&\color{red}{1}\end{bmatrix} \quad
\tilde{D}=\begin{bmatrix}\color{red}{3}&0&0&0&0&0&0\\0&\color{red}{3}&0&0&0&0&0\\0&0&\color{red}{4}&0&0&0&0\\0&0&0&\color{red}{5}&0&0&0\\0&0&0&0&\color{red}{4}&0&0\\0&0&0&0&0&\color{red}{3}&0\\0&0&0&0&0&0&\color{red}{3}\end{bmatrix}\</script><p>公式中所需要用到的 $\tilde{D}^{-\frac{1}{2}}$ 为如下矩阵:</p>
<script type="math/tex; mode=display">
\tilde{D}^{-\frac{1}{2}}=\begin{bmatrix}\color{red}{\frac{1}{\sqrt{3}}}&0&0&0&0&0&0\\0&\color{red}{\frac{1}{\sqrt{3}}}&0&0&0&0&0\\0&0&\color{red}{\frac{1}{\sqrt{4}}}&0&0&0&0\\0&0&0&\color{red}{\frac{1}{\sqrt{5}}}&0&0&0\\0&0&0&0&\color{red}{\frac{1}{\sqrt{4}}}&0&0\\0&0&0&0&0&\color{red}{\frac{1}{\sqrt{3}}}&0\\0&0&0&0&0&0&\color{red}{\frac{1}{\sqrt{3}}}\end{bmatrix}</script><p>为了方便理解更新方式，对<strong>图卷积计算公式</strong>先做如下方式的<strong>简化</strong>:</p>
<script type="math/tex; mode=display">
\begin{aligned}
H^{(l+1)}&=\sigma(\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}H^{(l)}W^{(l)})\\\ &\Downarrow \\\ H^{(l+1)}&=\sigma(\tilde{A}H^{(l)}W^{(l)})
\end{aligned}</script><p>即，<strong>先不考虑 度 对更新的影响</strong>。</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104173728466.png" alt=""></p>
<p>所以，$\tilde{A}H^{(l)}$ 的含义是：$l+1$ 层的第 0 节点表示是 $l$ 层第 0(自环), 1, 2 节点表示的和。</p>
<p>GCN 计算方式本质上跟 CNN 卷积过程一样，是一个加权求和的过程，就是将邻居节点通过度矩阵及其邻接矩阵，计算出各边的权重，然后加权求和。</p>
<p>在计算下一层节点表示的过程中, 隐含着一种机制(或是框架), <strong>消息传递</strong>:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104173754122.png" alt=""></p>
<p>0号点<strong>接收</strong>了来自0、1、2号节点的消息；然后进行<strong>聚合</strong>，对自身进行<strong>更新</strong>。</p>
<p>总结来说，消息传递方式实现图卷积网络的过程就是：</p>
<ol>
<li><strong>发送</strong>。边上的源节点，往目标节点发送消息(特征).</li>
<li><strong>接收</strong>。目标节点对收到的特征进行<strong>聚合</strong>，并更新自身。</li>
</ol>
<p>既然已经能够完成特征更新的整个流程, 为什么要引入 $\tilde{D}^{-\frac{1}{2}}$ 呢? 因为如果只使用邻接矩阵做加权, 周围人对你的评价可能并不是真实的:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104173915329.png" style="zoom: 50%;" /></p>
<p>例如新垣结衣的周围的人非常多(<strong>度非常大</strong>)，她的特征可能会因为对多人的评价而变得非常大，从而对你的评价可能就不那么准确，在训练时也容易导致梯度消失或梯度爆炸。相反，可能你的好友更加的了解你(<strong>度比较小</strong>), 对你的评价也更准确。对所有节点一视同仁会导致度大的节点特征越来越大，度小的节点越来越小。</p>
<p>因此, 我们可以使用<strong>度</strong>来衡量邻居信息的<strong>重要性</strong>, 这里的 $\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}$ 在做的事情实际上是用度矩阵对 $\tilde{A}$ 做了<strong>Renormalization</strong>:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104173835589.png" alt=""></p>
<p>度 d 越大, 信息就越少, $\frac{1}{\sqrt{d}}$ 就越小.</p>
<blockquote>
<p>这里采用<strong>Renormalization</strong>是有说法的, 想深入了解可以看 <a href="https://www.zhihu.com/question/426784258/answer/1536731121">GCN中的拉普拉斯矩阵如何归一化？</a>.</p>
<p>之所以没有采用”对称归一化”这个说法, 是因为矩阵并没有真正的得到归一化, 原论文中的表述也是”Renormalization”…</p>
</blockquote>
<p>下面来总结一下 GCN 的流程:</p>
<ol>
<li><p>使用 $\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}$ 进行节点之间的<strong>特征传递</strong>:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105153028136.png" style="zoom:50%;" /></p>
</li>
<li><p>对每一个节点做一次线性变换并且激活:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105153039440.png"  style="zoom:50%;" /></p>
</li>
<li><p><strong>重复</strong>上面两步多次, 实现多层GCN, 并能获得每个节点的表示：</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105153056016.png" alt=""></p>
</li>
<li><p>根据取得的节点表示 $H^{(l)}$ 将其用于<strong>下游任务</strong>:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105153122751.png" style="zoom:60%;" /></p>
</li>
</ol>
<p>GCN首次提出了卷积的方式融合图结构特征，提供一个全新的视角。</p>
<p>主要缺点：</p>
<ol>
<li>融合时边权值是固定的，不够灵活。</li>
<li>可扩展性差，因为它是全图卷积融合，全图做梯度更新，当图比较大时，这样的方式就太慢了，不合适。</li>
<li>层数加深时，结果会极容易平滑，每个点的特征结果都十分相似。</li>
</ol>
<blockquote>
<p>详细的数学推导可以看 <a href="https://zhuanlan.zhihu.com/p/107162772">图卷积网络（GCN）入门详解</a></p>
</blockquote>
<h3 id="GAT"><a href="#GAT" class="headerlink" title="GAT"></a>GAT</h3><p>在GCN中的边权重是通过<strong>度</strong>来控制的, 这种度量仅与度有关, 而且不可学习权重的分配方式.</p>
<p>在深度学习背景下, 我们更希望能够模型能够<strong>自己学习</strong>如何分配权重. 在深度学习中, 关于学习权重分配的分配方式, 人们很自然而然的就想到了<strong>Attention</strong>, 它也确实非常适合去做这件事情. <strong>图注意力网络</strong>(<strong>G</strong>raph <strong>At</strong>tention Network, <strong>GAT</strong>)应运而生.</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104210607354.png" style="zoom:50%;" /></p>
<p>GAT 通过对调整当前节点 $i$ 与其他节点 $j$ 之间的关系的权重来调整, 在这里只考虑节点 $i$ 的<strong>一阶邻居</strong> $j\in N<em>i$, 则 节点 $i$ 与节点 $j$ 之间的关系的权重 $e</em>{ij}$ 为:</p>
<script type="math/tex; mode=display">
e_{i j}=a\left(\mathbf{W} \vec{h}_{i}, \mathbf{W} \vec{h}_{j}\right)</script><p>GAT 中的 <strong>注意力系数 Attention coefficient</strong> 计算方式如下:</p>
<script type="math/tex; mode=display">
\displaylines{
\alpha_{i j}=\operatorname{softmax}_{j}\left(e_{i j}\right)=\frac{\exp \left(e_{i j}\right)}{\sum_{k \in \mathcal{N}_{i}} \exp \left(e_{i k}\right)}
\\\ \Downarrow \\
\alpha_{i j}=\frac{\exp \left(\operatorname{LeakyReLU}\left(\overrightarrow{\mathbf{a}}^{T}\left[\mathbf{W} \vec{h}_{i} || \mathbf{W} \vec{h}_{j}\right]\right)\right)}{\sum_{k \in \mathcal{N}_{i}} \exp \left(\text { LeakyReLU }\left(\overrightarrow{\mathbf{a}}^{T}\left[\mathbf{W} \vec{h}_{i} || \mathbf{W} \vec{h}_{k}\right]\right)\right)}
}</script><p>其中 $\overrightarrow{\mathbf{a}}$ 是一个权重向量, 也可以被视作是一个<strong>单层神经网络</strong>, $\mathbf{W}$ 为权重矩阵, 能够学习到输入特征 $\overrightarrow{h}$ 中更高级的特征. GAT 计算各节点的高阶特征, 后计算各节点对当前节点的重要程度, 并经过 LeakyReLU 激活, 最后用 Softmax 做归一化, 求得 注意力系数:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104211854226.png"  style="zoom: 33%;" /></p>
<p>对特征的聚合方式如下:</p>
<script type="math/tex; mode=display">
\vec{h}_{i}^{\prime}=\sigma\left(\sum_{j \in \mathcal{N}_{i}} \alpha_{i j} \mathbf{W} \vec{h}_{j}\right)</script><p>$\sigma$ 是非线性的激活函数.</p>
<p>与 Transformer 一样, GAT 也支持<strong>多头特征聚合</strong>:</p>
<script type="math/tex; mode=display">
\vec{h}_{i}^{\prime}=\operatorname{\lVert}\limits_{k=1}^{K} \sigma\left(\sum_{j \in \mathcal{N}_{i}} \alpha_{i j}^{k} \mathbf{W}^{k} \vec{h}_{j}\right)</script><p>其中 $||$ 代表 Concatenation. 即将多个头的特征 Concat 起来. 当然也可以采用求平均的方式来适应不同的场景:</p>
<script type="math/tex; mode=display">
\vec{h}_{i}^{\prime}=\sigma\left(\frac{1}{K} \sum_{k=1}^{K} \sum_{j \in \mathcal{N}_{i}} \alpha_{i j}^{k} \mathbf{W}^{k} \vec{h}_{j}\right)</script><p>GAT 总体来说如下所示:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220104213525395.png"  style="zoom:40%;" /></p>
<p>图中三种颜色的线代表有三个头, 学习到了不同的权重分配方式, 最后再通过某种聚合方式聚合获得 $\overrightarrow{h_1^\prime}$.</p>
<p>因此, GAT 不但将权重调整为与两个节点都相关的函数, 而且系数权重还是可学习的, 它同样遵守<u>消息传递框架</u></p>
<h3 id="Message-Passing"><a href="#Message-Passing" class="headerlink" title="Message Passing"></a>Message Passing</h3><p>消息传递是对图神经网络更新权重方式的一种<strong>范式</strong>或是一种<strong>框架</strong>。GCN、GAT 都是基于邻居聚合的模型 称为 Spatial (空间) GNN, 大部分的 Spatial GNN 都可以用 Message Passing实现</p>
<p>基于消息传递的 Graph Neural Network的通用公式如下:</p>
<script type="math/tex; mode=display">
h_{l}^{(t)}(v)=\color{green}{f}\left(h_{l}^{(t-1)}, \color{red}{\mathcal{F}}\left\{\color{blue}{h_{l}^{(t-1)}(u) \mid u \in N(v)}\right\}\right)</script><p>其中 $h_{l}^{(t-1)}(u)$ 代表邻居的消息发送, $\mathcal{F}$ 代表聚合函数, 可以是 <strong>Max</strong>, <strong>Mean</strong>, <strong>Sum</strong> 等, $\mathcal{F}$ 对应神经网络, 可以是 MLP 或者其他结构. 在 GCN 中, $\mathcal{F}$ 是基于<strong>度</strong>的加权求和, 在GAT 中是基于 <strong>Attention</strong> 的加权求和</p>
<h2 id="Graph-Sampling"><a href="#Graph-Sampling" class="headerlink" title="Graph Sampling"></a>Graph Sampling</h2><p>前面 GCN 举例的图中，使用的图 $G$ 节点个数非常少，然而在实际问题中，一张图可能节点非常多，因此就没有办法一次性把整张图送入计算资源，所以应该使用一种有效的<strong>子图采样</strong>算法，从全图 $G$ 中采样出一个子图 $g$，这样就可以进行训练了</p>
<p>但子图采样并不是随机采样, 我们最起码要保证采样完后的图是<strong>连通</strong>的。例如下图中，左边采样的子图就是连通的，右边的子图不是连通的</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105103240882.png"  style="zoom:50%;" /></p>
<h3 id="GraphSAGE-SAmple-amp-aggreGatE"><a href="#GraphSAGE-SAmple-amp-aggreGatE" class="headerlink" title="GraphSAGE (SAmple &amp; aggreGatE)"></a>GraphSAGE (SAmple &amp; aggreGatE)</h3><p>GraphSAGE(<strong>SA</strong>mple &amp; aggre<strong>G</strong>at<strong>E</strong>) 主要分两步：<strong>采样、聚合</strong>、(节点预测)</p>
<p>假设有下面这么一张图, 我们需要求出0号节点的表示, 所以需要从0号节点开始采样:</p>
<ol>
<li><p><strong>采样</strong>的阶段首先选取一个点，然后随机选取这个点的一阶邻居，再以这些邻居为起点随机选择它们的一阶邻居。</p>
<p>因此首先随机选择 0 号节点的一阶邻居 2、4、5，然后<strong>随机</strong>选择 2 号节点的一阶邻居 8、9；4 号节点的一阶邻居 11、12；5 号节点的一阶邻居 13、15</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105103738578.png"  style="zoom: 60%;" /></p>
</li>
<li><p><strong>聚合</strong>具体来说就是直接将子图从全图中抽离出来，从最边缘的节点开始，一层一层向里<strong>更新</strong>节点</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105103840425.png" style="zoom:60%;" /></p>
</li>
<li><p>最后就可以通过采样获得的子图来做节点预测了.</p>
</li>
</ol>
<p>邻居采样有两个优点:</p>
<ol>
<li><p>极大减少了训练计算量.</p>
</li>
<li><p>在<strong>推断</strong>时允许新的节点的加入, 增强了<strong>泛化</strong>能力.</p>
<p>因为原本要更新一个节点需要它周围的所有邻居，而通过邻居采样之后，每个节点就不是由所有的邻居来更新它，而是部分邻居节点，所以具有比较强的泛化能力, 也就是所谓的 Inductive 能力.</p>
</li>
</ol>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105104530922.png"  style="zoom: 67%;" /></p>
<div class="note note-info">
            <p>关于 GraphSAGE 在 <strong>Inductive</strong> 上的能力讨论可以看 <a href="https://www.zhihu.com/question/409415383/answer/1361596817">这里</a>, 我个人是比较赞同答主的说法(但是有点没看懂T^T)。算法能否  Inductive 和 Transductive 仅取决于节点输入是否是 One Hot , 以及在更新节点表示时是否只依赖于局部子图.</p><blockquote><p>“Inductive learning” 意为归纳学习，“Transductive learning” 意为直推学习。</p></blockquote>
          </div>
<h3 id="PinSAGE"><a href="#PinSAGE" class="headerlink" title="PinSAGE"></a>PinSAGE</h3><p><strong>采样时只能选取真实的邻居节点吗？</strong>如果构建的是一个与虚拟邻居相连的子图有什么优点？PinSAGE 算法将会给我们解答</p>
<ul>
<li>PinSAGE 算法通过多次随机游走，按游走经过的<strong>频率</strong>选取邻居.</li>
</ul>
<p>例如下面以 0 号节点作为起始，随机进行了 4 次游走</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105112734715.png"  style="zoom:70%;" /></p>
<p>其中 5、10、11 三个节点出现的频率最高，因此我们将这三个节点与 0 号节点相连，作为 0 号节点的虚拟邻居</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105112819870.png"  style="zoom:70%;" /></p>
<p>回到上述问题，采样时选取虚拟邻居有什么好处？</p>
<p><strong>可以快速获取高阶邻居的信息。</strong>实际上如果是按照 GraphSAGE 算法的方式生成子图，在聚合的过程中，非一阶邻居的信息可以通过消息传递逐渐传到中心，但是随着距离的增大，离中心越远的节点，其信息在传递过程中就越困难，甚至可能无法传递到；如果按照 PinSAGE 算法的方式生成子图，有一定的概率可以将非一阶邻居与中心直接相连，这样就可以快速聚合到多阶邻居的信息</p>
<h2 id="Neighborhood-Aggregation"><a href="#Neighborhood-Aggregation" class="headerlink" title="Neighborhood Aggregation"></a>Neighborhood Aggregation</h2><p>邻居聚合是在图采样之后做的操作, 不同的聚合方式可以达到不同效果. 经典的聚合函数有:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105114426271.png"  style="zoom: 50%;" /></p>
<p>栗：Max：特征维度对应的地方进行比较，比如第 0 位置上的max为 1，第 1 位置上的max也为 1</p>
<p>评估聚合表达能力的指标是<strong>单射(一对一映射)</strong>, 单射能保证对聚合以后的结果<strong>可区分</strong>:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105114516651.png" alt=""></p>
<p>两个子图分别进行 Mean、Max得出的结果相同，说明是不可区分的。对于不同的子图, Sum 保留了单射能力:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105114645993.png" style="zoom: 50%;" /></p>
<p>因此, 就有基于单射的 GIN(<strong>G</strong>raph <strong>I</strong>somorphism <strong>N</strong>et)模型:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105114753035.png" style="zoom:67%;" /></p>
<p>它的聚合方式就是具有单射能力的<strong>SUM</strong>, 但是为了区分中心节点与邻居, 特意加上了 $\mathcal{E}$:</p>
<p><img src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20220105114742148.png"  style="zoom:67%;" /></p>
<p>当然, GCN, GAT这类的聚合函数都是相较于经典聚合函数更为复杂的.</p>
]]></content>
      <tags>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>【PNAS】Progressive Neural Architecture Search</title>
    <url>/2022/07/19/%E3%80%90PNAS%E3%80%91Progressive%20Neural%20Architecture%20Search/</url>
    <content><![CDATA[<h1 id="progressive-neural-architecture-search">Progressive Neural Architecture Search</h1>
<ul>
<li>ECCV 2018</li>
</ul>
<p>这篇文章还是出自Google，进一步改善之前发表在AAAI2019的论文<a href="http://128.84.4.27/abs/1802.01548">《Regularized Evolution for Image Classiﬁer Architecture Search》</a>里所提出的方法的搜索速度。</p>
<blockquote>
<p><a href="https://stuxiaozhang.github.io/2022/07/17/%E3%80%90Aging%20Evolution%E3%80%91Regularized%20Evolution%20for%20Image%20Classifier%20Architecture%20Search/">关于《Regularized Evolution for Image Classiﬁer Architecture Search》简单的阅读笔记。</a></p>
</blockquote>
<h2 id="basic-idea">Basic Idea</h2>
<p>这篇文章提出了一种新的学习CNN架构的方法，比最近基于强化学习和进化算法的SOTA的方法更高效。本文的方法使用了基于序列模型的优化（SMBO）策略，在该策略中，按照增加复杂性的顺序搜索结构，同时学习代理模型以引导结构空间搜索。在相同搜索空间下的直接比较表明，就评估的模型数量而言，本文提出的方法的效率比之前NASNet用到的RL方法高5倍，而就总计算而言则高了8倍。然后搜索到的结构在CIFAR-10和ImageNet上也达到了SOTA的分类精度。</p>
<h2 id="method">Method</h2>
<p>NASNet的搜索空间（任务）是搜索一个好的卷积Cell，而不是一个完整的CNN。一个Cell包含B个blocks，其中一个block是应用于两个输入（张量）的组合运算符（例如相加），每个输入（张量）可以在组合之前进行变换（例如，卷积）。然后，根据训练集的大小和最终CNN所需的运行时间，将该单元结构堆叠一定次数。</p>
<h3 id="search-space">Search Space</h3>
<h4 id="cell-topologies">Cell Topologies</h4>
<p>实际一个cell就是一个完全卷积的网络，它将一个<span class="math inline">\(H\times W\times F\)</span>张量映射到另一个<span class="math inline">\(H&#39;\times W&#39;\times F&#39;\)</span>张量（自然stride=1时<span class="math inline">\(H、W、F\)</span>与<span class="math inline">\(H&#39;、W&#39;、F&#39;\)</span>就是一样的，stride=2时则有<span class="math inline">\(H&#39; = H / 2、W &#39;= W / 2、F&#39; =F/ 2\)</span>）。</p>
<p>cell可以由由B个块组成的DAG（有向无环图）表示，每个块是从2个输入张量到1个输出张量的映射。可以将一个cell中的块b指定为5元组(<span class="math inline">\((I_{1};I_{2};O_{1};O_{2};C)\)</span>，其中<span class="math inline">\(I_{1},I_{2}\in \mathcal{I}_{b}\)</span>指定块的输入，<span class="math inline">\(O_{1},O_{2}\in \mathcal{O}\)</span>指定应用于输入<span class="math inline">\(I_{i}\)</span>的操作，<span class="math inline">\(C\in \mathcal{C}\)</span>指定如何将<span class="math inline">\(O_{1}\)</span>和<span class="math inline">\(O_{2}\)</span>组合以生成与该块输出相对应的特征图（张量），用<span class="math inline">\(H_{b}^{c}\)</span>表示。可能的输入的集合<span class="math inline">\(\mathcal{I}_{b}\)</span>是这个cell中所有先前块的集合<span class="math inline">\(\{H_{1}^{c},\dots,H_{b-1}^{c}\}，\)</span>加上先前cell的输出<span class="math inline">\(H_{B}^{c-1}\)</span>，加上更先前单元的输出<span class="math inline">\(H_{B}^{c-2}\)</span>。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220719143837.png" alt="这里引用一下NASNet的图" /><figcaption>这里引用一下NASNet的图</figcaption>
</figure>
<p>算子空间<span class="math inline">\(\mathcal{O}\)</span>是以下8个函数的集合（比NASNet的少是因为去掉了一些没用到的函数），每个函数对一个张量进行运算：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220719132755.png" /></p>
<p>可能的组合运算符<span class="math inline">\(\mathcal{C}\)</span>的空间，NASNet中同时考虑了元素级相加（elementwise addition）和级联（concatenation）。但因为NASNet的结果中并没有使用到级联，所以为了减少搜索空间，总是使用加法作为组合运算符。也就是说一个块可以减少为用一个4元组表示。</p>
<p>第b个块的可能结构的空间为<span class="math inline">\(\mathcal{B}_{b}\)</span>；其大小<span class="math inline">\(|\mathcal{B}_{b}|=|\mathcal{I}_{b}|^{2}\times|\mathcal{O}|^{2}\times|\mathcal{C}|\)</span>，其中<span class="math inline">\(|\mathcal{I}_{b}|=(2+b-1)∣,|\mathcal{O}|=8\)</span>和<span class="math inline">\(|\mathcal{C}|=1\)</span>。对于b=1，有<span class="math inline">\(\mathcal{I}_{1}=\{H_{B}^{c-1},H_{B}^{c-2}\}\)</span>，这是前两个cell的 最终输出，因此有<span class="math inline">\(|\mathcal{B}_{1}\)</span>个可能的块结构。如果允许最多<span class="math inline">\(B=5\)</span>个块的cell，那么cell结构的总数由<span class="math inline">\(|\mathcal{B}_{1:5}|=2^{2}\times 8^{2} \times 3^{2}\times 8^{2} \times 4^{2}\times 8^{2} \times 5^{2}\times 8^{2} \times 6^{2}\times 8^{2}=5.6\times 10^{14}\)</span>给出。但是，此空间存在一定的对称性，可将其修剪到更合理的大小。事实上cell的总数约为<span class="math inline">\(10^{12}\)</span>。这比NASNet中使用的搜索空间（<span class="math inline">\(10^{18}\)</span>）小得多，但是它仍然是一个非常大的搜索空间，需要高效的优化方法。</p>
<h4 id="从cell到cnn">从cell到CNN</h4>
<p>要评估一个cell需要将其转换为CNN。 为此使用stride=1或stride=2堆叠预定数量的基本cell（具有相同的结构，但未固定权重），如图1（右）所示。然后相应地调整stride=2的cell之间的stride=1的cell的数量，最多重复N次。 在网络的顶部使用全局平均池化，然后使用softmax分类层。 然后在数据集上训练堆叠模型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220719145318.png" /></p>
<p>图1. 左：由渐进神经体系结构搜索发现的最佳cell结构，包括5个块。 右：在CIFAR-10和ImageNet上，由cell构建CNN时，采用与NASNet类似的策略。 注意这里学习的是单个cell的类型，而不区分Normal Cell和Reduction Cell。</p>
<p>CNN的整体构建过程与NASNet相同，只是这里只使用一种cell类型（不区分Normal Cell和Reduction Cell，而是通过使用stride为2的Normal Cell来模拟Reduction Cell），cell搜索空间稍小（因为使用较少的算子和合并操作）。</p>
<h3 id="progressive-neural-architecture-search-1">Progressive Neural Architecture Search</h3>
<p>许多先前的方法直接在完整cell或更糟糕的是完整的CNN的空间中搜索。作者认为，在指数级的大搜索空间中直接搜索是困难的，特别是在一开始并不知道什么是好模型的时候。</p>
<p>因此作者建议按先搜索最简单模型的递进顺序搜索空间。首先从<span class="math inline">\(\mathcal{B}_{1}\)</span>开始构造所有可能的cell结构（即由1个块组成），然后将它们添加到队列中。接着训练并评估队列中的所有模型（并行方式），然后通过添加<span class="math inline">\(\mathcal{B}_{2}\)</span>所有可能的块结构来扩展每个模型；这生成了一组<span class="math inline">\(|\mathcal{B}_{1}|\times|\mathcal{B}_{2}|=256\times 576=147,456\)</span>个深度为2的候选cell。因为负担不起训练和评估所有这些子网络的代价，所以这里用了一个学习到的<strong>预测函数</strong>（根据迄今为止访问过的cell的性能对其训练，且其训练和应用所需的时间可以忽略不计）。然后使用这个预测函数来评估所有候选cell，并选择K个最有希望的cell。将它们添加到队列中，并重复该过程，直到找到具有足够数量的块（B个）的cell。伪代码参见算法1，图2是一个示例。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220719114508.png" /></p>
<p>下图是当最大块数为B=3时PNAS搜索过程。此处<span class="math inline">\(S_b\)</span>表示具有B块的候选cells集。首先考虑具有1个块的所有单元，<span class="math inline">\(S_1=B_1\)</span>；训练和评估所有这些cells，并更新预测值。在迭代2中，将<span class="math inline">\(S_1\)</span>中的每个单元展开，以获得具有2个块的所有单元，<span class="math inline">\(S_2&#39;=B_{1:2}\)</span>，预测他们的分数，选择前K个得到<span class="math inline">\(S_2\)</span>，训练和评估他们，并更新预测值。在迭代3中，展开<span class="math inline">\(S_2\)</span>中的每个单元，以获得具有3个块的单元子集，<span class="math inline">\(S_3’⊆ B_{1:3}\)</span>，预测他们的分数，选择前K名获得<span class="math inline">\(S_3\)</span>，训练并评估他们，然后返回获胜者。<span class="math inline">\(B_b=| B_b |\)</span>是b级可能的块数，K是波束大小（在搜索树的每个级别上训练和评估的模型数）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220719151948.png" style="zoom:67%;" /></p>
<h3 id="基于代理模型的性能预测">基于代理模型的性能预测</h3>
<p>如上所述需要一种机制来预测cell的最终性能，然后才能真正训练它。这种预测器至少有三个期望的特性：</p>
<ul>
<li><em>处理可变大小的输入</em>：即需要预测器来处理可变长度的输入字符串。特别是，它应该能够预测任何具有b+1个块的cell的性能，即使它只在具有最多b个块的cell上训练过。</li>
<li><em>与真实性能相关</em>：事实上不一定要求低MSE，只需要预测器按照与真实性能值大致相同的顺序排列模型即可。</li>
<li><em>样本效率</em>：希望训练和评估尽可能少的cell，这意味着预测器的训练数据将是稀缺的</li>
</ul>
<p>要求预测器能够立即处理可变大小的字符串，RNN就可以。这里作者使用了LSTM读取长度为4b的序列（表示每个块的<span class="math inline">\(I_{1}、I_{2} O_{1}\)</span>和<span class="math inline">\(O_{2}\)</span>），每个步骤的输入是大小为<span class="math inline">\(|\mathcal{I}_{b}|\)</span>或<span class="math inline">\(|\mathcal{O}|\)</span>的一个one-hot向量，然后是嵌入查找（embedding lookup）。对tokens <span class="math inline">\(I_{1},I_{2}\in\mathcal{I}\)</span>使用维度D的共享嵌入，而对<span class="math inline">\(O_{1},O_{2}\in|\mathcal{O}|\)</span>使用另一个共享嵌入。最终的LSTM隐藏状态通过一个全连接层和sigmoid来回归验证精度。作者还尝试了一个更简单的MLP basline，如下所示将cell转换为一个固定长度的向量：将每个token嵌入到一个D维向量中，concat每个块的嵌入以获得一个4D维的向量，然后对块进行平均。</p>
<p>训练预测器时，一种方法是使用新的数据，通过几步SGD来更新预测器的参数。 但是，由于样本量很小，因此作者将5个预测器合为一组，每个预测器（从头开始）拟合搜索过程每一步可用数据的4/5。作者声称这减少了预测的方差。最后作者认为未来可以研究其他类型的预测器，例如具有字符串核的高斯过程，这可能可以更有效地训练和产生具有不确定性估计的预测。</p>
<blockquote>
<p>听不懂</p>
</blockquote>
<h2 id="summary">Summary</h2>
<p>这项工作的主要贡献是展示如何通过在日益复杂的搜索空间中使用渐进搜索，结合学习的预测函数，有效地识别最有希望探索的模型，来加速搜索良好的CNN结构。结果模型实现了与以前工作相同的性能水平，但计算成本很小。</p>
<p>未来的工作有很多可能的方向，包括：使用更好的代理predictor，例如string kernels的高斯过程；使用基于模型的早停止，因此可以在到达E1时代之前停止训练“无希望”的模型；使用“热启动”，从较小的父模型初始化训练较大的b+1模型；使用贝叶斯优化，其中我们使用获取函数，如预期改进或置信上限，对候选模型进行排序，而不是贪婪地挑选前K个；自适应地改变在每个步骤中评估的模型K的数量（例如，随着时间的推移减少）；速度-精度权衡的自动探索，等等。</p>
]]></content>
      <categories>
        <category>papers</category>
      </categories>
      <tags>
        <tag>PNAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis笔记</title>
    <url>/2022/08/03/Redis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Redis笔记"><a href="#Redis笔记" class="headerlink" title="Redis笔记"></a>Redis笔记</h1><p><strong><em>Redis</em></strong> 是典型的 <strong><em>NoSQL</em></strong> 数据库。是一个开源的 <strong><em>key-value</em></strong> 存储系统。</p>
<ul>
<li><p>和 <strong><em>Memcached</em></strong> 类似，它支持存储的 <strong><em>value</em></strong> 类型相对更多，包括 <strong><em>string、list、set、zset、sorted set、hash</em></strong>。</p>
</li>
<li><p>这些数据类型都支持 <strong><em>push/pop、add/remove</em></strong> 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
</li>
<li><p>在此基础上，<strong><em>Redis</em></strong> 支持各种不同方式的排序。</p>
</li>
<li><p>与 <strong><em>memcached</em></strong>一样，为了保证效率，数据都是缓存在内存中。</p>
</li>
<li><p>区别的是 <strong><em>Redis</em></strong> 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
</li>
<li><p>并且在此基础上实现了<strong><em>master-slave</em></strong> （主从）同步。</p>
</li>
<li><p>单线程 + <strong><em>IO</em></strong> 多路复用。</p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p>
</li>
<li><p><strong>串行 vs 多线程 + 锁（memcached） vs  单线程 + 多路 IO 复用 (Redis)</strong>（与 Memcache 三点不同：支持多数据类型，支持持久化，单线程 + 多路 IO 复用） 。</p>
</li>
<li><p>Redis优点：</p>
<ul>
<li>打破传统关系型数据库以业务逻辑为依据的存储模式，而针对不同数据结构类型改为以性能为最优先的存储方式。</li>
<li><p>减少CPU、IO压力，通过内存读取</p>
</li>
<li><p>NoSQL能够直接作为缓存使用，减少IO的读操作</p>
</li>
</ul>
</li>
</ul>
<h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><blockquote>
<p>安装 <strong><em>C</em></strong> 语言的编译环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum install centos-release-scl scl-utils-build<br>yum install -y devtoolset-8-toolchain<br>scl <span class="hljs-built_in">enable</span> devtoolset-8 bash<br></code></pre></td></tr></table></figure>
<p>通过 <strong><em>wget</em></strong> 下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget https://download.redis.io/releases/redis-6.2.6.tar.gz<br><br>// 下载路径：/opt<br></code></pre></td></tr></table></figure>
<p>解压至当前目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">tar -zxvf redis-6.2.6.tar.gz <br></code></pre></td></tr></table></figure>
<p>解压完成后进入目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis-6.2.6<br></code></pre></td></tr></table></figure>
<p>在当前目录下执行 <strong><em>make</em></strong></p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> &amp;&amp; <span class="hljs-built_in">make</span> install<br></code></pre></td></tr></table></figure>
<p>默认安装在 <code>/usr/local/bin</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何<br>redis-<span class="hljs-keyword">check</span>-aof：修复有问题的AOF文件，rdb和aof后面讲<br>redis-<span class="hljs-keyword">check</span>-dump：修复有问题的dump.rdb文件<br>redis-sentinel：Redis集群使用<br>redis-<span class="hljs-keyword">server</span>：Redis服务器启动命令<br>redis-cli：客户端，操作入口<br></code></pre></td></tr></table></figure>
<p>前台启动：<code>/usr/local/bin</code> 目录下启动 <strong><em>redis</em></strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">redis-server</span><span class="hljs-params">(前台启动)</span></span><br></code></pre></td></tr></table></figure>
<p>后台启动：</p>
<ul>
<li><p>安装 <strong><em>redis</em></strong> 的目录 <strong><em>/opt/redis-6.2.6</em></strong> 中将 <strong><em>redis.conf</em></strong> 复制到任意一个文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cp redis.conf /etc/redis.conf<br>// 将redis.conf复制到/etc/下<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改 <strong><em>/etc/redis.conf</em></strong> 配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">vim</span> <span class="hljs-string">redis.conf#</span> <span class="hljs-string">daemonize</span> <span class="hljs-literal">no</span> <span class="hljs-string">修改为</span> <span class="hljs-string">daemonize</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241224181.png" alt=""></p>
</li>
<li><p><strong><em>/usr/local/bin</em></strong> 目录下启动 <strong><em>redis</em></strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">redis-server <span class="hljs-regexp">/etc/</span>redis.conf<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>关闭 <strong><em>redis</em></strong></p>
<ul>
<li><strong><em>kill</em></strong> 进程</li>
<li>命令 <strong><em>shutdown</em></strong></li>
</ul>
</blockquote>
<p><u><strong>默认端口号：6379</strong></u></p>
<h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><p><strong><em>NoSQL（Not Only SQL）</em></strong> ，非关系型数据库</p>
<p><strong><em>NoSQL</em></strong> 不依赖业务逻辑方式存储，而以简单的 <strong><em>key-value</em></strong> 模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li>不遵循 <strong><em>SQL</em></strong> 标准。</li>
<li>不支持 <strong><em>ACID</em></strong>。</li>
<li>远超于 <strong><em>SQL</em></strong> 的性能。</li>
</ul>
<p><strong>适用于的场景</strong></p>
<ul>
<li>对数据高并发的读写；</li>
<li>海量数据的读写；</li>
<li>对数据高可扩展性的。</li>
</ul>
<p><strong>不适用的场景</strong></p>
<ul>
<li>需要事务支持；</li>
<li>基于 <strong><em>sql</em></strong> 的结构化查询存储，处理复杂的关系，需要即席查询。</li>
</ul>
<p>常见的 <strong><em>NoSQL</em></strong> 数据库</p>
<ul>
<li>Redis</li>
<li>MongoDB</li>
</ul>
<p>Redis 使用的是<strong>单线程 + 多路 IO 复用</strong>技术：</p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p>
<p>串行 vs <u>多线程 + 锁（memcached）</u> vs <u>单线程 + 多路 IO 复用 (Redis)</u>（与 Memcache 三点不同：<strong>Redis支持多数据类型；支持持久化；单线程 + 多路 IO 复用</strong>） 。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><strong><em>redis.conf</em></strong></p>
<h2 id="Units"><a href="#Units" class="headerlink" title="Units"></a><strong><em>Units</em></strong></h2><blockquote>
<p>单位，配置大小单位，开头定义了一些基本的度量单位，只支持 <strong><em>bytes</em></strong>，不支持 <strong><em>bit</em></strong>。</p>
<p>大小写不敏感。</p>
</blockquote>
<p><a href="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230368.png"><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230368.png" alt="img"></a></p>
<h2 id="INCLUDES"><a href="#INCLUDES" class="headerlink" title="INCLUDES"></a><strong><em>INCLUDES</em></strong></h2><blockquote>
<p>包含，多实例的情况可以把公用的配置文件提取出来。</p>
</blockquote>
<p><a href="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230370.png"><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241230370.png" alt="img"></a></p>
<h2 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a><strong><em>NETWORK</em></strong></h2><blockquote>
<p>网络相关配置。</p>
<p><strong><em>bind</em></strong></p>
<p>默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。</p>
<p>不写的情况下，无限制接受任何 <strong><em>ip</em></strong> 地址的访问。</p>
<p>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，所以需要将其注释掉。</p>
<p>如果开启了<strong><em>protected-mode</em></strong>，那么在没有设定 <strong><em>bind ip</em></strong> 且没有设密码的情况下，<strong><em>Redis</em></strong> 只允许接受本机的响应。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241231037.png" alt="img"></p>
<p><strong><em>protected-mode</em></strong></p>
<p>将本机访问保护模式设置 <strong><em>no</em></strong>。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241232546.png" alt="img"></p>
<p><strong><em>port</em></strong></p>
<p>端口号，默认 <strong><em>6379</em></strong>。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241232526.png" alt="img"></p>
<p><strong><em>tcp-backlog</em></strong></p>
<p>设置 <strong><em>tcp</em></strong> 的 <strong><em>backlog</em></strong>，<strong><em>backlog</em></strong> 其实是一个连接队列，<strong><em>backlog</em></strong> 队列总和 $=$ 未完成三次握手队列 $+$ 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高 <strong><em>backlog</em></strong> 值来避免慢客户端连接问题。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241233656.png" alt="img"></p>
<p><strong><em>timeout</em></strong></p>
<p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241233384.png" alt="img"></p>
<p><strong><em>tcp-keepalive</em></strong></p>
<p>对访问客户端的一种心跳检测，每个 <strong><em>n</em></strong> 秒检测一次。</p>
<p>单位为秒，如果设置为 0，则不会进行 <strong><em>Keepalive</em></strong> 检测，建议设置成 60。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241234246.png" alt="img"></p>
</blockquote>
<h2 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a><strong><em>GENERAL</em></strong></h2><blockquote>
<p>通用。</p>
<p><strong><em>daemonize</em></strong></p>
<p>是否为后台进程，设置为 <strong><em>yes</em></strong>。</p>
<p>守护进程，后台启动。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241235837.png" alt="img"></p>
<p><strong><em>pidfile</em></strong></p>
<p>存放 <strong><em>pid</em></strong> 文件的位置，每个实例会产生一个不同的 <strong><em>pid</em></strong> 文件。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241235968.png" alt="img"></p>
<p><strong><em>loglevel</em></strong></p>
<p>指定日志记录级别，<strong><em>Redis</em></strong> 总共支持四个级别：<strong><em>debug、verbose、notice、warning</em></strong>，默认为 <strong><em>notice</em></strong>。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241235383.png" alt="img"></p>
<p><strong><em>logfile</em></strong></p>
<p>日志文件名称。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241236971.png" alt="img"></p>
<p><strong><em>database</em></strong></p>
<p>设定库的数量 默认16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 <strong><em>id</em></strong>。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241236379.png" alt="img"></p>
</blockquote>
<h2 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a><strong><em>SECURITY</em></strong></h2><blockquote>
<p>安全。</p>
<p>访问密码的查看、设置和取消。</p>
<p>在命令中设置密码，只是临时的。重启 <strong><em>redis</em></strong> 服务器，密码就还原了。</p>
<p>永久设置，需要在配置文件中进行设置。</p>
</blockquote>
<h2 id="LIMITS"><a href="#LIMITS" class="headerlink" title="LIMITS"></a><strong><em>LIMITS</em></strong></h2><blockquote>
<p>限制。</p>
<p><strong><em>maxclients</em></strong></p>
<p>设置 <strong><em>redis</em></strong> 同时可以与多少个客户端进行连接。</p>
<p>默认情况下为 <strong><em>10000</em></strong> 个客户端。</p>
<p>如果达到了此限制，<strong><em>redis</em></strong> 则会拒绝新的连接请求，并且向这些连接请求方发出 <strong><em>max number of clients reached</em></strong> 以作回应。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241237488.png" alt="img"></p>
<p><strong><em>maxmemory</em></strong></p>
<p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p>
<p>设置 <strong><em>redis</em></strong> 可以使用的内存量。一旦到达内存使用上限，<strong><em>redis</em></strong> 将会试图移除内部数据，移除规则可以通过 <strong><em>maxmemory-policy</em></strong> 来指定。</p>
<p>如果 <strong><em>redis</em></strong> 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 <strong><em>redis</em></strong> 则会针对那些需要申请内存的指令返回错误信息，比如 <strong><em>SET、LPUSH</em></strong> 等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如 <strong><em>GET</em></strong> 等。如果你的 <strong><em>redis</em></strong> 是主 <strong><em>redis</em></strong>（ 说明你的 <strong><em>redis</em></strong> 有从 <strong><em>redis</em></strong> ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241237150.png" alt="img"></p>
<p><strong><em>maxmemory-policy</em></strong></p>
<p><strong><em>volatile-lru</em></strong>：使用 <strong><em>LRU</em></strong> 算法移除 <strong><em>key</em></strong>，只对设置了过期时间的键（最近最少使用）。</p>
<p><strong><em>allkeys-lru</em></strong>：在所有集合 <strong><em>key</em></strong> 中，使用 <strong><em>LRU</em></strong> 算法移除 <strong><em>key</em></strong>。</p>
<p><strong><em>volatile-random</em></strong>：在过期集合中移除随机的 <strong><em>key</em></strong>，只对设置了过期时间的键。</p>
<p><strong><em>allkeys-random</em></strong>：在所有集合 <strong><em>key</em></strong> 中，移除随机的 <strong><em>key</em></strong>。</p>
<p><strong><em>volatile-ttl</em></strong>：移除那些 <strong><em>TTL</em></strong> 值最小的 <strong><em>key</em></strong>，即那些最近要过期的 <strong><em>key</em></strong>。</p>
<p><strong><em>noeviction</em></strong>：不进行移除。针对写操作，只是返回错误信息。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241238328.png" alt="img"></p>
<p><strong><em>maxmemory-samples</em></strong></p>
<p>设置样本数量，<strong><em>LRU</em></strong> 算法和最小 <strong><em>TTL</em></strong> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<strong><em>redis</em></strong> 默认会检查这么多个 <strong><em>key</em></strong> 并选择其中 <strong><em>LRU</em></strong> 的那个。</p>
<p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241238581.png" alt="img"></p>
</blockquote>
<h1 id="常用五大基本数据类型"><a href="#常用五大基本数据类型" class="headerlink" title="常用五大基本数据类型"></a>常用五大基本数据类型</h1><h2 id="key操作"><a href="#key操作" class="headerlink" title="key操作"></a>key操作</h2><blockquote>
<p><code>keys *</code>：查看当前库所有 <strong><em>key</em></strong></p>
<p><code>exists key</code>：判断某个 <strong><em>key</em></strong> 是否存在</p>
<p><code>type key</code>：查看你的 <strong><em>key</em></strong> 是什么类型</p>
<p><code>del key</code> ：删除指定的 <strong><em>key</em></strong> 数据</p>
<p><code>unlink key</code>：根据 <strong><em>value</em></strong> 选择非阻塞删除，仅将 <strong><em>keys</em></strong> 从 <strong><em>keyspace</em></strong> 元数据中删除，真正的删除会在后续异步操作</p>
<p><code>expire key 10</code> ：为给定的 <strong><em>key</em></strong> 设置过期时间</p>
<p><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p><code>select</code>：命令切换数据库</p>
<p><code>dbsize</code>：查看当前数据库的 <strong><em>key</em></strong> 的数量</p>
<p><code>flushdb</code>：清空当前库</p>
<p><code>flushall</code>：通杀全部库</p>
</blockquote>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p><strong><em>String</em></strong> 类型是二进制安全的。意味着 <strong><em>Redis</em></strong> 的 <strong><em>string</em></strong> 可以包含任何数据。比如 <strong><em>jpg</em></strong> 图片或者序列化的对象。</p>
<p><strong><em>String</em></strong> 类型是 <strong><em>Redis</em></strong> 最基本的数据类型，一个 <strong><em>Redis</em></strong> 中字符串 <strong><em>value</em></strong> 最多可以是 512M。</p>
<blockquote>
<p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对</p>
<p><code>get &lt;key&gt;</code>：查询对应键值</p>
<p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 <strong><em><value></em></strong> 追加到原值的末尾</p>
<p><code>strlen &lt;key&gt;</code>：获得值的长度</p>
<p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 <strong><em>key</em></strong> 不存在时，设置 <strong><em>key</em></strong> 的值</p>
<p><code>incr &lt;key&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（<strong>具有原子性</strong>）</p>
<p><code>decr &lt;key&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1</p>
<p><code>incrby/decrby &lt;key&gt;&lt;步长&gt;</code>：将 <strong><em>key</em></strong> 中储存的数字值增减。自定义步长</p>
<p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code> ：同时设置一个或多个 <strong><em>key-value</em></strong> 对</p>
<p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...</code>：同时获取一个或多个 <strong><em>value</em></strong></p>
<p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;...</code>：同时设置一个或多个 <strong><em>key-value</em></strong> 对，当且仅当所有给定 <strong><em>key</em></strong> 都不存在。（原子性，有一个失败就都失败）</p>
<p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值的范围</p>
<p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：用 <strong><em>value</em></strong> 覆写 <strong><em>key</em></strong> 所储存的字符串值</p>
<p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒。</p>
<p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p>
</blockquote>
<p><strong>原子性</strong></p>
<p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作；</p>
<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 <strong><em>context switch</em></strong> （切换到另一个线程）。</p>
<ul>
<li>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li>
<li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li>
</ul>
<p><strong><em>Redis</em></strong> 单命令的原子性主要得益于 <strong><em>Redis的单线程</em></strong> 。</p>
<p><strong>数据结构</strong></p>
<p>String 的数据结构为简单动态字符串，是可以修改的字符串。内部结构实现上类似于 <strong><em>Java</em></strong> 的 <strong><em>ArrayList</em></strong>，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803153309.png" style="zoom:55%;" /></p>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p><strong><em>List</em></strong> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803182755.png" alt=""></p>
<blockquote>
<p><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边/右边插入一个或多个值。（我想象成一个双向的栈）</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803183843.png" alt=""></p>
<p><code>lpop/rpop &lt;key&gt;</code>：从左边/右边吐出一个值。值在键在，值光键亡。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220803185239.png" alt=""></p>
<p><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>：从 <strong><em>key1</em></strong> 列表右边吐出一个值，插到 <strong><em>key2</em></strong> 列表左边。</p>
<p><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>：按照索引下标获得元素（从左到右）</p>
<p><code>lrange mylist 0 -1 0</code>：左边第一个，-1右边第一个，（0 -1表示获取所有）</p>
<p><code>lindex &lt;key&gt;&lt;index&gt;</code>：按照索引下标获得元素（从左到右）</p>
<p><code>llen &lt;key&gt;</code>：获得列表长度</p>
<p><code>linsert &lt;key&gt; before/after &lt;value&gt;&lt;newvalue&gt;</code>：在 <strong><em>value</em></strong> 的前面/后面插入 <strong><em>newvalue</em></strong> 插入值</p>
<p><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>：从左边删除 <strong><em>n</em></strong> 个 <strong><em>value</em></strong>（从左到右）</p>
<p><code>ltrim &lt;key&gt;&lt;start&gt;&lt;end&gt;</code>：按照索引截取下标元素（从左到右）</p>
<p><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>：将列表 <strong><em>key</em></strong> 下标为 <strong><em>index</em></strong> 的值替换成 <strong><em>value</em></strong></p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><strong><em>List</em></strong> 的数据结构为快速链表 <strong><em>quickList</em></strong>。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <strong><em>ziplist</em></strong>，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成 <strong><em>quicklist</em></strong>。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 <strong><em>int</em></strong> 类型的数据，结构上还需要两个额外的指针 <strong><em>prev</em></strong> 和 <strong><em>next</em></strong>。</p>
<p><strong><em>Redis</em></strong> 将链表和 <strong><em>ziplist</em></strong> 结合起来组成了 <strong><em>quicklist</em></strong>。也就是将多个 <strong><em>ziplist</em></strong> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p><strong><em>Set</em></strong> 对外提供的功能与 <strong><em>List</em></strong> 类似列表的功能，特殊之处在于 <strong><em>Set</em></strong> 是可以 <strong>自动排重</strong> 的，当需要存储一个列表数据，又不希望出现重复数据时，<strong><em>Set</em></strong> 是一个很好的选择，并且 <strong><em>Set</em></strong> 提供了判断某个成员是否在一个 <strong><em>Set</em></strong> 集合内的重要接口，这个也是 <strong><em>List</em></strong> 所不能提供的。</p>
<p><strong><em>Redis</em></strong> 的 <strong><em>Set</em></strong> 是 <strong><em>String</em></strong> 类型的无序集合。它底层其实是一个 <strong><em>value</em></strong> 为 <strong><em>null</em></strong> 的 <strong><em>hash</em></strong> 表，所以添加，删除，查找的复杂度都是 <strong><em>O(1)</em></strong>。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是 <strong><em>O(1)</em></strong>，数据增加，查找数据的时间不变。</p>
<blockquote>
<p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code>：将一个或多个 <strong><em>member</em></strong> 元素加入到集合 <strong><em>key</em></strong> 中，已经存在的 <strong><em>member</em></strong> 元素将被忽略</p>
<p><code>smembers &lt;key&gt;</code>：取出该集合的所有值。</p>
<p><code>sismember &lt;key&gt;&lt;value&gt;</code>：判断集合 <strong><em><key></em></strong> 是否为含有该 <strong><em><value></em></strong> 值，有返回 1，没有返回 0</p>
<p><code>scard&lt;key&gt;</code>：返回该集合的元素个数。</p>
<p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code>：删除集合中的某个元素</p>
<p><code>spop &lt;key&gt;</code>：随机从该集合中吐出一个值</p>
<p><code>srandmember &lt;key&gt;&lt;n&gt;</code>：随机从该集合中取出 <strong><em>n</em></strong> 个值，不会从集合中删除</p>
<p><code>smove &lt;source&gt;&lt;destination&gt;value</code>：把集合中一个值从一个集合移动到另一个集合</p>
<p><code>sinter &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的交集元素</p>
<p><code>sunion &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的并集元素</p>
<p><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的差集元素（<strong><em>key1</em></strong> 中的，不包含 <strong><em>key2</em></strong> 中的）</p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><strong><em>Set</em></strong> 数据结构是字典，字典是用哈希表实现的。</p>
<h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p><strong><em>Redis hash</em></strong> 是一个键值对集合。</p>
<p><strong><em>Redis hash</em></strong> 是一个 <strong><em>String</em></strong> 类型的 <strong><em>field</em></strong> 和 <strong><em>value</em></strong> 的映射表，<strong><em>hash</em></strong> 特别适合用于存储对象。</p>
<blockquote>
<p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给 <strong><em><key></em></strong> 集合中的 <strong><em><field></em></strong> 键赋值 <strong><em><value></em></strong></p>
<p><code>hget &lt;key1&gt;&lt;field&gt;</code>：从 <strong><em><key1></em></strong> 集合 <strong><em><field></em></strong> 取出 <strong><em>value</em></strong></p>
<p><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code>： 批量设置 <strong><em>hash</em></strong> 的值</p>
<p><code>hexists &lt;key1&gt;&lt;field&gt;</code>：查看哈希表 <strong><em>key</em></strong> 中，给定域 <strong><em>field</em></strong> 是否存在</p>
<p><code>hkeys &lt;key&gt;</code>：列出该 <strong><em>hash</em></strong> 集合的所有 <strong><em>field</em></strong></p>
<p><code>hvals &lt;key&gt;</code>：列出该 <strong><em>hash</em></strong> 集合的所有 <strong><em>value</em></strong></p>
<p><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>：为哈希表 <strong><em>key</em></strong> 中的域 <strong><em>field</em></strong> 的值加上增量 1 -1</p>
<p><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：将哈希表 <strong><em>key</em></strong> 中的域 <strong><em>field</em></strong> 的值设置为 <strong><em>value</em></strong> ，当且仅当域 <strong><em>field</em></strong> 不存在</p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><strong><em>Hash</em></strong> 类型对应的数据结构是两种：<strong><em>ziplist</em></strong>（压缩列表），<strong><em>hashtable</em></strong>（哈希表）。</p>
<p>当 <strong><em>field-value</em></strong> 长度较短且个数较少时，使用 <strong><em>ziplist</em></strong>，否则使用 <strong><em>hashtable</em></strong>。</p>
<h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p><strong><em>Redis</em></strong> 有序集合 <strong><em>zset</em></strong> 与普通集合 <strong><em>set</em></strong> 非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（<strong><em>score</em></strong>）,这个评分（<strong><em>score</em></strong>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。</p>
<p>因为元素是有序的，所以可以很快的根据评分（<strong><em>score</em></strong>）或者次序（<strong><em>position</em></strong>）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p>
<blockquote>
<p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>：将一个或多个 <strong><em>member</em></strong> 元素及其 <strong><em>score</em></strong> 值加入到有序集 <strong><em>key</em></strong> 当中</p>
<p><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]</code>：返回有序集 <strong><em>key</em></strong> 中，下标在 <strong><em><start><stop></em></strong> 之间的元素</p>
<ul>
<li>当带 <strong><em>WITHSCORES</em></strong>，可以让分数一起和值返回到结果集</li>
</ul>
<p><code>zrangebyscore key min max [withscores] [limit offset count]</code>：返回有序集 <strong><em>key</em></strong> 中，所有 <strong><em>score</em></strong> 值介于 <strong><em>min</em></strong> 和 <strong><em>max</em></strong> 之间（包括等于 <strong><em>min</em></strong> 或 <strong><em>max</em></strong> ）的成员。有序集成员按 <strong><em>score</em></strong> 值递增（从小到大）次序排列。</p>
<p><code>zrevrangebyscore key max min [withscores] [limit offset count]</code>：同上，改为从大到小排列</p>
<p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code>：为元素的 <strong><em>score</em></strong> 加上增量</p>
<p><code>zrem &lt;key&gt;&lt;value&gt;</code>：删除该集合下，指定值的元素</p>
<p><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>：统计该集合，分数区间内的元素个数</p>
<p><code>zrank &lt;key&gt;&lt;value&gt;</code>：返回该值在集合中的排名，从 0 开始。</p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><strong><em>SortedSet（zset）</em></strong>是 <strong><em>Redis</em></strong> 提供的一个非常特别的数据结构，一方面它等价于 <strong><em>Java</em></strong> 的数据结构 <strong><em>Map<String, Double></em></strong>，可以给每一个元素 <strong><em>value</em></strong> 赋予一个权重 <strong><em>score</em></strong>，另一方面它又类似于 <strong><em>TreeSet</em></strong>，内部的元素会按照权重 <strong><em>score</em></strong> 进行排序，可以得到每个元素的名次，还可以通过 <strong><em>score</em></strong> 的范围来获取元素的列表。</p>
<p><strong><em>zset</em></strong> 底层使用了两个数据结构</p>
<ul>
<li><strong><em>hash</em></strong>，<strong><em>hash</em></strong> 的作用就是关联元素 <strong><em>value</em></strong> 和权重 <strong><em>score</em></strong>，保障元素 <strong><em>value</em></strong> 的唯一性，可以通过元素 <strong><em>value</em></strong> 找到相应的 <strong><em>score</em></strong> 值</li>
<li>跳跃表，跳跃表的目的在于给元素 <strong><em>value</em></strong> 排序，根据 <strong><em>score</em></strong> 的范围获取元素列表</li>
</ul>
<h1 id="Redis的发布与订阅"><a href="#Redis的发布与订阅" class="headerlink" title="Redis的发布与订阅"></a>Redis的发布与订阅</h1><p><strong><em>Redis</em></strong> 发布订阅（ <strong><em>pub/sub</em></strong> ）是一种消息通信模式：发送者（ <strong><em>pub</em></strong> ）发送消息，订阅者（ <strong><em>sub</em></strong> ）接收消息。</p>
<p><strong><em>Redis</em></strong> 客户端可以订阅任意数量的频道。</p>
<ol>
<li>客户端可以订阅频道</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220804093321.png" style="zoom:50%;" /></p>
<ol>
<li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220804093351.png" style="zoom:50%;" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">subscribe channel <span class="hljs-comment"># 订阅频道</span><br><br>publish channel hello <span class="hljs-comment"># 频道发送信息</span><br></code></pre></td></tr></table></figure>
<h1 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h1><p><strong><em>Redis</em></strong> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p><strong><em>Redis</em></strong> 事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p>
<h2 id="Multi、Exec、Discard"><a href="#Multi、Exec、Discard" class="headerlink" title="Multi、Exec、Discard"></a><em>Multi</em>、<em>Exec</em>、<em>Discard</em></h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220804140908.png" alt="202206241242519"></p>
<p><strong><em>Multi</em></strong></p>
<p><strong><em>Exec</em></strong></p>
<p><strong><em>Discard</em></strong></p>
<p>从输入 <strong><em>Multi</em></strong> 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 <strong><em>Exec</em></strong> 后，<strong><em>Redis</em></strong> 会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过 <strong><em>Discard</em></strong> 来放弃组队。</p>
<ul>
<li><p>组队成功，提交成功</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241243427.png" alt=""></p>
</li>
<li><p>放弃组队</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241243951.png" alt=""></p>
</li>
<li><p>组队中有命令错误，不会执行</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241244858.png" alt=""></p>
</li>
<li><p>组队中不报错，执行时报错</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241244271.png" alt=""></p>
</li>
</ul>
<p>当组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁（<strong><em>Pessimistic Lock</em></strong>），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 <strong><em>block</em></strong> 直到成功拿到锁。（效率低）</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁（<strong><em>Optimistic Lock</em></strong>），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制。</p>
<p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。</p>
<p><strong><em>Redis</em></strong> 就是利用这种 <strong><em>check-and-set</em></strong> 机制实现事务的。</p>
<h2 id="Watch、unwatch"><a href="#Watch、unwatch" class="headerlink" title="Watch、unwatch"></a><em>Watch、unwatch</em></h2><p>在执行 <strong><em>multi</em></strong> 之前，先执行 <strong><em>watch key1 [key2]</em></strong>，可以监视一个（或多个 ）<strong><em>key</em></strong> 。如果在事务执行之前这个 <strong><em>key</em></strong> 被其他命令所改动，那么事务将被打断。</p>
<p>取消 <strong><em>WATCH</em></strong> 命令对所有 <strong><em>key</em></strong> 的监视。如果在执行 <strong><em>WATCH</em></strong> 命令之后，<strong><em>EXEC</em></strong> 命令或 <strong><em>DISCARD</em></strong> 命令先被执行，那么就不需要再执行 <strong><em>UNWATCH</em></strong> 。</p>
<h2 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h2><ul>
<li><p>单独的隔离操作</p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>没有隔离级别的概念</p>
<p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p>
</li>
<li><p>不保证原子性</p>
<p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p>
</li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><p>RDB：在指定的时间间隔内将内存中的数据集快照写入磁盘， 即 <strong><em>Snapshot</em></strong> 快照，恢复时是将快照文件直接读到内存里。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241245966.png" style="zoom:50%;" /></p>
<p><strong><em>Redis</em></strong> 会单独创建一个子进程（<strong><em>fork</em></strong>）来进行持久化。先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件内容覆盖到 <strong><em>dump.rdb</em></strong>。</p>
<blockquote>
<p>这样做的目的是保证数据的完整性。假如直接同步过去，在同步时发生错误（比如服务器挂了），会造成数据缺失。</p>
<p>所以出现了这个技术：写时复制技术。</p>
</blockquote>
<p>整个过程中，主进程是不进行任何 <strong><em>IO</em></strong> 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 <strong><em>RDB</em></strong> 方式要比 <strong><em>AOF</em></strong> 方式更加的高效。</p>
<p><strong>RDB 的缺点是最后一次持久化后的数据可能丢失</strong>。</p>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul>
<li>作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li>
<li>在 <strong><em>Linux</em></strong> 程序中，<strong><em>fork()</em></strong> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <strong><em>exec</em></strong> 系统调用，出于效率考虑，<strong><em>Linux</em></strong> 中引入了 <strong>写时复制技术</strong></li>
<li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote>
<p><strong><em>dump</em> 文件名字</strong></p>
<p>在 <strong><em>redis.conf</em></strong> 中配置文件名称，默认为 <strong><em>dump.rdb</em></strong>。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241245089.png" alt="img"></p>
<p><strong><em>dump</em> 保存位置</strong></p>
<p><strong><em>rdb</em></strong> 文件的保存路径可以修改。默认为 <strong><em>Redis</em></strong> 启动时命令行所在的目录下。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241245951.png" alt="img"></p>
<p><strong><em>stop-writes-on-bgsave-error</em></strong></p>
<p>即当 <strong><em>redis</em></strong> 无法写入磁盘，关闭 <strong><em>redis</em></strong> 的写入操作。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241246038.png" alt="img"></p>
<p><strong><em>rdbcompression</em></strong></p>
<p>持久化的文件是否进行压缩存储。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241246917.png" alt="img"></p>
<p><strong><em>rdbchecksum</em></strong></p>
<p>完整性的检查，即数据是否完整性、准确性。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241247735.png" alt="img"></p>
<p><strong><em>save</em></strong></p>
<p>表示写操作的次数。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran">格式：<span class="hljs-keyword">save</span> 秒 写操作次数<br></code></pre></td></tr></table></figure>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241247583.png" alt="img"></p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>适合大规模的数据恢复；</li>
<li>对数据完整性和一致性要求不高更适合使用；</li>
<li>节省磁盘空间；</li>
<li>恢复速度快。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong><em>Fork</em></strong> 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑；</li>
<li>虽然 <strong><em>Redis</em></strong> 在 <strong><em>fork</em></strong> 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能；</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果 <strong><em>Redis</em></strong> 意外 <strong><em>down</em></strong> 掉的话，就会丢失最后一次快照后的所有修改。</li>
</ul>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>AOF：以日志的形式来记录每个写操作（增量保存），将 <strong><em>Redis</em></strong> 执行过的所有写指令记录下来（读操作不记录）， 只许追加文件但不可以改写文件，<strong><em>Redis</em></strong> 启动之初会读取该文件重新构建数据，换言之，如果 <strong><em>Redis</em></strong> 重启就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p><strong>执行流程</strong></p>
<ul>
<li>客户端的请求写命令会被 <strong><em>append</em></strong> 追加到 <strong><em>AOF</em></strong> 缓冲区内；</li>
<li><strong><em>AOF</em></strong> 缓冲区根据 <strong><em>AOF</em></strong> 持久化策略 <code>[always,everysec,no]</code> 将操作 <strong><em>sync</em></strong> 同步到磁盘的 <strong><em>AOF</em></strong> 文件中；</li>
<li><strong><em>AOF</em></strong> 文件大小超过重写策略或手动重写时，会对 <strong><em>AOF</em></strong> 文件 <strong><em>Rewrite</em></strong> 重写，压缩 <strong><em>AOF</em></strong> 文件容量；</li>
<li><strong><em>Redis</em></strong> 服务重启时，会重新 <strong><em>load</em></strong> 加载 <strong><em>AOF</em></strong> 文件中的写操作达到数据恢复的目的。</li>
</ul>
<p><strong><em>AOF</em></strong> 和 <strong><em>RDB</em></strong> 同时开启时，系统默认读取 <strong><em>AOF</em></strong> 的数据（数据不会存在丢失）</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><blockquote>
<p><strong><em>AOF</em> 默认不开启</strong></p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241248962.png" alt="img"></p>
<p><strong>文件名字</strong></p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241248396.png" alt="img"></p>
<p><strong><em>AOF</em> 同步频率设置</strong></p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241249139.png" alt="img"></p>
<p><strong><em>appendfsync always</em></strong></p>
<p> 始终同步，每次 <strong><em>Redis</em></strong> 的写入都会立刻记入日志；</p>
<p> 性能较差但数据完整性比较好。</p>
<p><strong><em>appendfsync everysec</em></strong></p>
<p> 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>
<p><strong><em>appendfsync no</em></strong></p>
<p> <strong><em>Redis</em></strong> 不主动进行同步，把同步时机交给操作系统。</p>
<p><strong><em>Rewrite</em> 压缩</strong></p>
<p>当 <strong><em>AOF</em></strong> 文件的大小超过所设定的阈值时，<strong><em>Redis</em></strong> 就会启动 <strong><em>AOF</em></strong> 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 <strong><em>bgrewriteaof</em></strong>。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241249997.png" alt="img"></p>
</blockquote>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>备份机制更稳健，丢失数据概率更低；</li>
<li>可读的日志文本，通过操作 <strong><em>AOF</em></strong> 稳健，可以处理误操作。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>比起 <strong><em>RDB</em></strong> 占用更多的磁盘空间；</li>
<li>恢复备份速度要慢；</li>
<li>每次读写都同步的话，有一定的性能压力；</li>
<li>存在个别 <strong><em>Bug</em></strong>，造成不能恢复。</li>
</ul>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><blockquote>
<p>官方推荐两个都启用。</p>
<p>如果对数据不敏感，可以选单独用 <strong><em>RDB</em></strong>。</p>
<p>不建议单独用 <strong><em>AOF</em></strong>，因为可能会出现 <strong><em>Bug</em></strong>。</p>
<p>如果只是做纯内存缓存，可以都不用。</p>
</blockquote>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主机数据更新后根据配置和策略， 自动同步到备机的 <strong><em>master/slaver</em></strong> 机制，<strong><em>Master</em></strong> 以写为主，<strong><em>Slaver</em></strong> 以读为主。主从复制节点间数据是全量的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805085119.png" style="zoom:50%;" /></p>
<p>作用：</p>
<ol>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复</li>
<li>一主多从！</li>
</ol>
<h2 id="搭建一主两从"><a href="#搭建一主两从" class="headerlink" title="搭建一主两从"></a>搭建一主两从</h2><ol>
<li>创建文件目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/opt/etc<br></code></pre></td></tr></table></figure>
<ol>
<li>将 <strong><em>redis.conf</em></strong> 复制到当前目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cp /etc/redis.conf /opt/etc/<br></code></pre></td></tr></table></figure>
<ol>
<li>创建 3 个 <strong><em>redis.conf</em></strong> 配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">redis6379.conf<br>redis6380.conf<br>redis6381.conf<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># redis6379.conf</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br><br><span class="hljs-comment"># redis6380.conf</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6380.pid<br>port 6380<br>dbfilename dump6380.rdb<br><br><span class="hljs-comment"># redis6381.conf</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6381.pid<br>port 6381<br>dbfilename dump6381.rdb<br>Copy<br></code></pre></td></tr></table></figure>
<ol>
<li>启动 3 台 <strong><em>redis</em></strong> 服务器</li>
</ol>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241250298.png" alt=""></p>
<ol>
<li>查看主机运行情况</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">info replication<br></code></pre></td></tr></table></figure>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241251598.png" alt=""></p>
<ol>
<li>配从不配主</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">slaveof  &lt;ip&gt;&lt;port&gt;<br><span class="hljs-comment"># 成为某个实例的从服务器</span><br></code></pre></td></tr></table></figure>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241251672.png" alt=""></p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241251039.png" alt=""></p>
<ol>
<li>再次查看主机运行情况</li>
</ol>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241252641.png" alt=""></p>
<p>成功搭建。</p>
<h2 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h2><p>主机 <strong><em>6379</em></strong>，从机 <strong><em>6380</em></strong> 和 <strong><em>6381</em></strong>。</p>
<ol>
<li>假设从机 <strong><em>6380</em></strong> 挂掉。</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">当<span class="hljs-number">6380</span>重启后，<span class="hljs-number">6380</span>不再是<span class="hljs-number">6379</span>的从机，而是作为新的<span class="hljs-literal">master</span>；<br>当再次把<span class="hljs-number">6380</span>作为<span class="hljs-number">6379</span>的从机加入后，从机会把数据从头到尾复制。<br></code></pre></td></tr></table></figure>
<ol>
<li>假设主机 <strong><em>6379</em></strong> 挂掉。</li>
</ol>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns"><span class="hljs-number">6380和6381</span>仍然是<span class="hljs-number">6379</span>的从机，不会做任何事；<br>当<span class="hljs-number">6379</span>重启后，依然是主服务器。<br></code></pre></td></tr></table></figure>
<h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241253497.png" style="zoom:50%;" /></p>
<p>上一个 <strong><em>slave</em></strong> 可以是下一个 <strong><em>slave</em></strong> 的 <strong><em>master</em></strong>，<strong><em>slave</em></strong> 同样可以接收其他 <strong><em>slave</em></strong>的连接和同步请求，那么该 <strong><em>slave</em></strong> 作为了链条中下一个的 <strong><em>master</em></strong>，可以有效减轻 <strong><em>master</em></strong> 的写压力，去中心化降低风险。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">slaveof &lt;ip&gt;&lt;port&gt;<br></code></pre></td></tr></table></figure>
<p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p>
<p>当某个 <strong><em>slave</em></strong> 宕机，后面的 <strong><em>slave</em></strong> 都没法备份。</p>
<p>即当主机挂掉，从机还是从机，但是无法继续写数据。</p>
<h2 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h2><p>当一个 <strong><em>master</em></strong> 宕机后，后面的 <strong><em>slave</em></strong> 可以立刻升为 <strong><em>master</em></strong>，其后面的 <strong><em>slave</em></strong> 不用做任何修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">slaveof no one<br></code></pre></td></tr></table></figure>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><strong>反客为主的自动版</strong>，即能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<ol>
<li>创建 <strong><em>sentinel.conf</em></strong> 文件</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/opt/</span>etc/sentinel.conf<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure>
<ol>
<li>配置哨兵</li>
</ol>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">sentinel<span class="hljs-built_in"> monitor </span>mymaster 172.16.88.168 6379 1<br><br><span class="hljs-comment"># mymaster：监控对象起的服务器名称</span><br><span class="hljs-comment"># 1：至少有多少个哨兵同意迁移的数量。 </span><br>Copy<br></code></pre></td></tr></table></figure>
<ol>
<li>启动哨兵</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">redis-sentinel  <span class="hljs-regexp">/opt/</span>etc/sentinel.conf <br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure>
<p><a href="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241253197.png"><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241253197.png" alt="img"></a></p>
<p>主机挂掉，会从机选举中产生新的主机。选举的规则。</p>
<h3 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h3><ul>
<li><p>根据优先级别，<strong><em>slave-priority/replica-priority</em></strong>，优先选择优先级靠前的。</p>
<p><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202206241253826.png" alt="img"></p>
</li>
<li><p>根据偏移量，优先选择偏移量大的。</p>
</li>
<li><p>根据 <strong><em>runid</em></strong>，优先选择最小的服务。</p>
</li>
</ul>
<h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在 <strong><em>master</em></strong> 上操作，然后同步更新到 <strong><em>slave</em></strong> 上，所以从 <strong><em>master</em></strong> 同步到 <strong><em>slave</em></strong> 从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<strong><em>slave</em></strong> 机器数量的增加也会使这个问题更加严重。</p>
<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><ul>
<li><strong><em>slave</em></strong> 启动成功连接到 <strong><em>master</em></strong> 后会发送一个 <strong><em>sync</em></strong> 命令（同步命令）。</li>
<li><strong><em>master</em></strong> 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<strong><em>master</em></strong> 将传送整个数据文件（<strong><em>rdb</em></strong>）到 <strong><em>slave</em></strong>，以完成一次完全同步。</li>
<li>当主服务进行写操作后，和从服务器进行数据同步。</li>
<li>全量复制：而 <strong><em>slave</em></strong> 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：<strong><em>master</em></strong> 继续将新的所有收集到的修改命令依次传给 <strong><em>slave</em></strong>，完成同步。</li>
<li>只要是重新连接 <strong><em>master</em></strong>，一次完全同步（全量复制）将被自动执行。</li>
</ul>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>容量不够，<strong><em>redis</em></strong> 如何进行扩容？</p>
<p>并发写操作， <strong><em>redis</em></strong> 如何分摊？</p>
<p>主从模式，薪火相传模式，主机宕机，导致 <strong><em>ip</em></strong> 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
<p>解决方法：</p>
<ul>
<li><p>代理主机（ <strong><em>之前</em></strong> ）</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805090723.png" alt=""></p>
</li>
<li><p>无中心化集群配置（ <strong><em>redis3.0</em></strong> ）</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805090746.png" alt="202206241255698"></p>
</li>
</ul>
<p><strong><em>Redis</em></strong> 集群实现了对 <strong><em>Redis</em></strong> 的水平扩容，即启动 <strong><em>N</em></strong> 个 <strong><em>Redis</em></strong> 节点，将整个数据库分布存储在这 <strong><em>N</em></strong> 个节点中，每个节点存储总数据的 <strong><em>1/N</em></strong> 。</p>
<p><strong><em>Redis</em></strong> 集群通过分区（<strong><em>partition</em></strong>）来提供一定程度的可用性（<strong><em>availability</em></strong>），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="redis-cluster-如何分配这六个节点"><a href="#redis-cluster-如何分配这六个节点" class="headerlink" title="redis cluster 如何分配这六个节点?"></a><em>redis cluster</em> 如何分配这六个节点?</h3><p>一个集群至少要有三个主节点。</p>
<p>选项 <code>--cluster-replicas 1</code>，表示希望为集群中的每个主节点创建一个从节点。</p>
<p>分配原则尽量保证每个主数据库运行在不同的 <strong><em>IP</em></strong> 地址，每个从库和主库不在一个 <strong><em>IP</em></strong> 地址上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805090840.png" style="zoom:50%;" /></p>
<h3 id="什么是-slots？"><a href="#什么是-slots？" class="headerlink" title="什么是 slots？"></a>什么是 <em>slots</em>？</h3><p>一个 <strong><em>Redis</em></strong> 集群包含 <strong><em>16384</em></strong> 个插槽（<strong><em>hash slot</em></strong>）， 数据库中的每个键都属于这 <strong><em>16384</em></strong> 个插槽的其中一个。</p>
<p>集群使用公式 <strong><em>CRC16(key) % 16384</em></strong> 来计算键 <strong><em>key</em></strong> 属于哪个槽， 其中 <strong><em>CRC16(key)</em></strong> 语句用于计算键 <strong><em>key</em></strong> 的 <strong><em>CRC16</em></strong> 校验和 。</p>
<p>集群中的每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：</p>
<ul>
<li>节点 <strong><em>A</em></strong> 负责处理 <strong><em>0</em></strong> 号至 <strong><em>5460</em></strong> 号插槽。</li>
<li>节点 <strong><em>B</em></strong> 负责处理 <strong><em>5461</em></strong> 号至 <strong><em>10922</em></strong> 号插槽。</li>
<li>节点 <strong><em>C</em></strong> 负责处理 <strong><em>10923</em></strong> 号至 <strong><em>16383</em></strong> 号插槽。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805091147.png" alt=""></p>
<h3 id="如何在集群中录入值？"><a href="#如何在集群中录入值？" class="headerlink" title="如何在集群中录入值？"></a>如何在集群中录入值？</h3><p>在 <strong><em>redis-cli</em></strong> 每次录入、查询键值，<strong><em>redis</em></strong> 都会计算出该 <strong><em>key</em></strong> 应该送往的插槽，如果不是该客户端对应服务器的插槽，<strong><em>redis</em></strong> 会报错，并告知应前往的 <strong><em>redis</em></strong> 实例地址和端口。</p>
<p><strong><em>redis-cli</em></strong> 客户端提供了 <strong><em>–c</em></strong> 参数实现自动重定向。</p>
<p>例如 <strong><em>redis-cli -c –p 6379</em></strong> 登入后，再录入、查询键值对可以自动重定向。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805084413.png" style="zoom: 67%;" /></p>
<h3 id="如何查询集群中的值？"><a href="#如何查询集群中的值？" class="headerlink" title="如何查询集群中的值？"></a>如何查询集群中的值？</h3><p>每个主机只能查询自己范围内部的插槽。</p>
<p><code>cluster keyslot &lt;key&gt;</code>：查询某个 <strong><em>key</em></strong> 的 <strong><em>slot</em> </strong>。</p>
<p><code>cluster countkeysinslot &lt;slot&gt;</code>：查询某个 <strong><em>slot</em></strong> 是否有值。</p>
<p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code>：返回 <strong><em>count</em></strong> 个 <strong><em>slot</em></strong> 槽中的键。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805091452.png" style="zoom:67%;" /></p>
<h3 id="故障恢复？"><a href="#故障恢复？" class="headerlink" title="故障恢复？"></a>故障恢复？</h3><blockquote>
<p>15秒超时是：在十五秒内，重启好，还是主机，否则就是从机。</p>
</blockquote>
<p>如果主节点下线？从节点能否自动升为主节点？注意：<strong><em>15</em></strong> 秒超时。</p>
<ul>
<li>当 <strong><em>6379</em></strong> 挂掉后，<strong><em>6380</em></strong> 成为新的主机。</li>
</ul>
<p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p>
<ul>
<li>当 <strong><em>6379</em></strong> 重启后，<strong><em>6379</em></strong> 成为 <strong><em>6380</em></strong> 的从机。</li>
</ul>
<p>如果所有某一段插槽的主从节点都宕掉，<strong><em>redis</em></strong> 服务是否还能继续?</p>
<ul>
<li>如果某一段插槽的主从都挂掉，而 <strong><em>cluster-require-full-coverage=yes</em></strong>，那么 ，整个集群都挂掉。</li>
<li>如果某一段插槽的主从都挂掉，而 <strong><em>cluster-require-full-coverage=no</em></strong>，那么，该插槽数据全都不能使用，也无法存储。</li>
</ul>
<p><code>redis.conf</code> 中的参数 <code>cluster-require-full-coverage</code></p>
<h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul>
<li>实现扩容；</li>
<li>分摊压力；</li>
<li>无中心配置相对简单。</li>
</ul>
<h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>多键操作是不被支持的；</li>
<li>多键的 <strong><em>Redis</em></strong> 事务是不被支持的。<strong><em>lua</em></strong> 脚本不被支持；</li>
<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至<strong><em>redis cluster</em></strong>，需要整体迁移而不是逐步过渡，复杂度较大。</li>
</ul>
<h1 id="Jedis操作Redis"><a href="#Jedis操作Redis" class="headerlink" title="Jedis操作Redis"></a>Jedis操作Redis</h1><p>即 <strong><em>Java</em></strong> 操作 <strong><em>Redis</em></strong>。</p>
<ol>
<li>依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>连接 <strong><em>Redis</em></strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.57.101&quot;</span>, <span class="hljs-number">6379</span>);<br>    String pong = jedis.ping();<br>    System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span> + pong);<br>    jedis.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><em>Key</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k3&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>);<br>Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>System.out.println(keys.size());<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br>	System.out.println(key);<br>&#125;<br>System.out.println(jedis.exists(<span class="hljs-string">&quot;k1&quot;</span>));<br>System.out.println(jedis.ttl(<span class="hljs-string">&quot;k1&quot;</span>));                <br>System.out.println(jedis.get(<span class="hljs-string">&quot;k1&quot;</span>));<br></code></pre></td></tr></table></figure>
<p><strong><em>String</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.mset(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>System.out.println(jedis.mget(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>));<br></code></pre></td></tr></table></figure>
<p><strong><em>List</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.lpush(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;lucy&quot;</span>, <span class="hljs-string">&quot;mary&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);<br>List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br>System.out.println(list);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>jack,mary,lucy</p>
</blockquote>
<p><strong><em>Set</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order01&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order03&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order04&quot;</span>);<br>Set&lt;String&gt; smembers = jedis.smembers(<span class="hljs-string">&quot;orders&quot;</span>);<br><span class="hljs-keyword">for</span> (String order : smembers) &#123;<br>	System.out.println(order);<br>&#125;<br>jedis.srem(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br></code></pre></td></tr></table></figure>
<p><strong><em>Hash</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.hset(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>System.out.println(jedis.hget(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>));<br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>map.put(<span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;13810169999&quot;</span>);<br>map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;atguigu&quot;</span>);<br>map.put(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;abc@163.com&quot;</span>);<br>jedis.hmset(<span class="hljs-string">&quot;hash2&quot;</span>,map);<br>List&lt;String&gt; result = jedis.hmget(<span class="hljs-string">&quot;hash2&quot;</span>, <span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br><span class="hljs-keyword">for</span> (String element : result) &#123;<br>	System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><em>zset</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">100d</span>, <span class="hljs-string">&quot;z3&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">90d</span>, <span class="hljs-string">&quot;l4&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">80d</span>, <span class="hljs-string">&quot;w5&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">70d</span>, <span class="hljs-string">&quot;z6&quot;</span>);<br><br>Set&lt;String&gt; zrange = jedis.zrange(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (String e : zrange) &#123;<br>	System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><ol>
<li>依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>配置文件 application.properties 配置 <strong><em>Redis</em></strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">#Redis服务器地址<br>spring.redis.host= ip<br>#Redis服务器连接端口<br>spring.redis.port=<span class="hljs-number">6379</span><br>#Redis数据库索引（默认为0）<br>spring.redis.database= <span class="hljs-number">0</span><br>#连接超时时间（毫秒）<br>spring.redis.timeout=<span class="hljs-number">1800000</span><br>#连接池最大连接数（使用负值表示没有限制）<br>spring.redis.lettuce.pool.max-active=<span class="hljs-number">20</span><br>#最大阻塞等待时间(负数表示没限制)<br>spring.redis.lettuce.pool.max-wait=-<span class="hljs-number">1</span><br>#连接池中的最大空闲连接<br>spring.redis.lettuce.pool.max-idle=<span class="hljs-number">5</span><br>#连接池中的最小空闲连接<br>spring.redis.lettuce.pool.min-idle=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<ol>
<li><strong><em>Redis</em></strong> 配置类（需要继承 <strong><em>CachingConfigurerSupport</em></strong>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CachingConfigurerSupport</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br>				<span class="hljs-comment">// key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br>				<span class="hljs-comment">// value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>				<span class="hljs-comment">// value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>				<span class="hljs-comment">// 解决查询缓存转换异常的问题</span><br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>				<span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        RedisCacheConfiguration config = <br>          RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>   .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="集群的-Jedis-开发"><a href="#集群的-Jedis-开发" class="headerlink" title="集群的 Jedis 开发"></a>集群的 <em>Jedis</em> 开发</h2><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p>
<p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisClusterTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>     Set&lt;HostAndPort&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;HostAndPort&gt;();<br>     set.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">&quot;172.16.88.168&quot;</span>,<span class="hljs-number">6379</span>)); <span class="hljs-comment">// 任何一个端口</span><br>     JedisCluster jedisCluster = <span class="hljs-keyword">new</span> JedisCluster(set);<br>     jedisCluster.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>     System.out.println(jedisCluster.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="应用问题解决"><a href="#应用问题解决" class="headerlink" title="应用问题解决"></a>应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805092950.png" alt=""></p>
<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><strong><em>key</em></strong> 对应的数据在数据源并不存在，每次针对此 <strong><em>key</em></strong> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</p>
<p>比如用一个不存在的用户 <strong><em>id</em></strong> 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p>造成现象：</p>
<ol>
<li>应用服务器压力变大（大量请求过来了）。</li>
<li><strong><em>redis</em></strong> 命中率下降（缓存中查不到） $\longrightarrow$ 一直查询数据库 。</li>
</ol>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p><strong>对空值缓存</strong></p>
<p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<strong><em>null</em></strong>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p>
</li>
<li><p><strong>设置可访问的名单（白名单）：</strong></p>
<p>使用 <strong><em>bitmaps</em></strong> 类型定义一个可以访问的名单，名单 <strong><em>id</em></strong> 作为 <strong><em>bitmaps</em></strong> 的偏移量，每次访问和 <strong><em>bitmap</em></strong> 里面的 <strong><em>id</em></strong> 进行比较，如果访问 <strong><em>id</em></strong> 不在 <strong><em>bitmaps</em></strong> 里面，进行拦截，则不允许访问。</p>
</li>
<li><p><strong>采用布隆过滤器</strong></p>
<p>布隆过滤器（<strong><em>Bloom Filter</em></strong>）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>将所有可能存在的数据哈希到一个足够大的 <strong><em>bitmaps</em></strong> 中，一个一定不存在的数据会被这个 <strong><em>bitmaps</em></strong> 拦截掉，从而避免了对底层存储系统的查询压力。</p>
</li>
<li><p><strong>进行实时监控</strong></p>
<p>当发现 <strong><em>Redis</em></strong> 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220805093556.png" style="zoom:50%;" /></p>
<p><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p>
<ol>
<li>数据库访问压力瞬间增大。</li>
<li><strong><em>redis</em></strong> 中没有出现大量 <strong><em>key</em></strong> 过期，<strong><em>redis</em></strong> 正常运行。</li>
<li>（即某个经常访问的 <strong><em>key</em></strong> 过期，突然有大量访问这个数据）</li>
</ol>
<h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p>预先设置热门数据</p>
<p>在 <strong><em>redis</em></strong> 高峰访问之前，把一些热门数据提前存入到 <strong><em>redis</em></strong> 里面，加大这些热门数据 <strong><em>key</em></strong> 的时长。</p>
</li>
<li><p>实时调整</p>
<p>现场监控哪些数据热门，实时调整 <strong><em>key</em></strong> 的过期时长。</p>
</li>
<li><p>使用锁</p>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多 <strong><em>key</em></strong> 缓存，前者则是某一个 <strong><em>key</em></strong>。</p>
<ol>
<li>数据库压力变大。</li>
<li>即极少的时间段，查询大量 <strong><em>key</em></strong> 的集中过期情况。</li>
</ol>
<h3 id="如何解决-2"><a href="#如何解决-2" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p><strong>构建多级缓存架构</strong></p>
<p><strong><em>nginx</em></strong> 缓存 + <strong><em>redis</em></strong> 缓存 + 其他缓存（<strong><em>ehcache</em></strong>等）</p>
</li>
<li><p><strong>使用锁或队列：</strong></p>
<p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p>
</li>
<li><p><strong>设置过期标志更新缓存：</strong></p>
<p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 <strong><em>key</em></strong> 的缓存。</p>
</li>
<li><p><strong>将缓存失效时间分散开：</strong></p>
<p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
</li>
</ul>
<hr>
<p>来自于</p>
<p><a href="https://zhangc233.github.io/2021/05/02/Redis/#Redis%E6%A6%82%E8%BF%B0">https://zhangc233.github.io/2021/05/02/Redis/#Redis%E6%A6%82%E8%BF%B0</a></p>
<p><a href="https://tsuiraku.com/2021/08/19/redis/#Redis">https://tsuiraku.com/2021/08/19/redis/#Redis</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记</title>
    <url>/2022/07/28/git/</url>
    <content><![CDATA[<h1 id="git-笔记">Git 笔记</h1>
<h2 id="git-介绍">Git 介绍</h2>
<p>Git 是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种项目。</p>
<p>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。 其性能优于 Subversion、 CVS、 Perforce 和 ClearCase 等版本控制工具。</p>
<p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p>
<h3 id="集中式版本控制工具">集中式版本控制工具</h3>
<p>集中化的版本控制系统诸如 CVS、 SVN 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
<p>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统， 要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p>这么做显而易见的<strong>缺点</strong>是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p>
<h3 id="分布式版本控制工具">分布式版本控制工具</h3>
<p>Git、 Mercurial、 Bazaar、 Darcs……</p>
<p><strong>像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）</strong>。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p>
<p>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷：</p>
<ol type="1">
<li>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li>
<li>每个客户端保存的也都是整个完整的项目（包含历史记录， 更加安全）</li>
</ol>
<h3 id="工作机制">工作机制</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220727163337.png" style="zoom:50%;" /></p>
<ul>
<li>工作区：本地代码所在磁盘目录</li>
<li>暂存区：工作区的代码需要添加到暂存区</li>
</ul>
<p>工作区相当于word,暂存区相当于没写完保存一下,本地库相当于将文档给指导老师看</p>
<h3 id="代码托管中心">代码托管中心</h3>
<p>代码托管中心是基于网络服务器的远程代码仓库，一般简单称为<strong>远程库</strong>。</p>
<ul>
<li>局域网
<ul>
<li>GitLab</li>
</ul></li>
<li>互联网
<ul>
<li>GitHub（外网）</li>
<li>Gitee 码云（国内网站）</li>
</ul></li>
</ul>
<h2 id="git-常用命令">Git 常用命令</h2>
<table>
<thead>
<tr class="header">
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>git config --global user.name 用户名</td>
<td>设置用户签名</td>
</tr>
<tr class="even">
<td>git config --global user.email 邮箱</td>
<td>设置用户email地址</td>
</tr>
<tr class="odd">
<td>git init</td>
<td>初始化本地库</td>
</tr>
<tr class="even">
<td>git status</td>
<td>查看本地库状态</td>
</tr>
<tr class="odd">
<td>git add 文件名</td>
<td>添加到暂存区</td>
</tr>
<tr class="even">
<td>git commit -m “日志信息” 文件名</td>
<td>提交到本地库</td>
</tr>
<tr class="odd">
<td>git reflog</td>
<td>查看历史记录</td>
</tr>
<tr class="even">
<td>git reset --hard 版本号</td>
<td>版本穿梭</td>
</tr>
</tbody>
</table>
<h3 id="设置用户签名">设置用户签名</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --global user.name abc <span class="hljs-comment">#有户名</span><br>git config --global user.email abc@123.com<br>12<br></code></pre></td></tr></table></figure>
<p>说明：<strong>签名的作用是区分不同操作者身份</strong>。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。 <strong>Git 首次安装必须设置一下用户签名，否则无法提交代码</strong>。</p>
<p><strong>注意</strong>： 这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</p>
<p>查看设置过用户签名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop<br>$ cat ~/.gitconfig<br>[user]<br>        name = abc<br>        email = abc@123.com<br>[core]<br>        quotepath = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<h3 id="初始化本地库">初始化本地库</h3>
<p>基本语法：<code>git init</code></p>
<p>案例实操：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo<br>$ git init<br>Initialized empty Git repository <span class="hljs-keyword">in</span> D:/mycode/git-space/git-demo/.git/<br><br><span class="hljs-comment"># 创建了一个名为.git非空隐藏文件夹</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ ls -al<br>total 4<br>drwxr-xr-x 1 HP 197121 0  7月 28 10:58 ./<br>drwxr-xr-x 1 HP 197121 0  7月 28 10:55 ../<br>drwxr-xr-x 1 HP 197121 0  7月 28 10:58 .git/<br>-rw-r--r-- 1 HP 197121 0  7月 28 10:56 假设这是一个项目.txt<br></code></pre></td></tr></table></figure>
<h3 id="查看本地库状态">查看本地库状态</h3>
<p>基本语法：<code>git status</code></p>
<p>案例实操：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首次查看（工作区没有任何文件）</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>nothing to commit (create/copy files and use <span class="hljs-string">&quot;git add&quot;</span> to track)<br><br><span class="hljs-comment"># 新增文件（hello.txt）</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ vim hello.txt<br><br><span class="hljs-comment"># 再次查看（检测到未追踪的文件）</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        hello.txt<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ cat hello.txt<br>hello!xiaozhang!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br></code></pre></td></tr></table></figure>
<h3 id="添加暂存区">添加暂存区</h3>
<p>基本语法：<code>git add 文件名</code></p>
<p>案例实操：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#添加至暂存区</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git add hello.txt<br>warning: LF will be replaced by CRLF <span class="hljs-keyword">in</span> hello.txt.<br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)<br>        new file:   hello.txt<br><br><span class="hljs-comment">#移除暂存区的hello.txt</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git rm --cached hello.txt<br>rm <span class="hljs-string">&#x27;hello.txt&#x27;</span><br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        hello.txt<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br><br><span class="hljs-comment"># 再次添加</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git add hello.txt<br>warning: LF will be replaced by CRLF <span class="hljs-keyword">in</span> hello.txt.<br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br><br></code></pre></td></tr></table></figure>
<h3 id="提交本地库">提交本地库</h3>
<p>基本语法：<code>git commit -m &quot;日志信息&quot; 文件名</code></p>
<p>案例实操：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git status<br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)<br>        new file:   hello.txt<br><br><span class="hljs-comment">#提交本地库</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git commit -m <span class="hljs-string">&quot;first commit&quot;</span> hello.txt<br>warning: LF will be replaced by CRLF <span class="hljs-keyword">in</span> hello.txt.<br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br>[master (root-commit) 9dfc5ca] first commit<br> 1 file changed, 9 insertions(+)<br> create mode 100644 hello.txt<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure>
<p>查看提交记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git reflog<br>9dfc5ca (HEAD -&gt; master) HEAD@&#123;0&#125;: commit (initial): first commit<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git <span class="hljs-built_in">log</span><br>commit 9dfc5ca533e71f33832ab69b25fe60c5abfc9931 (HEAD -&gt; master)<br>Author: stuxiaozhang &lt;zhangxinyan1999@126.com&gt;<br>Date:   Thu Jul 28 11:43:35 2022 +0800<br><br>    first commit<br></code></pre></td></tr></table></figure>
<h3 id="修改文件">修改文件</h3>
<p>修改hello.txt内容，<code>git status</code>会提示该文件修改过，还没有被添加到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ vim hello.txt<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ cat hello.txt<br>hello!xiaozhang!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!2222<br><br><span class="hljs-comment"># 提示 hello.txt 被修改过（modified）</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>        modified:   hello.txt<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br><br><span class="hljs-comment"># 将修改的文件再次添加暂存区</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git add hello.txt<br>warning: LF will be replaced by CRLF <span class="hljs-keyword">in</span> hello.txt.<br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)<br>        modified:   hello.txt<br><br><span class="hljs-comment"># 第2次提交</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git commit -m <span class="hljs-string">&quot;second commit&quot;</span><br>[master 55aafcd] second commit<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git reflog<br>55aafcd (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: second commit<br>9dfc5ca HEAD@&#123;1&#125;: commit (initial): first commit<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure>
<h3 id="版本穿梭">版本穿梭</h3>
<h4 id="查看历史版本">查看历史版本</h4>
<p>基本语法：</p>
<ul>
<li><code>git reflog</code> 查看版本信息</li>
<li><code>git log</code> 查看版本详细信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git reflog<br>637b4d1 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: third commit<br>1e7e073 HEAD@&#123;1&#125;: commit: second commit<br>97d2973 HEAD@&#123;2&#125;: commit (initial): first commit<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git <span class="hljs-built_in">log</span><br>commit 637b4d1132b393b277277e205657da39db0bb2ce (HEAD -&gt; master)<br>Author: stuxiaozhang &lt;zhangxinyan1999@126.com&gt;<br>Date:   Thu Jul 28 14:59:51 2022 +0800<br><br>    third commit<br><br>commit 1e7e0736e8a51fd6cd1d369d243bbded3dda7b83<br>Author: stuxiaozhang &lt;zhangxinyan1999@126.com&gt;<br>Date:   Thu Jul 28 14:59:02 2022 +0800<br><br>    second commit<br><br>commit 97d297350271b8edbe5ceb542a6dcd0f67ca0862<br>Author: stuxiaozhang &lt;zhangxinyan1999@126.com&gt;<br>Date:   Thu Jul 28 14:57:37 2022 +0800<br><br>    first commit<br><br></code></pre></td></tr></table></figure>
<p><strong>git log 与 git reflog 区别</strong></p>
<p><code>git log</code> 命令可以<strong>当前分支</strong>的提交记录，如果感觉太繁琐，可以加上参数 <code>--pretty=oneline</code>，只会显示版本号和提交时的备注信息。</p>
<p><code>git reflog</code> 可以查看<strong>所有分支</strong>的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）。例如，执行 <code>git reset --hard HEAD~1</code>，退回到上一个版本，用<code>git log</code>则是看不出来被删除的commitid，用<code>git reflog</code>则可以看到被删除的commitid，我们就可以买后悔药，恢复到被删除的那个版本。</p>
<h4 id="版本穿梭-1">版本穿梭</h4>
<p>基本语法：<code>git reset --hard 版本号</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先查看当前的历史记录</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git reflog<br>637b4d1 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: third commit<br>1e7e073 HEAD@&#123;1&#125;: commit: second commit<br>97d2973 HEAD@&#123;2&#125;: commit (initial): first commit<br><br><span class="hljs-comment"># 切换到 97d2973 版本，也就是第一次提交的版本</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git reset --hard 97d2973<br>HEAD is now at 97d2973 first commit<br><br><span class="hljs-comment"># 切换完毕之后再查看历史记录，当前成功切换到了 97d2973 版本</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git reflog<br>97d2973 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 97d2973<br>637b4d1 HEAD@&#123;1&#125;: commit: third commit<br>1e7e073 HEAD@&#123;2&#125;: commit: second commit<br>97d2973 (HEAD -&gt; master) HEAD@&#123;3&#125;: commit (initial): first commit<br><br><span class="hljs-comment"># 然后查看文件 hello.txt，发现文件内容回到第一版本</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ cat hello.txt<br>hello!xiaozhang!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br></code></pre></td></tr></table></figure>
<p><strong>Git 切换版本， 底层其实是移动的 HEAD 指针。</strong></p>
<h2 id="git-分支">Git 分支</h2>
<h3 id="什么是分支">什么是分支</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220728150828.png" /></p>
<p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来， 开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220728151209.png" style="zoom: 25%;" /></p>
<h3 id="分支的好处">分支的好处</h3>
<p>同时并行推进多个功能开发，提高开发效率。</p>
<p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p>
<h3 id="分支的操作">分支的操作</h3>
<table>
<thead>
<tr class="header">
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>git branch 分支名</td>
<td>创建分支</td>
</tr>
<tr class="even">
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr class="odd">
<td>git checkout 分支名</td>
<td>切换分支</td>
</tr>
<tr class="even">
<td>git merge 分支名</td>
<td>把指定的分支合并到当前分支上</td>
</tr>
</tbody>
</table>
<h4 id="查看分支">查看分支</h4>
<p>基本语法：<code>git branch -v</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git branch -v<br>* master 97d2973 first commit<br></code></pre></td></tr></table></figure>
<h4 id="创建分支">创建分支</h4>
<p>基本语法：<code>git branch 分支名</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git branch hot-fix<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git branch -v<br>  hot-fix 97d2973 first commit<br>* master  97d2973 first commit<br></code></pre></td></tr></table></figure>
<p>hot-fix 是<strong>刚创建的新的分支，并将主分支master的内容复制了一份</strong>。</p>
<h4 id="切换分支">切换分支</h4>
<p>基本语法：<code>git checkout 分支名</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git checkout hot-fix<br>Switched to branch <span class="hljs-string">&#x27;hot-fix&#x27;</span><br><br><span class="hljs-comment"># 切换到了刚创建的分支上</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ git branch -v<br>* hot-fix 97d2973 first commit<br>  master  97d2973 first commit<br></code></pre></td></tr></table></figure>
<p>切换分支后，在新分支修改文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ vim hello.txt<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ git add hello.txt<br><br><span class="hljs-comment"># 在hot-fix提交</span><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ git commit -m <span class="hljs-string">&quot;hot-fix first commit&quot;</span> hello.txt<br>[hot-fix d6680d5] hot-fix first commit<br> 1 file changed, 1 insertion(+)<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ cat hello.txt<br>hello!xiaozhang!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hot-fix 分支<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ git reflog<br>d6680d5 (HEAD -&gt; hot-fix) HEAD@&#123;0&#125;: commit: hot-fix first commit<br>97d2973 (master) HEAD@&#123;1&#125;: checkout: moving from master to hot-fix<br>97d2973 (master) HEAD@&#123;2&#125;: reset: moving to 97d2973<br>637b4d1 HEAD@&#123;3&#125;: commit: third commit<br>1e7e073 HEAD@&#123;4&#125;: commit: second commit<br>97d2973 (master) HEAD@&#123;5&#125;: commit (initial): first commit<br></code></pre></td></tr></table></figure>
<h4 id="创建分支和切换分支">创建分支和切换分支</h4>
<p>master、 hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD决定的。所以创建分支的本质就是多创建一个指针。</p>
<ul>
<li>HEAD 如果指向 master，那么我们现在就在 master 分支上。</li>
<li>HEAD 如果执行 hot-fix，那么我们现在就在 hot-fix 分支上。</li>
</ul>
<p>所以切换分支的本质就是移动 HEAD 指针。</p>
<h3 id="合并分支正常合并">合并分支(正常合并)</h3>
<p>基本语法：<code>git merge 分支名</code></p>
<p>在 master 分支上合并 hot-fix 分支（将hot-fix的合并到master）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ cat hello.txt<br>hello!xiaozhang!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git merge hot-fix<br>Updating 97d2973..d6680d5<br>Fast-forward<br> hello.txt | 1 +<br> 1 file changed, 1 insertion(+)<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ cat hello.txt<br>hello!xiaozhang!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hot-fix 分支<br></code></pre></td></tr></table></figure>
<p>注意：正常合并不是覆盖！是master发现hot-fix中不同地方，然后删掉不同的这几行，加上别人多出来的几行</p>
<h3 id="合并分支冲突合并">合并分支(冲突合并)</h3>
<h4 id="冲突产生的原因">冲突产生的原因</h4>
<p>并分支时，<strong>两个分支在同一个文件的同一个位置有两套完全不同的修改</strong>。 Git 无法替我们决定使用哪一个，因此，必须<strong>人为决定</strong>新代码内容。</p>
<h4 id="产生冲突">产生冲突</h4>
<p>首先，在master修改文件hello.txt最后一行内容，并提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ vim hello.txt<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ cat hello.txt<br>hello!xiaozhang!hot-fix<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!master <span class="hljs-built_in">test</span><br><br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git add hello.txt<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git commit -m <span class="hljs-string">&quot;master test&quot;</span><br>[master e84d459] master <span class="hljs-built_in">test</span><br> 1 file changed, 1 insertion(+), 1 deletion(-)<br><br></code></pre></td></tr></table></figure>
<p>然后，在hot-fix分支修改文件hello.txt最后一行内容，并提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git checkout hot-fix<br>Switched to branch <span class="hljs-string">&#x27;hot-fix&#x27;</span><br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ vim hello.txt<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ cat hello.txt<br>hello!xiaozhang!hot-fix<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!hot-fix <span class="hljs-built_in">test</span><br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ git add hello.txt<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ git commit -m <span class="hljs-string">&quot;hot-fix test&quot;</span><br>[hot-fix f7d88ed] hot-fix <span class="hljs-built_in">test</span><br> 1 file changed, 2 insertions(+), 2 deletions(-)<br><br></code></pre></td></tr></table></figure>
<p>切换到master分支，然后将hot-fix分支的合并到master，冲突产生：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (hot-fix)<br>$ git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master)<br>$ git merge hot-fix<br>Auto-merging hello.txt<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> hello.txt<br>Automatic merge failed; fix conflicts and <span class="hljs-keyword">then</span> commit the result.<br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master|MERGING)<br>$ git status<br>On branch master<br>You have unmerged paths.<br>  (fix conflicts and run <span class="hljs-string">&quot;git commit&quot;</span>)<br>  (use <span class="hljs-string">&quot;git merge --abort&quot;</span> to abort the merge)<br><br>Unmerged paths:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)<br>        both modified:   hello.txt<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br><br><br>HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master|MERGING)<br>$ cat hello.txt<br>hello, git!hot-fix<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string">hello!Git!master test</span><br><span class="hljs-string">=======</span><br><span class="hljs-string">hello!Git!hot-fix test</span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</span><br></code></pre></td></tr></table></figure>
<h4 id="解决冲突">解决冲突</h4>
<p>编辑有冲突的文件，<strong>删除特殊符号</strong>，决定要使用的内容</p>
<p>特殊符号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string">当前分支的代码 </span><br><span class="hljs-string">======= </span><br><span class="hljs-string">合并过来的代码 </span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master|MERGING)<br>$ cat hello.txt<br>hello!xiaozhang!hot-fix<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>hello!Git!<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string">hello!Git!master-test</span><br><span class="hljs-string">=======</span><br><span class="hljs-string">hello!Git!hot-fix test</span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</span><br><span class="hljs-string"></span><br><span class="hljs-string">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master|MERGING)</span><br><span class="hljs-string">$ vim hello.txt</span><br><span class="hljs-string"></span><br><span class="hljs-string">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master|MERGING)</span><br><span class="hljs-string">$ cat hello.txt</span><br><span class="hljs-string">hello!xiaozhang!hot-fix</span><br><span class="hljs-string">hello!Git!</span><br><span class="hljs-string">hello!Git!</span><br><span class="hljs-string">hello!Git!</span><br><span class="hljs-string">hello!Git!</span><br><span class="hljs-string">hello!Git!hot-fix test</span><br><span class="hljs-string"></span><br><span class="hljs-string">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master|MERGING)</span><br><span class="hljs-string">$ git add hello.txt</span><br><span class="hljs-string"></span><br><span class="hljs-string">HP@DESKTOP-VOLMMUF MINGW64 /d/mycode/git-space/git-demo (master|MERGING)</span><br><span class="hljs-string">$ git commit -m &quot;merge solved&quot;</span><br><span class="hljs-string">[master 3bff591] merge solved</span><br></code></pre></td></tr></table></figure>
<h2 id="git-团队协作">Git 团队协作</h2>
<h3 id="团队内协作">团队内协作</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220728154529.png" /></p>
<h3 id="跨团队写作">跨团队写作</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220728155033.png" /></p>
<h2 id="github">Github</h2>
<h3 id="远程仓库操作">远程仓库操作</h3>
<table>
<thead>
<tr class="header">
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr class="even">
<td>git remote add 别名 远程地址</td>
<td>起别名</td>
</tr>
<tr class="odd">
<td>git push 别名 分支</td>
<td>推送本地分支上的内容到远程仓库</td>
</tr>
<tr class="even">
<td>git clone 远程地址</td>
<td>将远程仓库的内容克隆到本地</td>
</tr>
<tr class="odd">
<td>git pull 远程库地址别名 远程分支名</td>
<td>将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</td>
</tr>
</tbody>
</table>
<p>剩下的操作可以查看：</p>
<p>https://blog.csdn.net/u011863024/article/details/118562748</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot笔记</title>
    <url>/2022/07/29/SpringBoot%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="springboot">SpringBoot</h1>
<h1 id="第一章-javaconfig">第一章 JavaConfig</h1>
<ol type="1">
<li><p>为什么要使用 Spring Boot</p>
<p>因为Spring， SpringMVC 需要使用的大量的配置文件 （xml文件）</p>
<p>还需要配置各种对象，把使用的对象放入到spring容器中才能使用对象</p>
<p>需要了解其他框架配置规则。</p></li>
<li><p>SpringBoot 就相当于 不需要配置文件的Spring+SpringMVC。 常用的框架和第三方库都已经配置好了。</p>
<p>拿来就可以使用了。</p></li>
<li><p>SpringBoot开发效率高，使用方便多了</p></li>
</ol>
<h2 id="javaconfig">1.1 JavaConfig</h2>
<p>JavaConfig: 使用java类作为xml配置文件的替代，是配置spring容器的纯java的方式。 在这个java类这可以创建java对象，把对象放入spring容器中（注入到容器）。</p>
<p>使用两个注解：</p>
<p>1）<span class="citation" data-cites="Configuration">@Configuration</span> ： 放在一个类的上面，表示这个类是作为配置文件使用的。</p>
<p>2）<span class="citation" data-cites="Bean">@Bean</span>：声明对象，把对象注入到容器中。</p>
<p>JavaConfig充当配置文件，用来配置spring容器，bean把返回值的对象注入到spring容器当中</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bjpowernode.config;<br><br><span class="hljs-keyword">import</span> com.bjpowernode.vo.Student;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Configuration:表示当前类是作为配置文件使用的。 就是用来配置容器的</span><br><span class="hljs-comment"> *       位置：在类的上面</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  SpringConfig这个类就相当于beans.xml</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建方法，方法的返回值是对象。 在方法的上面加入<span class="hljs-doctag">@Bean</span></span><br><span class="hljs-comment">     * 方法的返回值对象就注入到容器中。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Bean</span>: 把对象注入到spring容器中。 作用相当于&lt;bean&gt;</span><br><span class="hljs-comment">     *     位置：方法的上面</span><br><span class="hljs-comment">     *     说明：<span class="hljs-doctag">@Bean</span>,不指定对象的名称，默认是方法名是 id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">createStudent</span><span class="hljs-params">()</span></span>&#123;<br>        Student s1  = <span class="hljs-keyword">new</span> Student();<br>        s1.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        s1.setAge(<span class="hljs-number">26</span>);<br>        s1.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>        <span class="hljs-keyword">return</span> s1;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 指定对象在容器中的名称（指定&lt;bean&gt;的id属性）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Bean</span>的name属性，指定对象的名称（id）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean(name = &quot;lisiStudent&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">makeStudent</span><span class="hljs-params">()</span></span>&#123;<br>        Student s2  = <span class="hljs-keyword">new</span> Student();<br>        s2.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br>        s2.setAge(<span class="hljs-number">22</span>);<br>        s2.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>        <span class="hljs-keyword">return</span> s2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用JavaConfig</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);<br>    Student student = (Student) ctx.getBean(<span class="hljs-string">&quot;createStudent&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;使用JavaConfig创建的bean对象：&quot;</span>+student);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span>&#123;<br>    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);<br>    Student student = (Student) ctx.getBean(<span class="hljs-string">&quot;lisiStudent&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;03使用JavaConfig创建的bean对象：&quot;</span>+student);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="imporresource">1.2 <span class="citation" data-cites="ImporResource">@ImporResource</span></h2>
<p><span class="citation" data-cites="ImportResource">@ImportResource</span> 作用导入其他的xml配置文件， 等于 在xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resources</span>=<span class="hljs-string">&quot;其他配置文件&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ImportResource(value =&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="propertyresource">1.3 <span class="citation" data-cites="PropertyResource">@PropertyResource</span></h2>
<p><span class="citation" data-cites="PropertyResource">@PropertyResource</span>: 读取properties属性配置文件。 使用属性配置文件可以实现外部化配置 ，在程序代码之外提供数据。</p>
<p>步骤：</p>
<ol type="1">
<li>在resources目录下，创建properties文件， 使用k=v的格式提供数据</li>
<li>在PropertyResource 指定properties文件的位置</li>
<li>使用 <code>@Value(value=&quot;$&#123;key&#125;&quot;)</code></li>
</ol>
<hr />
<p>1、在resources目录下，创建properties文件， 使用k=v的格式提供数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">tiger.name=&quot;大老虎&quot;<br>tiger.age=3<br>12<br></code></pre></td></tr></table></figure>
<p>创建数据类 Tiger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;tiger&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tiger</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;tiger.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;$&#123;tiger.age&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tiger&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-number">12345678910111213141516</span><br></code></pre></td></tr></table></figure>
<p>2、在PropertyResource 指定properties文件的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ImportResource(value =&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)</span><br><span class="hljs-meta">@PropertySource(value = &quot;classpath:config.properties&quot;)</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.bjpowernode.vo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注解的方式和xml的方式对比</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(value = &quot;classpath:config.properties&quot;)</span>读取配置文件，<br><span class="hljs-meta">@Component(&quot;tiger&quot;)</span> 使用注解的方式创建javabean<br><span class="hljs-meta">@ComponentScan(value = &quot;com.link.vo&quot;)</span> 扫描vo下所有使用注解方式创建的javabean<br><span class="hljs-meta">@ImportResource(value = &#123;&quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)</span> 导入其他xml文件<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:config.properties&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.link.vo&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;classpath:beans.xml&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<h1 id="第二章-springboot">第二章 SpringBoot</h1>
<h2 id="介绍">2.1 介绍</h2>
<p>SpringBoot是Spring中的一个成员， 可以简化Spring，SpringMVC的使用。 他的核心还是IOC容器。</p>
<p>特点：</p>
<ul>
<li><p>Create stand-alone Spring applications</p>
<p>创建spring应用</p></li>
<li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</p>
<p>内嵌的tomcat， jetty ， Undertow</p></li>
<li><p>Provide opinionated 'starter' dependencies to simplify your build configuration</p>
<p>提供了starter起步依赖，简化应用的配置。</p>
<ul>
<li><p>比如使用MyBatis框架， 需要在Spring项目中，配置MyBatis的对象 SqlSessionFactory，Dao的代理对象</p></li>
<li><p>在SpringBoot项目中，在pom.xml里面, 加入一个 mybatis-spring-boot-starter 依赖</p></li>
</ul></li>
<li><p>Automatically configure Spring and 3rd party libraries whenever possible</p>
<p>尽可能去配置spring和第三方库。叫做自动配置（就是把spring中的，第三方库中的对象都创建好，放到容器中， 开发人员可以直接使用）</p></li>
<li><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p>
<p>提供了健康检查， 统计，外部化配置</p></li>
<li><p>Absolutely no code generation and no requirement for XML configuration</p>
<p>不用生成代码， 不用使用xml，做配置</p></li>
</ul>
<h2 id="注解的使用">2.2 注解的使用</h2>
<p><span class="citation" data-cites="SpringBootApplication">@SpringBootApplication</span> ： <span class="citation" data-cites="SpringBootApplication">@SpringBootApplication</span> 是一个复合注解，是由@SpringBootConfiguration，<span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span> ，<span class="citation" data-cites="ComponentScan">@ComponentScan</span> 联合在一起组成的。</p>
<h3 id="springbootconfiguration">1. <span class="citation" data-cites="SpringBootConfiguration">@SpringBootConfiguration</span></h3>
<p>就是 <span class="citation" data-cites="Configuration">@Configuration</span> 这个注解的功能，使用@SpringBootConfiguration这个注解的类就是配置文件的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br>    <span class="hljs-meta">@AliasFor(</span><br><span class="hljs-meta">        annotation = Configuration.class</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">proxyBeanMethods</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>说明：使用了@SpringBootConfiguration注解标注的类，可以作为配置文件使用的，可以使用Bean声明对象，注入到容器。</p>
<h3 id="enableautoconfiguration">2. <span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span></h3>
<p>启用自动配置，把java对象配置好，注入到spring容器中。例如可以把mybatis的对象创建好，放入到容器中</p>
<h3 id="componentscan">3. <span class="citation" data-cites="ComponentScan">@ComponentScan</span></h3>
<p><span class="citation" data-cites="ComponentScan">@ComponentScan</span> 组件扫描器，找到注解，根据注解的功能创建对象，给属性赋值等等。</p>
<p>组件扫描器默认扫描的是 <span class="citation" data-cites="ComponentScan">@ComponentScan</span> 注解所在的类， 类所在的包和子包。</p>
<h2 id="springboot的配置文件">2.3 SpringBoot的配置文件</h2>
<h3 id="properties-文件">1. .properties 文件</h3>
<p>配置文件名称： application</p>
<p>扩展名有： <code>properties(k=v)</code>; <code>yml (k: v)</code></p>
<p>使用application.properties, application.yml</p>
<p>例1：application.properties设置 端口和上下文</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">#设置端口号<br>server.port=8082<br>#设置访问应用上下文路径， contextpath<br>server.servlet.context-path=/myboot<br></code></pre></td></tr></table></figure>
<h3 id="yml-文件">2. .yml 文件</h3>
<p>例2： application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/myboot2</span><br></code></pre></td></tr></table></figure>
<p>注意 ： 当两种格式配置文件同时存在 ，在 SpringBoot2.4 开始， 使用的是 yml 配置文件.修改配置名称都为 application。</p>
<p>当properties、yaml和yml三种文件路径相同时，三个文件中的配置信息都会生效，但是当三个文件中有配置信息冲突时，加载顺序是：yml &gt; yaml &gt; properties</p>
<p>yml的优先级会大于properties，所以如果同时存在这两种配置，因为properties是后加载的，所以此时yml就没有生效。由里向外加载，所以最外层的最后被加载，会覆盖里层的属性，最后被加载。所以最后生效的是properties 。</p>
<p>推荐使用 yml 格式配置文件</p>
<h3 id="多环境配置">3. 多环境配置</h3>
<p>在实际开发的过程中，我们的项目会经历很多的阶段（开发-&gt;测试-&gt;上线），每个阶段的配置也会不同，例如：端口、上下文根、数据库等，那么这个时候<u>为了方便在不同的环境之间切换</u>，SpringBoot 提供了多环境配置，具体步骤如下：</p>
<p>为每个环境创建一个配置文件，命名必须以 <code>application-环境标识.properties|yml</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220731133915.png" style="zoom:40%;" /></p>
<p>application.properties。在这里指定/激活使用哪个配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">#激活使用哪个配置文件<br><br>#使用dev<br>#spring.profiles.active=dev<br><br>#使用test<br>spring.profiles.active=test<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果是 application.yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#激活使用的test环境</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>   <span class="hljs-attr">active:</span> <span class="hljs-string">test</span><br></code></pre></td></tr></table></figure>
<p>（开发）application-dev.yml</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/mydev</span><br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>
<p>（上线）application-online.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9002</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/myonline</span><br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>
<p>（测试）application-test.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/mytest</span><br></code></pre></td></tr></table></figure>
<h3 id="spring-boot-自定义配置">4. Spring Boot 自定义配置</h3>
<p>SpringBoot 的核心配置文件中，除了使用内置的配置项之外，我们还可以在自定义配置，然后采用如下注解去读取配置的属性值</p>
<h4 id="value-注解">1 <span class="citation" data-cites="Value">@Value</span> 注解</h4>
<p><span class="citation" data-cites="Value">@Value</span>(&quot;${key}&quot;) ， key 来自 application.properties(yml)</p>
<p>application.properties：添加两个自定义配置项 school.name 和 school.website。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-string">server.port=8082</span><br><span class="hljs-comment"># context-path</span><br><span class="hljs-string">server.servlet.context-path=/myboot</span><br><br><span class="hljs-comment">#自定义key=value</span><br><span class="hljs-string">school.name=linkacademy</span><br><span class="hljs-string">school.website=www.linkacademy.com</span><br><span class="hljs-string">school.address=北京市</span><br><br><span class="hljs-string">site=www.baidu.com</span><br></code></pre></td></tr></table></figure>
<p>读取配置文件数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloSpringBoot</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer port;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.servlet.context-path&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String contextPath;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;school.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;school.website&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String site;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/data&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;, site=&quot;</span> + site + <span class="hljs-string">&quot;,项目访问地址=&quot;</span> + contextPath + <span class="hljs-string">&quot;,使用的端口=&quot;</span> + port;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>启动应用 Application , 访问浏览器</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220731142021.png" alt="image-20220731142021024" /><figcaption>image-20220731142021024</figcaption>
</figure>
<h4 id="configurationproperties">2 <span class="citation" data-cites="ConfigurationProperties">@ConfigurationProperties</span></h4>
<p><span class="citation" data-cites="ConfigurationProperties">@ConfigurationProperties</span>: 把配置文件的数据映射为java对象。</p>
<p>属性：prefix 匹配 配置文件中的某些key的开头的内容。匹配一样，就把值value赋给同名的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;school&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolInfo</span> </span>&#123;<br><br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> String website;<br>	<span class="hljs-keyword">private</span> String address;<br>	...<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SchoolInfo&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, website=&#x27;&quot;</span> + website + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloSpringBoot</span> </span>&#123;<br>    <br>	 <span class="hljs-meta">@Value(&quot;$&#123;school.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;school.website&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String site;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> SchoolInfo info;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/info&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SchoolInfo对象==&quot;</span>+info.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="spring-boot-中使用-jsp">2.4 Spring Boot 中使用 JSP</h3>
<p>SpringBoot不推荐使用jsp ，而是使用模板技术代替jsp</p>
<p>使用jsp需要配置：</p>
<p>1） 加入一个处理jsp的依赖。 负责编译jsp文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>如果需要使用servlet， jsp，jstl的功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>2）需要在pom.xml指定jsp文件编译后的存放目录。</p>
<p>SpringBoot 要求 jsp 文件必须编译到指定的 META-INF/resources 目录下才能访问，否则访问不到。其实官方已经更建议使用模板技术（后面会讲模板技术）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定jsp编译后的存放目录--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--jsp原来的目录--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/webapp<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--指定编译后的存放目录--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>META-INF/resources<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--指定处理的目录和文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>3）在 application.properties 文件配置 Spring MVC 的视图展示为</p>
<p>jsp，这里相当于 Spring MVC 的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">spring.mvc.view.prefix=/<br>spring.mvc.view.suffix=.jsp<br></code></pre></td></tr></table></figure>
<p>4）在 com.bjpowernode.springboot.controller 包下创 建JspController 类，并编写代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JspController</span> </span>&#123;<br><br>    <span class="hljs-comment">/*public String doJsp(HttpServletRequest request)&#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        request.setAttribute(&quot;data&quot;,&quot;SpringBoot使用Jsp&quot;);</span><br><span class="hljs-comment">        //视图的逻辑名称</span><br><span class="hljs-comment">        return &quot;index&quot;;</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ModelAndView：</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> model</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@RequestMapping(&quot;/myjsp&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doJsp</span><span class="hljs-params">(Model model)</span></span>&#123;<br><br>        <span class="hljs-comment">//把数据放入到request作用域</span><br>        model.addAttribute(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-string">&quot;SpringBoot使用Jsp&quot;</span>);<br>        <span class="hljs-comment">//request.setAttribute(&quot;data&quot;,&quot;SpringBoot使用Jsp&quot;);</span><br><br>        <span class="hljs-comment">//视图的逻辑名称</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>5）在 src/main 下创建一个 webapp 目录，然后在该目录下新建index.jsp 页面</p>
<p>如果在webapp目录下右键，没有创建jsp的选项，可以在Project Structure中指定webapp为 Web Resource Directory</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;jsp文件&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h3&gt;使用jsp，显示Controller中的数据 $&#123;data&#125;&lt;/h3&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
<p>重新运行 Application，通过浏览器访问测试</p>
<h3 id="spring-boot-中使用-applicationcontext">2.5 Spring Boot 中使用 ApplicationContext</h3>
<p>在 main 方法中 SpringApplication.run() 方法获取返回的 Spring 容器对象，再获取业务 bean进行调用.</p>
<p>本质上是通过SpringApplication.run(Application.class, args); 返回值获取容器。</p>
<p>1.创建一个接口 UserService 和他的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2.创建启动类， main 方法中创建ConfigurableApplicationContext对象获取容器对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ch10SpringbootContainerApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        ConfigurableApplicationContext ctx= SpringApplication.run(Ch10SpringbootContainerApplication.class, args);<br><br>        UserService userService = ctx.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserService.class);<br>        userService.sayHello(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>ConfigurableApplicationContext : 接口，是ApplicationContext的子接口</p>
<h3 id="comnandlinerunner-接口applcationrunner接口">2.6 ComnandLineRunner 接口，ApplcationRunner接口</h3>
<p>开发中可能会有这样的情景。需要在容器启动后执行一些内容。比如<strong>读取配置文件</strong>，<strong>数据库连接</strong>之类的。SpringBoot 给我们提供了两个接口来帮助我们实现这种需求。这两个接口分别为 CommandLineRunner 和 ApplicationRunner。他们的执行时机为<strong>容器启动完成</strong>的时候。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;helloService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好：&quot;</span>+name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ch11SpringbootCommandlinerunnerApplication</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> HelloServiceImpl helloService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;准备创建容器对象&quot;</span>);<br>        <span class="hljs-comment">//创建容器对象</span><br>        ConfigurableApplicationContext ctx = SpringApplication.run(Ch11SpringbootCommandlinerunnerApplication.class, args);<br>        System.out.println(<span class="hljs-string">&quot;容器对象创建之后&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String str  = helloService.sayHello(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;调用容器中的对象=&quot;</span>+str);<br>        <span class="hljs-comment">//可做自定义的操作，比如读取文件， 数据库等等</span><br>        System.out.println(<span class="hljs-string">&quot;在容器对象创建好，执行的方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：<span class="citation" data-cites="SpringBootApplication">@SpringBootApplication</span> 启动类必须放在项目的根目录与所有包平级，一般在main方法内部通过执行</p>
<p><strong>main方法启动类位于项目根目录的原因</strong></p>
<p><span class="citation" data-cites="ComponentScan注解有个特性">@ComponentScan注解有个特性</span>：如果不指定需要扫描的包或者需要注册的类，则默认是扫描该使用@ComponentScan注解的类所在的包以及子包，所以将使用了@SpringBootApplication注解的包含main方法的启动类放在项目根目录，则会扫描项目的所有包。</p>
<p>除了@ComponentScan注解之外，<span class="citation" data-cites="EnableAutoConfiguration注解也是扫描使用了这个注解的类所在的包及其子包">@EnableAutoConfiguration注解也是扫描使用了这个注解的类所在的包及其子包</span>，故放在项目根目录，则可以扫描项目所有的包，对所有的类(具体为使用Spring容器管理的)进行检测，从而决定是否需要自动创建功能组件类的bean对象到spring的IOC容器中。</p>
<h1 id="第三章-web组件">第三章 Web组件</h1>
<h3 id="拦截器">3.1 拦截器</h3>
<p>拦截器是SpringMVC中一种对象，能拦截器对Controller的请求。</p>
<p>拦截器框架中有系统的拦截器， 还可以自定义拦截器。实现对请求预先处理。</p>
<h4 id="springmvc-使用拦截器">1. SpringMVC 使用拦截器</h4>
<p>SpringMVC 使用拦截器</p>
<p>1）自定义拦截器类，实现 HandlerInterceptor 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="hljs-meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="hljs-meta">@Nullable</span> Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2）注册拦截器类。需在SpringMVC的配置文件中，声明拦截器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    	&lt;mvc:path=&quot;url&quot; /&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;拦截器类全限定名称&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="springboot-使用拦截器">2. SpringBoot 使用拦截器</h4>
<p>1）创建类实现 HandlerInterceptor 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 自定义拦截器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler 被拦截的控制器对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     *      true: 拦截器把请求拦截下来，进行处理判断，判断是true就通过</span><br><span class="hljs-comment">     *      false: 请求被截断</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                             HttpServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">                             Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了LoginInterceptor的preHandle&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2）注册拦截器对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAppConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-comment">// 添加拦截器对象，注入到容器中</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建拦截器对象</span><br>        LoginInterceptor interceptor = <span class="hljs-keyword">new</span> LoginInterceptor();<br><br>        <span class="hljs-comment">//指定拦截的请求uri地址</span><br>        String path []=&#123;<span class="hljs-string">&quot;/user/**&quot;</span>&#125;;<br>        <span class="hljs-comment">//指定不拦截的地址</span><br>        String excludePath []=&#123;<span class="hljs-string">&quot;/user/login&quot;</span>&#125;;<br>        registry.addInterceptor(interceptor).addPathPatterns(path).excludePathPatterns(excludePath);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>3）创建测试使用的 Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootController</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/user/account&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">userAccount</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;访问user/account地址&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/login&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">userLogin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;访问user/login地址&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>4）启动主类， 运行浏览器</p>
<p>访问 user/account , user/login 观察拦截的输出语句</p>
<p>因为拦截器类设置的是false。user/account 会被拦截，页面无输出；而user/login 正常输出：&quot;访问user/login地址&quot;</p>
<p>如果是true的话，user/account也是被拦截了，但是preHandle方法中的返回值是true，还是会进行。排除是指不会经过拦截器，也就不会有输出。</p>
<h3 id="servlet">3.2 Servlet</h3>
<p>在SpringBoot框架中使用Servlet对象。</p>
<p>使用步骤：</p>
<ol type="1">
<li>创建Servlet类。 创建类继承HttpServlet</li>
<li>注册Servlet ，让框架能找到Servlet</li>
</ol>
<p>1）创建自定义Servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建Servlet类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doPost(req,resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>       <span class="hljs-comment">//使用HttpServletResponse输出数据，应答结果</span><br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>        PrintWriter out  = resp.getWriter();<br>        out.println(<span class="hljs-string">&quot;===执行的是Servlet==&quot;</span>);<br>        out.flush();<br>        out.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2）注册Servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebApplictionConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//定义方法， 注册Servlet对象</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">servletRegistrationBean</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//public ServletRegistrationBean(T servlet, String... urlMappings)</span><br>        <span class="hljs-comment">//第一个参数是 Servlet对象， 第二个是url地址</span><br><br>        <span class="hljs-comment">//ServletRegistrationBean bean =</span><br>                <span class="hljs-comment">//new ServletRegistrationBean( new MyServlet(),&quot;/myservlet&quot;);</span><br><br><br>        ServletRegistrationBean bean = <span class="hljs-keyword">new</span> ServletRegistrationBean();<br>        bean.setServlet( <span class="hljs-keyword">new</span> MyServlet());<br>        bean.addUrlMappings(<span class="hljs-string">&quot;/login&quot;</span>,<span class="hljs-string">&quot;/test&quot;</span>); <span class="hljs-comment">// &lt;url-pattern&gt;</span><br><br><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="过滤器filter">3.3 过滤器Filter</h3>
<p>Filter是Servlet规范中的过滤器，可以处理请求， 对请求的参数， 属性进行调整。 常常在过滤器中处理字符编码</p>
<p>在框架中使用过滤器：</p>
<ol type="1">
<li>创建自定义过滤器类</li>
<li>注册Filter过滤器对象</li>
</ol>
<p>例子：</p>
<p>1）自定义过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义过滤器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了MyFilter，doFilter &quot;</span>);<br>        filterChain.doFilter(servletRequest,servletResponse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2）注册Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebApplicationConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span></span>&#123;<br>        FilterRegistrationBean bean  = <span class="hljs-keyword">new</span> FilterRegistrationBean();<br>        bean.setFilter( <span class="hljs-keyword">new</span> MyFilter());<br>        bean.addUrlPatterns(<span class="hljs-string">&quot;/user/*&quot;</span>);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>3）创建 Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFilterController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/account&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">userAccount</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user/account&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/query&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryAccount</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/query&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="字符集过滤器">3.4 字符集过滤器</h3>
<p>CharacterEncodingFilter : 解决post请求中乱码的问题</p>
<p>在SpringMVC框架， 在web.xml 注册过滤器。 配置他的属性。</p>
<h4 id="第一种方式">第一种方式：</h4>
<p>使用步骤：</p>
<p>1）创建 Servlet，输出中文数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doPost(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>        PrintWriter out = resp.getWriter();<br>        out.println(<span class="hljs-string">&quot;===在Servlet输出中文,默认编码ISO-8859-1===&quot;</span>);<br>        out.flush();<br>        out.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2）配置字符集过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSystemConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//注册Servlet</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">servletRegistrationBean</span><span class="hljs-params">()</span></span>&#123;<br>        MyServlet myServlet = <span class="hljs-keyword">new</span> MyServlet();<br>        ServletRegistrationBean reg = <span class="hljs-keyword">new</span> ServletRegistrationBean(myServlet,<span class="hljs-string">&quot;/myservlet&quot;</span>);<br>        <span class="hljs-keyword">return</span> reg;<br>    &#125;<br><br><br>    <span class="hljs-comment">//注册Filter</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span></span>&#123;<br>        FilterRegistrationBean reg = <span class="hljs-keyword">new</span> FilterRegistrationBean();<br><br>        <span class="hljs-comment">//使用框架中的过滤器类</span><br>        CharacterEncodingFilter filter  = <span class="hljs-keyword">new</span> CharacterEncodingFilter();<br>        <span class="hljs-comment">//指定使用的编码方式</span><br>        filter.setEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">//指定request ， response都使用encoding的值</span><br>        filter.setForceEncoding(<span class="hljs-keyword">true</span>);<br><br>        reg.setFilter(filter);<br>        <span class="hljs-comment">//指定 过滤的url地址</span><br>        reg.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> reg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>3）修改application.properties文件， 让自定义的过滤器起作用</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#SpringBoot中默认已经配置了CharacterEncodingFilter。 编码默认ISO-8859-1</span><br><span class="hljs-comment">#设置enabled=false 作用是关闭系统中配置好的过滤器， 使用自定义的CharacterEncodingFilter</span><br><span class="hljs-meta">server.servlet.encoding.enabled</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure>
<h4 id="第二种方式">第二种方式</h4>
<p>Spring Boot 项目默认启用了 CharacterEncodingFilter, 设置他的属性就可以。修改application.properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">9001</span><br><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/myboot</span><br><br><span class="hljs-comment"># 让系统的CharacterEncdoingFilter生效</span><br><span class="hljs-meta">server.servlet.encoding.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 指定使用的编码方式</span><br><span class="hljs-meta">server.servlet.encoding.charset</span>=<span class="hljs-string">utf-8</span><br><span class="hljs-comment"># 强制request，response都使用charset属性的值</span><br><span class="hljs-meta">server.servlet.encoding.force</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>
<h1 id="第四章-orm-操作-mysql">第四章 ORM 操作 MySQL</h1>
<p>讲解 MyBatis 框架，读写 MySQL 数据。通过 SpringBoot +MyBatis 实现对数据库学生表的查询操作。</p>
<p>使用步骤：</p>
<ol type="1">
<li><p>mybatis起步依赖 ： 完成mybatis对象自动配置， 对象放在容器中</p></li>
<li><p>pom.xml 指定把src/main/java目录中的xml文件包含到classpath中</p></li>
<li><p>创建实体类Student</p></li>
<li><p>创建Dao接口 StudentDao , 创建一个查询学生的方法</p></li>
<li><p>创建Dao接口对应的Mapper文件， xml文件， 写sql语句</p></li>
<li><p>创建Service层对象， 创建StudentService接口和他的实现类。 去dao对象的方法。完成数据库的操作</p></li>
<li><p>创建Controller对象，访问Service。</p></li>
<li><p>写application.properties文件</p>
<p>配置数据库的连接信息。</p></li>
</ol>
<h3 id="第一种方式mapper">第一种方式：<span class="citation" data-cites="Mapper">@Mapper</span></h3>
<p><span class="citation" data-cites="Mapper">@Mapper</span>：放在dao接口的上面， 每个接口都需要使用这个注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Mapper</span>：告诉MyBatis这是dao接口，创建此接口的代理对象。</span><br><span class="hljs-comment"> *     位置：在类的上面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentDao</span> </span>&#123;<br><br>    <span class="hljs-function">Student <span class="hljs-title">selectById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;stuId&quot;)</span> Integer id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="第二种方式mapperscan">第二种方式：<span class="citation" data-cites="MapperScan">@MapperScan</span></h3>
<p>在 Dao 接口上面加入@Mapper，需要在每个接口都加入注解。当 Dao 接口多的时候不方便。</p>
<p>可以使用如下的方式解决：</p>
<p>主类上添加注解包扫描：<span class="citation" data-cites="MapperScan">@MapperScan</span>(“com.bjpowernode.dao”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@MapperScan</span>: 找到Dao接口和Mapper文件</span><br><span class="hljs-comment"> *     basePackages：Dao接口所在的包名</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.dao&quot;,&quot;com.bjpowernode.mapper&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="第三种方式-mapper文件和dao接口分开管理">第三种方式： Mapper文件和Dao接口分开管理</h3>
<p>在 application.properties 配置文件中指定映射文件的位置，这个配置只有接口和映射文件不在同一个包的情况下，才需要指定。</p>
<p>现在把Mapper文件放在resources目录下</p>
<p>1）在resources目录中创建子目录 （自定义的）， 例如mapper， 存放 xml 文件</p>
<p>2）把mapper文件放到mapper目录中</p>
<p>3）在application.properties文件中，指定mapper文件的目录</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#指定mapper文件的位置</span><br><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span><br><span class="hljs-comment">#指定mybatis的日志</span><br><span class="hljs-meta">mybatis.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure>
<p>4）在pom.xml中指定 把resources目录中的文件 ， 编译到目标目录中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--resources插件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="事务支持">事务支持</h3>
<p>Spring框架中的事务：</p>
<ol type="1">
<li><p>管理事务的对象： 事务管理器（接口， 接口有很多的实现类）</p>
<p>例如：使用Jdbc或mybatis访问数据库，使用的事务管理器：DataSourceTransactionManager</p></li>
<li><p>声明式事务：在xml配置文件或者使用注解说明事务控制的内容</p>
<p>控制事务：隔离级别，传播行为， 超时时间</p></li>
<li>事务处理方式：
<ol type="1">
<li>Spring框架中的@Transactional</li>
<li>aspectj框架可以在xml配置文件中，声明事务控制的内容</li>
</ol></li>
</ol>
<hr />
<p>Spring Boot 使用事务非常简单，底层依然采用的是 Spring 本身提供的事务管理</p>
<ol type="1">
<li>在入口类中使用注解 <span class="citation" data-cites="EnableTransactionManagement">@EnableTransactionManagement</span> 开启事务支持</li>
<li>在访问数据库的 Service 方法上添加注解 <span class="citation" data-cites="Transactional">@Transactional</span> 即可</li>
</ol>
<p>栗：通过 SpringBoot +MyBatis 实现对数据库学生表的更新操作，在 service 层的方法中构建异常，查看事务是否生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentService</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Transactional</span>: 表示方法的有事务支持</span><br><span class="hljs-comment">     *       默认：使用库的隔离级别， REQUIRED 传播行为； 超时时间  -1</span><br><span class="hljs-comment">     *       抛出运行时异常，回滚事务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;业务方法addStudent&quot;</span>);<br>        <span class="hljs-keyword">int</span> rows = studentMapper.insert(student);<br>        System.out.println(<span class="hljs-string">&quot;执行SQL语句&quot;</span>);<br>        <span class="hljs-comment">//抛出运行时异常，目的是回滚事物</span><br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">5</span>/<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">return</span> rows;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Application 主类上，<span class="citation" data-cites="EnableTransactionManagement">@EnableTransactionManagement</span> 开启事务支持</p>
<p><span class="citation" data-cites="EnableTransactionManagement">@EnableTransactionManagement</span> 可选，但是@Service 必须添加事务才生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@MapperScan(basePackages = &quot;com.bjpowernode.dao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="第五章-接口架构风格-restful">第五章 接口架构风格 — RESTful</h1>
<p>接口： API（Application Programming Interface，应用程序接口）是一些预先定义的接口（如函数、HTTP接口），或指软件系统不同组成部分衔接的约定。 用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问源码，或理解内部工作机制的细节。</p>
<p>接口（API）： 可以指访问servlet，controller的url，调用其他程序的 函数</p>
<p>架构风格：指的是API组织方式（样子）</p>
<p>这个例子就是一个传统的：http://localhost:9002/mytrans/addStudent?name=lisi&amp;age=26</p>
<p>在地址上提供了 访问的资源名称addStudent, 在其后使用了get方式传递参数。</p>
<h3 id="rest">5.1 REST</h3>
<p>RESTful架构风格</p>
<p>1）REST: Representational State Transfer , 表现层状态转移。</p>
<p>REST：是一种接口的架构风格和设计的理念，不是标准。</p>
<p>优点： 更简洁，更有层次</p>
<p>表现层状态转移:</p>
<ul>
<li>表现层就是视图层， 显示资源的， 通过视图页面，jsp等等显示操作资源的结果。</li>
<li>状态： 资源变化</li>
<li>转移： 资源可以变化的。 资源能创建，new状态，资源创建后可以查询资源， 能看到资源的内容，这个资源内容，可以被修改，修改后资源 和之前的不一样。</li>
</ul>
<p>2）REST中的要素：</p>
<p>用REST表示资源和对资源的操作。在互联网中，表示一个资源或者一个操作。</p>
<p>资源使用url表示的， 在互联网， 使用的图片，视频， 文本，网页等等都是资源。</p>
<p>资源是用名词表示。</p>
<p><strong>使用url表示资源 ，使用http动作操作资源。</strong></p>
<p>3）注解</p>
<p><code>@PathVariable</code> : 从url中获取数据</p>
<p><code>@GetMapping</code>：支持的get请求方式，等同于 <code>@RequestMapping( method=RequestMethod.GET)</code></p>
<p><code>@PostMapping</code>：支持post请求方式，等同于 <code>@RequestMapping( method=RequestMethod.POST)</code></p>
<p><code>@PutMapping</code>：支持put请求方式，等同于 <code>@RequestMapping( method=RequestMethod.PUT)</code></p>
<p><code>@DeleteMapping</code>：支持delete请求方式，等同于 <code>@RequestMapping( method=RequestMethod.DELETE)</code></p>
<p><code>@RestController</code>: 复合注解， 是@Controller 和@ResponseBody组合。在类的上面使用@RestController， 表示当前类者的所有方法都加入了 <code>@ResponseBody</code></p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bjpowernode.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRestController</span> </span>&#123;<br><br>    <span class="hljs-comment">// 学习注解的使用</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询id=1001的学生</span><br><span class="hljs-comment">     * http://localhost:9001/myboot/student/1001</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &#123;stuId&#125;:定义路径变量，stuId自定义名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/student/&#123;stuId&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryStudent</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;stuId&quot;)</span> Integer stuId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询学生id=&quot;</span>+stuId;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建资源Post请求方式</span><br><span class="hljs-comment">     * http://localhost:9001/myboot/student/zhangsan/20</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/student/&#123;name&#125;/&#123;age&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createStudent</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name,</span></span><br><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-meta">@PathVariable(&quot;age&quot;)</span> Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;创建资源 student：&quot;</span> + name + <span class="hljs-string">&quot;#age=&quot;</span> + age;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping(&quot;/student/&#123;id&#125;/&#123;age&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateStudent</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id,</span></span><br><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-meta">@PathVariable</span> Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;更新资源，执行put请求方式：id=&quot;</span> + id + <span class="hljs-string">&quot;#age=&quot;</span> + age;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;/student/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeStudentById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;删除资源，执行delete：id=&quot;</span> + id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="在页面中或者ajax中支持putdelete请求">5.2 在页面中或者ajax中，支持put，delete请求</h3>
<p>在SpringMVC中 有一个过滤器， 支持post请求转为put ,delete</p>
<p>过滤器： org.springframework.web.filter.HiddenHttpMethodFilter</p>
<p>作用： 把请求中的post请求转为 put ， delete</p>
<p>实现步骤：</p>
<ol type="1">
<li><p>application.properties(yml) : 开启使用 HiddenHttpMethodFilter 过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"># 启用支持put，delete<br>spring.mvc.hiddenmethod.filter.enabled=true<br></code></pre></td></tr></table></figure></li>
<li><p>在请求页面中，包含 _method参数， 他的值是 put，delete， 发起这个请求使用的post方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;student/test&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_method&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;put&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;put测试请求方式&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;student/testdelete&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_method&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;delete&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;delete测试请求方式&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hierarchical Representations】Hierarchical Representations For Efficient Architecture Search</title>
    <url>/2022/08/09/%E3%80%90Hierarchical%20Representations%E3%80%91Hierarchical%20Representations%20For%20Efficient%20Architecture%20Search/</url>
    <content><![CDATA[<h1 id="hierarchical-representations-for-efficient-architecture-search">Hierarchical Representations For Efficient Architecture Search</h1>
<ul>
<li>ICLR 2018</li>
</ul>
<p>论文基于层级表达提出高效的进化算法来进行神经网络结构搜索，通过层层堆叠来构建强大的卷积结构。</p>
<ol type="1">
<li>提出对神经网络结构的层级表达</li>
<li>通过实验证明搜索空间的设计十分重要，可以降低搜索方法的投入，甚至随机搜索也可以</li>
<li>提出可扩展的进化搜索方法，对比其它进化搜索方法有更好的结果</li>
</ol>
<h2 id="mythinking">MyThinking</h2>
<p><strong><em>这个能和图神经网络结合吗？？</em></strong></p>
<p>只包含了突变，没有交叉操作。</p>
<h2 id="architecture-search">Architecture Search</h2>
<h3 id="flat-architecture-representation">1. Flat Architecture Representation</h3>
<p>将神经网络结构定义为单输入、单输出的计算图，图中每个节点代表特征图，每条有向边为基本操作(卷积、池化等)，所以网络的架构由表示 <span class="math inline">\((G, \boldsymbol{o})\)</span> 定义，由两个成分组成：</p>
<ol type="1">
<li>可用的操作集 <span class="math inline">\(\boldsymbol{o}=\{o_1, o_2...\}\)</span></li>
<li>邻接矩阵 <span class="math inline">\(G\)</span> 去表示一个有向无环的神经网络图，<span class="math inline">\(G_{ij}=k\)</span>为节点i和节点j间的操作<span class="math inline">\(o_k\)</span></li>
</ol>
<p>因此，将操作集o和邻接矩阵G组合起来就得到网络的结构，表示为： <span class="math display">\[
arch = assemble(G, \boldsymbol{o})
\]</span> 由此产生的神经网络按照拓扑顺序，从其先前节点<span class="math inline">\(j\)</span>的特征映射<span class="math inline">\(x_j\)</span>中，依次计算每个节点<span class="math inline">\(i\)</span>的特征映射<span class="math inline">\(x_i\)</span>： <span class="math display">\[
x_{i}= merge \left[\left\{o_{G_{i j}}\left(x_{j}\right)\right\}_{j&lt;i}\right], \quad i=2, \ldots,|G|
\]</span> 这里，<span class="math inline">\(|G|\)</span>是图中的节点数，merge是一种将多个特征映射合并为一个的操作，被实现为depthwise concatenation。由于element-wise addition要求维度一致，比较不灵活，而且如果融合特征后接的是1×1卷积，这就其实类似于做concatienation</p>
<h3 id="hierarchical-architecture-representation">2. Hierarchical Architecture Representation</h3>
<p>层级架构表示的关键思想是在不同层次上具有多个构建块，较低层次的构建块会构建成较高层次的构建块。</p>
<p>对于一个L级的层次结构，最高级L的构建块就是一个与完整结构相对应的构建块，最低级别也就是第一级就是一个基本操作的集合。 <span class="math display">\[
o_{m}^{(\ell)}= assemble \left(G_{m}^{(\ell)}, \boldsymbol{o}^{(\ell-1)}\right), \quad \forall \ell=2, \ldots, L
\]</span> 其中，<span class="math inline">\(o_{m}^{(\ell)}\)</span> 递归定义为第 <span class="math inline">\(l\)</span> 层的第 <span class="math inline">\(m\)</span> 个构建块，上一层的构建块为<span class="math inline">\(\boldsymbol{o}^{(\ell-1)}=\left\{o_{1}^{(\ell-1)}, o_{2}^{(\ell-1)}, \ldots, o_{M_{(\ell-1)}}^{(\ell-1)}\right\}\)</span>。最终一个层次体系结构可以表示为 <span class="math display">\[
\left(\left\{\left\{G_{m}^{(\ell)}\right\}_{m=1}^{M_{\ell}}\right\}_{\ell=2}^{L}, \boldsymbol{O}^{(1)}\right)
\]</span> 下图举了一个三层结构表示的例子，下面一列图是第一级的构建块和几种操作，assemble成第二级的构建块。然后这个构建块与其他第二级的构建块，根据第三层的网络结构进行assemble集成第三级构建。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809115231.png" /></p>
<h3 id="primitive-operations">3. Primitive Operations</h3>
<p>在第一层的构建块中，设计了6种原始操作primitives：</p>
<ul>
<li>1 × 1 convolution of C channels</li>
<li>3 × 3 depthwise convolution</li>
<li>3 × 3 separable convolution of C channels</li>
<li>3 × 3 max-pooling</li>
<li>3 × 3 average-pooling</li>
<li>identity</li>
</ul>
<p>6种原始操作primitives步长均为1，以及进行padded来保留分辨率，卷积后都接BN+ReLU，维度固定为C。作者认为，具有更大感受野和更多通道的卷积也可以作为构建块 。之所以没有作为6种基本操作primitives是因为：事实上，通过在链式结构中叠加3×3卷积可以获得大的感受野，通过 depthwise concatenation 合并多个卷积的输出可以获得具有这种更多通道的更宽卷积。</p>
<p>还引入了一个特殊的 <span class="math inline">\(none\)</span> 操作，它表示节点i和j之间没有边。它被添加到每个级别的操作池中。</p>
<h2 id="evolutionary-architecture-search">Evolutionary Architecture Search</h2>
<h3 id="mutation">Mutation</h3>
<p>分层基因型的单个突变包含以下步骤：</p>
<ol type="1">
<li>随机选择一个non-primitive level <span class="math inline">\(l&gt;=2\)</span>作为目标层</li>
<li>在目标层采样一个目标构建块 <span class="math inline">\(m\)</span> 作为目标构建块</li>
<li>目标构建块中随机选择一个后继节点 <span class="math inline">\(i\)</span></li>
<li>目标构建块中随机选择一个前置节点 <span class="math inline">\(j\)</span></li>
<li>随机替换节点 <span class="math inline">\(i\)</span> 和节点 <span class="math inline">\(j\)</span> 之间的操作</li>
</ol>
<p>对于当前层级只有两层的基因型，第一步省略，直接将 <span class="math inline">\(l\)</span> 设为2。变异可总结为下列公式： <span class="math display">\[
\left[G_{m}^{(\ell)}\right]_{i j}=k^{\prime}
\]</span> <span class="math inline">\(\ell,m,i,j,k&#39;\)</span> 从各自区域的均匀分布中随机抽样得到。</p>
<p>上面的突变足够对模版产生3种修改：</p>
<ol type="1">
<li>添加一条新边 if <span class="math inline">\(o_{k}^{(\ell-1)}=\text { none, } o_{k^{\prime}}^{(\ell-1)} \neq \text { none }\)</span></li>
<li>改变一条存在的边 if <span class="math inline">\(o_{k}^{(\ell-1)} \neq \text { none, } o_{k^{\prime}}^{(\ell-1)} \neq \text { none }, o_{k}^{(\ell-1)} \neq o_{k^{\prime}}^{(\ell-1)}\)</span></li>
<li>移除一条存在的边 if <span class="math inline">\(o_{k}^{(\ell-1)} \neq \text { none, } o_{k^{\prime}}^{(\ell-1)}=\text { none }\)</span></li>
</ol>
<h3 id="initialization">Initialization</h3>
<p>基因/个体 的种群初始化包含两个步骤:</p>
<ol type="1">
<li>创建一个“trivial”基因型，其中每个模块都使用identity进行连接</li>
<li>通过应用大批的随机突变使基因型多样化。</li>
</ol>
<p>这种策略的好处就是：对比以前的研究使用常见的网络进行基因初始化，这样的初始化不仅能很好地覆盖不常见的网络的搜索空间，还能去除人工初始化带来的传统偏向</p>
<h3 id="search-algorithms">Search Algorithms</h3>
<p>论文的进化算法基于锦标赛选择(tournament selection)，首先对初始化的种群网络进行训练和测试得到分数，然后从种群中随机获取5%的基因，表现最好的基因进行突变得到新网络，在训练和测试后放入种群中，重复进行上述选取与放回，种群数量不断增大，最终取种群表现最好的基因 论文也使用随机搜索进行实验，基因种群随机生成，然后进行训练和验证，选取最好的模型，这种方法的主要好处在于能整个种群并行化计算，减少搜索时间</p>
<h3 id="implementation">Implementation</h3>
<p>论文使用异步分布式进行实现，由一个负责在基因型上执行进化的controller和一组负责评估的worker组成。双方都可以访问记录基因型总体及其适应度的一个共享内存表格M，以及包含应评估的未知基因型的数据队列Q。</p>
<p>具体而言，只要worker可用，controller将从M中选择一个基因型，然后对所选基因型进行变异，并将其插入到数据队列Q中进行适应度评估（算法1）。只要有可用的基因型，worker就会从Q中提取一个未评估基因型，将其组装到架构中，进行训练和验证，然后在M（算法2）中记录验证精度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809213218.png" /></p>
<p>体系结构是从零开始训练的，具有随机权重初始化的固定步数。没有使用权值共享加速，尽管将其纳入是可能的。请注意，在体系结构演进过程中，不需要同步，所有worker都被完全占用。</p>
<h2 id="experiments">Experiments</h2>
<h3 id="experimental-setup">Experimental Setup</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809224117.png" /></p>
<p>在实验中，没有对整体网络进行搜索，而是使用提出的方法进行卷积单元(cell)的搜索，这样能够在小网络上快速进行网络测试然后迁移到较大的网络。具体的各结构如图2，每个cell后面接2c维度和stride=2的3×3分离卷积，用于升维和降低分辨率，最后一个cell后面接c维度和stride=1的3×3分离卷积</p>
<h3 id="architecture-search-on-cifar-10">Architecture Search on CIFAR-10</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809224241.png" /></p>
<p>200卡，初始种群为200，层级L=3，每层模版的操作分别为M1=6，M2=6和M3=1，每层<span class="math inline">\((ℓ≥2)\)</span>的节点图分别为<span class="math inline">\(|G(2)|=4\)</span>和<span class="math inline">\(|G(3)|=5\)</span>，层2的模版跟一个跟模版输入维度一样1×1的卷积来降维。对于用于对比的不分层的搜索方法，则使用11个节点的计算图。从图3来看，论文提出的方法在收敛速度、准确率和参数量上都不错</p>
<p>为了进一步展示论文方法的效果，对图3中间的结果的每轮增量进行了可视化。在P100 GPU上，每个网络的测试需要花费1小时，进化共7000轮，200张卡共需要1.5天</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809224337.png" /></p>
<h3 id="architecture-evaluation-on-cifar-10-and-imagenet">Architecture Evaluation on CIFAR-10 and ImageNet</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809224414.png" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809224429.png" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809224452.png" /></p>
<h2 id="appendix">Appendix</h2>
<p>最好的网络结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809224555.png" style="zoom: 67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220809224637.png" /></p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>Hierarchical Representations</tag>
      </tags>
  </entry>
  <entry>
    <title>【RENAS】Reinforced Evolutionary Neural Architecture Search</title>
    <url>/2022/08/10/%E3%80%90RENAS%E3%80%91Reinforced%20Evolutionary%20Neural%20Architecture%20Search/</url>
    <content><![CDATA[<h1 id="renas-reinforced-evolutionary-neural-architecture-search">RENAS: Reinforced Evolutionary Neural Architecture Search</h1>
<ul>
<li>CVPR 2019</li>
</ul>
<p>论文提出了强化进化神经架构搜索（RENAS），它将RL集成到进化框架中以解决RL和EA问题。RENAS引入了一个reinforced mutation controller来帮助探索搜索空间。由于EA的性质，子模型可以从其父模型继承大多数参数，从而使搜索更加有效。主要贡献总结如下：</p>
<ol type="1">
<li>提出了一种新的神经结构搜索框架RENAS，将EA和RL相结合。该框架综合了两者的优点，保证了搜索效率。</li>
<li>设计了一个强化变异控制器来学习轻微修改的效果，并采取行动来指导进化。这有助于种群在更少的迭代中进化到更好的状态。</li>
<li>发现了一个神经网络结构RENASNet</li>
</ol>
<h2 id="background">Background</h2>
<p>EA-based NAS的局限性：对于EA-based NAS，它倾向于进化一个体系结构的种群，以确保潜在结果的多样性。然而，由于进化过程严重依赖于随机不可控突变，因此<strong>EA的进化过程缓慢。</strong>例如，AmoebaNet通过基于EA的方法进行搜索，其最终结果优于RL生成的NASNet。但在相同的搜索空间中，AmoebaNet比NASNet使用更多的计算资源。</p>
<p>RL-based NAS的局限性：它依赖超参数来保证稳定性。但在逐层确定架构时，RL控制器需要尝试数十种操作，以获得作为监控信号的正奖励。训练和评估单个模型，非常耗时。</p>
<hr />
<p>作者将mutation controller集成到进化框架中，以学习修改的效果并做出合理的变异动作。与仅RL方法和仅EA方法相比，这种集成有以下好处：</p>
<ol type="1">
<li>RL训练变得更有效。因为对网络进行修改所需的操作比逐层构建模型要少得多。由于子模型是从父模型修改而来的，变异控制器很容易学习细微差异的影响。</li>
<li>在reinforced mutation controller的帮助下，进化过程变得更加高效和稳定。模型架构及其验证精度以前被忽略，但在进化过程中产生了有价值的提示。作者重用这些有用的监控信号来训练mutation controller。反过来，它消除了有害突变的积累。</li>
</ol>
<h2 id="search-space">Search Space</h2>
<h3 id="block">Block</h3>
<p>图2右侧显示，每个block中，将两个输入 <span class="math inline">\(\{i_1,i_2\}\)</span> 分别通过两种操作 <span class="math inline">\(\{o_1,o_2\}\)</span> ，然后通过element-wise addition <span class="math inline">\(A\)</span> 结合成一个输出 <span class="math inline">\(O\)</span>。所以每个block可以表示为长度为4的字符串 <span class="math inline">\(\{i_1,i_2,o_1,o_2\}\)</span>。</p>
<p><span class="math inline">\(\{i_1,i_2\}\)</span> 从 <span class="math inline">\(\left\{O_{1}^{c}, O_{2}^{c}, \ldots, O_{b-1}^{c}, O_{B}^{c-1}, O_{B}^{c-2}\right\}\)</span> 中选择，<span class="math inline">\(O_{1}^{c},..., O_{2}^{c}\)</span> 是当前cell中前几个block的输出，而 <span class="math inline">\(O_{B}^{c-1}, O_{B}^{c-2}\)</span> 是前一个和前两个cell的输出。</p>
<p><span class="math inline">\(\{o_1,o_2\}\)</span> 操作可以从下列中选择：</p>
<ul>
<li>3x3 depth-wise separable convolution</li>
<li>5x5 depth-wise separable convolution</li>
<li>7x7 depth-wise separable convolution</li>
<li>3x3 avg pooling</li>
<li>3x3 max pooling</li>
<li>identity.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220810100628.png" /></p>
<h3 id="cell">Cell</h3>
<p>每个cell可以被表示为一个有向无环图由 B 个block组成。</p>
<h3 id="network">Network</h3>
<p>每个网络可以指定三个因素：单元结构，#N 要堆叠的单元数和 #F 第一层中的过滤器数量。在搜索过程中固定 #N 和 #F 时，搜索空间被限制在所有可能的单元结构中。搜索完成后，将构建不同大小的模型以适应各种任务或数据集。作者调整重复的单元数#N 和第一层中的过滤器数量来控制网络的深度和宽度。如图 2 (a) 所示，ImageNet 的架构还有两个步长为 2 的单元。由于 ImageNet (224x224) 中的图像尺寸远大于 CIFAR-10 (32x32) 中的图像尺寸，因此需要更多的下采样操作。</p>
<p>因此，每个网络都指定有 5 x #B tokens，其中 4 x #B tokens在搜索期间是可变的。因为每个cell由#B个block组成，每个block由5个tokens指定：两个输入 <span class="math inline">\(\{i_1,i_2\}\)</span> ，两个操作 <span class="math inline">\(\{o_1,o_2\}\)</span> 和一个固定为加法的组合操作 A。因此，搜索网络架构转换为搜索 4 x #B 变量。这个搜索空间小于 NASNet 搜索空间。</p>
<h2 id="search-strategy">Search Strategy</h2>
<h3 id="evolution-framework">Evolution Framework</h3>
<p>流程如下：首先随机初始化种群P。种群P的每个个体在训练集上进行训练，并在验证集评估，得到验证精度作为适应度值。然后开始进化，在每一个进化步骤中，采用锦标赛选择算法：从P中随机抽取一个子集S。根据其适应度值，从S中选择最佳个体B和最差个体W。W被排除在P之外，B成为父母，产生具有突变的子C。然后对C进行训练和评估，以测量其适应度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220810112934.png" style="zoom:50%;" /></p>
<h3 id="reinforced-mutation">Reinforced Mutation</h3>
<p>通过mutation controller实现Reinforced Mutation，以学习轻微修改的效果并做出变异动作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220810090210.png" /></p>
<p>控制器采用长度为5#B的字符串，该字符串表示给定的cell架构。具体而言，控制器由4部分组成：</p>
<ol type="1">
<li>Encoder <span class="math inline">\(Enc\)</span>：embedding layer后的编码器 （Enc）学习cell的每个部分的效果</li>
<li>Mutation-router <span class="math inline">\(Mut-rt\)</span>：从block的<span class="math inline">\(\{i_1,i_2,o_1,o_2\}\)</span>中选择一个的Mutation-router</li>
<li>Input-mutator <span class="math inline">\(IN-Mut\)</span>：用新输入 <span class="math inline">\(i_{new}\)</span> 改变节点的输入</li>
<li>OP-mutator <span class="math inline">\(OP-Mut\)</span>：用新的运算符 <span class="math inline">\(o_{new}\)</span> 改变节点的运算符。</li>
</ol>
<h4 id="encoder">1. Encoder</h4>
<p><span class="math inline">\(Enc\)</span> 是一种具有输入嵌入层的 Bi-RNN。<span class="math inline">\(Enc\)</span> 学习到的隐藏状态表示局部对整个网络的影响。对于Enc中的块b，其隐藏状态为 <span class="math inline">\(\left\{H_{i_{1}}^{b}, H_{i_{2}}^{b}, H_{o_{1}}^{b}, H_{o_{2}}^{b}\right\}\)</span>，其中 <span class="math inline">\(H_{o_{1}}^{b}\)</span> 表示block b的 <span class="math inline">\(o_1\)</span> 对整个网络的影响。由于每个模型由 5 x #B 个参数组成，<span class="math inline">\(Enc\)</span> 每一步生成 5 x #B 个hidden state。此外，还初始化了两个begin状态 <span class="math inline">\(H^{c-1}, H^{c-2}\)</span> 表示前一和前两个cell的信息。</p>
<hr />
<p><strong>mutation controller 的过程是这样的</strong>：对于块b，控制器按序做出两个决策。首先，根据 <span class="math inline">\(\left\{H_{i_{1}}^{b}, H_{i_{2}}^{b}, H_{o_{1}}^{b}, H_{o_{2}}^{b}\right\}\)</span>，<span class="math inline">\(Mut-rt\)</span> 决定需要修改块b中的 <span class="math inline">\(i1、i2、o1、o2\)</span> 中的哪一个。它通过softmax分类器以 Attention 机制进行采样。如果选择了一个输入 <span class="math inline">\(i_1\)</span> 或 <span class="math inline">\(i_2\)</span>，则通过 <span class="math inline">\(IN-Mut\)</span> 从 <span class="math inline">\(\left\{O_{1}^{c}, O_{2}^{c}, \ldots, O_{b-1}^{c}, O_{B}^{c-1}, O_{B}^{c-2}\right\}\)</span> 中选择一个。否则 <span class="math inline">\(OP-Mut\)</span> 将从这6个操作选项中选择一个新运算符。由于每个单元中有B个块，因此该过程将重复B次以修改给定的体系结构。因此，它对每个模型进行2#B修改动作。下面描述实现细节。</p>
<hr />
<h4 id="mutation-router">2. Mutation-router</h4>
<p>Mutation-router 决定需要修改块b中的 <span class="math inline">\(i1、i2、o1、o2\)</span> 中的哪一个。对于每个块，<span class="math inline">\(Mut-rt\)</span> 的输入是 Enc 输出的 <span class="math inline">\(\left\{H_{i_{1}}^{b}, H_{i_{2}}^{b}, H_{o_{1}}^{b}, H_{o_{2}}^{b}\right\}\)</span> 的子集，<span class="math inline">\(Mut-rt\)</span> 的输出是 <span class="math inline">\(i1、i2、o1、o2\)</span> 中的一个，是要突变的ID。每个隐藏状态后接全连接层，用 SOFTMAX 计算每个成分 <span class="math inline">\(\left\{P_{i_{1}}^{b}, P_{i_{2}}^{b}, P_{o_{1}}^{b}, P_{o_{2}}^{b}\right\}\)</span> 的修改概率，根据这些概率从 <span class="math inline">\(i1、i2、o1、o2\)</span> 中采样一个。</p>
<h4 id="in-mutator">3. IN-mutator</h4>
<p>如果选中 <span class="math inline">\(I D \in\left(i_{1}, i_{2}\right)\)</span>，则为节点选择一个新输入。输入包括：所选ID的隐藏状态 <span class="math inline">\(H_{ID}^{1}\)</span>、所有先前blocks的输出的隐藏状态 <span class="math inline">\(\left[H_{A}^{1}, \ldots, H_{A}^{b-1}\right]\)</span> 和 前cell和前前cell的隐藏状态 <span class="math inline">\(H^{c-1}, H^{c-2}\)</span>。concate <span class="math inline">\(\left[H_{ID}^{1};H_{A}^{1}, \ldots, H_{A}^{b-1}, H^{c-1}, H^{c-2}\right]\)</span> 然后接全连接层。</p>
<p>与 <span class="math inline">\(Mut-rt\)</span> 类似，用softmax计算上面的概率来替换原始输入的概率，然后通过从 <span class="math inline">\(1,…,b-1,c-1,c-2\)</span> 中选择这些概率来确定新输入 <span class="math inline">\(i_{new}\)</span> 。</p>
<h4 id="op-mutator">4. OP-mutator</h4>
<p><span class="math inline">\(OP-Mut\)</span> 根据输入的 <span class="math inline">\(H_{ID}^{1}\)</span> 输出一个新的运算符 <span class="math inline">\(o_{new}\)</span> 。这个过程类似于<span class="math inline">\(Mut-rt\)</span> 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220810165801.png" style="zoom:50%;" /></p>
<blockquote>
<p>我的理解是 mutation controller 先把各种输入输出转为嵌入向量，然后通过注意力机制寻找一个向量，作者没有详细说是什么样的向量。然后对这个进行突变。。。。</p>
</blockquote>
<h3 id="search-details">Search Details</h3>
<h4 id="controller">Controller</h4>
<p>在每个进化步骤中，Controller都会做出一系列变异动作。然后生成修改了父模型的子模型C。然后，使用参数继承计算验证精度 <span class="math inline">\(f_C\)</span>，该参数继承将在下一段中介绍。奖励 <span class="math inline">\(γ\)</span> 是 <span class="math inline">\(f_C\)</span>的非线性函数， <span class="math inline">\(\gamma=\tan \left(f_{C} \cdot \frac{\pi}{2}\right)\)</span>，因为提高精度的增益应该更大，而其父项的验证精度更高。通过策略梯度更新控制器参数θ。</p>
<h4 id="child-models">Child Models</h4>
<p>子模型通过从父模型继承的参数进行训练和评估。对于种群中的每个模型B，存储其结构字符串、适应度<span class="math inline">\(f_B\)</span>及其可学习参数<span class="math inline">\(ω_B\)</span>。由于每个子模型C都是从其父模型生成的，只需稍加修改，因此它们之间的差异仅存在于突变层中。因此，子级可以从父级B继承大多数参数。</p>
<p><span class="math inline">\(ω_C\)</span>分为可继承参数<span class="math inline">\(ω^C_{inh}\)</span>和新初始化参数<span class="math inline">\(ω^C_{new}\)</span>。并且其适合度<span class="math inline">\(f_C\)</span>可以通过微调而不是从头开始的训练来评估。在微调过程中，我们以<span class="math inline">\(ω^C_{new}\)</span>的学习率是<span class="math inline">\(ω^C_{inh}\)</span>的10倍的学习率通过<span class="math inline">\(D_{train}\)</span>对<span class="math inline">\(ω_C\)</span>进行整体训练。实验中，<span class="math inline">\(ω^C_{new}\)</span>的学习率等于0.01。</p>
<h4 id="deriving-architectures">Deriving Architectures</h4>
<p>在搜索过程中，将每个单元设置为包含#B=5个块，在第一个卷积单元中设置#F=24个滤波器，并将单元展开为#N=2。在达到最大迭代数#E后，仅从头开始重新训练总体中的模型，然后以最高精度获取模型。通过从头开始重新训练更多采样模型可以改进结果，但要证明我们控制器的性能是不公平的。在实验中，种群大小#P设置为20。为了更好的比较，我们将#F和#N设置为与NASNets相同。</p>
<h2 id="experiments">Experiments</h2>
<p>RENASNet结构如下：（1个cell）</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811095406.png" style="zoom: 67%;" /></p>
<h3 id="results-on-cifar-10">Results on CIFAR-10</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811094948.png" /></p>
<p>RENASNet 的准确率和其他先进模型差不多。</p>
<p>只有NASNet-A和AmoebaNet的性能比RENASNet稳定且更好，而它们使用的计算资源比我们的要多得多。ENAS比我们的方法更有效，但我们的模型参数更少，精度更高。</p>
<h3 id="results-on-cifar-10-1">Results on CIFAR-10</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811094953.png" /></p>
<h3 id="search-efficiency">Search Efficiency</h3>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811100402.png" style="zoom: 33%;" /></p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>RENAS</tag>
      </tags>
  </entry>
  <entry>
    <title>【NSGA-Net】Neural Architecture Search using Multi-Objective Genetic Algorithm</title>
    <url>/2022/08/12/nsga/</url>
    <content><![CDATA[<h1 id="nsga-net-neural-architecture-search-using-multi-objective-genetic-algorithm">NSGA-Net: Neural Architecture Search using Multi-Objective Genetic Algorithm</h1>
<p>NSGA网络的设计有三个目标：（1）一个考虑多个相互冲突的目标的过程，（2）一个平衡潜在神经网络结构探索和开发的有效过程，以及（3）一个在一次运行中找到一组不同的权衡网络结构的过程。</p>
<p>NSGA网络是一种基于群体的搜索算法，它通过三个步骤探索潜在神经网络体系结构的空间，即，基于手工构建体系结构的先验知识的群体初始化步骤、包括体系结构交叉和变异的探索步骤，最后是利用以贝叶斯网络形式存储在被评估的神经架构的整个历史中的隐藏有用知识的开发步骤。</p>
<p>计算复杂性由网络在前向传递过程中执行的浮点运算（FLOP）的数量来定义。</p>
<ul>
<li>确实哈，大多数现有方法的搜索空间仅限于一个按需重复多次的块。相反，NSGA网络搜索整个网络结构。该方案克服了在整个网络中重复相同计算块的固有限制，即单个块可能不是每个应用程序的最佳块，因此需要允许NAS发现网络不同部分中具有不同块的架构。</li>
</ul>
<p>NSGA网络与RL方法的不同之处在于使用了多个选择标准。更具体地说，选择网络是因为其对任务的准确值，而不是准确值的近似值以及计算复杂性。</p>
<p>此外，最成功的RL方法只搜索重复创建网络的计算块，NSGA网络允许跨计算块和块组合进行搜索。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811204252.png" /></p>
<h2 id="method">Method</h2>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220811220358.png" /></p>
<h3 id="encoding">Encoding</h3>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>RENAS</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch7笔记</title>
    <url>/2022/08/19/ElasticSearch%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第1章-elasticsearch-概念">第1章 ElasticSearch 概念</h1>
<h2 id="什么是restful">什么是RestFul</h2>
<p><strong>REST</strong> : 表现层状态转化(Representational State Transfer)，如果一个架构符合REST原则，就称它为 RESTful 架构风格。</p>
<p><strong>资源</strong>: 所谓&quot;资源&quot;，就是网络上的一个实体，或者说是网络上的一个具体信息</p>
<p><strong>表现层</strong> :我们把&quot;资源&quot;具体呈现出来的形式，叫做它的&quot;表现层&quot;(Representation)。</p>
<p>状态转化(State Transfer):如果客户端想要操作服务器，必须通过某种手段，让服务器端发生&quot;状态转 化&quot;(State Transfer)。而这种转化是建立在表现层之上的，所以就是&quot;表现层状态转化&quot;。</p>
<blockquote>
<p><strong><code>REST原则就是指一个URL代表一个唯一资源，并且通过HTTP协议里面四个动词:GET、POST、PUT、DELETE对应四种服务器端的基本操作: GET用来获取资源，POST用来添加资源(也可以用于更新资源)，PUT用来更新资源，DELETE用来删除资源。</code></strong></p>
</blockquote>
<h2 id="什么是全文检索">什么是全文检索</h2>
<p><strong>全文检索是计算机程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置。当用户查询时根据建立的索引查找，类似于通过字典的检索字表查字的过程。</strong></p>
<ul>
<li>索: 建立索引 文本----&gt; 切分 ----&gt; 词 文章出现过 出现多少次</li>
<li>检索: 查询 关键词----&gt; 索引中 ----&gt; 符合条件文章 相关度排序</li>
</ul>
<hr />
<p>全文检索（Full-Text Retrieval(检索)）以文本作为检索对象，找出含有指定词汇的文本。<strong>全面、准确和快速是衡量全文检索系统的关键指标。</strong></p>
<p>关于全文检索，我们要知道：</p>
<ul>
<li><code>只处理文本、不处理语义</code></li>
<li><code>搜索时英文不区分大小写</code></li>
<li><code>结果列表有相关度排序</code></li>
</ul>
<h2 id="什么是elasticsearch">什么是Elasticsearch</h2>
<p><strong>ElasticSearch</strong> 简称 <strong>ES</strong> ，<strong>是基于Apache Lucene构建的开源搜索引擎，是当前流行的企业级搜索引擎</strong>。Lucene本身就可以被认为迄今为止性能最好的一款开源搜索引擎工具包，但是lucene的API相对复杂，需要深厚的搜索理论。很难集成到实际的应用中去。<strong>但是ES是采用java语言编写，提供了简单易用的RestFul API，开发者可以使用其简单的RestFul API，开发相关的搜索功能，从而避免lucene的复杂性</strong>。</p>
<p>目前 Elasticsearch 有很多地方超越了 Lucene，它不仅可以实现全文搜索功能，还可以完成以下工作：</p>
<ul>
<li>分布式实时文档存储，并将每一个字段都编入索引，使其可以被搜索。</li>
<li>分布式实时分析与搜索引擎。</li>
<li>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。</li>
<li>可以轻松地通过客户端或者任何你喜欢的程序语言与 Elasticsearch 的 RESTful API 进行通信</li>
</ul>
<h3 id="es的应用场景">ES的应用场景</h3>
<p><strong>ES主要以<code>轻量级JSON</code>作为数据存储格式，这点与MongoDB有点类似，但它在读写性能上优于 MongoDB 。同时也支持地理位置查询 ，还方便地理位置和文本混合查询 。 以及在统计、日志类数据存储和分析、可视化这方面是引领者。</strong></p>
<ul>
<li>国外:</li>
</ul>
<p><strong>Wikipedia</strong>(维基百科)使用ES提供全文搜索并高亮关键字、StackOverflow(IT问答网站)结合全文搜索与地理位置查询、Github使用Elasticsearch检索1300亿行的代码。</p>
<ul>
<li>国内:</li>
</ul>
<p>百度(在云分析、网盟、预测、文库、钱包、风控等业务上都应用了ES，单集群每天导入30TB+数据， 总共每天60TB+)、新浪 、阿里巴巴、腾讯等公司均有对ES的使用。</p>
<p><strong><code>使用比较广泛的平台ELK(ElasticSearch, Logstash, Kibana)</code></strong></p>
<h2 id="elasticsearch相关术语">ElasticSearch相关术语</h2>
<h3 id="接近实时nrt-near-real-time">接近实时(NRT — Near Real Time )</h3>
<p>Elasticsearch是一个接近实时的搜索平台。这意味着，<strong>从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟(通常是1秒内)</strong></p>
<h3 id="索引index">索引(index)</h3>
<p>索引是文档的容器，一类文档的集合，存储在分片Shard上</p>
<p><strong>一个索引就是一个拥有几分相似特征的文档的集合</strong>。<strong>一个索引由一个名字来标识(必须全部是小写字母的)</strong>，<strong>并且当我们要对这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字</strong>。在一个集群中，如果你想，可以定义任意多的索引。</p>
<ul>
<li>索引类比关系数据库的db</li>
<li>索引的Mapping定义文档字段类型，类比关系数据库的schema</li>
<li>索引的Setting定义数据在分片上的分布</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/7d097077a5744f51bccf3f6c32820eee.png" /></p>
<h3 id="映射mapping">映射(Mapping)</h3>
<p><strong>映射是定义一个文档和它所包含的字段如何被存储和索引的过程</strong>。相当于数据库中的schema，用来约束字段的数据类型，每一种数据类型都有对应的使用场景。在默认配置下，ES可以根据插入的数据自动创建mapping，也可以手动创建mapping。mapping 中定义了一个文档所包含的所有 field 信息，每个文档都有映射，<strong>但是在大多数使用场景中，我们并不需要显示的创建映射，因为ES中实现了动态映射</strong>。我们在索引中写入一个下面的JSON文档</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">&#123;<br>    &quot;name&quot;:&quot;jack&quot;,<br>    &quot;age&quot;:18,<br>    &quot;birthDate&quot;: &quot;1991-10-05&quot;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在动态映射的作用下，name会映射成text类型，age会映射成long类型，birthDate会被映射为date类型，映射的索引信息如下。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">&#123;<br>  &quot;mappings&quot;: &#123;<br>    &quot;_doc&quot;: &#123;<br>      &quot;properties&quot;: &#123;<br>        &quot;age&quot;: &#123;<br>          &quot;type&quot;: &quot;long&quot;<br>        &#125;,<br>        &quot;birthDate&quot;: &#123;<br>          &quot;type&quot;: &quot;date&quot;<br>        &#125;,<br>        &quot;name&quot;: &#123;<br>          &quot;type&quot;: &quot;text&quot;,<br>          &quot;fields&quot;: &#123;<br>            &quot;keyword&quot;: &#123;<br>              &quot;type&quot;: &quot;keyword&quot;,<br>              &quot;ignore_above&quot;: 256<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="文档document">文档(document)</h2>
<p><strong>一个文档是一个可被索引的最小单元，类似于表中的一条记录。</strong> 比如，你可以拥有某一个员工的文档,也可以拥有某个商品的一个文档。文档以采用了轻量级的数据交换格式JSON(Javascript Object Notation)来表示。</p>
<ul>
<li>文档类比关系数据库一条记录</li>
<li>每个文档有一个唯一的ID，类比关系数据库主键ID</li>
<li>json对象由filed构成，filed类比关系数据库column</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">&#123;<br>  &quot;_index&quot;: &quot;user&quot;,<br>  &quot;_type&quot;: &quot;_doc&quot;,<br>  &quot;_id&quot;: &quot;qbuOs4AB1VH6WaY_OsFW&quot;,<br>  &quot;_version&quot;: 1,<br>  &quot;_score&quot;: 1,<br>  &quot;_source&quot;: &#123;<br>    &quot;name&quot;: &quot;张三&quot;,<br>    &quot;address&quot;: &quot;广东省深圳市&quot;,<br>    &quot;remark&quot;: &quot;他是一个程序员&quot;,<br>    &quot;age&quot;: 28,<br>    &quot;salary&quot;: 8800,<br>    &quot;birthDate&quot;: &quot;1991-10-05&quot;,<br>    &quot;createTime&quot;: &quot;2019-07-22T13:22:00.000Z&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上图为 ES 一条文档数据，而一个文档不只有基础数据，它还包含了元数据(metadata)——关于文档的信息，也就是用下划线开头的字段，它是官方提供的字段：</p>
<ul>
<li>_index ：文档所属索引名称，即文档存储的地方。</li>
<li>_type ：文档所属类型名（此处已默认为 _doc）。</li>
<li>_id ：文档的唯一标识。在写入的时候，可以指定该 Doc 的 ID 值，如果不指定，则系统自动生成一个唯一的 UUID 值。</li>
<li>_score ：顾名思义，得分，也可称之为相关性，在查询是 ES 会 根据一些规则计算得分，并根据得分进行倒排。除此之外，ES 支持通过 Function score query 在查询时自定义 score 的计算规则。</li>
<li>_source ：文档的原始 JSON 数据。</li>
</ul>
<h3 id="es和db的关系">ES和DB的关系</h3>
<p><img src="https://img-blog.csdnimg.cn/6ac5e490229248a9972034baa2f85315.png" /></p>
<h1 id="第2章-es-索引映射文档">第2章 ES 索引、映射、文档</h1>
<p>通过Kibana的Dev Tools来充当Elasticsearch客户端来操作ES</p>
<h2 id="索引index的基本操作">索引(Index)的基本操作</h2>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">PUT /ems/       创建索引<br>DELETE /ems	 删除索引<br>DELETE /*		     删除所有索引<br></code></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /_cat/indices?v 			查看索引信息;<br><br>健康情况   状态   索引名  索引id  分片数  副本数  文档数量      删除文档数量  文档大小     主分片文档大小<br>health  status  index  uuid   pri    rep    docs.count docs.deleted store.size pri.store.size <br></code></pre></td></tr></table></figure>
<h3 id="创建">创建</h3>
<ol type="1">
<li>创建索引</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">PUT /索引名 ====&gt; PUT /products<br></code></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>ES中索引健康转态 red(索引不可用) 、yellow(索引可用,存在风险)、green(健康)</li>
<li>默认ES在创建索引时回为索引创建1个副本索引和1个分片索引</li>
</ul>
<ol start="2" type="1">
<li>创建索引 进行索引分片配置</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">PUT /products<br>&#123;<br>  &quot;settings&quot;: &#123;<br>    &quot;number_of_shards&quot;: 1, #指定主分片的数量<br>    &quot;number_of_replicas&quot;: 0 #指定副本分片的数量<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/cdd17ad7956b47fea7b2e94007c5b2eb.png" /></p>
<h3 id="查询">查询</h3>
<p>查询索引</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">GET <span class="hljs-regexp">/_cat/i</span>ndices?v<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/9eea91355568451f9dce20d2d1fea624.png" /></p>
<h3 id="删除">删除</h3>
<p>删除索引</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">- DELETE /索引名 =====&gt; DELETE /products<br>- DELETE /*     `*代表通配符,代表所有索引`<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ee76967f95714d7abeadef987d3367cf.png" /></p>
<h2 id="映射mapping的基本操作">映射(mapping)的基本操作</h2>
<h3 id="创建-1">创建</h3>
<blockquote>
<p>只有text类型才会进行分词,其他类型都不会分词</p>
</blockquote>
<p>字符串类型：keyword 关键字 关键词 、text 一段文本</p>
<p>数字类型：integer, long</p>
<p>小数类型：float, double</p>
<p>布尔类型：boolean</p>
<p>日期类型：date</p>
<ol type="1">
<li>创建索引&amp;映射</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">PUT /products<br>&#123; <br>  &quot;settings&quot;: &#123;<br>    &quot;number_of_shards&quot;: 1,<br>    &quot;number_of_replicas&quot;: 0<br>  &#125;, <br>  &quot;mappings&quot;: &#123;<br>    &quot;properties&quot;: &#123;<br>      &quot;title&quot;:&#123;<br>        &quot;type&quot;: &quot;keyword&quot;<br>      &#125;,<br>      &quot;price&quot;:&#123;<br>        &quot;type&quot;: &quot;double&quot;<br>      &#125;,<br>      &quot;created_at&quot;:&#123;<br>        &quot;type&quot;: &quot;date&quot;<br>      &#125;,<br>      &quot;description&quot;:&#123;<br>        &quot;type&quot;: &quot;text&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/107a7170500a4021beac7b2e39231d6a.png" /></p>
<blockquote>
<p>说明: ES中支持字段类型非常丰富，如：text、keyword、integer、long、ip 等。更多参见https://www.elastic.co/guide/en/elasticsearch/reference/7.15/mapping-types.html</p>
</blockquote>
<h3 id="查询-1">查询</h3>
<p>查看某个索引的映射</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /索引名/_mapping =====&gt; GET /products/_mapping<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/54509eb2707e43dbad35894c7b14428e.png" /></p>
<ul>
<li>映射信息不能修改，删除。如果创建时出现问题，只能将索引删除掉。</li>
</ul>
<h2 id="文档document的基本操作">文档(document)的基本操作</h2>
<h3 id="添加文档">添加文档</h3>
<p><code>/索引/类型/id</code></p>
<ul>
<li>在es7.x类型为_doc, 已经舍弃了自定义type</li>
<li>可以手动指定id，也可以不指定 自动生成</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">POST /products/_doc/1   #/索引/类型/id  #在es7.x类型为_doc, 已经舍弃了自定义type<br>&#123;<br>  &quot;id&quot;:1,<br>  &quot;title&quot;:&quot;小浣熊&quot;,<br>  &quot;price&quot;:0.5,<br>  &quot;created_at&quot;:&quot;2012-12-12&quot;,<br>  &quot;description&quot;:&quot;小浣熊挺好吃&quot;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220819143334.png" /></p>
<h3 id="查询文档">查询文档</h3>
<ul>
<li>手动定义的id</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_doc/1<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220819143910.png" /></p>
<ul>
<li>自动生成的id</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs HTTP">GET /products/_doc/巴拉巴拉懒得抄<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220819143928.png" /></p>
<h3 id="删除文档">删除文档</h3>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">DELETE /products/_doc/巴拉巴拉懒得抄<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220819144057.png" /></p>
<h3 id="更新文档">更新文档</h3>
<ol type="1">
<li>第一种方式 更新原有的数据。这种其实是<strong>先删除了原始文档，再重新添加的</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">PUT /products/_doc/1<br>&#123;<br>	&quot;title&quot;:&quot;小浣熊熊&quot;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220819144404.png" /></p>
<p>查看文档：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220819144513.png" /></p>
<p>解决办法：</p>
<ol type="1">
<li>按照原文档格式重新写。<strong>这样删除了原始文档，再重新添加，传递全部字段进行更新。</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">PUT /products/_doc/1<br>&#123;<br>  &quot;id&quot;:1,<br>  &quot;title&quot;:&quot;小浣熊熊&quot;,<br>  &quot;price&quot;:0.5,<br>  &quot;created_at&quot;:&quot;2012-12-12&quot;,<br>  &quot;description&quot;:&quot;小浣熊挺好吃&quot;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>基于指定字段进行更新。<strong>保留原字段进行更新。</strong>要用 <strong>POST</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">POST /products/_doc/1/_update<br>&#123;<br>	&quot;doc&quot;:&#123;<br>		&quot;price&quot;:1.6<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220819144941.png" /></p>
<h3 id="批量操作-不是原子操作-_bulk">批量操作 (不是原子操作) _bulk</h3>
<p><code>_bulk</code>(批量操作) 添加(<code>index</code>) 删除(<code>delete</code>) 更新(<code>update</code>)</p>
<ul>
<li>批量往索引中添加两个文档</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">POST /products/_doc/_bulk<br>&#123;&quot;index&quot;:&#123;&quot;_id&quot;:2&#125;&#125;<br>  &#123;&quot;id&quot;:2,&quot;title&quot;:&quot;小浣熊&quot;,&quot;price&quot;:10.5,&quot;created_at&quot;:&quot;2012-12-12&quot;,&quot;description&quot;:&quot;小浣熊挺好吃&quot;&#125;<br>&#123;&quot;index&quot;:&#123;&quot;_id&quot;:3&#125;&#125;<br>  &#123;&quot;id&quot;:3,&quot;title&quot;:&quot;日本豆&quot;,&quot;price&quot;:30.5,&quot;created_at&quot;:&quot;2012-12-12&quot;,&quot;description&quot;:&quot;日本豆挺好吃&quot;&#125;<br></code></pre></td></tr></table></figure>
<p>注意：批量操作时字段必须都在同一行！</p>
<ul>
<li>批量操作 添加 更新 删除</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">POST /products/_doc/_bulk<br>&#123;&quot;index&quot;:&#123;&quot;_id&quot;:4&#125;&#125;<br>  &#123;&quot;id&quot;:4,&quot;title&quot;:&quot;锅包肉&quot;,&quot;price&quot;:40,&quot;created_at&quot;:&quot;2012-12-12&quot;,&quot;description&quot;:&quot;锅包肉挺好吃&quot;&#125;<br>&#123;&quot;update&quot;:&#123;&quot;_id&quot;:3&#125;&#125;<br>  &#123;&quot;id&quot;:3,&quot;title&quot;:&quot;日本豆豆&quot;,&quot;price&quot;:30.5,&quot;created_at&quot;:&quot;2022-12-12&quot;,&quot;description&quot;:&quot;日本豆豆挺好吃&quot;&#125;<br>&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:2&#125;&#125;  <br></code></pre></td></tr></table></figure>
<p>注意：批量时不会因为一个失败而全部失败，而是继续执行后续操作，批量在返回时按照执行的状态开始返回</p>
<h1 id="第3章-es高级查询索引库原理倒排索引dsl高级检索">第3章 ES高级查询、索引库原理、倒排索引、DSL高级检索</h1>
<p>检索: 索: 对文档创建索引的过程; 检: 检索,根据查询条件查询文档</p>
<h2 id="检索方式-_search">检索方式 _search</h2>
<p>ES官方提供了两中检索方式:</p>
<ul>
<li><strong>一种是通过 URL 参数进行搜索</strong></li>
<li><strong>另一种是通过 <code>Query DSL</code>(Domain Specified Language) 进行搜索</strong>。<strong>官方更推荐使用第二种方式第二种方式是基于传递JSON作为请求体(request body)格式与ES进行交互，这种方式更强大，更简洁</strong>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/dbc685c5788b40049499d4efc88518f9.png" /></p>
<ul>
<li><p>使用语法</p>
<p><strong><code>URL查询: GET /索引/类型/_search?参数</code></strong></p>
<p><strong><code>DSL查询: GET /索引/类型/_search &#123;json请求体数据&#125;</code></strong></p></li>
</ul>
<h2 id="query-dsl-语法">Query DSL 语法</h2>
<h3 id="查询所有文档-match_all">查询所有文档 <code>match_all</code></h3>
<p><code>match_all</code>：返回索引中的全部文档</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;match_all&quot;:&#123;&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>GET /products/_search</code> 或者 <code>GET /products/_doc/_search</code></p>
<h3 id="返回指定条数-size">返回指定条数 <code>size</code></h3>
<p><strong>size 关键字</strong>: 指定查询结果中返回指定条数。 <strong>默认返回值10条</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;match_all&quot;:&#123;&#125;<br>  &#125;,<br>  &quot;size&quot;: 2<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="分页查询-from">分页查询 <code>from</code></h3>
<p><strong>from 关键字</strong>: 用来指定起始返回位置，和<strong>size关键字连用可实现分页效果</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;match_all&quot;:&#123;&#125;<br>  &#125;,<br>  &quot;size&quot;: 2,<br>  &quot;from&quot;: 1<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="指定字段排序-sort">指定字段排序 <code>sort</code></h3>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;match_all&quot;:&#123;&#125;<br>  &#125;,<br>  &quot;sort&quot;: [<br>    &#123;<br>		&quot;price&quot;: &#123;<br>			&quot;order&quot;: &quot;desc&quot;<br>		&#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="返回指定字段-_source">返回指定字段 <code>_source</code></h3>
<p>**_source 关键字**: 是一个数组,在数组中用来指定展示那些字段</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;match_all&quot;:&#123;&#125;<br>  &#125;,<br>  &quot;_source&quot;: [&quot;id&quot;, &quot;title&quot;, &quot;description&quot;]<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="关键词查询-term">关键词查询 <code>term</code></h3>
<p><code>term</code> 关键字：用来查询关键字。对于keyword类型，不分词，要使用全部内容搜索。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;term&quot;:&#123;<br>    	&quot;price&quot;:&#123;<br>    		&quot;value&quot;<br>    	&#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820103256.png" /></p>
<p><strong>对于text类型，默认ES标准分词器，中文单字分词，英文单词分词。</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820104302.png" alt="image-20220820104301693" /><figcaption>image-20220820104301693</figcaption>
</figure>
<p>Note：</p>
<ol type="1">
<li><p>term 基于关键词查询中，<strong>在ES的Mapping Type 中 keyword , date ,integer, long , double , boolean or ip 这些类型不分词</strong>，<strong><code>只有text类型分词</code></strong></p></li>
<li><p>ES中默认使用分词器为<strong>标准分词器(StandardAnalyzer)，</strong>标准分词器对于英文<strong>单词</strong>分词，对于中文<strong>单字</strong>分词</p></li>
</ol>
<h3 id="范围查询-range">范围查询 <code>range</code></h3>
<p><code>range</code>：用来指定查询指定范围内的文档</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;range&quot;:&#123;<br>    	&quot;price&quot;:&#123;<br>    		&quot;gte&quot;: 0,<br>    		&quot;lte&quot;: 5<br>    	&#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820105150.png" /></p>
<h3 id="前缀查询-prefix">前缀查询 <code>prefix</code></h3>
<p><code>prefix</code> 关键词：用来检索含有指定前缀的关键词的相关文档</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;prefix&quot;:&#123;<br>    	&quot;title&quot;:&#123;<br>    		&quot;value&quot;: &quot;小&quot;<br>    	&#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820105535.png" /></p>
<h3 id="通配符查询-wildcard">通配符查询 <code>wildcard</code></h3>
<p><code>wildcard</code> 关键词：通配符查询</p>
<ul>
<li><code>?</code> 用来匹配一个任意字符</li>
<li><code>*</code> 用来匹配多个任意字符</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;wildcard&quot;:&#123;<br>    	&quot;description&quot;:&#123;<br>    		&quot;value&quot;: &quot;goo?&quot;<br>    	&#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820110034.png" /></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820110011.png" alt="image-20220820110011270" /><figcaption>image-20220820110011270</figcaption>
</figure>
<h3 id="多id查询-ids">多id查询 <code>ids</code></h3>
<p><code>ids</code> 关键字：值为数组类型，用来根据一组 id 获取多个对应的文档</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;ids&quot;:&#123;<br>    	&quot;values&quot;:[1,3,4]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820110432.png" alt="image-20220820110432112" /><figcaption>image-20220820110432112</figcaption>
</figure>
<h3 id="模糊查询-fuzzy">模糊查询 <code>fuzzy</code></h3>
<p><code>fuzzy</code> 关键字：用来模糊查询含有指定关键字的文档</p>
<p><code>fuzzy</code> 模糊查询的最大模糊错误 必须在0-2之间</p>
<ul>
<li>搜索关键词长度为 2 不允许存在模糊</li>
<li>搜索关键词长度为3-5 允许一次模糊 0 1</li>
<li>搜索关键词长度大于5 允许最大2模糊</li>
</ul>
<blockquote>
<p>模糊：错误❌</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;fuzzy&quot;:&#123;<br>    	&quot;title&quot;: &quot;小浣猫&quot;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820110559.png" /></p>
<h3 id="布尔查询-bool">布尔查询 <code>bool</code></h3>
<p><code>bool</code>: 用来组合多个条件实现复杂查询</p>
<ul>
<li><p><code>must</code>: 相当于&amp;&amp; 同时成立</p></li>
<li><p><code>should</code>: 相当于|| 成立一个就行</p></li>
<li><p><code>must_not</code>: 相当于! 不能满足任何一个</p></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;bool&quot;:&#123;<br>    	&quot;must&quot;: [<br>    		&#123;<br>    			&quot;ids&quot;: &#123;<br>    				&quot;values&quot;: [1]<br>    			&#125;<br>    		&#125;,&#123;<br>    			&quot;term&quot;: &#123;<br>    				&quot;title&quot;: &#123;<br>    					&quot;value&quot;: &quot;小浣熊&quot;<br>    				&#125;<br>    			&#125;<br>    		&#125;<br>    	]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820111405.png" /></p>
<h3 id="多字段查询-multi_match">多字段查询 <code>multi_match</code></h3>
<ul>
<li>如果搜索的字段分词，会对query进行 先分词 再搜索</li>
<li>如果搜索的字段不分词，会直接使用query整体进行字段搜索</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;multi_match&quot;:&#123;<br>    	&quot;query&quot;: &quot;小浣熊&quot;,<br>    	&quot;fields&quot;: [&quot;title&quot;, &quot;description&quot;]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820152421.png" /></p>
<h3 id="默认字段分词查询-query_string">默认字段分词查询 <code>query_string</code></h3>
<p>查询字段分词，就将查询条件分词查询</p>
<p>查询字段不分词，将查询条件不分词查询</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;query_string&quot;:&#123;<br>    	&quot;default_field&quot;: &quot;description&quot;,<br>    	&quot;query&quot;: &quot;熊熊真可爱&quot;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>“description”</code> 是 text 类型，分词，所以查询 熊 真 可 爱</p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820153209.png" /></p>
<hr />
<p>其他的查询语法</p>
<h3 id="高亮查询-highlight">高亮查询 <code>highlight</code></h3>
<p><code>highlight</code>: 可以让符合条件的文档中的关键词高亮</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /products/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;query_string&quot;:&#123;<br>    	&quot;default_field&quot;: &quot;description&quot;,<br>    	&quot;query&quot;: &quot;熊熊真可爱&quot;<br>    &#125;<br>  &#125;,<br>  &quot;highlight&quot;: &#123;<br>    &quot;fields&quot;: &#123;<br>      &quot;*&quot;: &#123;&#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820153723.png" /></p>
<p><strong>自定义高亮html标签</strong>: 可以在highlight中使用<code>pre_tags</code>和<code>post_tags</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820154051.png" /></p>
<p>多字段高亮 使用<code>require_field_match</code>开启多个字段高亮</p>
<h3 id="倒排索引原理">倒排索引原理</h3>
<p>https://www.bilibili.com/video/BV1SQ4y1m7Ds?p=23</p>
<h1 id="第4章-es中的分词器ik分词器">第4章 ES中的分词器、IK分词器</h1>
<h2 id="分词器">分词器</h2>
<h3 id="analysis-和-analyzer">Analysis 和 Analyzer</h3>
<p><code>Analysis</code>： 文本分析是把全文本转换一系列单词(term/token)的过程，也叫分词(Analyzer)。<strong>Analysis是通过Analyzer来实现的</strong>。</p>
<p><code>分词就是将文档通过Analyzer分成一个一个的Term(关键词查询),每一个Term都指向包含这个Term的文档</code>。</p>
<h3 id="analyzer-组成">Analyzer 组成</h3>
<p>StandardAnalyzer 标准分词器 (ES默认分词器)</p>
<ul>
<li>中文进行单字分词, 英文按照单词分词</li>
</ul>
<blockquote>
<p>eg : 我是中国人 this is good man</p>
<p>标准分词后: 我 是 中 国 人 this is good man</p>
</blockquote>
<p>分析器（analyzer）都由三种构件组成的：<code>character filters</code> ， <code>tokenizers</code> ， <code>token filters</code>。</p>
<ul>
<li><code>character filter</code> 字符过滤器
<ul>
<li>在一段文本进行分词之前，先进行预处理，比如说最常见的就是，过滤html标签（hello --&gt; hello），&amp; --&gt; and（I&amp;you --&gt; I and you）</li>
</ul></li>
<li><code>tokenizers</code> 分词器
<ul>
<li>英文分词可以根据空格将单词分开，中文分词比较复杂，可以采用机器学习算法来分词。</li>
</ul></li>
<li><code>Token filters</code> Token过滤器
<ul>
<li><strong>将切分的单词进行加工</strong>。大小写转换（例将“Quick”转为小写），去掉停用词（例如停用词像“a”、“and”、“the”等等），加入同义词（例如同义词像“jump”和“leap”）。</li>
</ul></li>
</ul>
<p>注意：</p>
<ul>
<li>三者顺序: Character Filters—&gt;Tokenizer—&gt;Token Filter</li>
<li>三者个数：Character Filters（0个或多个） + Tokenizer + Token Filters(0个或多个)</li>
</ul>
<h3 id="内置分词器">内置分词器</h3>
<ul>
<li><strong>Standard Analyzer</strong> - 默认分词器，英文按单词词切分，并小写处理; 对中文进行单字分词</li>
<li>Simple Analyzer - 按照单词切分(符号被过滤), 小写处理</li>
<li>Stop Analyzer - 小写处理，停用词过滤（the，a，is）</li>
<li>WhiteSpace Analyzer - 按照空格切分，不转小写</li>
<li>Keyword Analyzer - 不分词，直接将输入当作输出</li>
</ul>
<h3 id="内置分词器测试">内置分词器测试</h3>
<ul>
<li>标准分词器
<ul>
<li>特点：按照单词分词，英文统一转为小写，过滤标点符号；中文单字分词</li>
</ul></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">POST /_analyze<br>&#123;<br>  &quot;analyzer&quot;: &quot;standard&quot;,<br>  &quot;text&quot;: &quot;this is a , good Man 中华人民共和国&quot;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820195527.png" /></p>
<ul>
<li>Simple 分词器
<ul>
<li>特点：英文按照单词分词，英文统一转为小写，去掉符号；中文按照空格进行分词</li>
</ul></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820195717.png" /></p>
<ul>
<li>Whitespace 分词器
<ul>
<li>特点：中文 英文 按照空格分开，英文不会转为小写，不去掉标点符号</li>
</ul></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220820195928.png" /></p>
<h4 id="创建索引设置分词">创建索引设置分词</h4>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">PUT /索引名<br>&#123;<br>  &quot;settings&quot;: &#123;&#125;,<br>  &quot;mappings&quot;: &#123;<br>    &quot;properties&quot;: &#123;<br>      &quot;title&quot;:&#123;<br>        &quot;type&quot;: &quot;text&quot;,<br>        &quot;analyzer&quot;: &quot;standard&quot; //显示指定分词器<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="中文分词器-ik分词器">中文分词器 (IK分词器)</h2>
<p>在ES中支持中文分词器非常多 如 <strong>smartCN</strong>、<strong>IK</strong> 等，推荐的就是 <code>IK分词器</code>。</p>
<h3 id="ik使用">IK使用</h3>
<p>IK有两种颗粒度的拆分：</p>
<ul>
<li><code>ik_smart</code>: 会做最粗粒度的拆分</li>
<li><code>ik_max_word</code>: 会将文本做最细粒度的拆分</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs HTTP">POST /_analyze<br>&#123;<br>  &quot;analyzer&quot;: &quot;ik_smart&quot;,<br>  &quot;text&quot;: &quot;中华人民共和国国歌&quot;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/dfd956c0819e4a458c97e5dbe2a36abf.png" /></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs HTTP">POST /_analyze<br>&#123;<br>  &quot;analyzer&quot;: &quot;ik_max_word&quot;,<br>  &quot;text&quot;: &quot;中华人民&quot;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5203cd48ae694b788cdef6a0a534ecb8.png" /></p>
<h3 id="扩展词停用词配置">扩展词、停用词配置</h3>
<p>IK支持自定义<code>扩展词典</code>和<code>停用词典</code></p>
<ul>
<li><strong><code>扩展词典</code></strong> 就是有些词并不是关键词,但是也希望被ES用来作为检索的关键词,可以将这些词加入扩展词典。</li>
<li><strong><code>停用词典</code></strong> 就是有些词是关键词,但是出于业务场景不想使用这些关键词被检索到，可以将这些词放入停用词典。</li>
</ul>
<p>定义扩展词典和停用词典可以修改IK分词器中<code>config</code>目录中<code>IKAnalyzer.cfg.xml</code>这个文件。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 修改vim IKAnalyzer.cfg.xml<br><br><span class="hljs-code">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-code">    &lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;</span><br><span class="hljs-code">    &lt;properties&gt;</span><br><span class="hljs-code">        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;</span><br><span class="hljs-code">        &lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="hljs-code">        &lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;</span><br><span class="hljs-code">         &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="hljs-code">        &lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopword.dic&lt;/entry&gt;</span><br><span class="hljs-code">    &lt;/properties&gt;</span><br><span class="hljs-code"></span><br><span class="hljs-code">2. 在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效</span><br><span class="hljs-code">	vim ext_dict.dic </span><br><span class="hljs-code">	加入扩展词即可，一行放一个词</span><br><span class="hljs-code"></span><br><span class="hljs-code">3. 在ik分词器目录下config目录中创建ext_stopword.dic文件 </span><br><span class="hljs-code">	vim ext_stopword.dic 加入停用词即可</span><br><span class="hljs-code"></span><br><span class="hljs-code">4. 重启es生效</span><br></code></pre></td></tr></table></figure>
<p>注意：词典的编码必须为UTF-8，否则无法生效!</p>
<h1 id="第5章-过滤查询聚合查询">第5章 过滤查询、聚合查询</h1>
<h2 id="filter-query过滤查询">Filter Query(过滤查询)</h2>
<h3 id="过滤查询">过滤查询</h3>
<p>其实准确来说，ES中的查询操作分为2种: <code>查询(query)</code>和<code>过滤(filter)</code>。</p>
<ul>
<li>查询即是之前提到的query查询，它(查询)默认会<strong>计算每个返回文档的得分，然后根据得分排序</strong>。</li>
<li>过滤(filter)只会<strong>筛选出符合的文档，并不计算得分</strong>，且它可以缓存文档 。所以，单从<strong>性能</strong>考虑，<strong>过滤比查询更快</strong>。</li>
</ul>
<p>换句话说，过滤适合在大范围筛选数据，而查询则适合精确匹配数据。一般应用时， <strong><code>应先使用过滤操作过滤数据， 然后使用查询匹配数据。</code></strong></p>
<p><img src="https://img-blog.csdnimg.cn/407fdf90fc7140949b3172311caa36c0.png" /></p>
<h3 id="过滤语法">过滤语法</h3>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">// 从所有文档中过滤age&gt;=10的文档<br>GET /ems/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;bool&quot;: &#123;<br>      &quot;must&quot;: [<br>        &#123;&quot;match_all&quot;: &#123;&#125;&#125;<br>      ],<br>      &quot;filter&quot;: &#123;<br>        &quot;range&quot;: &#123;<br>          &quot;age&quot;: &#123;<br>            &quot;gte&quot;: 10<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>在执行filter和query时，<strong>先执行filter在执行query</strong></p></li>
<li><p>Elasticsearch会自动缓存经常使用的过滤器，以加快性能。</p></li>
</ul>
<h3 id="常见的过滤器类型">常见的过滤器类型</h3>
<h4 id="term-terms-filter">term 、terms Filter</h4>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">// 先过滤出content字段关键词为spring的文档,再query出name为黑的文档<br>GET /ems/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;bool&quot;: &#123;<br>      &quot;must&quot;: [<br>        &#123;<br>          &quot;term&quot;: &#123;<br>            &quot;name&quot;: &#123;<br>              &quot;value&quot;: &quot;黑&quot;<br>            &#125;<br>          &#125;<br>        &#125;<br>      ],<br>      &quot;filter&quot;: &#123;<br>        &quot;term&quot;: &#123;<br>          &quot;content&quot;:&quot;spring&quot;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">// 找到content中过滤不包含 科技,声音的文档, 然后在进行term关键词查询name为中国的文档<br>GET /dangdang/_search  #使用terms过滤<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;bool&quot;: &#123;<br>      &quot;must&quot;: [<br>        &#123;&quot;term&quot;: &#123;<br>          &quot;name&quot;: &#123;<br>            &quot;value&quot;: &quot;中国&quot;<br>          &#125;<br>        &#125;&#125;<br>      ],<br>      &quot;filter&quot;: &#123;<br>        &quot;terms&quot;: &#123;<br>          &quot;content&quot;:[<br>              &quot;科技&quot;,<br>              &quot;声音&quot;<br>            ]<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ranage-filter">ranage filter</h4>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /ems/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;bool&quot;: &#123;<br>      &quot;must&quot;: [<br>        &#123;&quot;term&quot;: &#123;<br>          &quot;name&quot;: &#123;<br>            &quot;value&quot;: &quot;中国&quot;<br>          &#125;<br>        &#125;&#125;<br>      ],<br>      &quot;filter&quot;: &#123;<br>        &quot;range&quot;: &#123;<br>          &quot;age&quot;: &#123;<br>            &quot;gte&quot;: 7,<br>            &quot;lte&quot;: 20<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="exists-filter">exists filter</h4>
<p><strong>过滤出存在指定字段的文档</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">// 首先过滤出存在name字段的文档,并且进行term关键词查询,name字段中包含中国的文档<br>GET /ems/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;bool&quot;: &#123;<br>      &quot;must&quot;: [<br>        &#123;&quot;term&quot;: &#123;<br>          &quot;name&quot;: &#123;<br>            &quot;value&quot;: &quot;中国&quot;<br>          &#125;<br>        &#125;&#125;<br>      ],<br>      &quot;filter&quot;: &#123;<br>        &quot;exists&quot;: &#123;<br>          &quot;field&quot;:&quot;name&quot;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ids-filter">ids filter</h4>
<p><strong>过滤含有指定字段的索引记录</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">GET /ems/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;bool&quot;: &#123;<br>      &quot;must&quot;: [<br>        &#123;&quot;term&quot;: &#123;<br>          &quot;name&quot;: &#123;<br>            &quot;value&quot;: &quot;中国&quot;<br>          &#125;<br>        &#125;&#125;<br>      ],<br>      &quot;filter&quot;: &#123;<br>        &quot;ids&quot;: &#123;<br>          &quot;values&quot;: [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="聚合查询">聚合查询</h2>
<h3 id="简介">简介</h3>
<p>聚合：<strong>英文为Aggregation，是es除搜索功能外提供的针对es数据做统计分析的功能</strong>。聚合有助于根据搜索查询提供聚合数据。</p>
<p>聚合查询是数据库中重要的功能特性，ES作为搜索引擎兼数据库，同样提供了强大的聚合分析能力。它基于查询条件来对数据进行分桶、计算的方法。有点类似于 SQL 中的 group by 再加一些函数方法的操作。</p>
<ul>
<li>注意：text类型是不支持聚合的。</li>
</ul>
<h3 id="测试数据">测试数据</h3>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">// 创建索引 index 和映射 mapping<br>PUT /fruit<br>&#123;<br>  &quot;mappings&quot;: &#123;<br>    &quot;properties&quot;: &#123;<br>      &quot;title&quot;:&#123;<br>        &quot;type&quot;: &quot;keyword&quot;<br>      &#125;,<br>      &quot;price&quot;:&#123;<br>        &quot;type&quot;:&quot;double&quot;<br>      &#125;,<br>      &quot;description&quot;:&#123;<br>        &quot;type&quot;: &quot;text&quot;,<br>        &quot;analyzer&quot;: &quot;ik_max_word&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>// 放入测试数据<br>PUT /fruit/_bulk<br>&#123;&quot;index&quot;:&#123;&#125;&#125;<br>  &#123;&quot;title&quot; : &quot;面包&quot;,&quot;price&quot; : 19.9,&quot;description&quot; : &quot;小面包非常好吃&quot;&#125;<br>&#123;&quot;index&quot;:&#123;&#125;&#125;<br>  &#123;&quot;title&quot; : &quot;旺仔牛奶&quot;,&quot;price&quot; : 29.9,&quot;description&quot; : &quot;非常好喝&quot;&#125;<br>&#123;&quot;index&quot;:&#123;&#125;&#125;<br>  &#123;&quot;title&quot; : &quot;日本豆&quot;,&quot;price&quot; : 19.9,&quot;description&quot; : &quot;日本豆非常好吃&quot;&#125;<br>&#123;&quot;index&quot;:&#123;&#125;&#125;<br>  &#123;&quot;title&quot; : &quot;小馒头&quot;,&quot;price&quot; : 19.9,&quot;description&quot; : &quot;小馒头非常好吃&quot;&#125;<br>&#123;&quot;index&quot;:&#123;&#125;&#125;<br>  &#123;&quot;title&quot; : &quot;大辣片&quot;,&quot;price&quot; : 39.9,&quot;description&quot; : &quot;大辣片非常好吃&quot;&#125;<br>&#123;&quot;index&quot;:&#123;&#125;&#125;<br>  &#123;&quot;title&quot; : &quot;透心凉&quot;,&quot;price&quot; : 9.9,&quot;description&quot; : &quot;透心凉非常好喝&quot;&#125;<br>&#123;&quot;index&quot;:&#123;&#125;&#125;<br>  &#123;&quot;title&quot; : &quot;小浣熊&quot;,&quot;price&quot; : 19.9,&quot;description&quot; : &quot;童年的味道&quot;&#125;<br>&#123;&quot;index&quot;:&#123;&#125;&#125;<br>  &#123;&quot;title&quot; : &quot;海苔&quot;,&quot;price&quot; : 19.9,&quot;description&quot; : &quot;海的味道&quot;&#125;<br></code></pre></td></tr></table></figure>
<h3 id="使用">使用</h3>
<h4 id="根据某个字段分组">根据某个字段分组</h4>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">// 根据检索条件查询出来的文档, 进行分组;根据price进行分组,分组叫price_group<br>GET /fruit/_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;term&quot;: &#123;<br>      &quot;description&quot;: &#123;<br>        &quot;value&quot;: &quot;吃&quot;<br>      &#125;<br>    &#125;<br>  &#125;, <br>  &quot;aggs&quot;: &#123;<br>    &quot;price_group&quot;: &#123;<br>      &quot;terms&quot;: &#123;<br>        &quot;field&quot;: &quot;price&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http">&#123;<br>  &quot;took&quot; : 3,<br>  &quot;timed_out&quot; : false,<br>  &quot;_shards&quot; : &#123;<br>    &quot;total&quot; : 1,<br>    &quot;successful&quot; : 1,<br>    &quot;skipped&quot; : 0,<br>    &quot;failed&quot; : 0<br>  &#125;,<br>  &quot;hits&quot; : &#123;<br>    &quot;total&quot; : &#123;<br>      &quot;value&quot; : 4,<br>      &quot;relation&quot; : &quot;eq&quot;<br>    &#125;,<br>    &quot;max_score&quot; : 0.6489038,<br>    &quot;hits&quot; : [<br>      &#123;<br>        &quot;_index&quot; : &quot;fruit&quot;,<br>        &quot;_type&quot; : &quot;_doc&quot;,<br>        &quot;_id&quot; : &quot;xbUHXYIBkJ4IdFBIeDXc&quot;,<br>        &quot;_score&quot; : 0.6489038,<br>        &quot;_source&quot; : &#123;<br>          &quot;title&quot; : &quot;面包&quot;,<br>          &quot;price&quot; : 19.9,<br>          &quot;description&quot; : &quot;小面包非常好吃&quot;<br>        &#125;<br>      &#125;,<br>      &#123;<br>        &quot;_index&quot; : &quot;fruit&quot;,<br>        &quot;_type&quot; : &quot;_doc&quot;,<br>        &quot;_id&quot; : &quot;x7UHXYIBkJ4IdFBIeDXc&quot;,<br>        &quot;_score&quot; : 0.6489038,<br>        &quot;_source&quot; : &#123;<br>          &quot;title&quot; : &quot;日本豆&quot;,<br>          &quot;price&quot; : 19.9,<br>          &quot;description&quot; : &quot;日本豆非常好吃&quot;<br>        &#125;<br>      &#125;,<br>      &#123;<br>        &quot;_index&quot; : &quot;fruit&quot;,<br>        &quot;_type&quot; : &quot;_doc&quot;,<br>        &quot;_id&quot; : &quot;yLUHXYIBkJ4IdFBIeDXc&quot;,<br>        &quot;_score&quot; : 0.6489038,<br>        &quot;_source&quot; : &#123;<br>          &quot;title&quot; : &quot;小馒头&quot;,<br>          &quot;price&quot; : 19.9,<br>          &quot;description&quot; : &quot;小馒头非常好吃&quot;<br>        &#125;<br>      &#125;,<br>      &#123;<br>        &quot;_index&quot; : &quot;fruit&quot;,<br>        &quot;_type&quot; : &quot;_doc&quot;,<br>        &quot;_id&quot; : &quot;ybUHXYIBkJ4IdFBIeDXc&quot;,<br>        &quot;_score&quot; : 0.6489038,<br>        &quot;_source&quot; : &#123;<br>          &quot;title&quot; : &quot;大辣片&quot;,<br>          &quot;price&quot; : 39.9,<br>          &quot;description&quot; : &quot;大辣片非常好吃&quot;<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;,<br>  &quot;aggregations&quot; : &#123;<br>    &quot;price_group&quot; : &#123;<br>      &quot;doc_count_error_upper_bound&quot; : 0,<br>      &quot;sum_other_doc_count&quot; : 0,<br>      &quot;buckets&quot; : [<br>        &#123;<br>          &quot;key&quot; : 19.9,<br>          &quot;doc_count&quot; : 3<br>        &#125;,<br>        &#123;<br>          &quot;key&quot; : 39.9,<br>          &quot;doc_count&quot; : 1<br>        &#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="求最大值">求最大值</h4>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http"># 求最大值 <br>GET /fruit/_search<br>&#123;<br>  &quot;aggs&quot;: &#123;<br>    &quot;price_max&quot;: &#123;<br>      &quot;max&quot;: &#123;<br>        &quot;field&quot;: &quot;price&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/c4ed529ba46d44a8a18758bcd50bead8.png" /></p>
<h4 id="求最小值">求最小值</h4>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http"># 求最小值<br>GET /fruit/_search<br>&#123;<br>  &quot;aggs&quot;: &#123;<br>    &quot;price_min&quot;: &#123;<br>      &quot;min&quot;: &#123;<br>        &quot;field&quot;: &quot;price&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5cc7d85eb6ca418f843f6c845c4fce47.png" /></p>
<h4 id="求平均值">求平均值</h4>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http"># 求平均值<br>GET /fruit/_search<br>&#123;<br>  &quot;aggs&quot;: &#123;<br>    &quot;price_agv&quot;: &#123;<br>      &quot;avg&quot;: &#123;<br>        &quot;field&quot;: &quot;price&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/d6dfb27001944fee9c6c87cbf0686281.png" /></p>
<h4 id="求和">求和</h4>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs http"># 求和<br>GET /fruit/_search<br>&#123;<br>  &quot;aggs&quot;: &#123;<br>    &quot;price_sum&quot;: &#123;<br>      &quot;sum&quot;: &#123;<br>        &quot;field&quot;: &quot;price&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/d0289d731f1d48318012f6e7fd6187fa.png" /></p>
<h1 id="第6章-springboot整合">第6章 SpringBoot整合</h1>
<h2 id="客户端对象">客户端对象</h2>
<ul>
<li>ElasticsearchOperations</li>
<li>RestHighLevelClient <strong>推荐</strong></li>
</ul>
<h2 id="elasticsearchoperations">ElasticsearchOperations</h2>
<ul>
<li>特点：始终使用面向对象方式操作 ES
<ul>
<li>索引：用来存放详细文档集合</li>
<li>映射：用来决定放入文档的每个字段以什么样的方式录入到 ES 中 字段类型 分词器</li>
<li>文档：可以被索引的最小单元 json数据格式</li>
</ul></li>
</ul>
<h3 id="相关注解">相关注解</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Document(indexName = &quot;products&quot;, createIndex = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br><br>    <span class="hljs-meta">@Id</span> <span class="hljs-comment">// 用来将放入的id值，作为文档_id进行映射</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-meta">@Field(type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-meta">@Field(type = FieldType.Double)</span><br>    <span class="hljs-keyword">private</span> Double price;<br>    <span class="hljs-meta">@Field(type = FieldType.Text)</span><br>    <span class="hljs-keyword">private</span> String description;<br>    <br>    <span class="hljs-comment">// get set...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol type="1">
<li><code>@Document(indexName = &quot;products&quot;, createIndex = true)</code> 用在类上，作用：代表一个对象文档
<ul>
<li>indexName 属性：创建索引的名称</li>
<li>createIndex 属性：是否创建索引</li>
</ul></li>
<li><code>@Id</code> 用在属性上，作用：将对象id字段与 ES 中文档的 _id 对应</li>
<li><code>@Field(type = FieldType.Keyword)</code> 用在属性上，作用：用来描述属性在ES中存储类型以及分词情况
<ul>
<li><code>type</code> ：用来指定字段类型</li>
</ul></li>
</ol>
<h3 id="索引文档">索引文档</h3>
<p><code>save</code> 方法：创建一条文档，也可以更新一条文档。当文档id 不存在时添加文档，当文档id存在时更新文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * save 索引一条文档，也可以更新一条文档</span><br><span class="hljs-comment">     *      save 方法当文档id 不存在时添加文档，当文档id存在时更新文档</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIndex</span><span class="hljs-params">()</span> </span>&#123;<br>    Product product = <span class="hljs-keyword">new</span> Product();<br>    product.setId(<span class="hljs-number">2</span>);<br>    product.setTitle(<span class="hljs-string">&quot;锅包肉&quot;</span>);<br>    product.setPrice(<span class="hljs-number">38.0</span>);<br>    product.setDescription(<span class="hljs-string">&quot;锅包肉真好吃，直到现在都很爱吃！&quot;</span>);<br>    elasticsearchOperations.save(product);  <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="删除一条文档">删除一条文档</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>    Product product = <span class="hljs-keyword">new</span> Product();<br>    product.setId(<span class="hljs-number">1</span>);<br>    elasticsearchOperations.delete(product);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="删除所有文档">删除所有文档</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteAll</span><span class="hljs-params">()</span> </span>&#123;<br>    elasticsearchOperations.delete(Query.findAll(), Product.class);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="查询一条文档">查询一条文档</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSearch</span><span class="hljs-params">()</span> </span>&#123;<br>    Product product = elasticsearchOperations.get(<span class="hljs-string">&quot;1&quot;</span>, Product.class);<br>    System.out.println(product.getId() + product.getTitle() + product.getPrice() + product.getDescription());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="查询所有文档">查询所有文档</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;<br>    SearchHits&lt;Product&gt; productSearchHits = elasticsearchOperations.search(Query.findAll(), Product.class);<br>    System.out.println(<span class="hljs-string">&quot;总分数&quot;</span> + productSearchHits.getMaxScore());<br>    System.out.println(<span class="hljs-string">&quot;符合条件的总条数&quot;</span> + productSearchHits.getTotalHits());<br>    <span class="hljs-keyword">for</span> (SearchHit&lt;Product&gt; productSearchHit : productSearchHits) &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(productSearchHit.getContent()));  <span class="hljs-comment">// 将传入的对象序列化为json，返回给调用者</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220822124702.png" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220822124958.png" /></p>
<h2 id="resthighlevelclient-重点">RestHighLevelClient (重点)</h2>
<p>JavaREST客户端有两种模式：</p>
<ul>
<li>Java Low Level REST Client：ES官方的低级客户端。低级别的客户端通过http与Elasticearch集群通信。</li>
<li><strong>Java High Level REST Client</strong>：ES官方的高级客户端。基于上面的低级客户端，也是通过HTTP与ES集群进行通信。它提供了更多的接口。</li>
</ul>
<h3 id="创建索引">创建索引</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIndexAndMapping</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 参数1：创建索引请求对象  参数2：请求配置对象</span><br>    CreateIndexRequest createIndexRequest = <span class="hljs-keyword">new</span> CreateIndexRequest(<span class="hljs-string">&quot;products&quot;</span>);<br>    createIndexRequest.mapping(<span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;                \&quot;properties\&quot;: &#123;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;            \&quot;title\&quot;: &#123;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;                \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;            &#125;,\n&quot;</span> +<br>                               <span class="hljs-string">&quot;            \&quot;price\&quot;: &#123;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;                \&quot;type\&quot;: \&quot;double\&quot;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;            &#125;,\n&quot;</span> +<br>                               <span class="hljs-string">&quot;            \&quot;created_at\&quot;: &#123;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;                \&quot;type\&quot;: \&quot;date\&quot;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;            &#125;,\n&quot;</span> +<br>                               <span class="hljs-string">&quot;            \&quot;description\&quot;: &#123;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;                \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>                               <span class="hljs-string">&quot;                        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;            &#125;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;        &#125;\n&quot;</span> +<br>                               <span class="hljs-string">&quot;  &#125;&quot;</span>,XContentType.JSON); <span class="hljs-comment">// 指定映射  参数1：指定映射 json 结构  参数2：指定数据类型</span><br>    CreateIndexResponse createIndexResponse = restHighLevelClient.indices().create(createIndexRequest, RequestOptions.DEFAULT);<br>    System.out.println(<span class="hljs-string">&quot;创建状态：&quot;</span>+ createIndexResponse.isAcknowledged());<br>    restHighLevelClient.close();  <span class="hljs-comment">// 关闭资源</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="创建文档">创建文档</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 参数1：索引请求对象  参数2：请求配置对象</span><br>    IndexRequest indexRequest = <span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;products&quot;</span>);<br>    indexRequest.id(<span class="hljs-string">&quot;2&quot;</span>)  <span class="hljs-comment">// 手动指定文档id</span><br>        .source(<span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  \&quot;title\&quot;: \&quot;日本豆\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;  \&quot;price\&quot;: 2.0,\n&quot;</span> +<br>                <span class="hljs-string">&quot;  \&quot;created_at\&quot;: \&quot;2022-08-22\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;  \&quot;description\&quot;: \&quot;日本豆没吃过！\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>, XContentType.JSON);<br>    IndexResponse indexResponse = restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT);<br>    System.out.println(indexResponse.status());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="更新文档-1">更新文档</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 参数1：去哪个索引中更新  参数2：更新文档 id</span><br>    UpdateRequest updateRequest = <span class="hljs-keyword">new</span> UpdateRequest(<span class="hljs-string">&quot;products&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>    updateRequest.doc(<span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                      <span class="hljs-string">&quot;    \&quot;title\&quot;: \&quot;日本豆腐\&quot;\n&quot;</span> +<br>                      <span class="hljs-string">&quot;  &#125;&quot;</span>, XContentType.JSON);<br>    <span class="hljs-comment">// 参数1：更新请求对象  参数2：请求配置对象</span><br>    UpdateResponse updateResponse = restHighLevelClient.update(updateRequest, RequestOptions.DEFAULT);<br>    System.out.println(updateResponse.status());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="删除文档-1">删除文档</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 参数1：删除请求对象  参数2：请求配置对象</span><br>    DeleteRequest deleteRequest = <span class="hljs-keyword">new</span> DeleteRequest(<span class="hljs-string">&quot;products&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>    DeleteResponse deleteResponse = restHighLevelClient.delete(deleteRequest, RequestOptions.DEFAULT);<br>    System.out.println(deleteResponse.status());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="基于id查询文档">基于id查询文档</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQueryById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    GetRequest getRequest = <span class="hljs-keyword">new</span> GetRequest(<span class="hljs-string">&quot;products&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>    <span class="hljs-comment">// 参数1：查询请求对象  参数2：请求配置对象   返回值：查询响应对象</span><br>    GetResponse getResponse = restHighLevelClient.get(getRequest, RequestOptions.DEFAULT);<br>    System.out.println(<span class="hljs-string">&quot;id:&quot;</span>+getResponse.getId());<br>    System.out.println(<span class="hljs-string">&quot;source:&quot;</span>+getResponse.getSourceAsString());<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220824202304.png" /></p>
<h3 id="查询所有-matchallquery">查询所有 matchAllQuery()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSearch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;products&quot;</span>);  <span class="hljs-comment">// 指定搜索索引</span><br>    SearchSourceBuilder sourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();  <span class="hljs-comment">// 指定条件对象</span><br>    sourceBuilder.query(QueryBuilders.matchAllQuery());  <span class="hljs-comment">// 查询所有</span><br>    searchRequest.source(sourceBuilder);  <span class="hljs-comment">// 指定查询条件</span><br><br>    SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);<span class="hljs-comment">// 参数1：搜索请求对象 参数2：请求配置对象 返回</span><br><br>    System.out.println(<span class="hljs-string">&quot;总条数:&quot;</span> + searchResponse.getHits().getTotalHits().value);<br>    System.out.println(<span class="hljs-string">&quot;最大得分:&quot;</span> + searchResponse.getHits().getMaxScore());<br><br>    SearchHit[] hits = searchResponse.getHits().getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String id = hit.getId();<br>        System.out.println(<span class="hljs-string">&quot;id:&quot;</span> + id + <span class="hljs-string">&quot;source:&quot;</span> + hit.getSourceAsString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/stuxiaozhang/blogimage/img/20220824204749.png" /></p>
<p><strong>把固定的查询流程抽取出来</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(QueryBuilder queryBuilder)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;products&quot;</span>);<br><br>    <span class="hljs-comment">// 定义查询条件</span><br>    SearchSourceBuilder sourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br>    sourceBuilder.query(queryBuilder);  <span class="hljs-comment">// 指定查询条件</span><br>    searchRequest.source(sourceBuilder);<br><br>    SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);<br><br>    System.out.println(<span class="hljs-string">&quot;总条数:&quot;</span> + searchResponse.getHits().getTotalHits().value);<br>    System.out.println(<span class="hljs-string">&quot;获取文档最大得分:&quot;</span> + searchResponse.getHits().getMaxScore());<br><br>    SearchHit[] hits = searchResponse.getHits().getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String id = hit.getId();<br>        System.out.println(<span class="hljs-string">&quot;id:&quot;</span> + id + <span class="hljs-string">&quot;source:&quot;</span> + hit.getSourceAsString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="term-查询">term 查询</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">query(QueryBuilders.termQuery(<span class="hljs-string">&quot;description&quot;</span>, <span class="hljs-string">&quot;日本豆&quot;</span>));<br></code></pre></td></tr></table></figure>
<h3 id="range-查询">range 查询</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">query(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).gt(<span class="hljs-number">0</span>).lte(<span class="hljs-number">2.0</span>));<br></code></pre></td></tr></table></figure>
<h3 id="prefix-查询">prefix 查询</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">query(QueryBuilders.prefixQuery(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;锅&quot;</span>));<br></code></pre></td></tr></table></figure>
<h3 id="wildcard-查询通配符查询-一个字符-任意多个字符">wildcard 查询通配符查询 ？一个字符 *任意多个字符</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">query(QueryBuilders.wildcardQuery(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;锅*&quot;</span>));<br></code></pre></td></tr></table></figure>
<h3 id="ids-多个指定">ids 多个指定</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">query(QueryBuilders.idsQuery().addIds(<span class="hljs-string">&quot;1&quot;</span>).addIds(<span class="hljs-string">&quot;2&quot;</span>));<br></code></pre></td></tr></table></figure>
<h3 id="multi_match-多字段查询">multi_match 多字段查询</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">query(QueryBuilders.multiMatchQuery(<span class="hljs-string">&quot;日本豆&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;description&quot;</span>));<br></code></pre></td></tr></table></figure>
<h3 id="分页查询">分页查询</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分页查询 form 起始位置 size 每页展示记录数</span><br><span class="hljs-comment">     * 排序： sort</span><br><span class="hljs-comment">     * 返回指定的字段 _source 用来指定查询文档返回那些字段</span><br><span class="hljs-comment">     * 高亮结果 highlighter</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSearchForm</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest();<br>    SearchSourceBuilder sourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br><br>    <span class="hljs-comment">//创建高亮器</span><br>    HighlightBuilder highlightBuilder = <span class="hljs-keyword">new</span> HighlightBuilder();<br>    highlightBuilder.requireFieldMatch(<span class="hljs-keyword">false</span>).field(<span class="hljs-string">&quot;description&quot;</span>).field(<span class="hljs-string">&quot;title&quot;</span>).preTags(<span class="hljs-string">&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;</span>).postTags(<span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>);<br><br>    sourceBuilder.query(QueryBuilders.termQuery(<span class="hljs-string">&quot;description&quot;</span>, <span class="hljs-string">&quot;好吃&quot;</span>))<br>        .from(<span class="hljs-number">0</span>)  <span class="hljs-comment">// 起始位置 start = (page - 1) * size</span><br>        .size(<span class="hljs-number">1</span>) <span class="hljs-comment">// 每页显示条数 默认返回十条</span><br>        .sort(<span class="hljs-string">&quot;price&quot;</span>, SortOrder.DESC)   <span class="hljs-comment">// 指定排序条件</span><br>        .fetchSource(<span class="hljs-keyword">new</span> String[]&#123;&#125;, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;created_at&quot;</span>&#125;)  <span class="hljs-comment">// 参数1: 包含字段数组  参数2：排除字段数组</span><br>        .highlighter(highlightBuilder);  <span class="hljs-comment">// 高亮</span><br>    searchRequest.source(sourceBuilder);<br>    SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);<br><br>    System.out.println(<span class="hljs-string">&quot;总条数:&quot;</span> + searchResponse.getHits().getTotalHits().value);<br>    System.out.println(<span class="hljs-string">&quot;获取文档最大得分:&quot;</span> + searchResponse.getHits().getMaxScore());<br><br>    SearchHit[] hits = searchResponse.getHits().getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        System.out.println(<span class="hljs-string">&quot;id:&quot;</span> + hit.getId() + <span class="hljs-string">&quot;source:&quot;</span> + hit.getSourceAsString());<br><br>        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();<br>        <span class="hljs-keyword">if</span>(highlightFields.containsKey(<span class="hljs-string">&quot;description&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;description高亮结果：&quot;</span> + highlightFields.get(<span class="hljs-string">&quot;description&quot;</span>).fragments()[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(highlightFields.containsKey(<span class="hljs-string">&quot;title&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;title高亮结果：&quot;</span> + highlightFields.get(<span class="hljs-string">&quot;title&quot;</span>).fragments()[<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="过滤查询-1">过滤查询</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * query         ：查询 精确查询  查询计算文档得分 并根据文档得分进行返回</span><br><span class="hljs-comment">     * filter query  ：过滤查询 用来在大量数据中筛选出本地查询相关数据  不会计算文档得分</span><br><span class="hljs-comment">     * 注意：一旦 使用 query 和 filterQuery  es优先执行 filter Query 然后再执行 query</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFilterQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;products&quot;</span>);  <span class="hljs-comment">// 指定搜索索引</span><br><br>    SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);<span class="hljs-comment">// 参数1：搜索请求对象 参数2：请求配置对象 返回</span><br><br>    System.out.println(<span class="hljs-string">&quot;总条数:&quot;</span> + searchResponse.getHits().getTotalHits().value);<br>    System.out.println(<span class="hljs-string">&quot;最大得分:&quot;</span> + searchResponse.getHits().getMaxScore());<br><br>    SearchHit[] hits = searchResponse.getHits().getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String id = hit.getId();<br>        System.out.println(<span class="hljs-string">&quot;id:&quot;</span> + id + <span class="hljs-string">&quot;source:&quot;</span> + hit.getSourceAsString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="聚合查询-1">聚合查询</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于 term 进行聚合文档</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQAggs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    <span class="hljs-comment">// 参数1：查询请求对象  参数2：请求配置对象   返回值：查询响应对象</span><br>    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;products&quot;</span>);<br>    SearchSourceBuilder sourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br>    sourceBuilder<br>        .query(QueryBuilders.matchAllQuery())<br>        .aggregation(AggregationBuilders.terms(<span class="hljs-string">&quot;price_group&quot;</span>).field(<span class="hljs-string">&quot;price&quot;</span>))<br>        .size(<span class="hljs-number">0</span>);<br><br>    searchRequest.source(sourceBuilder);<br>    SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);<br><br>    <span class="hljs-comment">// 处理聚合的结果</span><br>    Aggregations aggregations = searchResponse.getAggregations();<br>    ParsedDoubleTerms parsedDoubleTerms = aggregations.get(<span class="hljs-string">&quot;price_group&quot;</span>);  <span class="hljs-comment">// 后面是什么类型，前面就写ParsedXXXTerms</span><br><br>    ParsedSum parsedSum = aggregations.get(<span class="hljs-string">&quot;price_group&quot;</span>);<br><br>    List&lt;? extends Terms.Bucket&gt; buckets = parsedDoubleTerms.getBuckets();<br>    <span class="hljs-keyword">for</span> (Terms.Bucket bucket : buckets) &#123;<br>        System.out.println(bucket.getKey() + <span class="hljs-string">&quot; &quot;</span> + bucket.getDocCount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="第7章-es集群">第7章 ES集群</h1>
<h2 id="集群-cluster">集群 cluster</h2>
<blockquote>
<p>由多个ES节点构成 集群提供负载均衡,以及es搜索吞吐量等功能,避免单节点故障</p>
</blockquote>
<p>一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。一个集群 由一个唯一的名字标识，这个名字默认就是 <code>elasticsearch</code>。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。</p>
<h2 id="节点-node">节点 node</h2>
<p>https://blog.csdn.net/m0_37989980/article/details/126195146</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ElasticSearch7</tag>
      </tags>
  </entry>
</search>
