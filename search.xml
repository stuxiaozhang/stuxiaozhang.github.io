<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django学习笔记</title>
    <url>/2020/11/10/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Django基础----视图层</title>
    <url>/2020/10/30/Django%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h1 id="2-视图层"><a href="#2-视图层" class="headerlink" title="2. 视图层"></a>2. 视图层</h1><p>视图层是Django处理请求的核心代码层，它对外接收用户请求，对内调度模型层和模版层，统合数据库和前端，最后根据业务逻辑，将处理好的数据，与前端结合，返回给用户。视图层是真正的后端，是Python工程师的‘主营业务’。</p>
<p>Django的视图层包含下面一些主要内容：</p>
<ul>
<li>URL路由</li>
<li>视图函数</li>
<li>快捷方式</li>
<li>装饰器</li>
<li>请求与响应</li>
<li>类视图</li>
<li>文件上传</li>
<li>CSV/PDF生成</li>
<li>内置中间件</li>
</ul>
<h2 id="2-1-URL路由基础"><a href="#2-1-URL路由基础" class="headerlink" title="2.1 URL路由基础"></a>2.1 URL路由基础</h2><p>URL是Web服务的入口，用户通过浏览器发送过来的任何请求，都是发送到一个指定的URL地址，然后被响应。</p>
<h3 id="2-1-1-Django如何处理请求"><a href="#2-1-1-Django如何处理请求" class="headerlink" title="2.1.1 Django如何处理请求"></a>2.1.1 Django如何处理请求</h3><p>当用户请求一个页面时，Django根据下面的逻辑执行操作：</p>
<ol>
<li><strong>决定要使用的根URLconf模块。</strong>通常，这是<code>ROOT_URLCONF</code>设置的值，但是如果传入的HttpRequest对象具有urlconf属性（由中间件设置），则其值将被用于代替<code>ROOT_URLCONF</code>设置。也就是说你可以自定义项目入口url是哪个文件！</li>
<li><strong>加载该模块并寻找可用的urlpatterns。</strong> 它是<code>django.urls.path()</code>或者<code>django.urls.re_path()</code>实例的一个列表。</li>
<li><strong>依次匹配每个URL模式，在与请求的URL相匹配的第一个模式停下来</strong>。也就是说，url匹配是从上往下的短路操作（匹配就停），所以url在列表中的位置非常关键。</li>
<li>导入并调用匹配行中给定的视图，该视图是一个简单的Python函数（被称为视图函数）,或基于类的视图。 视图将获得如下参数:</li>
<li>一个HttpRequest 实例。</li>
<li>如果匹配的表达式返回了未命名的组，那么匹配的内容将作为位置参数提供给视图。</li>
<li>关键字参数由表达式匹配的命名组组成，但是可以被<code>django.urls.path()</code>的可选参数kwargs覆盖。</li>
<li>如果没有匹配到任何表达式，或者过程中抛出异常，将调用一个适当的错误处理视图。（比如403，比如无任何反应）</li>
</ol>
<p>先看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;articles/2003/&#x27;</span>, views.special_case_2003),</span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:year&gt;/&#x27;</span>, views.year_archive),</span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:year&gt;/&lt;int:month&gt;/&#x27;</span>, views.month_archive),</span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/&#x27;</span>, views.article_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>urlpatterns是个列表，每个元素都是<code>path()</code> 或 <code>re_path()</code> 的实例</li>
<li>要捕获一段url中的值，需要使用<strong>尖括号</strong>，而不是之前的圆括号；</li>
<li>可以转换捕获到的值为指定类型，比如例子中的int。默认情况下，捕获到的结果保存为字符串类型，不包含<code>/</code>这个特殊字符；</li>
<li>匹配模式的最开头不需要添加<code>/</code>，因为默认情况下，每个url都带一个最前面的<code>/</code>，既然大家都有的部分，就不用浪费时间特别写一个了。</li>
<li>每个匹配模式都建议以斜杠结尾</li>
</ol>
<h3 id="2-1-2-path转换器"><a href="#2-1-2-path转换器" class="headerlink" title="2.1.2 path转换器"></a>2.1.2 path转换器</h3><p>默认情况下，Django内置下面的路径转换器：</p>
<ul>
<li><code>str</code>：匹配任何非空字符串，但不含斜杠<code>/</code>，如果你没有专门指定转换器，默认使用该转换器</li>
<li><code>int</code>：匹配0和正整数，返回一个int类型</li>
<li>…</li>
</ul>
<p>对于更复杂的匹配需求，可能需要自定义自己的path转换器。</p>
<p>path转换器其实就是一个类，包含下面的成员和属性：</p>
<ul>
<li>类属性<code>regex</code>：一个字符串形式的正则表达式属性；</li>
<li><code>to_python(self, value)</code> 方法：一个用来将匹配到的字符串转换为你想要的那个数据类型，并传递给视图函数。如果转换失败，它必须弹出ValueError异常；</li>
<li><code>to_url(self, value)</code>方法：将Python数据类型转换为一段url的方法，上面方法的反向操作。如果转换失败，也会弹出<code>ValueError</code>异常。</li>
</ul>
<p>例如，新建一个<code>converters.py</code>文件，与urlconf同目录，写个下面的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourDigitYearConverter</span>:</span></span><br><span class="line">    regex = <span class="string">&#x27;[0-9]&#123;4&#125;&#x27;</span>  <span class="comment"># 1234,5678....</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%04d&#x27;</span> % value</span><br></pre></td></tr></table></figure>
<p>写完类后，在URLconf 中使用<code>register_converter</code>注册它，如下所示，注册了一个yyyy：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> register_converter, path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> converters, views</span><br><span class="line"></span><br><span class="line">register_converter(converters.FourDigitYearConverter, <span class="string">&#x27;yyyy&#x27;</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;articles/2003/&#x27;</span>, views.special_case_2003),</span><br><span class="line">    path(<span class="string">&#x27;articles/&lt;yyyy:year&gt;/&#x27;</span>, views.year_archive),</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<ul>
<li>匹配部分</li>
</ul>
<p>请求的URL被看做是一个普通的Python字符串，URLconf在其上查找并匹配。<strong>进行匹配时将不包括GET或POST请求方式的参数以及域名。</strong></p>
<p>例如，在<code>https://www.example.com/myapp/</code>的请求中，URLconf将查找<code>myapp/</code>。</p>
<p>在<code>https://www.example.com/myapp/?page=3</code>的请求中，URLconf也将查找<code>myapp/</code>。</p>
<p>URLconf不检查使用何种HTTP请求方法，所有请求方法POST、GET、HEAD等都将路由到同一个URL的同一个视图。在视图中，才根据具体请求方法的不同，进行不同的处理。</p>
<ul>
<li>指定视图参数的默认值</li>
</ul>
<p>有一个小技巧，我们可以指定视图参数的默认值。 下面是一个URLconf和视图的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URLconf</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;blog/&#x27;</span>, views.page),</span><br><span class="line">    path(<span class="string">&#x27;blog/page&lt;int:num&gt;/&#x27;</span>, views.page),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图 (blog/views.py)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page</span>(<span class="params">request, num=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment"># Output the appropriate page of blog entries, according to num.</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，两个URL模式指向同一个视图<code>views.page</code>。但是第一个模式不会从URL中捕获任何值。 如果第一个模式匹配，page()函数将使用num参数的默认值”1”。 如果第二个模式匹配，page()将使用捕获的num值。</p>
<h2 id="2-2-路由转发"><a href="#2-2-路由转发" class="headerlink" title="2.2 路由转发"></a>2.2 路由转发</h2><p>通常，我们会在每个app里，各自创建一个urls.py路由模块，然后从根路由出发，将app所属的url请求，全部转发到相应的urls.py模块中。</p>
<p>路由转发使用的是<code>include()</code>方法，需要提前导入，它的参数是转发目的地路径的字符串，路径以圆点分割。每当Django 遇到<code>include()</code>时，它会去掉URL中匹配的部分并将剩下的字符串发送给include的URLconf做进一步处理，也就是转发到<strong>二级路由</strong>去。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path   </span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># ... 省略...</span></span><br><span class="line">    path(<span class="string">&#x27;community/&#x27;</span>, include(<span class="string">&#x27;aggregator.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;contact/&#x27;</span>, include(<span class="string">&#x27;contact.urls&#x27;</span>)),</span><br><span class="line">    <span class="comment"># 比如上面这个，直接跳转道contact文件？的urls里</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>




<h2 id="2-3-视图函数"><a href="#2-3-视图函数" class="headerlink" title="2.3 视图函数"></a>2.3 视图函数</h2><p>视图函数，简称视图，本质上是一个简单的Python函数，<strong>它接受Web请求并且返回Web响应。</strong></p>
<p>响应的内容可以是HTML网页、重定向、404错误，XML文档或图像等任何东西。但是，无论视图本身是个什么处理逻辑，最好都返回某种响应。</p>
<p>视图函数的代码放在项目或应用程序目录中的名为<code>views.py</code>的文件中。</p>
<h3 id="2-3-1-简单的视图"><a href="#2-3-1-简单的视图" class="headerlink" title="2.3.1 简单的视图"></a>2.3.1 简单的视图</h3><p>下面是一个返回当前日期和时间作为HTML文档的视图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_datetime</span>(<span class="params">request</span>):</span></span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    html = <span class="string">&quot;&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;&quot;</span> % now</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(html)</span><br></pre></td></tr></table></figure>
<p>让我们逐行分析一下上面的代码：</p>
<ul>
<li>首先，从<code>django.http</code>模块导入了<code>HttpResponse</code>类，以及Python的datetime库。</li>
<li>接着，我们定义了<code>current_datetime</code>视图函数。</li>
<li>每个视图函数都接收一个<code>HttpRequest</code>对象作为第一位置参数，一般取名为<code>request</code>，你可以取别的名字，但这不符合潜规则，最好不要那么做。</li>
<li>视图函数的名称没有强制规则，但尽量不要和Python及Django内置的各种名称重名，并且尽量精确地反映出它的功能，比如这里的<code>current_datetime</code>。</li>
<li>该视图返回一个<code>HttpResponse</code>对象，其中包含生成的HTML页面。</li>
</ul>
<h3 id="2-3-2-返回错误"><a href="#2-3-2-返回错误" class="headerlink" title="2.3.2 返回错误"></a>2.3.2 返回错误</h3><h4 id="默认的"><a href="#默认的" class="headerlink" title="默认的"></a>默认的</h4><p>HttpResponse的许多子类对应着除了200（代表“OK”）以外的一些常用的HTTP状态码。</p>
<p>为了标示一个错误，可以直接返回那些子类中的一个实例，而不是普通的HttpResponse。像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse, HttpResponseNotFound</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">if</span> foo:</span><br><span class="line">        <span class="keyword">return</span> HttpResponseNotFound(<span class="string">&#x27;&lt;h1&gt;Page not found&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;&lt;h1&gt;Page was found&lt;/h1&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>Django为404错误提供了一个特化的子类HttpResponseNotFound。由于一些状态码不太常用，所以不是每个状态码都有一个特化的子类。</p>
<h4 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h4><p>Django有内置的HTML模版，用于返回错误页面给用户，但是这些403，404页面实在丑陋，通常我们都自定义错误页面。</p>
<p>首先，在根URLconf中额外增加下面的条目，并导入views模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加的条目</span></span><br><span class="line">handler400 = views.bad_request</span><br><span class="line">handler403 = views.permission_denied</span><br><span class="line">handler404 = views.page_not_found</span><br><span class="line">handler500 = views.error</span><br></pre></td></tr></table></figure>


<p>然后在，app/views.py文件中增加四个处理视图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> requires_csrf_token</span><br><span class="line"></span><br><span class="line"><span class="meta">@requires_csrf_token</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bad_request</span>(<span class="params">request, exception</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;400.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@requires_csrf_token</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permission_denied</span>(<span class="params">request, exception</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;403.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@requires_csrf_token</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span>(<span class="params">request, exception</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;404.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@requires_csrf_token</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;500.html&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>再根据自己的需求，创建对应的400、403、404、500.html四个页面文件，就可以了（要注意好模板文件的引用方式，视图的放置位置等等）。</p>
<p><strong>只有当DEBUG设置为False时，这些错误视图才会被自动使用。DEBUG为True表示开发模式，Django会展示详细的错误信息页面，而不是针对性的错误页面。</strong></p>
<h3 id="2-3-3-内置的快捷方法"><a href="#2-3-3-内置的快捷方法" class="headerlink" title="2.3.3 内置的快捷方法"></a>2.3.3 内置的快捷方法</h3><p>Django在<code>django.shortcuts</code>模块中，为我们提供了很多快捷方便的类和方法，它们都很重要，使用频率很高。</p>
<h4 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">render(request, template_name, context=<span class="literal">None</span>, content_type=<span class="literal">None</span>, status=<span class="literal">None</span>, using=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结合一个给定的模板和一个给定的上下文字典，返回一个渲染后的HttpResponse对象。</strong></p>
<p><strong>必需参数：</strong></p>
<ul>
<li><strong>request</strong>：视图函数处理的当前请求，封装了请求头的所有数据，其实就是视图参数request。</li>
<li><strong>template_name</strong>：要使用的模板的完整名称或者模板名称的列表。如果是一个列表，将使用其中能够查找到的第一个模板。</li>
</ul>
<p><strong>可选参数：</strong></p>
<ul>
<li><strong>context</strong>：添加到模板上下文的一个数据字典。默认是一个空字典。可以将认可需要提供给模板的数据以字典的格式添加进去。这里有个小技巧，使用Python内置的<code>locals()</code>方法，可以方便地将函数作用域内的所有变量一次性添加进去。</li>
<li><strong>content_type</strong>：用于生成的文档的MIME类型。 默认为<code>DEFAULT_CONTENT_TYPE</code>设置的值，也就是<code>&#39;text/html&#39;</code>。</li>
<li><strong>status</strong>：响应的状态代码。 默认为200。</li>
<li><strong>using</strong>：用于加载模板使用的模板引擎的NAME。</li>
</ul>
<p><strong>范例：</strong></p>
<p>下面的例子将渲染模板<code>myapp/index.html</code>，MIME类型为<code>application/xhtml+xml</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># View code here...</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;myapp/index.html&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    &#125;, content_type=<span class="string">&#x27;application/xhtml+xml&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="redirect"><a href="#redirect" class="headerlink" title="redirect()"></a>redirect()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">redirect(to, *args, permanent=<span class="literal">False</span>,* *kwargs)</span><br></pre></td></tr></table></figure>
<p><strong>根据传递进来的url参数，返回HttpResponseRedirect。</strong></p>
<p>参数to可以是：</p>
<ul>
<li>一个模型实例：将调用模型的<code>get_absolute_url()</code>函数，反向解析出目的url；</li>
<li>URL的name名称：可能带有参数：reverse()将用于反向解析url；</li>
<li>一个绝对的或相对的URL：将原封不动的作为重定向的目标位置。</li>
</ul>
<p>默认情况下是临时重定向，如果设置<code>permanent=True</code>将永久重定向。</p>
<p><strong>范例：</strong></p>
<p>重定向到硬编码的URL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/some/url/&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>重定向到一个完整的URL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;https://www.liujiangblog.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/some/url/&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="get-object-or-404"><a href="#get-object-or-404" class="headerlink" title="get_object_or_404()"></a>get_object_or_404()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get_object_or_404(klass, *args,* *kwargs)</span><br></pre></td></tr></table></figure>
<p>这个方法，非常有用，一定熟记。</p>
<p><strong>常用于查询某个对象，找到了则进行下一步处理，如果未找到则给用户返回404页面。</strong></p>
<p>在后台，Django其实是调用了模型管理器的get()方法，只会返回一个对象。不同的是，如果get()发生异常，会引发Http404异常，从而返回404页面，而不是模型的DoesNotExist异常。</p>
<p><strong>必需参数</strong>：</p>
<ul>
<li><code>class</code>：要获取的对象的Model类名或者Queryset等；</li>
<li><code>**kwargs</code>:查询的参数，格式应该可以被get()接受。</li>
</ul>
<p><strong>范例：</strong></p>
<p>1.从MyModel中使用主键1来获取对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    obj = get_object_or_404(MyModel, pk=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这个示例等同于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        obj = MyModel.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> MyModel.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">&quot;No MyModel matches the given query.&quot;</span>)</span><br></pre></td></tr></table></figure>


<h2 id="2-4-HttpRequest对象"><a href="#2-4-HttpRequest对象" class="headerlink" title="2.4 HttpRequest对象"></a>2.4 HttpRequest对象</h2><p>每当一个用户请求发送过来，Django将HTTP数据包中的相关内容，打包成为一个HttpRequest对象，并传递给视图函数作为第一位置参数，也就是request，供我们调用。</p>
<p>所有的请求和响应对象都位于<code>django.http</code>模块内。</p>
<h4 id="HttpRequest-method"><a href="#HttpRequest-method" class="headerlink" title="HttpRequest.method"></a>HttpRequest.method</h4><p>字符串类型，表示请求使用的HTTP方法。默认为大写。 像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if request.method &#x3D;&#x3D; &#39;GET&#39;:</span><br><span class="line">    do_something()</span><br><span class="line">elif request.method &#x3D;&#x3D; &#39;POST&#39;:</span><br><span class="line">    do_something_else()</span><br></pre></td></tr></table></figure>
<p>通过这个属性来判断请求的方法，然后根据请求的方法不同，在视图中执行不同的代码。</p>
<h4 id="HttpRequest-session"><a href="#HttpRequest-session" class="headerlink" title="HttpRequest.session"></a>HttpRequest.session</h4><p>来自<code>SessionMiddleware</code>中间件：一个可读写的，类似字典的对象，表示当前会话。我们要保存用户状态，回话过程等等，靠的就是这个中间件和这个属性。</p>
<h4 id="HttpRequest-user"><a href="#HttpRequest-user" class="headerlink" title="HttpRequest.user"></a>HttpRequest.user</h4><p>来自<code>AuthenticationMiddleware</code>中间件：表示当前登录的用户的<code>AUTH_USER_MODEL</code>的实例，这个模型是Django内置的Auth模块下的User模型。如果用户当前未登录，则user将被设置为<code>AnonymousUser</code>的实例。</p>
<p>可以使用<code>is_authenticated</code>方法判断当前用户是否合法用户，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> request.user.is_authenticated:</span><br><span class="line">    ... <span class="comment"># Do something for logged-in users.</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ... <span class="comment"># Do something for anonymous users.</span></span><br></pre></td></tr></table></figure>


<p><a href="https://www.liujiangblog.com/course/django/138">其他的……</a></p>
<h2 id="2-5-HttpResponse对象"><a href="#2-5-HttpResponse对象" class="headerlink" title="2.5 HttpResponse对象"></a>2.5 HttpResponse对象</h2><p>HttpResponse类定义在django.http模块中。</p>
<p>HttpRequest对象是浏览器发送过来的请求数据的封装</p>
<p>HttpResponse对象则是你想要返回给浏览器的数据的封装。</p>
<p>HttpRequest对象由Django自动解析HTTP数据包而创建</p>
<p>而HttpResponse对象则由程序员手动创建。</p>
<p>我们编写的每个视图都要实例化、填充和返回一个HttpResponse对象。也就是函数的return值。</p>
<h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>响应的内容。bytes类型。</p>
<h4 id="status-code"><a href="#status-code" class="headerlink" title="status_code"></a>status_code</h4><p>响应的状态码，比如200。</p>
<p><a href="https://www.liujiangblog.com/course/django/140">剩下的……</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World！</title>
    <url>/2020/09/24/World/</url>
    <content><![CDATA[<p>耶嘿！小张的宇宙空间站正式开通啦！</p>
<p>这里将记录小张的成长过程！</p>
<p>小张同学加油！</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/codedog.jpg" style="zoom:50%;" />]]></content>
      <categories>
        <category>小张日记</category>
      </categories>
      <tags>
        <tag>小张日记</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习》课程笔记</title>
    <url>/2020/10/26/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h3><p>对于机器学习的两种定义：</p>
<ul>
<li>“the field of study that gives computers the ability to learn without being explicitly programmed.” - Arthur Samuel</li>
<li>“A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.” - Tom Mitchell</li>
</ul>
<p>任何机器学习问题可以归于两大类之一：<strong>监督学习（Supervised Learning）</strong>，或<strong>无监督学习（Unsupervised Learning，或称非监督学习）</strong>。当然，还有半监督学习、强化学习等，尚不在讨论范围内。</p>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>监督学习使用有标签的数据集，其任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</p>
<p>监督学习问题被分为<strong>回归（Regression）</strong>和<strong>分类（Classification）</strong>问题：</p>
<ul>
<li>回归问题：将输入变量映射到某个连续函数，即预测一个连续值；</li>
<li>分类问题：将输入变量映射到离散的类别中，即预测一个离散值。</li>
</ul>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>在无监督学习中，使用的数据集没有标签，不知道结果会是什么样子，但可以通过聚类的方式从数据中提取一个特殊的结构。</p>
<h2 id="模型与代价函数"><a href="#模型与代价函数" class="headerlink" title="模型与代价函数"></a>模型与代价函数</h2><h3 id="模型表示"><a href="#模型表示" class="headerlink" title="模型表示"></a>模型表示</h3><p>为了描述监督学习问题，我们的目标是，通过一个训练集，学习一个函数 $h:X→Y$，使得 $h(x)$ 对于对应值 $y$ 是一个很好的预测器。由于历史原因，$h(x)$ 被称为假设函数（hypothesis function）。</p>
<h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p><strong>成本函数（cost function）</strong>用于测量假设函数的准确度，即模型预测的好坏，模型参数的拟合程度：<br>$$<br>J\left(\theta_{0}, \theta_{1}\right)=\frac{1}{2 m} \sum_{i=1}^{m}\left(\hat{y}<em>{i}-y</em>{i}\right)^{2}=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x_{i}\right)-y_{i}\right)^{2}<br>$$<br>这个函数也被称为“平方误差函数（Squared error function）”或者“均方误差（Mean squared error）”。在取平均时多了一个 $\frac12$，这是为了方便计算梯度下降，求导时 $\frac12$ 将被消掉。</p>
<h2 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>在已有假设函数和代价函数的情况下，用 <strong>梯度下降（Gradient Descent）</strong>可以估计得到假设函数中的参数。迭代使用：<br>$$<br>\theta_{j}:=\theta_{j}-\alpha \frac{\partial}{\partial \theta_{j}} J\left(\theta_{0}, \theta_{1}\right)<br>$$<br>直到收敛或到达预定的迭代次数。</p>
<p>其中，$j=0,1$ 表示特征的 index，$α$ 为学习率。</p>
<h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><h3 id="引入多元"><a href="#引入多元" class="headerlink" title="引入多元"></a>引入多元</h3><p>引入以下符号：</p>
<ul>
<li>$x^{i}_j$：第 $i$ 个训练样本的特征 $j$ 的值</li>
<li>$x^{(i)}$：第 $i$ 个训练样本的所有特征</li>
<li>$m$：训练样本的数量</li>
<li>$n$：特征的数量</li>
</ul>
<p>则有多项式的假设函数：<br>$$<br>hθ(x)=θ<em>0+θ<em>1x_1+θ_2x_2+θ_3x_3+…+θ_nx_n<br>$$<br>令 $x_0=1$，则上式可以简写为：<br>$$<br>h</em>{\theta}(x)=\left[\begin{array}{llll}<br>\theta</em>{0} &amp; \theta_{1} &amp; \ldots &amp; \theta_{n}<br>\end{array}\right]\left[\begin{array}{c}<br>x_{0} \<br>x_{1} \<br>\ldots \<br>x_{n}<br>\end{array}\right]=\theta^{T} x<br>$$</p>
<h3 id="对多元的梯度下降"><a href="#对多元的梯度下降" class="headerlink" title="对多元的梯度下降"></a>对多元的梯度下降</h3><p>与单元线性回归类似，有<br>$$<br>\theta_{j}:=\theta_{j}-\alpha \frac{\partial}{\partial \theta_{j}} J(\theta_0, \theta_1,…\theta_n)<br>$$<br>已知代价函数<br>$$<br>J(\theta)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}<br>$$<br>得，当 n &gt;= 1 时，有<br>$$<br>\frac{\partial}{\partial \theta_{j}} J(\theta)=\frac{1}{m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right) x_{j}^{(i)}<br>$$<br>即多元线性回归的梯度下降为，<br>$$<br>\theta_{j}:=\theta_{j}-\alpha\frac{1}{m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right) x_{j}^{(i)}<br>$$</p>
<h3 id="实际中的梯度下降-特征缩放"><a href="#实际中的梯度下降-特征缩放" class="headerlink" title="实际中的梯度下降-特征缩放"></a>实际中的梯度下降-特征缩放</h3><p>可以通过使每个输入值再大致相同的范围内来加速梯度下降。这是因为梯度在小范围内下降快，而在大范围内下降较慢；另外，对于不平整的变量，梯度在下降至最优值的过程中会出现降低效率的震荡。</p>
<p>因此将<strong>特征缩放（feature scaling）</strong>和<strong>均值归一化（mean normalization）</strong>两种技术结合使用。<strong>特征缩放</strong>将输入值除以输入变量的范围（即最大值减去最小值），从而得到一个大小为 1 的新范围；<strong>均值归一化</strong>涉及从输入变量的值减去输入变量的平均值，从而导致输入变量的新平均值为 0。公式为：<br>$$<br>x_i:=\frac{x_i−μ_i}{s_i}<br>$$<br>其中，$μ_i$ 是特征 $i$ 所有值的平均值，$s_i$ 是特征 $i$ 的范围（最大值减最小值）。</p>
<h3 id="实际中的梯度下降-学习率"><a href="#实际中的梯度下降-学习率" class="headerlink" title="实际中的梯度下降-学习率"></a>实际中的梯度下降-学习率</h3><p>当学习率 $α$ 太小，则梯度下降太慢；而当学习率 $α$ 太大，则梯度可能不会下降，也因此不会收敛。因此有时需要观察并进行调整。</p>
<h2 id="参数计算"><a href="#参数计算" class="headerlink" title="参数计算"></a>参数计算</h2><h3 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h3><p>梯度下降是最小化 $J$ 的一种方法。第二种方法是<strong>正规方程（Normal Equation）</strong>，它显式地执行最小化，而不使用迭代式的算法。<br>$$<br>θ=(X^TX)^{−1}X^Ty<br>$$<br>正规方程方法中，无需做特征缩放。两种方法的对比如下：</p>
<table>
<thead>
<tr>
<th>梯度下降</th>
<th>正规方程</th>
</tr>
</thead>
<tbody><tr>
<td>需要选择学习率</td>
<td>不需要选择学习率</td>
</tr>
<tr>
<td>需要多次迭代</td>
<td>不需要迭代</td>
</tr>
<tr>
<td>O(kn2)O(kn2)</td>
<td>O(n3)O(n3)，需要计算 (XTX)−1(XTX)−1</td>
</tr>
<tr>
<td>当 n 较大时效果很好</td>
<td>当 n 较大时速度较慢</td>
</tr>
</tbody></table>
<p>不过正规方程方法要求 $X^TX$ 可逆。$X^TX$ 不可逆的原因有两种可能：</p>
<ol>
<li>列向量线性相关：即训练集中存在冗余特征（特征线性依赖），此时应该剔除掉多余特征；</li>
<li>特征过多（多于样本数量）：此时应该去掉影响较小的特征，或引入正则化（regularization）项。</li>
</ol>
<p>（对于特定的线性回归，正规方程是比梯度下降要快的。）</p>
<h1 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h1><h2 id="逻辑回归-Logistic-Regression"><a href="#逻辑回归-Logistic-Regression" class="headerlink" title="逻辑回归 Logistic Regression"></a>逻辑回归 Logistic Regression</h2><h3 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h3><p>$x$ 代表特征向量。<br>$$<br>h_\theta = g(\theta^Tx)<br>$$</p>
<p>$$<br>z=\theta^Tx<br>$$</p>
<p>$$<br>g(z)=\frac{1}{1+e^{-z}}<br>$$</p>
<p>其中，$g(z)$ 被称为 Sigmoid 函数（或者 Logistic 函数），将任意实数映射到 (0, 1) 区间。这样，可以通过划分判定边界（decision boundary）进行分类。</p>
<h3 id="代价函数-1"><a href="#代价函数-1" class="headerlink" title="代价函数"></a>代价函数</h3><p>Logistic Regression 不能使用和线性回归相同的成本函数，因为 Sigmoid 函数是非凸的，容易陷入局部最优。</p>
<blockquote>
<p>非凸函数意味着代价函数中会有许多局部最小值，这会影响梯度下降法寻找局部最小值。</p>
</blockquote>
<p>因此，我们重新定义 LR 的代价函数：<br>$$<br>J(\theta) = \frac{1}{m}\sum^m_{i=1}Cost(h_{\theta}(x^{(i)}), y^{(i)})<br>$$</p>
<p>$$<br>Cost(h_{\theta}(x), y) = -y log(h_{\theta}(x)) - (1-y)log(1-h_{\theta}(x))<br>$$</p>
<p>注意，$y$ 只有 0 或 1 两种取值。</p>
<p>向量化的表示为：<br>$$<br>h = g(X\theta)<br>$$</p>
<p>$$<br>J(\theta) = \frac{1}{m} \cdot (-y^Tlog(h) - (1-y)^Tlog(1-h))<br>$$</p>
<h3 id="梯度下降-1"><a href="#梯度下降-1" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>由梯度下降的一般形式：<br>$$<br>\theta_{j}:=\theta_{j}-\alpha \frac{\partial}{\partial \theta_{j}} J\left(\theta\right)<br>$$<br>可以推导出 LR 的梯度下降公式：（推导出来的555这…）<br>$$<br>\theta_j := \theta_j - \frac{\alpha}{m} \sum^m_{i=1}(h_{\theta}(x^{(i)}) - y^{(i)})x_j^{(i)}<br>$$<br>向量化表示为：<br>$$<br>\theta := \theta - \frac{\alpha}{m}X^T(g(X\theta) - \vec y)<br>$$<br>推导过程如下：（等我都明白了再回来看看吧555）</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p><strong>高偏差（high bias）</strong>或者欠拟合是指模型对已有数据的拟合较差，通常因为模型太简单或者使用过少的特征；而<strong>高方差（high variance）</strong>或者过拟合是指模型对已有数据的拟合过强，以至于对于新数据无法很好的预测，通常因为模型过于复杂。</p>
<p>两种技术可用于处理过拟合问题：</p>
<ol>
<li>减少特征数量：人工选择留下的特征，或者使用特征选择的算法；</li>
<li><strong>正则化（Regularization）</strong>：留下所有的特征，但是减小参数 $θ_j$。</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《经典卷积神经网络》</title>
    <url>/2020/12/15/%E3%80%8A%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E3%80%8B/</url>
    <content><![CDATA[<h1 id="经典卷积神经网络"><a href="#经典卷积神经网络" class="headerlink" title="经典卷积神经网络"></a>经典卷积神经网络</h1><div class="note danger">
            <p>等以后学会的知识多了，再回来重新阅读这些论文，用自己的理解写这篇文章。(泪目)</p>
          </div>



<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20210102165227347.png" alt="image-20210102165227347"></p>
<p>通过吴恩达的深度学习课程大致的了解了一些经典的卷积神经网络。在这里我没有细致的阅读论文，只是看了论文的核心思想以及一些博主的笔记，进行了一小下整理。等以后学会的知识多了，再回来重新阅读这些论文，用自己的理解写这篇文章。</p>
<p>总结的经典 CNN 模型有：</p>
<ul>
<li>LeNet-5</li>
<li>AlexNet</li>
<li>NIN (Network In Network)</li>
<li>VGG</li>
<li>Inception Net<ul>
<li>Inception Net V1（GoogLeNet）</li>
<li>Inception Net V2（未完待续…）</li>
<li>Inception Net V3（未完待续…）</li>
<li>Inception Net V4（未完待续…）</li>
<li>Inception-ResNet（未完待续…）</li>
</ul>
</li>
<li>ResNet（未完待续…）</li>
<li>Inception-ResNet（未完待续…）</li>
<li>Xception（未完待续…）</li>
<li>DenseNet（未完待续…）</li>
</ul>
<h2 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h2><p>卷积神经网络的开山之作 LeNet-5 出自论文 <a href="https://ieeexplore.ieee.org/document/726791?reload=true&arnumber=726791">Gradient-Based Learning Applied to Document Recognition</a> ，LeNet虽然不是CNN的起点，但却是后来CNN兴起的标志模型。LeNet-5 是1998年 YannLeCun 设计用于手写数字识别的模型。</p>
<p>典型的 LeNet-5 网络结构是 <strong>卷积层+池化层+全连接层</strong>，一个或多个卷积层后面跟着一个池化层的模式至今仍十分常用。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201214092832020.png" alt="image-20201214092832020"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201214091028974.png" alt="image-20201214091028974"></p>
<p><strong>LeNet-5 特点：</strong></p>
<ol>
<li>LeNet-5 针对灰度图像而训练，因此输入图片的通道数为 1。</li>
<li>该模型总共包含了约 6 万个参数，远少于当时大行其道的 MLP(Multi-Layer Perceptron) 所需。卷积层的参数较少，这也是卷积层的主要特性：<strong>局部连接</strong> 和 <strong>权值共享</strong> 所决定的。</li>
<li>典型的 LeNet-5 结构包含卷积层（CONV layer），池化层（POOL layer）和全连接层（FC layer），排列顺序一般为 CONV layer-&gt;POOL layer-&gt;CONV layer-&gt;POOL layer-&gt;FC layer-&gt;FC layer-&gt;OUTPUT layer。一个或多个卷积层后面跟着一个池化层的模式至今仍十分常用。</li>
<li>当 LeNet-5 模型被提出时，其池化层使用的是平均池化，而且各层激活函数一般选用 Sigmoid 和 tanh。现在，我们可以根据需要，做出改进，使用最大池化并选用 ReLU 作为激活函数。</li>
</ol>
<h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p>AlexNet 出自论文 <a href="http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf">ImageNet Classification with Deep Convolutional Neural Networks</a> 是 Hinton 和他的学生 Alex Krizhevsky 在 2012年 ImageNet Challenge 使用的模型结构。在 ImageNet 挑战赛一举夺魁，使得卷积神经网络再次引起人们的重视，并因此而一发不可收拾，卷积神经网络的研究如雨后春笋一般不断涌现，推陈出新。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201214150953443.png" alt="image-20201214150953443"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201214152538064.png" alt="image-20201214152538064"></p>
<p><strong>AlexNet 的特点：</strong></p>
<ol>
<li><p>AlexNet 模型与 LeNet-5 模型类似，但是更复杂，包含约 6000 万个参数。</p>
</li>
<li><p>使用了 <strong>ReLU</strong> (Rectified Linear Units) 激活函数，使收敛更快。</p>
</li>
<li><p>多 GPU 并行训练，不仅减少了训练时间，与一个GPU上训练的每个卷积层只有一半的内核数量的网络相比还降低了错误率。</p>
</li>
<li><p>使用了 <strong>局部响应归一化LRN</strong> (Local Response Normalization)，它实现了一种模仿真实神经元的横向抑制，从而在使用不同内核计算的神经元输出之间产生较大的竞争。</p>
<blockquote>
<p>横向抑制：兴奋的神经元对周围神经元有抑制作用。</p>
</blockquote>
</li>
<li><p><strong>重叠池化</strong> (Overlapping Polling)。传统方法中，相邻池化单元之间互不重叠，即 池化步长=池化窗口。重叠池化是：池化步长&lt;池化窗口。</p>
</li>
<li><p><strong>减少过拟合</strong>这里用了两种方法：</p>
<ul>
<li><p><strong>数据增强</strong>：数据增强用了两种方法。一是平移/水平翻转图像。二是改变训练图像中RGB通道的灰度。在整个训练集的图像的RGB像素值上使用PCA（主成分分析）。对于每个训练图像，我们添加多个通过PCA找到的主成分，大小与相应的特征值成比例，乘以一个随机值，该随机值属于均值为0、标准差为0.1的高斯分布。</p>
<blockquote>
<p>PCA 还没学(尴尬)，学完来填坑。</p>
</blockquote>
</li>
<li><p><strong>Dropout</strong>：以50%的概率随机将隐含层的神经元输出置为0。以这种方法被置0的神经元不参与网络的前馈和反向传播。因此，每次给网络提供了输入后，神经网络都会采用一个不同的结构，但是这些结构都共享权重。这种技术减少了神经元的复杂适应性，因为神经元无法依赖于其他特定的神经元而存在。因此，它被迫学习更强大更鲁棒的功能，使得这些神经元可以与其他神经元的许多不同的随机子集结合使用。</p>
</li>
</ul>
</li>
</ol>
<h2 id="NIN-Network-In-Network"><a href="#NIN-Network-In-Network" class="headerlink" title="NIN(Network In Network)"></a>NIN(Network In Network)</h2><p>Network in Network提出了一种全新的模型设计：用微型网络层MLP代替了传统conv层；用GAP全局平均池化代替了传统的FC层实现分类输出。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201227131143581.png" alt="image-20201227131143581"></p>
<p>这是 Network in Network 整体网络架构，包含三个mlpconv层 + 一个GAP全局平均池化层。</p>
<p>一个mlpconv中是一个3层的感知机（1个卷积层+2个全连接层）。作者表示，mlpconv中感知机层数是可以调整的，同样，mlpconv层作为一个微型网络结构，也可以被用在卷积层之间，个数随需调整。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201228152438093.png" alt="image-20201228152438093"></p>
<p><strong>NIN 特点：</strong></p>
<ul>
<li><p>NIN 由三个mlpconv 层 + 一个GAP全局平均池化层组成，其中mlpconv是由1个卷积层+2个全连接层组成</p>
</li>
<li><p><strong>NIN网络用微型网络 mlpconv层代替了传统的卷积层；用GAP代替了传统CNN模型中末尾的全连接层。</strong></p>
</li>
<li><p><strong>mlpconv概述：</strong></p>
<ol>
<li><p><strong>本身和卷积层兼容，且为深度模型，符合特征重用的思想；其中的全连接层等价于1×1卷积。</strong></p>
</li>
<li><p><strong>为局部特征块提取出更抽象的特征，从而在送入下一层之前，增加抽象性，从而提高模型整体的通用性。</strong></p>
</li>
</ol>
</li>
<li><p><strong>GAP概述：</strong></p>
<ol>
<li><p>没有了全连接层，减少了大量需要学习的参数，也降低了FC层过拟合的发生(全连接层依赖dropout)，<strong>起到正则化的效果。</strong></p>
</li>
<li><p><strong>增强了特征映射和类别之间的对应关系</strong>，更符合卷积的结构，因此特征图就<strong>更容易对应上最后要输出分类的类别置信度；</strong></p>
</li>
</ol>
<blockquote>
<p>举个栗子关于GAP(global average pooling)：</p>
<p>所谓的全局就是针对常用的平均池化而言，平均池化会有它的filter size，比如 2 * 2，全局平均池化就没有size，它针对的是整张feature map.</p>
<p>一个feature map 全局平均池化后得到一个值，再进行全连接（softmax）就会少很多参数。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201228170227319.png" alt="image-20201228170227319"></p>
</blockquote>
</li>
</ul>
<h2 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h2><p><a href="https://arxiv.org/pdf/1409.1556.pdf">VGG</a> 是 Oxford 的 <strong>V</strong>isual <strong>G</strong>eometry <strong>G</strong>roup 的组提出的。该网络是在ILSVRC 2014上的相关工作，主要工作是使用一个<strong>非常小的(3×3)卷积filter的架构</strong>对增加深度的网络进行了彻底的评估，这表明通过<strong>将深度提升到16 - 19个weight层</strong>，可以显著改善先前的配置。VGG 有两种结构，分别是 VGG16 和 VGG19 ，两者并没有本质上的区别，只是网络深度不一样。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201215153154379.png" alt="image-20201215153154379"></p>
<p><strong>VGG 的特点：</strong></p>
<ol>
<li><p><strong>vgg-block **内堆叠的卷积层都是同结构的。意味着输入和输出的尺寸一样，且卷积层可以堆叠复用（其中的实现是通过统一的size为 **3×3的kernel size + stride1 + padding(same)</strong> 实现。）</p>
</li>
<li><p><strong>较小的 kernel size</strong>。 这里全局的kernel size都为 3×3 ，而没有像其他的网络配置一样，在第一卷积层中使用较大的感受野。其实，两个3×3卷积层堆叠有5×5的有效感受野；三个3×3卷积层具有7×7的有效感受野。那为什么都使用3x3的kernel呢？例如通过使用三个3×3卷积层的堆叠来替换单个7×7层。</p>
<ol>
<li>首先，三个卷积层叠加带来了3次的ReLU的非线性修正，这使得单层layer<strong>更具有非线性，更具有识别力(or判别力)。</strong></li>
<li>其次，<strong>降低了参数量</strong>。假设三层 3×3 卷积堆叠的输入和输出有 $C$ 个通道，堆叠卷积层的参数为 $3(3^2C^2)=27C^2$ 个权重；同时，单个 7x7 卷积层将需要 $7^2C^2=49C^2$ 个参数，即参数多81％。</li>
</ol>
</li>
<li><p><strong>VGG验证了通过不断加深网络结构可以提升性能。</strong></p>
</li>
<li><p>VGG的网络结构中（除了一个）不包含AlexNet中提及的 LRN (局部响应正则化)，因为作者发现其并不能提高性能，反而会带来内存消耗和计算时间的增加。</p>
</li>
<li><p>训练的图像数据方面，为了增加数据集，和AlexNet一样，这里也采用了随机水平翻转和随机RGB色差进行数据扩增。对经过重新缩放的图片随机排序并进行随机剪裁得到固定尺寸大小为224×224的训练图像。</p>
</li>
<li><p>深度更深，参数也更多。</p>
</li>
</ol>
<p>总结：<strong>VGG和之前的AlexNet相比，深度更深，参数更多(1.38亿)，效果和可移植性更好，且模型设计的简洁而规律，从而被广泛使用。</strong></p>
<h2 id="GoogLeNet-（Inception-V1）"><a href="#GoogLeNet-（Inception-V1）" class="headerlink" title="GoogLeNet （Inception V1）"></a>GoogLeNet （Inception V1）</h2><p>2014 年，Google 提出了 Inception 网络结构，并以此构建了 [GoogLeNet](Inception Neural Network)（之所以这样命名，是为了向LeNet致敬；此外，GoogLeNet 也经常被称为 Inception Net V1，而该论文经常被称为 Inception V1）。GoogLeNet 在同年的 ImageNet Challenge 上夺得第一名。</p>
<p>从VGG中我们了解到，提高深度神经网络性能最直接的方式是<strong>增加它们的尺寸</strong>。这不仅包括增加<strong>深度：网络层次的数目</strong>；也包括它的<strong>宽度：每一层的单元数目</strong>。网络层数越深效果越好。但是会产生两个缺点：随着模型越深参数越来越多，这就导致网络比较容易过拟合，需要提供更多的训练数据；另外，复杂的网络意味计算资源使用的显著增加。</p>
<p>解决这两个问题的一个基本的方式就是<strong>引入稀疏性并将全连接层替换为稀疏的全连接层，甚至是卷积层。</strong> 然而，目前的硬件都是针对密集矩阵运算的，非均匀的稀疏数据结构会使得计算效率十分低下。那么能否有一个方法是既能引入网络的稀疏性，又可以通过密集的、容易获得的组件来覆盖假设结果（利用高性能的密集矩阵运算）。根据文献得知，稀疏矩阵乘法可以<strong>将稀疏矩阵聚类为相对密集的子矩阵</strong>，这会有更佳的性能。</p>
<p>于是，就成为了Inception架构的主要想法：考虑怎样<strong>近似卷积视觉网络的最优稀疏结构，并 用容易获得的密集组件进行覆盖</strong>。</p>
<p>下图是 GoogLeNet 网络整体架构</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/GoogLeNet.png"></p>
<p>其中 Inception 块结构如下：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201228185046046.png" alt="inception module"></p>
<p>(a)为普通的Inception块；(b)为带有1×1卷积的，可以对输入通道降维的Inception块</p>
<blockquote>
<p>为什么给出的Inception模块分为两种结构，因为(a)类结构，由于层层叠加，容易导致在连结层的通道数暴增，为了解决此问题，需要在每一个Inception块用filter组进行特征提取前，先用1×1卷积进行降维处理，于是有了(b)类的Inception结构</p>
</blockquote>
<p><strong>Inception 块的特点</strong></p>
<ul>
<li><p>Inception块之间可以堆叠使用。</p>
</li>
<li><p>添加了1×1卷积，降低输入的通道维度，避免参数过量影响训练</p>
<p><strong>1x1 卷积的作用：</strong></p>
<ul>
<li><strong>降维。</strong>移除卷积瓶颈，否则会限制网络的大小。</li>
<li><strong>减少参数量和运算量。</strong></li>
<li><strong>增加网络深度。提高非线性表示能力。</strong></li>
</ul>
</li>
<li><p>多卷积核+池化的并行结构，通过合并层进行串联，实际上让网络具备了自动选择的能力，而不是人为地设置卷积或池化，或决定卷积核的尺寸。</p>
<p><img data-src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210102163206402.png" alt="image-20210102163206402"></p>
<p>针对同一个输入层，在Inception块中有四条并行的线路，其中前1~3个是1×1卷积层，第4个是一个MaxPooling池化层，这四条线路最后的输出拥有相同的shape和不同的channel通道数。于是，这些输出最后可在channel维度进行合并。</p>
<p>例如：28×28×64，28×28×128，28×28×32，28×28×32。</p>
<p>通道合并层的shape：28×28×256(64+128+32+32)</p>
<blockquote>
<p>这块不懂(擦汗…)，等以后再回来看。</p>
</blockquote>
</li>
</ul>
<p>总结：GoogLeNet 用现有的dense结构来组合构建出最佳的稀疏结构，是改善计算机视觉神经网络的可行方法。与较浅和较窄的网络结构相比，该方法的优点在于计算量适度增加的情况下显著提高网络效果。</p>
<h2 id="Inception-v2（未完待续…）"><a href="#Inception-v2（未完待续…）" class="headerlink" title="Inception v2（未完待续…）"></a>Inception v2（未完待续…）</h2><h2 id="Inception-v3（未完待续…）"><a href="#Inception-v3（未完待续…）" class="headerlink" title="Inception v3（未完待续…）"></a>Inception v3（未完待续…）</h2><h2 id="Inception-v4（未完待续…）"><a href="#Inception-v4（未完待续…）" class="headerlink" title="Inception v4（未完待续…）"></a>Inception v4（未完待续…）</h2><h2 id="Inception-ResNet（未完待续…）"><a href="#Inception-ResNet（未完待续…）" class="headerlink" title="Inception-ResNet（未完待续…）"></a>Inception-ResNet（未完待续…）</h2><h2 id="ResNet（未完待续…）"><a href="#ResNet（未完待续…）" class="headerlink" title="ResNet（未完待续…）"></a>ResNet（未完待续…）</h2><h2 id="Xception（未完待续…）"><a href="#Xception（未完待续…）" class="headerlink" title="Xception（未完待续…）"></a>Xception（未完待续…）</h2><h2 id="DenseNet（未完待续…）"><a href="#DenseNet（未完待续…）" class="headerlink" title="DenseNet（未完待续…）"></a>DenseNet（未完待续…）</h2>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/2020/10/05/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维前缀和（计算区域内的和-）"><a href="#一维前缀和（计算区域内的和-）" class="headerlink" title="一维前缀和（计算区域内的和 ）"></a>一维前缀和（计算区域内的和 ）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>作用：能快速求出原数组中一段区间的数字和。</p>
</li>
<li><p>计算公式：计算 $[l, r]$ 区间和前缀和 <code>S[r] - S[l - 1]</code></p>
</li>
<li><p><code>a[l] + ... + a[r] = S[r] - S[l - 1]</code></p>
<p>如何推导？<br>$$<br>S_r = a_1 + a_2 + …. +  a_{l-1} + a_l + … + a_r<br>$$</p>
<p>$$<br>S_{l-1} = a_1 + a_2 + …. + a_{l-1}<br>$$</p>
</li>
</ul>
<p>  $(1) - (2)$ 得：<br>  $$<br>  S_r - S_{l-1} = a_l + …. + a_r<br>  $$</p>
<ul>
<li><p>为什么下标要从 $1$ 开始？</p>
<p>比如 $[1, 10] =&gt;$ $S_{10} - S_{0} = S_{10}$ ，这样可以统一处理所有情况。 </p>
</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>差分操作和前缀和一样数组下标都从1开始。</strong></p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N],S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) S[i] = S[i - <span class="number">1</span>] + a[i]; <span class="comment">// 前缀和的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,S[r] - S[l<span class="number">-1</span>]);  <span class="comment">// 区间和的计算</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1、AcWing-795-前缀和"><a href="#1、AcWing-795-前缀和" class="headerlink" title="1、AcWing 795. 前缀和"></a>1、<a href="https://www.acwing.com/problem/content/description/797/">AcWing 795. 前缀和</a></h4><blockquote>
<p>模板题</p>
</blockquote>
<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>$S [i, j]$ = 第i行j列格子左上部分所有元素的和</li>
</ul>
<ol>
<li><p><strong>如何计算前缀和矩阵？</strong></p>
<p><strong>容斥原理：</strong><br>$$<br>S_{x,y} = S_{x-1,y} +  S_{x,y-1} - S_{x-1,y-1} + a_{x,y}<br>$$</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/算法基础/基础算法/前缀和与差分/image-20201005210359578.png" alt="image-20201005210359578" style="zoom:80%;" />
</li>
<li><p><strong>如何利用前缀和矩阵，计算某一子矩阵的和？</strong></p>
</li>
</ol>
<ul>
<li><p>以 $(x1, y1)$ 为左上角，$(x2, y2)$ 为右下角的子矩阵的和为：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/image-20201005210336024.png" alt="image-20201005210336024"></p>
</li>
</ul>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N], S[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            S[i][j] += S[i - <span class="number">1</span>][j] + S[i][j - <span class="number">1</span>] - S[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S[x2][y2] - S[x2][y1 - <span class="number">1</span>] - S[x1 - <span class="number">1</span>][y2] + S[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><strong>差分是前缀和的逆运算。</strong></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/image-20201005210457677.png" alt="image-20201005210457677"></p>
<p>$b[i]$ 是差分数组， $a[i]$ 是原数组，其实原数组 相当于 前缀和数组，所以 $a[i]$ 我用 $S[i]$ 代替，即 $S[i]$ 是前缀和数组。</p>
<p>拥有数组 $b[n]$ 后，想要对 $S[n]$ 中所有的数据加上 $c$ ,只需要将 $b[1]+c$ 即可，因为 $S[n]$ 是 $a[n]$的前缀和，$S[i]=b[1]+b[2]+b[3]+……+b[n]$ 。$b[1]$ 是所有的 $S[i]$ 都拥有的子元素，将$b[1]+c$，那么 $a[n]$ 中所有的数据都会加上 $c$ 。如果想将 $S[n]$ 中 $[l,r]$ 部分的数据全部加上c，只需要将 $b[l]+c$ ,然后 $b[r+1]-c$ 即可。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p><strong>差分操作和前缀和一样数组下标都从1开始。</strong><br>$b[l]+c$ 后，$l$ 后面的数组都会加 $c$ 。$r$ 后面的数据也会被改变，要改回来就得 $b[r+1]-c$</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[N];  <span class="comment">// 差分数组</span></span><br><span class="line"><span class="keyword">int</span> S[N];  <span class="comment">// 原数组</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 1. 输入原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">cin</span> &gt;&gt; S[i];  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构造差分数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] = S[i] - S[i - <span class="number">1</span>]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 求</span></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        </span><br><span class="line">        b[l] += c;      <span class="comment">// 将l和以后+c</span></span><br><span class="line">        b[r + <span class="number">1</span>] -= c;  <span class="comment">// 将r之后-c(r + 1 和以后)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] + b[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="差分矩阵"><a href="#差分矩阵" class="headerlink" title="差分矩阵"></a>差分矩阵</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>有些难理解…</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/image-20201005210540990.png" alt="image-20201005210540990"></p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S[N][N];  <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="keyword">int</span> b[N][N];  <span class="comment">// 差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 输入原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; S[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 2. 构造差分数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += S[i][j];</span><br><span class="line">            b[i + <span class="number">1</span>][j] -= S[i][j];</span><br><span class="line">            b[i][j + <span class="number">1</span>] -= S[i][j];</span><br><span class="line">            b[i + <span class="number">1</span>][j + <span class="number">1</span>] += S[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 求</span></span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        </span><br><span class="line">        b[x1][y1] += c;</span><br><span class="line">        b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">        b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">        b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 差分数组求前缀和才变回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; b[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>算法基础</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2020/10/03/%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>二分关键词：“最大值最小”，“最小值最大”，“平均值最大/最小”</strong></p>
<blockquote>
<p>一个题目，如果一个区间具有单调性质，那么一定可以二分，但是如果说这道题目没有单调性质，而是具有某种区间性质的话，我们同样可以使用二分.<strong>（二段性）</strong></p>
<p>就是：<strong>如果有单调性，一定可以二分。</strong></p>
<p>但是可以二分的题目，不一定有单调性。也就是说，没有单调性的题目也可以二分</p>
<p>二段性：满足一段而不满足另一段，两段连上！</p>
</blockquote>
<ol>
<li>确定一个区间，使得目标一定在区间中。</li>
<li>找一个性质，满足：<ol>
<li>性质具有二段性（答案是性质的边界）所有二分都成立</li>
<li>答案是二段性的分界点</li>
</ol>
</li>
</ol>
<ul>
<li><strong>一定要好好分析 <code>check()</code> 函数</strong></li>
</ul>
<h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在一个范围内,查找一个数字,要求找到这个元素的起始位置和结束位置,请注意这个范围内的数字都是单调递增的,即具有单调性质.</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;  <span class="comment">// 一定要加1</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1、Acwing-789-数的范围"><a href="#1、Acwing-789-数的范围" class="headerlink" title="1、Acwing 789. 数的范围"></a>1、<a href="https://www.acwing.com/problem/content/description/791/">Acwing 789. 数的范围</a></h4><blockquote>
<p>模板题</p>
</blockquote>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>需要写两个二分，一个需要找到 &gt;=x 的第一个数，另一个需要找到 &lt;=x 的最后一个数</p>
<ol>
<li><p><strong>查找大于等于x的第一个位置</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">	<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>查找小于等于x的第一个位置（查找大于等于x的最后一个位置）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;  <span class="comment">// 一定要加1！</span></span><br><span class="line">	<span class="keyword">if</span> (q[mid] &lt;= x) l = mid;</span><br><span class="line">	<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>为什么这里一定要 <strong>加 1</strong> 呢？</p>
<p>答：因为如果按照上一个二分的写法，循环判断条件还是l &lt; r,当只有两个元素比如“2 2”时，l指向第一个元素，r指向第二个元素，mid指向第一个元素即 mid = l，q[mid] &lt;= x，l = mid还是指向第一个元素，指针不移动了，陷入死循环了，此刻l + 1 == r，未能退出循环。</p>
</li>
<li><p>为什么查找大于等于x的第一个位置不会死循环？</p>
<p>因为这时就算只有两个元素，l + 1 = r，mid = l，q[mid] &lt; x 时 l 是会+1的，不小于 x 时r = mid也会缩小区间。而查找小于等于x的第一个位置之所以会死循环是因为编程语言里面除以2的下取整性，试想下如果l + 1 = r时， mid = r 呢，q[mid] &lt;= x，l = mid = r，区间缩小；否则r = mid - 1 = l 区间缩小，l都会与r相遇。就不会死循环。</p>
</li>
<li><p>那如何做到上取整呢？</p>
<p>只需要取mid时在l + r后面再加1即可，这里l和r都是闭区间，所以当a[mid] &gt; x时，r = mid - 1.</p>
</li>
</ul>
</li>
</ol>
<h5 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++ ) <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找左端点，即: 大于等于x的第一个位置</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (q[l] != x) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            r = n - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 找右端点，即: 小于等于x的第一个位置</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + r + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




















<h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>将区间 <code>[l, r]</code> 划分成 <code>[l, mid]</code> 和 <code>[mid, r]</code></p>
</li>
<li><p>当区间长度足够小时就停止。一般是多2位！ </p>
<blockquote>
<p>比如题目要求小数点后六位，你就写 <code>while(r - l &gt; 1e-8)</code></p>
</blockquote>
</li>
</ul>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> ((r - l) &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="1、AcWing-790-数的三次方根"><a href="#1、AcWing-790-数的三次方根" class="headerlink" title="1、AcWing 790. 数的三次方根"></a>1、<a href="https://www.acwing.com/problem/content/792/">AcWing 790. 数的三次方根</a></h4><blockquote>
<p>模板题</p>
</blockquote>
<h5 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((r - l) &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid * mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="在stl中的二分查找"><a href="#在stl中的二分查找" class="headerlink" title="在stl中的二分查找"></a>在stl中的二分查找</h2><p><code>lower_bound( )</code> 和 <code>upper_bound( )</code>都是利用二分查找的方法在一个<u>排好序的数组中</u>进行查找的。</p>
<p>在从小到大的排序数组中，</p>
<p><strong>lower_bound( begin,end,num)**：从数组的begin位置到end-1位置二分查找</strong>第一个<u>大于或等于</u>num的数字，找到返回该数字的地址**，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p><strong>upper_bound( begin,end,num)**：从数组的begin位置到end-1位置二分查找</strong>第一个<u>大于</u>num的数字，找到返回该数字的地址，**不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p>AC 67. 数字在排序数组中出现的次数</p>
]]></content>
      <categories>
        <category>算法基础</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2020/10/07/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在利用双指针算法解题时,考虑原问题如何用暴力算法解出,观察是否可构成单调性,若可以,就可采用双指针算法对暴力算法进行优化。</p>
<p>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; i &amp;&amp; check(i , j))</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//每道题目的具体逻辑。。。</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>核心思想就是优化暴力枚举，两重循环。将 $O(n^2)$ 变为 $O(n)$ 。 </p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1、AcWing-799-最长连续不重复子序列"><a href="#1、AcWing-799-最长连续不重复子序列" class="headerlink" title="1、AcWing 799. 最长连续不重复子序列"></a>1、<a href="https://www.acwing.com/problem/content/801/">AcWing 799. 最长连续不重复子序列</a></h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>遍历数组a中的每一个元素a[i], 对于每一个i，找到j使得双指针[j, i]维护的是以a[i]结尾的最长连续不重复子序列，长度为i - j + 1, 将这一长度与r的较大者更新给r。</li>
<li>对于每一个i，如何确定j的位置：由于[j, i - 1]是前一步得到的最长连续不重复子序列，所以如果[j, i]中有重复元素，一定是a[i]，因此右移j直到a[i]不重复为止（由于[j, i - 1]已经是前一步的最优解，此时j只可能右移以剔除重复元素a[i]，不可能左移增加元素，因此，j具有“单调性”、本题可用双指针降低复杂度）。</li>
<li>用<strong>数组s记录子序列a[j ~ i]中各元素出现次数</strong>，遍历过程中对于每一个i有3步操作：将a[i]出现次数s[a[i]]加1 -&gt; 若a[i]重复则右移j（s[a[j]]要先减1，再右移） -&gt; 确定j及更新当前长度i - j + 1给r。</li>
</ol>
<h4 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h4><p>当a[i]重复时，<strong>一定要先把a[j]次数减1，再右移j。</strong></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/image-20201006172808285.png" alt="image-20201006172808285"></p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> s[N];  <span class="comment">// 记录数组元素出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]] ++ ;</span><br><span class="line">        <span class="keyword">while</span>(s[a[i]] &gt; <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]] -- ;  <span class="comment">// 先减次数</span></span><br><span class="line">            j ++ ;  <span class="comment">// 再往后移指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2、AcWing-800-数组元素的目标和"><a href="#2、AcWing-800-数组元素的目标和" class="headerlink" title="2、AcWing 800. 数组元素的目标和"></a>2、<a href="https://www.acwing.com/problem/content/description/802/">AcWing 800. 数组元素的目标和</a></h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>当 <code>a[i]+b[j]&gt;x</code> 时,随着i增加，j减少</p>
<h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i ++ ) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m; i ++ ) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[i] + b[j] == x) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法基础</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>小张的反思日记</title>
    <url>/2020/10/12/%E5%B0%8F%E5%BC%A0%E7%9A%84%E4%B8%89%E5%B9%B4%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>天亮了。</p>
<blockquote>
<p>张欣妍</p>
<p>2020.10.12 4:20</p>
</blockquote>
]]></content>
      <categories>
        <category>小张日记</category>
      </categories>
      <tags>
        <tag>小张日记</tag>
      </tags>
  </entry>
  <entry>
    <title>小张同学的2020年度总结</title>
    <url>/2020/12/31/%E5%B0%8F%E5%BC%A0%E2%80%98s2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这里是来自小张同学的2020年度总结。</p>
<p><em><a id="more"></a></em></p>
<p>Emmm….感觉没啥可写的，又觉得有好多话想说。</p>
<p>其实2020年对我而言是蛮重要的一年，是我的保研之路最后冲刺阶段。相较于其他人而言，我缺少了也许是最后一次大战命运的机会，第一次是高考，我已经错过了，而且现在想来十分后悔，当初的幼稚与不自律，让所有人都看不起我，走错了一步就改变了一生。第二次，也许就是最后一次，就是考研。既遗憾又稍有一点的开心，遗憾是因为我总有一点不甘心，总觉着我能凭借自己的努力去更好的地方，而又庆幸自己没有选择考研，因为不可控的因素实在是太多，我怕坚持不下来。</p>
<p>也许是上天的惩罚，又也许是上天的赏赐，我最后还是去了东北大学。我以为我可以有其他的选择，可是我还是和其他人一样。我曾经在很丧的时候写过一篇很倔强的日记，希望得到结果的那一天可以扬眉吐气的发出来，结果还是没有那一天。那句”趁着年轻，我偏要勉强“，我还是没做到，想起来还蛮讽刺的。反思这三年，做的最对的就是为了自己的目标一直努力的前进着，做的最错的就是太封闭自我，丝毫不了解这个专业到底需要什么，也就是没有方向的努力，方向的偏离导致了很多时候都是事倍功半。</p>
<p>看了今年写的日记，概括起来也是我这三年的总结：<strong>“你配不上自己的野心，也辜负了曾经的苦难。”</strong>。</p>
<p>今年的关键字写在了日记的第一大页，<strong>“不服输”</strong>。今年的日记基本上都是关于小二的，诸如”为什么他行，我不行“之类的。直到后来我才发现，每当我觉得我快要追上他的时候，他总是会更加牛逼的出现在我面前，像是在对我说”放弃吧小辣鸡，你永远不如我“。其实我也是这么想的，每当我以为，你行我也行的时候，就发现，我还是差了十万八千里。后来我发现我不仅欠缺的太多，而且我总是在追赶他的步伐。在这个过程中，我像是杀红了眼，只顾着追赶，忘记了我的目标我的方向。再后来，慢慢的，我不知道是因为自己明知道自己追不上他了，还是累了懒惰了，我觉得这两种可能都有，我开始放弃了。最后，我彻底放弃了，一定也有前两种原因在里面，我告诉自己，每个人都有自己的目标和方向，你何必追逐别人呢，你为什么要走他的路呢。而且，你有思考过你的方向吗。终于停下了追赶他人的脚步，虽然每次看到他有更好的成绩我依旧不甘心，可是我也做不了什么，我也就不打算做什么了。看着自己一年的日记全都是不服输，真的是……一言难尽。</p>
<p>说到今年的保研，就是另一个关键词，<strong>“不甘心”</strong>。今年的遗憾也蛮多的。院校真的看了很多，也换了很多。因为心气高，所以不敢相信，但我知道，那些真的也是我力不能及。最开始的王恺老师，到魏乐义老师，到后来的王巍老师，到最后的王鹏飞老师。尤其是王鹏飞老师，我是真的不甘心。王老师人是真的好，电话聊了那么多，真的感觉特别合得来，这是我非常喜欢的亦师亦友的感觉。可惜今年连尝试的机会都没有，不然也许都不会这么感觉遗憾。很难过错过了王鹏飞老师，都是命中注定，每个努力的瞬间，每个懒惰的瞬间，种种无数的叠加造成了今天的遗憾， 说后悔早已来不及。以后我会将王老师设立为自己的标杆，一切靠自己，如果我未来也想成为老师的话，他就是我的榜样。最后到了马老师，我跟马老师的接触并不多，但了解到他是一位为人不错的老师，看未来的日子了，来日方长，希望一切顺利吧。还记得和温可瑞学长的那通电话，整个电话的核心思想就是他告诉我：“<strong>做想清楚自己的底线，做好心理建设；然后就去拼吧！</strong>想清楚自己的底线，也就是最差结果会到什么程度，然后就没什么可怕的了，拼吧！不顾一切地拼就好了！“。我会受教，并用之于未来的路。感谢一路上所有帮助我的人，谢谢你们。</p>
<p>写着写着想起了一些事。想起了我有多么渴望得奖，证明给别人看，我也行，最后也水到了比赛得的奖。想起了我对于WK强烈的意愿，结果因为没有能力也没有好好准备，搞砸了我人生的第一场面试，想起来都丢人。想起了我今年用过的乱七八糟的壁纸。想起来一个从未谋面只因为一封邮件，就给我打电话的学长讲述了他的很多感悟的那一通电话。想起来和王鹏飞老师打电话的那个下午。想起来得到结果的那一晚哭了一整夜。想起了我的家人丢了身份证银行卡，我惊慌失措不知道怎么办只能干着急。好多画面涌现出来……2020对我来说真的是糟糕的一年，烦心事很多，真的很丧。这糟糕的一年终于要结束了……GoodBye!</p>
<p>写完这些话，伴随着一首温暖的不知名曲子，刚好是2021年了，词穷的我依然想不出什么美好的句子告别过去。刚好换了一首曲子，那就迎新吧：<strong>Tomorrow will be fine.</strong></p>
<p>放几张对于我的2020有纪念性意义的照片吧。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/NK_0.jpg"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/NK_4.jpg"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/NK_1.jpg"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/talk.png"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/tower.jpg"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/mont.jpg"></p>
<p><strong>置身于这样的环境去学习 和 在这样的环境下依旧能学进去习 都是能力的体现。</strong></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/mytheme/room.jpg"></p>
<hr>
<p>希望明年加以改进的地方：</p>
<ul>
<li><p><strong>沉下心来。</strong>觉得自己在学习的时候很浮躁，而且学东西很浮很浅很表面，看了别人写的文章感觉就是有自己的思考在里面，而我是一味的照搬或者翻译，缺少思考在里面。希望以后能沉下来学东西。</p>
</li>
<li><p><strong>学会思考。</strong></p>
<ul>
<li>做事之前三思，这件事做了会有什么影响，我应该做好哪些准备，做事的顺序，会出现什么样的结果，我该如何应对之类的…</li>
<li>说话之前三思，这句话该不该说，会有什么后果。</li>
</ul>
</li>
<li><p><strong>提高情商。</strong>做一个情商高，但又不会是过于精明的让人不舒服的人。</p>
</li>
</ul>
<p>希望明年达成的目标：</p>
<ul>
<li><input disabled="" type="checkbox"> 毕业前决定好短期未来的路和方向。</li>
<li><input disabled="" type="checkbox"> 毕业前瘦到110斤。</li>
<li><input disabled="" type="checkbox"> 毕业前刷完300道算法题。</li>
<li><input disabled="" type="checkbox"> 毕业设计拿优。</li>
<li><input disabled="" type="checkbox"> 毕业前学完前端课程。</li>
<li><input disabled="" type="checkbox"> 未完待续，及时补充…</li>
</ul>
]]></content>
      <categories>
        <category>小张日记</category>
      </categories>
      <tags>
        <tag>小张日记</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序与快速选择算法</title>
    <url>/2021/01/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>第一次是在数据结构课学的快速排序。基本思路是：令 <code>i = l; j = r</code> ，选最左边的数为 pivot。<code>j --</code>从后向前找比它小的数，找到后与 pivot 交换。再 <code>i ++</code> 从前往后找比它大的数，找到后与 pivot 交换。再重复执行这一过程，直到 <code>i == j</code> 时，就找到了 pivot 的位置。再分别递归直至顺序。学了 y 总的方法感觉更聪明，是一种双指针快排的思路。</p>
<p>快速选择算法是快速排序的一种变形。通常用在未排序的数组中寻找第 k 小 / 第 k 大的元素。快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 $O(n logn)$ 至 $O(n)$ ，不过最坏情况仍然是 $O(n^2)$ 。</p>
<p><em><a id="more"></a></em></p>
<h1 id="快速排序算法 - 双指针排序"><a href="# 快速排序算法 - 双指针排序" class="headerlink" title="快速排序算法 (双指针排序)"></a> 快速排序算法 (双指针排序)</h1><h2 id="思路"><a href="# 思路" class="headerlink" title="思路"></a> 思路</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 算法基础 / 基础算法 / 快速排序 /quick_sort.jpg" style="zoom: 67%;" /></p>
<ol>
<li><strong>注意递归要退出！记得写退出条件！<code>if(l &gt;= r)</code> 时退出</strong></li>
<li><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</li>
<li><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</li>
<li><strong>递归处理左右两端</strong> (又回到 0)</li>
</ol>
<h2 id="时间复杂度"><a href="# 时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度 </h2><p> 平均时间复杂度 $O(nlogn)$，最坏情况下 $O(n^2)$，在数组已排好序的情况下出现，可以通过随机化或者取中点来避免最差情况。</p>
<blockquote>
<p>数学推导证明过程挺复杂的。算法导论上有，用主定理证明的，很详细。但是没法简化</p>
</blockquote>
<h2 id="快排模板"><a href="# 快排模板" class="headerlink" title="快排模板"></a>快排模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;  <span class="comment">// 循环退出条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;  <span class="comment">// 注意值和下角标的区别。</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    quick_sort(q, l, j), quick_sort(q, j + <span class="number">1</span>, r);  <span class="comment">// 边界不要写错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="# 注意" class="headerlink" title="注意"></a>注意 </h2><h3 id="1、边界情况分析。"><a href="#1、边界情况分析。" class="headerlink" title="1、边界情况分析。"></a>1、边界情况分析。</h3><p> 快排属于 <strong> 分治算法 </strong>，最怕的就是 <code>n 分成 0 和 n</code>，或 <code>n 分成 n 和 0</code>，这会造成<strong> 无限划分</strong>(死循环)</p>
<ol>
<li><p><strong>以 <code>j</code> 为划分时，<code>x</code> 不能选 <code>q[r]</code>  (若以 <code>i</code> 为划分, 则 <code>x</code> 不能选 <code>q[l]</code> )</strong></p>
<p>假设 <code>x = q[r]</code>：关键句子 <code>quick_sort(q, l, j), quick_sort(q, j + 1, r)</code></p>
<p>因为 <code>j</code> 的最小值是 <code>l</code>，所以 <code>[j + 1, r]</code> 不会造成无限划分，</p>
<p>但 <code>[l..j]</code>(即 <code>quick_sort(q, l, j)</code> ) 却可能造成无限划分，因为 <code>j</code> 可能为 <code>r</code> </p>
<p>举例来说，若 <code>x</code> 选为 <code>q[r]</code> ，数组中 <code>q[l..r-1] &lt; x</code> ，</p>
<p>那么这一轮循环结束时 <code>i = r, j = r</code>，这就造成了无限划分。</p>
<p>以 <code>0, 1</code> 这组数据为例，<code>x = q[r] = 1</code>，<code>do i ++ ; while(q[i] &lt; x)</code> ，</p>
<p>则 <code>i = 1 = r</code> ，<code>do j -- ; while(q[j] &gt; x)</code> ，则 <code>j = 1 = r</code> 。</p>
<p>则 <code>[0, 1]</code> 被划分成 <code>[0, 1]</code> 和 <code>[2, 1]</code> ，这就造成无限划分，即死循环。</p>
<blockquote>
<p>边界情况复杂，建议 <code>x = q[l + r &gt;&gt; 1]</code> 。</p>
</blockquote>
</li>
<li><p><strong><code>do i++; while(q[i] &lt; x)</code> 和 <code>do j--; while(q[j] &gt; x)</code> 不能用 <code>q[i] &lt;= x</code> 和 <code>q[j] &gt;= x</code>。</strong></p>
<p>举个栗子，比如 取的 <code>x</code> 刚好是数据里的最大值，执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>i+1</code>，交换的时候就是 <code>q[i + 1]</code> 和 <code>q[j]</code> 交换了，这显然不对。</p>
<p>或者举个极端情况，假设 <code>q[l..r]</code> 全相等，则执行完 <code>do i++; while(q[i] &lt;= x);</code> 之后，<code>i</code> 会自增到 <code>r+1</code>，然后继续执行 <code>q[i] &lt;= x</code> 判断条件，造成数组下标越界(但这貌似不会报错)。</p>
<p>并且如果之后的 <code>q[i] &lt;= x</code> (此时 <code>i &gt; r</code> ) 条件也不幸成立，就会造成一直循环下去(亲身实验)，造成内存超限 <code>(Memory Limit Exceeded)</code></p>
</li>
<li><p><code>if(i &lt; j) swap(q[i], q[j])</code> 能否使用 <code>i &lt;= j</code> ？</p>
<p><strong>可以使用 <code>if(i &lt;= j) swap(q[i], q[j]);</code></strong></p>
<p>因为 i = j 时，交换一下 <code>q[i],q[j]</code> 也就是交换自己，无影响，马上就会跳出循环了</p>
</li>
<li><p>最后一句能否改用 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 作为划分(用 <code>i</code> 做划分时也是同样的道理,)</p>
<p><strong>不能</strong>。根据之前的证明，最后一轮循环可以得到这些结论</p>
<ul>
<li><code>q[l..i-1] &lt;= x, q[i...r] &gt;= x</code> </li>
<li><code>q[l...j] &lt;= x, q[j+1..r] &gt;= x</code></li>
<li><code>j &lt;= i</code> </li>
</ul>
<p>所以，<code>q[l..j-1] &lt;= x</code> 是显然成立的，</p>
<p>但 <code>quick_sort(q, j, r)</code> 中的 <code>q[j]</code> 却是 <code>q[j] &lt;= x</code> ，这不符合快排的要求</p>
<p>另外一点，注意 <code>quick_sort(q, l, j-1), quick_sort(q, j, r)</code> 可能会造成无线划分</p>
<p>当 <code>x</code> 选为 <code>q[l]</code> 时会造成无限划分，报错为(MLE),</p>
<p>如果手动改为 <code>x = q[r]</code>，可以避免无限划分。</p>
<p>但是上面所说的 <code>q[j] &lt;= x</code> 的问题依然不能解决，这会造成 <code>WA (Wrong Answer)</code></p>
</li>
<li><p><strong><code>j</code> 的取值范围为 <code>[l..r-1]</code></strong> (这块还是不太懂….)</p>
<p>证明：<strong>反证法</strong></p>
<p>假设 <code>j</code> 最终的值为 <code>r</code> , 说明只有一轮循环(两轮的话 <code>j</code> 至少会自减两次)</p>
<p>说明 <code>q[r] &lt;= x</code> (因为要跳出 <code>do-while</code> 循环)</p>
<p>说明 <code>i &gt;= r</code>(<code>while</code> 循环的结束条件), <code>i</code> 为 <code>r</code> 或 <code>r + 1</code>(必不可能成立)</p>
<p>说明 <code>i</code> 自增到了 <code>r</code> , 说明 <code>q[r] &gt;= x</code> 和 <code>q[l..r-1] &lt; x</code>，</p>
<p>得出 <code>q[r] = x</code> 和 <code>q[l..r-1] &lt; x</code> 的结论，但这与 <code>x = q[l + r &gt;&gt; 1]</code> 矛盾</p>
<p><strong>反证法 </strong> 得出 <code>j &lt; r</code></p>
<p>假设 <code>j</code> 可能小于 <code>l</code> 说明 <code>q[l..r] &gt; x</code> , 矛盾</p>
<p><strong>反证法 </strong> 得出 <code>j &gt;= l</code></p>
<p>所以 <code>j</code> 的取值范围为 <code>[l..r-1]</code> ，不会造成无限划分和数组越界</p>
</li>
</ol>
<p>顺带一提用 <code>i</code> 做划分时的模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>];  <span class="comment">// 注意是向上取整, 因为向下取整可能使得 x 取到 q[l]</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, i - <span class="number">1</span>), quick_sort(q, i, r);  <span class="comment">// 不用 q[l..i],q[i+1..r]划分的道理和分析 4 中 j 的情况一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有从大到小排序的模板(仅仅改两个地方的判断符号)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span>(q[i] &gt; x);  <span class="comment">// 这里和下面</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span>(q[j] &lt; x);  <span class="comment">// 这行的判断条件改一下</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, j), quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="2、元素值 - 和 -q- 角标 - 的区别"><a href="#2、元素值 - 和 -q- 角标 - 的区别" class="headerlink" title="2、元素值 和 q[角标] 的区别"></a>2、<code>元素值 </code> 和 <code>q[角标]</code> 的区别</h3><p> 我之前一直搞错了角标的问题。正确写法是 <code>x = q[l + r &gt;&gt; 1]</code> ，我总是写成 <code>x = l + r &gt;&gt; 1; ...q[i] &lt; q[x]</code>。好蠢，一直没弄清楚 <strong><code>元素值 </code> 和 <code>q[角标]</code> 的区别</strong>。<code> 元素值</code> 就是一个数字，而 <code>q[角标]</code> 表示角标所在位置的值，相当于一个坑。快排在交换元素时，可能这个坑里的元素会有变化，而快排想要的仅仅是一个作为比较的值，模板里选了中间位置的元素值，而不是这个位置的数。之前一直没想通这个问题，直到模拟了一个错误样例才想明白。</p>
<blockquote>
<p>错误样例为：49，59，88，37，98，97，68，54，31，3</p>
</blockquote>
<p>以后遇到错误也要 <u> 多模拟样例</u>，自己想明白才是真的明白，不然也不会背了四五遍模板也记不清楚。</p>
<hr>
<h2 id="例题"><a href="# 例题" class="headerlink" title="例题"></a>例题 </h2><h3 id="1-AcWing-785- 快速排序"><a href="#1-AcWing-785- 快速排序" class="headerlink" title="1. AcWing 785. 快速排序"></a>1. <a href="https://www.acwing.com/problem/content/787/">AcWing 785. 快速排序</a></h3><p> 给定你一个长度为 n 的整数数列。</p>
<p>请你使用快速排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<p><strong>输入格式</strong></p>
<p>输入共两行，第一行包含整数 n。</p>
<p>第二行包含 n 个整数（所有整数均在 $1$ ~ $10^9$ 范围内），表示整个数列。</p>
<p><strong>输出格式</strong></p>
<p>输出共一行，包含 n 个整数，表示排好序的数列。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤100000$</p>
<p><strong>输入样例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模板题</p>
</blockquote>
<p><strong>code</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;    </span><br><span class="line">    quick_sort(q, l, j), quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ;i ++ ) <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">    quick_sort(q, <span class="number">0</span>, n - <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="快速选择算法"><a href="# 快速选择算法" class="headerlink" title="快速选择算法"></a>快速选择算法 </h1><p> 快速选择算法是快速排序的一种变形。通常用在未排序的数组中寻找第 k 小 / 第 k 大的元素。</p>
<h2 id="思路 -1"><a href="# 思路 -1" class="headerlink" title="思路"></a>思路 </h2><p> 快速选择的总体思路与快速排序一致。</p>
<ol>
<li><strong>确定分界点</strong>：<code>int x = q[l + r &gt;&gt; 1]</code>。(这里最好取中间值比较保险，因为左右两端需要考虑边界问题)</li>
<li><strong>调整区间</strong>：找到左边区间 <code>q[i] &lt; x</code> 的点 和 右边区间 <code>q[j] &gt; x</code> 的点，并交换~</li>
<li><strong>递归处理 k 在的一端</strong>：快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。直至 <code>if (l &gt;= r) return q[l];</code> 。其中 <code>q[l]</code> 或者 <code>q[r]</code> 都可以，因为最后一次递归数组里只有一个数，就是要找的数。</li>
</ol>
<h2 id="时间复杂度 -1"><a href="# 时间复杂度 -1" class="headerlink" title="时间复杂度"></a>时间复杂度 </h2><p> 快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 $O(n logn)$ 至 $O(n)$ ，不过最坏情况仍然是 $O(n^2)$ 。</p>
<p>第一层：$O(n)$</p>
<p>第二层：$O(n/2)$</p>
<p>第三层：$O(n/4)$</p>
<p>…</p>
<p>所以：$O(n·(1 + \frac{1}{2}+ \frac{1}{4} + … + \frac{1}{n})) &lt;= O(2n) = O(n)$</p>
<h2 id="快速选择模板"><a href="# 快速选择模板" class="headerlink" title="快速选择模板"></a>快速选择模板</h2><blockquote>
<p>快速选择算法：类似快排 + 二分，k 在哪半部分，就递归哪个部分。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_xuan</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> q[l];  <span class="comment">// q[l]/q[r]都可以，因为最后一次递归数组里只有一个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left_num = j - l + <span class="number">1</span>;  <span class="comment">// left_num: 左边的数有多少个</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (k &lt;= left_num) quick_xuan(q, l, j, k);  <span class="comment">// 递归左半边</span></span><br><span class="line">    <span class="keyword">else</span> quick_xuan(q, j + <span class="number">1</span>, r, k - (j - l + <span class="number">1</span>));  <span class="comment">// 递归右半边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题 -1"><a href="# 例题 -1" class="headerlink" title="例题"></a>例题 </h2><h3 id="1-AcWing-786- 第 k 个数"><a href="#1-AcWing-786- 第 k 个数" class="headerlink" title="1. AcWing 786. 第 k 个数"></a>1. <a href="https://www.acwing.com/problem/content/788/">AcWing 786. 第 k 个数</a></h3><p> 给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 $n$ 和 $k$。</p>
<p>第二行包含 $n$ 个整数（所有整数均在 $1$ ~ $10^9$ 范围内），表示整数数列。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示数列的第 k 小数。</p>
<p><strong>数据范围</strong></p>
<p>$1≤n≤100000$,<br>$1≤k≤n$</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 4 1 5 3</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模板题</p>
</blockquote>
<p><strong>code</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const <span class="built_in">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> q[N];</span><br><span class="line"><span class="built_in">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> quick_xuan(<span class="built_in">int</span> q[], <span class="built_in">int</span> l, <span class="built_in">int</span> r, <span class="built_in">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> q[l];  // q[l]/q[r]都可以，因为最后一次递归数组里只有一个数</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        do i ++ ; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        do j -- ; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> left_num = j - l + <span class="number">1</span>;  // left_num: 左边的数有多少个</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (k &lt;= left_num) quick_xuan(q, l, j, k);  // 递归左半边</span><br><span class="line">    <span class="keyword">else</span> quick_xuan(q, j + <span class="number">1</span>, r, k - (j - l + <span class="number">1</span>));  // 递归右半边</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; quick_xuan(q, <span class="number">0</span>, n - <span class="number">1</span>, k) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-AcWing-104- 货仓选址"><a href="#2-AcWing-104- 货仓选址" class="headerlink" title="2. AcWing 104. 货仓选址"></a>2. <a href="https://www.acwing.com/problem/content/106/">AcWing 104. 货仓选址</a></h3><blockquote>
<p>此题需要贪心算法。我还不会，留个坑以后填。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法基础</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>快速排序</tag>
        <tag>快速选择</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/10/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20201002121328404.png" alt="image-20201002121328404"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20201002120409804.png" alt="image-20201002120409804"></p>
<ol start="0">
<li><strong>注意递归要退出！记得写退出条件！</strong></li>
<li>将区间一分为二：<code>int mid = l + r &gt;&gt; 1 ;</code></li>
<li>递归排序 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code></li>
<li>归并：将左右两个有序序列 合并成一个有序序列</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);          <span class="comment">// 递归排序左右边</span></span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;  <span class="comment">// k是当前tmp数组里有多少数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左半边或右半边可能没有循环完，只要拿过来放入就行</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果存入tmp里面去了，得拿回来</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1、AcWing-787-归并排序"><a href="#1、AcWing-787-归并排序" class="headerlink" title="1、AcWing 787. 归并排序"></a>1、<a href="https://www.acwing.com/problem/content/789/">AcWing 787. 归并排序</a></h3><blockquote>
<p>模板题</p>
</blockquote>
<h3 id="2、AcWing-788-逆序对的数量"><a href="#2、AcWing-788-逆序对的数量" class="headerlink" title="2、AcWing 788. 逆序对的数量"></a>2、<a href="https://www.acwing.com/problem/content/790/">AcWing 788. 逆序对的数量</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。</p>
<p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</p>
<p><strong>样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 3 4 5 6 1</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20201003094921152.png" alt="image-20201003094921152"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>注意结果数据范围会爆int，所以 <code>res</code> 和 <code>merge_sort()</code> 要用 <code>long long</code> 数据类型。</li>
<li><code>res</code> 要累加啊！！！</li>
</ol>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL res = merge_sort(q, l, mid) + merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k ++ ] = q[j ++ ];</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>, i = l; i &lt;= r; i ++ , k ++ ) q[i] = tmp[k];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; merge_sort(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3、AcWing-107-超快速排序"><a href="#3、AcWing-107-超快速排序" class="headerlink" title="3、AcWing 107. 超快速排序"></a>3、<a href="https://www.acwing.com/problem/content/description/109/">AcWing 107. 超快速排序</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>在这个问题中，您必须分析特定的排序算法—-超快速排序。</p>
<p>该算法通过交换两个相邻的序列元素来处理n个不同整数的序列，直到序列按升序排序。</p>
<p>对于输入序列<code>9 1 0 5 4</code>，超快速排序生成输出<code>0 1 4 5 9</code>。</p>
<p>您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。</p>
<p><strong>输入格式</strong></p>
<p>输入包括一些测试用例。</p>
<p>每个测试用例的第一行输入整数n，代表该用例中输入序列的长度。</p>
<p>接下来n行每行输入一个整数 $a_i$ ,代表用例中输入序列的具体数据，第i行的数据代表序列中第i个数。</p>
<p>当输入用例中包含的输入序列长度为0时，输入终止，该序列无需处理。</p>
<p><strong>输出格式</strong></p>
<p>对于每个需要处理的输入序列，输出一个整数op，代表对给定输入序列进行排序所需的最小交换操作数，每个整数占一行。</p>
<p><strong>数据范围</strong></p>
<p>$0≤N&lt;5000000,$</p>
<p>$0≤a_i≤9999999990$</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">9</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>一、<strong>最少交换多少次</strong>，其实就是求<strong>逆序对的数量</strong>，所以转换到了<strong>归并排序</strong>。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20201003232550206.png" alt="image-20201003232550206"></p>
<ol>
<li><p>左右两个区域的逆序对不会受影响。</p>
</li>
<li><p>左边与 $a_i$，右边与 $a_{i+1}$ ，在逆序对交换后也不会受影响。以左边为例， $a_i &gt; a_{i+1}$ ，在这个逆序对交换后，只是逆序对数量$- 1$。因为：</p>
<ol>
<li>若 $A &gt; a_{i+1}$ ，逆序对交换后依旧是 $A &gt; a_{i+1}$ 。</li>
<li>若 $A &lt; a_{i+1}$ ，逆序对交换后依旧是 $A &lt; a_{i+1}$ 。</li>
</ol>
<p>右边同理。</p>
<p>综上，逆序对的交换，只是会使逆序对的数量$- 1$。不会对其他逆序对造成影响。</p>
</li>
</ol>
<p>二、将整个序列变成升序，等同于 逆序对数量为0。</p>
<p>假设有$k$个逆序对，变为0，也就是要操作$k$次。就是求逆序对的数量，包装了一下~</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL q[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(LL q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    LL res = merge_sort(q, l, mid) + merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k ++ ] =q[j ++ ] ;</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k ++ ] =q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l, k = <span class="number">0</span>; i &lt;= r ; i ++ , k ++ ) q[i] = tmp[k]; </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, merge_sort(q, <span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
































]]></content>
      <categories>
        <category>算法基础</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/2020/10/04/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><ul>
<li><strong>C = A + B, A &gt;= 0, B &gt;= 0</strong></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/image-20201004231525570.png" alt="image-20201004231525570"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>将数字倒序读入，注意数组里的存放位置是 <code>size()-1</code> ~ <code>0</code>，范围一定不要写错。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.size() &lt; B.size()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;      <span class="comment">//按字符串形式输入123456</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;                      <span class="comment">//按照 ‘6’‘5’‘4’‘3’‘2’‘1’压栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1、AcWing-791-高精度加法"><a href="#1、AcWing-791-高精度加法" class="headerlink" title="1、AcWing 791. 高精度加法"></a>1、<a href="https://www.acwing.com/problem/content/793/">AcWing 791. 高精度加法</a></h4><blockquote>
<p>模板题</p>
</blockquote>
<h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><ul>
<li><strong>C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</strong></li>
</ul>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>一定要模拟好样例，并且多举几个例子。比如<strong>多余的前导0问题</strong>就要处理。</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有 A &gt;= B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.size() != B.size()) <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) </span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t = t - B[i];</span><br><span class="line">        </span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();  <span class="comment">// 除去首部多余的0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cmp(A, B)) C = sub(A, B);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        C = sub(B, A);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="1、AcWing-791-高精度加法-1"><a href="#1、AcWing-791-高精度加法-1" class="headerlink" title="1、AcWing 791. 高精度加法"></a>1、<a href="https://www.acwing.com/problem/content/793/">AcWing 791. 高精度加法</a></h4><blockquote>
<p>模板题</p>
</blockquote>
<h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><ul>
<li>*<em>C = A $</em>$ b, A &gt;= 0, b &gt; 0<strong>，这里的高精乘是指</strong>高精度乘以低精度**。</li>
</ul>
<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>一定要模拟好样例，并且多举几个例子。比如<strong>多余的前导0问题</strong>就要处理。</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();  </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, C;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( b == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>); </span><br><span class="line"></span><br><span class="line">        C = mul (A, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )  <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h4 id="1、AcWing-793-高精度乘法"><a href="#1、AcWing-793-高精度乘法" class="headerlink" title="1、AcWing 793. 高精度乘法"></a>1、<a href="https://www.acwing.com/problem/content/795/">AcWing 793. 高精度乘法</a></h4><blockquote>
<p>模板题</p>
</blockquote>
<h4 id="2、A从Wing-1500-趣味数字"><a href="#2、A从Wing-1500-趣味数字" class="headerlink" title="2、A从Wing 1500. 趣味数字"></a>2、<a href="https://www.acwing.com/problem/content/description/1502/">A从Wing 1500. 趣味数字</a></h4><h5 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h5><ol>
<li><p>int : $2^{31} - 1$ 约为 $2 * 10^{9}$</p>
</li>
<li><p>long long : $2^{63} - 1$ 约为 $9 * 10^{18}$</p>
</li>
<li><p>高精加！可以先复习一下 <a href="https://www.acwing.com/problem/content/793/">高精加模板题</a> </p>
</li>
<li><p>高精乘！可以先复习一下 <a href="https://www.acwing.com/problem/content/795/">高精乘模板题</a> </p>
</li>
</ol>
<h5 id="小分析"><a href="#小分析" class="headerlink" title="小分析"></a>小分析</h5><p>给一个数字加倍， <code>A * 2</code>可以当作是 <code>A + A</code>,题中输入数字不超过20位，如果写成longlong 也会爆掉，所以还是得写成字符串形式。两个大数相加，这时，便想到了我们的 高精加！2333</p>
<p>(其实高精乘也可以hh，高精乘是高精度乘以低精度)</p>
<h5 id="小步骤"><a href="#小步骤" class="headerlink" title="小步骤"></a>小步骤</h5><ol>
<li><p>按字符串形式 输入</p>
</li>
<li><p>将乘法转为加法</p>
</li>
<li><p>将原数按要求和结果比较</p>
<ul>
<li><p>那么如何判断：加倍以后得到的数字是否可以由原数字的各数位重新排列得到 呢？</p>
<p>答：可以将两个结果排序，都是vector型的，<strong>vector 类型支持字典序比较</strong>！相同就可以呗。</p>
</li>
</ul>
</li>
</ol>
<h5 id="错误历程"><a href="#错误历程" class="headerlink" title="错误历程"></a>错误历程</h5><p>最开始写高精加模板时，忘记给<code>int t = 0</code>了，结果怎么都算不对hh气死了</p>
<p>后来忘记给原来的数字排序了，怎么输出都不对hh，看来还是得先想明白过程再写！</p>
<p><strong>捋清思路先~</strong></p>
<h5 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;  <span class="comment">//记得初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = add(A, A);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> CC = C;  <span class="comment">// 把结果先复制出来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得对两个都排序！</span></span><br><span class="line">    sort(CC.begin(), CC.end());</span><br><span class="line">    sort(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC == A) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但其实用高精乘也可以吧hhh，高精乘是高精度乘以低精度。<br>高精乘 和 高精加差不多hh</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(t);     </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = mul(A, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> CC = C;  <span class="comment">// 把结果先复制出来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得对两个都排序！</span></span><br><span class="line">    sort(CC.begin(), CC.end());</span><br><span class="line">    sort(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC == A) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>








<h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><ul>
<li><strong>A / b = C … r, A &gt;= 0, b &gt; 0</strong></li>
</ul>
<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/image-20201004231448128.png" alt="image-20201004231448128"></p>
<p>一定要捋清思路，输入时是倒过来存入数组的，但除法算的时候其实是正着算的，所以还要再倒过来遍历，也就是 <code>for (int i = A.size() - 1; i &gt;= 0; i -- )</code> ，因为同样结果也是倒着输出的，所以这里应该把正着的结果倒过来，再倒过来输出就是正着的结果。记得同样<strong>存在前导0问题</strong>。</p>
<h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> +A[i];</span><br><span class="line">        C.push_back( r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(C.begin(),C.end());</span><br><span class="line">    <span class="keyword">while</span>( C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = div(A, b, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i -- ) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="1、AcWing-794-高精度除法"><a href="#1、AcWing-794-高精度除法" class="headerlink" title="1、AcWing 794. 高精度除法"></a>1、<a href="https://www.acwing.com/problem/content/796/">AcWing 794. 高精度除法</a></h4><blockquote>
<p>模板题。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法基础</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《深度学习》课程笔记1_神经网络和深度学习</title>
    <url>/2020/11/08/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<blockquote>
<p>此篇文章是吴恩达《深度学习》课程的笔记，主要源自于黄思腾大佬的博客</p>
</blockquote>
<h1 id="神经网络和深度学习"><a href="#神经网络和深度学习" class="headerlink" title="神经网络和深度学习"></a>神经网络和深度学习</h1><h2 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h2><ul>
<li>实现一个神经网络时，如果需要遍历整个训练集，并不需要直接使用 for 循环。</li>
<li>神经网络的计算过程中，通常有一个正向过程（forward pass）或者叫<strong>正向传播步骤（forward propagation step）</strong>，接着会有一个反向过程（backward pass）或者叫<strong>反向传播步骤（backward propagation step）</strong>。</li>
</ul>
<h3 id="Logistic-回归"><a href="#Logistic-回归" class="headerlink" title="Logistic 回归"></a>Logistic 回归</h3><p><strong>逻辑回归( Logistic Regression)：</strong>是一种用于解决<strong>监督学习（Supervised Learning）</strong>问题的学习算法。</p>
<p>进行逻辑回归的目的是使训练数据的标签值与预测出来的值之间的误差最小化。</p>
<p>Logistic 回归是一个用于<strong>二分类</strong>的算法，给定一些输入，输出结果是离散值。</p>
<p>Logistic 回归中使用的参数如下：</p>
<ul>
<li>输入的特征向量：$x∈R^nx$，其中 $n^x$ 是特征数量；</li>
<li>用于训练的标签：$y∈0,1$</li>
<li>权重：$w∈R^nx$</li>
<li>偏置：$ b∈R$</li>
<li>输出：$\hat{y} = \sigma(w^Tx+b)$</li>
<li>Sigmoid 函数：</li>
</ul>
<p>$$<br>s = \sigma(w^Tx+b) = \sigma(z) = \frac{1}{1+e^{-z}}<br>$$</p>
<p>为将 $wTx+b$ 约束在 [0, 1] 间，引入 Sigmoid 函数。从下图可看出，Sigmoid 函数的值域为 [0, 1]。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201109154334967.png" alt="image-20201109154334967" style="zoom:67%;" />



<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><strong>损失函数（loss function）</strong>用于衡量<u>单个样本</u>预测结果 $\hat{y}^{(i)}$ 与真实值 $y^{(i)}$ 之间的误差。</p>
<p>最简单的损失函数定义方式为<u>平方差损失函数</u>：<br>$$<br>L(\hat{y},y) = \frac{1}{2}(\hat{y}-y)^2<br>$$<br>但 Logistic 回归中我们并不倾向于使用这样的损失函数，因为之后讨论的优化问题会变成非凸的，最后会得到很多个局部最优解，梯度下降法可能找不到全局最优值。</p>
<p>一般使用<u>交叉熵损失函数</u>：<br>$$<br>L(\hat{y},y) = -(y\log\hat{y})-(1-y)\log(1-\hat{y})<br>$$<br>损失函数是在单个训练样本中定义的，它衡量了在<strong>单个</strong>训练样本上的表现。</p>
<p>而<strong>代价函数（cost function，或者称作成本函数）</strong>衡量的是在<strong>全体</strong>训练样本上的表现，即衡量参数 w 和 b 的效果。<br>$$<br>J(w,b) = \frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})<br>$$</p>
<div class="note warning">
            <p>损失函数：针对单个训练样本。</p><p>代价函数：针对全体训练样本，是参数的总代价。</p>
          </div>





<h3 id="梯度下降法（Gradient-Descent）"><a href="#梯度下降法（Gradient-Descent）" class="headerlink" title="梯度下降法（Gradient Descent）"></a>梯度下降法（Gradient Descent）</h3><p>函数的<strong>梯度（gradient）</strong>指出了函数的最陡增长方向。即是说，按梯度的方向走，函数增长得就越快。那么按梯度的负方向走，函数值自然就降低得最快了。</p>
<p>模型的训练目标即是寻找合适的 w 与 b 以最小化代价函数值。简单起见我们先假设 w 与 b 都是一维实数，那么可以得到如下的 J 关于 w 与 b 的图：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201113092437430.png" alt="image-20201113092437430" style="zoom:67%;" />

<p>可以看到，成本函数 J 是一个<strong>凸函数</strong>，与非凸函数的区别在于其不含有多个局部最低点；选择这样的代价函数就保证了无论我们初始化模型参数如何，都能够寻找到合适的最优解。</p>
<p>参数 w 的更新公式为：<br>$$<br>w := w - \alpha\frac{dJ(w, b)}{dw}<br>$$<br>其中 α 表示学习速率，即每次更新的 w 的步伐长度。$\frac{dJ(w, b)}{dw}$ 是函数 $dJ(w,b)$ 对 w 求偏导。</p>
<p>当 w 大于最优解 w′ 时，导数大于 0，那么 w 就会向更小的方向更新。反之当 w 小于最优解 w′ 时，导数小于 0，那么 w 就会向更大的方向更新。迭代直到收敛。</p>
<p>在成本函数 J(w, b) 中还存在参数 b，因此也有：</p>
<p>$$<br>b := b - \alpha\frac{dJ(w, b)}{db}<br>$$</p>
<h3 id="计算图（Computation-Graph）"><a href="#计算图（Computation-Graph）" class="headerlink" title="计算图（Computation Graph）"></a>计算图（Computation Graph）</h3><p>神经网络中的计算即是由多个计算网络输出的前向传播与计算梯度的后向传播构成。所谓的<strong>反向传播（Back Propagation）</strong>即是当我们需要计算最终值相对于某个特征变量的导数时，我们需要利用计算图中上一步的结点定义。计算图解释了为什么我们用这种方式组织这些计算过程。</p>
<h3 id="Logistic-回归中的梯度下降法"><a href="#Logistic-回归中的梯度下降法" class="headerlink" title="Logistic 回归中的梯度下降法"></a>Logistic 回归中的梯度下降法</h3><p>假设输入的特征向量维度为 2，即输入参数共有 x1, w1, x2, w2, b 这五个。可以推导出如下的计算图：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201113080326996.png" alt="image-20201113080326996"></p>
<p>考虑单个样例，已知：<br>$$<br>L(a,y)=-(y\log a + (1-y)\log (1-a))<br>$$</p>
<p>$$<br>a=\sigma(z) = \frac{1}{1+e^{-z}}<br>$$</p>
<p>$$<br>z=w_1x_1+w_2x_2 + b<br>$$</p>
<blockquote>
<p>注：对sigmoid求导：<br>$$<br>dz=\frac{a}{1-a}<br>$$</p>
</blockquote>
<hr>
<p>首先反向求出 L 对于 a 的导数：<br>$$<br>da=\frac{dL(a,y)}{da}=-\frac{y}{a}+\frac{1-y}{1-a}<br>$$<br>然后继续反向求出 L 对于 z 的导数：<br>$$<br>dz=\frac{dL}{dz}=\frac{dL(a,y)}{dz}=\frac{dL}{da}\frac{da}{dz}=a−y<br>$$<br>依此类推求出最终的损失函数相较于原始参数的导数之后，根据如下公式进行参数更新：<br>$$<br>w_1:=w_1-\alpha dw_1<br>$$</p>
<p>$$<br>w_2:=w_2-\alpha dw_2<br>$$</p>
<p>$$<br>b:=b-\alpha db<br>$$</p>
<hr>
<p>接下来我们需要将对于单个用例的损失函数扩展到整个训练集的代价函数：<br>$$<br>J(w,b)=\frac{1}{m}\sum^m_{i=1}L(a^{(i)},y^{(i)})<br>$$</p>
<p>$$<br>a^{(i)}=\hat{y}^{(i)}=\sigma(z^{(i)})=\sigma(w^Tx^{(i)}+b)<br>$$</p>
<p>我们可以对于某个权重参数 w1，其导数计算为：<br>$$<br>dw_1=\frac{\partial J(w,b)}{\partial{w_1}}=\frac{1}{m}\sum^m_{i=1}\frac{\partial L(a^{(i)},y^{(i)})}{\partial{w_1}}<br>$$<br>完整的 Logistic 回归中某次训练的伪代码流程如下，这里仅假设特征向量的维度为 2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">J=<span class="number">0</span>; dw1=<span class="number">0</span>; dw2=<span class="number">0</span>; db=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m</span><br><span class="line">    z(i) = wx(i)+b;</span><br><span class="line">    a(i) = sigmoid(z(i));</span><br><span class="line">    J += -[y(i)log(a(i))+(<span class="number">1</span>-y(i)）log(<span class="number">1</span>-a(i));</span><br><span class="line">    dz(i) = a(i)-y(i);</span><br><span class="line">    dw1 += x1(i)dz(i);</span><br><span class="line">    dw2 += x2(i)dz(i);</span><br><span class="line">    db += dz(i);</span><br><span class="line"></span><br><span class="line">J/= m;</span><br><span class="line">dw1/= m;</span><br><span class="line">dw2/= m;</span><br><span class="line">db/= m;</span><br><span class="line">w=w-alpha*dw</span><br><span class="line">b=b-alpha*db</span><br></pre></td></tr></table></figure>
<p>上述过程在计算时有一个缺点：你需要编写两个 for 循环。第一个 for 循环遍历 m 个样本，而第二个 for 循环遍历所有特征。如果有大量特征，在代码中显式使用 for 循环会使算法很低效。<strong>向量化</strong>可以用于解决显式使用 for 循环的问题。</p>
<h3 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h3><p>在 Logistic 回归中，需要计算<br>$$<br>z=w^Tx+b<br>$$<br>如果是非向量化的循环方式操作，代码可能如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_x):</span><br><span class="line">	z[i] += w[i] * x[i];</span><br><span class="line">z += b</span><br></pre></td></tr></table></figure>


<p>而如果是向量化的操作，代码则会简洁很多，并带来近百倍的性能提升（并行指令）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = np.dot(w, x) + b</span><br></pre></td></tr></table></figure>


<p>不用显式 for 循环，实现 Logistic 回归的梯度下降一次迭代（对应之前伪代码的 for 循环部分。这里公式和 NumPy 的代码混杂，注意分辨）：<br>$$<br>Z=w^TX+b=np.dot(w.T, x) + b<br>$$</p>
<p>$$<br>A=\sigma(Z)<br>$$</p>
<p>$$<br>dZ=A-Y<br>$$</p>
<p>$$<br>dw=\frac{1}{m}XdZ^T<br>$$</p>
<p>$$<br>db=\frac{1}{m}np.sum(dZ)<br>$$</p>
<p>$$<br>w:=w-\sigma dw<br>$$</p>
<p>$$<br>b:=b-\sigma db<br>$$</p>
<p>正向和反向传播尽管如此，多次迭代的梯度下降依然需要 for 循环。</p>
<h3 id="广播（broadcasting）"><a href="#广播（broadcasting）" class="headerlink" title="广播（broadcasting）"></a>广播（broadcasting）</h3><p>Numpy 的 Universal functions 中要求输入的数组 shape 是一致的。当数组的 shape 不相等的时候，则会使用广播机制，调整数组使得 shape 一样，满足规则，则可以运算，否则就出错。</p>
<p>四条规则：</p>
<ol>
<li>让所有输入数组都向其中 shape 最长的数组看齐，shape 中不足的部分都通过在前面加 1 补齐；</li>
<li>输出数组的 shape 是输入数组 shape 的各个轴上的最大值；</li>
<li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错；</li>
<li>当输入数组的某个轴的长度为 1 时，沿着此轴运算时都用此轴上的第一组值。</li>
</ol>
<h3 id="NumPy-使用技巧"><a href="#NumPy-使用技巧" class="headerlink" title="NumPy 使用技巧"></a>NumPy 使用技巧</h3><p>转置对秩为 1 的数组无效。因此，应该避免使用秩为 1 的数组，用 n * 1 的矩阵代替。例如，用<code>np.random.randn(5,1)</code> 代替 <code>np.random.randn(5)</code> 。</p>
<p>如果得到了一个秩为 1 的数组，可以使用 <code>reshape</code> 进行转换。</p>
<h2 id="浅层神经网络"><a href="#浅层神经网络" class="headerlink" title="浅层神经网络"></a>浅层神经网络</h2><h3 id="神经网络表示"><a href="#神经网络表示" class="headerlink" title="神经网络表示"></a>神经网络表示</h3><p>竖向堆叠起来的输入特征被称作神经网络的<strong>输入层（the input layer）</strong>。</p>
<p>神经网络的<strong>隐藏层（a hidden layer）</strong>。“隐藏”的含义是<strong>在训练集中</strong>，这些中间节点的真正数值是无法看到的。</p>
<p><strong>输出层（the output layer）</strong>负责输出预测值。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201114113032833.png" alt="image-20201114113032833" style="zoom: 67%;" />

<p>如图是一个<strong>双层神经网络</strong>，也称作<strong>单隐层神经网络（a single hidden layer neural network）</strong>。当我们计算网络的层数时，通常不考虑输入层，因此图中隐藏层是第一层，输出层是第二层，而输入层为第零层。</p>
<p>约定俗成的符号表示是：</p>
<ul>
<li>上标“[ ]”括号中的数字表示<u>神经网络中的第几层</u>，a代表着<strong>激活（Activation）</strong>，指的是不同层次的神经网络传递给后续层次的值。</li>
<li>输入层的激活值为 $a[0]$ ；</li>
<li>同样，隐藏层也会产生一些激活值，记作 $a^{[1]}$ 隐藏层的第一个单元（或者说节点）就记作 $a_1^{[1]}$ ,输出层同理。</li>
<li>另外，隐藏层和输出层都是带有参数 W 和 b 的。它们都使用上标 [1] 来表示是和第一个隐藏层有关，或者上标 [2] 来表示是和输出层有关。</li>
</ul>
<h3 id="计算神经网络的输出"><a href="#计算神经网络的输出" class="headerlink" title="计算神经网络的输出"></a>计算神经网络的输出</h3><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201115084405346.png" alt="image-20201115084405346" style="zoom:50%;" />

<p>实际上，神经网络只不过将 Logistic 回归的计算步骤重复很多次。对于隐藏层的第一个节点，<br>$$<br>z _1^{[1]} = (W _1^{[1]})^TX+b _1^{[1]}<br>$$</p>
<p>$$<br>a _1^{[1]} = \sigma(z _1^{[1]})<br>$$</p>
<p>我们可以类推得到，对于第一个隐藏层有下列公式：<br>$$<br>z^{[1]} = (W^{[1]})^Ta^{[0]}+b^{[1]}<br>$$</p>
<p>$$<br>a^{[1]} = \sigma(z^{[1]})<br>$$</p>
<p>其中，$a[0]$ 可以是一个列向量，也可以将多个列向量堆叠起来得到矩阵。如果是后者的话，得到的 $z[1]$ 和 $a[1]$ 也是一个矩阵。</p>
<p>同理，对于输出层有：<br>$$<br>z^{[2]} = (W^{[2]})^Ta^{[1]}+b^{[2]}<br>$$</p>
<p>$$<br>\hat{y} = a^{[2]} = \sigma(z^{[2]})<br>$$</p>
<p>值得注意的是<strong>层与层之间参数矩阵的规格大小</strong>。</p>
<ul>
<li>输入层和隐藏层之间：$(W^{[1]})^T$ 的 shape 为 <code>(4,3)</code> ，前面的 4 是隐藏层神经元的个数，后面的 3 是输入层神经元的个数；$b^{[1]}$ 的 shape 为 <code>(4,1)</code> ，和隐藏层的神经元个数相同。</li>
<li>隐藏层和输出层之间：$(W^{[2]})^T$ 的 shape 为 <code>(1,4)</code> ，前面的 1 是输出层神经元的个数，后面的 4 是隐藏层神经元的个数；$b^{[2]}$ 的 shape 为 <code>(1,1)</code> ，和输出层的神经元个数相同。</li>
</ul>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>有一个问题是神经网络的隐藏层和输出单元用什么激活函数。之前我们都是选用 sigmoid 函数，但有时其他函数的效果会好得多。</p>
<p>可供选用的激活函数有：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115102234900.png" alt="image-20201115102234900"></p>
<h4 id="tanh-函数（the-hyperbolic-tangent-function，双曲正切函数）"><a href="#tanh-函数（the-hyperbolic-tangent-function，双曲正切函数）" class="headerlink" title="tanh 函数（the hyperbolic tangent function，双曲正切函数）"></a>tanh 函数（the hyperbolic tangent function，双曲正切函数）</h4><p>$$<br>a = \frac{e^z - e^{-z}}{e^z + e^{-z}}<br>$$</p>
<p>效果几乎总比 sigmoid 函数好（除开<strong>二元分类的输出层</strong>，因为我们希望输出的结果介于 0 到 1 之间），因为函数输出介于 -1 和 1 之间，激活函数的平均值就更接近 0，有类似数据中心化的效果。</p>
<p>然而，tanh 函数存在和 sigmoid 函数一样的缺点：当 z 趋紧无穷大（或无穷小），导数的梯度（即函数的斜率）就趋紧于 0，这使得梯度算法的速度大大减缓。</p>
<h4 id="ReLU-函数（the-rectified-linear-unit，修正线性单元）"><a href="#ReLU-函数（the-rectified-linear-unit，修正线性单元）" class="headerlink" title="ReLU 函数（the rectified linear unit，修正线性单元）"></a>ReLU 函数（the rectified linear unit，修正线性单元）</h4><p>$$<br>a=max(0,z)<br>$$</p>
<p>当 z &gt; 0 时，梯度始终为 1，从而提高神经网络基于梯度算法的运算速度，收敛速度远大于 sigmoid 和 tanh。然而当 z &lt; 0 时，梯度一直为 0，但是实际的运用中，该缺陷的影响不是很大。</p>
<h4 id="Leaky-ReLU（带泄漏的-ReLU）："><a href="#Leaky-ReLU（带泄漏的-ReLU）：" class="headerlink" title="Leaky ReLU（带泄漏的 ReLU）："></a>Leaky ReLU（带泄漏的 ReLU）：</h4><p>$$<br>a=max(0.01z,z)<br>$$</p>
<p>当 z &gt; 0 时，梯度始终为 1，从而提高神经网络基于梯度算法的运算速度，收敛速度远大于 sigmoid 和 tanh。然而当 z &lt; 0 时，梯度一直为 0，但是实际的运用中，该缺陷的影响不是很大。</p>
<blockquote>
<p>经验：在选择激活函数的时候，如果是二分类问题，输出层选 sigmoid 函数，其他层都选 ReLU 函数。如果在不知道该选什么的时候就选择 ReLU，当然也没有固定答案，要依据实际问题在交叉验证集合中进行验证分析。当然，我们可以在不同层选用不同的激活函数。</p>
</blockquote>
<h4 id="使用-ReLU-激活函数的优点？-为什么ReLU要好过sigmoid和tanh？"><a href="#使用-ReLU-激活函数的优点？-为什么ReLU要好过sigmoid和tanh？" class="headerlink" title="使用 ReLU 激活函数的优点？/ 为什么ReLU要好过sigmoid和tanh？"></a>使用 ReLU 激活函数的优点？/ 为什么ReLU要好过sigmoid和tanh？</h4><ol>
<li>采用 sigmoid 等函数，算激活函数时（指数运算），计算量大，反向传播求误差梯度时，求导涉及除法和指数运算，计算量相对大，而采用 ReLU 激活函数，整个过程的计算量节省很多。</li>
<li>对于深层网络，sigmoid 函数反向传播时，很容易就会出现梯度消失的情况（在 sigmoid 接近饱和区时，变换太缓慢，导数趋于0，这种情况会造成信息丢失），这种现象称为饱和，从而无法完成深层网络的训练，为什么会无法完成训练呢，因为神经网络更新w的时候就是依靠导数来更新的，如果导数接近0，那 w 更新之后还是原来的 w了。而 ReLU 就不会有饱和倾向，不会有特别小的梯度出现。</li>
</ol>
<blockquote>
<p>需注意， ReLU 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性。主要问题有两个：</p>
<ol>
<li>0点附近不可微。所以通常在0点只求右导数</li>
<li>它会“谋杀”一些神经元。就是说在 BP 的过程中很快会让一些神经元的导数永远是0，于是这些神经元等于被抛弃了，也就是被谋杀了。这提高了速度和精度，但是也有些武断，于是为了解决这个问题，引入了Leaky ReLU。Leaky ReLu 不会产生这个问题。</li>
</ol>
</blockquote>
<h3 id="使用非线性激活函数的原因"><a href="#使用非线性激活函数的原因" class="headerlink" title="使用非线性激活函数的原因"></a>使用非线性激活函数的原因</h3><ol>
<li><p>使用线性激活函数和不使用激活函数、直接使用 Logistic 回归没有区别，那么无论神经网络有多少层，输出都是输入的线性组合，与<strong>没有隐藏层</strong>效果相当，就成了最原始的感知器了。</p>
</li>
<li><p>使用非线性激活函数 ，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。使用非线性激活函数，能够从输入输出之间生成非线性映射。</p>
</li>
</ol>
<h3 id="激活函数的导数"><a href="#激活函数的导数" class="headerlink" title="激活函数的导数"></a>激活函数的导数</h3><ul>
<li>sigmoid 函数：</li>
</ul>
<p>$$<br>g(z) = \frac{1}{1+e^{-z}}<br>$$</p>
<p>$$<br>g\prime(z)=\frac{dg(z)}{dz} = \frac{1}{1+e^{-z}}(1-\frac{1}{1+e^{-z}})=g(z)(1-g(z))<br>$$</p>
<ul>
<li>tanh 函数：</li>
</ul>
<p>$$<br>g(z) = tanh(z) = \frac{e^z - e^{-z}}{e^z + e^{-z}}<br>$$</p>
<p>$$<br>g\prime(z)=\frac{dg(z)}{dz} = 1-(tanh(z))^2=1-(g(z))^2<br>$$</p>
<ul>
<li>ReLU 函数：</li>
</ul>
<p>$$<br>g(z)=max(0,z)<br>$$</p>
<p>$$<br>\frac{d}{d z} g(z)=\left{\begin{array}{ll}<br>0 &amp; \text { if } z&lt;0 \<br>1 &amp; \text { if } z&gt;0 \<br>\text { undefined } &amp; \text { if } z=0<br>\end{array}\right.<br>$$</p>
<h2 id="神经网络的梯度下降法"><a href="#神经网络的梯度下降法" class="headerlink" title="神经网络的梯度下降法"></a>神经网络的梯度下降法</h2><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115110144415.png" alt="image-20201115110144415"></p>
<p>$$<br>z^{[1]}={(w^{[1]})}^Tx+b^{[1]}<br>$$</p>
<p>$$<br>a^{[1]}=g^{[1]}(z^{[1]})<br>$$</p>
<p>$$<br>z^{[2]}={(w^{[2]})}^Ta^{[1]}+b^{[2]},(x=a^{[1]})<br>$$</p>
<p>$$<br>a^{[2]}=g^{[2]}(z^{[2]})=\sigma(z^{[2]})<br>$$</p>
<p>$$<br>\mathcal{L}\left(a^{[2]}, y\right)=-\left(y \log a^{[2]}+(1-y) \log \left(1-a^{[2]}\right)\right)<br>$$</p>
<p>在训练过程中，经过前向传播后得到的最终结果跟训练样本的真实值总是存在一定误差，这个误差便是损失函数。想要减小这个误差，当前应用最广的一个算法便是梯度下降，于是用损失函数，从后往前，依次求各个参数的偏导，这就是所谓的<strong>反向传播（Back Propagation）</strong>，一般简称这种算法为BP算法。</p>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115112715694.png" alt="image-20201115112715694"></p>
<p>已知 sigmoid 函数的导数为：<br>$$<br>a^{[2]^{\prime}}=\operatorname{sigmoid}\left(z^{[2]}\right)^{\prime}=\frac{\partial a^{[2]}}{\partial z^{[2]}}=a^{[2]}\left(1-a^{[2]}\right)<br>$$</p>
<p>由复合函数求导中的链式法则，反向传播过程中：<br>$$<br>d a^{[2]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} =-\frac{y}{a^{[2]}} + \frac{1-y}{1-a^{[2]}},(对交叉熵损失函数求导)<br>$$</p>
<p>$$<br>d z^{[2]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial \alpha^{[2]}}{\partial z^{[2]}}=a^{[2]}-y<br>$$</p>
<p>$$<br>d w^{[2]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial w^{[2]}}=d z^{[2]}=a^{[2]}-y<br>$$</p>
<p>$$<br>d b^{[2]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial b^{[2]}}=d z^{[2]}=a^{[2]}-y<br>$$</p>
<p>$$<br>d a^{[1]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}}=d z^{[2]} \cdot w^{[2]}<br>$$</p>
<p>$$<br>d z^{[1]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{(2]}} \cdot \frac{\partial \alpha^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}} \cdot \frac{\partial a^{[1]}}{\partial z^{[1]}}=d z^{[2]} \cdot w^{[2]} \times g^{[1]^{\prime}}\left(z^{[1]}\right)<br>$$</p>
<p>$$<br>d w^{[1]}=\frac{\partial \mathcal{L}\left(\alpha^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{(2]}} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}} \cdot \frac{\partial a^{[1]}}{\partial z^{[1]}} \cdot \frac{\partial z^{[1]}}{\partial w^{[1]}}=d z^{[1]} \cdot{X^{T}}<br>$$</p>
<p>$$<br>d b^{[1]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}} \cdot \frac{\partial a^{[1]}}{\partial z^{[1]}} \cdot \frac{\partial z^{[1]}}{\partial b^{[1]}}=d z^{[1]}<br>$$</p>
<p>这便是反向传播的整个推导过程，在具体的算法实现过程中，使用梯度下降的方法，将各个参数进行向量化、取平均值，不断进行更新。</p>
<h3 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h3><p>如果在初始时将两个隐藏神经元的参数设置为相同的大小，那么两个隐藏神经元对输出单元的影响也是相同的，通过反向梯度下降去进行计算的时候，会得到同样的梯度大小，所以在经过多次迭代后，两个隐藏层单位仍然是对称的。无论设置多少个隐藏单元，其最终的影响都是相同的，那么多个隐藏神经元就没有了意义。</p>
<p>在初始化的时候，<strong>W 参数要进行随机初始化，不可以设置为 0</strong>。而 b 因为不存在对称性的问题，可以设置为 0。</p>
<p>以 2 个输入，2 个隐藏神经元为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W = np.random.rand(<span class="number">2</span>,<span class="number">2</span>)* <span class="number">0.01</span></span><br><span class="line">b = np.zeros((<span class="number">2</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>这里将 W 的值乘以 0.01（或者其他的常数值）的原因是为了使得权重 W 初始化为较小的值，<u>这是因为使用 sigmoid 函数或者 tanh 函数作为激活函数时，W 比较小，则 Z=WX+b 所得的值趋近于 0，梯度较大，能够提高算法的更新速度。</u>而如果 W 设置的太大的话，得到的梯度较小，训练过程因此会变得很慢。</p>
<p>ReLU 和 Leaky ReLU 作为激活函数时不存在这种问题，因为在大于 0 的时候，梯度均为 1。</p>
<h2 id="深层神经网络"><a href="#深层神经网络" class="headerlink" title="深层神经网络"></a>深层神经网络</h2><h3 id="深层网络中的前向和反向传播"><a href="#深层网络中的前向和反向传播" class="headerlink" title="深层网络中的前向和反向传播"></a>深层网络中的前向和反向传播</h3><h4 id="前向传播-1"><a href="#前向传播-1" class="headerlink" title="前向传播"></a>前向传播</h4><p>推导整个前向传播的过程可得：</p>
<p><strong>输入：</strong> $a^{[l-1]}$</p>
<p><strong>输出：</strong> $a^{[l]}$， $cache(z^{[l]})$</p>
<p><strong>公式：</strong><br>$$<br>Z^{[l]}=W^{[l]}\cdot a^{[l-1]}+b^{[l]}<br>$$</p>
<p>$$<br>a^{[l]}=g^{[l]}(Z^{[l]})<br>$$</p>
<h4 id="反向传播-1"><a href="#反向传播-1" class="headerlink" title="反向传播"></a>反向传播</h4><p><strong>输入</strong>：$da^{[l]}$</p>
<p><strong>输出</strong>：$da^{[l−1]}$，$dW[l]$，$db^{[l]}$</p>
<p><strong>公式：</strong><br>$$<br>dZ^{[l]}=da^{[l]}*g^{[l]}{‘}(Z^{[l]})<br>$$</p>
<p>$$<br>dW^{[l]}=dZ^{[l]}\cdot a^{[l-1]}<br>$$</p>
<p>$$<br>db^{[l]}=dZ^{[l]}<br>$$</p>
<p>$$<br>da^{[l-1]}=W^{[l]T}\cdot dZ^{[l]}<br>$$</p>
<ul>
<li>总结：</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/A3AB54BACCBBD3A9346DCD5378E9A876.png" alt="A3AB54BACCBBD3A9346DCD5378E9A876"></p>
<h3 id="搭建深层神经网络块"><a href="#搭建深层神经网络块" class="headerlink" title="搭建深层神经网络块"></a>搭建深层神经网络块</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115205800365.png" alt="image-20201115205800365"></p>
<p>神经网络的一步训练（一个梯度下降循环），包含了从 $a[0]$（即 x）经过一系列正向传播计算得到 $\hat y$（即 $a[l]$）。然后再计算 $da[l]$，开始实现反向传播，用<strong>链式法则</strong>得到所有的导数项，W 和 b 也会在每一层被更新。</p>
<p>在代码实现时，可以将正向传播过程中计算出来的 z 值缓存下来，待到反向传播计算时使用。</p>
<h3 id="矩阵的维度"><a href="#矩阵的维度" class="headerlink" title="矩阵的维度"></a>矩阵的维度</h3><p>$$<br>W^{[l]}: (n^{[l]}, n^{[l-1]})<br>$$</p>
<p>$$<br>b^{[l]}: (n^{[l]}, 1)<br>$$</p>
<p>$$<br>dW^{[l]}: (n^{[l]}, n^{[l-1]})<br>$$</p>
<p>$$<br>db^{[l]}: (n^{[l]}, 1)<br>$$</p>
<p>对于 Z、a，向量化之前有：<br>$$<br>Z^{[l]}, a^{[l]}: (n^{[l]}, 1)<br>$$<br>而在向量化之后，则有：<br>$$<br>Z^{[l]}, A^{[l]}: (n^{[l]}, m)<br>$$<br>在计算反向传播时，dZ、dA 的维度和 Z、A 是一样的。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115203736131.png" alt="image-20201115203736131"></p>
<h3 id="使用深层表示的原因"><a href="#使用深层表示的原因" class="headerlink" title="使用深层表示的原因"></a>使用深层表示的原因</h3><p>对于人脸识别，神经网络的第一层从原始图片中提取人脸的轮廓和边缘，每个神经元学习到不同边缘的信息；网络的第二层将第一层学得的边缘信息组合起来，形成人脸的一些局部的特征，例如眼睛、嘴巴等；后面的几层逐步将上一层的特征组合起来，形成人脸的模样。随着神经网络层数的增加，特征也从原来的边缘逐步扩展为人脸的整体，由整体到局部，由简单到复杂。层数越多，那么模型学习的效果也就越精确。</p>
<p>同样的，对于语音识别，第一层神经网络可以学习到语言发音的一些音调，后面更深层次的网络可以检测到基本的音素，再到单词信息，逐渐加深可以学到短语、句子。</p>
<p>通过例子可以看到，随着神经网络的深度加深，模型能学习到更加复杂的问题，功能也更加强大。</p>
<h3 id="参数和超参数"><a href="#参数和超参数" class="headerlink" title="参数和超参数"></a>参数和超参数</h3><p><strong>参数</strong>即是我们在过程中想要模型学习到的信息（<strong>模型自己能计算出来的</strong>），例如 W[l]W[l]，b[l]b[l]。而<strong>超参数（hyper parameters）</strong>即为控制参数的输出值的一些网络信息（<strong>需要人经验判断</strong>）。超参数的改变会导致最终得到的参数 $W^{[l]}$，$b^{[l]}$ 的改变。</p>
<p>典型的超参数有：</p>
<ul>
<li>学习速率：α</li>
<li>迭代次数：N</li>
<li>隐藏层的层数：L</li>
<li>每一层的神经元个数：$n^{[1]}$，$n^{[2]}$，…</li>
<li>激活函数 g(z) 的选择</li>
</ul>
<p>当开发新应用时，预先很难准确知道超参数的最优值应该是什么。因此，通常需要尝试很多不同的值。应用深度学习领域是一个很大程度基于经验的过程。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《深度学习》课程笔记3_搭建机器学习项目</title>
    <url>/2020/11/23/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h1 id="搭建机器学习项目"><a href="#搭建机器学习项目" class="headerlink" title="搭建机器学习项目"></a>搭建机器学习项目</h1><h2 id="机器学习（ML）策略（1）"><a href="#机器学习（ML）策略（1）" class="headerlink" title="机器学习（ML）策略（1）"></a>机器学习（ML）策略（1）</h2><p>对于一个已经被构建好且产生初步结果的机器学习系统，为了能使结果更令人满意，往往还要进行大量的改进。鉴于之前的课程介绍了多种改进的方法，例如收集更多数据、调试超参数、调整神经网络的大小或结构、采用不同的优化算法、进行正则化等等，我们有可能浪费大量时间在一条错误的改进路线上。</p>
<p>想要找准改进的方向，使一个机器学习系统更快更有效地工作，就需要学习一些在构建机器学习系统时常用到的策略。</p>
<h3 id="正交化"><a href="#正交化" class="headerlink" title="正交化"></a>正交化</h3><p><strong>正交化（Orthogonalization）</strong>的核心在于<strong>每次调整只会影响模型某一方面的性能，而对其他功能没有影响</strong>。这种方法有助于更快更有效地进行机器学习模型的调试和优化。</p>
<p>在机器学习（监督学习）系统中，可以划分四个“功能”：</p>
<ol>
<li>建立的模型在训练集上表现良好；</li>
<li>建立的模型在验证集上表现良好；</li>
<li>建立的模型在测试集上表现良好；</li>
<li>建立的模型在实际应用中表现良好。</li>
</ol>
<p>其中，</p>
<ul>
<li>对于第一条，如果模型在训练集上表现不好，可以尝试<strong>训练更大的神经网络</strong>或者<strong>换一种更好的优化算法（例如 Adam）</strong>；</li>
<li>对于第二条，如果模型在验证集上表现不好，可以进行<strong>正则化处理</strong>或者<strong>加入更多训练数据</strong>；</li>
<li>对于第三条，如果模型在测试集上表现不好，可以尝试<strong>使用更大的验证集</strong>进行验证；</li>
<li>对于第四条，如果模型在实际应用中表现不好，可能是因为<strong>测试集没有设置正确</strong>或者<strong>成本函数评估指标有误，需要改变测试集或成本函数</strong>。</li>
</ul>
<p>面对遇到的各种问题，正交化能够帮助我们更为精准有效地解决问题。</p>
<p>一个反例是早停止法（Early Stopping）。如果早期停止，虽然可以改善验证集的拟合表现，但是对训练集的拟合就不太好。因为对两个不同的“功能”都有影响，所以早停止法不具有正交化。虽然也可以使用，但是用其他正交化控制手段来进行优化会更简单有效。</p>
<h3 id="单值评价指标"><a href="#单值评价指标" class="headerlink" title="单值评价指标"></a>单值评价指标</h3><p>构建机器学习系统时，通过设置一个量化的<strong>单值评价指标</strong>（single-number evaluation metric），可以使我们根据这一指标比较不同超参数对应的模型的优劣，从而选择最优的那个模型。</p>
<p>例如，对于二分类问题，常用的评价指标是<strong>查准率</strong>（Precision）和<strong>查全率（Recall）</strong>。</p>
<p>首先：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201124093957384.png" alt="image-20201124093957384"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>True Positives（TP）</td>
<td>False Positives（FP）</td>
</tr>
<tr>
<td>True Negatives（TN）</td>
<td>False Negatives（FN）</td>
</tr>
</tbody></table>
<ul>
<li>TP的英文全称为True Positives，其指的是<strong>被分配为正样本，而且分配对了</strong>的样本，代表的是<strong>被正确分类的正样本</strong>。</li>
<li>TN的英文全称为True Negatives，其指的是<strong>被分配为负样本，而且分配对了</strong>的样本，代表的是<strong>被正确分类的负样本</strong>。</li>
<li>FP的英文全称为False Positives，其指的是<strong>被分配为正样本，但分配错了</strong>的样本，代表的是<strong>被错误分类的负样本</strong>。</li>
<li>FN的英文全称为False Negatives，其指的是<strong>被分配为负样本，但分配错了</strong>的样本，代表的是<strong>被错误分类的正样本</strong>。</li>
</ul>
<blockquote>
<p>True\False：看作是正确\错误分类</p>
<p>Positive\Negative：看作是正\负样本</p>
</blockquote>
<div class="note warning">
            <ul><li>$查准率=\frac{分类器认为是正类并且确实是正类的部分}{分类器认为是正类}=\frac{TP}{TP+FP}$</li><li>$查全率=\frac{分类器认为是正类并且确实是正类的部分}{确实是正类}=\frac{TP}{TP+FN}$</li></ul>
          </div>



<p>接下来，</p>
<p>假设我们有 A 和 B 两个分类器，其两项指标分别如下：</p>
<table>
<thead>
<tr>
<th>分类器</th>
<th>查准率（Precision）</th>
<th>查全率（Recall）</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>95%</td>
<td>90%</td>
</tr>
<tr>
<td>B</td>
<td>98%</td>
<td>85%</td>
</tr>
</tbody></table>
<p>实际应用中，我们通常使用综合了精确率和召回率的单值评价指标 <strong>F1 Score</strong> 来评价模型的好坏。F1 Score 其实就是精准率和召回率的<strong>调和平均数（Harmonic Mean）</strong>，比单纯的平均数效果要好。<br>$$<br>F_1 = \frac{2}{\frac{1}{P}+\frac{1}{R}} = \frac{2PR}{P+R}<br>$$<br>因此，我们计算出两个分类器的 F1 Score。可以看出 A 模型的效果要更好。</p>
<table>
<thead>
<tr>
<th>分类器</th>
<th>精确率</th>
<th>召回率</th>
<th>F1 Score</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>95%</td>
<td>90%</td>
<td>92.4%</td>
</tr>
<tr>
<td>B</td>
<td>98%</td>
<td>85%</td>
<td>91.0%</td>
</tr>
</tbody></table>
<p>通过引入单值评价指标，我们可以更方便快速地对不同模型进行比较。</p>
<p>举栗：假如某个班级有男生<strong>80</strong>人，女生<strong>20</strong>人，共计<strong>100</strong>人。目标是找出所有女生.<br>现在某人挑选出<strong>50</strong>个人,其中<strong>20</strong>人是女生,另外还错误的把<strong>30</strong>个男生也当作女生挑选出来了.<br>作为评估者的你需要来评估(<strong>evaluation</strong>)下他的工作。</p>
<p><strong>答：</strong>假设女生是正样本，则男生是负样本。题中表明目的是选出所有女生，即一共挑选的50人它都以为是女生（正样本），而剩下的50人就被认定成男生（负样本）。其中20个女生是分类正确的正样本，30个是分类错误的正样本。进而得到，剩下的50个男生本来就是男生，即分类正确的负样本为50，分类错误的负样本为0，如下图所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>正样本 Positive （女）</th>
<th>负样本 Negative （男）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>分类正确 True</td>
<td>（True Positive）  20</td>
<td>（True Negative）50</td>
<td>20</td>
</tr>
<tr>
<td>分类错误 False</td>
<td>（False Negative）30</td>
<td>（False Negative）0</td>
<td>80</td>
</tr>
<tr>
<td></td>
<td>50</td>
<td>50</td>
<td>100</td>
</tr>
</tbody></table>
<p>可以评估他的工作：</p>
<ul>
<li>查准率 $P=\frac{TP}{TP+FP}=40%$</li>
<li>查全率 $R=\frac{TP}{TP+FN}=100%$</li>
<li>$F_1=\frac{2PR}{P+R} = 57.1%$</li>
</ul>
<h3 id="优化指标和满足指标"><a href="#优化指标和满足指标" class="headerlink" title="优化指标和满足指标"></a>优化指标和满足指标</h3><p>如果我们还想要将分类器的运行时间也纳入考虑范围，将其和精确率、召回率组合成一个单值评价指标显然不那么合适。</p>
<p>这时，我们可以将某些指标作为<strong>优化指标（Optimizing Matric）</strong>，寻求它们的最优值；而将某些指标作为<strong>满足指标（Satisficing Matric）</strong>，只要在一定阈值以内即可。</p>
<p>比如，你要考虑 N 个指标，有时候选择其中一个指标作为优化指标是合理的。所以想尽可能地去优化那个指标，然后剩下 N-1 个指标都是满足指标，意味着只要他么达到一定阈值之后，就不必在乎过了那个门槛之后的表现，去看优化指标就行。但是首先他们必须要达到这个门槛。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201204154310114.png" alt="image-20201204154310114"></p>
<p>在这个例子中，准确率就是一个优化指标，因为我们想要分类器尽可能做到正确分类；而运行时间就是一个满足指标，如果你想要分类器的运行时间不多于某个阈值，那最终选择的分类器就应该是以这个阈值为界里面准确率最高的那个，即为 B 。</p>
<h3 id="动态改变评价指标"><a href="#动态改变评价指标" class="headerlink" title="动态改变评价指标"></a>动态改变评价指标</h3><p>对于模型的评价标准优势需要根据实际情况进行动态调整，以让模型在实际应用中获得更好的效果。</p>
<p>例如，有时我们不太能接受某些分类错误，于是改变单纯用错误率作为评价标准，给某些分类错误更高的权重，以从追求最小错误率转为追求最小风险。</p>
<h3 id="训练-验证-测试集划分"><a href="#训练-验证-测试集划分" class="headerlink" title="训练/验证/测试集划分"></a>训练/验证/测试集划分</h3><p>我们一般将数据集分为训练集、验证集、测试集。构建机器学习系统时，我们采用不同的学习方法，在<strong>训练集</strong>上训练出不同的模型，然后使用<strong>验证集</strong>对模型的好坏进行评估，确信其中某个模型足够好时再用<strong>测试集</strong>对其进行测试。</p>
<p>因此，训练集、验证集、测试集的设置对于机器学习模型非常重要，合理的设置能够大大提高模型训练效率和模型质量。</p>
<h4 id="验证集和测试集的分布"><a href="#验证集和测试集的分布" class="headerlink" title="验证集和测试集的分布"></a>验证集和测试集的分布</h4><p>验证集和测试集的数据来源应该相同（来自同一分布）、和机器学习系统将要在实际应用中面对的数据一致，且必须从所有数据中随机抽取。这样，系统才能做到尽可能不偏离目标。</p>
<blockquote>
<p>即 “瞄准一个目标”</p>
</blockquote>
<h4 id="验证集和测试集的大小"><a href="#验证集和测试集的大小" class="headerlink" title="验证集和测试集的大小"></a>验证集和测试集的大小</h4><p>过去数据量较小（小于 1 万）时，通常将数据集按照以下比例进行划分：</p>
<ul>
<li>无验证集的情况：70% / 30%；</li>
<li>有验证集的情况：60% / 20% / 20%；</li>
</ul>
<p>这是为了保证验证集和测试集有足够的数据。现在的机器学习时代数据集规模普遍较大，例如 100 万数据量，这时将相应比例设为 98% / 1% / 1% 或 99% / 1% 就已经能保证验证集和测试集的规模足够。</p>
<p>测试集的大小应该设置得足够提高系统整体性能的可信度，验证集的大小也要设置得足够用于评估几个不同的模型。应该根据实际情况对数据集灵活地进行划分，而不是死板地遵循老旧的经验。</p>
<h3 id="比较人类表现水平"><a href="#比较人类表现水平" class="headerlink" title="比较人类表现水平"></a>比较人类表现水平</h3><p>很多机器学习模型的诞生是为了取代人类的工作，因此其表现也会跟人类表现水平作比较。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201204160303692.png" alt="image-20201204160303692"></p>
<p>上图展示了随着时间的推进，机器学习系统和人的表现水平的变化。一般的，当机器学习超过人的表现水平后，它的进步速度逐渐变得缓慢，最终性能无法超过某个理论上限，这个上限被称为<strong>贝叶斯最优误差（Bayes Optimal Error）</strong>。</p>
<p>贝叶斯最优误差一般认为是理论上可能达到的最优误差，换句话说，其就是理论最优函数，任何从 x 到精确度 y 映射的函数都不可能超过这个值。例如，对于语音识别，某些音频片段嘈杂到基本不可能知道说的是什么，所以完美的识别率不可能达到 100%。</p>
<p>因为人类对于一些自然感知问题的表现水平十分接近贝叶斯最优误差，所以当机器学习系统的表现超过人类后，就没有太多继续改善的空间了。</p>
<p>也因此，只要建立的机器学习模型的表现还没达到人类的表现水平时，就可以通过各种手段来提升它。例如采用人工标记过的数据进行训练，通过人工误差分析了解为什么人能够正确识别，或者是进行偏差、方差分析。</p>
<p>当模型的表现超过人类后，这些手段起的作用就微乎其微了。</p>
<h4 id="可避免偏差"><a href="#可避免偏差" class="headerlink" title="可避免偏差"></a>可避免偏差</h4><p>通过与贝叶斯最优误差，或者说，与人类表现水平的比较，可以表明一个机器学习模型表现的好坏程度，由此判断后续操作应该注重于减小偏差还是减小方差。</p>
<p>模型在<strong>训练集</strong>上的误差与人类表现水平<strong>（贝叶斯错误率）</strong>的<strong>差值</strong>被称作<strong>可避免偏差（Avoidable Bias）</strong>。可避免偏差低便意味着模型在训练集上的表现很好，而<strong>训练集与验证集之间错误率的差值</strong>越小，意味着模型在验证集与测试集上的表现和训练集同样好。</p>
<p>如果<strong>可避免偏差</strong>大于<strong>训练集与验证集之间错误率的差值</strong>，之后的工作就应该专注于减小偏差；反之，就应该专注于减小方差。</p>
<h4 id="理解人类表现水平"><a href="#理解人类表现水平" class="headerlink" title="理解人类表现水平"></a>理解人类表现水平</h4><p>我们一般用<strong>人类水平误差（Human-level Error）</strong>来代表贝叶斯最优误差（或者简称贝叶斯误差）。对于不同领域的例子，不同人群由于其经验水平不一，错误率也不同。一般来说，<strong>我们将表现最好的作为人类水平误差</strong>。但是实际应用中，不同人选择人类水平误差的基准是不同的，这会带来一定的影响。</p>
<p>例如，如果某模型在训练集上的错误率为 8%，验证集的错误率为 10%。如果选择的人类水平误差为 1%，那么应该专注减少偏差；而如果选择的人类水平误差为 7.5%，则应该专注减少方差。也就是说，根据人类水平误差的不同选择，我们可能因此选择不同的优化操作。</p>
<p>这种问题只会发生在模型表现很好，接近人类水平误差的时候才会出现。人类水平误差给了我们一种估计贝叶斯误差的方式，而不是像之前一样将训练的错误率直接对着 0% 的方向进行优化。</p>
<p>当机器学习模型的表现超过了人类水平误差时，很难再通过人的直觉去判断模型还能够往什么方向优化以提高性能。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>想让一个监督学习算法达到使用程度，应该做到以下两点：</p>
<ol>
<li>算法对训练集的拟合很好，可以看作可避免偏差很低；</li>
<li>推广到验证集和测试集效果也很好，即方差不是很大。</li>
</ol>
<p>根据正交化的思想，我们有一些措施可以独立地优化二者之一。</p>
<h2 id="机器学习（ML）策略（2）"><a href="#机器学习（ML）策略（2）" class="headerlink" title="机器学习（ML）策略（2）"></a>机器学习（ML）策略（2）</h2><h3 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h3><p>通过人工检查机器学习模型得出的结果中出现的一些错误，有助于深入了解下一步要进行的工作。这个过程被称作<strong>错误分析（Error Analysis）</strong>。</p>
<p>例如，你可能会发现一个猫图片识别器错误地将一些看上去像猫的狗误识别为猫。这时，立即盲目地去研究一个能够精确识别出狗的算法不一定是最好的选择，因为我们不知道这样做会对提高分类器的准确率有多大的帮助。</p>
<p>这时，我们可以从分类错误的样本中统计出狗的样本数量。根据狗样本所占的比重来判断这一问题的重要性。假如狗类样本所占比重仅为 5%，那么即使花费几个月的时间来提升模型对狗的识别率，改进后的模型错误率并没有显著改善；而如果错误样本中狗类所占比重为 50%，那么改进后的模型性能会有较大的提升。因此，花费更多的时间去研究能够精确识别出狗的算法是值得的。</p>
<p>这种人工检查看似简单而愚笨，但却是十分必要的，因为这项工作能够有效避免花费大量的时间与精力去做一些对提高模型性能收效甚微的工作，让我们专注于解决影响模型准确率的主要问题。</p>
<p>在对输出结果中分类错误的样本进行人工分析时，可以建立一个表格来记录每一个分类错误的具体信息，例如某些图像是模糊的，或者是把狗识别成了猫等，并统计属于不同错误类型的错误数量。这样，分类结果会更加清晰。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201204205644683.png" alt="image-20201204205644683"></p>
<p>总结一下，进行错误分析时，你应该观察错误标记的例子，看看假阳性(False Positive)和假阴性(False Negative)，统计属于不同错误类型的错误数量。在这个过程中，你可能会得到启发，归纳出新的错误类型。总之，通过统计不同错误标记类型占总数的百分比，有助于发现哪些问题亟待解决，或者提供构思新优化方向的灵感。</p>
<h3 id="修正错误标记"><a href="#修正错误标记" class="headerlink" title="修正错误标记"></a>修正错误标记</h3><p>我们用 mislabeled examples 来表示学习算法输出了错误的 Y 值。而在做误差分析时，有时会注意到数据集中有些样本被人为地错误标记（incorrectly labeled）了，这时该怎么做？</p>
<p>如果是在训练集中，由于机器学习算法对于随机误差的<strong>稳健性（Robust）</strong>（也称作“鲁棒性”），只要这些出错的样本数量较小，且分布近似随机，就不必花费时间一一修正。</p>
<p>而如果出现在验证集或者测试集，则可以在进行误差分析时，通过统计人为标记错误所占的百分比，来大致分析这种情况对模型的识别准确率的影响，并比较该比例的大小和其他错误类型的比例，以此判断是否值得去将错误的标记一一进行修正，还是可以忽略。</p>
<p>当你决定在验证集和测试集上手动检查标签并进行修正时，有一些额外的方针和原则需要考虑：</p>
<ul>
<li>在验证集和测试集上<strong>同时使用同样的修正手段</strong>，以保证验证集和测试集来自相同的分布；</li>
<li>同时检查判断正确和判断错误的例子（通常不用这么做）；</li>
<li>在修正验证集和测试集时，鉴于训练集的分布不必和验证/测试集完全相同，可以不去修正训练集。</li>
</ul>
<h3 id="快读搭建系统并迭代"><a href="#快读搭建系统并迭代" class="headerlink" title="快读搭建系统并迭代"></a>快读搭建系统并迭代</h3><p>对于每个可以改善模型的合理方向，如何选择一个方向集中精力处理成了问题。如果想搭建一个全新的机器学习系统，建议根据以下步骤快速搭建好第一个系统，然后开始迭代：</p>
<ol>
<li>设置好训练、验证、测试集及衡量指标，确定目标；</li>
<li>快速训练出一个初步的系统，用训练集来拟合参数，用验证集调参，用测试集评估；</li>
<li>通过偏差/方差分析以及错误分析等方法，决定下一步优先处理的方向。</li>
</ol>
<h3 id="在不同的分布上训练和测试"><a href="#在不同的分布上训练和测试" class="headerlink" title="在不同的分布上训练和测试"></a>在不同的分布上训练和测试</h3><p>有时，我们很难得到来自同一个分布的训练集和验证/测试集。还是以猫识别作为例子，我们的训练集可能由网络爬取得到，图片比较清晰，而且规模较大（例如 20 万）；而验证/测试集可能来自用户手机拍摄，图片比较模糊，且数量较少（例如 1 万），难以满足作为训练集时的规模需要。</p>
<p>虽然验证/测试集的质量不高，但是机器学习模型最终主要应用于识别这些用户上传的模糊图片。考虑到这一点，在划分数据集时，可以将 20 万张网络爬取的图片和 5000 张用户上传的图片作为训练集，而将剩下的 5000 张图片一半作验证集，一半作测试集。比起混合数据集所有样本再随机划分，这种分配方法虽然使训练集分布和验证/测试集的分布并不一样，但是能保证<strong>验证/测试集更接近实际应用场景</strong>，在长期能带来更好的系统性能。</p>
<h3 id="数据不匹配"><a href="#数据不匹配" class="headerlink" title="==数据不匹配=="></a>==数据不匹配==</h3><p>之前的学习中，我们通过比较人类水平误差、训练集错误率、验证集错误率的相对差值来判断进行偏差/方差分析。但在训练集和验证/测试集分布不一致的情况下，无法根据相对差值来进行偏差/方差分析。这是因为训练集错误率和验证集错误率的差值<u>可能来自于算法本身（归为方差）</u>，也<u>可能来自于样本分布不同，和模型关系不大</u>。</p>
<p>在可能存在训练集和验证/测试集分布不一致的情况下，为了解决这个问题，我们可以再定义一个<strong>训练-验证集（Training-dev Set）</strong>。训练-验证集和训练集的分布相同（或者是训练集分割出的子集），但是不参与训练过程。</p>
<p>现在，我们有了 <em>训练集</em> 错误率、 <em>训练-验证集</em> 错误率，以及 <em>验证集</em> 错误率。其中， <em>训练集</em> 错误率和 <em>训练-验证集</em> 错误率的差值反映了方差；而 <em>训练-验证集</em> 错误率和 <em>验证集</em> 错误率的差值反映了样本分布不一致的问题，从而说明<strong>模型擅长处理的数据和我们关心的数据来自不同的分布</strong>，我们称之为<strong>数据不匹配（Data Mismatch）</strong>问题。</p>
<p>人类水平误差、<em>训练集</em>错误率、<em>训练-验证集</em>错误率、<em>验证集</em>错误率、<em>测试集</em>错误率之间的差值所反映的问题如下图所示：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201205104721879.png" alt="image-20201205104721879"></p>
<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>这里有两条关于如何解决数据不匹配问题的建议：</p>
<ul>
<li>做错误分析，尝试了解训练集和验证/测试集的具体差异（主要是人工查看训练集和验证集的样本）；</li>
<li>尝试将训练数据调整得更像验证集，或者收集更多类似于验证/测试集的数据。</li>
</ul>
<p>如果你打算将训练数据调整得更像验证集，可以使用的一种技术是<strong>人工合成数据</strong>。我们以语音识别问题为例，实际应用场合（验证/测试集）是包含背景噪声的，而作为训练样本的音频很可能是清晰而没有背景噪声的。为了让训练集与验证/测试集分布一致，我们可以给训练集人工添加背景噪声，合成类似实际场景的声音。</p>
<p>人工合成数据能够使数据集匹配，从而提升模型的效果。但需要注意的是，不能给每段语音都增加同一段背景噪声，因为这样模型会对这段背景噪音出现过拟合现象，使得效果不佳。</p>
<h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p><strong>迁移学习（Transfer Learning）</strong>是通过将已训练好的神经网络模型的一部分网络结构应用到另一模型，将一个神经网络从某个任务中学到的知识和经验运用到另一个任务中，以显著提高学习任务的性能。</p>
<p>例如，我们将为猫识别器构建的神经网络迁移应用到放射科诊断中。因为猫识别器的神经网络已经学习到了有关图像的结构和性质等方面的知识，所以只要先删除神经网络中原有的输出层，加入新的输出层并随机初始化权重系数（$W^{[L]}$、$b^{[L]}$），随后用新的训练集进行训练，就完成了以上的迁移学习。</p>
<p>如果新的数据集很小，可能只需要重新训练输出层前的最后一层的权重，即 $W^{[L]}$、$b^{[L]}$，并保持其他参数不变；而如果有足够多的数据，可以只保留网络结构，重新训练神经网络中所有层的系数。这时初始权重由之前的模型训练得到，这个过程称为<strong>预训练（Pre-Training）</strong>，之后的权重更新过程称为<strong>微调（Fine-Tuning）</strong>。</p>
<p>你也可以不止加入一个新的输出层，而是多向神经网络加几个新层。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201204213709492.png" alt="image-20201204213709492"></p>
<p>在下述场合进行迁移学习是有意义的：</p>
<ol>
<li>两个任务有同样的输入（比如都是图像或者都是音频）；</li>
<li><strong>拥有更多数据的任务迁移到数据较少的任务</strong>；</li>
<li>某一任务的低层次特征（底层神经网络的某些功能）对另一个任务的学习有帮助。</li>
</ol>
<h3 id="多任务学习"><a href="#多任务学习" class="headerlink" title="多任务学习"></a>多任务学习</h3><p>迁移学习中的步骤是串行的；而<strong>多任务学习（Multi-Task Learning）</strong>使用单个神经网络模型，利用共享表示采用并行训练同时学习多个任务。多任务学习的基本假设是<strong>多个任务之间具有相关性</strong>，并且任务之间可以利用相关性相互促进。例如，属性分类中，抹口红和戴耳环有一定的相关性，单独训练的时候是无法利用这些信息，多任务学习则可以利用任务相关性联合提高多个属性分类的精度。</p>
<p>以汽车自动驾驶为例，需要实现的多任务是识别行人、车辆、交通标志和信号灯。如果在输入的图像中检测出车辆和交通标志，则输出的 y 为：<br>$$<br>y = \begin{bmatrix} 0 \ 1 \ 1 \ 0 \end{bmatrix}\quad<br>$$</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201205115842523.png" alt="image-20201205115842523"></p>
<p>多任务学习模型的成本函数为：<br>$$<br>\frac{1}{m} \sum^m_{i=1} \sum^c_{j=1} L(\hat y_j^{(i)}, y_j^{(i)})<br>$$<br>其中，j 代表任务下标，总有 c 个任务。对应的损失函数为：<br>$$<br>L(\hat y_j^{(i)}, y_j^{(i)}) = -y_j^{(i)} log \hat y_j^{(i)} - (1 -y_j^{(i)})log(1 - \hat y_j^{(i)})<br>$$<br>多任务学习是使用单个神经网络模型来实现多个任务。实际上，也可以分别构建多个神经网络来实现。多任务学习中可能存在训练样本 Y 某些标签空白的情况，这不会影响多任务学习模型的训练。</p>
<p>多任务学习和 Softmax 回归看上去有些类似，容易混淆。它们的区别是，Softmax 回归的输出向量 y 中只有一个元素为 1；而多任务学习的输出向量 y 中可以有多个元素为 1。</p>
<blockquote>
<p>例如一个图像多个标签。</p>
</blockquote>
<p>在下述场合进行多任务学习是有意义的：</p>
<ol>
<li>训练的一组任务可以共用低层次特征；</li>
<li><em>通常</em>，每个任务的数据量接近；</li>
<li>能够训练一个足够大的神经网络，以同时做好所有的工作。多任务学习会降低性能的唯一情况（即和为每个任务训练单个神经网络相比性能更低的情况）是神经网络还不够大。</li>
</ol>
<p>在多任务深度网络中，低层次信息的共享有助于减少计算量，同时共享表示层可以使得几个有共性的任务更好的结合相关性信息，任务特定层则可以单独建模任务特定的信息，实现共享信息和任务特定信息的统一。</p>
<p>在实践中，多任务学习的使用频率要远低于迁移学习。计算机视觉领域中的物体识别是一个多任务学习的例子hh。</p>
<h3 id="端到端学习"><a href="#端到端学习" class="headerlink" title="端到端学习"></a>端到端学习</h3><p>在传统的机器学习分块模型中，每一个模块处理一种输入，然后其输出作为下一个模块的输入，构成一条流水线。而<strong>端到端深度学习（End-to-end Deep Learning）</strong>只用一个单一的神经网络模型来实现所有的功能。它将所有模块混合在一起，只关心输入和输出。</p>
<p>如果数据量较少，传统机器学习分块模型所构成的流水线效果会很不错。但如果训练样本足够大，并且训练出的神经网络模型足够复杂，那么端到端深度学习模型的性能会比传统机器学习分块模型更好。</p>
<p>而如果数据集规模适中，还是可以使用流水线方法，但是可以混合端到端深度学习，通过神经网络绕过某些模块，直接输出某些特征。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201204213920952.png" alt="image-20201204213920952"></p>
<h4 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h4><p>应用端到端学习的优点：</p>
<ul>
<li>只要有足够多的数据，剩下的全部交给一个足够大的神经网络。比起传统的机器学习分块模型，可能更能捕获数据中的任何统计信息，而不需要用人类固有的认知（或者说，成见）来进行分析；</li>
<li>所需手工设计的组件更少，简化设计工作流程；</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要大量的数据；</li>
<li>排除了可能有用的人工设计组件；</li>
</ul>
<p>根据以上分析，决定一个问题是否应用端到端学习的<strong>关键点</strong>是：是否有足够的数据，支持能够直接学习从 x 映射到 y 并且足够复杂的函数？</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《深度学习》课程笔记4_卷积神经网络</title>
    <url>/2020/12/06/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络 CNN"></a>卷积神经网络 CNN</h2><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p><strong>计算机视觉（Computer Vision）</strong>的高速发展标志着新型应用产生的可能，例如自动驾驶、人脸识别、创造新的艺术风格。人们对于计算机视觉的研究也催生了很多机算机视觉与其他领域的交叉成果。一般的计算机视觉问题包括以下几类：</p>
<ul>
<li>图片分类（Image Classification）；</li>
<li>目标检测（Object detection）；</li>
<li>神经风格转换（Neural Style Transfer）。</li>
</ul>
<p>应用计算机视觉时要面临的一个挑战是数据的输入可能会非常大。例如一张 1000x1000x3 的图片，神经网络输入层的维度将高达三百万，使得网络权重 W 非常庞大。这样会造成两个后果：</p>
<ol>
<li>神经网络结构复杂，数据量相对较少，容易出现过拟合；</li>
<li>所需内存和计算量巨大。</li>
</ol>
<p>因此，一般的神经网络很难处理蕴含着大量数据的图像。解决这一问题的方法就是使用<strong>卷积神经网络（Convolutional Neural Network, CNN）</strong>。</p>
<h3 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h3><p>我们之前提到过，神经网络由浅层到深层，分别可以检测出图片的边缘特征、局部特征（例如眼睛、鼻子等），到最后面的一层就可以根据前面检测的特征来识别整体面部轮廓。这些工作都是依托卷积神经网络来实现的。</p>
<p><strong>卷积运算（Convolutional Operation）</strong>是卷积神经网络最基本的组成部分。我们以边缘检测为例，来解释卷积是怎样运算的。</p>
<h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p>图片最常做的边缘检测有两类：<strong>垂直边缘（Vertical Edges）检测</strong>和<strong>水平边缘（Horizontal Edges）检测</strong>。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201207101305453.png" alt="image-20201207101305453"></p>
<p>图片的边缘检测可以通过与相应滤波器进行卷积来实现。以垂直边缘检测为例，原始图片尺寸为 6x6，中间的矩阵被称作<strong>滤波器（filter）</strong>，尺寸为 3x3，卷积后得到的图片尺寸为 4x4，得到结果如下（数值表示灰度，以左上角和右下角的值为例）：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201207103132826.png" alt="image-20201207103132826"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201207103929622.png" alt="image-20201207103929622"></p>
<p>可以看到，卷积运算的求解过程是从左到右，由上到下，每次在原始图片矩阵中取与滤波器同等大小的一部分 ，每一部分中的值与滤波器中的值对应相乘后求和，将结果组成一个矩阵。</p>
<p>下图对应一个垂直边缘检测的例子：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201207105004129.png" alt="image-20201207105004129"></p>
<p>如果将最右边的矩阵当作图像，那么中间一段亮一些的区域对应最左边的图像中间的垂直边缘。</p>
<h4 id="更多边缘检测的例子"><a href="#更多边缘检测的例子" class="headerlink" title="更多边缘检测的例子"></a>更多边缘检测的例子</h4><p>如果将灰度图左右的颜色进行翻转，再与之前的滤波器进行卷积，得到的结果也有区别。实际应用中，这反映了由明变暗和由暗变明的两种渐变方式。可以对输出图片取绝对值操作，以得到同样的结果。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201207111642258.png" alt="image-20201207111642258"></p>
<p>垂直边缘检测和水平边缘检测的滤波器如下所示：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201207112003086.png" alt="image-20201207112003086"></p>
<p>其他常用的滤波器还有 Sobel 滤波器和 Scharr 滤波器。它们增加了中间行的权重，以提高结果的稳健性。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201207112353055.png" alt="image-20201207112353055"></p>
<p>滤波器中的值还可以设置为<strong>参数</strong>，通过模型训练来得到。这样，神经网络使用反向传播算法可以学习到一些低级特征，从而实现对图片所有边缘特征的检测，而不仅限于垂直边缘和水平边缘。</p>
<h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>假设输入图片的大小为 $n×n$，而滤波器的大小为 $f×f$，则卷积后的输出图片大小为 $(n−f+1)×(n−f+1)$ 。</p>
<p>这样就有两个问题：</p>
<ul>
<li>每次卷积运算后，输出图片的尺寸缩小；</li>
<li>原始图片的角落、边缘区像素点在输出中采用较少，输出图片丢失边缘位置的很多信息。</li>
</ul>
<p>为了解决这些问题，可以在进行卷积操作前，对原始图片在边界上进行<strong>填充（Padding）</strong>，以增加矩阵的大小。通常将 0 作为填充值。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201207133745044.png" alt="image-20201207133745044"></p>
<p>设每个方向扩展像素点数量为 $p$，则填充后原始图片的大小为 $(n+2p)×(n+2p)$，滤波器大小保持 $f×f$ 不变，则输出图片大小为 $(n+2p−f+1)×(n+2p−f+1)$。</p>
<p>因此，在进行卷积运算时，我们有两种选择：</p>
<ul>
<li><strong>Valid 卷积</strong>：不填充，直接卷积。结果大小为 $(n−f+1)×(n−f+1)$；</li>
<li><strong>Same 卷积</strong>：进行填充，并使得卷积后结果大小与输入一致，这样可以得到 $p=\frac{f−1}2$ 。</li>
</ul>
<p>在计算机视觉领域，$f$ 通常为奇数。原因包括 Same 卷积中 $p=\frac{f−1}2$ 能得到自然数结果，并且滤波器有一个便于表示其所在位置的中心点。</p>
<h3 id="卷积步长"><a href="#卷积步长" class="headerlink" title="卷积步长"></a>卷积步长</h3><p>卷积过程中，有时需要通过填充来避免信息损失，有时也需要通过设置<strong>步长（Stride）</strong>来压缩一部分信息。步长表示滤波器在原始图片的水平方向和垂直方向上每次移动的距离。</p>
<p>之前，步长被默认为 1。而如果我们设置步长为 2，则卷积过程如下图所示：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201210105436586.png" alt="image-20201210105436586"></p>
<p>设步长为 $s$，填充长度为 $p$，输入图片大小为 $n×n$，滤波器大小为 $f×f$，则卷积后图片的尺寸为：<br>$$<br>\biggl\lfloor \frac{n+2p-f}{s}+1   \biggr\rfloor \times \biggl\lfloor \frac{n+2p-f}{s}+1 \biggr\rfloor<br>$$<br>注意公式中有一个向下取整的符号，用于处理商不为整数的情况。向下取整反映着当取原始矩阵的图示蓝框完全包括在图像内部时，才对它进行运算。</p>
<p>目前为止我们学习的“卷积”实际上被称为<strong>互相关（cross-correlation）</strong>，而非数学意义上的卷积。真正的卷积操作在做元素乘积求和之前，要将滤波器沿水平和垂直轴翻转（相当于旋转 180 度）。因为这种翻转对一般为水平或垂直对称的滤波器影响不大，按照机器学习的惯例，我们通常不进行翻转操作，在简化代码的同时使神经网络能够正常工作。</p>
<h3 id="高维卷积"><a href="#高维卷积" class="headerlink" title="高维卷积"></a>高维卷积</h3><p>如果我们想要对三通道的 RGB 图片进行卷积运算，那么其对应的滤波器组也同样是三通道的。过程是将每个单通道（R，G，B）与对应的滤波器进行卷积运算求和，然后再将三个通道的和相加，将 27 个乘积的和作为输出图片的一个像素值。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212091752414.png" alt="image-20201212091752414"></p>
<p>不同通道的滤波器可以不相同。例如只检测 R 通道的垂直边缘，G 通道和 B 通道不进行边缘检测，则 G 通道和 B 通道的滤波器全部置零。当输入有特定的高、宽和通道数时，滤波器可以有不同的高和宽，但通道数必须和输入一致。</p>
<p>如果想同时检测垂直和水平边缘，或者更多的边缘检测，可以增加更多的滤波器组。例如设置第一个滤波器组实现垂直边缘检测，第二个滤波器组实现水平边缘检测。设输入图片的尺寸为 $n×n×n_c$（$n_c$ 为通道数），滤波器尺寸为 $f×f×n_c$，则卷积后的输出图片尺寸为 $(n−f+1)×(n−f+1)×n′_c$，$n′_c$ 为滤波器组的个数。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212092506485.png" alt="image-20201212092506485"></p>
<blockquote>
<p>举栗：下面的图示显示了包含两个 filter 的卷积层的计算。$7<em>7</em>3$ 输入，经过两个 $3<em>3</em>3$ filter 的卷积（步幅为 $2$），得到了 $3<em>3</em>2$ 的输出。图中的 Zero padding 是 $1$，也就是在输入元素的周围补了一圈 $0$。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212103233564.png" alt="image-20201212103233564"></p>
<p>这个就是两个filters，我以目前图中划线的小方块为例。</p>
<p>$x[0] = 1$ ，$x[1]=-1$，$x[2]=0$，$bias=1$，所以加和得$o[0]$ 得第一个位置是 $1$</p>
</blockquote>
<h3 id="单层卷积网络"><a href="#单层卷积网络" class="headerlink" title="单层卷积网络"></a>单层卷积网络</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212111708339.png" alt="image-20201212111708339"></p>
<p>与之前的卷积过程相比较，卷积神经网络的单层结构多了激活函数和偏移量；而与标准神经网络：<br>$$<br>Z^{[l]} = W^{[l]}A^{[l-1]}+b<br>$$</p>
<p>$$<br>A^{[l]} = g^{[l]}(Z^{[l]})<br>$$</p>
<p>相比，滤波器的数值对应着权重 $W^{[l]}$，卷积运算对应着 $W^{[l]}$ 与 $A^{[l−1]}$ 的乘积运算，所选的激活函数变为 ReLU。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212110720587.png" alt="image-20201212110720587"></p>
<p>对于一个 3x3x3 的滤波器，包括偏移量 $b$ 在内共有 28 个参数。不论输入的图片有多大，用这一个滤波器来提取特征时，参数始终都是 28 个，固定不变。即<strong>选定滤波器组后，参数的数目与输入图片的尺寸无关</strong>。因此，卷积神经网络的参数相较于标准神经网络来说要少得多。这是 CNN 的优点之一。</p>
<h4 id="符号总结"><a href="#符号总结" class="headerlink" title="符号总结"></a>符号总结</h4><ul>
<li><p><strong>输入矩阵</strong>格式：四个维度，依次为：**[样本数、图像高度、图像宽度、图像通道数]**</p>
</li>
<li><p><strong>输出矩阵</strong>格式：四个维度，依次为：**[样本数、图像高度、图像宽度、图像通道数]**。与输出矩阵的维度顺序和含义相同，但是后三个维度（图像高度、图像宽度、图像通道数）的尺寸发生变化。</p>
</li>
<li><p><strong>权重矩阵</strong>（卷积核）格式：同样是四个维度，但维度的含义与上面两者都不同，为：**[卷积核高度、卷积核宽度、输入通道数、输出通道数]**（卷积核个数）</p>
</li>
<li><p><strong>输入矩阵、权重矩阵、输出矩阵这三者之间的相互决定关系</strong></p>
<ul>
<li><p>输入 x：[batch, height, width, in_channel]</p>
<p>权重 w：[height, width, in_channel, out_channel]</p>
<p>输出 y：[batch, height, width, out_channel]</p>
</li>
<li><p>卷积核的输入通道数（in depth）由输入矩阵的通道数所决定。（红色标注）</p>
</li>
<li><p>输出矩阵的通道数（out depth）由卷积核的输出通道数所决定。（绿色标注）</p>
</li>
<li><p>输出矩阵的高度和宽度（height, width）这两个维度的尺寸由输入矩阵、卷积核、扫描方式所共同决定。计算公式如下。（蓝色标注）</p>
</li>
</ul>
</li>
</ul>
<p>$$<br>n^{[l]}_H = \biggl\lfloor \frac{n^{[l-1]}_H+2p^{[l]}-f^{[l]}}{s^{[l]}}+1   \biggr\rfloor<br>$$</p>
<p>$$<br>n^{[l]}_W = \biggl\lfloor \frac{n^{[l-1]}_W+2p^{[l]}-f^{[l]}}{s^{[l]}}+1   \biggr\rfloor<br>$$</p>
<blockquote>
<p>以 AlexNet 模型的第一个卷积层为例，</p>
<ul>
<li>输入图片的尺寸统一为 227 x 227 x 3 （高度 x 宽度 x 颜色通道数），</li>
<li>本层一共具有96个卷积核，</li>
<li>每个卷积核的尺寸都是 11 x 11 x 3。</li>
<li>已知 stride = 4， padding = 0，</li>
<li>假设 batch_size = 256，</li>
<li>则输出矩阵的高度/宽度为 (227 - 11) / 4 + 1 = 55</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212160525312.png" alt="image-20201212160525312"></p>
</blockquote>
<blockquote>
<p>后期 GoogLeNet、ResNet 等经典模型中普遍使用一个像素大小的卷积核作为降低参数复杂度的手段。</p>
<p>从下面的运算可以看到，其实 1 x 1 卷积没有什么神秘的，其作用就是将输入矩阵的通道数量缩减后输出（512 降为 32），并保持它在宽度和高度维度上的尺寸（227 x 227）。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212160640410.png" alt="image-20201212160640410"></p>
</blockquote>
<p>总结下来，其实只需要认识到，虽然输入的每一张图像本身具有三个维度，但是对于卷积核来讲依然只是一个一维向量。卷积核做的，其实就是与感受野范围内的像素点进行点积（而不是矩阵乘法）。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Batch</th>
<th align="center">Height</th>
<th align="center">Width</th>
<th align="center">In Depth</th>
<th align="center">Out Depth</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入 x</td>
<td align="center">batch</td>
<td align="center">height</td>
<td align="center">width</td>
<td align="center">in_channel</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">权重 w</td>
<td align="center"></td>
<td align="center">height</td>
<td align="center">width</td>
<td align="center">in_channel</td>
<td align="center">out_channel</td>
</tr>
<tr>
<td align="center">输出 y</td>
<td align="center">batch</td>
<td align="center">height</td>
<td align="center">width</td>
<td align="center"></td>
<td align="center">out_channel</td>
</tr>
</tbody></table>
<h3 id="简单卷积网络实例"><a href="#简单卷积网络实例" class="headerlink" title="简单卷积网络实例"></a>简单卷积网络实例</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212163528828.png" alt="image-20201212163528828"></p>
<p>其中，$a^{[3]}$ 的维度为 7x7x40，将 1960 个特征平滑展开成 1960 个单元的一列，然后连接最后一级的输出层。输出层可以是一个神经元，即二元分类（logistic）；也可以是多个神经元，即多元分类（softmax）。最后得到预测输出 $\hat{y}$。</p>
<p>随着神经网络计算深度不断加深，图片的高度和宽度 $n^{[l]}_H$、$n^{[l]}_W$ 一般逐渐减小，而 $n^{[l]}_c$ 在增加。</p>
<p>一个典型的卷积神经网络通常包含有三种层：<strong>卷积层（Convolution layer）</strong>、<strong>池化层（Pooling layer）</strong>、<strong>全连接层（Fully Connected layer）</strong>。仅用卷积层也有可能构建出很好的神经网络，但大部分神经网络还是会添加池化层和全连接层，它们更容易设计。</p>
<h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p><strong>池化层</strong>的作用是缩减模型的大小，提高计算速度，同时减小噪声提高所提取特征的稳健性。</p>
<p>采用较多的一种池化过程叫做<strong>最大池化（Max Pooling）</strong>。将输入拆分成不同的区域，输出的每个元素都是对应区域中元素的最大值，如下图所示：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212223919692.png" alt="image-20201212223919692"></p>
<p>池化过程类似于卷积过程，上图所示的池化过程中相当于使用了一个大小 $f=2$ 的滤波器，且池化步长 $s=2$。卷积过程中的几个计算大小的公式也都适用于池化过程。如果有多个通道，那么就对每个通道分别执行计算过程。</p>
<p>对最大池化的一种直观解释是，元素值较大可能意味着池化过程之前的卷积过程提取到了某些特定的特征，池化过程中的最大化操作使得只要在一个区域内提取到某个特征，它都会保留在最大池化的输出中。但是，没有足够的证据证明这种直观解释的正确性，而最大池化被使用的主要原因是它在很多实验中的效果都很好。</p>
<p>另一种池化过程是<strong>平均池化（Average Pooling）</strong>，就是从取某个区域的最大值改为求这个区域的平均值：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212230108937.png" alt="image-20201212230108937"></p>
<p>池化过程的特点之一是，它有一组超参数，但是并<strong>没有参数需要学习</strong>。池化过程的超参数包括滤波器的大小 $f$、步长 $s$，以及选用最大池化还是平均池化。而填充 $p$ 则很少用到。</p>
<p>池化过程的输入维度为：<br>$$<br>n_H \times n_W \times n_c<br>$$<br>输出维度为：<br>$$<br>\biggl\lfloor \frac{n_H-f}{s}+1   \biggr\rfloor \times \biggl\lfloor \frac{n_W-f}{s}+1   \biggr\rfloor \times n_c<br>$$</p>
<h3 id="卷积神经网络实例"><a href="#卷积神经网络实例" class="headerlink" title="卷积神经网络实例"></a>卷积神经网络实例</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201212231101805.png" alt="image-20201212231101805"></p>
<p>在计算神经网络的层数时，通常只统计具有权重和参数的层，因此池化层通常和之前的卷积层共同计为一层。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Activation shape</th>
<th align="center">Activation Size</th>
<th align="center">#parameters</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Input</strong></td>
<td align="center">(32, 32, 3)</td>
<td align="center">3072</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>CONV1(f=5, s=1)</strong></td>
<td align="center">(28, 28, 6)</td>
<td align="center">4704</td>
<td align="center">158</td>
</tr>
<tr>
<td align="center"><strong>POOL1</strong></td>
<td align="center">(14, 14, 6)</td>
<td align="center">1176</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>CONV2(f=5, s=1)</strong></td>
<td align="center">(10, 10, 16)</td>
<td align="center">1600</td>
<td align="center">416</td>
</tr>
<tr>
<td align="center"><strong>FC3</strong></td>
<td align="center">(120, 1)</td>
<td align="center">120</td>
<td align="center">48120</td>
</tr>
<tr>
<td align="center"><strong>FC4</strong></td>
<td align="center">(84, 1)</td>
<td align="center">84</td>
<td align="center">10164</td>
</tr>
<tr>
<td align="center"><strong>Softmax</strong></td>
<td align="center">(10, 1)</td>
<td align="center">10</td>
<td align="center">850</td>
</tr>
</tbody></table>
<p>个人推荐<a href="http://scs.ryerson.ca/~aharley/vis/conv/">一个直观感受卷积神经网络的网站</a>。</p>
<h3 id="使用卷积的原因"><a href="#使用卷积的原因" class="headerlink" title="使用卷积的原因"></a>使用卷积的原因</h3><p>相比标准神经网络，对于大量的输入数据，卷积过程有效地减少了 CNN 的参数数量，原因有以下两点：</p>
<ul>
<li><strong>参数共享（Parameter sharing）</strong>：特征检测如果适用于图片的某个区域，那么它也可能适用于图片的其他区域。即在卷积过程中，不管输入有多大，一个特征探测器（滤波器）就能对整个输入的某一特征进行探测。</li>
<li><strong>稀疏连接（Sparsity of connections）</strong>：在每一层中，由于滤波器的尺寸限制，输入和输出之间的连接是稀疏的，每个输出值只取决于输入在局部的一小部分值。</li>
</ul>
<p>池化过程则在卷积后很好地聚合了特征，通过降维来减少运算量。</p>
<p>由于 CNN 参数数量较小，所需的训练样本就相对较少，因此在一定程度上不容易发生过拟合现象。并且 CNN 比较擅长捕捉区域位置偏移。即进行物体检测时，不太受物体在图片中位置的影响，增加检测的准确性和系统的健壮性。</p>
<h2 id="深度卷积网络：实例探究"><a href="#深度卷积网络：实例探究" class="headerlink" title="深度卷积网络：实例探究"></a>深度卷积网络：实例探究</h2><p>讲到的经典 CNN 模型包括：</p>
<ul>
<li>LeNet-5</li>
<li>AlexNet</li>
<li>VGG</li>
<li>ResNet（Residual Network，残差网络）</li>
<li>Inception Neural Network。</li>
</ul>
<p>详细介绍请看这篇 <a href="https://stuxiaozhang.github.io/2020/12/15/%E3%80%8A%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E3%80%8B/">《经典卷积神经网络》</a>。</p>
<h3 id="使用开源的实现方案"><a href="#使用开源的实现方案" class="headerlink" title="使用开源的实现方案"></a>使用开源的实现方案</h3><p>很多神经网络复杂细致，并充斥着参数调节的细节问题，因而很难仅通过阅读论文来重现他人的成果。想要搭建一个同样的神经网络，查看开源的实现方案会快很多。</p>
<h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>在“搭建机器学习项目”课程中，迁移学习已经被提到过。计算机视觉是一个经常用到迁移学习的领域。在搭建计算机视觉的应用时，相比于从头训练权重，下载别人已经训练好的网络结构的权重，用其做<strong>预训练</strong>，然后转换到自己感兴趣的任务上，有助于加速开发。</p>
<p>对于已训练好的卷积神经网络，可以将所有层都看作是<strong>冻结的</strong>，只需要训练与你的 Softmax 层有关的参数即可。大多数深度学习框架都允许用户指定是否训练特定层的权重。</p>
<p>而冻结的层由于不需要改变和训练，可以看作一个固定函数。可以将这个固定函数存入硬盘，以便后续使用，而不必每次再使用训练集进行训练了。</p>
<p>上述的做法适用于你只有一个较小的数据集。如果你有一个更大的数据集，应该冻结更少的层，然后训练后面的层。越多的数据意味着冻结越少的层，训练更多的层。如果有一个极大的数据集，你可以将开源的网络和它的权重整个当作初始化（代替随机初始化），然后训练整个网络。</p>
<h3 id="数据扩增"><a href="#数据扩增" class="headerlink" title="数据扩增"></a>数据扩增</h3><p>计算机视觉领域的应用都需要大量的数据。当数据不够时，<strong>数据扩增（Data Augmentation）</strong>就有帮助。常用的数据扩增包括镜像翻转、随机裁剪、色彩转换。</p>
<p>其中，色彩转换是对图片的 RGB 通道数值进行随意增加或者减少，改变图片色调。另外，<strong>PCA 颜色增强</strong>指更有针对性地对图片的 RGB 通道进行主成分分析（Principles Components Analysis，PCA），对主要的通道颜色进行增加或减少，可以采用高斯扰动做法来增加有效的样本数量。具体的 PCA 颜色增强做法可以查阅 AlexNet 的相关论文或者开源代码。</p>
<p>在构建大型神经网络的时候，数据扩增和模型训练可以由两个或多个不同的线程并行来实现。</p>
<h3 id="计算机视觉现状"><a href="#计算机视觉现状" class="headerlink" title="计算机视觉现状"></a>计算机视觉现状</h3><p>通常，学习算法有两种知识来源：</p>
<ul>
<li>被标记的数据</li>
<li>手工工程</li>
</ul>
<p><strong>手工工程（Hand-engineering，又称 hacks）</strong>指精心设计的特性、网络体系结构或是系统的其他组件。手工工程是一项非常重要也比较困难的工作。在数据量不多的情况下，手工工程是获得良好表现的最佳方式。正因为数据量不能满足需要，历史上计算机视觉领域更多地依赖于手工工程。近几年数据量急剧增加，因此手工工程量大幅减少。</p>
<p>另外，在模型研究或者竞赛方面，有一些方法能够有助于提升神经网络模型的性能：</p>
<ul>
<li>集成（Ensembling）：独立地训练几个神经网络，并平均输出它们的输出</li>
<li>Multi-crop at test time：将数据扩增应用到测试集，对结果进行平均</li>
</ul>
<p>但是由于这些方法计算和内存成本较大，一般不适用于构建实际的生产项目。</p>
<p>（当完成目标检测相关论文阅读后，再来继续学习）</p>
<h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><p>目标检测是计算机视觉领域中一个新兴的应用方向，其任务是对输入图像进行分类的同时，检测图像中是否包含某些目标，并对他们准确定位并标识。</p>
<h3 id="目标定位"><a href="#目标定位" class="headerlink" title="目标定位"></a>目标定位</h3><h2 id="特殊应用：人脸识别和神经风格迁移"><a href="#特殊应用：人脸识别和神经风格迁移" class="headerlink" title="特殊应用：人脸识别和神经风格迁移"></a>特殊应用：人脸识别和神经风格迁移</h2>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构课堂笔记总结</title>
    <url>/2020/09/28/%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[ <div class="note warning">
            <p>2020.09.28：总结了一些有关数据结构的常见面试问题以及一些书上和笔记上的知识点。</p>
          </div> 



<h1 id="数据结构常见面试问题"><a href="#数据结构常见面试问题" class="headerlink" title="数据结构常见面试问题"></a>数据结构常见面试问题</h1><h2 id="大O什么意思？"><a href="#大O什么意思？" class="headerlink" title="大O什么意思？"></a>大O什么意思？</h2><p>大O表示法：算法的时间复杂度通常用 <u>大O符号</u> 表述，定义为 $T[n] = O(f(n)) $。称函数 T(n)以f(n)为界或者称T(n)受限于f(n)。 如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。当输入量n逐渐加大时，时间复杂度的极限情形称为算法的“渐近时间复杂度”。</p>
<h2 id="简述数据结构的三要素"><a href="#简述数据结构的三要素" class="headerlink" title="简述数据结构的三要素"></a>简述数据结构的三要素</h2><ul>
<li>逻辑结构：从逻辑上描述数据，即数据之间的逻辑关系。（线性结构和非线性结构）</li>
<li>物理结构：数据在计算机内的存储方式（顺序存储，链式存储，索引存储，散列存储）</li>
<li>数据的运算：数据的运算包括数据的定义与实现，运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</li>
</ul>
<h2 id="循环比递归效率高吗？"><a href="#循环比递归效率高吗？" class="headerlink" title="循环比递归效率高吗？"></a>循环比递归效率高吗？</h2><p>并不能绝对的说循环比递归效率高。</p>
<p>递归的优点是：代码简洁清晰，容易检查代码的正确性。缺点是：当递归调用的次数很多时，对执行效率会有一定的影响。</p>
<p>循环的优点是：结构简单，速度快；缺点是：并不能解决所有问题，有些问题适合用递归来解决而不适合用循环。</p>
<h3 id="循环比递归效率高吗？-1"><a href="#循环比递归效率高吗？-1" class="headerlink" title="循环比递归效率高吗？"></a>循环比递归效率高吗？</h3><p>并不能绝对的说循环比递归效率高。</p>
<p>递归：</p>
<ul>
<li>优点：代码简洁清晰，容易检查代码的正确性。</li>
<li>缺点：当递归调用的次数很多时，对执行效率会有一定的影响。</li>
</ul>
<p>循环：</p>
<ul>
<li>优点：结构简单，速度快</li>
<li>缺点是：并不能解决所有问题，有些问题适合用递归来解决而不适合用循环。</li>
</ul>
<h2 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别"></a>栈和队列的区别</h2><p>队列和栈都是操作受限的线性表。</p>
<p>队列是只允许在一段插入，在另一端删除的线性表。进入队列的元素按先入先出的原则进行处理；</p>
<p>栈是指能在表尾进行插入和删操作的线性表。对于插入到栈的元素按先进后出的规则进行处理，插入和删除操作都在栈顶进行。</p>
<h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p>利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，将两个栈的栈底设在共享空间的两端，两个栈顶向共享空间的中间延伸，这样能够更有效的利用存储空间。</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>思想：如果已匹配相等的前缀序列中有某个后缀正好是子串的前缀，就可以将子串向后滑动到与这些后缀相匹配的位置。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kmp.jpg"></p>
<h2 id="名词解释：满二叉树，完全二叉树，二叉排序树，平衡二叉树。"><a href="#名词解释：满二叉树，完全二叉树，二叉排序树，平衡二叉树。" class="headerlink" title="名词解释：满二叉树，完全二叉树，二叉排序树，平衡二叉树。"></a>名词解释：满二叉树，完全二叉树，二叉排序树，平衡二叉树。</h2><ul>
<li>满二叉树：高度为H，结点数为 $2^{H}-1$ 的二叉树为满二叉树。</li>
<li>完全二叉树：除最后一层外，其余各层的节点数量达到最大值，并且最后一层只能在右侧缺少节点。</li>
<li>二叉排序树：左子树上所有的关键字均小于根结点，右子树上所有关键字均大于根结点。左子树和右子树又分别是一棵二叉排序树。</li>
<li>平衡二叉树：树中每一个结点的左子树，右子树高度之差的绝对值小于等于1</li>
</ul>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><ul>
<li><p>顺序存储：用一组连续的地址单元自上到下，自左到右的存储完全二叉树的结点元素。</p>
</li>
<li><p>链式存储：采用二叉链表来存储树的每个节点。二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针 指向该结点的两个孩子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">BTNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的dfs遍历，递归和非递归，一个是系统栈，一个是用户栈，为什么用户栈比系统栈效率高？</p>
<p>答：递归函数申请的系统栈是一个所有递归函数都要通用的栈，系统栈除了会 记录访问过的节点信息，还有其他信息比如函数参数和返回值等等，以实现函 数的递归调用。</p>
<p> 而用户自己定义的栈仅保存遍历所需的节点信息，是一个有针对性的设计，所 以相比之下更高效。</p>
<h3 id="1、先序遍历："><a href="#1、先序遍历：" class="headerlink" title="1、先序遍历："></a>1、先序遍历：</h3><ol>
<li>访问根结点；</li>
<li>先序遍历左子树；</li>
<li>先序遍历右子树。</li>
</ol>
<ul>
<li><p>递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BTBode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(p);</span><br><span class="line">        preorder(p-&gt;lchild);</span><br><span class="line">        preorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>非递归</p>
<ol>
<li><p>根节点入栈</p>
</li>
<li><p>循环栈：</p>
</li>
</ol>
<p>​      1）根节点出栈</p>
<p>​      2）右节点入栈</p>
<p>​      3）左节点入栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perorderNonrecursion</span> <span class="params">(BTNode *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != null)</span><br><span class="line">    &#123;</span><br><span class="line">        BTNode * Stack[N];  <span class="comment">// 定义一个栈</span></span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;  <span class="comment">// 初始化栈</span></span><br><span class="line">        BTNode *p;</span><br><span class="line">        Stack[++ top] = p;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = Stack[-- top];</span><br><span class="line">            visit(p);</span><br><span class="line">            <span class="keyword">if</span> (p -&gt; rchild != null ) Stack[++ top] = p -&gt; rchild;</span><br><span class="line">            <span class="keyword">if</span> (p -&gt; lchild != null ) Stack[++ top] = p -&gt; lchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="2、中序遍历："><a href="#2、中序遍历：" class="headerlink" title="2、中序遍历："></a>2、中序遍历：</h3><ol>
<li>中序遍历左子树；</li>
<li>访问根结点；</li>
<li>中序遍历右子树。</li>
</ol>
<ul>
<li><p>递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BTBode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        preorder(p-&gt;lchild);</span><br><span class="line">        visit(p);</span><br><span class="line">        preorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>非递归</p>
<ol>
<li><p>根节点入栈</p>
</li>
<li><p>循环栈：</p>
<p>1）看栈顶是否有左子，有的话，左子一直入栈</p>
<p>2）（没有左子）输出栈顶（就是“中”）</p>
<p>3）再看是否有右子，有则右子入栈，再循环2.1</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderNonrecursion</span> <span class="params">(BTNode *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != null)</span><br><span class="line">    &#123;</span><br><span class="line">        BTNode * Stack[N];  <span class="comment">// 定义一个栈</span></span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;  <span class="comment">// 初始化栈</span></span><br><span class="line">        BTNode *p;</span><br><span class="line">        p = bt;</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="comment">// 栈不空 或者 指针不空 （循环条件）</span></span><br><span class="line">        <span class="keyword">while</span>(top != <span class="number">-1</span> || p != null)</span><br><span class="line">        &#123;</span><br><span class="line">         	<span class="keyword">while</span>(p != null)  <span class="comment">// 左孩子存在，则左孩子入栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                Stack[++ top] = p;</span><br><span class="line">                p = p -&gt; lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="number">-1</span>)  <span class="comment">// 栈不空</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = Stack[top --];  <span class="comment">// 输出栈顶</span></span><br><span class="line">                visit(p);  <span class="comment">// 访问元素</span></span><br><span class="line">                p = p -&gt; rchild;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3、后序遍历"><a href="#3、后序遍历" class="headerlink" title="3、后序遍历"></a>3、后序遍历</h3><ol>
<li>后序遍历左子树；</li>
<li>后序遍历右子树；</li>
<li>访问根结点。</li>
</ol>
<ul>
<li><p>递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BTBode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        preorder(p-&gt;lchild);</span><br><span class="line">        preorder(p-&gt;rchild);</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>非递归</p>
<ol>
<li><p>根节点入栈</p>
</li>
<li><p>循环栈：</p>
<p>1）看栈顶是否有左子，有的话，左子一直入栈</p>
<p>2）（没有左子）看右子</p>
<p>​        右子入栈，再重复2.1</p>
<p>。。。有问题</p>
</li>
</ol>
</li>
</ul>
<h3 id="4、层序遍历"><a href="#4、层序遍历" class="headerlink" title="4、层序遍历"></a>4、层序遍历</h3><p>若树为空，则什么都不做直接返回。<br>否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
<p>建立一个队列</p>
<ol>
<li>根节点入队</li>
<li>出队，访问该节点：<ul>
<li>如果有左孩子，左孩子入队</li>
<li>如果有右孩子，右孩子入队</li>
</ul>
</li>
</ol>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><ul>
<li>二叉树的非递归遍历避免了系统栈的调用，提高了一定的效率。线索二叉树可以把用户栈也省掉，把二叉树的遍历过程线索化，进一步提高效率。</li>
</ul>
<ul>
<li><p>N个结点的二叉链表，N+1个空指针域。</p>
</li>
<li><p>将树中的空指针域作为寻找当前结点前驱或后继的线索。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">lchild</th>
<th align="center">ltag</th>
<th align="center">data</th>
<th align="center">rtag</th>
<th align="center">rchild</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>指针</strong>，指向左孩子</td>
<td align="center">0</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center"><strong>指针</strong>，指向右孩子</td>
</tr>
<tr>
<td align="center"><strong>线索</strong>，指向前驱结点</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"><strong>线索</strong>，指向后继结点</td>
</tr>
</tbody></table>
<h2 id="二叉树、树、森林的转换"><a href="#二叉树、树、森林的转换" class="headerlink" title="二叉树、树、森林的转换"></a>二叉树、树、森林的转换</h2><ol>
<li><p>树—》二叉树：</p>
<ul>
<li><p>同一节点的各孩子用线连接串起来</p>
</li>
<li><p>将每个结点的分支从左往右除了第一个，其余都剪掉</p>
</li>
</ul>
</li>
<li><p>二叉树—》树：</p>
<ul>
<li>找到一个孩子节点，然后沿着他一直往右下走</li>
<li>途径的所有的节点都与该孩子的父节点相连；然后断开孩子之间的连线</li>
</ul>
</li>
<li><p>森林—》二叉树：</p>
<ul>
<li>先将森林里的每一棵树转为二叉树（树的根节点一定是没有右兄弟的，因此转换为二叉树后，根节点一定没有右孩子）</li>
<li>再将第二棵二叉树转换为第一棵的右子树，以此类推</li>
</ul>
</li>
<li><p>二叉树—》森林：</p>
<ul>
<li>将根节点有右孩子的二叉树都断开</li>
<li>再进行二叉树—》树</li>
</ul>
</li>
</ol>
<ul>
<li><p>树/森林 的先序遍历 == 二叉树的先序遍历</p>
<p>树/森林 的后序遍历 == 二叉树的中序遍历</p>
</li>
</ul>
<h2 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h2><ul>
<li><p><strong>哈夫曼树：又叫最优二叉树。带权路径长度最短。</strong></p>
<p>构建哈夫曼树：</p>
<ol>
<li>将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。</li>
<li>构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li>
<li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</li>
<li>重复步骤2）和3），直至F中只剩下一棵树为止。</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>哈夫曼编码：通过哈夫曼树导出的每个字符的编码，进而得到对整个字符串的编码（压缩空间）</strong></p>
<p>哈夫曼编码是前缀码，因为根通往任意叶子节点的路径都不可能是通往其余叶子节点路径的子路径</p>
<blockquote>
<p>前缀码中：任意字符的编码串都不是另一字符编码串的前缀。</p>
<p>用前缀码，在解码时不会发生歧义</p>
</blockquote>
<ul>
<li>权值：字符出现在字符串里的次数（然后构建哈夫曼树）</li>
<li>对字符的编码：是路径</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>为什么要用哈夫曼树构建前缀码？</strong></p>
<p><strong>答：</strong>由哈夫曼树的特性可知，其树的带权路径长度是最短的。哈夫曼编码的过程中，每个字符的权值是在字符串中出现的次数，路径长度是每个字符编码的长度。字符出现的次数越多，编码长度越短。这样就使得其整个字符串在编码后的前缀码长度最短。</p>
<p>哈夫曼编码产生的是最短前缀码。</p>
</li>
</ul>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><ul>
<li><strong>邻接矩阵法（顺序存储）（稠密图）</strong>：用一个一维数组存储图的顶点信息，用二维数组存储各顶点的邻接关系。存储顶点邻接关系的二维数组称为邻接矩阵。</li>
<li><strong>邻接表法（链式存储）（稀疏图）</strong>：图中每个顶点与其有邻接关系的顶点拉成一个单链表，每个顶点都有一个单链表。<ul>
<li>十字链表法（有向图）：十字链表法是有向图的一种链式存储结构。在十字链表中，有向图中的每一条弧都有一个对应的节点，每个顶点都有对应的一个节点。</li>
<li>邻接多重表法（无向图）</li>
</ul>
</li>
</ul>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先搜索(DFS:Depth-First-Search)：深度优先搜索类似于树的先序遍历算法</p>
<ul>
<li><p>空间复杂度：<strong>由于DFS是一个递归算法，递归是需要一个工作栈</strong>来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|)</p>
</li>
<li><p>时间复杂度：</p>
<ol>
<li><p>邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)</p>
</li>
<li><p>邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2) </p>
</li>
</ol>
</li>
</ul>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先搜索(BFS:Breadth-First-Search)：广度优先搜索类似于树的层序遍历算法</p>
<ul>
<li>空间复杂度：<strong>BFS需要借助一个队列</strong>，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。    </li>
<li>时间复杂度：<ol>
<li>邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)</li>
<li>邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)</li>
</ol>
</li>
</ul>
<h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/tulun.jpg"></p>
<h3 id="一、最小生成树"><a href="#一、最小生成树" class="headerlink" title="一、最小生成树"></a>一、最小生成树</h3><h3 id="1、Prim算法"><a href="#1、Prim算法" class="headerlink" title="1、Prim算法"></a>1、Prim算法</h3><p>**与Dijkstra区别：Dijkstra算法是更新到起始点的距离；Prim是更新到集合S的距离 **</p>
<ul>
<li><strong>思路：$O(n ^2)$</strong><ol>
<li><strong>找集合之外距离最近的点</strong></li>
<li><strong>标记这个点(并加入集合)</strong></li>
<li><strong>用这个点 $t$ 更新其他点到集合的距离</strong></li>
</ol>
</li>
</ul>
<ul>
<li>双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为$O(n ^2)$<br>而且时间复杂度只和n有关，所以适合稠密图</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/prim.jpg"></p>
<h3 id="2、Kruskal算法"><a href="#2、Kruskal算法" class="headerlink" title="2、Kruskal算法"></a>2、Kruskal算法</h3><ul>
<li><strong>思路：$O(mlogm)$</strong><ol>
<li><strong>将图中边按照权值从小到大排列</strong></li>
<li><strong>然后从最小的边开始枚举。如果该边并入不构成回路的话，将该边并入集合中（当前生成树）。直到所有的边都检测完为止。</strong></li>
</ol>
</li>
<li>概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kruskal.jpg"></p>
<h3 id="二、最短路径"><a href="#二、最短路径" class="headerlink" title="二、最短路径"></a>二、最短路径</h3><h3 id="1、Dijkstra算法"><a href="#1、Dijkstra算法" class="headerlink" title="1、Dijkstra算法"></a>1、Dijkstra算法</h3><ul>
<li><strong>单源最短路：一个源点到其余顶点的最短路径</strong></li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%B4%E7%B4%A0dijstra.jpg"></p>
<h3 id="2、弗洛伊德"><a href="#2、弗洛伊德" class="headerlink" title="2、弗洛伊德"></a>2、弗洛伊德</h3><ul>
<li><strong>多源汇最短路：所有顶点到所有顶点的最短路径（询问从i-&gt;j的最短路）</strong><ul>
<li>算法思想：<br>递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)<br>其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径</li>
<li>非带权图</li>
</ul>
</li>
<li>两点之间经过边数最少的路径<ul>
<li>带权图</li>
</ul>
</li>
<li>两点之间经过的边上权值之和最小的路径</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul>
<li>拓扑排序常用来确定一个依赖关系集中，事物发生的顺序。例如，在日常工作中，可能会将项目拆分成A、B、C、D四个子部分来完成，但A依赖于B和D，C依赖于D。为了计算这个项目进行的顺序，可对这个关系集进行拓扑排序，得出一个线性的序列，则排在前面的任务就是需要先完成的任务。</li>
</ul>
<ul>
<li><p>AOV(Activity On Vertex)</p>
</li>
<li><p>如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)</p>
</li>
<li><p>拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：<br>如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；<br>如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。</p>
</li>
<li><p><strong>拓扑排序算法：</strong><br>从AOV网中<strong>选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧</strong>。重复这个步骤<u>直到输出图中全部顶点，或者找不到入度为0的顶点为止。</u></p>
</li>
<li><p><strong>拓扑排序流程(bfs)：</strong></p>
<ol>
<li><p><strong>遍历所有点找到入度为0的点，把它们入队</strong></p>
</li>
<li><p><strong>开始从入度为0的点 找：</strong></p>
<ol>
<li><p><strong>队头出队</strong></p>
</li>
<li><p><strong>遍历队头的临边</strong></p>
</li>
<li><p><strong>临边的入度 - 1</strong> </p>
</li>
<li><p><strong>判断此时入度是否为0：为0说明它可以做新的起点，入队</strong></p>
</li>
</ol>
</li>
<li><p><strong>return tt == n - 1 (队尾下标是n-1，说明所有点都已经入队)</strong>.</p>
</li>
</ol>
</li>
</ul>
<h2 id="AOV与AOE的区别？"><a href="#AOV与AOE的区别？" class="headerlink" title="AOV与AOE的区别？"></a>AOV与AOE的区别？</h2><p>相同点：AOV网和AOE网都是有向无环图，<u>区别在于它们的顶点和边所代表的含义是不同的</u>：</p>
<ul>
<li>AOV网的顶点：活动，边：仅代表活动之间的关系，无权值。</li>
<li>AOE网的顶点：事件，边：表示活动，边有权值，表示完成该活动所需要的时间。</li>
</ul>
<p><strong>关键路径</strong></p>
<ul>
<li>AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li>静态查找：若一个查找表的操作无需动态的修改表，称为静态查找。</li>
<li>动态查找：需要动态的插入和删除的查找表称为动态查找表。</li>
<li>平均查找长度：所有查找过程中进行关键字比较次数的平均值。</li>
</ul>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>从线性表的一端开始，逐个比较关键字的值是否满足查询条件。</p>
<ul>
<li>优点：对数据元素的存储没有要求，顺序存储或链式存储均可。</li>
<li>缺点：平均查找长度大，效率低。</li>
</ul>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>若顺序表有序，先将关键字与表中间元素比较，若相等则查找成功，否则在除中间元素以外的前半部分或后半部分进行同样的查找，如此重复直到查找成功或者确定表中没有要查找的元素，查找失败。</p>
<ul>
<li>优点：比顺序查找效率高</li>
<li>缺点：查找表必须有序且必须采用顺序存储结构。</li>
</ul>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>将查找表分为若干个子块，块内元素可以无序，各块之间必须有序，也就是说，第一个块内最大的关键字要小于第二个块内所有记录的关键字，第二个块内最大的关键字要小于第三个块内所有记录的关键字以此类推，再建立一张索引表，表项中存放每个块的最大关键字和第一个元素的地址。<br>查找步骤为：</p>
<ol>
<li>在索引表中确定待查记录所在的块，可以顺序查找也可以折半查找。</li>
<li>在块内顺序查找。</li>
</ol>
<p><u>吸取了顺序查找和折半查找各自的优点。</u></p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列函数：一个把查找表中关键字映射成为该关键字对应地址的函数。Hash(key)=Addr</p>
<p>散列表：根据关键字直接进行访问的散列表，建立了关键字与存储地址的直接映射关系。</p>
<ul>
<li>散列函数的构造方法：(开除平)</li>
</ul>
<ol>
<li><strong>开放定址法</strong>：直接取关键字的某个线性函数值为其存储地址。H(key)=a×key+b</li>
<li><strong>除留余数法</strong>：假定散列表表长为m，取一个不大于m且最接近m的质数p，通过关键字取余p来得到关键字的存储地址。</li>
<li><strong>平方取中法</strong>：取关键字平方的中间几位作为该关键字的存储地址。</li>
</ol>
<ul>
<li>解决冲突的办法：(线平双)</li>
</ul>
<ol>
<li><p><strong>开放地址法</strong>：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。</p>
<ol>
<li><p><u>线性探测法</u>：冲突发生时顺序查看表中下一个单元，直到找出一个空闲单元为止。（可能会造成大量元素在相邻的散列地址上堆积，降低查找效率）</p>
</li>
<li><p><u>平方探测法</u>：设发生冲突的地址为d,平方探测法得到的新的地址序列为$(d+1)^2$，$(d-1)^2$，$(d+2)^2$，$(d-2)^2$……</p>
<p>能够避免出现”堆积问题“，但是不能够探测到散列表中的所有单元。</p>
</li>
<li><p><u>双散列法</u>：使用两个散列函数，当第一个散列函数出现冲突时，就选用第二个散列函数。</p>
</li>
</ol>
</li>
<li><p><strong>拉链法</strong>：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非 同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表 由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。</p>
</li>
</ol>
<p>散列表的查找性能：和装填因子有关。α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突 的可能性越小</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li><p>内部排序：排序期间元素全部存放在内存中。（插入，交换，选择，归并，基数）</p>
</li>
<li><p>外部排序：排序期间元素无法同时存放在内存中，必须在排序期间根据要求不停地在内，外存移动。（多路归并）</p>
</li>
<li><p>排序的稳定性：如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p>
</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li><p><strong>直接插入排序</strong>：每次将一个待排序的记录按其关键字的大小插入到已排好序的子序列中。</p>
<ol>
<li><p>从前面的有序子表中查出待插入元素应该插入的位置</p>
</li>
<li><p>将已排序的记录逐步向后移动，给待插入元素腾出位置，并将待插入元素复制到插入位置。 </p>
<p>适用顺序存储/链式存储</p>
</li>
</ol>
</li>
<li><p><strong>折半插入排序</strong>：如果是顺序存储的线性表，可以通过折半查找的方式来查找待插入元素在有序子序列的位置。确定待插入位置之后，可以统一的向后移动位置。</p>
</li>
<li><p><strong>希尔排序</strong>：将待排序列按相隔某个增量分割成若干个子序列，对各个子序列进行直接插入排序，逐渐缩小增量，重复上述步骤，直到序列基本有序，再对全体记录进行一次直接插入排序。</p>
</li>
</ul>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><ul>
<li><p><strong>冒泡排序</strong>：从前到后（从后往前）依次两两比较相邻元素的值，若为逆序，就交换元素，每一趟排序完成之后，就有一个元素被放在最终位置上，重复上述步骤，当一趟排序不发生任何元素的交换为止。</p>
</li>
<li><p><strong>快速排序</strong>：快速排序是一种基于分治法的排序方法。 </p>
<p>每一趟快排选择序列中任一个元素作为枢轴(通常选第一个元素)，将序列中比枢 轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。最后确定枢轴元素的最终位置并将枢轴放入，再对枢轴前后得到的子序列再重复上述步骤，直到每部分只有一个元素或为空为止，则所有元素放在最终位置上。</p>
<ul>
<li><p>时间复杂度：<br>最好情况下时间复杂度为$O(nlogn)$，待排序序列越无序，算法效率越高。<br>最坏情况下时间复杂度为$O(n^2)$，待排序序列越有序，算法效率越低。</p>
</li>
<li><p>空间复杂度：<br>由于快速排序是递归的，需要借助一个<strong>递归工作栈</strong>来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。<br>最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)<br>最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；</p>
</li>
<li><p>稳定性：快速排序是不稳定的，是因为存在交换关键字。</p>
</li>
</ul>
</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li><p><strong>简单选择排序</strong>：每趟排序选择关键字最小的元素与序列前面的元素进行交换，每次排序均可确定一个元素的最终位置。</p>
</li>
<li><p><strong>堆排序</strong>：先将待排元素建成初始堆，以大根堆为例，堆顶元素为最大值，将其输出后，把堆底元素送入堆顶，此时堆不满足大根堆的性质，将堆顶元素向下调整（从堆的最后一个非叶子节点开始，从左到右，从下到上的顺序进行调整），成为大根堆之后再输出堆顶元素，重复上述过程，直到输出所有元素。</p>
<ul>
<li><p>什么是堆？</p>
<ul>
<li>堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。<ul>
<li>如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。</li>
<li>如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是堆排序？</p>
<ul>
<li><p>我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。</p>
</li>
<li><p>时间复杂度：<br>堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆</p>
<p>堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)</p>
</li>
<li><p>堆排序不稳定</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>“归并”：就是将两个或两个以上的有序表组成一个新的有序表。</p>
<p>归并排序是分治的思想。先将整个序列分为两半，对每一半分别进行排序，得 到两个有序序列，再将两个序列归并成一个序列即可。</p>
<blockquote>
<p> 假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1， 然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重 复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。</p>
</blockquote>
<p>稳定性：稳定</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BD%92%E5%B9%B6%E5%BF%AB%E6%8E%92.jpg"></p>
<p>可以发现，<strong>归并排序的处理过程是由下到上的</strong>，先处理子问题，然后再合并。而<strong>快排正好相反，它的处理过程是由上到下的</strong>，先分区，然后再处理子问题。<strong>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法</strong>。我们前面讲过，归并之所以是非原地排序算法，主要原因是<strong>合并函数无法在原地执行</strong>。<strong>快速排序通过设计</strong>巧妙的原地分区函数，<strong>可以实现原地排序。</strong></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul>
<li>基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。</li>
<li>创建0~9的十个数组，将待排序表的所有元素先按个位进行分类，将分类后的元素按索引大小取出形成新的队列，再对队列按十位，百位的顺序进行分类，重复上述过程，最后形成一个有序序列。</li>
<li>例子：53, 3, 542, 748, 14, 214, 154, 63, 616<ul>
<li>补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616</li>
<li>桶实际是一个队列，先进先出(从桶的上面进，下面出)</li>
<li>关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10</li>
</ul>
</li>
<li>空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)</li>
<li>时间复杂度：需要进行关键字位数d次”分配”和”收集”，一次”分配”需要将n个关键字放进各个队列中，一次”收集”需要将r个桶都收集一遍。所以一次”分配”和一次”收集”时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。</li>
<li>稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。</li>
</ul>
<h2 id="选取排序算法需要考虑的因素"><a href="#选取排序算法需要考虑的因素" class="headerlink" title="选取排序算法需要考虑的因素"></a>选取排序算法需要考虑的因素</h2><ol>
<li>待排元素的数目；</li>
<li>稳定性的要求；</li>
<li>元素本身信息量的大小；</li>
<li>关键字的结构及其分布情况；</li>
</ol>
<p>若n较小，可直接采用直接插入排序或者简单选择排序。由于直接插入排序比简单选择排序移动的元素要多，所以当元素本身信息量比较大时可选用简单选择排序。<br>若待排序表已基本有序可以选用直接插入排序或者冒泡排序。</p>
<p>当n比较大时，可以选用快速排序、堆排序、归并排序。快速排序被认为是当前基于比较的内部排序中最好的排序方法，当待排序表记录随机分布时，使用快速排序速度最快。堆排序所用存储空间少于快速排序，且不会出现快速排序的最坏情况，这两种算法都是不稳定的，若要稳定排序则选用归并排序算法。</p>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>采用多路归并法，包括两个相对独立的阶段：<br>（1）根据内部缓冲区的大小，将待排文件分成若干个大小合适的子文件，将子文件带入内存采用内部排序算法排序完成后再写回外存。<br>（2）对这些归并段进行逐趟归并，使归并段逐渐由小到大，直到得到整个有序文件为止。</p>
<h2 id="提高外部排序算法的效率"><a href="#提高外部排序算法的效率" class="headerlink" title="提高外部排序算法的效率"></a>提高外部排序算法的效率</h2><p>由于待排文件无法全部放入内存，所以排序期间必须要频繁的进行内外存之间数据的交换，这会耗费大量的时间。所以可以通过增加归并路数来减少归并趟数，进而减少I/O次数。而增加归并路数又会增加内部排序的时间，所以引入了败者树。<br>增加初始归并段个数，并且不受内存空间的限制，引入了置换-选择算法。<br>文件经过置换-选择算法之后得到的是长度不同的初始归并段，如何组织长度不等的出使归并段的归并顺序，使得I/O次数最少，就引入了最佳归并树。</p>
<h2 id="败者树（大的为失败者，小的为胜利者）"><a href="#败者树（大的为失败者，小的为胜利者）" class="headerlink" title="败者树（大的为失败者，小的为胜利者）"></a>败者树（大的为失败者，小的为胜利者）</h2><p>可视为一棵完全二叉树，每个叶结点存放各归并段在归并过程中参加比较的记录，非叶结点用来记录左右子树中的“失败者”，胜利者继续向上比较直到根节点。输出最后的胜利者。</p>
<h2 id="置换选择算法"><a href="#置换选择算法" class="headerlink" title="置换选择算法"></a>置换选择算法</h2><p>根据缓冲区的大小，由外存读入记录，当记录充满缓冲区时，选择最小的输出，其空缺位置由下一个记录来取代，输出记录称为当前初始归并段的一部分，如果新输出的记录比新建立归并段最大的记录小，就不能成为该归并段的一部分，只能成为下一个归并段的选择。重复上述步骤，直到缓冲区中所有记录都比当前归并段最大记录小时，就生成了一个初始归并段，用同样的方法继续生成下一个归并段，直到全部记录都处理完毕为止。</p>
<h2 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h2><p>对于K路归并算法，可用构造K叉哈夫曼树的方法来构造最佳归并树。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>《深度学习》课程笔记1_神经网络和深度学习</title>
    <url>/2020/11/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>此篇文章是吴恩达《深度学习》课程的笔记，主要源自于黄思腾大佬的博客</p>
</blockquote>
<h1 id="神经网络和深度学习"><a href="#神经网络和深度学习" class="headerlink" title="神经网络和深度学习"></a>神经网络和深度学习</h1><h2 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h2><ul>
<li>实现一个神经网络时，如果需要遍历整个训练集，并不需要直接使用 for 循环。</li>
<li>神经网络的计算过程中，通常有一个正向过程（forward pass）或者叫<strong>正向传播步骤（forward propagation step）</strong>，接着会有一个反向过程（backward pass）或者叫<strong>反向传播步骤（backward propagation step）</strong>。</li>
</ul>
<h3 id="Logistic-回归"><a href="#Logistic-回归" class="headerlink" title="Logistic 回归"></a>Logistic 回归</h3><p><strong>逻辑回归( Logistic Regression)：</strong>是一种用于解决<strong>监督学习（Supervised Learning）</strong>问题的学习算法。</p>
<p>进行逻辑回归的目的是使训练数据的标签值与预测出来的值之间的误差最小化。</p>
<p>Logistic 回归是一个用于<strong>二分类</strong>的算法，给定一些输入，输出结果是离散值。</p>
<p>Logistic 回归中使用的参数如下：</p>
<ul>
<li>输入的特征向量：$x∈R^nx$，其中 $n^x$ 是特征数量；</li>
<li>用于训练的标签：$y∈0,1$</li>
<li>权重：$w∈R^nx$</li>
<li>偏置：$ b∈R$</li>
<li>输出：$\hat{y} = \sigma(w^Tx+b)$</li>
<li>Sigmoid 函数：</li>
</ul>
<p>$$<br>s = \sigma(w^Tx+b) = \sigma(z) = \frac{1}{1+e^{-z}}<br>$$</p>
<p>为将 $wTx+b$ 约束在 [0, 1] 间，引入 Sigmoid 函数。从下图可看出，Sigmoid 函数的值域为 [0, 1]。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201109154334967.png" alt="image-20201109154334967" style="zoom:67%;" />



<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><strong>损失函数（loss function）</strong>用于衡量<u>单个样本</u>预测结果 $\hat{y}^{(i)}$ 与真实值 $y^{(i)}$ 之间的误差。</p>
<p>最简单的损失函数定义方式为<u>平方差损失函数</u>：<br>$$<br>L(\hat{y},y) = \frac{1}{2}(\hat{y}-y)^2<br>$$<br>但 Logistic 回归中我们并不倾向于使用这样的损失函数，因为之后讨论的优化问题会变成非凸的，最后会得到很多个局部最优解，梯度下降法可能找不到全局最优值。</p>
<p>一般使用<u>交叉熵损失函数</u>：<br>$$<br>L(\hat{y},y) = -(y\log\hat{y})-(1-y)\log(1-\hat{y})<br>$$<br>损失函数是在单个训练样本中定义的，它衡量了在<strong>单个</strong>训练样本上的表现。</p>
<p>而<strong>代价函数（cost function，或者称作成本函数）</strong>衡量的是在<strong>全体</strong>训练样本上的表现，即衡量参数 w 和 b 的效果。<br>$$<br>J(w,b) = \frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})<br>$$</p>
<div class="note warning">
            <p>损失函数：针对单个训练样本。</p><p>代价函数：针对全体训练样本，是参数的总代价。</p>
          </div>





<h3 id="梯度下降法（Gradient-Descent）"><a href="#梯度下降法（Gradient-Descent）" class="headerlink" title="梯度下降法（Gradient Descent）"></a>梯度下降法（Gradient Descent）</h3><p>函数的<strong>梯度（gradient）</strong>指出了函数的最陡增长方向。即是说，按梯度的方向走，函数增长得就越快。那么按梯度的负方向走，函数值自然就降低得最快了。</p>
<p>模型的训练目标即是寻找合适的 w 与 b 以最小化代价函数值。简单起见我们先假设 w 与 b 都是一维实数，那么可以得到如下的 J 关于 w 与 b 的图：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201113092437430.png" alt="image-20201113092437430" style="zoom:67%;" />

<p>可以看到，成本函数 J 是一个<strong>凸函数</strong>，与非凸函数的区别在于其不含有多个局部最低点；选择这样的代价函数就保证了无论我们初始化模型参数如何，都能够寻找到合适的最优解。</p>
<p>参数 w 的更新公式为：<br>$$<br>w := w - \alpha\frac{dJ(w, b)}{dw}<br>$$<br>其中 α 表示学习速率，即每次更新的 w 的步伐长度。$\frac{dJ(w, b)}{dw}$ 是函数 $dJ(w,b)$ 对 w 求偏导。</p>
<p>当 w 大于最优解 w′ 时，导数大于 0，那么 w 就会向更小的方向更新。反之当 w 小于最优解 w′ 时，导数小于 0，那么 w 就会向更大的方向更新。迭代直到收敛。</p>
<p>在成本函数 J(w, b) 中还存在参数 b，因此也有：</p>
<p>$$<br>b := b - \alpha\frac{dJ(w, b)}{db}<br>$$</p>
<h3 id="计算图（Computation-Graph）"><a href="#计算图（Computation-Graph）" class="headerlink" title="计算图（Computation Graph）"></a>计算图（Computation Graph）</h3><p>神经网络中的计算即是由多个计算网络输出的前向传播与计算梯度的后向传播构成。所谓的<strong>反向传播（Back Propagation）</strong>即是当我们需要计算最终值相对于某个特征变量的导数时，我们需要利用计算图中上一步的结点定义。计算图解释了为什么我们用这种方式组织这些计算过程。</p>
<h3 id="Logistic-回归中的梯度下降法"><a href="#Logistic-回归中的梯度下降法" class="headerlink" title="Logistic 回归中的梯度下降法"></a>Logistic 回归中的梯度下降法</h3><p>假设输入的特征向量维度为 2，即输入参数共有 x1, w1, x2, w2, b 这五个。可以推导出如下的计算图：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201113080326996.png" alt="image-20201113080326996"></p>
<p>考虑单个样例，已知：<br>$$<br>L(a,y)=-(y\log a + (1-y)\log (1-a))<br>$$</p>
<p>$$<br>a=\sigma(z) = \frac{1}{1+e^{-z}}<br>$$</p>
<p>$$<br>z=w_1x_1+w_2x_2 + b<br>$$</p>
<blockquote>
<p>注：对sigmoid求导：<br>$$<br>dz=\frac{a}{1-a}<br>$$</p>
</blockquote>
<hr>
<p>首先反向求出 L 对于 a 的导数：<br>$$<br>da=\frac{dL(a,y)}{da}=-\frac{y}{a}+\frac{1-y}{1-a}<br>$$<br>然后继续反向求出 L 对于 z 的导数：<br>$$<br>dz=\frac{dL}{dz}=\frac{dL(a,y)}{dz}=\frac{dL}{da}\frac{da}{dz}=a−y<br>$$<br>依此类推求出最终的损失函数相较于原始参数的导数之后，根据如下公式进行参数更新：<br>$$<br>w_1:=w_1-\alpha dw_1<br>$$</p>
<p>$$<br>w_2:=w_2-\alpha dw_2<br>$$</p>
<p>$$<br>b:=b-\alpha db<br>$$</p>
<hr>
<p>接下来我们需要将对于单个用例的损失函数扩展到整个训练集的代价函数：<br>$$<br>J(w,b)=\frac{1}{m}\sum^m_{i=1}L(a^{(i)},y^{(i)})<br>$$</p>
<p>$$<br>a^{(i)}=\hat{y}^{(i)}=\sigma(z^{(i)})=\sigma(w^Tx^{(i)}+b)<br>$$</p>
<p>我们可以对于某个权重参数 w1，其导数计算为：<br>$$<br>dw_1=\frac{\partial J(w,b)}{\partial{w_1}}=\frac{1}{m}\sum^m_{i=1}\frac{\partial L(a^{(i)},y^{(i)})}{\partial{w_1}}<br>$$<br>完整的 Logistic 回归中某次训练的伪代码流程如下，这里仅假设特征向量的维度为 2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">J=<span class="number">0</span>; dw1=<span class="number">0</span>; dw2=<span class="number">0</span>; db=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m</span><br><span class="line">    z(i) = wx(i)+b;</span><br><span class="line">    a(i) = sigmoid(z(i));</span><br><span class="line">    J += -[y(i)log(a(i))+(<span class="number">1</span>-y(i)）log(<span class="number">1</span>-a(i));</span><br><span class="line">    dz(i) = a(i)-y(i);</span><br><span class="line">    dw1 += x1(i)dz(i);</span><br><span class="line">    dw2 += x2(i)dz(i);</span><br><span class="line">    db += dz(i);</span><br><span class="line"></span><br><span class="line">J/= m;</span><br><span class="line">dw1/= m;</span><br><span class="line">dw2/= m;</span><br><span class="line">db/= m;</span><br><span class="line">w=w-alpha*dw</span><br><span class="line">b=b-alpha*db</span><br></pre></td></tr></table></figure>
<p>上述过程在计算时有一个缺点：你需要编写两个 for 循环。第一个 for 循环遍历 m 个样本，而第二个 for 循环遍历所有特征。如果有大量特征，在代码中显式使用 for 循环会使算法很低效。<strong>向量化</strong>可以用于解决显式使用 for 循环的问题。</p>
<h3 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h3><p>在 Logistic 回归中，需要计算<br>$$<br>z=w^Tx+b<br>$$<br>如果是非向量化的循环方式操作，代码可能如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_x):</span><br><span class="line">	z[i] += w[i] * x[i];</span><br><span class="line">z += b</span><br></pre></td></tr></table></figure>


<p>而如果是向量化的操作，代码则会简洁很多，并带来近百倍的性能提升（并行指令）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = np.dot(w, x) + b</span><br></pre></td></tr></table></figure>


<p>不用显式 for 循环，实现 Logistic 回归的梯度下降一次迭代（对应之前伪代码的 for 循环部分。这里公式和 NumPy 的代码混杂，注意分辨）：<br>$$<br>Z=w^TX+b=np.dot(w.T, x) + b<br>$$</p>
<p>$$<br>A=\sigma(Z)<br>$$</p>
<p>$$<br>dZ=A-Y<br>$$</p>
<p>$$<br>dw=\frac{1}{m}XdZ^T<br>$$</p>
<p>$$<br>db=\frac{1}{m}np.sum(dZ)<br>$$</p>
<p>$$<br>w:=w-\sigma dw<br>$$</p>
<p>$$<br>b:=b-\sigma db<br>$$</p>
<p>正向和反向传播尽管如此，多次迭代的梯度下降依然需要 for 循环。</p>
<h3 id="广播（broadcasting）"><a href="#广播（broadcasting）" class="headerlink" title="广播（broadcasting）"></a>广播（broadcasting）</h3><p>Numpy 的 Universal functions 中要求输入的数组 shape 是一致的。当数组的 shape 不相等的时候，则会使用广播机制，调整数组使得 shape 一样，满足规则，则可以运算，否则就出错。</p>
<p>四条规则：</p>
<ol>
<li>让所有输入数组都向其中 shape 最长的数组看齐，shape 中不足的部分都通过在前面加 1 补齐；</li>
<li>输出数组的 shape 是输入数组 shape 的各个轴上的最大值；</li>
<li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错；</li>
<li>当输入数组的某个轴的长度为 1 时，沿着此轴运算时都用此轴上的第一组值。</li>
</ol>
<h3 id="NumPy-使用技巧"><a href="#NumPy-使用技巧" class="headerlink" title="NumPy 使用技巧"></a>NumPy 使用技巧</h3><p>转置对秩为 1 的数组无效。因此，应该避免使用秩为 1 的数组，用 n * 1 的矩阵代替。例如，用<code>np.random.randn(5,1)</code> 代替 <code>np.random.randn(5)</code> 。</p>
<p>如果得到了一个秩为 1 的数组，可以使用 <code>reshape</code> 进行转换。</p>
<h2 id="浅层神经网络"><a href="#浅层神经网络" class="headerlink" title="浅层神经网络"></a>浅层神经网络</h2><h3 id="神经网络表示"><a href="#神经网络表示" class="headerlink" title="神经网络表示"></a>神经网络表示</h3><p>竖向堆叠起来的输入特征被称作神经网络的<strong>输入层（the input layer）</strong>。</p>
<p>神经网络的<strong>隐藏层（a hidden layer）</strong>。“隐藏”的含义是<strong>在训练集中</strong>，这些中间节点的真正数值是无法看到的。</p>
<p><strong>输出层（the output layer）</strong>负责输出预测值。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201114113032833.png" alt="image-20201114113032833" style="zoom: 67%;" />

<p>如图是一个<strong>双层神经网络</strong>，也称作<strong>单隐层神经网络（a single hidden layer neural network）</strong>。当我们计算网络的层数时，通常不考虑输入层，因此图中隐藏层是第一层，输出层是第二层，而输入层为第零层。</p>
<p>约定俗成的符号表示是：</p>
<ul>
<li>上标“[ ]”括号中的数字表示<u>神经网络中的第几层</u>，a代表着<strong>激活（Activation）</strong>，指的是不同层次的神经网络传递给后续层次的值。</li>
<li>输入层的激活值为 $a[0]$ ；</li>
<li>同样，隐藏层也会产生一些激活值，记作 $a^{[1]}$ 隐藏层的第一个单元（或者说节点）就记作 $a_1^{[1]}$ ,输出层同理。</li>
<li>另外，隐藏层和输出层都是带有参数 W 和 b 的。它们都使用上标 [1] 来表示是和第一个隐藏层有关，或者上标 [2] 来表示是和输出层有关。</li>
</ul>
<h3 id="计算神经网络的输出"><a href="#计算神经网络的输出" class="headerlink" title="计算神经网络的输出"></a>计算神经网络的输出</h3><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201115084405346.png" alt="image-20201115084405346" style="zoom:50%;" />

<p>实际上，神经网络只不过将 Logistic 回归的计算步骤重复很多次。对于隐藏层的第一个节点，<br>$$<br>z _1^{[1]} = (W _1^{[1]})^TX+b _1^{[1]}<br>$$</p>
<p>$$<br>a _1^{[1]} = \sigma(z _1^{[1]})<br>$$</p>
<p>我们可以类推得到，对于第一个隐藏层有下列公式：<br>$$<br>z^{[1]} = (W^{[1]})^Ta^{[0]}+b^{[1]}<br>$$</p>
<p>$$<br>a^{[1]} = \sigma(z^{[1]})<br>$$</p>
<p>其中，$a[0]$ 可以是一个列向量，也可以将多个列向量堆叠起来得到矩阵。如果是后者的话，得到的 $z[1]$ 和 $a[1]$ 也是一个矩阵。</p>
<p>同理，对于输出层有：<br>$$<br>z^{[2]} = (W^{[2]})^Ta^{[1]}+b^{[2]}<br>$$</p>
<p>$$<br>\hat{y} = a^{[2]} = \sigma(z^{[2]})<br>$$</p>
<p>值得注意的是<strong>层与层之间参数矩阵的规格大小</strong>。</p>
<ul>
<li>输入层和隐藏层之间：$(W^{[1]})^T$ 的 shape 为 <code>(4,3)</code> ，前面的 4 是隐藏层神经元的个数，后面的 3 是输入层神经元的个数；$b^{[1]}$ 的 shape 为 <code>(4,1)</code> ，和隐藏层的神经元个数相同。</li>
<li>隐藏层和输出层之间：$(W^{[2]})^T$ 的 shape 为 <code>(1,4)</code> ，前面的 1 是输出层神经元的个数，后面的 4 是隐藏层神经元的个数；$b^{[2]}$ 的 shape 为 <code>(1,1)</code> ，和输出层的神经元个数相同。</li>
</ul>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>有一个问题是神经网络的隐藏层和输出单元用什么激活函数。之前我们都是选用 sigmoid 函数，但有时其他函数的效果会好得多。</p>
<p>可供选用的激活函数有：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115102234900.png" alt="image-20201115102234900"></p>
<h4 id="tanh-函数（the-hyperbolic-tangent-function，双曲正切函数）"><a href="#tanh-函数（the-hyperbolic-tangent-function，双曲正切函数）" class="headerlink" title="tanh 函数（the hyperbolic tangent function，双曲正切函数）"></a>tanh 函数（the hyperbolic tangent function，双曲正切函数）</h4><p>$$<br>a = \frac{e^z - e^{-z}}{e^z + e^{-z}}<br>$$</p>
<p>效果几乎总比 sigmoid 函数好（除开<strong>二元分类的输出层</strong>，因为我们希望输出的结果介于 0 到 1 之间），因为函数输出介于 -1 和 1 之间，激活函数的平均值就更接近 0，有类似数据中心化的效果。</p>
<p>然而，tanh 函数存在和 sigmoid 函数一样的缺点：当 z 趋紧无穷大（或无穷小），导数的梯度（即函数的斜率）就趋紧于 0，这使得梯度算法的速度大大减缓。</p>
<h4 id="ReLU-函数（the-rectified-linear-unit，修正线性单元）"><a href="#ReLU-函数（the-rectified-linear-unit，修正线性单元）" class="headerlink" title="ReLU 函数（the rectified linear unit，修正线性单元）"></a>ReLU 函数（the rectified linear unit，修正线性单元）</h4><p>$$<br>a=max(0,z)<br>$$</p>
<p>当 z &gt; 0 时，梯度始终为 1，从而提高神经网络基于梯度算法的运算速度，收敛速度远大于 sigmoid 和 tanh。然而当 z &lt; 0 时，梯度一直为 0，但是实际的运用中，该缺陷的影响不是很大。</p>
<h4 id="Leaky-ReLU（带泄漏的-ReLU）："><a href="#Leaky-ReLU（带泄漏的-ReLU）：" class="headerlink" title="Leaky ReLU（带泄漏的 ReLU）："></a>Leaky ReLU（带泄漏的 ReLU）：</h4><p>$$<br>a=max(0.01z,z)<br>$$</p>
<p>当 z &gt; 0 时，梯度始终为 1，从而提高神经网络基于梯度算法的运算速度，收敛速度远大于 sigmoid 和 tanh。然而当 z &lt; 0 时，梯度一直为 0，但是实际的运用中，该缺陷的影响不是很大。</p>
<blockquote>
<p>经验：在选择激活函数的时候，如果是二分类问题，输出层选 sigmoid 函数，其他层都选 ReLU 函数。如果在不知道该选什么的时候就选择 ReLU，当然也没有固定答案，要依据实际问题在交叉验证集合中进行验证分析。当然，我们可以在不同层选用不同的激活函数。</p>
</blockquote>
<h4 id="使用-ReLU-激活函数的优点？-为什么ReLU要好过sigmoid和tanh？"><a href="#使用-ReLU-激活函数的优点？-为什么ReLU要好过sigmoid和tanh？" class="headerlink" title="使用 ReLU 激活函数的优点？/ 为什么ReLU要好过sigmoid和tanh？"></a>使用 ReLU 激活函数的优点？/ 为什么ReLU要好过sigmoid和tanh？</h4><ol>
<li>采用 sigmoid 等函数，算激活函数时（指数运算），计算量大，反向传播求误差梯度时，求导涉及除法和指数运算，计算量相对大，而采用 ReLU 激活函数，整个过程的计算量节省很多。</li>
<li>对于深层网络，sigmoid 函数反向传播时，很容易就会出现梯度消失的情况（在 sigmoid 接近饱和区时，变换太缓慢，导数趋于0，这种情况会造成信息丢失），这种现象称为饱和，从而无法完成深层网络的训练，为什么会无法完成训练呢，因为神经网络更新w的时候就是依靠导数来更新的，如果导数接近0，那 w 更新之后还是原来的 w了。而 ReLU 就不会有饱和倾向，不会有特别小的梯度出现。</li>
</ol>
<blockquote>
<p>需注意， ReLU 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性。主要问题有两个：</p>
<ol>
<li>0点附近不可微。所以通常在0点只求右导数</li>
<li>它会“谋杀”一些神经元。就是说在 BP 的过程中很快会让一些神经元的导数永远是0，于是这些神经元等于被抛弃了，也就是被谋杀了。这提高了速度和精度，但是也有些武断，于是为了解决这个问题，引入了Leaky ReLU。Leaky ReLu 不会产生这个问题。</li>
</ol>
</blockquote>
<h3 id="使用非线性激活函数的原因"><a href="#使用非线性激活函数的原因" class="headerlink" title="使用非线性激活函数的原因"></a>使用非线性激活函数的原因</h3><ol>
<li><p>使用线性激活函数和不使用激活函数、直接使用 Logistic 回归没有区别，那么无论神经网络有多少层，输出都是输入的线性组合，与<strong>没有隐藏层</strong>效果相当，就成了最原始的感知器了。</p>
</li>
<li><p>使用非线性激活函数 ，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。使用非线性激活函数，能够从输入输出之间生成非线性映射。</p>
</li>
</ol>
<h3 id="激活函数的导数"><a href="#激活函数的导数" class="headerlink" title="激活函数的导数"></a>激活函数的导数</h3><ul>
<li>sigmoid 函数：</li>
</ul>
<p>$$<br>g(z) = \frac{1}{1+e^{-z}}<br>$$</p>
<p>$$<br>g\prime(z)=\frac{dg(z)}{dz} = \frac{1}{1+e^{-z}}(1-\frac{1}{1+e^{-z}})=g(z)(1-g(z))<br>$$</p>
<ul>
<li>tanh 函数：</li>
</ul>
<p>$$<br>g(z) = tanh(z) = \frac{e^z - e^{-z}}{e^z + e^{-z}}<br>$$</p>
<p>$$<br>g\prime(z)=\frac{dg(z)}{dz} = 1-(tanh(z))^2=1-(g(z))^2<br>$$</p>
<ul>
<li>ReLU 函数：</li>
</ul>
<p>$$<br>g(z)=max(0,z)<br>$$</p>
<p>$$<br>\frac{d}{d z} g(z)=\left{\begin{array}{ll}<br>0 &amp; \text { if } z&lt;0 \<br>1 &amp; \text { if } z&gt;0 \<br>\text { undefined } &amp; \text { if } z=0<br>\end{array}\right.<br>$$</p>
<h2 id="神经网络的梯度下降法"><a href="#神经网络的梯度下降法" class="headerlink" title="神经网络的梯度下降法"></a>神经网络的梯度下降法</h2><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115110144415.png" alt="image-20201115110144415"></p>
<p>$$<br>z^{[1]}={(w^{[1]})}^Tx+b^{[1]}<br>$$</p>
<p>$$<br>a^{[1]}=g^{[1]}(z^{[1]})<br>$$</p>
<p>$$<br>z^{[2]}={(w^{[2]})}^Ta^{[1]}+b^{[2]},(x=a^{[1]})<br>$$</p>
<p>$$<br>a^{[2]}=g^{[2]}(z^{[2]})=\sigma(z^{[2]})<br>$$</p>
<p>$$<br>\mathcal{L}\left(a^{[2]}, y\right)=-\left(y \log a^{[2]}+(1-y) \log \left(1-a^{[2]}\right)\right)<br>$$</p>
<p>在训练过程中，经过前向传播后得到的最终结果跟训练样本的真实值总是存在一定误差，这个误差便是损失函数。想要减小这个误差，当前应用最广的一个算法便是梯度下降，于是用损失函数，从后往前，依次求各个参数的偏导，这就是所谓的<strong>反向传播（Back Propagation）</strong>，一般简称这种算法为BP算法。</p>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115112715694.png" alt="image-20201115112715694"></p>
<p>已知 sigmoid 函数的导数为：<br>$$<br>a^{[2]^{\prime}}=\operatorname{sigmoid}\left(z^{[2]}\right)^{\prime}=\frac{\partial a^{[2]}}{\partial z^{[2]}}=a^{[2]}\left(1-a^{[2]}\right)<br>$$</p>
<p>由复合函数求导中的链式法则，反向传播过程中：<br>$$<br>d a^{[2]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} =-\frac{y}{a^{[2]}} + \frac{1-y}{1-a^{[2]}},(对交叉熵损失函数求导)<br>$$</p>
<p>$$<br>d z^{[2]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial \alpha^{[2]}}{\partial z^{[2]}}=a^{[2]}-y<br>$$</p>
<p>$$<br>d w^{[2]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial w^{[2]}}=d z^{[2]}=a^{[2]}-y<br>$$</p>
<p>$$<br>d b^{[2]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial b^{[2]}}=d z^{[2]}=a^{[2]}-y<br>$$</p>
<p>$$<br>d a^{[1]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}}=d z^{[2]} \cdot w^{[2]}<br>$$</p>
<p>$$<br>d z^{[1]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{(2]}} \cdot \frac{\partial \alpha^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}} \cdot \frac{\partial a^{[1]}}{\partial z^{[1]}}=d z^{[2]} \cdot w^{[2]} \times g^{[1]^{\prime}}\left(z^{[1]}\right)<br>$$</p>
<p>$$<br>d w^{[1]}=\frac{\partial \mathcal{L}\left(\alpha^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{(2]}} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}} \cdot \frac{\partial a^{[1]}}{\partial z^{[1]}} \cdot \frac{\partial z^{[1]}}{\partial w^{[1]}}=d z^{[1]} \cdot{X^{T}}<br>$$</p>
<p>$$<br>d b^{[1]}=\frac{\partial \mathcal{L}\left(a^{[2]}, y\right)}{\partial a^{[2]}} \cdot \frac{\partial a^{[2]}}{\partial z^{[2]}} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}} \cdot \frac{\partial a^{[1]}}{\partial z^{[1]}} \cdot \frac{\partial z^{[1]}}{\partial b^{[1]}}=d z^{[1]}<br>$$</p>
<p>这便是反向传播的整个推导过程，在具体的算法实现过程中，使用梯度下降的方法，将各个参数进行向量化、取平均值，不断进行更新。</p>
<h3 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h3><p>如果在初始时将两个隐藏神经元的参数设置为相同的大小，那么两个隐藏神经元对输出单元的影响也是相同的，通过反向梯度下降去进行计算的时候，会得到同样的梯度大小，所以在经过多次迭代后，两个隐藏层单位仍然是对称的。无论设置多少个隐藏单元，其最终的影响都是相同的，那么多个隐藏神经元就没有了意义。</p>
<p>在初始化的时候，<strong>W 参数要进行随机初始化，不可以设置为 0</strong>。而 b 因为不存在对称性的问题，可以设置为 0。</p>
<p>以 2 个输入，2 个隐藏神经元为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W = np.random.rand(<span class="number">2</span>,<span class="number">2</span>)* <span class="number">0.01</span></span><br><span class="line">b = np.zeros((<span class="number">2</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>这里将 W 的值乘以 0.01（或者其他的常数值）的原因是为了使得权重 W 初始化为较小的值，<u>这是因为使用 sigmoid 函数或者 tanh 函数作为激活函数时，W 比较小，则 Z=WX+b 所得的值趋近于 0，梯度较大，能够提高算法的更新速度。</u>而如果 W 设置的太大的话，得到的梯度较小，训练过程因此会变得很慢。</p>
<p>ReLU 和 Leaky ReLU 作为激活函数时不存在这种问题，因为在大于 0 的时候，梯度均为 1。</p>
<h2 id="深层神经网络"><a href="#深层神经网络" class="headerlink" title="深层神经网络"></a>深层神经网络</h2><h3 id="深层网络中的前向和反向传播"><a href="#深层网络中的前向和反向传播" class="headerlink" title="深层网络中的前向和反向传播"></a>深层网络中的前向和反向传播</h3><h4 id="前向传播-1"><a href="#前向传播-1" class="headerlink" title="前向传播"></a>前向传播</h4><p>推导整个前向传播的过程可得：</p>
<p><strong>输入：</strong> $a^{[l-1]}$</p>
<p><strong>输出：</strong> $a^{[l]}$， $cache(z^{[l]})$</p>
<p><strong>公式：</strong><br>$$<br>Z^{[l]}=W^{[l]}\cdot a^{[l-1]}+b^{[l]}<br>$$</p>
<p>$$<br>a^{[l]}=g^{[l]}(Z^{[l]})<br>$$</p>
<h4 id="反向传播-1"><a href="#反向传播-1" class="headerlink" title="反向传播"></a>反向传播</h4><p><strong>输入</strong>：$da^{[l]}$</p>
<p><strong>输出</strong>：$da^{[l−1]}$，$dW[l]$，$db^{[l]}$</p>
<p><strong>公式：</strong><br>$$<br>dZ^{[l]}=da^{[l]}*g^{[l]}{‘}(Z^{[l]})<br>$$</p>
<p>$$<br>dW^{[l]}=dZ^{[l]}\cdot a^{[l-1]}<br>$$</p>
<p>$$<br>db^{[l]}=dZ^{[l]}<br>$$</p>
<p>$$<br>da^{[l-1]}=W^{[l]T}\cdot dZ^{[l]}<br>$$</p>
<ul>
<li>总结：</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/A3AB54BACCBBD3A9346DCD5378E9A876.png" alt="A3AB54BACCBBD3A9346DCD5378E9A876"></p>
<h3 id="搭建深层神经网络块"><a href="#搭建深层神经网络块" class="headerlink" title="搭建深层神经网络块"></a>搭建深层神经网络块</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115205800365.png" alt="image-20201115205800365"></p>
<p>神经网络的一步训练（一个梯度下降循环），包含了从 $a[0]$（即 x）经过一系列正向传播计算得到 $\hat y$（即 $a[l]$）。然后再计算 $da[l]$，开始实现反向传播，用<strong>链式法则</strong>得到所有的导数项，W 和 b 也会在每一层被更新。</p>
<p>在代码实现时，可以将正向传播过程中计算出来的 z 值缓存下来，待到反向传播计算时使用。</p>
<h3 id="矩阵的维度"><a href="#矩阵的维度" class="headerlink" title="矩阵的维度"></a>矩阵的维度</h3><p>$$<br>W^{[l]}: (n^{[l]}, n^{[l-1]})<br>$$</p>
<p>$$<br>b^{[l]}: (n^{[l]}, 1)<br>$$</p>
<p>$$<br>dW^{[l]}: (n^{[l]}, n^{[l-1]})<br>$$</p>
<p>$$<br>db^{[l]}: (n^{[l]}, 1)<br>$$</p>
<p>对于 Z、a，向量化之前有：<br>$$<br>Z^{[l]}, a^{[l]}: (n^{[l]}, 1)<br>$$<br>而在向量化之后，则有：<br>$$<br>Z^{[l]}, A^{[l]}: (n^{[l]}, m)<br>$$<br>在计算反向传播时，dZ、dA 的维度和 Z、A 是一样的。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201115203736131.png" alt="image-20201115203736131"></p>
<h3 id="使用深层表示的原因"><a href="#使用深层表示的原因" class="headerlink" title="使用深层表示的原因"></a>使用深层表示的原因</h3><p>对于人脸识别，神经网络的第一层从原始图片中提取人脸的轮廓和边缘，每个神经元学习到不同边缘的信息；网络的第二层将第一层学得的边缘信息组合起来，形成人脸的一些局部的特征，例如眼睛、嘴巴等；后面的几层逐步将上一层的特征组合起来，形成人脸的模样。随着神经网络层数的增加，特征也从原来的边缘逐步扩展为人脸的整体，由整体到局部，由简单到复杂。层数越多，那么模型学习的效果也就越精确。</p>
<p>同样的，对于语音识别，第一层神经网络可以学习到语言发音的一些音调，后面更深层次的网络可以检测到基本的音素，再到单词信息，逐渐加深可以学到短语、句子。</p>
<p>通过例子可以看到，随着神经网络的深度加深，模型能学习到更加复杂的问题，功能也更加强大。</p>
<h3 id="参数和超参数"><a href="#参数和超参数" class="headerlink" title="参数和超参数"></a>参数和超参数</h3><p><strong>参数</strong>即是我们在过程中想要模型学习到的信息（<strong>模型自己能计算出来的</strong>），例如 W[l]W[l]，b[l]b[l]。而<strong>超参数（hyper parameters）</strong>即为控制参数的输出值的一些网络信息（<strong>需要人经验判断</strong>）。超参数的改变会导致最终得到的参数 $W^{[l]}$，$b^{[l]}$ 的改变。</p>
<p>典型的超参数有：</p>
<ul>
<li>学习速率：α</li>
<li>迭代次数：N</li>
<li>隐藏层的层数：L</li>
<li>每一层的神经元个数：$n^{[1]}$，$n^{[2]}$，…</li>
<li>激活函数 g(z) 的选择</li>
</ul>
<p>当开发新应用时，预先很难准确知道超参数的最优值应该是什么。因此，通常需要尝试很多不同的值。应用深度学习领域是一个很大程度基于经验的过程。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫基础</title>
    <url>/2020/11/01/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="第一章-爬虫简介"><a href="#第一章-爬虫简介" class="headerlink" title="第一章 爬虫简介"></a>第一章 爬虫简介</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ul>
<li>概念：用于从万维网服务器传输超文本到本地浏览器的传送协议。就是服务器和客户端进行数据交互的形式。</li>
</ul>
<h3 id="常见的请求头信息"><a href="#常见的请求头信息" class="headerlink" title="常见的请求头信息"></a>常见的请求头信息</h3><ul>
<li><p><strong>User-Agent：</strong>请求载体的身份标识</p>
</li>
<li><p><strong>Connection：</strong>浏览器通过这个头告诉服务器，请求完后是断开链接还是保持链接</p>
</li>
</ul>
<h3 id="常见的响应头信息"><a href="#常见的响应头信息" class="headerlink" title="常见的响应头信息"></a>常见的响应头信息</h3><ul>
<li><strong>Content-Type：</strong>服务器通过这个头，告诉浏览器回送数据的类型</li>
</ul>
<h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。</p>
<h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><ul>
<li>对称秘钥加密</li>
<li>非对称秘钥加密</li>
<li>证书秘钥加密</li>
</ul>
<h1 id="第二章-requests模块基础"><a href="#第二章-requests模块基础" class="headerlink" title="第二章 requests模块基础"></a>第二章 requests模块基础</h1><h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3><p>requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率高。</p>
<ul>
<li>urllib模块</li>
<li>requests模块</li>
</ul>
<p><strong>requests模块作用：模拟浏览器发请求</strong></p>
<h3 id="如何使用：-requests模块的编码流程"><a href="#如何使用：-requests模块的编码流程" class="headerlink" title="如何使用：(requests模块的编码流程)"></a>如何使用：(requests模块的编码流程)</h3><ol>
<li><p>指定url</p>
<ul>
<li>UA伪装</li>
<li>请求参数的处理</li>
</ul>
</li>
<li><p>发起请求，get方法会返回一个响应对象</p>
</li>
<li><p>获取相应数据 <code>.text</code> 返回的是字符串形式的响应数据</p>
</li>
<li><p>持久化存储</p>
</li>
</ol>
<h4 id="栗子1：爬取搜狗首页的页面数据"><a href="#栗子1：爬取搜狗首页的页面数据" class="headerlink" title="栗子1：爬取搜狗首页的页面数据"></a>栗子1：爬取搜狗首页的页面数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬取搜狗首页的页面数据</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 1. 指定url</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.sogou.com/&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 发起请求</span></span><br><span class="line">    <span class="comment"># get方法会返回一个响应对象</span></span><br><span class="line">    response = requests.get(url=url)</span><br><span class="line">    <span class="comment"># 3. 获取相应数据.text返回的是字符串形式的响应数据</span></span><br><span class="line">    page_text = response.text</span><br><span class="line">    print(page_text)</span><br><span class="line">    <span class="comment"># 4. 持久化存储</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./sogou.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(page_text)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;爬取数据结束！&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="反爬机制："><a href="#反爬机制：" class="headerlink" title="反爬机制："></a>反爬机制：</h3><ul>
<li><p><strong>UA</strong>：User-Agent (请求载体的身份标识)</p>
</li>
<li><p><strong>UA检测</strong>：门户网站的服务器会检测对应请求的载体身份标识，如果检测到请求的载体身份标识为某一款浏览器，就说明该请求是一个正常的请求.<br>但是，如果检测到请求的载体身份标识不是基于某一款浏览器，则表示该请求为不正常的请求(爬虫)，则服务器就很有可能拒绝该次请求。</p>
</li>
<li><p><strong>UA伪装</strong>：让爬虫对应的请求载体身份标识伪装成某一款浏览器<br>like：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="栗子2：UA伪装"><a href="#栗子2：UA伪装" class="headerlink" title="栗子2：UA伪装"></a>栗子2：UA伪装</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># UA伪装</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># UA伪装：将对应的User-Agent封装到一个字典中</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 指定url</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.sogou.com/web&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理url携带的参数：封装到字典中</span></span><br><span class="line">    kw = <span class="built_in">input</span>(<span class="string">&#x27;enter a word:&#x27;</span>)</span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">&#x27;query&#x27;</span>: kw</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 对指定的url发起的请求对应的url是携带参数的，并且请求过程中处理了参数</span></span><br><span class="line">    response = requests.get(url=url, params=param,headers=headers)  <span class="comment"># 相当于动态拼接了参数</span></span><br><span class="line"></span><br><span class="line">    page_text=response.text</span><br><span class="line"></span><br><span class="line">    fileName = kw + <span class="string">&#x27;.html&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fileName,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(page_text)</span><br><span class="line"></span><br><span class="line">    print(fileName, <span class="string">&#x27;爬完了&#x27;</span>)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。</p>
<p>Ajax 是一种用于创建快速动态网页的技术。一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p>
<p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
</blockquote>
<blockquote>
<p>数据如果是通过ajax动态请求到的，可以捕获包(url再一次enter)</p>
</blockquote>
<h4 id="栗子3：破解百度翻译（post请求携带了参数）"><a href="#栗子3：破解百度翻译（post请求携带了参数）" class="headerlink" title="栗子3：破解百度翻译（post请求携带了参数）"></a>栗子3：破解百度翻译（post请求携带了参数）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 破解百度翻译</span></span><br><span class="line"><span class="comment"># - post请求（携带了参数）</span></span><br><span class="line"><span class="comment"># - 响应数据是一组jso数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1. 指定url</span></span><br><span class="line">    post_url = <span class="string">&#x27;https://fanyi.baidu.com/sug&#x27;</span></span><br><span class="line">    <span class="comment"># 2. UA伪装</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 3. post请求参数处理（同get请求一致）</span></span><br><span class="line">    word = <span class="built_in">input</span>(<span class="string">&#x27;enter a word:&#x27;</span>)</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;kw&#x27;</span>:word</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 4.请求发送</span></span><br><span class="line">    response = requests.post(url=post_url,data=data,headers=headers)</span><br><span class="line">    <span class="comment"># 5. 获取响应数据.json()方法返回的是一个obj(如果确认响应数据是json类型的，才可以使用json())</span></span><br><span class="line">    <span class="comment"># 可以看 Content-Type</span></span><br><span class="line">    dic_obj = response.json()</span><br><span class="line">    print(dic_obj)</span><br><span class="line">    <span class="comment"># 持久化存储</span></span><br><span class="line">    fileName = word + <span class="string">&#x27;.json&#x27;</span></span><br><span class="line">    fp = <span class="built_in">open</span>(fileName,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json.dump(dic_obj,fp=fp,ensure_ascii=<span class="literal">False</span>)  <span class="comment"># json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;done!&quot;</span>)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>步骤：</p>
<ol>
<li>指定url</li>
<li>UA伪装</li>
<li>请求发送</li>
<li>获取响应数据</li>
<li>持久化存储</li>
</ol>
</blockquote>
<h4 id="栗子4：爬取豆瓣电影"><a href="#栗子4：爬取豆瓣电影" class="headerlink" title="栗子4：爬取豆瓣电影"></a>栗子4：爬取豆瓣电影</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬取豆瓣电影</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = <span class="string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;24&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;interval_id&#x27;</span>:<span class="string">&#x27;100:90&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;start&#x27;</span>:<span class="string">&#x27;1&#x27;</span>,  <span class="comment"># 从库中第几个开始取</span></span><br><span class="line">        <span class="string">&#x27;limit&#x27;</span>:<span class="string">&#x27;20&#x27;</span>,  <span class="comment"># 一次取的电影个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response = requests.get(url=url,params=params,headers=headers)</span><br><span class="line"></span><br><span class="line">    list_data = response.json()</span><br><span class="line"></span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&#x27;./douban.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json.dump(list_data,fp=fp,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;done!&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h1 id="第三章-数据解析"><a href="#第三章-数据解析" class="headerlink" title="第三章 数据解析"></a>第三章 数据解析</h1><p>聚焦爬虫：爬取页面中指定的页面内容。</p>
 <div class="note warning">
            <p><strong>至此，我们的数据爬取的流程可以修改为：</strong></p><ol><li><strong>指定url（UA伪装）</strong></li><li><strong>发起请求</strong></li><li><strong>获取响应数据</strong></li><li><strong>数据解析</strong></li><li><strong>持久化存储(不再存一整张页面)</strong></li></ol>
          </div> 



<p>数据解析分类:</p>
<ul>
<li>正则</li>
<li>bs4</li>
<li>xpath (重点)</li>
</ul>
<p><strong>数据解析原理概述</strong>：解析的局部的文本内容都会在标签之内或者标签对应的属性中进行存储。</p>
<ol>
<li><p>进行指定标签的定位</p>
</li>
<li><p>标签或者标签对应属性的中存储的数据值进行提取(解析)</p>
</li>
</ol>
<h3 id="数据解析—-正则表达式"><a href="#数据解析—-正则表达式" class="headerlink" title="数据解析—-正则表达式"></a>数据解析—-正则表达式</h3><h4 id="栗子1：爬取糗事百科特定的图"><a href="#栗子1：爬取糗事百科特定的图" class="headerlink" title="栗子1：爬取糗事百科特定的图"></a>栗子1：爬取糗事百科特定的图</h4><p><code>get().content</code> 返回的是二进制形式的图片数据</p>
<p><strong>text（字符串）/content（二进制形式图片）/json（）（对象）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬取糗事百科特定的图</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = <span class="string">&#x27;https://pic.qiushibaike.com/system/pictures/12374/123744051/medium/9NBGP34WEBWKFRON.jpg&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    response = requests.get(url=url,headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># content返回的是二进制形式的图片数据</span></span><br><span class="line">    <span class="comment"># text（字符串）content（二进制）json（）（对象）</span></span><br><span class="line">    img_data = response.content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./qiutu.jpg&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img_data)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;done!&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="栗子2：爬取糗事百科糗图板块下的所有的糗图图片"><a href="#栗子2：爬取糗事百科糗图板块下的所有的糗图图片" class="headerlink" title="栗子2：爬取糗事百科糗图板块下的所有的糗图图片"></a>栗子2：爬取糗事百科糗图板块下的所有的糗图图片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬取糗事百科中热图板块下的图片</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;div class=&quot;thumb&quot;&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;a href=&quot;/article/123739568&quot; target=&quot;_blank&quot;&gt;</span></span><br><span class="line"><span class="comment"># &lt;img src=&quot;//pic.qiushibaike.com/system/pictures/12373/123739568/medium/J1YQ1CZA0P0NC1TV.jpg&quot; alt=&quot;糗事#123739568&quot; class=&quot;illustration&quot; width=&quot;100%&quot; height=&quot;auto&quot;&gt;</span></span><br><span class="line"><span class="comment"># &lt;/a&gt;</span></span><br><span class="line"><span class="comment"># &lt;/div&gt;</span></span><br><span class="line"><span class="comment"># ex = &lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个文件夹</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./qiutuLibs&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./qiutuLibs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    url = <span class="string">&#x27;https://www.qiushibaike.com/imgrank/&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用通用爬虫对url对应的一整张页面进行爬取,获得的是整张页面的源码数据</span></span><br><span class="line">    page_text = requests.get(url=url,headers=headers).text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用聚焦爬虫</span></span><br><span class="line">    ex = <span class="string">&#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;&#x27;</span></span><br><span class="line">    img_src_list = re.findall(ex,page_text,re.S)  <span class="comment"># re.S 单行匹配，re,M 多行匹配</span></span><br><span class="line">    <span class="comment"># print(img_src_list)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> src <span class="keyword">in</span> img_src_list:</span><br><span class="line">        <span class="comment"># 拼接出一个完整的图片url</span></span><br><span class="line">        src = <span class="string">&#x27;https:&#x27;</span> + src</span><br><span class="line">        <span class="comment"># 请求到了图片的二进制数据</span></span><br><span class="line">        img_data = requests.get(url=src,headers=headers).content</span><br><span class="line">        <span class="comment"># 生成图片名称</span></span><br><span class="line">        img_name = src.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        imgPath = <span class="string">&#x27;./qiutuLibs/&#x27;</span> + img_name</span><br><span class="line">        <span class="comment"># 图片存储的路径</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(imgPath,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            fp.write(img_data)</span><br><span class="line">            print(img_name,<span class="string">&#x27;下载成功！！！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;done!&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="栗子3：爬取糗事百科图-分页爬取"><a href="#栗子3：爬取糗事百科图-分页爬取" class="headerlink" title="栗子3：爬取糗事百科图-分页爬取"></a>栗子3：爬取糗事百科图-分页爬取</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分页爬取</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./qiutu&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./qiutu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置一个通用的url模板</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.qiushibaike.com/imgrank/page/%d/&#x27;</span></span><br><span class="line">    <span class="comment"># page_num = 1</span></span><br><span class="line">    <span class="keyword">for</span> page_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 对应页码的url</span></span><br><span class="line">        new_url = <span class="built_in">format</span>(url%page_num)</span><br><span class="line">        print(new_url)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用聚焦爬虫将页面中所有的图进行解析/提取,获得的是整张页面的源码数据</span></span><br><span class="line">        page_text = requests.get(url=new_url,headers=headers).text</span><br><span class="line">        ex = <span class="string">&#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;&#x27;</span></span><br><span class="line">        img_src_list = re.findall(ex,page_text,re.S)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> src <span class="keyword">in</span> img_src_list:</span><br><span class="line">            <span class="comment"># 拼接出一个完整的图片url</span></span><br><span class="line">            src = <span class="string">&#x27;https:&#x27;</span> + src</span><br><span class="line">            <span class="comment"># 请求到了图片的二进制数据</span></span><br><span class="line">            img_data = requests.get(url=src, headers=headers).content</span><br><span class="line">            <span class="comment"># 生成图片名称</span></span><br><span class="line">            img_name = src.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            imgPath = <span class="string">&#x27;./qiutu/&#x27;</span> + img_name</span><br><span class="line">            <span class="comment"># 图片存储的路径</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(imgPath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                fp.write(img_data)</span><br><span class="line">                print(img_name, <span class="string">&#x27;下载成功！！！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;done&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="数据解析—-bs4"><a href="#数据解析—-bs4" class="headerlink" title="数据解析—-bs4"></a>数据解析—-bs4</h3><h4 id="bs4数据解析的原理："><a href="#bs4数据解析的原理：" class="headerlink" title="bs4数据解析的原理："></a>bs4数据解析的原理：</h4><ol>
<li><p>实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中</p>
</li>
<li><p>通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取</p>
</li>
</ol>
<h4 id="如何实例化BeautifulSoup对象："><a href="#如何实例化BeautifulSoup对象：" class="headerlink" title="如何实例化BeautifulSoup对象："></a>如何实例化BeautifulSoup对象：</h4><ul>
<li><p><code>from bs4 import BeautifulSoup</code></p>
</li>
<li><p>对象的实例化：</p>
<ul>
<li><p>将本地的html文档中的数据加载到该对象中(这种很麻烦)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;./test.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">soup = BeautifulSoup(fp,<span class="string">&#x27;lxml&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>将互联网上获取的页面源码加载到该对象中(一般用这种)</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">page_text = response.text</span><br><span class="line">soup = BeautifulSoup(page_text,<span class="string">&#x27;lxml&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lxml 是一种解析器</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="提供的用于数据解析的方法和属性"><a href="#提供的用于数据解析的方法和属性" class="headerlink" title="提供的用于数据解析的方法和属性:"></a>提供的用于数据解析的方法和属性:</h4><ul>
<li><p><code>soup.tagName</code>：返回的是html中第一次出现的tagName</p>
<blockquote>
<p>例：</p>
<ul>
<li><p><code>soup.a</code>   只能找到第一个符合要求的标签</p>
</li>
<li><p><code>soup.a.attrs</code>  获取a所有的属性和属性值，返回一个字典</p>
</li>
<li><p><code>soup.a.attrs[&#39;href&#39;]</code>  获取标签中href属性</p>
</li>
</ul>
</blockquote>
</li>
<li><p><code>soup.find()</code> ：找到第一个符合要求的标签</p>
<blockquote>
<ul>
<li><code>find(&#39;tagName&#39;)</code> ：等同于 <code>soup.tagName</code></li>
<li>属性定位：<code>soup.find(&#39;a&#39;,class_ / id / attr=&#39;***&#39; )</code></li>
</ul>
</blockquote>
</li>
<li><p><code>soup.find_all(&#39;tagName&#39;)</code> ：返回符合要求的所有标签(是一个列表)。</p>
</li>
<li><p><code>select</code> ：<code>select(&#39;某种选择器(id, class, 标签...选择器)&#39;)</code> 返回的是一个列表。</p>
<ul>
<li>层级选择器：常见的选择器：标签选择器(a)、类选择器(.)、id选择器(#)、层级选择器<ul>
<li><code>soup.select(&#39;.tang &gt; ul &gt; li &gt; a&#39;)</code> ： 标识的是一个层级</li>
<li><code>soup.select(&#39;.tang &gt; ul a&#39;)</code> ： 中间的空格表示跨越了多个层级</li>
</ul>
</li>
</ul>
</li>
<li><p>获取标签之间的文本数据:</p>
<ul>
<li><code>soup.a.text/string/get_text()</code></li>
<li><code>text / get_text()</code> ：可以获取某一个标签中所有的文本内容</li>
<li><code>string</code> ： 值可以获取该标签下面直系的文本内容</li>
</ul>
</li>
</ul>
<h4 id="栗子：爬取三国演义小说所有的章节标题和章节内容"><a href="#栗子：爬取三国演义小说所有的章节标题和章节内容" class="headerlink" title="栗子：爬取三国演义小说所有的章节标题和章节内容"></a>栗子：爬取三国演义小说所有的章节标题和章节内容</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬取三国演义小说所有的章节标题和章节内容</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 对首页数据进行爬取</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.shicimingju.com/book/sanguoyanyi.html&#x27;</span></span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_text = requests.get(url=url,headers=headers).text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在首页中解析出章节的标题和详情页的url</span></span><br><span class="line">    <span class="comment"># 1. 实例化出BeautifulSoup对象，需要将页面源码数据加载到该对象中</span></span><br><span class="line">    soup = BeautifulSoup(page_text,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="comment"># 2. 解析章节标题和url</span></span><br><span class="line">    li_list = soup.select(<span class="string">&#x27;.book-mulu &gt; ul &gt; li&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(li_list)</span></span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&#x27;./sanguo.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">        title = li.a.string</span><br><span class="line">        detail_url = <span class="string">&#x27;https://www.shicimingju.com&#x27;</span> + li.a[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对详情页发起请求，解析出章节内容</span></span><br><span class="line">        detail_page_text = requests.get(url=detail_url,headers=headers).text</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析出详情页中相关的章节内容</span></span><br><span class="line">        detail_soup = BeautifulSoup(detail_page_text,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        div_tag = detail_soup.find(<span class="string">&#x27;div&#x27;</span>,class_=<span class="string">&#x27;chapter_content&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析到了章节内容</span></span><br><span class="line">        content = div_tag.text</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 持久化存储(不能写到循环里)</span></span><br><span class="line">        fp.write(title+<span class="string">&#x27;:&#x27;</span>+content+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        print(title,<span class="string">&#x27;爬取成功&#x27;</span>)</span><br></pre></td></tr></table></figure>




<h3 id="数据解析—-xpath解析"><a href="#数据解析—-xpath解析" class="headerlink" title="数据解析—-xpath解析"></a>数据解析—-xpath解析</h3><p>xpath解析：最常用且最高效便捷的一种解析方式。通用性最强。</p>
<h4 id="xpath解析原理："><a href="#xpath解析原理：" class="headerlink" title="xpath解析原理："></a>xpath解析原理：</h4><ol>
<li>实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。</li>
<li>调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获</li>
</ol>
<h4 id="如何实例化一个etree对象"><a href="#如何实例化一个etree对象" class="headerlink" title="如何实例化一个etree对象:"></a>如何实例化一个etree对象:</h4><ul>
<li><p><code>from lxml import etree</code></p>
</li>
<li><p>对象的实例化：</p>
<ul>
<li><p>将本地的html文档中的源码数据加载到该对象中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">etree.parse(filePath)</span><br></pre></td></tr></table></figure></li>
<li><p>可以将从互联网上获取的源码数据加载到该对象中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">etree.HTML(<span class="string">&#x27;PAGE_text&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>xpath(‘xpath表达式’)</strong> <strong>(重点！)</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="xpath表达式"><a href="#xpath表达式" class="headerlink" title="xpath表达式:"></a>xpath表达式:</h4><ul>
<li><p><code>/</code>：表示的是从根节点开始定位。标识的是一个层级</p>
<p>  <code>//</code>：表示的是多个层级。可以表示从任意位置开始定位</p>
<ul>
<li><code>/text()</code> 获取的是标签中直系的文本内容</li>
<li><code>//text()</code> 标签中非直系的文本内容(所有的文本内容)</li>
</ul>
</li>
<li><p>属性定位：<code>tagName[@attr=&quot;属性名称&quot;]</code></p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找到class属性值为song的div标签</span></span><br><span class="line">//div[@class=&quot;song&quot;]</span><br></pre></td></tr></table></figure></li>
<li><p>层级&amp;索引定位:</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找到class属性值为tang的div的直系子标签ul下的第二个子标签li下的直系子标签a</span></span><br><span class="line">//div[@class=&quot;tang&quot;]/ul/li[2]/a</span><br></pre></td></tr></table></figure></li>
<li><p>逻辑运算：</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找到href属性值为空且class属性值为du的a标签</span></span><br><span class="line">//a[@href=&quot;&quot; and @class=&quot;du&quot;]</span><br></pre></td></tr></table></figure></li>
<li><p>模糊匹配：</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">//div[contains(@class, &quot;ng&quot;)]</span><br><span class="line">//div[starts-with(@class, &quot;ta&quot;)]</span><br></pre></td></tr></table></figure></li>
<li><p>取文本:</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /表示获取某个标签下的文本内容</span></span><br><span class="line"><span class="comment"># //表示获取某个标签下的文本内容和所有子标签下的文本内容</span></span><br><span class="line">//div[@class=&quot;song&quot;]/p[1]/text()</span><br><span class="line">//div[@class=&quot;tang&quot;]//text()</span><br></pre></td></tr></table></figure>
<ul>
<li>取属性：/@attrName     (前面这里是属性定位)/img/@src</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//div[@class=&quot;tang&quot;]//li[2]/a/@href</span><br></pre></td></tr></table></figure></li>
<li><p>如果发生乱码问题:</p>
<ul>
<li>第一种:可以手动设定响应数据的编码格式 <code>response.encoding = &#39;utf-8&#39;</code></li>
<li>第二种:通用处理中文乱码的解决方案(可能更有效？) <code>img_name = img_name.encode(&#39;iso-8859-1&#39;).decode(&#39;gbk&#39;)</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《深度学习》课程笔记2_改善深层神经网络</title>
    <url>/2020/11/16/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<div class="note danger">
            <p>这一章看的很吃力，等以后懂得多了也许就明白了吧…</p>
          </div>



<h1 id="改善深层神经网络：超参数调试、正则化以及优化"><a href="#改善深层神经网络：超参数调试、正则化以及优化" class="headerlink" title="改善深层神经网络：超参数调试、正则化以及优化"></a>改善深层神经网络：超参数调试、正则化以及优化</h1><h1 id="深度学习的实用层面"><a href="#深度学习的实用层面" class="headerlink" title="深度学习的实用层面"></a>深度学习的实用层面</h1><h2 id="数据划分：训练-验证-测试集"><a href="#数据划分：训练-验证-测试集" class="headerlink" title="数据划分：训练/验证/测试集"></a>数据划分：训练/验证/测试集</h2><p>应用深度学习是一个典型的迭代过程。</p>
<p>对于一个需要解决的问题的样本数据，在建立模型的过程中，数据会被划分为以下几个部分：</p>
<ul>
<li>训练集（train set）：用训练集对算法或模型进行<strong>训练</strong>过程；</li>
<li>验证集（development set）：利用验证集（又称为简单交叉验证集，hold-out cross validation set）进行<strong>交叉验证</strong>，<strong>选择出最好的模型</strong>；</li>
<li>测试集（test set）：最后利用测试集对模型进行测试，<strong>获取模型运行的无偏估计</strong>（对学习方法进行评估）。</li>
</ul>
<p>在<strong>小数据量</strong>的时代，如 100、1000、10000 的数据量大小，可以将数据集按照以下比例进行划分：</p>
<ul>
<li>无验证集的情况：70% / 30%；</li>
<li>有验证集的情况：60% / 20% / 20%；</li>
</ul>
<p>而在如今的<strong>大数据时代</strong>，对于一个问题，我们拥有的数据集的规模可能是百万级别的，所以验证集和测试集所占的比重会趋向于变得更小。</p>
<p>验证集的目的是为了验证不同的算法哪种更加有效，所以验证集只要足够大到能够验证大约 2-10 种算法哪种更好，而不需要使用 20% 的数据作为验证集。如百万数据中抽取 1 万的数据作为验证集就可以了。</p>
<p>测试集的主要目的是评估模型的效果，如在单个分类器中，往往在百万级别的数据中，我们选择其中 1000 条数据足以评估单个模型的效果。</p>
<ul>
<li>100 万数据量：98% / 1% / 1%；</li>
<li>超百万数据量：99.5% / 0.25% / 0.25%（或者99.5% / 0.4% / 0.1%）</li>
</ul>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>建议<strong>验证集要和训练集来自于同一个分布</strong>（数据来源一致），可以使得机器学习算法变得更快并获得更好的效果。</p>
<p>如果不需要用<strong>无偏估计</strong>来评估模型的性能，则可以不需要测试集。</p>
<h3 id="补充：1-交叉验证（cross-validation）"><a href="#补充：1-交叉验证（cross-validation）" class="headerlink" title="补充：1. 交叉验证（cross validation）"></a>补充：1. 交叉验证（cross validation）</h3><p>交叉验证的基本思想是重复地使用数据；把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。</p>
<h3 id="2-无偏估计"><a href="#2-无偏估计" class="headerlink" title="2. 无偏估计"></a>2. 无偏估计</h3><p>无偏估计是用样本统计量来估计总体参数时的一种无偏推断。估计量的数学期望等于被估计参数的真实值，则称此估计量为被估计参数的无偏估计，即具有无偏性，是一种用于评价估计量优良性的准则。无偏估计的意义是：在多次重复下，它们的平均数接近所估计的参数真值。无偏估计常被应用于测验分数统计中。</p>
<h2 id="模型估计：偏差-方差"><a href="#模型估计：偏差-方差" class="headerlink" title="模型估计：偏差/方差"></a>模型估计：偏差/方差</h2><p><strong>“偏差-方差分解”（bias-variance decomposition）</strong>是解释学习算法泛化性能的一种重要工具。</p>
<p>泛化误差可分解为偏差、方差与噪声之和：</p>
<ul>
<li><strong>偏差</strong>：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了<strong>学习算法本身的拟合能力</strong>；</li>
<li><strong>方差</strong>：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了<strong>数据扰动所造成的影响</strong>；</li>
<li><strong>噪声</strong>：表达了在当前任务上任何学习算法所能够达到的期望泛化误差的下界，即刻画了<strong>学习问题本身的难度</strong>。</li>
</ul>
<p>偏差-方差分解说明，<strong>泛化性能</strong>是由<strong>学习算法的能力</strong>、<strong>数据的充分性</strong>以及<strong>学习任务本身的难度</strong>所共同决定的。给定学习任务，为了取得好的泛化性能，则需要使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小。</p>
<p>在<strong>欠拟合（underfitting）</strong>的情况下，出现<strong>高偏差（high bias）</strong>的情况，即不能很好地对数据进行分类。</p>
<p>当模型设置的太复杂时，训练集中的一些噪声没有被排除，使得模型出现<strong>过拟合（overfitting）</strong>的情况，在验证集上出现<strong>高方差（high variance）</strong>的现象。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201116195537497.png" alt="image-20201116195537497"></p>
<p>当训练出一个模型以后，如果：</p>
<ul>
<li>训练集的错误率较小，而验证集的错误率却较大，说明模型存在较大方差，可能出现了过拟合；</li>
<li>训练集和开发集的错误率都较大，且两者相当，说明模型存在较大偏差，可能出现了欠拟合；</li>
<li>训练集错误率较大，且开发集的错误率远较训练集大，说明方差和偏差都较大，模型很差；</li>
<li>训练集和开发集的错误率都较小，且两者的相差也较小，说明方差和偏差都较小，这个模型效果比较好。</li>
</ul>
<p>偏差和方差的权衡问题对于模型来说十分重要。</p>
<p>最优误差通常也称为“贝叶斯误差”。</p>
<h3 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h3><p>存在高偏差：</p>
<ul>
<li>扩大网络规模，如添加隐藏层或隐藏单元数目；</li>
<li>寻找合适的网络架构，使用更大的 NN 结构；</li>
<li>花费更长时间训练。</li>
</ul>
<p>存在高方差：</p>
<ul>
<li>获取更多的数据；</li>
<li>正则化（regularization）；</li>
<li>寻找更合适的网络结构。</li>
</ul>
<p>不断尝试，直到找到低偏差、低方差的框架。</p>
<p>在深度学习的早期阶段，没有太多方法能做到只减少偏差或方差而不影响到另外一方。而在大数据时代，深度学习对监督式学习大有裨益，使得我们不用像以前一样太过关注如何平衡偏差和方差的权衡问题，通过以上方法可以在不增加某一方的前提下减少另一方的值。</p>
<h2 id="正则化（regularization）"><a href="#正则化（regularization）" class="headerlink" title="正则化（regularization）"></a>正则化（regularization）</h2><p><strong>正则化</strong>是在成本函数中加入一个正则化项，惩罚模型的复杂度。<strong>正则化可以用于解决高方差的问题。</strong></p>
<h3 id="Logistic-回归中的正则化"><a href="#Logistic-回归中的正则化" class="headerlink" title="Logistic 回归中的正则化"></a>Logistic 回归中的正则化</h3><p>对于 Logistic 回归，加入 L2 正则化（也称“L2 范数”）的成本函数：<br>$$<br>J(w,b) = \frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})+\frac{\lambda}{2m}{||w||}^2_2<br>$$</p>
<ul>
<li>L2 正则化：</li>
</ul>
<p>$$<br>\frac{\lambda}{2m}{||w||}^2_2 = \frac{\lambda}{2m}\sum_{j=1}^{n_x}w^2_j = \frac{\lambda}{2m}w^Tw<br>$$</p>
<ul>
<li>L1 正则化：</li>
</ul>
<p>$$<br>\frac{\lambda}{2m}{||w||}<em>1 = \frac{ \lambda }{2m}\sum</em>{j=1}^{n_x}{|w_j|}<br>$$</p>
<p>其中，λ 为<strong>正则化因子</strong>，是<strong>超参数</strong>。</p>
<p>由于 L1 正则化最后得到 w 向量中将存在大量的 0，会使模型变得稀疏化。</p>
<p>相比之下，L2 正则化更加常用。</p>
<p><strong>注意</strong>，<code>lambda</code>在 Python 中属于保留字，所以在编程的时候，用<code>lambd</code>代替这里的正则化因子。</p>
<blockquote>
<p>数学上，范数是一个向量空间或矩阵上所有向量的长度和大小的求和。</p>
<p>like：$||x||$ ,x可以是一个向量或者矩阵。</p>
<p>例如一个向量 $a = [3,-2,1]$，其欧几里得范数为：$ ||a||_2 = \sqrt{3^2+(-2)^2+1^2} $</p>
</blockquote>
<h3 id="神经网络中的正则化"><a href="#神经网络中的正则化" class="headerlink" title="神经网络中的正则化"></a>神经网络中的正则化</h3><p>对于神经网络，加入正则化的成本函数：<br>$$<br>J(w^{[1]}, b^{[1]}, …, w^{[L]}, b^{[L]}) = \frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})+\frac{\lambda}{2m}\sum_{l=1}^L{ {||w^{[l]}||} }^2_F<br>$$<br>因为 w 的大小为 ($n^{[l−1]}$, $n^{[l]}$)，因此<br>$$<br>{ {||w^{[l]}||} }^2_F = \sum^{n^{[l-1]} }<em>{i=1}\sum^{n^{[l]} }</em>{j=1}(w^{[l]}_{ij})^2<br>$$<br>该矩阵范数被称为<strong>弗罗贝尼乌斯范数（Frobenius Norm）</strong>，所以神经网络中的正则化项被称为弗罗贝尼乌斯范数矩阵。</p>
<h4 id="权重衰减（Weight-decay）"><a href="#权重衰减（Weight-decay）" class="headerlink" title="权重衰减（Weight decay）"></a>权重衰减（Weight decay）</h4><p><strong>在加入正则化项后，梯度变为</strong>（反向传播要按这个计算）：<br>$$<br>dW^{[l]}= \frac{\partial L}{\partial w^{[l]}} +\frac{\lambda}{m}W^{[l]}<br>$$<br>代入梯度更新公式：<br>$$<br>W^{[l]} := W^{[l]}-\alpha dW^{[l]}<br>$$<br>可得：<br>$$<br>W^{[l]} := W^{[l]} - \alpha [\frac{\partial L}{\partial w^{[l]}} + \frac{\lambda}{m}W^{[l]}]\<br>= W^{[l]} - \alpha \frac{\lambda}{m}W^{[l]} - \alpha \frac{\partial L}{\partial w^{[l]}}\<br>= (1 - \frac{\alpha\lambda}{m})W^{[l]} - \alpha \frac{\partial L}{\partial w^{[l]}}<br>$$<br>其中，因为 $1−\frac{αλ}{m}&lt;1$，会给原来的 $W^{[l]}$一个衰减的参数，因此 L2 正则化项也被称为<strong>权重衰减（Weight Decay）</strong>。</p>
<h3 id="正则化可以减小过拟合的原因"><a href="#正则化可以减小过拟合的原因" class="headerlink" title="正则化可以减小过拟合的原因"></a>正则化可以减小过拟合的原因</h3><h4 id="直观解释"><a href="#直观解释" class="headerlink" title="直观解释"></a>直观解释</h4><p>正则化因子设置的足够大的情况下，为了使成本函数最小化，权重矩阵 W 就会被设置为接近于 0 的值，<strong>直观上</strong>相当于消除了很多神经元的影响，那么大的神经网络就会变成一个较小的网络。当然，实际上隐藏层的神经元依然存在，但是其影响减弱了，便不会导致过拟合。</p>
<h4 id="数学解释"><a href="#数学解释" class="headerlink" title="数学解释"></a>数学解释</h4><p>假设神经元中使用的激活函数为<code>g(z) = tanh(z)</code>（sigmoid 同理）。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201117094946442.png" alt="image-20201117094946442"></p>
<p>在加入正则化项后，当 λ 增大，导致 $W^{[l]}$减小，$Z^{[l]}=W^{[l]}a^{[l−1]}+b^{[l]}$ 便会减小。由上图可知，在 z 较小（接近于 0）的区域里，<code>tanh(z)</code>函数近似线性，所以每层的函数就近似线性函数，整个网络就成为一个简单的近似线性的网络，因此不会发生过拟合。</p>
<h4 id="其他解释"><a href="#其他解释" class="headerlink" title="其他解释"></a>其他解释</h4><p>在权值 $w^{[L]}$变小之下，输入样本 X 随机的变化不会对神经网络模造成过大的影响，神经网络受局部噪音的影响的可能性变小。这就是正则化能够降低模型方差的原因。</p>
<h2 id="dropout-正则化"><a href="#dropout-正则化" class="headerlink" title="dropout 正则化"></a>dropout 正则化</h2><p><strong>dropout（随机失活）</strong>是在神经网络的隐藏层为每个神经元结点设置一个随机消除的概率，保留下来的神经元形成一个结点较少、规模较小的网络用于训练。dropout 正则化较多地被使用在<strong>计算机视觉（Computer Vision）</strong>领域。</p>
<h3 id="反向随机失活（Inverted-dropout）"><a href="#反向随机失活（Inverted-dropout）" class="headerlink" title="反向随机失活（Inverted dropout）"></a>反向随机失活（Inverted dropout）</h3><p>反向随机失活是实现 dropout 的方法。对第 <code>l</code> 层进行 dropout：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keep_prob = <span class="number">0.8</span>    <span class="comment"># 设置神经元保留概率</span></span><br><span class="line">dl = np.random.rand(al.shape[<span class="number">0</span>], al.shape[<span class="number">1</span>]) &lt; keep_prob</span><br><span class="line">al = np.multiply(al, dl)</span><br><span class="line">al /= keep_prob</span><br></pre></td></tr></table></figure>
<p>最后一步 <code>al /= keep_prob</code> 是因为 $a^{[l]}$中的一部分元素失活（相当于被归零），为了在下一层计算时不影响 $Z^{[l+1]}=W^{[l+1]}a^{[l]}+b^{[l+1]}$ 的期望值，因此除以一个 <code>keep_prob</code> 。</p>
<p><strong>注意</strong>，在<strong>测试阶段不要使用 dropout</strong>，因为那样会使得预测结果变得随机。</p>
<h3 id="理解-dropout"><a href="#理解-dropout" class="headerlink" title="理解 dropout"></a>理解 dropout</h3><p>对于单个神经元，其工作是接收输入并产生一些有意义的输出。但是加入了 dropout 后，输入的特征都存在被随机清除的可能，所以该神经元不会再特别依赖于任何一个输入特征，即不会给任何一个输入特征设置太大的权重。</p>
<p>因此，通过传播过程，dropout 将产生和 L2 正则化相同的<strong>收缩权重</strong>的效果。</p>
<p>对于不同的层，设置的 <code>keep_prob</code> 也不同。一般来说，神经元较少的层，会设 <code>keep_prob</code> 为 1.0，而神经元多的层则会设置比较小的 <code>keep_prob</code>。</p>
<p>dropout 的一大<strong>缺点</strong>是<u>成本函数无法被明确定义</u>。因为每次迭代都会随机消除一些神经元结点的影响，因此无法确保成本函数单调递减。因此，使用 dropout 时，先将 <code>keep_prob</code> 全部设置为 1.0 后运行代码，确保 $J(w,b)$ 函数单调递减，再打开 dropout。</p>
<h2 id="其他正则化方法"><a href="#其他正则化方法" class="headerlink" title="其他正则化方法"></a>其他正则化方法</h2><ul>
<li>数据扩增（Data Augmentation）：通过图片的一些变换（翻转，局部放大后切割等），得到更多的训练集和验证集。</li>
<li>早停止法（Early Stopping）：将训练集和验证集进行梯度下降时的成本变化曲线画在同一个坐标轴内，当训练集误差降低但验证集误差升高，两者开始发生较大偏差时及时停止迭代，并返回具有最小验证集误差的连接权和阈值，以避免过拟合。这种方法的优点是只运行一次梯度下降，就可以找到 w 的较小值，中间值和较大值，而无需尝试 $L2$ 正则化找 $\lambda$ 的很多值。缺点是无法同时达成偏差和方差的最优。</li>
</ul>
<h2 id="标准化输入"><a href="#标准化输入" class="headerlink" title="标准化输入"></a>标准化输入</h2><p>使用标准化处理输入 X 能够有效加速收敛。</p>
<h3 id="标准化公式"><a href="#标准化公式" class="headerlink" title="标准化公式"></a>标准化公式</h3><p>$$<br>x = \frac{x - \mu}{\sigma}<br>$$</p>
<p>其中，<br>$$<br>\mu = \frac{1}{m}\sum^m_{i=1}x^{(i)}<br>$$</p>
<p>$$<br>\sigma = \sqrt{\frac{1}{m}\sum^m_{i=1}x^{ {(i)}^2} }<br>$$</p>
<h3 id="使用标准化的原因"><a href="#使用标准化的原因" class="headerlink" title="使用标准化的原因"></a>使用标准化的原因</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201117142928488.png" alt="image-20201117142928488"></p>
<p>有图可知，使用标准化前后，成本函数的形状有较大差别。</p>
<p>在不使用标准化的成本函数中，如果设置一个较小的学习率，可能需要很多次迭代才能到达全局最优解；而如果使用了标准化，那么无论从哪个位置开始迭代，都能以相对较少的迭代次数找到全局最优解。</p>
<h2 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h2><p>在梯度函数上出现的以指数级递增或者递减的情况分别称为<strong>梯度爆炸</strong>或者<strong>梯度消失</strong>。</p>
<p>假定 $g(z)=z,b^{[l]}=0$，对于目标输出有：<br>$$<br>\hat{y} = W^{[L]}W^{[L-1]}…W^{[2]}W^{[1]}X<br>$$</p>
<ul>
<li>对于 $W^{[l]}$ 的值大于 1 的情况，激活函数的值将以指数级递增；</li>
<li>对于 $W^{[l]}$ 的值小于 1 的情况，激活函数的值将以指数级递减。</li>
</ul>
<p>对于导数同理。因此，在计算梯度时，根据不同情况梯度函数会以指数级递增或递减，导致训练导数难度上升，梯度下降算法的步长会变得非常小，需要训练的时间将会非常长。</p>
<h3 id="利用初始化缓解梯度消失和梯度爆炸"><a href="#利用初始化缓解梯度消失和梯度爆炸" class="headerlink" title="利用初始化缓解梯度消失和梯度爆炸"></a>利用初始化缓解梯度消失和梯度爆炸</h3><p>根据<br>$$<br>z={w}_1{x}_1+{w}_2{x}_2 + … + {w}_n{x}_n + b<br>$$<br>为了预防 z 值过大或过小，当输入的数量 n 较大时，我们希望每个 $w_i$ 的值都小一些，这样它们的和得到的 z 也较小。</p>
<p>为了得到较小的 $w_i$ ，设置 <code>Var(wi)=1/n</code>，这里称为 <strong>Xavier initialization</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WL = np.random.randn(WL.shape[<span class="number">0</span>], WL.shape[<span class="number">1</span>]) * np.sqrt(<span class="number">1</span>/n)</span><br></pre></td></tr></table></figure>
<p>其中 n 是输入的神经元个数，即 <code>WL.shape[1]</code>。</p>
<p>这样，激活函数的输入 x 近似设置成均值为 0，标准方差为 1，神经元输出 z 的方差就正则化到 1 了。虽然没有解决梯度消失和爆炸的问题，但其在一定程度上确实减缓了梯度消失和爆炸的速度。</p>
<p>同理，也有 <strong>He Initialization</strong>。它和 Xavier initialization 唯一的区别是<code>Var(wi)=2/n</code>，适用于 <strong>ReLU</strong> 作为激活函数时。</p>
<p>当激活函数使用 ReLU 时，<code>Var(wi)=2/n</code> ；当激活函数使用 tanh 时，<code>Var(wi)=1/n</code>。</p>
<h2 id="梯度检验（Gradient-checking）"><a href="#梯度检验（Gradient-checking）" class="headerlink" title="梯度检验（Gradient checking）"></a>梯度检验（Gradient checking）</h2><h3 id="梯度的数值逼近"><a href="#梯度的数值逼近" class="headerlink" title="梯度的数值逼近"></a>梯度的数值逼近</h3><p>使用双边误差的方法去逼近导数，精度要高于单边误差。</p>
<ul>
<li>单边误差：</li>
</ul>
<p>$$<br>f’(\theta) = {\lim_{\varepsilon\to 0}} = \frac{f(\theta + \varepsilon) - (\theta)}{\varepsilon}<br>$$</p>
<ul>
<li>双边误差求导：</li>
</ul>
<p>$$<br>f’(\theta) = {\lim_{\varepsilon\to 0}} = \frac{f(\theta + \varepsilon) - (\theta - \varepsilon)}{2\varepsilon}<br>$$</p>
<p>当 ε 越小时，结果越接近真实的导数，也就是梯度值。可以使用这种方法来判断反向传播进行梯度下降时，是否出现了错误。</p>
<h3 id="梯度检验的实施"><a href="#梯度检验的实施" class="headerlink" title="梯度检验的实施"></a>梯度检验的实施</h3><h4 id="连接参数"><a href="#连接参数" class="headerlink" title="连接参数"></a>连接参数</h4><p>将 $W^{[1]}$，$b^{[1]}$，…，$W^[L]$，$b^{[l]}$ 全部连接出来，成为一个巨型向量 θ。这样，<br>$$<br>J(W^{[1]}, b^{[1]}, …, W^{[L]}，b^{[L]}) = J(\theta)<br>$$<br>同时，对 $dW^{[1]}$，$db^{[1]}$，…，$dW^[L]$，$db^{[l]}$ 执行同样的操作得到巨型向量 dθ，它和 θ 有同样的维度。</p>
<p>现在，我们需要找到 dθ 和代价函数 J 的梯度的关系。</p>
<h4 id="进行梯度检验"><a href="#进行梯度检验" class="headerlink" title="进行梯度检验"></a>进行梯度检验</h4><p>现在的问题的是： $d\theta$ 和代价函数 $J$ 的梯度有什么关系？</p>
<p>答：<strong>grad check</strong> ，梯度检验。首先我们要清楚 $J$ 函数是超参数 $\theta$ 的一个函数，也可以将 $J$ 函数展开为 $J(\theta_1, \theta_2, \theta_3, …)$ ，不论超参数 $\theta$ 的维度是多少，为了实施梯度检验，要做的就是循环执行，从而对每个 $i$ 也就是对每个 $\theta$ 组成元素计算 的值，在这里使用双边误差。即：<br>$$<br>d\theta_{approx}[i] ＝ \frac{J(\theta_1, \theta_2, …, \theta_i+\varepsilon, …) - J(\theta_1, \theta_2, …, \theta_i-\varepsilon, …)}{2\varepsilon}<br>$$<br>正常情况下应该：<br>$$<br>d\theta_{approx}[i] \approx{d\theta[i]} = \frac{\partial J}{\partial \theta_i}<br>$$<br>那，如何验证这两个向量相互逼近呢？</p>
<p>答：欧几里得距离。然后用向量长度归一化，即使用向量长度的欧几里得范数来预防向量过大或过小。即用梯度检验值：<br>$$<br>\frac{ {||d\theta_{approx} - d\theta||}<em>{2} }{ {||d\theta</em>{approx}||}<em>2+{||d\theta||}</em>{2} }<br>$$<br>来检验反向传播的实施是否正确。</p>
<ol>
<li>这个值如果 $\approx 10^{-7}$ ，说明神经网络很好，神经网络的实施是正确的。倒数逼近很有可能是正确的。</li>
<li>这个值如果 $\approx 10^{-5}$ ，要小心，也许没问题，但是要再次检查，可能有bug。</li>
<li>这个值如果 $\approx 10^{-3}$ ，应该是有错，应该仔细检查所有 $\theta$ 项，看是否有一个具体的 $i$ 值，使得 $d\theta_{approx}$ 和 $d\theta[i]$ 大不相同，并用它来追踪一些求导计算是否正确，经过一些调试，最终结果会是这种非常小的值 $(10^{-7})$ 。</li>
</ol>
<p>其中，<br>$$<br>{||x||}<em>2 = \sum^N</em>{i=1}{|x_i|}^2<br>$$<br>表示向量 x 的 2-范数（也称“欧几里德范数”）。</p>
<p>​                                                                          </p>
<h3 id="在神经网络实施梯度检验的使用技巧和注意事项"><a href="#在神经网络实施梯度检验的使用技巧和注意事项" class="headerlink" title="在神经网络实施梯度检验的使用技巧和注意事项"></a>在神经网络实施梯度检验的使用技巧和注意事项</h3><ol>
<li>不要在训练中使用梯度检验，它只用于调试（debug）。使用完毕关闭梯度检验的功能；</li>
<li>如果算法的梯度检验失败，要检查所有项，并试着找出 bug，即确定哪个 dθapprox[i] 与 dθ 的值相差比较大；</li>
<li>当成本函数包含正则项时，也需要带上正则项进行检验；</li>
<li>梯度检验不能与 dropout 同时使用。因为每次迭代过程中，dropout 会随机消除隐藏层单元的不同子集，难以计算 dropout 在梯度下降上的成本函数 J。建议关闭 dropout，用梯度检验进行双重检查，确定在没有 dropout 的情况下算法正确，然后打开 dropout；</li>
</ol>
<h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><p>深度学习难以在大数据领域发挥最大效果的一个原因是，在巨大的数据集基础上进行训练速度很慢。而优化算法能够帮助快速训练模型，大大提高效率。</p>
<h2 id="batch-梯度下降法"><a href="#batch-梯度下降法" class="headerlink" title="batch 梯度下降法"></a>batch 梯度下降法</h2><p><strong>batch 梯度下降法</strong>（批梯度下降法，我们之前一直使用的梯度下降法）是最常用的梯度下降形式，即同时处理整个训练集。其在更新参数时使用所有的样本来进行更新。</p>
<p>对整个训练集进行梯度下降法的时候，我们必须处理整个训练数据集，然后才能进行一步梯度下降，即每一步梯度下降法需要对整个训练集进行一次处理，如果训练数据集很大的时候，处理速度就会比较慢。</p>
<p>但是如果每次处理训练数据的一部分即进行梯度下降法，则我们的算法速度会执行的更快。而处理的这些一小部分训练子集即称为 <strong>mini-batch</strong>。</p>
<h2 id="Mini-Batch-梯度下降法"><a href="#Mini-Batch-梯度下降法" class="headerlink" title="Mini-Batch 梯度下降法"></a>Mini-Batch 梯度下降法</h2><p><strong>Mini-Batch 梯度下降法</strong>（小批量梯度下降法）每次同时处理单个的 mini-batch，其他与 batch 梯度下降法一致。</p>
<p>使用 batch 梯度下降法，对整个训练集的一次遍历只能做一个梯度下降；而使用 Mini-Batch 梯度下降法，对整个训练集的一次遍历（称为一个 epoch）能做 mini-batch 个数个梯度下降。之后，可以一直遍历训练集，直到最后收敛到一个合适的精度。</p>
<p>batch 梯度下降法和 Mini-batch 梯度下降法代价函数的变化趋势如下：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201118140135287.png" alt="image-20201118140135287" style="zoom: 50%;" />





<h3 id="batch-的不同大小（size）带来的影响"><a href="#batch-的不同大小（size）带来的影响" class="headerlink" title="batch 的不同大小（size）带来的影响"></a>batch 的不同大小（size）带来的影响</h3><ul>
<li>mini-batch 的大小为 1，即是<strong>随机梯度下降法（stochastic gradient descent）</strong>，每个样本都是独立的 mini-batch；</li>
<li>mini-batch 的大小为 m（数据集大小），即是 batch 梯度下降法；</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201118142621742.png" alt="image-20201118142621742"></p>
<ul>
<li><p>batch 梯度下降法：</p>
<ul>
<li>对所有 m 个训练样本执行一次梯度下降，<strong>每一次迭代时间较长，训练过程慢</strong>；</li>
<li>相对噪声低一些，幅度也大一些；</li>
<li>成本函数总是向减小的方向下降。</li>
</ul>
</li>
<li><p>随机梯度下降法：</p>
<ul>
<li>对每一个训练样本执行一次梯度下降，训练速度快，但<strong>丢失了向量化带来的计算加速</strong>；</li>
<li>有很多噪声，减小学习率可以适当；</li>
<li>成本函数总体趋势向全局最小值靠近，但永远不会收敛，而是一直在最小值附近波动。</li>
</ul>
</li>
</ul>
<p>因此，选择一个 <code>1 &lt; size &lt; m</code> 的合适的大小进行 Mini-batch 梯度下降，可以实现快速学习，也应用了向量化带来的好处，且成本函数的下降处于前两者之间。</p>
<h3 id="mini-batch-大小的选择"><a href="#mini-batch-大小的选择" class="headerlink" title="mini-batch 大小的选择"></a>mini-batch 大小的选择</h3><ul>
<li>如果训练样本的大小比较小，如 m ⩽ 2000 时，选择 batch 梯度下降法；</li>
<li>如果训练样本的大小比较大，选择 Mini-Batch 梯度下降法。为了和计算机的信息存储方式相适应，代码在 mini-batch 大小为 2 的幂次时运行要快一些。典型的大小为 $2^6、2^7、…、2^9$；</li>
<li>mini-batch 的大小要符合 CPU/GPU 内存。</li>
</ul>
<p>mini-batch 的大小也是一个重要的超变量，需要根据经验快速尝试，找到能够最有效地减少成本函数的值。</p>
<h3 id="获得-mini-batch-的步骤"><a href="#获得-mini-batch-的步骤" class="headerlink" title="获得 mini-batch 的步骤"></a>获得 mini-batch 的步骤</h3><ol>
<li>将数据集打乱；</li>
<li>按照既定的大小分割数据集；</li>
</ol>
<p>其中打乱数据集的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = X.shape[<span class="number">1</span>] </span><br><span class="line">permutation = <span class="built_in">list</span>(np.random.permutation(m))</span><br><span class="line">shuffled_X = X[:, permutation]</span><br><span class="line">shuffled_Y = Y[:, permutation].reshape((<span class="number">1</span>,m))</span><br></pre></td></tr></table></figure>
<p><code>np.random.permutation</code>与<code>np.random.shuffle</code>有两处不同：</p>
<ol>
<li>如果传给<code>permutation</code>一个矩阵，它会返回一个洗牌后的矩阵副本；而<code>shuffle</code>只是对一个矩阵进行洗牌，没有返回值。</li>
<li>如果传入一个整数，它会返回一个洗牌后的<code>arange</code>。</li>
</ol>
<h3 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h3><ul>
<li>使用上角小括号 i 表示训练集里的值，$x^{(i)}$ 是第 i 个训练样本；</li>
<li>使用上角中括号 l 表示神经网络的层数，$z^{[l]}$ 表示神经网络中第 l 层的 z 值；</li>
<li>现在引入大括号 t 来代表不同的 mini-batch，因此有 $X_t$、$Y_t$。</li>
</ul>
<div class="note danger">
            <p>这一块开始看的很吃力，基本上没怎么看懂…以后有机回会来再看一次555</p>
          </div>



<h2 id="指数平均加权"><a href="#指数平均加权" class="headerlink" title="指数平均加权"></a>指数平均加权</h2><p><strong>指数加权平均（Exponentially Weight Average）</strong>是一种常用的序列数据处理方式，计算公式为：<br>$$<br>S_t =<br>\begin{cases}<br>Y_1, &amp;t = 1 \<br>\beta S_{t-1} + (1-\beta)Y_t, &amp;t &gt; 1<br>\end{cases}<br>$$<br>其中 $Y_t$ 为 t 下的实际值，$S_t$ 为 t 下加权平均后的值，β 为权重值。</p>
<p>指数加权平均数在统计学中被称为“指数加权移动平均值”。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201118152903889.png" alt="image-20201118152903889"></p>
<p>给定一个时间序列，例如伦敦一年每天的气温值，图中蓝色的点代表真实数据。对于一个即时的气温值，取权重值 β 为 0.9，根据求得的值可以得到图中的红色曲线，它反映了气温变化的大致趋势。</p>
<p>当取权重值 β=0.98 时，可以得到图中更为平滑的绿色曲线。而当取权重值 β=0.5 时，得到图中噪点更多的黄色曲线。<strong>β 越大相当于求取平均利用的天数越多</strong>，曲线自然就会越平滑而且越滞后。</p>
<h3 id="理解指数平均加权"><a href="#理解指数平均加权" class="headerlink" title="理解指数平均加权"></a>理解指数平均加权</h3><p>当 β 为 0.9 时，<br>$$<br>v_{100} = 0.9v_{99} + 0.1 \theta_{100}<br>$$</p>
<p>$$<br>v_{99} = 0.9v_{98} + 0.1 \theta_{99}<br>$$</p>
<p>$$<br>v_{98} = 0.9v_{97} + 0.1 \theta_{98}<br>$$</p>
<p>$$<br>…<br>$$</p>
<p>展开：<br>$$<br>v_{100} = 0.1 \theta_{100} + 0.1 * 0.9 \theta_{99} + 0.1 * {(0.9)}^2 \theta_{98} + …<br>$$<br>其中 θi 指第 i 天的实际数据。所有 θ 前面的系数（不包括 0.1）相加起来为 1 或者接近于 1，这些系数被称作<strong>偏差修正（Bias Correction）</strong>。</p>
<p>根据函数极限的一条定理：<br>$$<br>{\lim_{\beta\to 0}}(1 - \beta)^{\frac{1}{\beta}} = \frac{1}{e} \approx 0.368<br>$$<br>当 β 为 0.9 时，可以当作把过去 10 天的气温指数加权平均作为当日的气温，因为 10 天后权重已经下降到了当天的 1/3 左右。同理，当 β 为 0.98 时，可以把过去 50 天的气温指数加权平均作为当日的气温。</p>
<p>因此，在计算当前时刻的平均值时，只需要前一天的平均值和当前时刻的值。<br>$$<br>v_t = \beta v_{t-1} + (1 - \beta)\theta_t<br>$$<br>考虑到代码，只需要不断更新 v 即可：<br>$$<br>v := \beta v + (1 - \beta)\theta_t<br>$$<br>指数平均加权并<strong>不是最精准</strong>的计算平均数的方法，你可以直接计算过去 10 天或 50 天的平均值来得到更好的估计，但缺点是保存数据需要占用更多内存，执行更加复杂，计算成本更加高昂。</p>
<p>指数加权平均数公式的好处之一在于它只需要一行代码，且占用极少内存，因此<strong>效率极高，且节省成本</strong>。</p>
<h3 id="指数平均加权的偏差修正"><a href="#指数平均加权的偏差修正" class="headerlink" title="指数平均加权的偏差修正"></a>指数平均加权的偏差修正</h3><p>我们通常有<br>$$<br>v_0 = 0<br>$$</p>
<p>$$<br>v_1 = 0.98v_0 + 0.02\theta_1<br>$$</p>
<p>因此，$v_1$ 仅为第一个数据的 0.02（或者说 1- β），显然不准确。往后递推同理。</p>
<p>因此，我们修改公式为<br>$$<br>v_t = \frac{\beta v_{t-1} + (1 - \beta)\theta_t}NaN<br>$$<br>随着 t 的增大，β 的 t 次方趋近于 0。因此当 t 很大的时候，偏差修正几乎没有作用，但是在前期学习可以帮助更好的预测数据。在实际过程中，一般会忽略前期偏差的影响。</p>
<h2 id="动量梯度下降法"><a href="#动量梯度下降法" class="headerlink" title="动量梯度下降法"></a>动量梯度下降法</h2><p><strong>动量梯度下降（Gradient Descent with Momentum）</strong>是计算梯度的指数加权平均数，并利用该值来更新参数值。具体过程为：</p>
<p>for l = 1, .. , L：<br>$$<br>v_{dW^{[l]}} = \beta v_{dW^{[l]}} + (1 - \beta) dW^{[l]}<br>$$</p>
<p>$$<br>v_{db^{[l]}} = \beta v_{db^{[l]}} + (1 - \beta) db^{[l]}<br>$$</p>
<p>$$<br>W^{[l]} := W^{[l]} - \alpha v_{dW^{[l]}}<br>$$</p>
<p>$$<br>b^{[l]} := b^{[l]} - \alpha v_{db^{[l]}}<br>$$</p>
<p>其中，将动量衰减参数 β 设置为 0.9 是超参数的一个常见且效果不错的选择。当 β 被设置为 0 时，显然就成了 batch 梯度下降法。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201121105508543.png" alt="image-20201121105508543"></p>
<p>进行一般的梯度下降将会得到图中的蓝色曲线，由于存在上下波动，减缓了梯度下降的速度，因此只能使用一个较小的学习率进行迭代。如果用较大的学习率，结果可能会像紫色曲线一样偏离函数的范围。</p>
<p>而使用动量梯度下降时，通过累加过去的梯度值来减少抵达最小值路径上的波动，加速了收敛，因此在横轴方向下降得更快，从而得到图中红色的曲线。</p>
<p>当前后梯度方向一致时，动量梯度下降能够加速学习；而前后梯度方向不一致时，动量梯度下降能够抑制震荡。</p>
<p>另外，在 10 次迭代之后，移动平均已经不再是一个具有偏差的预测。因此实际在使用梯度下降法或者动量梯度下降法时，不会同时进行偏差修正。</p>
<h3 id="动量梯度下降法的形象解释"><a href="#动量梯度下降法的形象解释" class="headerlink" title="动量梯度下降法的形象解释"></a>动量梯度下降法的形象解释</h3><p>将成本函数想象为一个碗状，从顶部开始运动的小球向下滚，其中 $dw$，$db$ 想象成球的加速度；而 $v_{dw}$、$v_{db}$ 相当于速度。</p>
<p>小球在向下滚动的过程中，因为加速度的存在速度会变快，但是由于 β 的存在，其值小于 1，可以认为是摩擦力，所以球不会无限加速下去。</p>
<h2 id="RMSProp-算法"><a href="#RMSProp-算法" class="headerlink" title="RMSProp 算法"></a>RMSProp 算法</h2><p><strong>RMSProp（Root Mean Square Propagation，均方根传播）</strong>算法是在对梯度进行指数加权平均的基础上，引入平方和平方根。具体过程为（省略了 l）：<br>$$<br>s_{dw} = \beta s_{dw} + (1 - \beta)(dw)^2<br>$$</p>
<p>$$<br>s_{db} = \beta s_{db} + (1 - \beta)(db)^2<br>$$</p>
<p>$$<br>w := w - \alpha \frac{dw}{\sqrt{s_{dw} + \epsilon}}<br>$$</p>
<p>$$<br>b := b - \alpha \frac{db}{\sqrt{s_{db} + \epsilon}}<br>$$</p>
<p>其中，ϵ 是一个实际操作时加上的较小数（例如 $10^{-8}$），为了防止分母太小而导致的数值不稳定。</p>
<p>当 dw 或 db 较大时，$(dw)^2$、$(db)^2$ 会较大，进而 $s_{dw}$、$s_{db}$ 也会较大，最终使得<br>$$<br>\frac{dw}{\sqrt{s_{dw} + \epsilon}}<br>$$<br>和<br>$$<br>\frac{db}{\sqrt{s_{db} + \epsilon}}<br>$$<br>较小，从而减小某些维度梯度更新波动较大的情况，使下降速度变得更快。</p>
<p>RMSProp 有助于减少抵达最小值路径上的摆动，并允许使用一个更大的学习率 α，从而加快算法学习速度。并且，它和 Adam 优化算法已被证明适用于不同的深度学习网络结构。</p>
<p>注意，β 也是一个超参数</p>
<h2 id="Adam-优化算法"><a href="#Adam-优化算法" class="headerlink" title="Adam 优化算法"></a>Adam 优化算法</h2><p><strong>Adam 优化算法（Adaptive Moment Estimation，自适应矩估计）</strong>基本上就是将 Momentum 和 RMSProp 算法结合在一起，通常有超越二者单独时的效果。具体过程如下（省略了 l）：</p>
<p>首先进行初始化：<br>$$<br>v_{dW} = 0, s_{dW} = 0, v_{db} = 0, s_{db} = 0<br>$$<br>用每一个 mini-batch 计算 dW、db，第 t 次迭代时：<br>$$<br>v_{dW} = \beta_1 v_{dW} + (1 - \beta_1) dW<br>$$</p>
<p>$$<br>v_{db} = \beta_1 v_{db} + (1 - \beta_1) db<br>$$</p>
<p>$$<br>s_{dW} = \beta_2 s_{dW} + (1 - \beta_2) {(dW)}^2<br>$$</p>
<p>$$<br>s_{db} = \beta_2 s_{db} + (1 - \beta_2) {(db)}^2<br>$$</p>
<p>一般使用 Adam 算法时需要计算偏差修正：<br>$$<br>v^{corrected}<em>{dW} = \frac{v</em>{dW}}{1-{\beta_1}^t}<br>$$</p>
<p>$$<br>v^{corrected}<em>{db} = \frac{v</em>{db}}{1-{\beta_1}^t}<br>$$</p>
<p>$$<br>s^{corrected}<em>{dW} = \frac{s</em>{dW}}{1-{\beta_2}^t}<br>$$</p>
<p>$$<br>s^{corrected}<em>{db} = \frac{s</em>{db}}{1-{\beta_2}^t}<br>$$</p>
<p>所以，更新 W、b 时有：<br>$$<br>W := W - \alpha \frac{v^{corrected}<em>{dW}}{ {\sqrt{s^{corrected}</em>{dW}} + \epsilon} }<br>$$</p>
<p>$$<br>b := b - \alpha \frac{v^{corrected}<em>{db} }{ {\sqrt{s^{corrected}</em>{db} } + \epsilon} }<br>$$</p>
<p>（可以看到 Andrew 在这里 ϵ 没有写到平方根里去，和他在 RMSProp 中写的不太一样。考虑到 ϵ 所起的作用，影响不大）</p>
<h3 id="超参数的选择"><a href="#超参数的选择" class="headerlink" title="超参数的选择"></a>超参数的选择</h3><p>Adam 优化算法有很多的超参数，其中</p>
<ul>
<li>学习率 α：需要尝试一系列的值，来寻找比较合适的；</li>
<li>β1：常用的缺省值为 0.9；</li>
<li>β2：Adam 算法的作者建议为 0.999；</li>
<li>ϵ：不重要，不会影响算法表现，Adam 算法的作者建议为 $10^{−8}$；</li>
</ul>
<p>β1、β2、ϵ 通常不需要调试。</p>
<h2 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h2><p>如果设置一个固定的学习率 α，在最小值点附近，由于不同的 batch 中存在一定的噪声，因此不会精确收敛，而是始终在最小值周围一个较大的范围内波动。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201122100905548.png" alt="image-20201122100905548" style="zoom: 25%;" />

<p>而如果随着时间慢慢减少学习率 α 的大小，在初期 α 较大时，下降的步长较大，能以较快的速度进行梯度下降；而后期逐步减小 α 的值，即减小步长，有助于算法的收敛，更容易接近最优解。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/image-20201122101038303.png" alt="image-20201122101038303" style="zoom: 25%;" />

<p>最常用的学习率衰减方法：<br>$$<br>\alpha = \frac{1}{1 + decay_rate * epoch_num} * \alpha_0<br>$$<br>其中，<code>decay_rate</code> 为衰减率（超参数），<code>epoch_num</code> 为将所有的训练样本完整过一遍的次数。</p>
<ul>
<li>指数衰减：</li>
</ul>
<p>$$<br>\alpha = 0.95^{epoch_num} * \alpha_0<br>$$</p>
<ul>
<li>其他：</li>
</ul>
<p>$$<br>\alpha = \frac{k}{\sqrt{epoch_num}} * \alpha_0<br>$$</p>
<ul>
<li><p>离散下降</p>
<p>对于较小的模型，也有人会在训练时根据进度手动调小学习率。</p>
</li>
</ul>
<h2 id="局部最优问题"><a href="#局部最优问题" class="headerlink" title="局部最优问题"></a>局部最优问题</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201122103336971.png" alt="image-20201122103336971"></p>
<p><strong>鞍点（saddle）</strong>是函数上的导数为零，但不是轴上局部极值的点。当我们建立一个神经网络时，通常梯度为零的点是上图所示的鞍点，而非局部最小值。减少损失的难度也来自误差曲面中的鞍点，而不是局部最低点。因为在一个具有高维度空间的成本函数中，如果梯度为 0，那么在每个方向，成本函数或是凸函数，或是凹函数。而所有维度均需要是凹函数的概率是极小的，因此在低维度的局部最优点的情况并不适用于高维度。</p>
<p>结论：</p>
<ul>
<li>在训练较大的神经网络、存在大量参数，并且成本函数被定义在较高的维度空间时，困在极差的局部最优中是不大可能的；</li>
<li>鞍点附近的平稳段会使得学习非常缓慢，而这也是动量梯度下降法、RMSProp 以及 Adam 优化算法能够加速学习的原因，它们能帮助尽早走出平稳段。</li>
</ul>
<h1 id="超参数调试、Batch-正则化和程序框架"><a href="#超参数调试、Batch-正则化和程序框架" class="headerlink" title="超参数调试、Batch 正则化和程序框架"></a>超参数调试、Batch 正则化和程序框架</h1><h2 id="超参数调试处理"><a href="#超参数调试处理" class="headerlink" title="超参数调试处理"></a>超参数调试处理</h2><h3 id="重要程度排序"><a href="#重要程度排序" class="headerlink" title="重要程度排序"></a>重要程度排序</h3><p>目前已经讲到过的超参数中，重要程度依次是（仅供参考）：</p>
<ul>
<li><strong>最重要</strong>：<ul>
<li>学习率 α；</li>
</ul>
</li>
<li><strong>其次重要</strong>：<ul>
<li>β：动量衰减参数，常设置为 0.9；</li>
<li>#hidden units：各隐藏层神经元个数；</li>
<li>mini-batch 的大小；</li>
</ul>
</li>
<li><strong>再次重要</strong>：<ul>
<li>β1，β2，ϵ：Adam 优化算法的超参数，常设为 0.9、0.999、$10^{−8}$；</li>
<li>#layers：神经网络层数;</li>
<li>decay_rate：学习衰减率；</li>
</ul>
</li>
</ul>
<h3 id="调参技巧"><a href="#调参技巧" class="headerlink" title="调参技巧"></a>调参技巧</h3><p>系统地组织超参调试过程的技巧：</p>
<ul>
<li><strong>随机选择</strong>点（而非均匀选取），用这些点实验超参数的效果。这样做的原因是我们提前很难知道超参数的重要程度，可以通过选择更多值来进行更多实验；</li>
<li>由粗糙到精细：聚焦效果不错的点组成的小区域，在其中更密集地取值，以此类推；</li>
</ul>
<h3 id="选择合适的范围-不懂"><a href="#选择合适的范围-不懂" class="headerlink" title="选择合适的范围(不懂==)"></a>选择合适的范围(不懂==)</h3><ul>
<li>对于学习率 α，用<strong>对数标尺</strong>而非线性轴更加合理：0.0001、0.001、0.01、0.1 等，然后在这些刻度之间再随机均匀取值；</li>
<li>对于 β，取 0.9 就相当于在 10 个值中计算平均值，而取 0.999 就相当于在 1000 个值中计算平均值。可以考虑给 1-β 取值，这样就和取学习率类似了。</li>
</ul>
<p>上述操作的原因是当 β 接近 1 时，即使 β 只有微小的改变，所得结果的灵敏度会有较大的变化。例如，β 从 0.9 增加到 0.9005 对结果（1/(1-β)）几乎没有影响，而 β 从 0.999 到 0.9995 对结果的影响巨大（从 1000 个值中计算平均值变为 2000 个值中计算平均值）。</p>
<h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h3><ul>
<li>深度学习如今已经应用到许多不同的领域。不同的应用出现相互交融的现象，某个应用领域的超参数设定有可能通用于另一领域。不同应用领域的人也应该更多地阅读其他研究领域的 paper，跨领域地寻找灵感；</li>
<li>考虑到数据的变化或者服务器的变更等因素，建议每隔几个月至少一次，重新测试或评估超参数，来获得实时的最佳模型；</li>
<li>根据你所拥有的计算资源来决定你训练模型的方式：<ul>
<li>Panda（熊猫方式）：在在线广告设置或者在计算机视觉应用领域有大量的数据，但受计算能力所限，同时试验大量模型比较困难。可以采用这种方式：试验一个或一小批模型，初始化，试着让其工作运转，观察它的表现，不断调整参数；</li>
<li>Caviar（鱼子酱方式）：拥有足够的计算机去平行试验很多模型，尝试很多不同的超参数，选取效果最好的模型；</li>
</ul>
</li>
</ul>
<h2 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h2><p><strong>批标准化（Batch Normalization，经常简称为 BN）</strong>会使参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，超参数的范围会更庞大，工作效果也很好，也会使训练更容易。</p>
<p>之前，我们对输入特征 X 使用了标准化处理。我们也可以用同样的思路处理<strong>隐藏层</strong>的激活值 $a^{[l]}$，以加速 $W^{[l+1]}$和 $b^{[l+1]}$的训练。在<strong>实践</strong>中，经常选择标准化 $Z^{[l]}$：<br>$$<br>\mu = \frac{1}{m} \sum_i z^{(i)}<br>$$</p>
<p>$$<br>\sigma^2 = \frac{1}{m} \sum_i {(z_i - \mu)}^2<br>$$</p>
<p>$$<br>z_{norm}^{(i)} = \frac{z^{(i)} - \mu}{\sqrt{\sigma^2 + \epsilon}}<br>$$</p>
<p>其中，m 是单个 mini-batch 所包含的样本个数，ϵ 是为了防止分母为零，通常取 $10^{−8}$。</p>
<p>这样，我们使得所有的输入 $z^{(i)}$值为 0，方差为 1。但我们不想让隐藏层单元总是含有平均值 0 和方差 1，也许隐藏层单元有了不同的分布会更有意义。因此，我们计算<br>$$<br>\tilde z^{(i)} = \gamma z^{(i)}_{norm} + \beta<br>$$<br>其中，γ 和 β 都是模型的学习参数，所以可以用各种梯度下降算法来更新 γ 和 β 的值，如同更新神经网络的权重一样。</p>
<p>通过对 γ 和 β 的合理设置，可以让 z<del>(i)z</del>(i)的均值和方差为任意值。这样，我们对隐藏层的 z(i)z(i)进行标准化处理，用得到的 z<del>(i)z</del>(i)替代 z(i)z(i)。</p>
<p><strong>设置 γ 和 β 的原因</strong>是，如果各隐藏层的输入均值在靠近 0 的区域，即处于激活函数的线性区域，不利于训练非线性神经网络，从而得到效果较差的模型。因此，需要用 γ 和 β 对标准化后的结果做进一步处理。</p>
<h3 id="将-BN-应用于神经网络"><a href="#将-BN-应用于神经网络" class="headerlink" title="将 BN 应用于神经网络"></a>将 BN 应用于神经网络</h3><p>对于 L 层神经网络，经过 Batch Normalization 的作用，整体流程如下：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201123134528833.png" alt="image-20201123134528833"></p>
<p>实际上，Batch Normalization 经常使用在 mini-batch 上，这也是其名称的由来。</p>
<p>使用 Batch Normalization 时，因为标准化处理中包含减去均值的一步，因此 b 实际上没有起到作用，其数值效果交由 β 来实现。因此，在 Batch Normalization 中，可以省略 b 或者暂时设置为 0。</p>
<p>在使用梯度下降算法时，分别对 $W^{[l]}$，$β^{[l]}$和 $γ^{[l]}$进行迭代更新。除了传统的梯度下降算法之外，还可以使用之前学过的动量梯度下降、RMSProp 或者 Adam 等优化算法。</p>
<h3 id="BN-有效的原因"><a href="#BN-有效的原因" class="headerlink" title="BN 有效的原因"></a>BN 有效的原因</h3><p>Batch Normalization 效果很好的原因有以下两点：</p>
<ol>
<li>通过对隐藏层各神经元的输入做类似的标准化处理，提高神经网络训练速度；</li>
<li>可以使前面层的权重变化对后面层造成的影响减小，整体网络更加健壮。</li>
</ol>
<p>关于第二点，如果实际应用样本和训练样本的数据分布不同（例如，橘猫图片和黑猫图片），我们称发生了“<strong>Covariate Shift</strong>”。这种情况下，一般要对模型进行重新训练。Batch Normalization 的作用就是减小 Covariate Shift 所带来的影响，让模型变得更加健壮，鲁棒性（Robustness）更强。</p>
<p>即使输入的值改变了，由于 Batch Normalization 的作用，使得均值和方差保持不变（由 γ 和 β 决定），限制了在前层的参数更新对数值分布的影响程度，因此后层的学习变得更容易一些。Batch Normalization 减少了各层 W 和 b 之间的耦合性，让各层更加独立，实现自我训练学习的效果。</p>
<p>另外，Batch Normalization 也<strong>起到微弱的正则化</strong>（regularization）效果。因为在每个 mini-batch 而非整个数据集上计算均值和方差，只由这一小部分数据估计得出的均值和方差会有一些噪声，因此最终计算出的 $\tilde z^{(i)}$ 也有一定噪声。类似于 dropout，这种噪声会使得神经元不会再特别依赖于任何一个输入特征。</p>
<p>因为 Batch Normalization 只有微弱的正则化效果，因此可以和 dropout 一起使用，以获得更强大的正则化效果。通过应用更大的 mini-batch 大小，可以减少噪声，从而减少这种正则化效果。</p>
<p>最后，不要将 Batch Normalization 作为正则化的手段，而是当作加速学习的方式。正则化只是一种非期望的副作用，Batch Normalization 解决的还是反向传播过程中的梯度问题（梯度消失和爆炸）。</p>
<h3 id="测试时的-Batch-Normalization"><a href="#测试时的-Batch-Normalization" class="headerlink" title="测试时的 Batch Normalization"></a>测试时的 Batch Normalization</h3><p>Batch Normalization 将数据以 mini-batch 的形式逐一处理，但在测试时，可能需要对每一个样本逐一处理，这样无法得到 μ 和 $σ^2$ 。</p>
<p>理论上，我们可以将所有训练集放入最终的神经网络模型中，然后将每个隐藏层计算得到的 $μ^{[l]}$和 $σ^{2[l]}$直接作为测试过程的 μ 和 σ 来使用。但是，实际应用中一般不使用这种方法，而是使用之前学习过的指数加权平均的方法来预测测试过程单个样本的 μ 和 $σ^2$ 。</p>
<p>对于第 l 层隐藏层，考虑所有 mini-batch 在该隐藏层下的 $μ^{[l]}$ 和 $σ^{2[l]}$，然后用指数加权平均的方式来预测得到当前单个样本的 $μ^{[l]}$ 和 $σ^{2[l]}$。这样就实现了对测试过程单个样本的均值和方差估计。</p>
<h2 id="Softmax-回归"><a href="#Softmax-回归" class="headerlink" title="Softmax 回归"></a>Softmax 回归</h2><p>目前为止，介绍的分类例子都是二分类问题：神经网络输出层只有一个神经元，表示预测输出 $\hat y$ 是正类的概率 P(y = 1|x)， $\hat y$ &gt; 0.5 则判断为正类，反之判断为负类。</p>
<p>对于<strong>多分类问题</strong>，用 C 表示种类个数，则神经网络输出层，也就是第 L 层的单元数量 $n^{[L]}=C$ 。每个神经元的输出依次对应属于该类的概率，即 $P(y=c|x),c=0,1,..,C−1$ 。有一种 Logistic 回归的一般形式，叫做 <strong>Softmax 回归</strong>，可以处理多分类问题。</p>
<p>对于 Softmax 回归模型的输出层，即第 L 层，有：<br>$$<br>Z^{[L]} = W^{[L]}a^{[L-1]} + b^{[L]}<br>$$<br>for i in range(L)，有：<br>$$<br>a^{[L]}_i = \frac{e^{Z^{[L]}<em>i}}{\sum^C</em>{i=1}e^{Z^{[L]}<em>i}}<br>$$<br>为输出层每个神经元的输出，对应属于该类的概率，满足：<br>$$<br>\sum^C</em>{i=1}a^{[L]}_i = 1<br>$$<br>一个直观的计算例子如下：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/image-20201123104538968.png" alt="image-20201123104538968"></p>
<h3 id="损失函数和成本函数"><a href="#损失函数和成本函数" class="headerlink" title="损失函数和成本函数"></a>损失函数和成本函数</h3><p>定义<strong>损失函数</strong>为：<br>$$<br>L(\hat y, y) = -\sum^C_{j=1}y_jlog\hat y_j<br>$$<br>当 i 为样本真实类别，则有：<br>$$<br>y_j = 0, j \ne i<br>$$<br>因此，损失函数可以简化为：<br>$$<br>L(\hat y, y) = -y_ilog\hat y_i = log \hat y_i<br>$$<br>所有 m 个样本的<strong>成本函数</strong>为：<br>$$<br>J = \frac{1}{m}\sum^m_{i=1}L(\hat y, y)<br>$$</p>
<h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>多分类的 Softmax 回归模型与二分类的 Logistic 回归模型只有输出层上有一点区别。经过不太一样的推导过程，仍有<br>$$<br>dZ^{[L]} = A^{[L]} - Y<br>$$<br>反向传播过程的其他步骤也和 Logistic 回归的一致。</p>
<h2 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h2><h3 id="比较著名的框架"><a href="#比较著名的框架" class="headerlink" title="比较著名的框架"></a>比较著名的框架</h3><ul>
<li>Caffe / Caffe 2</li>
<li>CNTK</li>
<li>DL4J</li>
<li>Keras</li>
<li>Lasagne</li>
<li>mxnet</li>
<li>PaddlePaddle</li>
<li>TensorFlow</li>
<li>Theano</li>
<li>Torch</li>
</ul>
<h3 id="选择框架的标准"><a href="#选择框架的标准" class="headerlink" title="选择框架的标准"></a>选择框架的标准</h3><ul>
<li>便于编程：包括神经网络的开发和迭代、配置产品；</li>
<li>运行速度：特别是训练大型数据集时；</li>
<li>是否真正开放：不仅需要开源，而且需要良好的管理，能够持续开放所有功能。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Django基础----模型层</title>
    <url>/2020/10/28/Django%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="0-Django介绍"><a href="#0-Django介绍" class="headerlink" title="0. Django介绍"></a>0. Django介绍</h1><p>Django是基于Python的Web开发框架。Web开发指的是开发基于B/S架构，通过前后端的配合，将后台服务器的数据在浏览器上展现给前台用户的应用。</p>
<p>一般Web框架的架构是这样的：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/image-20201029080219087.png" alt="image-20201029080219087"></p>
<p>大多数基于Python的web框架，如Django、Tornado、Flask、Webpy都是在这个范围内进行增删裁剪。例如Tornado用的是自己的异步非阻塞“WSGI”网关接口，Flask则只提供了最精简和基本的框架，Django则是直接使用了现成的WSGI，并实现了大部分功能，提供了大量的应用工具。</p>
<p>MVC及MTV设计模式：</p>
<ul>
<li><p>MVC设计模式</p>
<p><code>MVC</code>把Web框架分为三个基础部分：</p>
<ul>
<li><p>**模型(Model)**：用于封装与应用程序的业务逻辑相关的数据及对数据的处理方法，是Web应用程序中用于处理应用程序的数据逻辑的部分，Model只提供功能性的接口，通过这些接口可以获取Model的所有功能。白话说，这个模块就是业务逻辑和数据库的交互层，定义了数据表。</p>
</li>
<li><p>**视图(View)**：负责数据的显示和呈现，是对用户的直接输出。</p>
</li>
<li><p>**控制器(Controller)**：负责从用户端收集用户的输入，可以看成提供View的反向功能。</p>
</li>
</ul>
<p>这三个部分互相独立，但又相互联系，使得改进和升级界面及用户交互流程，在Web开发过程任务分配时，不需要重写业务逻辑及数据访问代码。</p>
<p>MVC在Python之外的语言中也有广泛应用，例如VC++的MFC，Java的Structs及Spring、C#的.NET开发框架，都非常有名。</p>
</li>
<li><p>MTV设计模式：</p>
<p>MTV和MVC本质上是一样的。</p>
<p>Django对传统的MVC设计模式进行了修改，将视图分成View模块和Template模块两部分，将动态的逻辑处理与静态的页面展示分离开。而<u>Model采用了ORM技术，将关系型数据库表抽象成面向对象的Python类，将数据库的表操作转换成Python的类操作，避免了编写复杂的SQL语句。</u></p>
<ul>
<li><p>**模型(Model)**：和MVC中的定义一样</p>
</li>
<li><p>**模板(Template)**：将模型数据与HTML页面结合起来的引擎</p>
</li>
<li><p>**视图(View)**：负责实际的业务逻辑实现</p>
</li>
</ul>
<p>Django的MTV模型组织可参考下图所示：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Django/image-20201029083915147.png" alt="image-20201029083915147"></p>
</li>
</ul>
<h1 id="1-模型层"><a href="#1-模型层" class="headerlink" title="1. 模型层"></a>1. 模型层</h1><h2 id="1-1-模型和字段"><a href="#1-1-模型和字段" class="headerlink" title="1.1 模型和字段"></a>1.1 模型和字段</h2><p>一个模型（model）就是一个单独的、确定的数据的信息源，包含了数据的字段和操作方法。通常，每个模型映射为一张数据库中的表。</p>
<p>基本的原则如下：</p>
<ul>
<li>每个模型在Django中的存在形式为一个Python类</li>
<li>每个类都是<code>django.db.models.Model</code>的子类</li>
<li>模型（类）的每个字段（属性）代表数据表的某一列</li>
<li>Django自动为你生成访问数据库的API</li>
</ul>
<p>举个栗子：</p>
<p>下面的模型定义了一个“人”，它具有<code>first_name</code>和<code>last_name</code>字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>每一个字段都是一个类属性，每个类属性表示数据表中的一个列。</p>
<p>上面的代码，相当于下面的原生SQL语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myapp_person (</span><br><span class="line">    <span class="string">&quot;id&quot;</span> serial NOT NULL PRIMARY KEY,</span><br><span class="line">    <span class="string">&quot;first_name&quot;</span> varchar(<span class="number">30</span>) NOT NULL,</span><br><span class="line">    <span class="string">&quot;last_name&quot;</span> varchar(<span class="number">30</span>) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>表名<code>myapp_person</code>由Django自动生成，默认格式为“<code>项目名称+下划线+小写类名</code>”，你可以重写这个规则。</li>
<li>Django会自动创建自增主键<code>id</code>，当然，你也可以自己指定主键。</li>
<li>上面的SQL语句基于<code>PostgreSQL</code>语法。</li>
</ul>
<p>通常，我们会将模型编写在其所属app下的models.py文件中，没有特别需求时，请坚持这个原则，不要自己给自己添加麻烦。</p>
<p>创建了模型之后，在使用它之前，需要先在settings文件中的<code>INSTALLED_APPS</code> 处，注册<code>models.py</code>文件所在的<code>myapp</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    #...</span><br><span class="line">    &#39;myapp&#39;,</span><br><span class="line">    #...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>每次对模型进行增、删、修改时，先执行<code>python manage.py makemigrations</code>让修改动作保存到记录文件中，再执行命令<code>python manage.py migrate</code>，让操作实际应用到数据库上。</strong></p>
<h2 id="模型方法"><a href="#模型方法" class="headerlink" title="模型方法"></a>模型方法</h2><p>模型的方法其实就是Python的实例方法。Django内置了一些，我们也可以自定义一些。</p>
<ul>
<li><code>__str__()</code>： 这个其实是Python的魔法方法，用于返回实例对象的打印字符串。为了让显示的内容更直观更易懂，我们往往自定义这个方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    birth_date = models.DateField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.first_name + self.last_name</span><br></pre></td></tr></table></figure>
<ul>
<li><code>get_absolute_url()</code>: 这个方法是返回每个模型实例的相应的访问url。</li>
<li>…</li>
</ul>
<h2 id="模型字段fields"><a href="#模型字段fields" class="headerlink" title="模型字段fields"></a>模型字段fields</h2><p>Django内置了许多字段类型，它们都位于<code>django.db.models</code>中，例如<code>models.CharField</code>，它们的父类都是Field类。这些类型基本满足需求，如果还不够，也可以自定义字段。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AutoField</td>
<td>一个自动增加的整数类型字段。通常你不需要自己编写它，Django会自动帮你添加字段：<code>id = models.AutoField(primary_key=True)</code>，这是一个自增字段，从1开始计数。如果你非要自己设置主键，那么请务必将字段设置为<code>primary_key=True</code>。Django在一个模型中只允许有一个自增字段，并且该字段必须为主键！</td>
</tr>
<tr>
<td>BigAutoField</td>
<td>64位整数类型自增字段，数字范围更大，从1到9223372036854775807</td>
</tr>
<tr>
<td>BigIntegerField</td>
<td>64位整数字段（看清楚，非自增），类似IntegerField ，-9223372036854775808 到9223372036854775807。在Django的模板表单里体现为一个<code>NumberInput</code>标签。</td>
</tr>
<tr>
<td><strong>BooleanField</strong></td>
<td>布尔值类型。默认值是None。在HTML表单中体现为CheckboxInput标签。如果设置了参数null=True，则表现为NullBooleanSelect选择框。可以提供default参数值，设置默认值。</td>
</tr>
<tr>
<td><strong>CharField</strong></td>
<td>最常用的类型，字符串类型。必须接收一个max_length参数，表示字符串长度不能超过该值。默认的表单标签是text input。</td>
</tr>
<tr>
<td><strong>DateField</strong></td>
<td><code>class DateField(auto_now=False, auto_now_add=False, **options)</code> , 日期类型。一个Python中的datetime.date的实例。在HTML中表现为DateInput标签。在admin后台中，Django会帮你自动添加一个JS日历表和一个“Today”快捷方式，以及附加的日期合法性验证。两个重要参数：（参数互斥，不能共存） <code>auto_now</code>:每当对象被保存时将字段设为当前日期，常用于保存最后修改时间。<code>auto_now_add</code>：每当对象被创建时，设为当前日期，常用于保存创建日期(注意，它是不可修改的)。设置上面两个参数就相当于给field添加了<code>editable=False</code>和<code>blank=True</code>属性。如果想具有修改属性，请用default参数。例子：<code>pub_time = models.DateField(auto_now_add=True)</code>，自动添加发布时间。</td>
</tr>
<tr>
<td>DateTimeField</td>
<td>日期时间类型。Python的datetime.datetime的实例。与DateField相比就是多了小时、分和秒的显示，其它功能、参数、用法、默认值等等都一样。</td>
</tr>
<tr>
<td>DecimalField</td>
<td>固定精度的十进制小数。相当于Python的Decimal实例，必须提供两个指定的参数！参数<code>max_digits</code>：最大的位数，必须大于或等于小数点位数 。<code>decimal_places</code>：小数点位数，精度。 当<code>localize=False</code>时，它在HTML表现为NumberInput标签，否则是textInput类型。例子：储存最大不超过999，带有2位小数位精度的数，定义如下：<code>models.DecimalField(..., max_digits=5, decimal_places=2)</code>。</td>
</tr>
<tr>
<td><strong>EmailField</strong></td>
<td>邮箱类型，默认max_length最大长度254位。使用这个字段的好处是，可以使用Django内置的EmailValidator进行邮箱格式合法性验证。</td>
</tr>
<tr>
<td><strong>FileField</strong></td>
<td><code>class FileField(upload_to=None, max_length=100, **options)</code>上传文件类型，后面单独介绍。</td>
</tr>
<tr>
<td>FilePathField</td>
<td>文件路径类型，后面单独介绍</td>
</tr>
<tr>
<td>FloatField</td>
<td>浮点数类型，对应Python的float。参考整数类型字段。</td>
</tr>
<tr>
<td><strong>ImageField</strong></td>
<td>图像类型，后面单独介绍。</td>
</tr>
<tr>
<td><strong>IntegerField</strong></td>
<td>整数类型，最常用的字段之一。取值范围-2147483648到2147483647。在HTML中表现为NumberInput或者TextInput标签。</td>
</tr>
<tr>
<td><strong>GenericIPAddressField</strong></td>
<td><code>class GenericIPAddressField(protocol=&#39;both&#39;, unpack_ipv4=False, **options)</code>,IPV4或者IPV6地址，字符串形式，例如<code>192.0.2.30</code>或者<code>2a02:42fe::4</code>。在HTML中表现为TextInput标签。参数<code>protocol</code>默认值为‘both’，可选‘IPv4’或者‘IPv6’，表示你的IP地址类型。</td>
</tr>
<tr>
<td>JSONField</td>
<td>JSON类型字段。Django3.1新增。签名为<code>class JSONField(encoder=None,decoder=None,**options)</code>。其中的encoder和decoder为可选的编码器和解码器，用于自定义编码和解码方式。如果为该字段提供default值，请务必保证该值是个不可变的对象，比如字符串对象。</td>
</tr>
<tr>
<td><strong>TextField</strong></td>
<td>用于储存大量的文本内容，在HTML中表现为Textarea标签，最常用的字段类型之一！如果你为它设置一个max_length参数，那么在前端页面中会受到输入字符数量限制，然而在模型和数据库层面却不受影响。只有CharField才能同时作用于两者。</td>
</tr>
<tr>
<td>TimeField</td>
<td>时间字段，Python中datetime.time的实例。接收同DateField一样的参数，只作用于小时、分和秒。</td>
</tr>
<tr>
<td><strong>URLField</strong></td>
<td>一个用于保存URL地址的字符串类型，默认最大长度200。</td>
</tr>
<tr>
<td><strong>UUIDField</strong></td>
<td>用于保存通用唯一识别码（Universally Unique Identifier）的字段。使用Python的UUID类。在PostgreSQL数据库中保存为uuid类型，其它数据库中为char(32)。这个字段是自增主键的最佳替代品。</td>
</tr>
</tbody></table>
<h2 id="1-2-关系类型字段"><a href="#1-2-关系类型字段" class="headerlink" title="1.2 关系类型字段"></a>1.2 关系类型字段</h2><p>除了普通类型字段，Django还定义了一组关系类型字段，用来表示模型与模型之间的关系。</p>
<h3 id="1-2-1-多对一（ForeignKey）"><a href="#1-2-1-多对一（ForeignKey）" class="headerlink" title="1.2.1 多对一（ForeignKey）"></a>1.2.1 多对一（ForeignKey）</h3><p>多对一的关系，通常被称为外键。外键字段类的定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForeignKey</span>(<span class="params">to, on_delete, **options</span>)</span></span><br></pre></td></tr></table></figure>
<p>外键需要两个位置参数，一个是关联的模型，另一个是<code>on_delete</code>。</p>
<p><strong>外键要定义在‘多’的一方！</strong></p>
<p>举栗：</p>
<p>每辆车都会有一个生产工厂，一个工厂可以生产N辆车，于是用一个外键字段manufacturer表示，并放在Car模型中。注意，此manufacturer非彼Manufacturer模型类，它是一个字段的名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manufacturer</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>在实际的数据库后台，Django会为每一个外键添加<code>_id</code>后缀，并以此创建数据表里的一列。在上面的工厂与车的例子中，Car模型对应的数据表中，会有一列叫做<code>manufacturer_id</code>。但实际上，在Django代码中你不需要使用这个列名，除非你书写原生的SQL语句，一般我们都直接使用字段名<code>manufacturer</code>。</p>
<p>多对一字段的变量名一般设置为关联的模型的小写单数，而多对多则一般设置为小写复数。在Django的模型定义中，经常出现类似的英文单词大小写不同，一定要注意区分！</p>
<p>如果要创建一个递归的外键，也就是自己关联自己的的外键，使用下面的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models.ForeignKey(<span class="string">&#x27;self&#x27;</span>, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<p>关系字段的定义还有个小坑。在后面<code>verbose_name</code>参数用于设置字段的别名。很多情况下，为了方便，我们都会设置这么个值，并且作为字段的第一位置参数。但是对于关系字段，其第一位置参数永远是关系对象，不能是<code>verbose_name</code>，一定要注意！</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><h4 id="on-delete"><a href="#on-delete" class="headerlink" title="on_delete"></a>on_delete</h4><p>当一个外键关联的对象被删除时，Django将模仿<code>on_delete</code>参数定义的SQL约束执行相应操作。</p>
<p>该参数可选的值都内置在<code>django.db.models</code>中（全部为大写），包括：</p>
<ul>
<li>CASCADE：模拟SQL语言中的<code>ON DELETE CASCADE</code>约束，将定义有外键的模型对象同时删除！</li>
<li>PROTECT:阻止上面的删除操作，但是弹出<code>ProtectedError</code>异常</li>
<li>SET_NULL：将外键字段设为null，只有当字段设置了<code>null=True</code>时，方可使用该值。</li>
<li>SET_DEFAULT:将外键字段设为默认值。只有当字段设置了default参数时，方可使用。</li>
<li>DO_NOTHING：什么也不做。</li>
<li>SET()：设置为一个传递给SET()的值或者一个回调函数的返回值。注意大小写。</li>
</ul>
<h4 id="limit-choices-to"><a href="#limit-choices-to" class="headerlink" title="limit_choices_to"></a>limit_choices_to</h4><p>该参数用于限制外键所能关联的对象，只能用于Django的ModelForm（Django的表单模块）和admin后台，对其它场合无限制功能。其值可以是一个字典、Q对象或者一个返回字典或Q对象的函数调用，如下例所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">staff_member = models.ForeignKey(</span><br><span class="line">    User,</span><br><span class="line">    on_delete=models.CASCADE,</span><br><span class="line">    limit_choices_to=&#123;<span class="string">&#x27;is_staff&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样定义，则ModelForm的<code>staff_member</code>字段列表中，只会出现那些<code>is_staff=True</code>的Users对象，这一功能对于admin后台非常有用。</p>
<h4 id="related-name"><a href="#related-name" class="headerlink" title="related_name"></a>related_name</h4><p>用于关联对象反向引用模型的名称。以前面车和工厂的例子解释，就是从工厂反向关联到车的关系名称。</p>
<p>通常情况下，这个参数我们可以不设置，Django会默认以模型的小写加上<code>_set</code>作为反向关联名，比如对于工厂就是<code>car_set</code>，如果你觉得<code>car_set</code>还不够直观，可以如下定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    manufacturer = models.ForeignKey(</span><br><span class="line">        <span class="string">&#x27;production.Manufacturer&#x27;</span>,      </span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">        related_name=<span class="string">&#x27;car_producted_by_this_manufacturer&#x27;</span>,  <span class="comment"># 看这里！！</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>也许我定义了一个蹩脚的词，但表达的意思很清楚。以后从工厂对象反向关联到它所生产的汽车，就可以使用<code>maufacturer.car_producted_by_this_manufacturer</code>了。</p>
<h3 id="1-2-2-多对多（ManyToManyField）"><a href="#1-2-2-多对多（ManyToManyField）" class="headerlink" title="1.2.2 多对多（ManyToManyField）"></a>1.2.2 多对多（ManyToManyField）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManyToManyField</span>(<span class="params">to, **options</span>)</span></span><br></pre></td></tr></table></figure>
<p>多对多关系在数据库中也是非常常见的关系类型。比如一本书可以有好几个作者，一个作者也可以写好几本书。多对多的字段可以定义在任何的一方，请尽量定义在符合人们思维习惯的一方，但不要同时都定义，只能选择一个模型设置该字段（比如我们通常将披萨上的配料字段放在披萨模型中，而不是在配料模型中放置披萨字段）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topping</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    toppings = models.ManyToManyField(Topping)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>建议为多对多字段名使用复数形式。</p>
</li>
<li><p>多对多关系需要一个位置参数：关联的对象模型，其它用法和外键多对一基本类似。</p>
</li>
<li><p>如果要创建一个关联自己的多对多字段，依然是通过<code>&#39;self&#39;</code>引用。</p>
</li>
</ul>
<h3 id="1-2-3-一对一（OneToOneField）"><a href="#1-2-3-一对一（OneToOneField）" class="headerlink" title="1.2.3 一对一（OneToOneField）"></a>1.2.3 一对一（OneToOneField）</h3><p>一对一关系类型的定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneToOneField</span>(<span class="params">to, on_delete, parent_link=<span class="literal">False</span>, **options</span>)</span></span><br></pre></td></tr></table></figure>
<p>从概念上讲，一对一关系非常类似具有<code>unique=True</code>属性的外键关系，但是反向关联对象只有一个。这种关系类型多数用于当一个模型需要从别的模型扩展而来的情况。比如，Django自带auth模块的User用户表，如果你想在自己的项目里创建用户模型，又想方便的使用Django的auth中的一些功能，那么一个方案就是在你的用户模型里，使用一对一关系，添加一个与auth模块User模型的关联字段。</p>
<p>该关系的第一位置参数为关联的模型，其用法和前面的多对一外键一样。</p>
<p>如果你没有给一对一关系设置<code>related_name</code>参数，Django将使用当前模型的小写名作为默认值。</p>
<p>看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个字段都使用一对一关联到了Django内置的auth模块中的User模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpecialUser</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    user = models.OneToOneField(</span><br><span class="line">        settings.AUTH_USER_MODEL,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">    )</span><br><span class="line">    supervisor = models.OneToOneField(</span><br><span class="line">        settings.AUTH_USER_MODEL,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">        related_name=<span class="string">&#x27;supervisor_of&#x27;</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>


<h2 id="1-3-字段的参数"><a href="#1-3-字段的参数" class="headerlink" title="1.3 字段的参数"></a>1.3 字段的参数</h2><p>所有的模型字段都可以接收一定数量的参数，比如CharField至少需要一个max_length参数。下面的这些参数是所有字段都可以使用的，并且是可选的。</p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>该值为True时，Django在数据库用NULL保存空值。默认值为False。对于保存字符串类型数据的字段，请尽量避免将此参数设为True，那样会导致两种‘没有数据’的情况，一种是<code>NULL</code>，另一种是空字符串<code>&#39;&#39;</code>。Django 的惯例是使用空字符串而不是 <code>NULL</code>。</p>
<h4 id="blank"><a href="#blank" class="headerlink" title="blank"></a>blank</h4><p>True时，字段可以为空。默认False。和null参数不同的是，null是纯数据库层面的，而blank是验证相关的，它与表单验证是否允许输入框内为空有关，与数据库无关。所以要小心一个null为False，blank为True的字段接收到一个空值可能会出bug或异常。</p>
<h4 id="choices"><a href="#choices" class="headerlink" title="choices"></a>choices</h4><p>用于页面上的选择框标签，需要先提供一个二维的二元元组，第一个元素表示存在数据库内真实的值，第二个表示页面上显示的具体内容。在浏览器页面上将显示第二个元素的值。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    YEAR_IN_SCHOOL_CHOICES = (</span><br><span class="line">        (FRESHMAN, <span class="string">&#x27;Freshman&#x27;</span>),</span><br><span class="line">        (SOPHOMORE, <span class="string">&#x27;Sophomore&#x27;</span>),</span><br><span class="line">        (JUNIOR, <span class="string">&#x27;Junior&#x27;</span>),</span><br><span class="line">        (SENIOR, <span class="string">&#x27;Senior&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    year_in_school = models.CharField(</span><br><span class="line">        max_length=<span class="number">2</span>,</span><br><span class="line">        choices=YEAR_IN_SCHOOL_CHOICES,</span><br><span class="line">        default=FRESHMAN,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_upperclass</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.year_in_school <span class="keyword">in</span> (self.JUNIOR, self.SENIOR)</span><br></pre></td></tr></table></figure>


<h4 id="primary-key"><a href="#primary-key" class="headerlink" title="primary_key"></a>primary_key</h4><p>如果你没有给模型的任何字段设置这个参数为True，Django将自动创建一个AutoField自增字段，名为‘id’，并设置为主键。也就是<code>id = models.AutoField(primary_key=True)</code>。</p>
<p>如果你为某个字段设置了primary_key=True，则当前字段变为主键，并关闭Django自动生成id主键的功能。</p>
<p><strong><code>primary_key=True</code>隐含<code>null=False</code>和<code>unique=True</code>的意思。一个模型中只能有一个主键字段！</strong></p>
<p>另外，主键字段不可修改，如果你给某个对象的主键赋个新值实际上是创建一个新对象，并不会修改原来的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">###############    </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruit = Fruit.objects.create(name=<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruit.name = <span class="string">&#x27;Pear&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruit.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fruit.objects.values_list(<span class="string">&#x27;name&#x27;</span>, flat=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Pear&#x27;</span>]</span><br></pre></td></tr></table></figure>


<h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><p>设为True时，在整个数据表内该字段的数据不可重复。</p>
<p>注意：</p>
<ul>
<li><p>对于ManyToManyField和OneToOneField关系类型，该参数无效。</p>
</li>
<li><p>当unique=True时，db_index参数无须设置，因为unqiue隐含了索引。</p>
</li>
</ul>
<h4 id="verbose-name"><a href="#verbose-name" class="headerlink" title="verbose_name"></a>verbose_name</h4><p>为字段设置一个人类可读，更加直观的别名。</p>
<p>对于每一个字段类型，除了<code>ForeignKey</code>、<code>ManyToManyField</code>和<code>OneToOneField</code>这三个特殊的关系类型，其第一可选位置参数都是<code>verbose_name</code>。如果没指定这个参数，Django会利用字段的属性名自动创建它，并将下划线转换为空格。</p>
<p>下面这个例子的<code>verbose name</code>是”person’s first name”:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first_name = models.CharField(<span class="string">&quot;person&#x27;s first name&quot;</span>, max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>下面这个例子的<code>verbose name</code>是”first name”:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first_name = models.CharField(max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>对于外键、多对多和一对一字字段，由于第一个参数需要用来指定关联的模型，因此必须用关键字参数<code>verbose_name</code>来明确指定。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poll = models.ForeignKey(</span><br><span class="line">    Poll,</span><br><span class="line">    on_delete=models.CASCADE,</span><br><span class="line">    verbose_name=<span class="string">&quot;the related poll&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">sites = models.ManyToManyField(Site, verbose_name=<span class="string">&quot;list of sites&quot;</span>)</span><br><span class="line">    place = models.OneToOneField(</span><br><span class="line">    Place,</span><br><span class="line">    on_delete=models.CASCADE,</span><br><span class="line">    verbose_name=<span class="string">&quot;related place&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h2 id="1-4-模型的元数据Meta"><a href="#1-4-模型的元数据Meta" class="headerlink" title="1.4 模型的元数据Meta"></a>1.4 模型的元数据Meta</h2><p>模型的元数据，指的是“除了字段外的所有内容”，例如排序方式、数据库表名、人类可读的单数或者复数名等等。想在模型中增加元数据，方法很简单，在模型类中添加一个子类，名字是固定的<code>Meta</code>，然后在这个Meta类下面增加各种元数据选项或者说设置项。参考下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ox</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    horn_length = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>         <span class="comment"># 注意，是模型的子类，要缩进！</span></span><br><span class="line">        ordering = [<span class="string">&quot;horn_length&quot;</span>]</span><br><span class="line">        verbose_name_plural = <span class="string">&quot;oxen&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们为模型Ox增加了两个元数据‘ordering’和‘verbose_name_plural’，分别表示排序和复数名。</p>
<p>介绍一些常用的元数据选项：</p>
<h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p>如果<code>abstract=True</code>，那么模型会被认为是一个抽象模型。抽象模型本身不实际生成数据库表，而是作为其它模型的父类，被继承使用。具体内容可以参考Django模型的继承。</p>
<h3 id="ordering"><a href="#ordering" class="headerlink" title="ordering"></a>ordering</h3><p>最常用的元数据之一了！</p>
<p>用于指定该模型生成的所有对象的排序方式，接收一个字段名组成的元组或列表。默认按升序排列，如果在字段名前加上字符“-”则表示按降序排列，如果使用字符问号“？”表示随机排列。请看下面的例子：</p>
<p>这个顺序是你通过查询语句，获得Queryset后的列表内元素的顺序，切不可和前面的<code>get_latest_by</code>等混淆。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ordering = [<span class="string">&#x27;pub_date&#x27;</span>]             <span class="comment"># 表示按&#x27;pub_date&#x27;字段进行升序排列</span></span><br><span class="line">ordering = [<span class="string">&#x27;-pub_date&#x27;</span>]            <span class="comment"># 表示按&#x27;pub_date&#x27;字段进行降序排列</span></span><br><span class="line">ordering = [<span class="string">&#x27;-pub_date&#x27;</span>, <span class="string">&#x27;author&#x27;</span>]  <span class="comment"># 表示先按&#x27;pub_date&#x27;字段进行降序排列，再按`author`字段进行升序排列。</span></span><br></pre></td></tr></table></figure>


<h4 id="unique-together"><a href="#unique-together" class="headerlink" title="unique_together"></a>unique_together</h4><p>这个元数据是非常重要的一个！它<strong>等同于数据库的联合约束！</strong></p>
<p>举个例子，假设有一张用户表，保存有用户的姓名、出生日期、性别和籍贯等等信息。要求是所有的用户唯一不重复，可现在有好几个叫“张伟”的，如何区别它们呢？（不要说主键唯一，这里讨论的不是这个问题）</p>
<p>我们可以设置不能有两个用户在同一个地方同一时刻出生并且都叫“张伟”，使用这种联合约束，保证数据库能不能重复添加用户（也不要和我谈小概率问题）。在Django的模型中，如何实现这种约束呢？</p>
<p>使用<code>unique_together</code>，也就是联合唯一！</p>
<p>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unique_together = [[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;birth_day&#x27;</span>, <span class="string">&#x27;address&#x27;</span>],......]</span><br></pre></td></tr></table></figure>
<p>这样，哪怕有两个在同一天出生的张伟，但他们的籍贯不同，也就是两个不同的用户。一旦三者都相同，则会被Django拒绝创建。这个元数据选项经常被用在admin后台，并且强制应用于数据库层面。</p>
<p>unique_together接收一个二维的列表，每个元素都是一维列表，表示一组联合唯一约束，可以同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unique_together = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;birth_day&#x27;</span>, <span class="string">&#x27;address&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>联合唯一无法作用于普通的多对多字段。</p>
<h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>如果设置了<code>proxy = True</code>，表示使用代理模式的模型继承方式。具体内容与abstract选项一样，参考模型继承章节。</p>
<h4 id="verbose-name-1"><a href="#verbose-name-1" class="headerlink" title="verbose_name"></a>verbose_name</h4><p>最常用的元数据之一！用于设置模型对象的直观、人类可读的名称，用于在各种打印、页面展示等场景。可以用中文。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">verbose_name = <span class="string">&quot;story&quot;</span></span><br><span class="line">verbose_name = <span class="string">&quot;披萨&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果你不指定它，那么Django会使用小写的模型名作为默认值。</p>
<h4 id="verbose-name-plural"><a href="#verbose-name-plural" class="headerlink" title="verbose_name_plural"></a>verbose_name_plural</h4><p>英语有单数和复数形式。这个就是模型对象的复数名，比如“apples”。因为我们中文通常不区分单复数，所以保持和<code>verbose_name</code>一致也可以。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">verbose_name_plural = <span class="string">&quot;stories&quot;</span></span><br><span class="line">verbose_name_plural = <span class="string">&quot;披萨&quot;</span></span><br><span class="line">verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure>
<p>如果不指定该选项，那么默认的复数名字是<code>verbose_name</code>加上‘s’</p>
<h4 id="permissions"><a href="#permissions" class="headerlink" title="permissions"></a>permissions</h4><p>该元数据用于当创建对象时增加额外的权限。它接收一个所有元素都是二元元组的列表或元组，每个元素都是<code>(权限代码, 直观的权限名称)</code>的格式。比如下面的例子：</p>
<p>这个Meta选项非常重要，和auth框架的权限系统紧密相关。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">permissions = ((<span class="string">&quot;can_deliver_pizzas&quot;</span>, <span class="string">&quot;可以送披萨&quot;</span>),)</span><br></pre></td></tr></table></figure>


<h2 id="1-5-模型的继承"><a href="#1-5-模型的继承" class="headerlink" title="1.5 模型的继承"></a>1.5 模型的继承</h2><p>Django中所有的模型都必须继承<code>django.db.models.Model</code>模型</p>
<p>Django有三种继承的方式：</p>
<ul>
<li><u>抽象基类</u>：被用来继承的模型被称为<code>Abstract base classes</code>，将子类共同的数据抽离出来，供子类继承重用，它不会创建实际的数据表；</li>
<li><u>多表继承</u>：<code>Multi-table inheritance</code>，每一个模型都有自己的数据库表，父子之间独立存在；</li>
<li><u>代理模型</u>：如果你只想修改模型的Python层面的行为，并不想改动模型的字段，可以使用代理模型。</li>
</ul>
<p><strong>注意！同Python的继承一样，Django也是可以同时继承两个以上父类的！</strong></p>
<h3 id="1-5-1-抽象基类"><a href="#1-5-1-抽象基类" class="headerlink" title="1.5.1 抽象基类"></a>1.5.1 抽象基类</h3><p>只需要在模型的Meta类里添加<code>abstract=True</code>元数据项，就可以将一个模型转换为抽象基类。Django不会为这种类创建实际的数据库表，它们也没有管理器，不能被实例化也无法直接保存，它们就是被当作父类供起来，让子类继承的。抽象基类完全就是用来保存子模型们共有的内容部分，达到重用的目的。当它们被继承时，它们的字段会全部复制到子模型中。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    age = models.PositiveIntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">CommonInfo</span>):</span></span><br><span class="line">    home_group = models.CharField(max_length=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<p>Student模型将拥有name，age，home_group三个字段，并且CommonInfo模型不能当做一个正常的模型使用，不会有这张表出现。</p>
<p>那如果我想修改CommonInfo父类中的name字段的定义呢？</p>
<ul>
<li>在Student类中创建一个name字段，覆盖父类的即可。</li>
</ul>
<p>那如果我不需要CommonInfo父类中的name字段呢？</p>
<ul>
<li>在Student类中创建一个name变量，值设为None即可。</li>
</ul>
<h4 id="抽象基类的Meta数据："><a href="#抽象基类的Meta数据：" class="headerlink" title="抽象基类的Meta数据："></a>抽象基类的Meta数据：</h4><p>如果子类没有声明自己的Meta类，那么它将自动继承抽象基类的Meta类。</p>
<p>如果子类要设置自己的Meta属性，则需要扩展基类的Meta：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line">        ordering = [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">CommonInfo</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>(<span class="params">CommonInfo.Meta</span>):</span>   <span class="comment"># 注意这里有个继承关系</span></span><br><span class="line">        db_table = <span class="string">&#x27;student_info&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里有几点要特别说明：</p>
<ul>
<li><p>抽象基类中有的元数据，子模型没有的话，直接继承；子模型也有的话，直接覆盖；</p>
</li>
<li><p>子模型可以额外添加元数据；</p>
</li>
<li><p>抽象基类中的<code>abstract=True</code>这个元数据不会被继承。也就是说如果想让一个抽象基类的子模型，同样成为一个抽象基类，那你必须显式的在该子模型的Meta中同样声明一个<code>abstract = True</code>；</p>
</li>
<li><p>有一些元数据对抽象基类无效，比如<code>db_table</code>，首先是抽象基类本身不会创建数据表，其次它的所有子类也不会按照这个元数据来设置表名。</p>
</li>
<li><p>由于Python继承的工作机制，如果子类继承了多个抽象基类，则默认情况下仅继承第一个列出的基类的 Meta 选项。如果要从多个抽象基类中继承 Meta 选项，必须显式地声明 Meta 继承。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    age = models.PositiveIntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line">        ordering = [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unmanaged</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line">        managed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">CommonInfo, Unmanaged</span>):</span></span><br><span class="line">    home_group = models.CharField(max_length=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>(<span class="params">CommonInfo.Meta, Unmanaged.Meta</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="1-5-2-多表继承"><a href="#1-5-2-多表继承" class="headerlink" title="1.5.2 多表继承"></a>1.5.2 多表继承</h3><p>这种继承方式下，父类和子类都是独立自主、功能完整、可正常使用的模型，都有自己的数据库表，内部隐含了一个一对一的关系。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Place</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span>(<span class="params">Place</span>):</span></span><br><span class="line">    serves_hot_dogs = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    serves_pizza = models.BooleanField(default=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>


<h4 id="Meta和多表继承"><a href="#Meta和多表继承" class="headerlink" title="Meta和多表继承"></a>Meta和多表继承</h4><p>在多表继承的情况下，由于父类和子类都在数据库内有物理存在的表，父类的Meta类会对子类造成不确定的影响，因此，Django在这种情况下关闭了子类继承父类的Meta功能。这一点和抽象基类的继承方式有所不同。</p>
<p>但是，还有两个Meta元数据属性特殊一点，那就是<code>ordering</code>和<code>get_latest_by</code>，这两个参数是会被继承的。因此，如果在多表继承中，你不想让你的子类继承父类的上面两种参数，就必须在子类中显示的指出或重写。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildModel</span>(<span class="params">ParentModel</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># 移除父类对子类的排序影响</span></span><br><span class="line">        ordering = []</span><br></pre></td></tr></table></figure>


<h4 id="多表继承和反向关联"><a href="#多表继承和反向关联" class="headerlink" title="多表继承和反向关联"></a>多表继承和反向关联</h4><p>因为多表继承使用了一个隐含的OneToOneField来链接子类与父类，所以象上例那样，你可以从父类访问子类。但是这个OnetoOneField字段默认的<code>related_name</code>值与ForeignKey和 ManyToManyField默认的反向名称相同。如果你与父类或另一个子类做多对一或是多对多关系，你就必须在每个多对一和多对多字段上强制指定<code>related_name</code>。如果你没这么做，Django就会在你运行或验证(validation)时抛出异常。</p>
<p>仍以上面Place类为例，我们创建一个带有ManyToManyField字段的子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Supplier</span>(<span class="params">Place</span>):</span></span><br><span class="line">    customers = models.ManyToManyField(Place)</span><br></pre></td></tr></table></figure>
<p>这会产生下面的错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Reverse query name <span class="keyword">for</span> <span class="string">&#x27;Supplier.customers&#x27;</span> clashes <span class="keyword">with</span> reverse query</span><br><span class="line">name <span class="keyword">for</span> <span class="string">&#x27;Supplier.place_ptr&#x27;</span>.</span><br><span class="line">HINT: Add <span class="keyword">or</span> change a related_name argument to the definition <span class="keyword">for</span></span><br><span class="line"><span class="string">&#x27;Supplier.customers&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;Supplier.place_ptr&#x27;</span>.</span><br></pre></td></tr></table></figure>
<p>解决方法是：向customers字段中添加<code>related_name</code>参数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">customers = models.ManyToManyField(Place, related_name=<span class="string">&#x27;provider&#x27;</span>)。</span><br></pre></td></tr></table></figure>


<h3 id="1-5-3-代理模型"><a href="#1-5-3-代理模型" class="headerlink" title="1.5.3 代理模型"></a>1.5.3 代理模型</h3><p>使用多表继承时，父类的每个子类都会创建一张新数据表，通常情况下，这是我们想要的操作，因为子类需要一个空间来存储不包含在父类中的数据。但有时，你可能只想更改模型在Python层面的行为，比如更改默认的manager管理器，或者添加一个新方法。</p>
<p>代理模型就是为此而生的。你可以创建、删除、更新代理模型的实例，并且所有的数据都可以像使用原始模型（非代理类模型）一样被保存。不同之处在于你可以在代理模型中改变默认的排序方式和默认的manager管理器等等，而不会对原始模型产生影响。</p>
<p>代理模型其实就是给原模型换了件衣服（API），实际操作的还是原来的模型和数据。</p>
<p><strong>声明一个代理模型只需要将Meta中proxy的值设为True。</strong></p>
<p>例如你想给Person模型添加一个方法。你可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPerson</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        proxy = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>MyPerson类将操作和Person类同一张数据库表。并且任何新的Person实例都可以通过MyPerson类进行访问，反之亦然。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person.objects.create(first_name=<span class="string">&quot;foobar&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyPerson.objects.get(first_name=<span class="string">&quot;foobar&quot;</span>)</span><br><span class="line">&lt;MyPerson: foobar&gt;</span><br></pre></td></tr></table></figure>
<p>下面的例子通过代理进行排序，但父类却不排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedPerson</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># 现在，普通的Person查询是无序的，而OrderedPerson查询会按照`last_name`排序。</span></span><br><span class="line">        ordering = [<span class="string">&quot;last_name&quot;</span>]</span><br><span class="line">        proxy = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>一些约束：</strong></p>
<ul>
<li>代理模型必须继承自一个非抽象的基类，并且不能同时继承多个非抽象基类；</li>
<li>代理模型可以同时继承任意多个抽象基类，前提是这些抽象基类没有定义任何模型字段。</li>
<li>代理模型可以同时继承多个别的代理模型，前提是这些代理模型继承同一个非抽象基类。</li>
</ul>
<h3 id="1-5-4-多重继承"><a href="#1-5-4-多重继承" class="headerlink" title="1.5.4 多重继承"></a>1.5.4 多重继承</h3><p>注意，多重继承和多表继承是两码事，两个概念。</p>
<p>Django的模型体系支持多重继承，就像Python一样。如果多个父类都含有Meta类，则只有第一个父类的会被使用，剩下的会忽略掉。</p>
<p>一般情况，能不要多重继承就不要，尽量让继承关系简单和直接，避免不必要的混乱和复杂。</p>
<h2 id="1-6-验证器"><a href="#1-6-验证器" class="headerlink" title="1.6 验证器"></a>1.6 验证器</h2><p>在Django的模型字段参数中，有一个参数叫做<code>validators</code>，这个参数是用来指定当前字段需要使用的验证器，也就是对字段数据的合法性进行验证，比如大小、类型等。</p>
<p>Django的验证器可以分为模型相关的验证器和表单相关的验证器，它们基本类似，但在使用上有区别。</p>
<p>详情请见<a href="https://www.liujiangblog.com/course/django/101">这里</a>，这里讨论模型相关的验证器。</p>
<h2 id="1-7-查询操作"><a href="#1-7-查询操作" class="headerlink" title="1.7 查询操作"></a>1.7 查询操作</h2><p>查询操作是Django的ORM框架中最重要的内容之一。我们建立模型、保存数据为的就是在需要的时候可以查询得到数据。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    tagline = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    email = models.EmailField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)</span><br><span class="line">    headline = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    body_text = models.TextField()</span><br><span class="line">    pub_date = models.DateField()</span><br><span class="line">    mod_date = models.DateField()</span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br><span class="line">    number_of_comments = models.IntegerField()</span><br><span class="line">    number_of_pingbacks = models.IntegerField()</span><br><span class="line">    rating = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.headline</span><br></pre></td></tr></table></figure>


<h3 id="1-7-1-创建对象"><a href="#1-7-1-创建对象" class="headerlink" title="1.7.1 创建对象"></a>1.7.1 创建对象</h3><p>创建一个模型实例，也就是一条数据库记录，最一般的方式是使用模型类的实例化构造方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = Blog.objects.create(name=<span class="string">&#x27;小张&#x27;</span>, tagline=<span class="string">&#x27;你猜&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>有时实现一些额外需求，常见的做法是自定义<code>__init__</code>方法。但这不好，容易打断Django源码的调用链，存在漏洞。更推荐的是下面的方法：</p>
<ul>
<li>自定义管理器，并在其中添加创建对象的方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookManager</span>(<span class="params">models.Manager</span>):</span>   <span class="comment"># 继承默认的管理器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_book</span>(<span class="params">self, title</span>):</span></span><br><span class="line">        book = self.create(title=title)</span><br><span class="line">        <span class="comment"># 将你的个人代码放在这里</span></span><br><span class="line">        print(<span class="string">&#x27;测试一下是否工作正常&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> book</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    objects = BookManager()   <span class="comment"># 赋值objects</span></span><br><span class="line"></span><br><span class="line">book = Book.objects.create_book(<span class="string">&quot;www&quot;</span>)   <span class="comment">#改为使用create_book方法创建对象</span></span><br></pre></td></tr></table></figure>


<h3 id="1-7-2-修改对象并保存"><a href="#1-7-2-修改对象并保存" class="headerlink" title="1.7.2 修改对象并保存"></a>1.7.2 修改对象并保存</h3><p>我们往往会重写save方法，添加自己的业务逻辑，然后在其中调用原来的save方法，保证Django基本工作机制正常。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Blog(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;100)</span><br><span class="line">    tagline &#x3D; models.TextField()</span><br><span class="line"></span><br><span class="line">    def save(self, *args, **kwargs):</span><br><span class="line">        do_something()   # 保存前做点私活</span><br><span class="line">        super().save(*args, **kwargs)  # 一定不要忘记这行代码</span><br><span class="line">        do_something_else()  # 保存后又加塞点东西</span><br></pre></td></tr></table></figure>
<p>这样，任何一篇博客在保存前后都会执行一些额外的代码。</p>
<p>注意，千万不要忘记<code>super().save(*args, **kwargs)</code>，这行确保了Django源码中关于save方法的代码会依然被执行。</p>
<p>下面的例子则是对博客名字做限制，只有小张的博客才可以保存：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    tagline = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.name != <span class="string">&quot;小张的博客&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="comment"># 只有小张的博客才可以保存</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">super</span>().save(*args, **kwargs)  <span class="comment"># 调用真正的save方法</span></span><br></pre></td></tr></table></figure>
<p><code>*args, **kwargs</code>的参数设计，确保我们自定义的save方法是个万金油，不论Django源码中的save方法的参数怎么变，我们自己的save方法不会因为参数定义的不正确而出现bug。</p>
<p>此外：</p>
<p>执行save方法后，Django才会真正为对象设置自增主键的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = Blog(name=<span class="string">&#x27;Cheddar Talk&#x27;</span>, tagline=<span class="string">&#x27;Thoughts on cheese.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2.<span class="built_in">id</span>     <span class="comment"># 返回None，因为此时b2还没有写入数据库，没有id值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2.<span class="built_in">id</span>     <span class="comment"># 这回有了</span></span><br></pre></td></tr></table></figure>
<p>当然，你也可以自己指定主键的值，不需要等待数据库为主键分配值，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b3 = Blog(<span class="built_in">id</span>=<span class="number">3</span>, name=<span class="string">&#x27;Cheddar Talk&#x27;</span>, tagline=<span class="string">&#x27;Thoughts on cheese.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b3.<span class="built_in">id</span>     <span class="comment"># 返回 3.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b3.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b3.<span class="built_in">id</span>     <span class="comment"># 返回 3.</span></span><br></pre></td></tr></table></figure>
<p>很显然，你必须确保分配的主键值是没有被使用过的，否则肯定出问题，因为在这种情况下，Django认为你是在更新一条已有的数据对象，而不是新建对象，比如下面的操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b4 = Blog(<span class="built_in">id</span>=<span class="number">3</span>, name=<span class="string">&#x27;Not Cheddar&#x27;</span>, tagline=<span class="string">&#x27;Anything but cheese.&#x27;</span>)</span><br><span class="line">b4.save() </span><br><span class="line"><span class="comment"># 实际上是更新了上面的b3，而不是新建，此时b4==b3</span></span><br></pre></td></tr></table></figure>
<p>上面现象的本质是Django对SQL的INSERT和UPDATE语句进行了抽象合并，共用一个save方法。</p>
<p>有些罕见情况下，可能你必须强制进行INSERT或者UPDATE操作，而不是让Django自动决定。这时候可以使用save方法的<code>force_insert</code>和<code>force_update</code>参数，将其中之一设置为True，强制指定保存模式。</p>
<ul>
<li>保存外键和多对多字段:</li>
</ul>
<p>保存一个外键字段和保存普通字段没什么区别，只是要注意值的类型要正确。下面的例子，有一个Entry的实例entry和一个Blog的实例<code>cheese_blog</code>，然后把<code>cheese_blog</code>作为值赋给了entry的blog属性，最后调用save方法进行保存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from blog.models import Blog, Entry</span><br><span class="line">&gt;&gt;&gt; entry &#x3D; Entry.objects.get(pk&#x3D;1)</span><br><span class="line">&gt;&gt;&gt; cheese_blog &#x3D; Blog.objects.get(name&#x3D;&quot;Cheddar Talk&quot;)</span><br><span class="line">&gt;&gt;&gt; entry.blog &#x3D; cheese_blog</span><br><span class="line">&gt;&gt;&gt; entry.save()</span><br></pre></td></tr></table></figure>
<p>多对多字段的保存稍微有点区别，需要调用一个<code>add()</code>方法，而不是直接给属性赋值，但它不需要调用save方法。如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from blog.models import Author</span><br><span class="line">&gt;&gt;&gt; joe &#x3D; Author.objects.create(name&#x3D;&quot;Joe&quot;)</span><br><span class="line">&gt;&gt;&gt; entry.authors.add(joe)</span><br></pre></td></tr></table></figure>
<p>在一行语句内，可以同时添加多个对象到多对多的字段，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; john &#x3D; Author.objects.create(name&#x3D;&quot;John&quot;)</span><br><span class="line">&gt;&gt;&gt; paul &#x3D; Author.objects.create(name&#x3D;&quot;Paul&quot;)</span><br><span class="line">&gt;&gt;&gt; george &#x3D; Author.objects.create(name&#x3D;&quot;George&quot;)</span><br><span class="line">&gt;&gt;&gt; ringo &#x3D; Author.objects.create(name&#x3D;&quot;Ringo&quot;)</span><br><span class="line">&gt;&gt;&gt; entry.authors.add(john, paul, george, ringo)</span><br></pre></td></tr></table></figure>
<p>如果你指定或添加了错误类型的对象，Django会抛出异常。</p>
<h3 id="1-7-3-检索对象"><a href="#1-7-3-检索对象" class="headerlink" title="1.7.3 检索对象"></a>1.7.3 检索对象</h3><p>想要从数据库内检索对象，你需要基于模型类，通过管理器（Manager）操作数据库并返回一个查询结果集（QuerySet）。</p>
<p>详情请看有关<a href="https://www.liujiangblog.com/course/django/129">查询结果集（QuerySet）</a>的介绍</p>
<h2 id="1-8-返回QuerySets的API"><a href="#1-8-返回QuerySets的API" class="headerlink" title="1.8 返回QuerySets的API"></a>1.8 返回QuerySets的API</h2><p><a href="https://www.liujiangblog.com/course/django/130">详情请看有关介绍</a></p>
<h2 id="1-9-不返回QuerySets的API"><a href="#1-9-不返回QuerySets的API" class="headerlink" title="1.9 不返回QuerySets的API"></a>1.9 不返回QuerySets的API</h2><p>以下的方法不会返回QuerySets，但是作用非常强大，尤其是粗体显示的方法，需要背下来。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>get()</strong></td>
<td>获取单个对象</td>
</tr>
<tr>
<td><strong>create()</strong></td>
<td>创建对象，无需save()</td>
</tr>
<tr>
<td><strong>get_or_create()</strong></td>
<td>查询对象，如果没有找到就新建对象</td>
</tr>
<tr>
<td><strong>update_or_create()</strong></td>
<td>更新对象，如果没有找到就创建对象</td>
</tr>
<tr>
<td><code>bulk_create()</code></td>
<td>批量创建对象</td>
</tr>
<tr>
<td>bulk_update()</td>
<td>批量更新对象</td>
</tr>
<tr>
<td><strong>count()</strong></td>
<td>统计对象的个数</td>
</tr>
<tr>
<td><code>in_bulk()</code></td>
<td>根据主键值的列表，批量返回对象</td>
</tr>
<tr>
<td><code>iterator()</code></td>
<td>获取包含对象的迭代器</td>
</tr>
<tr>
<td><strong>latest()</strong></td>
<td>获取最近的对象</td>
</tr>
<tr>
<td><strong>earliest()</strong></td>
<td>获取最早的对象</td>
</tr>
<tr>
<td><strong>first()</strong></td>
<td>获取第一个对象</td>
</tr>
<tr>
<td><strong>last()</strong></td>
<td>获取最后一个对象</td>
</tr>
<tr>
<td><strong>aggregate()</strong></td>
<td>聚合操作</td>
</tr>
<tr>
<td><strong>exists()</strong></td>
<td>判断queryset中是否有对象</td>
</tr>
<tr>
<td><strong>update()</strong></td>
<td>更新对象</td>
</tr>
<tr>
<td><strong>delete()</strong></td>
<td>删除对象</td>
</tr>
<tr>
<td>as_manager()</td>
<td>获取管理器</td>
</tr>
<tr>
<td>explain()</td>
<td>对数据库操作的解释性信息</td>
</tr>
</tbody></table>
<h4 id="1-get"><a href="#1-get" class="headerlink" title="1. get()"></a>1. get()</h4><p>返回按照查询参数匹配到的单个对象，参数的格式应该符合Field lookups的要求。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">Entry.objects.get(blog=blog, entry_number=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>如果匹配到的对象个数不只一个的话，触发<code>MultipleObjectsReturned</code>异常:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.get(name=<span class="string">&#x27;张伟&#x27;</span>) </span><br><span class="line"><span class="comment"># raises Entry.MultipleObjectsReturned</span></span><br></pre></td></tr></table></figure>
<p>如果根据给出的参数匹配不到对象的话，触发DoesNotExist异常。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.get(<span class="built_in">id</span>=-<span class="number">999</span>) </span><br><span class="line"><span class="comment"># raises Entry.DoesNotExist</span></span><br></pre></td></tr></table></figure>
<p>DoesNotExist异常从<code>django.core.exceptions.ObjectDoesNotExist</code>继承，可以定位多个DoesNotExist异常。 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ObjectDoesNotExist</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    blog = Blog.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">    entry = Entry.objects.get(blog=blog, entry_number=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">    print(<span class="string">&quot;Either the blog or entry doesn&#x27;t exist.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果希望查询器只返回一个对象，则可以使用get()，无需添加任何参数：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">entry = Entry.objects.filter(...).exclude(...).get()</span></span><br></pre></td></tr></table></figure>


<h4 id="2-create"><a href="#2-create" class="headerlink" title="2. create()"></a>2. create()</h4><p>在一步操作中同时创建并且保存对象的便捷方法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Person.objects.create(first_name=<span class="string">&quot;Bruce&quot;</span>, last_name=<span class="string">&quot;Springsteen&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>等于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Person(first_name=<span class="string">&quot;Bruce&quot;</span>, last_name=<span class="string">&quot;Springsteen&quot;</span>)</span><br><span class="line">p.save(force_insert=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>force_insert</code>表示强制创建对象。如果model中有一个你手动设置的主键，并且这个值已经存在于数据库中, 调用create()将会失败并且触发IntegrityError因为主键必须是唯一的。如果你手动设置了主键，做好异常处理的准备。</p>
<h4 id="3-get-or-create"><a href="#3-get-or-create" class="headerlink" title="3. get_or_create()"></a>3. get_or_create()</h4><p><strong>通过kwargs来查询对象的便捷方法（如果模型中的所有字段都有默认值，可以为空），如果该对象不存在则创建一个新对象</strong>。</p>
<p>该方法<strong>返回一个由(object, created)组成的元组</strong>，元组中的object 是一个查询到的或者是被创建的对象， created是一个表示是否创建了新的对象的布尔值。</p>
<p>对于下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    obj = Person.objects.get(first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line">    obj = Person(first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>, birthday=date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">9</span>))</span><br><span class="line">    obj.save()</span><br></pre></td></tr></table></figure>
<p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用<code>get_or_create()</code>重写 :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj, created = Person.objects.get_or_create(</span><br><span class="line">    first_name=<span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    last_name=<span class="string">&#x27;Lennon&#x27;</span>,</span><br><span class="line">    defaults=&#123;<span class="string">&#x27;birthday&#x27;</span>: date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">9</span>)&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>任何传递给<code>get_or_create()</code>的关键字参数，除了一个可选的defaults，都将传递给get()调用。 如果查找到一个对象，返回一个包含匹配到的对象以及False 组成的元组。</p>
<h4 id="4-update-or-create"><a href="#4-update-or-create" class="headerlink" title="4. update_or_create()"></a>4. update_or_create()</h4><p>类似前面的<code>get_or_create()</code>。</p>
<p><strong>通过给出的kwargs来更新对象的便捷方法， 如果没找到对象，则创建一个新的对象</strong>。defaults是一个由 (field, value)对组成的字典，用于更新对象。defaults中的值可以是可调用对象（也就是说函数等）。</p>
<p>该方法返回一个由(object, created)组成的元组,元组中的object是一个创建的或者是被更新的对象， created是一个标示是否创建了新的对象的布尔值。</p>
<p><code>update_or_create</code>方法尝试通过给出的kwargs 去从数据库中获取匹配的对象。 如果找到匹配的对象，它将会依据defaults 字典给出的值更新字段。</p>
<p>像下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">defaults = &#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    obj = Person.objects.get(first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> defaults.items():</span><br><span class="line">        <span class="built_in">setattr</span>(obj, key, value)</span><br><span class="line">    obj.save()</span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line">    new_values = &#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Lennon&#x27;</span>&#125;</span><br><span class="line">    new_values.update(defaults)</span><br><span class="line">    obj = Person(**new_values)</span><br><span class="line">    obj.save()</span><br></pre></td></tr></table></figure>
<p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。 上面的示例可以用<code>update_or_create()</code> 重写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj, created = Person.objects.update_or_create(</span><br><span class="line">    first_name=<span class="string">&#x27;John&#x27;</span>, last_name=<span class="string">&#x27;Lennon&#x27;</span>,</span><br><span class="line">    defaults=&#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>kwargs中的名称如何解析的详细描述可以参见<code>get_or_create()</code>。</p>
<p>和<code>get_or_create()</code>一样，这个方法也容易导致竞态条件，如果数据库层级没有前置唯一性会让多行同时插入。</p>
<h4 id="5-count"><a href="#5-count" class="headerlink" title="5. count()"></a>5. count()</h4><p>count()</p>
<p>返回在数据库中对应的QuerySet对象的个数。count()永远不会引发异常。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回总个数.</span></span><br><span class="line">Entry.objects.count()</span><br><span class="line"><span class="comment"># 返回包含有&#x27;Lennon&#x27;的对象的总数</span></span><br><span class="line">Entry.objects.<span class="built_in">filter</span>(headline__contains=<span class="string">&#x27;Lennon&#x27;</span>).count()</span><br></pre></td></tr></table></figure>


<h4 id="6-exists"><a href="#6-exists" class="headerlink" title="6. exists()"></a>6. exists()</h4><p>如果QuerySet包含任何结果，则返回True，否则返回False。</p>
<p>查找具有唯一性字段（例如primary_key）的模型是否在一个QuerySet中的最高效的方法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">entry = Entry.objects.get(pk=<span class="number">123</span>)</span><br><span class="line"><span class="keyword">if</span> some_queryset.<span class="built_in">filter</span>(pk=entry.pk).exists():</span><br><span class="line">    print(<span class="string">&quot;Entry contained in queryset&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>它将比下面的方法快很多，这个方法要求对QuerySet求值并迭代整个QuerySet：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> entry <span class="keyword">in</span> some_queryset:</span><br><span class="line">   print(<span class="string">&quot;Entry contained in QuerySet&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>若要查找一个QuerySet是否包含任何元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> some_queryset.exists():</span><br><span class="line">    print(<span class="string">&quot;There is at least one object in some_queryset&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>将快于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> some_queryset:</span><br><span class="line">    print(<span class="string">&quot;There is at least one object in some_queryset&quot;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="7-update"><a href="#7-update" class="headerlink" title="7. update()"></a>7. update()</h4><p><strong>对指定的字段执行更新操作，并返回匹配的行数</strong>（如果某些行已具有新值，则可能不等于已更新的行数）。</p>
<p>例如，要对2010年发布的所有博客条目关闭评论功能，可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2010</span>).update(comments_on=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>可以同时更新多个字段 （没有多少字段的限制）。 例如同时更新comments_on和headline字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2010</span>).update(comments_on=<span class="literal">False</span>, headline=<span class="string">&#x27;This is old&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>update()方法无需save操作，会立刻写入数据库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update只能更新模型主表中的字段，不能更新关联模型中的字段。</span><br></pre></td></tr></table></figure>
<p>例如不能这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.update(blog__name=<span class="string">&#x27;foo&#x27;</span>) <span class="comment"># 这样做是无效的</span></span><br></pre></td></tr></table></figure>
<p>但是，仍然可以根据相关字段进行过滤：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(blog__id=<span class="number">1</span>).update(comments_on=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>update()方法返回受影响的行数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">64</span>).update(comments_on=<span class="literal">True</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(slug=<span class="string">&#x27;nonexistent-slug&#x27;</span>).update(comments_on=<span class="literal">True</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2010</span>).update(comments_on=<span class="literal">False</span>)</span><br><span class="line"><span class="number">132</span></span><br></pre></td></tr></table></figure>
<p>如果你只是更新一下对象，不需要为对象做别的事情，最有效的方法是调用update()，而不是将模型对象加载到内存中。 例如，不要这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = Entry.objects.get(<span class="built_in">id</span>=<span class="number">10</span>)</span><br><span class="line">e.comments_on = <span class="literal">False</span></span><br><span class="line">e.save()</span><br></pre></td></tr></table></figure>
<p>建议如下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">10</span>).update(comments_on=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>用update()还可以防止在加载对象和调用save()之间的短时间内数据库中某些内容可能发生更改的竞争条件。</p>
<p><code>update()方法不会调用save()方法，也不会发出pre_save和post_save信号。</code>所以，如果想更新一个具有自定义save()方法的模型的记录，请循环遍历它们并调用save()，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2020</span>):</span><br><span class="line">    e.comments_on = <span class="literal">False</span></span><br><span class="line">    e.save()</span><br></pre></td></tr></table></figure>


<h4 id="8-delete"><a href="#8-delete" class="headerlink" title="8. delete()"></a>8. delete()</h4><p>批量删除QuerySet中的所有对象，并返回删除的对象个数和每个对象类型的删除次数的字典。</p>
<p>delete()动作是立即执行的。</p>
<p>例如，要删除特定博客中的所有条目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Blog.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 删除b下所属的所有条目</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.<span class="built_in">filter</span>(blog=b).delete()</span><br><span class="line">(<span class="number">4</span>, &#123;<span class="string">&#x27;weblog.Entry&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>默认情况下，任何具有指向要删除的对象的外键的对象将与它们一起被删除。 像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>blogs = Blog.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="comment"># This will delete all Blogs and all of their Entry objects.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blogs.delete()</span><br><span class="line">(<span class="number">5</span>, &#123;<span class="string">&#x27;weblog.Blog&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;weblog.Entry&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;weblog.Entry_authors&#x27;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>这种级联的行为可以通过的ForeignKey的<code>on_delete</code>参数自定义。（什么时候要改变这种行为呢？比如日志数据，就不能和它关联的主体一并被删除！）</p>
<p>delete()会为所有已删除的对象（包括级联删除）发出<code>pre_delete</code>和<code>post_delete</code>信号。</p>
<p>详情请百度，或查阅<a href="https://www.liujiangblog.com/course/django/131">这里</a>。</p>
<h2 id="1-10-注解与聚合"><a href="#1-10-注解与聚合" class="headerlink" title="1.10 注解与聚合"></a>1.10 注解与聚合</h2><p>Django的ORM提供的API主要是用来增删查改单个对象的方法。 然而，有时候你要获取的值需要根据一组对象聚合后才能得到，比如几个学生成绩的平均分，非常类似数据分析和统计。</p>
<p>本节以下面的模型为例，来记录多个网上书店的库存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line">    pages = models.IntegerField()</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">10</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    rating = models.FloatField()</span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br><span class="line">    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)</span><br><span class="line">    pubdate = models.DateField()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line">    books = models.ManyToManyField(Book)</span><br></pre></td></tr></table></figure>


<h3 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h3><p>下面是根据以上模型执行常见的聚合查询范例，注意阅读其中的注释文字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 书籍的总数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.count()</span><br><span class="line"><span class="number">2452</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BaloneyPress出版社出版的书籍总数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.<span class="built_in">filter</span>(publisher__name=<span class="string">&#x27;BaloneyPress&#x27;</span>).count()</span><br><span class="line"><span class="number">73</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有书籍的平均价格</span></span><br><span class="line"><span class="comment"># 要注意！Avg，Count等聚合工具是由Django提供的，不是Python内置的，也不是你自己编写的。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.<span class="built_in">all</span>().aggregate(Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;price__avg&#x27;</span>: <span class="number">34.35</span>&#125;   <span class="comment"># 本来返回的是查询集，聚合后返回的是一个数据字典，字典的键名是有规律的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有书籍中最高的价格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Max</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.<span class="built_in">all</span>().aggregate(Max(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;price__max&#x27;</span>: Decimal(<span class="string">&#x27;81.20&#x27;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有书籍中最高价和平均价的差</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> FloatField</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Book.objects.aggregate(</span><br><span class="line"><span class="meta">... </span>    price_diff=Max(<span class="string">&#x27;price&#x27;</span>, output_field=FloatField()) - Avg(<span class="string">&#x27;price&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;price_diff&#x27;</span>: <span class="number">46.85</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是annonte注解的用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个被过滤出来的出版社对象都被附加了一个&quot;num_books&quot;属性，这个属性就是所谓的注释</span></span><br><span class="line"><span class="comment"># 和aggregate不同，annotate返回的依然是查询集，添加了私货的查询集。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="string">&#x27;book&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs</span><br><span class="line">&lt;QuerySet [&lt;Publisher: BaloneyPress&gt;, &lt;Publisher: SalamiPress&gt;, ...]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].num_books</span><br><span class="line"><span class="number">73</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个出版商都被附加了两个额外的属性，分别表示好评率大于5和好评率小于等于5的书籍的总数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"><span class="comment"># 统计每个出版社中好评率大于5的书籍的数量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>above_5 = Count(<span class="string">&#x27;book&#x27;</span>, <span class="built_in">filter</span>=Q(book__rating__gt=<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>below_5 = Count(<span class="string">&#x27;book&#x27;</span>, <span class="built_in">filter</span>=Q(book__rating__lte=<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要理解这里的链式调用含义。annotate不是filter，不会增减查询集的元素。</span></span><br><span class="line"><span class="comment"># 所以Publisher.objects实际上等于pubs=Publisher.objects.all()</span></span><br><span class="line"><span class="comment"># 第一个annotate为pubs增加below_5属性，第二个annotate又再次增加above_5属性</span></span><br><span class="line"><span class="comment"># 虽然是链式调用，但不是过滤行为，而是追加行为</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(below_5=below_5).annotate(above_5=above_5)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].above_5</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].below_5</span><br><span class="line"><span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个比较复杂。首先获取了所有的出版社。其次统计每个出版社的发行书籍数量，保存在num_books属性中。</span></span><br><span class="line"><span class="comment"># 然后对所有的出版社进行排序，根据num_books属性进行反向由多到少排序，最后切片获取前5个出版社。</span></span><br><span class="line">The top <span class="number">5</span> publishers, <span class="keyword">in</span> order by number of books.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs = Publisher.objects.annotate(num_books=Count(<span class="string">&#x27;book&#x27;</span>)).order_by(<span class="string">&#x27;-num_books&#x27;</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pubs[<span class="number">0</span>].num_books</span><br><span class="line"><span class="number">1323</span></span><br></pre></td></tr></table></figure>


































]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统课堂笔记总结</title>
    <url>/2020/10/06/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[ <div class="note warning">
            <p>2020.10.4：总结了一些有关操作系统的常见面试问题以及一些书上和笔记上的知识点。</p>
          </div> 





<h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F//image-20201006083338715.png" alt="image-20201006083338715"></p>
<h2 id="1、什么是操作系统？它的主要特征是什么？"><a href="#1、什么是操作系统？它的主要特征是什么？" class="headerlink" title="1、什么是操作系统？它的主要特征是什么？"></a>1、什么是操作系统？它的主要特征是什么？</h2><p><strong>操作系统是指控制和管理整个计算机系统硬件和软件资源的最基本的系统软件。</strong></p>
<p><strong>特征：</strong></p>
<ol>
<li><p><strong>并发性</strong>：两个或多个事件在<strong>同一时间间隔</strong>内发生（而并行性是指两个或多个事件在同一时刻发生）计算机系统中同时存在多个运行的程序，因此他有处理和调度多个程序同时执行的能力。在os中，引入进程的目的是使程序能够并发执行。</p>
<blockquote>
<p>并发和并行的区别？</p>
<ul>
<li>并发：同一时间间隔。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此微观上这些程序仍是分时交替执行的。操作系统的并发性是通过分时得以实现的。</li>
<li>并行：同一时刻</li>
</ul>
</blockquote>
</li>
<li><p><strong>共享性</strong>：系统中的硬件和软件资源不再为某个程序所独占，而是供多个用户共同使用（包括互斥共享（如<em>打印机，某些变量，队列等一段时间只能供一个作业使用的资源</em>）和同时访问（如<em>可重入代码，磁盘等</em>），后者作业访问资源的顺序不会影响访问的结果）</p>
</li>
<li><p><strong>虚拟性</strong>：把一个物理上的实体变为若干个逻辑上的对应物</p>
</li>
<li><p><strong>异步性</strong>：在多道程序环境中，由于资源等因素的限制，程序（进程）走走停停，以不可预知的速度向前推进</p>
</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F//image-20200827214637040.png" alt="image-20200827214637040"></p>
<h2 id="2、操作系统的功能"><a href="#2、操作系统的功能" class="headerlink" title="2、操作系统的功能"></a>2、操作系统的功能</h2><h3 id="1-操作系统是计算机资源的管理者"><a href="#1-操作系统是计算机资源的管理者" class="headerlink" title="1. 操作系统是计算机资源的管理者"></a>1. 操作系统是计算机资源的管理者</h3><ol>
<li><strong>处理器管理</strong>：对处理器的分配和和运行（以进程为单位）实施有效的管理，包括<code>进程控制（负责进程的创建，撤销以及状态转换），进程同步（对并发执行的进程进行协调），进程通信（负责进程间的信息交流），进程调度（按一定算法进行处理器分配）</code> </li>
<li><strong>存储器管理</strong>：对内存进行分配，保护和扩充，包括<code>内存分配（按一定策略为每道程序分配内存），内存保护（保证各程序在自己的内存区域内运行而不相互干扰），内存扩充（为允许大型最作业或多作业的运行，必须借助虚拟存储技术去获得增加内存的效果）</code> </li>
<li><strong>文件管理</strong>：操作系统中负责信息管理的部分称为文件系统，文件管理的主要任务包括<code>文件存储空间的管理（存储空间的分配与回收），目录管理（提供按名存取的功能），文件操作管理（负责完成数据的读写），文件保护</code><br>用户接口：方便用户使用操作系统，包括<code>命令接口（包括联机命令接口和脱机命令接口），程序接口（也称系统调用），图形接口</code></li>
<li><strong>设备管理</strong>：对计算机系统内的所有设备进行管理。包括<code>设备分配（根据一定的设备分配原则对设备进行分配），设备传输控制（实现物理的输入输出操作），设备独立性（用户程序中的设备与实际使用的物理设备无关)</code> </li>
</ol>
<h3 id="2-提供用户与计算机之间的接口"><a href="#2-提供用户与计算机之间的接口" class="headerlink" title="2. 提供用户与计算机之间的接口"></a>2. 提供用户与计算机之间的接口</h3><h3 id="3-扩充机器"><a href="#3-扩充机器" class="headerlink" title="3. 扩充机器"></a>3. 扩充机器</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F//image-20200827190507593.png" alt="image-20200827190507593"></p>
<h2 id="3、中断和异常"><a href="#3、中断和异常" class="headerlink" title="3、中断和异常"></a>3、中断和异常</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F//image-20200830115528580.png" alt="image-20200830115528580"></p>
<h3 id="1-中断的引入——为了支持CPU和设备之间的并行操作"><a href="#1-中断的引入——为了支持CPU和设备之间的并行操作" class="headerlink" title="1. 中断的引入——为了支持CPU和设备之间的并行操作"></a>1. 中断的引入——为了支持CPU和设备之间的并行操作</h3><p>中断也称外中断，<u>指来自CPU执行指令以外的事件的发生</u>，如设备发出的I/O结束中断、时钟中断 等。这一类中断通常是与当前执行的指令无关的事件。 </p>
<h3 id="2-异常的引入——表示CPU执行指令本身时出现的问题"><a href="#2-异常的引入——表示CPU执行指令本身时出现的问题" class="headerlink" title="2. 异常的引入——表示CPU执行指令本身时出现的问题"></a>2. 异常的引入——表示CPU执行指令本身时出现的问题</h3><p>异常也称内中断、例外或陷入，<u>指源自CPU执行指令内部的事件</u>，如程序的非法操作码、地址越 界、算术溢出、缺页异常等。对异常的处理一般要依赖与当前程序的运行现场，不能被屏蔽。 </p>
<h3 id="3-中断和异常的联系与区别"><a href="#3-中断和异常的联系与区别" class="headerlink" title="3. 中断和异常的联系与区别"></a>3. 中断和异常的联系与区别</h3><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006112017650.png" alt="image-20201006112017650" style="zoom:80%;" />



<h3 id="4-中断执行的流程"><a href="#4-中断执行的流程" class="headerlink" title="4. 中断执行的流程"></a>4. 中断执行的流程</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F//image-20200830104258275.png" alt="image-20200830104258275"></p>
<h2 id="4、系统调用是什么？"><a href="#4、系统调用是什么？" class="headerlink" title="4、系统调用是什么？"></a>4、系统调用是什么？</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F//image-20200830114156802.png" alt="image-20200830114156802"></p>
<ul>
<li><strong>系统调用：是操作系统为应用程序使用内核功能所提供的接口。</strong></li>
<li>系统调用的目的：申请系统服务。OS不允许用户直接操作各种硬件资源，因此用户只能通过系统调用的方式来请求内核为其服务，间接地使用各种资源。</li>
</ul>
<p>操作系统为用户态进程与硬件设备进行交互提供了一组接口——系统调用:</p>
<ol>
<li><p>把用户从底层的硬件编程中解放了出来;</p>
</li>
<li><p>极大地提高了系统的安全性使用户程序具有可移植性；用户程序与具体硬件 已经被抽象接口所替代。</p>
</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F//image-20200830104510608.png" alt="image-20200830104510608"></p>
<h3 id="与一般过程调用有何区别？"><a href="#与一般过程调用有何区别？" class="headerlink" title="与一般过程调用有何区别？"></a>与一般过程调用有何区别？</h3><p>一般过程调用工作在用户态，通过过程调用语句实现，可以无限制嵌套调用；</p>
<p>系统调用运行在核心态，通过访管中断进入，不可以嵌套调用。</p>
<h3 id="指令是内核态的多还是用户态的多？"><a href="#指令是内核态的多还是用户态的多？" class="headerlink" title="指令是内核态的多还是用户态的多？"></a>指令是内核态的多还是用户态的多？</h3><p>内核态，CPU可以访问内存所有数据，用户态下是受限访问，只能访问自己空间中的内存</p>
<h3 id="中断和系统调用的区别"><a href="#中断和系统调用的区别" class="headerlink" title="中断和系统调用的区别:"></a>中断和系统调用的区别:</h3><ol>
<li><p>中断是由外设产生, 无意的, 被动的</p>
<p>系统调用是由应用程序请求操作系统提供服务产生, 有意的, 主动的。要从用户态通过中断进入内核态。（联系）</p>
</li>
<li><p>中断过程：中断请求 中断响应 断点保护 执行中断服务程序 断点恢复 中断返回</p>
<p>系统调用过程：应用程序在用户态执行时请求系统调用，中断，从用户态进入内核态，在内核态执行相应的内核代码。</p>
</li>
</ol>
<h3 id="中断之后保存什么？"><a href="#中断之后保存什么？" class="headerlink" title="中断之后保存什么？"></a>中断之后保存什么？</h3><p>保存pc, psw, 通用寄存器。Pc程序计数器program count，存放下一条指令所在的单元的地址。Psw，program status word程序状态字，指处理器的状态。</p>
<h2 id="5、操作系统的发展与分类"><a href="#5、操作系统的发展与分类" class="headerlink" title="5、操作系统的发展与分类"></a>5、操作系统的发展与分类</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200827215158997.png" alt="image-20200827215158997"></p>
<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829172422636.png" alt="image-20200829172422636"></p>
<h2 id="1、进程与线程的基本概念"><a href="#1、进程与线程的基本概念" class="headerlink" title="1、进程与线程的基本概念"></a>1、进程与线程的基本概念</h2><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong></p>
<h3 id="进程的组成（进程映像-进程实体）"><a href="#进程的组成（进程映像-进程实体）" class="headerlink" title="进程的组成（进程映像 / 进程实体）"></a>进程的组成（进程映像 / 进程实体）</h3><ul>
<li><p>程序段：进程运行的程序的代码进程中能被进程调度程序调度到CPU上执行的代码段</p>
</li>
<li><p>数据段：存储程序运行过程中相关的一些数据</p>
</li>
<li><p>PCB：每一个进程都有一个PCB，记录进程的状态和控制进程的全部信息。既能标识进程存在（唯一标识），又能刻画执行瞬间的数据结构 。系统通过PCB对进程进行控制和管理。</p>
<p>【为什么PCB是进程存在的唯一标志？】</p>
<blockquote>
<p> 在系统调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存地址，找到其程序和数据</p>
<p> 进程在执行过程中，当需要和与之合作的进程实现同步，通信或访问文件时，也都需要访问PCB</p>
<p> 当程序由于某种原因暂停执行时，又需要将其断点的处理机环境保存在PCB中</p>
</blockquote>
</li>
</ul>
<h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200828090515446.png" alt="image-20200828090515446"></p>
<blockquote>
<p>就绪态和阻塞态的区别？</p>
<ul>
<li>就绪态：指进程进缺少处理机，只要获得处理机资源就立即执行。</li>
<li>阻塞态：指进程需要 其他资源（除了处理机）或  等待某事件发生。</li>
</ul>
<p>之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地由运行态转换到就绪态的。</p>
<p>而其它资源（如外设）的使用和分配 或 某一事件的发生（I/O操作的完成）对应的时间相对来说很长，进程由运行态转换为阻塞态的次数也相对较少。</p>
</blockquote>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20201006092312841.png" alt="image-20201006092312841"></p>
<h3 id="进程与程序的关系"><a href="#进程与程序的关系" class="headerlink" title="进程与程序的关系"></a>进程与程序的关系</h3><ul>
<li>进程是动态的，程序是静态的</li>
<li>进程是暂时的，进程是永久的</li>
<li>进程与程序的组成不同<ul>
<li>进程是竞争计算机资源的基本单位</li>
<li>程序是一组有序的指令集合</li>
</ul>
</li>
<li>进程具有并发性，而程序没有</li>
<li>通过多次执行，一个程序可以产生多个不同的进程；通过调用关系，一个进程可以执行多个程序。进程可以创建其他进程，而程序不能形成新的程序。进程与程序之间不是一一对应的，一个进程可以执行多个程序，但一个进程只能对应一个程序。</li>
</ul>
<h3 id="进程同步有哪几种机制"><a href="#进程同步有哪几种机制" class="headerlink" title="进程同步有哪几种机制"></a>进程同步有哪几种机制</h3><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p>
<h3 id="进程间通信IPC的几种方式"><a href="#进程间通信IPC的几种方式" class="headerlink" title="进程间通信IPC的几种方式"></a>进程间通信IPC的几种方式</h3><h4 id="低级通信方式PV"><a href="#低级通信方式PV" class="headerlink" title="低级通信方式PV"></a>低级通信方式PV</h4><p>我们通过信号量机制, 来解决进程同步和互斥的问题.而pv操作是可以访问信号量的两个原语. P<a href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD">原语</a>操作的动作是：S减1；若S减1后仍大于或等于零，则进程继续执行；若S减1后小于零，则该进程被阻塞后进入等待队列。</p>
<p>V原语操作的动作是：S加1；若相加结果大于零，则进程继续执行；若相加结果小于或等于零，则从待队列中唤醒一等待进程.</p>
<h4 id="高级通信方式"><a href="#高级通信方式" class="headerlink" title="高级通信方式"></a>高级通信方式</h4><ol>
<li><p>共享内存 </p>
<p>顾名思义，共享内存就是两个进程同时共享一块内存，然后在这块内存上的数据可以共同修改和 读取，达到通信的目的。 </p>
</li>
<li><p>无名管道 </p>
<p>无名管道是半双工的通信方式；并且只能在具有亲缘关系的进程之间使用（亲缘关系是指进程间 的父子关系，兄弟关系等），具有亲缘关系的进程在创建时同时拥有一个无名管道的句柄，可以 进行读写；无名管道不存在磁盘节点，只存在与内存中用完即销毁。 </p>
</li>
<li><p>命名管道 </p>
<p>命名管道也是半双工的通信方式；可以在不具有亲缘关系的进程间通信；有名管道存在磁盘节 点，有对应的FIFO文件，凡是可以访问该路径的文件的进程均可以进行通信。 </p>
</li>
<li><p>消息队列</p>
<p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信 息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 </p>
</li>
<li><p>套接字 </p>
<p>套接字是网络编程的api，通过套接字可以不同的机器间的进程进行通信，常用于客户端进程和服 务器进程的通信。 </p>
</li>
<li><p>信号 </p>
<p>信号是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中 发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原 始机制。一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等） 都有可能产生一个信号。Shell也使用信号向它的子进程发送作业控制信号。</p>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a>线程的定义</h3><ul>
<li><p>“轻量级进程”</p>
</li>
<li><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200828095244971.png" alt="image-20200828095244971"></p>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ul>
<li>用户级线程：不依赖于操作系统核心，线程管理（现成的创建、撤销和切换等）的所有工作都有应用程序完成，内核意识不到线程的存在。</li>
<li>内核级线程：<strong>依赖于内核</strong>，线程管理的所有工作都有内核完成。应用程序没有进行线程管理的代码，只有一个到被内核级线程的编程接口。内核为进程及起内部的每个进程维护上下文信息，调度也在内核基于线程架构的基础上完成。</li>
</ul>
<h3 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h3><ul>
<li>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li>
<li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
</ul>
<h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><blockquote>
<ul>
<li><p>引入进程的目的：为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量。</p>
<p>多道程序同时运行的过程，是一个动态的过程，而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程序内部的执行情况，即无法从程序的字面上看出他何时停顿，中止，也无法看出它与其他执行程序的关系，因此，程序这个静态概念已不能如实反映程序的并发执行的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。</p>
</li>
<li><p>引入线程的目的：为了减小程序在并发执行时所付出的时空开销，提高OS的并发性能。</p>
</li>
</ul>
</blockquote>
<ol>
<li><p><strong>调度。</strong>引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位；在同一进程中，线程的切换不会引起进程切换；在不同进程中进行线程切换，将引起进程切换。</p>
</li>
<li><p><strong>拥有资源。</strong>进程始终是拥有资源的基本单位；线程不拥有系统资源，但可以访问其隶属进程的系统资源</p>
</li>
<li><p><strong>并发性。</strong>引入线程的操作系统中，不仅进程之间可以并发执行，而且同一进程内的多个线程之间也可以并发执行，这使得操作系统具有更好的并发性，提高了系统的资源吞吐量。</p>
</li>
<li><p><strong>系统开销。</strong>引入线程后，线程之间的切换开销很小，而且由于同一进程内的多个线程共享进程的地址空间，因此多线程之间的同步与通信容易实现</p>
</li>
<li><p><strong>通信方面。</strong>进程间通信IPC需要进程同步和互斥手段的辅助，以保正数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p>
</li>
</ol>
<blockquote>
<p>【进程的特征】</p>
<ul>
<li>动态性：进程是程序的一次执行过程，是动态地产生，变化和消亡的 </li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行，独立获得资源，独立接受调度的基本单位</li>
<li>异步性：各进程按各自独立的，不可预知的速度向前推进</li>
<li>结构性：每个进程都会配置一个PCB，结构上看，进程由数据段，程序段，PCB组成</li>
</ul>
<p>【导致进程创建的事件有哪些？】</p>
<ul>
<li><p>用户登录。在分时系统中，用户在终端输入登录信息，系统检测通过后就为该终端用户建立新进程并插入到就绪队列</p>
</li>
<li><p>作业调度。在批处理系统中，当作业调度程序按照一定的算法调度到某个作业时，将该作业装入内存，并为其分配资源并创建进程，并插入到就绪队列</p>
</li>
<li><p>请求服务。基于进程的需要，由其自身创建一个新进程并完成特定任务</p>
</li>
</ul>
<p>【创建进程时，操作系统需要完成的主要工作是什么？】</p>
<ul>
<li><p>先向系统申请一个空闲PCB，并指定唯一的进程标识符（PID）</p>
</li>
<li><p>为新进程分配必要的资源</p>
</li>
<li><p>将新进程的PCB初始化。为新进程的PCB填入进程名，家族信息，程序数据地址，优先级等信息</p>
</li>
<li><p>将新进程的PCB插入到就绪队列</p>
</li>
</ul>
<p>【导致进程撤销的事件有哪些？】</p>
<p>进程正常结束，进程异常结束以及外界干预等</p>
<p>【撤销一个进程时，操作系统主要完成的工作是什么？】</p>
<ul>
<li><p>先从PCB集合中找到被撤销进程的PCB</p>
</li>
<li><p>若被撤销进程正处于执行状态，则应立即停止该进程的执行，设置重新调度标识，以便进程重新后将处理器分配给其他进程</p>
</li>
<li><p>对后一种撤销策略，若被撤销进程有子孙进程，还应将该进程的子孙进程撤销</p>
</li>
<li><p>回收被撤销进程所占有的资源，或者归还给父进程，或者归还给系统。最后，回收其PCB</p>
</li>
</ul>
<p>【阻塞一个进程时，操作系统主要完成的工作是什么？】</p>
<ul>
<li><p>首先停止当前进程的运行。因该进程正处于执行状态，故应中断处理器</p>
</li>
<li><p>保存该进程的CPU现场以便之后可以重新调用该进程并从中断点开始执行</p>
</li>
<li><p>停止运行该进程，将进程状态由执行状态改为阻塞状态，然后将该进程插入到相应事件的等待队列中</p>
</li>
<li><p>转到进程调度程序，从就绪队列中选择一个新的进程投入运行</p>
</li>
</ul>
<p>【唤醒一个进程时，操作系统主要完成的工作是什么？】</p>
<ul>
<li><p>将被唤醒进程从相应的等待队列中移出</p>
</li>
<li><p>将状态改为就绪并插入相应的就绪队列</p>
</li>
</ul>
<p>【简述进程上下文切换的过程】==【切换进程时，操作系统主要完成的工作是什么？】</p>
<ul>
<li><p>保存处理及上下文，包括程序计数器和其他寄存器</p>
</li>
<li><p>更新PCB信息</p>
</li>
<li><p>把进程的PCB移入相应队列，如就绪，某事件的阻塞队列</p>
</li>
<li><p>选择另一个进程执行，更新其PCB</p>
</li>
<li><p>更新内存管理的数据结构</p>
</li>
<li><p>恢复处理器上下文</p>
</li>
</ul>
<p>【进程与作业的关系】</p>
<p>作业是用户向计算机提交任务的任务实体，而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位</p>
<p>一个作业可由一个或多个进程组成，但一个进程不能构成多个作业</p>
<p>作业的概念主要用在批处理系统中，而进程的概念则几乎用在所有的多道程序系统中</p>
</blockquote>
<h2 id="2、进程调度的基本概念、调度方式、调度算法"><a href="#2、进程调度的基本概念、调度方式、调度算法" class="headerlink" title="2、进程调度的基本概念、调度方式、调度算法"></a>2、进程调度的基本概念、调度方式、调度算法</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IMG_2285(20200829-102509).PNG" alt="IMG_2285(20200829-102509)"></p>
<h3 id="进程调度的概念"><a href="#进程调度的概念" class="headerlink" title="进程调度的概念"></a>进程调度的概念</h3><ul>
<li><strong>系统按照某种算法动态地把处理器分配给就绪队列中的某个进程，以便使之执行</strong></li>
</ul>
<h3 id="操作系统中的3级调度"><a href="#操作系统中的3级调度" class="headerlink" title="操作系统中的3级调度"></a>操作系统中的3级调度</h3><blockquote>
<p> 高级调度，又称作业调度，按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程，发生频率最低</p>
<p> 中级调度，又称内存调度，按照某种规则，从挂起队列中选择合适的进程将其数据调回内存，发生频率中等</p>
<p> 低级调度，又称进程调度，按照某种规则，从就绪队列中选择一个进程为其分配处理机，发生频率最高</p>
</blockquote>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200828152139261.png" alt="image-20200828152139261"></p>
<h3 id="进程调度的方式-CPU调度算法中抢占式调度和非抢占式调度有何区别？"><a href="#进程调度的方式-CPU调度算法中抢占式调度和非抢占式调度有何区别？" class="headerlink" title="进程调度的方式/CPU调度算法中抢占式调度和非抢占式调度有何区别？"></a>进程调度的方式/CPU调度算法中抢占式调度和非抢占式调度有何区别？</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200828161817900.png" alt="image-20200828161817900"></p>
<ul>
<li><p>抢占方式，当一个进程正在处理器上运行时，若有更高优先级的进程进入就绪队列，则立即暂停执行当前进程，将处理器分配给新进程。可优先处理紧急进程，也可实现让各进程按时间片轮流执行，适用于分时操作系统，实时操作系统</p>
</li>
<li><p>非抢占方式，当一个进程正在处理器上运行时，即使有更高优先级的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或者因发生某种事件而进入完成或者阻塞状态时，才把处理器分配个新进程。实现简单，开销小，但无法处理紧急任务，适用于早期批处理系统</p>
</li>
</ul>
<h3 id="在交互式系统中，非剥夺是不是一个好的策略？为什么？"><a href="#在交互式系统中，非剥夺是不是一个好的策略？为什么？" class="headerlink" title="在交互式系统中，非剥夺是不是一个好的策略？为什么？"></a>在交互式系统中，非剥夺是不是一个好的策略？为什么？</h3><p>在分时系统中不剥夺并不是一个好的策略。因为在分时系统中，除了交互性以外，及时性是很重要的性能因素。当一个作业被阻塞后，CPU就完全空闲了，别的用户的及时性就无法保证了，而完全可以把这些时间分配给别的作业运行。以提高整体的吞吐量。</p>
<h3 id="调度算法的评级指标"><a href="#调度算法的评级指标" class="headerlink" title="调度算法的评级指标"></a>调度算法的评级指标</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200901161312189.png" alt="image-20200901161312189"></p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20201006111857860.png" alt="image-20201006111857860"></p>
<ul>
<li><p>先来先服务：先请求CPU的进程先分配到CPU</p>
</li>
<li><p>短作业优先：平均等待时间最短，但难以知道下一个CPU区间长度</p>
</li>
<li><p>优先级调度：分为抢占式和非抢占式，优先级相同时，通常按照先来先服务或者短作业优先的顺序执行</p>
</li>
<li><p>时间片轮转：各进程执行一个时间片</p>
</li>
<li><p>高响应比优先：响应比=（等待时间+运行时间）/运行时间</p>
</li>
<li><p>多级反馈队列调度</p>
<p>与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p>
</li>
</ul>
<blockquote>
<p><u>优先级调度算法</u>按照任务的优先级进行调度，对于更紧急的任务会有更高的优先级，适合实时操作系统。</p>
<p><u>高响应比优先调度算法，时间片轮转调度算法，多级反馈队列调度算法</u> 都能保证每个任务在一定时间内分到时间片，并轮流占用CPU，适合分时操作系统。</p>
</blockquote>
<h3 id="为什么要进行处理机的调度？"><a href="#为什么要进行处理机的调度？" class="headerlink" title="为什么要进行处理机的调度？"></a>为什么要进行处理机的调度？</h3><p>答：若没有处理机的调度，就意味着要等到当前运行的进程执行完毕后，下一个进程才能执行，而实际情况中，进程时常需要等待一些外部设备的输入，而外部设备的速度与处理机相比是非常缓慢的，若让处理机总是等待外部设备，则对处理机的资源是一种极大的浪费。而引进处理机调度后，可在运行进程等待外部设备时，把处理机调度给其他进程，从而提高处理机的利用率。简单来说，就是<strong>为了合理地处理计算机的软/硬件资源</strong>。</p>
<blockquote>
<p>【引起进程调度的原因】</p>
<p>当前进程运行结束，包括任务完成而正常结束或者因出现错误而异常结束</p>
<p>当前运行进程因某种原因，如I/O请求，P操作，阻塞原语等从运行态变为阻塞态</p>
<p>执行完系统调用等系统程序后返回用户进程，这时可以看作系统进程执行完毕，从而可以调度一个新的用户进程</p>
<p>在采用抢占式调度方式的系统中，更高优先级的进程要求使用处理器，则使当前运行进程进入就绪队列</p>
<p>在分时系统中，分配给该进程的时间片已用完</p>
<p>【不能进行进程调度的情况】</p>
<p>处理中断的过程中。处理中断过程复杂，很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理器资源</p>
<p>在操作系统内核程序临界区中。进程进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放</p>
<p>在其他需要完全屏蔽中断的原子操作过程中。原子操作不可再分，不能进行进程切换</p>
</blockquote>
<h2 id="3、进程同步的基本概念、临界区、信号量、经典同步问题"><a href="#3、进程同步的基本概念、临界区、信号量、经典同步问题" class="headerlink" title="3、进程同步的基本概念、临界区、信号量、经典同步问题"></a>3、进程同步的基本概念、临界区、信号量、经典同步问题</h2><h3 id="为什么要引入进程同步的概念？"><a href="#为什么要引入进程同步的概念？" class="headerlink" title="为什么要引入进程同步的概念？"></a>为什么要引入进程同步的概念？</h3><p>答：在多道程序共同执行的条件下，进程与进程之间是并发执行的，不同进程之间存在不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p>
<h3 id="两种形式的制约关系：同步和互斥？"><a href="#两种形式的制约关系：同步和互斥？" class="headerlink" title="两种形式的制约关系：同步和互斥？"></a>两种形式的制约关系：同步和互斥？</h3><ul>
<li><p>同步：直接相互制约关系。多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消 息，获得消息之前进入阻塞态；</p>
</li>
<li><p>互斥：间接相互制约关系。多个进程在同一时刻只有一个进程能进入临界区</p>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829102854372.png" alt="image-20200829102854372"></p>
<blockquote>
<p> 临界资源：同时仅允许一个进程使用的资源</p>
<p> 临界区：进程中用于访问临界资源的代码，又称临界段</p>
</blockquote>
<h3 id="临界区互斥的要求-同步机制的4个准则"><a href="#临界区互斥的要求-同步机制的4个准则" class="headerlink" title="临界区互斥的要求/同步机制的4个准则"></a>临界区互斥的要求/同步机制的4个准则</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20201006101307403.png" alt="image-20201006101307403"></p>
<ul>
<li><strong>空闲让进</strong>：当没有进程处于临界区时，可以允许一个请求进入临界区的进程立即进入临界区</li>
<li><strong>忙则等待</strong>：当已有进程进入临界区时，其他师徒进入的进程必须等待</li>
<li><strong>有限等待</strong>：对要求访问临界区的进程，应在有限的时间内进入自己的临界区</li>
<li><strong>让权等待</strong>：当一个进程因为某些已有无法进入自己的临界区时，应释放处理器给其他进程</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829110504215.png" alt="image-20200829110504215"></p>
<blockquote>
<p>(1)整型信号量：未遵循让权等待</p>
<p>(2)记录型信号量（资源信号量），P&amp;V 操作主要用这个</p>
</blockquote>
<h3 id="经典IPC问题"><a href="#经典IPC问题" class="headerlink" title="经典IPC问题"></a>经典IPC问题</h3><blockquote>
<p> 生产者-消费者<br> 读者写者问题（读优先，读写公平，写优先）<br> 哲学家进餐<br> 理发师</p>
</blockquote>
<h3 id="什么是管程？"><a href="#什么是管程？" class="headerlink" title="什么是管程？"></a>什么是管程？</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829111335944.png" alt="image-20200829111335944"></p>
<p>管程是由<strong>一组局部变量</strong>、<strong>对局部变量进行操作的一组过程</strong>和<strong>对局部变量进行初始化的语句序列</strong>组成。<br>引入的原因是因为P/V操作太过分散，对它的<strong>维护很麻烦且容易造成死锁</strong>。<br>管程的特点是：</p>
<ol>
<li>管程的过程只能访问管程的局部变量，管程的局部变量只能由其过程来访问；</li>
<li>任何时刻只能有一个进程进入管程执行；</li>
<li>进程只能通过管程提供的过程入口进入管程。</li>
</ol>
<h2 id="4、死锁的基本概念、处理策略、死锁预防和死锁避免的算法、死锁检测"><a href="#4、死锁的基本概念、处理策略、死锁预防和死锁避免的算法、死锁检测" class="headerlink" title="4、死锁的基本概念、处理策略、死锁预防和死锁避免的算法、死锁检测"></a>4、死锁的基本概念、处理策略、死锁预防和死锁避免的算法、死锁检测</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829165839493.png" alt="image-20200829165839493"></p>
<h3 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h3><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829120015942.png" alt="image-20200829120015942"></p>
<h3 id="饥饿和死锁？"><a href="#饥饿和死锁？" class="headerlink" title="饥饿和死锁？"></a>饥饿和死锁？</h3><p>饥饿：指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。 </p>
<p>相同：二者都是因为竞争资源引起的。</p>
<p>差别：</p>
<ol>
<li><p>进入饥饿的进程可以只有一个，但是死锁必须大于等于两个；</p>
</li>
<li><p>出于饥饿状态的进程可以是一个就绪进程，但是死锁状态的进程必定是阻塞进程。</p>
</li>
</ol>
<h3 id="可剥夺资源与不可剥夺资源的区别"><a href="#可剥夺资源与不可剥夺资源的区别" class="headerlink" title="可剥夺资源与不可剥夺资源的区别"></a>可剥夺资源与不可剥夺资源的区别</h3><ul>
<li><p>可剥夺资源是指虽然资源占有者进程需要使用该资源，但另一个进程可以强行把该资源剥夺来归自己使用</p>
</li>
<li><p>不可剥夺资源是指除占有者进程不再需要使用该资源而主动释放资源，其他进程不可在资源占有者使用资源过程中强行剥夺</p>
</li>
</ul>
<h3 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h3><ul>
<li><p>系统资源不足（根本原因）（对不可剥夺资源的竞争）</p>
</li>
<li><p>进程推进顺序不当（P1拥有A申请B，P2拥有B申请A）</p>
</li>
</ul>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829121437044.png" alt="image-20200829121437044"></p>
<ul>
<li><p><strong>互斥条件</strong>：进程要求对所分配的资源进行排他性控制，即在一段时间内某种资源仅为一个进程所占有</p>
</li>
<li><p><strong>不剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，只能由获得该资源的进程主动释放</p>
</li>
<li><p><strong>请求和保持条件</strong>：也成部分分配条件，是指进程已经保持了至少一个资源，但又提出了新的资源请求，而在等待新的资源被分配的同时，又对已有资源保持占有</p>
</li>
<li><p><strong>循环等待条件</strong>：存在一种资源的循环等待链，而链中每一个进程已获得的资源同时被链中的下一个进程所请求</p>
</li>
</ul>
<h3 id="有什么方法解决死锁问题？（处理死锁的基本方法）"><a href="#有什么方法解决死锁问题？（处理死锁的基本方法）" class="headerlink" title="有什么方法解决死锁问题？（处理死锁的基本方法）"></a>有什么方法解决死锁问题？（处理死锁的基本方法）</h3><ol start="0">
<li><p>鸵鸟算法：视死锁不见</p>
</li>
<li><p>预防死锁：破坏死锁产生的4个必要条件中的一个或多个</p>
</li>
<li><p>避免死锁：在资源的动态分配过程中，用 某种方法(一些算法)去防止系统进入不安全状态，从而避免发生死锁。</p>
</li>
<li><p>检测死锁：若不加任何限制措施，系统可在为进程分配资源的同时，记录下来进程的请求和分配信息，然后按某种算法计算系统是否会发生死锁；</p>
</li>
<li><p>解除死锁：系统发生死锁时通常采用撤销进程或剥夺进程资源的方法使系统解除死锁。</p>
</li>
</ol>
<h3 id="死锁的预防（静态策略）"><a href="#死锁的预防（静态策略）" class="headerlink" title="死锁的预防（静态策略）"></a>死锁的预防（静态策略）</h3><ol>
<li><p>破坏互斥条件：允许多个进程同时访问资源，可行性不高</p>
</li>
<li><p>破坏不剥夺条件：对于一个已经获得了某些资源的进程，若新的资源请求不能立即得到满足，则它必须释放所拥有的全部资源，以后需要时再重新申请，实现复杂，可能导致部分工作失效，导致系统开销增大，导致饥饿</p>
</li>
<li><p>破坏请求和保持条件：运行之前一次行分配好所需要的全部资源，简单安全，但资源利用率低，可能导致饥饿</p>
</li>
<li><p>破坏循环等待条件：给资源编号，必须按照编号从小到大的顺序申请资源，不方便增加新设备，会造成资源浪费，用户编程麻烦</p>
</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829130743530.png" alt="image-20200829130743530"></p>
<h3 id="死锁的避免（动态策略）"><a href="#死锁的避免（动态策略）" class="headerlink" title="死锁的避免（动态策略）"></a>死锁的避免（动态策略）</h3><h4 id="什么是安全状态？"><a href="#什么是安全状态？" class="headerlink" title="什么是安全状态？"></a>什么是安全状态？</h4><p>安全状态是指系统按照某种进程顺序，为进程分配资源，使得每个进程都能获取所需的最大资源，并顺利完成。</p>
<p>当系统不安全时就是系统不一定是死锁状态，但是死锁状态一定是不安全状态。</p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>主要思想是避免系统进入不安全状态，在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先试行分配，并对分配后的新状态进行安全性检查。如果新状态安全，则正式分配上述资 源，否则拒绝分配上述资源。这样就保证系统始终处于安全状态，从而避免死锁现象的发生。</p>
<h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><p>系统状态为死锁的条件是：当且仅当g该状态下的资源分配图是不可完全简化的。</p>
<p>如果资源分配图是可以完全简化的（能消去所有的边），则没有死锁。</p>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><ul>
<li><p><strong>资源剥夺法</strong>：从其进程中抢占足够的资源给死锁的进程以解除其死锁状态</p>
</li>
<li><p><strong>撤销进程法</strong>：撤销一些进程，直到有足够的资源分配给其他进程，进程死锁状态</p>
</li>
<li><p><strong>进程回退法</strong>：让一个或多个进程回退到足以避免死锁的地步，进程回退时资源释放资源而不是被剥夺，要求系统保持进程的历史信息，设置还原点</p>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829130957970.png" alt="image-20200829130957970"></p>
<h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200901090309778.png" alt="image-20200901090309778"></p>
<h2 id="1、内存管理基本概念"><a href="#1、内存管理基本概念" class="headerlink" title="1、内存管理基本概念"></a>1、内存管理基本概念</h2><h4 id="内存管理的功能-存储器管理应具有的功能？"><a href="#内存管理的功能-存储器管理应具有的功能？" class="headerlink" title="内存管理的功能\存储器管理应具有的功能？"></a>内存管理的功能\存储器管理应具有的功能？</h4><ul>
<li><p>内存的分配与回收：实施内存的分配，回收系统或用户释放的内存空间。</p>
</li>
<li><p>地址变换：提供地址变换功能，将逻辑地址转换成物理地址。</p>
</li>
<li><p>内存扩充：借助于虚拟存储技术或其他自动覆盖技术，为用户提供比内存空间大的地址空间， 从逻辑 上扩充内存。</p>
</li>
<li><p>存储保护：保证进入内存的各道作业都在自己的存储空间内运行，互不干扰</p>
</li>
</ul>
<h4 id="将用户程序变为可在内存中执行的程序的步骤？"><a href="#将用户程序变为可在内存中执行的程序的步骤？" class="headerlink" title="将用户程序变为可在内存中执行的程序的步骤？"></a>将用户程序变为可在内存中执行的程序的步骤？</h4><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200831084249851.png" alt="image-20200831084249851"></p>
<ol start="0">
<li><p>编辑</p>
</li>
<li><p><strong>编译</strong>：由编译程序将用户源代码编译成若干目标模块 </p>
</li>
<li><p><strong>链接</strong>：由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的 装入模块。 </p>
</li>
<li><p><strong>装入</strong>：由装入程序将装入模块装入内存中运行。</p>
</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829200126647.png" alt="image-20200829200126647"></p>
<h4 id="链接的3种方式"><a href="#链接的3种方式" class="headerlink" title="链接的3种方式"></a>链接的3种方式</h4><ul>
<li><p><strong>静态链接</strong>：在程序运行之前，先把各个目标模块及所需库链接为一个完整的可执行程序，以后不再拆开</p>
</li>
<li><p><strong>装入时动态链接</strong>：将应用程序编译后所得到一组目标模块装入内存时采用边装入边链接的动态链接方式</p>
</li>
<li><p><strong>运行时动态链接</strong>：在程序执行中需要该目标模块时，才对这些模块进行链接，便于修改和更新，便于实现对目标模块的共享</p>
</li>
</ul>
<h4 id="程序装入的3种方式"><a href="#程序装入的3种方式" class="headerlink" title="程序装入的3种方式"></a>程序装入的3种方式</h4><ul>
<li><p><strong>绝对装入</strong>：编译时就知道程序将要驻留在内存中的物理地址，编译程序产生含有物理地址的目标代码，不适合多道程序设计</p>
</li>
<li><p><strong>可重定位装入</strong>：又称静态重定位，根据内存当前情况，将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，之后不再改变，适用于早期的多道批处理操作系统，容易实现，无需增加硬件地址变换机构，但要求为每个程序分配一个连续的存储区，而且在程序执行期间不能移动，不能再申请内存空间，难以做到程序和数据的共享</p>
</li>
<li><p><strong>动态运行时装入</strong>：又称动态重定位，允许程序运行时在内存中移动位置，把地址变换推迟到程序真正要执行时才进行，需要一个重定位寄存器的支持：物理地址=基址寄存器内容+逻辑地址</p>
</li>
</ul>
<p>【内存保护的方法】</p>
<blockquote>
<p> 界限寄存器方法，包括上、下界寄存器方法和基址和限长寄存器方法</p>
<p> 存储保护键方法,给每个存储块分配一个单独的保护键</p>
</blockquote>
<h2 id="2、内存交换及分页、分段、段页式内存分配管理"><a href="#2、内存交换及分页、分段、段页式内存分配管理" class="headerlink" title="2、内存交换及分页、分段、段页式内存分配管理"></a>2、内存交换及分页、分段、段页式内存分配管理</h2><h3 id="内存空间的分配与回收—-连续分配管理方式"><a href="#内存空间的分配与回收—-连续分配管理方式" class="headerlink" title="内存空间的分配与回收—-连续分配管理方式"></a>内存空间的分配与回收—-连续分配管理方式</h3><ol>
<li><p><strong>单一连续分配</strong></p>
<ul>
<li><p>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户 区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。 </p>
</li>
<li><p>这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。缺点是只能 用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。</p>
</li>
</ul>
</li>
<li><p><strong>固定分区分配</strong></p>
<p>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小 的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中,选择适 当大小的作业装入该分区，如此循环。 </p>
<p>固定分区分配在划分分区时，有两种不同的方法。 </p>
<ul>
<li><p>分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。 </p>
</li>
<li><p>分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。</p>
</li>
</ul>
</li>
<li><p><strong>动态分区分配</strong></p>
<p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内 存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进 程的需要。因此系统中分区的大小和数目是可变的。</p>
</li>
</ol>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><p>在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存 块给进程使用，这就是动态分区的分配策略，考虑以下几种算法：</p>
<ol>
<li><strong>首次适应(First Fit)算法</strong>：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能 满足要求的第一个空闲分区。 </li>
<li><strong>最佳适应(Best Fit)算法</strong>：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分 区。 </li>
<li><strong>最坏适应(Worst Fit)算法</strong>：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链 接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</li>
<li><strong>邻近适应(Next Fit)算法</strong>：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分 配内存时从上次查找结束的位置开始继续查找。</li>
</ol>
<h2 id="非连续分配管理"><a href="#非连续分配管理" class="headerlink" title="非连续分配管理"></a>非连续分配管理</h2><h3 id="基本分页-存储管理方式的优缺点"><a href="#基本分页-存储管理方式的优缺点" class="headerlink" title="基本分页 存储管理方式的优缺点"></a>基本分页 存储管理方式的优缺点</h3><ul>
<li><p>优点：内存利用率高，实现了离散分配，便于存储访问控制，无外部碎片</p>
</li>
<li><p>缺点：需要硬件支持（尤其是快表），内存访问效率下降，共享困难，有内部碎片</p>
</li>
</ul>
<h3 id="基本分段-存储管理方式的优缺点"><a href="#基本分段-存储管理方式的优缺点" class="headerlink" title="基本分段 存储管理方式的优缺点"></a>基本分段 存储管理方式的优缺点</h3><ul>
<li><p>优点：便于程序模块化处理和处理变换的数据结构，便于动态链接和共享，无内部碎片</p>
</li>
<li><p>缺点：与分页类似，需要硬件支持；为满足分段的动态增长和减少外部碎片，要采用拼接技术；分段的最大尺寸受到主存可用空间的限制；有外部碎片</p>
</li>
</ul>
<h3 id="分段与分页的区别"><a href="#分段与分页的区别" class="headerlink" title="分段与分页的区别"></a>分段与分页的区别</h3><ul>
<li><p>页是信息的物理单位，段是信息的逻辑单位；</p>
</li>
<li><p>分页的目的是系统管理所需，为了提高内存利用率；分段的目的是为了更好的满足用户的需要，实现地址共享</p>
</li>
<li><p>页的大小固定且由系统决定；段的长度不固定，段长由用户编写的程序决定</p>
</li>
<li><p>分页的地址空间是一维的；而分段的地址空间是二维的；</p>
</li>
<li><p>分页有内部碎片，无外部碎片；分段有外部碎片，无内部碎片</p>
</li>
</ul>
<h3 id="页式存储管理方式中设置快表的作用"><a href="#页式存储管理方式中设置快表的作用" class="headerlink" title="页式存储管理方式中设置快表的作用"></a>页式存储管理方式中设置快表的作用</h3><p>快表，又称联想寄存器(TLB)，时一种访问速度比内存快很多的高速缓存，用来存放最近访问过的页表项的副本，若快表命中，则只要访问一次高速缓存以及一次主存即可，这样就可以加速地址变换的速度，从而提高了查找的速度和指令执行效率</p>
<h3 id="什么是页表和快表，有什么作用？"><a href="#什么是页表和快表，有什么作用？" class="headerlink" title="什么是页表和快表，有什么作用？"></a>什么是页表和快表，有什么作用？</h3><p> 页表指出逻辑地址中的页号与所占主存块号的对应关系。</p>
<p>作用：页式存储管理在用动态重定位方式装入作业时，要利用页表做地址转换工作。快表就是存放在高速缓冲存储器的部分页表。它起页表相同的作用。由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表， 有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<h3 id="地址翻译的过程？"><a href="#地址翻译的过程？" class="headerlink" title="地址翻译的过程？"></a>地址翻译的过程？</h3><blockquote>
<p>TLB-&gt;页表（TLB不命中）-&gt;Cache-&gt;主存（Cache不命中）-&gt;外存</p>
</blockquote>
<h2 id="3、虚拟内存"><a href="#3、虚拟内存" class="headerlink" title="3、虚拟内存"></a>3、虚拟内存</h2><h3 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h3><ul>
<li><p>覆盖</p>
</li>
<li><p>交换</p>
</li>
</ul>
<ol>
<li><p>覆盖技术： 把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位，把程序执行时并不要 求同时 装入内存的覆盖组成一组，成为覆盖段，这个覆盖段分配到同一个存储区域，这个存储区 域成为覆盖区，它与覆盖段一一对应。覆盖段的大小由覆盖段中最大的覆盖来确定。（为了解决 内存容量太小的问题，打破了必须将一个程序全部信息装入内存后才能运行的限制） </p>
</li>
<li><p>交换技术： 把暂时不用的某个程序及数据部分从内存移到外存中去，以便腾出必要的内存空间；或者把指定 的程序或数据从外存读到相应的内存中，并将控制权交给他，让其在系统上运行的一种内存扩充 技术。处理器的中级调度就是采用交换技术。 </p>
</li>
<li><p>区别： </p>
</li>
</ol>
<p>① 与覆盖技术相比，交换技术不要求程序员给出的 程序段之间的覆盖结构；</p>
<p>② 交换技术主要在进程和作业之间进行，覆盖技术主要在同一个进程或作业中进行；</p>
<p>③ 覆盖技术只能覆盖于覆盖程序段无关的程序段，交换进程由换出和换入两个过程组成。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200901033503721.png" alt="image-20200901033503721"></p>
<h3 id="虚拟内存的特征"><a href="#虚拟内存的特征" class="headerlink" title="虚拟内存的特征"></a>虚拟内存的特征</h3><ul>
<li><p><strong>离散性</strong>：程序在内存中离散存储</p>
</li>
<li><p><strong>多次性</strong>：一个作业可以分成多次调入内存</p>
</li>
<li><p><strong>对换性</strong>：又称交换性，指作业在运行过程中可以换入换出</p>
</li>
<li><p><strong>虚拟性</strong>：从逻辑上扩充内存容量，用户可以使用的空间远大于实际内存容量</p>
</li>
</ul>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul>
<li><p>时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问，都集中在一个较短的时期内</p>
</li>
<li><p>空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的数据，都集中在一个较小的区域内</p>
</li>
</ul>
<h3 id="页面置换算法（决定应该换入-换出哪页）"><a href="#页面置换算法（决定应该换入-换出哪页）" class="headerlink" title="页面置换算法（决定应该换入/换出哪页）"></a>页面置换算法（决定应该换入/换出哪页）</h3><p>进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲时间时，就需要从内存中调入一页程序或数据，送入磁盘的对换区。</p>
<p>选择调出页面的算法就成为页面置换算法。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829211857819.png" alt="image-20200829211857819"></p>
<h4 id="1-最佳（OPT）置换算法"><a href="#1-最佳（OPT）置换算法" class="headerlink" title="1. 最佳（OPT）置换算法"></a>1. 最佳（OPT）置换算法</h4><p>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。 于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 即被淘汰页面是以后永不使用或最长时间内不再访问的页面。（往后看）</p>
<h4 id="2-先进先出（FIFO）置换算法"><a href="#2-先进先出（FIFO）置换算法" class="headerlink" title="2. 先进先出（FIFO）置换算法"></a>2. 先进先出（FIFO）置换算法</h4><p>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存 时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被 使用的可能性最大。 即优先淘汰最早进入内存的页面。（往前看）</p>
<h4 id="3-最近最久未使用（LRU）算法"><a href="#3-最近最久未使用（LRU）算法" class="headerlink" title="3. 最近最久未使用（LRU）算法"></a>3. 最近最久未使用（LRU）算法</h4><p>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推 测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访 问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的 页面予以淘汰。 即淘汰最近最长时间未访问过的页面。（往前看） </p>
<h4 id="4-时钟-CLOCK-置换算法"><a href="#4-时钟-CLOCK-置换算法" class="headerlink" title="4. 时钟(CLOCK)置换算法"></a>4. 时钟(CLOCK)置换算法</h4><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。 所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是 CLOCK算法的变体。 </p>
<p>该算法为每个页面设置一位访问位，将内存中的所有页面通过指针链成一个循环队列。由于该算法<strong>只有一位访问位</strong>，只能用它表示该页是否已经使用过，而置换时是将最近未使用过的页面换出去，所以把该算法称为最近未用算法。<br><strong>选择页置换的过程</strong>：<br>1.当某页被访问时，其访问位置“1”；<br>2.在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页；<br>3.在循环队列中检查下一个页面，直到访问到访问位为“0”的页面为止。</p>
<p>由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。</p>
<h3 id="抖动现象"><a href="#抖动现象" class="headerlink" title="抖动现象"></a>抖动现象</h3><p>刚刚换出的页面，过后不久又要访问，并且调入不久后又被调出，如此反复，使得系统把大部分的时间用在了页面的调入调出上，而几乎不能有效的工作</p>
<h1 id="第四章-文件管理"><a href="#第四章-文件管理" class="headerlink" title="第四章 文件管理"></a>第四章 文件管理</h1><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200829211145794.png" alt="image-20200829211145794"></p>
<h2 id="1、文件系统基础"><a href="#1、文件系统基础" class="headerlink" title="1、文件系统基础"></a>1、文件系统基础</h2><h3 id="文件的定义"><a href="#文件的定义" class="headerlink" title="文件的定义"></a>文件的定义</h3><p>文件是具有文件名的一组相关元素的集合，在文件系统中是一个最大的数据单位，它描述了一个对象集，每个文件都有一个文件名，用户通过文件名来访问文件</p>
<h3 id="文件的组成结构"><a href="#文件的组成结构" class="headerlink" title="文件的组成结构"></a>文件的组成结构</h3><p>数据项，文件系统中最低级的数据组织形式，包括基本数据项(<code>用于描述一个对象是的某种特性的一个值</code>)和组合数据项(<code>由多个数据项组合而成</code>)</p>
<p>记录，是指一组相关的数据项的集合，用于描述一个对象在某一方面的属性</p>
<p>文件，是指由创建者所定义的一组相关数据的集合，逻辑上可分为有结构文件和无结构文件</p>
<h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h3><blockquote>
<p> 名称。文件名唯一，以容易读取的形式保存</p>
<p> 标识符。系统内文件的唯一标签，对用户透明</p>
<p> 文件类型。被支持不同类型的文件系统使用</p>
<p> 文件位置。指向文件的指针</p>
<p> 文件的大小，建立时间，用户标识</p>
</blockquote>
<h3 id="文件的逻辑结构：顺序文件、索引文件和索引顺序文件"><a href="#文件的逻辑结构：顺序文件、索引文件和索引顺序文件" class="headerlink" title="文件的逻辑结构：顺序文件、索引文件和索引顺序文件"></a>文件的逻辑结构：顺序文件、索引文件和索引顺序文件</h3><p>3种有结构文件：</p>
<ul>
<li><p>顺序文件：定长记录的顺序文件，若物理上采用顺序存储则可以实现随机存取，若再能保证记录的顺序结构，则可实现快速检索，但因为文件存储要求连续的存储空间，所以会产生碎片，同时也不利于文件的动态扩充</p>
</li>
<li><p>索引文件：可以进行随机访问，易于文件的增删，但索引表的使用增加了存储空间的开销，并且索引表的查找策略对文件系统的影响很大</p>
</li>
<li><p>索引顺序文件：大大提高了了顺序存取速度，但仍需配置一个索引表，增加了存储开销</p>
</li>
</ul>
<p>FAT: 文件配置表file allocation table: 分配给文件的所有盘块号都放在该表中，记录了文件所在位置。</p>
<p>文件系统：负责管理和存储文件信息的软件机构，由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性</p>
<p>文件系统类型： Windows中有FAT32，NTFS，Linus中有ext2,ext3,ext4</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>【目录的功能】</p>
<blockquote>
<p> 实现按名存取</p>
<p> 提高检索速度</p>
<p> 允许文件同名</p>
<p> 允许文件共享</p>
</blockquote>
<h4 id="区分文件目录，目录文件"><a href="#区分文件目录，目录文件" class="headerlink" title="区分文件目录，目录文件"></a>区分文件目录，目录文件</h4><ul>
<li><p>文件目录：又称文件控制块，存储的是文件的管理信息，控制对象是单个文件；</p>
<ul>
<li><p>文件控制块FCB</p>
<p>文件控制块是用于保存文件属性信息的数据结构，至少包含以下信息：文件名，文件的结构（有结构的记录式文件or无格式的流式文件），文件的物理位置，存取控制信息，管理信息</p>
</li>
</ul>
</li>
<li><p>目录文件：存储的是若干个文件目录，控制对象是整个文件系统；</p>
<ul>
<li>目前广泛采用的树形目录结构，优点是：允许文件重命名，实现了文件分类。</li>
</ul>
</li>
</ul>
<p>【索引结点】</p>
<blockquote>
<p> FCB的改进，把除了文件名之外的其他文件描述信息都放到<code>索引结点（i结点）</code>，文件目录中的每个目录项仅由文件名和指向该文件i节点的指针构成；</p>
<p> 存放在磁盘上的使用节点称为<code>磁盘索引节点</code>，每个文件都有唯一的磁盘索引节点，主要包括以下内容：文件主标识符，文件类型，文件存取权限，文件物理地址，文件长度，文件链接计数，文件存取时间；</p>
<p> 存放在内存中的索引节点称为<code>内存索引节点</code>，主要包括以下内容：索引节点编号，状态，访问计数，逻辑设备号，链接指针</p>
</blockquote>
<p>【文件的目录结构】</p>
<blockquote>
<p> 单级目录结构，在整个文件系统中只建立一张目录表，每个文件占据其中的一个表目，易于实现，管理简单，但不允许文件重名，文件查找速度慢</p>
<p> 二级目录结构，将文件目录分为主文件目录和用户文件目录，允许文件重名，可获得较高的查找速度，但缺乏灵活性，用户不能对自己的文件进行分类</p>
<p> 多级目录结构，又称树形目录结构，，使用路径名来唯一标识文件，便于对文件分类，层次结构清晰，能更有效的进行文件的管理与保护，但查找文件时需按照路径名逐级访问中间节点，增加了磁盘访问次数，进而影响了查询速度</p>
<p> 无环图目录结构，实现了文件的共享，但使得系统的管理变得复杂</p>
</blockquote>
<p>（4）文件的访问类型及访问控制</p>
<p>【访问类型】</p>
<blockquote>
<p> 读，写，执行，添加，删除，列表清单</p>
</blockquote>
<p>【访问控制】</p>
<blockquote>
<p> 对不同的用户访问同一个文件采取不同的访问类型，访问控制通常有四种方法：</p>
<p> 访问控制矩阵，访问控制表和用户权限表都是采用某种数据结构来记录用户或用户组对每个文件的操作权限，而口令和密码是另一种访问控制方法，口令直接存储在系统内部，不够安全，密码方法的保密性强，节省存储空间，但编码和译码要花费一定时间</p>
</blockquote>
<h2 id="2、文件系统实现"><a href="#2、文件系统实现" class="headerlink" title="2、文件系统实现"></a>2、文件系统实现</h2><p>（1）文件系统层次结构</p>
<p>【文件的层次结构】</p>
<blockquote>
<p> 用户接口</p>
<p> 文件目录系统</p>
<p> 存取控制验证</p>
<p> 逻辑文件系统与文件信息缓冲区</p>
<p> 物理文件系统</p>
</blockquote>
<p>（2）目录实现</p>
<p>【目录的实现】</p>
<blockquote>
<p> 线性表</p>
<p> 散列表</p>
</blockquote>
<p>（3）文件实现</p>
<p>【外存分配方式】</p>
<blockquote>
<p> 静态分配：在文件建立时一次性分配所需的全部空间</p>
<p> 动态分配：根据动态增长的文件长度进行分配</p>
</blockquote>
<p>【连续分配】</p>
<blockquote>
<p> 最简单的磁盘空间分配策略，为文件分配连续的磁盘区域，保证了逻辑文件中的记录顺序与存储器中文件占用盘块顺序一致；优点是查找速度快（只需起始块号和文件大小），目录中关于文件物理存储位置的信息也比较简单，缺点是不方便文件拓展，容易产生碎片，需要定期进行存储空间的紧缩</p>
</blockquote>
<p>【链接分配】</p>
<blockquote>
<p> 分为隐式链接和显式链接。</p>
<p> 隐式链接（默认）：目录项中有指向索引顺序文件的第一块盘块和最后一块盘块的指针，此外每个盘块中都含有指向下一个盘块的指针；缺点是不支持随机访问，访问效率低下，并且由于其中任何一个盘块的指针错误都会导致后面的盘块的位置丢失；另外，指向下一个盘块的指针也需要耗费少量的存储空间；优点是方便文件拓展，不会有碎片问题，外存利用率高</p>
<p> 显式链接：把用于链接文件各物理块的指针显式地存放在一张表中，称为文件分配表(FAT)，一个磁盘仅设置一张FAT并且在开机时就将其读入内存且常驻内存；优点是既支持顺序访问，又支持随机访问，块号转换过程无需访问磁盘，因此访问速度较快；缺点是FAT需要占用一定的存储空间</p>
</blockquote>
<p>【索引分配】</p>
<blockquote>
<p> 系统为每个文件分配一个索引块，索引块中存放索引表，索引表的每个表项对应分配给该文件的一个物理块；优点是支持随机访问，无外部碎片，便于文件拓展，缺点是访存次数增加导致文件的存取速度降低（可以通过提前将索引表调入内存来解决），索引表本身需占用一定的存储空间</p>
</blockquote>
<p>【文件的存储空间管理】</p>
<blockquote>
<p> 空闲文件表<br> 空闲块链表<br> 位示图，保存在主存中</p>
<p> 成组链接法(UNIX的文件存储空间管理方法)，适用于大型文件系统</p>
</blockquote>
<h2 id="3、磁盘组织与管理"><a href="#3、磁盘组织与管理" class="headerlink" title="3、磁盘组织与管理"></a>3、磁盘组织与管理</h2><p>（1）磁盘的结构</p>
<blockquote>
<p> 引导控制块</p>
<p> 分区控制块</p>
<p> 目录结构</p>
<p> 文件控制块</p>
</blockquote>
<h3 id="磁盘调度算法有哪些？"><a href="#磁盘调度算法有哪些？" class="headerlink" title="磁盘调度算法有哪些？"></a>磁盘调度算法有哪些？</h3><h4 id="1-先来先服务算法（FCFS）First-Come-First-Service"><a href="#1-先来先服务算法（FCFS）First-Come-First-Service" class="headerlink" title="1. 先来先服务算法（FCFS）First Come First Service"></a>1. 先来先服务算法（FCFS）First Come First Service</h4><p>这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优 点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满 足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低 设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较 小。 </p>
<h4 id="2-最短寻道时间优先算法（SSTF）-Shortest-Seek-Time-First"><a href="#2-最短寻道时间优先算法（SSTF）-Shortest-Seek-Time-First" class="headerlink" title="2. 最短寻道时间优先算法（SSTF） Shortest Seek Time First"></a>2. 最短寻道时间优先算法（SSTF） Shortest Seek Time First</h4><p>该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时 间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的 服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况 下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。 </p>
<h4 id="3-扫描算法（SCAN）电梯调度"><a href="#3-扫描算法（SCAN）电梯调度" class="headerlink" title="3. 扫描算法（SCAN）电梯调度"></a>3. 扫描算法（SCAN）电梯调度</h4><p>扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例 如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当 前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换 向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁 道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称 为电梯调度算法。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间 变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但 由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。 </p>
<h4 id="4-循环扫描算法（CSCAN）"><a href="#4-循环扫描算法（CSCAN）" class="headerlink" title="4. 循环扫描算法（CSCAN）"></a>4. 循环扫描算法（CSCAN）</h4><p>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一 端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一 端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定 磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里 的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。</p>
<h1 id="第五章-输入输出管理"><a href="#第五章-输入输出管理" class="headerlink" title="第五章 输入输出管理"></a>第五章 输入输出管理</h1><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200901094051834.png" alt="image-20200901094051834"></p>
<p><strong>设备管理的主要任务就是控制设备和内存或处理及之间的数据传送。</strong></p>
<p>外设和内存之间的io控制方式有四种：</p>
<h2 id="I-O控制方式有哪些？"><a href="#I-O控制方式有哪些？" class="headerlink" title="I/O控制方式有哪些？"></a>I/O控制方式有哪些？</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200901094752112.png" alt="image-20200901094752112"></p>
<h3 id="1-程序-I-O-方式"><a href="#1-程序-I-O-方式" class="headerlink" title="1. 程序 I/O 方式"></a>1. 程序 I/O 方式</h3><p>早期的计算机系统中， 没有中断系统，所以CPU和I/O设备进行通信，传输数据时CPU速度远快于 I/O设备，于是CPU需要不断测试I/O设备，看其是否完成了传输。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111433996.png" alt="image-20201006111433996" style="zoom:80%;" />



<h3 id="2-中断驱动方式"><a href="#2-中断驱动方式" class="headerlink" title="2. 中断驱动方式"></a>2. 中断驱动方式</h3><p>当某进程要启动某个 I/O 设备工作时，便由 CPU 向相应的设备控制器发出一条 I/O 命令，然后立 即返回继续执行原来的任务。仅当输完一个数据时，才需 CPU 花费极短的时间去做些中断处理。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-操作系统/image-20201006111522762.png" alt="image-20201006111522762" style="zoom:80%;" />





<h3 id="3-DMA方式（直接存储器访问）"><a href="#3-DMA方式（直接存储器访问）" class="headerlink" title="3. DMA方式（直接存储器访问）"></a>3. DMA方式（直接存储器访问）</h3><p>在中断驱动方式中，io设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度还是受限，而DMA（直接存储器存取）的思想是：在I/O设备和内存之间开辟直接的数据交换通路，彻底”解放“CPU。</p>
<p>通过在I/O设备和内存之间开启一个可以直接传输数据的通路，采用DMA控制器来控制一个数据块 的传输，CPU只需在一个数据块传输开始阶段设置好传输所需的控制信息，并在传输结束阶段做 进一步处理。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20201006111541455.png" alt="image-20201006111541455"></p>
<h4 id="DMA控制方式与中断驱动方式的主要区别："><a href="#DMA控制方式与中断驱动方式的主要区别：" class="headerlink" title="DMA控制方式与中断驱动方式的主要区别："></a>DMA控制方式与中断驱动方式的主要区别：</h4><ul>
<li><p>主要区别是，中断驱动方式在每个数据需要传输时中断CPU，而DMA控制方式则是在所要求的传送的一批数据完成传送结束后才中断CPU。</p>
</li>
<li><p>中断驱动方式的数据传送，在中断处理时由CPU控制，而DMA控制方式是在DMA控制器的控制下完成的。</p>
</li>
</ul>
<h3 id="4-I-O通道控制方式"><a href="#4-I-O通道控制方式" class="headerlink" title="4. I/O通道控制方式"></a>4. I/O通道控制方式</h3><p>通道，独立于 CPU 的专门负责输入输出控制的处理机，它控制设备与内存直接进行数据交换。有自己的通道指令，这些指令由 CPU 启动，并在操作结束时向 CPU 发出中断信号。</p>
<p>直接程序控制方式和中断程序控制方式适合于低速设备的数据传送，而 DMA 方式虽然适合于高速设备的数据传送，但一个 DMA 控制器只能控制少量的同类设备，这远远不能满足大型计算机系统的需要。通常，一个大型计算机需要连接大量的高速和低速设备，通道控制方式可以满足这个要求。</p>
<h4 id="I-O通道与一般处理机的区别："><a href="#I-O通道与一般处理机的区别：" class="headerlink" title="I/O通道与一般处理机的区别："></a>I/O通道与一般处理机的区别：</h4><p>通道指令单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说 通道与CPU共享内存。</p>
<h4 id="I-O通道与DMA控制方式的区别："><a href="#I-O通道与DMA控制方式的区别：" class="headerlink" title="I/O通道与DMA控制方式的区别："></a>I/O通道与DMA控制方式的区别：</h4><ul>
<li><p>DMA方式需要CPU来控制传输的数据块大小，传输的内存位置，而通道方式中这些信息是由通道控制的。</p>
</li>
<li><p>每个DMA控制对应一台设备与内存传递数据，而一个通道可以龙之多台设备与内训的数据交换。</p>
</li>
</ul>
<h2 id="Spooling技术？"><a href="#Spooling技术？" class="headerlink" title="Spooling技术？"></a>Spooling技术？</h2><p>虚拟性是OS的四大特性之一。如果说可以通过多道程序技术将一台物理CPU虚拟为多台逻辑 CPU，从而允许多个用户共享一台主机，那么，通过SPOOling技术便可将一台物理I/O设备虚拟 为多台逻辑I/O设备，同样允许多个用户共享一台物理I/O设备。 </p>
<p>SPOOLing技术是对脱机输入、输出系统的模拟。相应地，SPOOLing系统必须建立在具有多道程 序功能的操作系统上，而且还应有高速随机外存的支持，这通常是采用磁盘存储技术。 </p>
<p>SPOOLing系统主要有以下三部分： </p>
<p>（1）输入井和输出井。这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设 备，用于暂存I/Q设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数 据。 </p>
<p>（2）输入缓冲区和输出缓冲区。为了缓和和CPU和磁盘之间速度不匹配的矛盾，在内存中要开辟 两个缓冲区；输入缓冲区和输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传 送到输入井。输出缓冲区用与暂存从输出井送来的数据，以后在传送给输出设备。 </p>
<p>（3）输入进程SPi 和输入进程SP0。这里利用两个进程来模拟脱机I/O时的外围控制机。其中，进 程SPi模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井， 当CPU需要输入数据时，直接从输入井读入内存；进程SP0模拟脱机输出时的外围控制机，把用户 要求输出的数据从先内存送到输出井，待输出设备空闲时，在将输出井中的数据经过输出缓冲区 送到输出设备上。 </p>
<h3 id="SPOOLing技术的特点："><a href="#SPOOLing技术的特点：" class="headerlink" title="SPOOLing技术的特点："></a>SPOOLing技术的特点：</h3><p>(1)提高了I/O速度。从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作，如同脱机操作 一样，提高了I/O速度，缓和了CPU与低速I/O设备速度不匹配的矛盾。</p>
<p>(2)将独占设备改造为共享设备。因为在SPOOLing系统的系统中，实际上并没为任何进程分配设 备，而知识在输入井或输出井中为进程分配一个存储区和建立一张I/O请求表。这样，便把独占设 备改造为共享设备。</p>
<p>(3)实现了虚拟设备功能。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这 一设备，从而实现了设备的虚拟分配。不过，该设备是逻辑上的设备。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础</title>
    <url>/2020/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1-神经网络组成？"><a href="#1-1-神经网络组成？" class="headerlink" title="1.1 神经网络组成？"></a>1.1 神经网络组成？</h2><p>神经网络类型众多，其中最为重要的是多层感知机。为了详细地描述神经网络，先从最简单的神经网络说起。</p>
<h3 id="1-1-1-感知机"><a href="#1-1-1-感知机" class="headerlink" title="1.1.1 感知机"></a>1.1.1 感知机</h3><p>多层感知机中的特征神经元模型称为感知机，由<em>Frank Rosenblatt</em>于1957年发明。</p>
<p>简单的感知机如下图所示：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3-1.png" alt="3-1"  />

<p>其中$x_1$，$x_2$，$x_3$为感知机的输入，其输出为：<br>$$<br>output = \left{<br>\begin{aligned}<br>0, \quad if \ \ \sum_i w_i x_i \leqslant threshold \<br>1, \quad if \ \ \sum_i w_i x_i &gt; threshold<br>\end{aligned}\right.<br>$$</p>
<p>假如把感知机想象成一个加权投票机制，比如 3 位评委给一个歌手打分，打分分别为$ 4 $分、$1$ 分、$-3 $分，这$ 3$ 位评分的权重分别是 $1、3、2$，则该歌手最终得分为 $4 \times 1 + 1 \times 3 + (-3) \times 2 = 1$ 。按照比赛规则，选取的 $threshold$ 为 $3$，说明只有歌手的综合评分大于$ 3$ 时，才可顺利晋级。对照感知机，该选手被淘汰，因为：</p>
<p>$$<br>\sum_i w_i x_i &lt; threshold=3, output = 0<br>$$</p>
<p>用 $-b$  代替 $threshold$，输出变为：</p>
<p>$$<br>output = \left { \begin{aligned}<br>0, \quad if \ \ \boldsymbol{w} \cdot \boldsymbol{x} + b \leqslant 0 \<br>1, \quad if \ \ \boldsymbol{w} \cdot \boldsymbol{x} + b &gt; 0<br>\end{aligned} \right.<br>$$</p>
<p>设置合适的  $\boldsymbol{x}$  和  $b$ ，一个简单的感知机单元的与非门表示如下：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3-2.png" alt="3-2"  />

<p>当输入为 $0$，$1$ 时，感知机输出为 $ 0 \times (-2) + 1 \times (-2) + 3 = 1$。</p>
<p>复杂一些的感知机由简单的感知机单元组合而成：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3-3.png" alt="3-3"  />



<h3 id="1-1-2-多层感知机"><a href="#1-1-2-多层感知机" class="headerlink" title="1.1.2 多层感知机"></a>1.1.2 多层感知机</h3><p>多层感知机由感知机推广而来，最主要的特点是有多个神经元层，因此也叫深度神经网络。相比于单独的感知机，多层感知机的第 $ i $ 层的每个神经元和第 $ i-1 $ 层的每个神经元都有连接。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3.1.1.5.png" alt="3.1.1.5" style="zoom:80%;" />

<p>输出层可以不止有$ 1$ 个神经元。隐藏层可以只有$ 1$ 层，也可以有多层。输出层为多个神经元的神经网络例如下图所示：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026142212607.png" alt="image-20201026142212607" style="zoom: 67%;" />



<h2 id="1-2-为什么使用深层表示"><a href="#1-2-为什么使用深层表示" class="headerlink" title="1.2 为什么使用深层表示?"></a>1.2 为什么使用深层表示?</h2><ol>
<li>深度神经网络是一种特征递进式的学习算法，浅层的神经元直接从输入数据中学习一些低层次的简单特征，例如边缘、纹理等。而深层的特征则基于已学习到的浅层特征继续学习更高级的特征，从计算机的角度学习深层的语义信息。</li>
<li>深层的网络隐藏单元数量相对较少，隐藏层数目较多，如果浅层的网络想要达到同样的计算结果则需要指数级增长的单元数量才能达到。</li>
</ol>
<h2 id="1-3-为什么深层神经网络难以训练？"><a href="#1-3-为什么深层神经网络难以训练？" class="headerlink" title="1.3 为什么深层神经网络难以训练？"></a>1.3 为什么深层神经网络难以训练？</h2><h3 id="1-3-1-梯度消失"><a href="#1-3-1-梯度消失" class="headerlink" title="1.3.1 梯度消失"></a>1.3.1 梯度消失</h3><p>梯度消失是指通过隐藏层从后向前看，梯度会变的越来越小，说明前面层的学习会显著慢于后面层的学习，所以学习会卡住，除非梯度变大。</p>
<p>梯度消失的原因受到多种因素影响，例如学习率的大小，网络参数的初始化，激活函数的边缘效应等。<strong>在深层神经网络中，每一个神经元计算得到的梯度都会传递给前一层，较浅层的神经元接收到的梯度受到之前所有层梯度的影响。如果计算得到的梯度值非常小，随着层数增多，求出的梯度更新信息将会以指数形式衰减，就会发生梯度消失。</strong></p>
<p>下图是不同隐含层的学习速率：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3-8.png" alt="3-8" style="zoom: 50%;" />

<h3 id="1-3-2-梯度爆炸"><a href="#1-3-2-梯度爆炸" class="headerlink" title="1.3.2 梯度爆炸"></a>1.3.2 梯度爆炸</h3><p>在深度网络或循环神经网络（Recurrent Neural Network, RNN）等网络结构中，梯度可在网络更新的过程中不断累积，变成非常大的梯度，导致网络权重值的大幅更新，使得网络不稳定；在极端情况下，权重值甚至会溢出，变为$NaN$值，再也无法更新。</p>
<h3 id="1-3-3-权重矩阵的退化导致模型的有效自由度减少。"><a href="#1-3-3-权重矩阵的退化导致模型的有效自由度减少。" class="headerlink" title="1.3.3 权重矩阵的退化导致模型的有效自由度减少。"></a>1.3.3 权重矩阵的退化导致模型的有效自由度减少。</h3><p>参数空间中学习的退化速度减慢，导致减少了模型的有效维数，网络的可用自由度对学习中梯度范数的贡献不均衡，随着相乘矩阵的数量（即网络深度）的增加，矩阵的乘积变得越来越退化。在有硬饱和边界的非线性网络中（例如 ReLU 网络），随着深度增加，退化过程会变得越来越快。Duvenaud等人2014年的论文里展示了关于该退化过程的可视化：</p>
<p>可以发现：随着深度的增加，输入空间（左上角所示）会在输入空间中的每个点处被扭曲成越来越细的单丝，只有一个与细丝正交的方向影响网络的响应。沿着这个方向，网络实际上对变化变得非常敏感。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3-9.jpg" alt="3-9" style="zoom: 67%;" />





<h2 id="1-4-深度学习和机器学习有什么不同？"><a href="#1-4-深度学习和机器学习有什么不同？" class="headerlink" title="1.4 深度学习和机器学习有什么不同？"></a>1.4 深度学习和机器学习有什么不同？</h2><p><strong>机器学习</strong>：利用计算机、概率论、统计学等知识，输入数据，让计算机学会新知识。机器学习的过程，就是训练数据去优化目标函数。</p>
<p><strong>深度学习</strong>：是一种特殊的机器学习，具有强大的能力和灵活性。它通过学习将世界表示为嵌套的层次结构，每个表示都与更简单的特征相关，而抽象的表示则用于计算更抽象的表示。</p>
<p>传统的机器学习需要定义一些手工特征，从而有目的的去提取目标信息， 非常依赖任务的特异性以及设计特征的专家经验。而深度学习可以从大数据中先学习简单的特征，并从其逐渐学习到更为复杂抽象的深层特征，不依赖人工的特征工程，这也是深度学习在大数据时代受欢迎的一大原因。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201025110330265.png" alt="image-20201025110330265" style="zoom:50%;" />



<h1 id="2-网络操作与计算"><a href="#2-网络操作与计算" class="headerlink" title="2. 网络操作与计算"></a>2. 网络操作与计算</h1><h2 id="2-1-前向传播与反向传播"><a href="#2-1-前向传播与反向传播" class="headerlink" title="2.1 前向传播与反向传播"></a>2.1 前向传播与反向传播</h2><p>神经网络的计算主要有两种：</p>
<ul>
<li><p>前向传播（foward propagation, FP）作用于每一层的输入，<strong>通过逐层计算得到输出结果；</strong></p>
</li>
<li><p>反向传播（backward propagation, BP）作用于网络的输出，<strong>通过计算梯度由深到浅更新网络参数。</strong></p>
</li>
</ul>
<p>使用反向传播算法的多层感知器又称为BP神经网络。BP算法是一个迭代算法，它的基本思想为：</p>
<ol>
<li>先计算每一层的状态和激活值，直到最后一层（即信号是前向传播的）</li>
<li>计算每一层的误差，误差的计算过程是从最后一层向前推进的（这就是反向传播算法名字的由来）；</li>
<li>更新参数（目标是误差变小）。</li>
<li>迭代前面两个步骤，直到满足停止准则（比如相邻两次迭代的误差的差别很小）。</li>
</ol>
<p>==详情请看这篇文章。第三章的3.2.5有详细介绍，到时候写bpboke记得参考！==</p>
<h2 id="2-2-如何计算神经网络的输出？"><a href="#2-2-如何计算神经网络的输出？" class="headerlink" title="2.2 如何计算神经网络的输出？"></a>2.2 如何计算神经网络的输出？</h2><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3.2.2.1.png" alt="3.2.2.1" style="zoom:80%;" />

<p>如上图，输入层有三个节点，我们将其依次编号为 1、2、3；隐藏层的 4 个节点，编号依次为 4、5、6、7；最后输出层的两个节点编号为 8、9。比如，隐藏层的节点 4，它和输入层的三个节点 1、2、3 之间都有连接，其连接上的权重分别为是 $ w_{41}, w_{42}, w_{43} $。</p>
<p>为了计算节点 4 的输出值，我们必须先得到其所有上游节点（也就是节点 1、2、3）的输出值。节点 1、2、3 是输入层的节点，所以，他们的输出值就是输入向量本身。按照上图画出的对应关系，可以看到节点 1、2、3 的输出值分别是 $ x_1, x_2, x_3 $。</p>
<p>$$<br>a_4 = \sigma(w^T \cdot a) = \sigma(w_{41}x_4 + w_{42}x_2 + w_{43}x_3 + w_{4b})<br>$$</p>
<p>其中 $ w_{4b} $ 是节点 4 的偏置项。</p>
<p>同样，我们可以继续计算出节点 5、6、7 的输出值 $ a_5, a_6, a_7 $。</p>
<p>计算输出层的节点 8 的输出值 $ y_1 $：</p>
<p>$$<br>y_1 = \sigma(w^T \cdot a) = \sigma(w_{84}a_4 + w_{85}a_5 + w_{86}a_6 + w_{87}a_7 + w_{8b})<br>$$</p>
<p>其中 $ w_{8b} $ 是节点 8 的偏置项。</p>
<p>同理，我们还可以计算出 $ y_2 $。这样输出层所有节点的输出值计算完毕，我们就得到了在输入向量 $ x_1, x_2, x_3, x_4 $ 时，神经网络的输出向量 $ y_1, y_2 $ 。这里我们也看到，输出向量的维度和输出层神经元个数相同。</p>
<h2 id="2-3-如何计算卷积神经网络输出值？"><a href="#2-3-如何计算卷积神经网络输出值？" class="headerlink" title="2.3 如何计算卷积神经网络输出值？"></a>2.3 如何计算卷积神经网络输出值？</h2><p>假设有一个 5*5 的图像，使用一个 3*3 的 filter 进行卷积，想得到一个 3*3 的 Feature Map，如下所示：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3.2.3.1.png" alt="3.2.3.1" style="zoom:80%;" />

<p>$ x_{i,j} $ 表示图像第  $ i $ 行第 $ j $ 列元素。$ w_{m,n} $ 表示 filter​ 第 $ m $ 行第 $ n $ 列权重。 $ w_b $ 表示 $filter$ 的偏置项。 表$a_i,_j$示 feature map 第 $ i$ 行第 $ j $ 列元素。 $f$ 表示激活函数，这里以$ ReLU$ 函数为例。</p>
<p>卷积计算公式如下：</p>
<p>$$<br>a_{i,j} = f(\sum_{m=0}^2 \sum_{n=0}^2 w_{m,n} x_{i+m, j+n} + w_b )<br>$$</p>
<p>当步长为 $1$ 时，计算 feature map 元素 $ a_{0,0} $ 如下：</p>
<p>$$<br>a_{0,0} = f(\sum_{m=0}^2 \sum_{n=0}^2 w_{m,n} x_{0+m, 0+n} + w_b )<br>= relu(w_{0,0} x_{0,0} + w_{0,1} x_{0,1} + w_{0,2} x_{0,2} + w_{1,0} x_{1,0} + \<br>w_{1,1} x_{1,1} + w_{1,2} x_{1,2} + w_{2,0} x_{2,0} + w_{2,1} x_{2,1} + w_{2,2} x_{2,2}) \<br>= 1 + 0 + 1 + 0 + 1 + 0 + 0 + 0 + 1 \<br>= 4<br>$$</p>
<p>其计算过程图示如下：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3.2.3.2.png" alt="3.2.3.2" style="zoom:80%;" />

<p>以此类推，计算出全部的Feature Map。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026111418991.png" alt="image-20201026111418991" style="zoom: 70%;" />

<p>当步幅为 2 时，Feature Map计算如下</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3.2.3.5.png" alt="3.2.3.5" style="zoom:80%;" />

<div class="note warning">
            <p>图像大小、步幅和卷积后的Feature Map大小是有关系的。它们满足下面的关系：</p><p>$$<br>W_2 = (W_1 - F + 2P)/S + 1\<br>H_2 = (H_1 - F + 2P)/S + 1<br>$$</p><p>其中:</p><ul><li> $ W_2 $ 是卷积后 Feature Map 的宽度；</li><li> $ W_1 $ 是卷积前图像的宽度；</li><li> $ F $ 是 filter 的宽度；</li><li> $ P $ 是 Zero Padding 数量，Zero Padding 是指在原始图像周围补几圈 $0$，如果 $P$ 的值是 $1$，那么就补 $1$ 圈 $0$；</li><li>$S$ 是步幅 Stride；</li><li> $ H_2 $ 卷积后 Feature Map 的高度；</li><li> $ H_1 $ 是卷积前图像的宽度。</li></ul>
          </div>

<blockquote>
<p>举栗：假设图像宽度 $ W_1 = 5 $，filter 宽度 $ F=3 $，Zero Padding $ P=0 $，步幅 $ S=2 $，$ Z $ 则</p>
<p>$$<br>W_2 = (W_1 - F + 2P)/S + 1<br>= (5-3+0)/2 + 1<br>= 2<br>$$</p>
<p>说明 Feature Map 宽度是2。同样，我们也可以计算出 Feature Map 高度也是 2。</p>
</blockquote>
<div class="note warning">
            <p>如果卷积前的图像深度为 $ D $，那么相应的 filter 的深度也必须为 $ D $。深度大于 1 的卷积计算公式：</p><p>$$<br>a_{i,j} = f(\sum_{d=0}^{D-1} \sum_{m=0}^{F-1} \sum_{n=0}^{F-1} w_{d,m,n} x_{d,i+m,j+n} + w_b)<br>$$</p><p>​    其中，$ D $ 是深度；$ F $ 是 filter 的大小；$ w_{d,m,n} $ 表示 filter 的第 $ d $ 层第 $ m $ 行第 $ n $ 列权重；$ a_{d,i,j} $ 表示 feature map 的第 $ d $ 层第 $ i $ 行第 $ j $ 列像素；其它的符号含义前面相同，不再赘述。</p>
          </div>



<p>每个卷积层可以有多个 filter。每个 filter 和原始图像进行卷积后，都可以得到一个 Feature Map。卷积后 Feature Map 的深度(个数)和卷积层的 filter 个数相同。</p>
<blockquote>
<p>举栗：下面的图示显示了包含两个 filter 的卷积层的计算。$7<em>7</em>3$ 输入，经过两个 $3<em>3</em>3$ filter 的卷积(步幅为 $2$)，得到了 $3<em>3</em>2$ 的输出。图中的 Zero padding 是 $1$，也就是在输入元素的周围补了一圈 $0$。</p>
</blockquote>
<p>以上就是卷积层的计算方法。这里面体现了<strong>局部连接和权值共享</strong>：每层神经元只和上一层部分神经元相连(卷积计算规则)，且 filter 的权值对于上一层所有神经元都是一样的。对于包含两个 $ 3 * 3 * 3 $ 的 fitler 的卷积层来说，其参数数量仅有 $ (3 * 3 * 3+1) * 2 = 56 $ 个，且参数数量与上一层神经元个数无关。与全连接神经网络相比，其参数数量大大减少了。</p>
<h2 id="2-4-如何计算-Pooling-层输出值输出值？"><a href="#2-4-如何计算-Pooling-层输出值输出值？" class="headerlink" title="2.4 如何计算 Pooling 层输出值输出值？"></a>2.4 如何计算 Pooling 层输出值输出值？</h2><p><strong>Pooling 层主要的作用是下采样，通过去掉 Feature Map 中不重要的样本，进一步减少参数数量。</strong></p>
<p>Pooling 的方法很多，最常用的是 Max Pooling。Max Pooling 实际上就是在 n*n 的样本中取最大值，作为采样后的样本值。下图是 2*2 max pooling：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/3.2.4.1.png" alt="3.2.4.1" style="zoom:80%;" />

<p>除了 Max Pooing 之外，常用的还有 Average Pooling ——取各样本的平均值。</p>
<div class="note warning">
            <p>对于深度为 $ D $ 的 Feature Map，各层独立做 Pooling，因此 Pooling 后的深度仍然为 $ D $。</p>
          </div>



<h2 id="2-5-神经网络更“深”有什么意义？"><a href="#2-5-神经网络更“深”有什么意义？" class="headerlink" title="2.5 神经网络更“深”有什么意义？"></a>2.5 神经网络更“深”有什么意义？</h2><p>前提：在一定范围内。</p>
<ul>
<li>在神经元数量相同的情况下，深层网络结构具有更大容量，分层组合带来的是指数级的表达空间，能够组合成更多不同类型的子结构，这样可以更容易地学习和表示各种特征。</li>
<li>隐藏层增加则意味着由激活函数带来的非线性变换的嵌套层数更多，就能构造更复杂的映射关系。</li>
</ul>
<h1 id="3-超参数"><a href="#3-超参数" class="headerlink" title="3. 超参数"></a>3. 超参数</h1><h2 id="3-1-什么是超参数？"><a href="#3-1-什么是超参数？" class="headerlink" title="3.1 什么是超参数？"></a>3.1 什么是超参数？</h2><p><strong>超参数</strong> : 在机器学习的上下文中，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要<u>对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。</u></p>
<p>超参数通常存在于：</p>
<ul>
<li>定义关于模型的更高层次的概念，如复杂性或学习能力。</li>
<li>不能直接从标准模型培训过程中的数据中学习，需要预先定义。</li>
<li>可以通过设置不同的值，训练不同的模型和选择更好的测试值来决定</li>
</ul>
<p>超参数具体来讲比如算法中的学习率（learning rate）、梯度下降法迭代的数量（iterations）、隐藏层数目（hidden layers）、隐藏层单元数目、激活函数（ activation function）都需要根据实际情况来设置，这些数字实际上控制了最后的参数和的值，所以它们被称作超参数。</p>
<h2 id="3-2-如何寻找超参数的最优值？"><a href="#3-2-如何寻找超参数的最优值？" class="headerlink" title="3.2 如何寻找超参数的最优值？"></a>3.2 如何寻找超参数的最优值？</h2><p>在使用机器学习算法时，总有一些难调的超参数。例如权重衰减大小，高斯核宽度等等。这些参数需要人为设置，设置的值对结果产生较大影响。常见设置超参数的方法有：</p>
<ol>
<li><p>猜测和检查：根据经验或直觉，选择参数，一直迭代。</p>
</li>
<li><p>网格搜索：让计算机尝试在一定范围内均匀分布的一组值。</p>
</li>
<li><p>随机搜索：让计算机随机挑选一组值。</p>
</li>
<li><p>贝叶斯优化：使用贝叶斯优化超参数，会遇到贝叶斯优化算法本身就需要很多的参数的困难。</p>
</li>
<li><p>MITIE方法，好初始猜测的前提下进行局部优化。它使用BOBYQA算法，并有一个精心选择的起始点。由于BOBYQA只寻找最近的局部最优解，所以这个方法是否成功很大程度上取决于是否有一个好的起点。在MITIE的情况下，我们知道一个好的起点，但这不是一个普遍的解决方案，因为通常你不会知道好的起点在哪里。从好的方面来说，这种方法非常适合寻找局部最优解。稍后我会再讨论这一点。</p>
</li>
<li><p>最新提出的LIPO的全局优化方法。这个方法没有参数，而且经验证比随机搜索方法好。</p>
</li>
</ol>
<h2 id="3-3-超参数搜索一般过程？"><a href="#3-3-超参数搜索一般过程？" class="headerlink" title="3.3 超参数搜索一般过程？"></a>3.3 超参数搜索一般过程？</h2><p>超参数搜索一般过程：</p>
<ol>
<li>将数据集划分成训练集、验证集及测试集。</li>
<li>在训练集上根据模型的性能指标对模型参数进行优化。</li>
<li>在验证集上根据模型的性能指标对模型的超参数进行搜索。</li>
<li>步骤 2 和步骤 3 交替迭代，最终确定模型的参数和超参数，在测试集中验证评价模型的优劣。</li>
</ol>
<p>其中，搜索过程需要搜索算法，一般有：网格搜索、随机搜过、启发式智能搜索、贝叶斯搜索。</p>
<h1 id="4-激活函数"><a href="#4-激活函数" class="headerlink" title="4.激活函数"></a>4.激活函数</h1><h2 id="4-1-为什么需要非线性激活函数？"><a href="#4-1-为什么需要非线性激活函数？" class="headerlink" title="4.1 为什么需要非线性激活函数？"></a>4.1 为什么需要非线性激活函数？</h2><h3 id="4-1-1-为什么需要激活函数？"><a href="#4-1-1-为什么需要激活函数？" class="headerlink" title="4.1.1 为什么需要激活函数？"></a>4.1.1 为什么需要激活函数？</h3><ol>
<li>激活函数对模型学习、理解非常复杂和非线性的函数具有重要作用。</li>
<li>激活函数可以引入非线性因素。如果不使用激活函数，则输出信号仅是一个简单的线性函数。线性函数一个一级多项式，线性方程的复杂度有限，从数据中学习复杂函数映射的能力很小。没有激活函数，神经网络将无法学习和模拟其他复杂类型的数据，例如图像、视频、音频、语音等。</li>
<li>激活函数可以把当前特征空间通过一定的线性映射转换到另一个空间，让数据能够更好的被分类。</li>
</ol>
<h3 id="4-1-2-为什么激活函数需要非线性函数？"><a href="#4-1-2-为什么激活函数需要非线性函数？" class="headerlink" title="4.1.2 为什么激活函数需要非线性函数？"></a>4.1.2 为什么激活函数需要非线性函数？</h3><ol>
<li>如果不用激励函数（其实相当于激励函数是f(x) = x），在这种情况下你每一层输出都是上层输入的线性函数，很容易验证，无论你神经网络有多少层，输出都是输入的线性组合，与只有一个隐藏层效果相当，这种情况就是多层感知机（MLP）了。</li>
<li>使用非线性激活函数 ，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。使用非线性激活函数，能够从输入输出之间生成非线性映射。</li>
</ol>
<h2 id="4-2-激活函数有哪些性质？"><a href="#4-2-激活函数有哪些性质？" class="headerlink" title="4.2 激活函数有哪些性质？"></a>4.2 激活函数有哪些性质？</h2><ol>
<li><p>非线性： 当激活函数是线性的，那么线性的组合还是线性，与单独一个线性分类器无异。这样就做不到用非线性来逼近任意函数，一个两层的神经网络就可以基本上逼近所有的函数。</p>
</li>
<li><p>可微性： 反向传播中，损失函数要对参数求偏导，如果激活函数不可微，那就无法使用梯度下降方法更新参数了。(ReLU只在零点不可微，但是梯度下降几乎不可能收敛到梯度为0)</p>
</li>
<li><p>单调性： 当激活函数是单调的时候，单层网络能够保证是凸函数；</p>
</li>
<li><p>非饱和性：饱和指在某些区间梯度接近于零，使参数无法更新。Sigmoid和tanh都有这个问题，而ReLU就没有，所以普遍效果更好。</p>
<blockquote>
<p>sigmoid函数反向传播时，很容易就会出现梯度消失的情况（在sigmoid接近饱和区时，变换太缓慢，导数趋于0，这种情况会造成信息丢失），这种现象称为饱和。</p>
</blockquote>
</li>
<li><p>计算简单：神经元(units)越多，激活函数计算的次数就越多，复杂的激活函数会降低训练速度。</p>
</li>
<li><p>输出值的范围： 当激活函数输出值是有限的时候，基于梯度的优化方法会更加稳定，即使有很大的输入，激活函数的输出也不会太大。当激活函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况小，一般需要更小的 Learning Rate。</p>
</li>
</ol>
<h2 id="4-3-常见的激活函数及图像"><a href="#4-3-常见的激活函数及图像" class="headerlink" title="4.3 常见的激活函数及图像"></a>4.3 常见的激活函数及图像</h2><h3 id="4-3-1-sigmoid-激活函数"><a href="#4-3-1-sigmoid-激活函数" class="headerlink" title="4.3.1 sigmoid 激活函数"></a>4.3.1 sigmoid 激活函数</h3><p>函数的值域为 $ (0,1) $，定义为：<br>$$<br>f(x) = \frac{1}{1 + e^{-x}}<br>$$<br>函数图像如下：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026145935759.png" alt="image-20201026145935759" style="zoom: 67%;" />





<h3 id="4-3-2-softmax-激活函数"><a href="#4-3-2-softmax-激活函数" class="headerlink" title="4.3.2 softmax 激活函数"></a>4.3.2 softmax 激活函数</h3><p><strong>Softmax 多用于多分类神经网络输出。</strong>函数定义为：<br>$$<br>f(z_j) = \frac{e^{z_j}}{\sum_{k=1}^K e^{z_k}}<br>$$</p>
<h4 id="sigmoid-函数和-softmax-函数-的区别？"><a href="#sigmoid-函数和-softmax-函数-的区别？" class="headerlink" title="sigmoid 函数和 softmax 函数 的区别？"></a>sigmoid 函数和 softmax 函数 的区别？</h4><p>wiki百科对softmax函数的定义：</p>
<blockquote>
<p>softmax is a generalization of logistic function that “squashes”(maps) a K-dimensional vector z of arbitrary real values to a K-dimensional vector σ(z) of real values in the range (0, 1) that add up to 1.</p>
</blockquote>
<p>这句话既表明了softmax函数与logistic函数的关系，也同时阐述了softmax函数的本质就是将一个K维的任意实数向量压缩（映射）成另一个K维的实数向量，其中向量中的每个元素取值都介于（0，1）之间。</p>
<p>即：sigmoid将一个real value映射到（0,1）的区间（当然也可以是（-1,1）），这样可以用来做<strong>二分类</strong>。<br>而softmax把一个k维的real value向量 $(a1,a2,a3,a4…)$ 映射成一个 $(b1,b2,b3,b4…)$ 其中bi是一个0-1的常数，然后可以根据bi的大小来进行<strong>多分类</strong>的任务，如取权重最大的一维。</p>
<h4 id="softmax-函数如何应用于多分类？"><a href="#softmax-函数如何应用于多分类？" class="headerlink" title="softmax 函数如何应用于多分类？"></a>softmax 函数如何应用于多分类？</h4><p>softmax 用于多分类过程中，它将多个神经元的输出，映射到 $ (0,1) $ 区间内，可以看成概率来理解，从而来进行多分类！</p>
<p>假设有一个数组，$ V_j $ 表示 $ V $  中的第 $j$ 个元素，那么这个元素的 softmax 值就是</p>
<p>$$<br>S_j = \frac{e^{V_j}}{\sum_i e^{V_i}}<br>$$<br>从下图看，神经网络中包含了输入层，然后通过两个特征层处理，最后通过 softmax 分析器就能得到不同条件下的概率，这里需要分成三个类别，最终会得到 $ y=0, y=1, y=2 $ 的概率值。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026154055521.png" alt="image-20201026154055521" style="zoom: 67%;" />

<p>继续看下面的图，三个输入通过 softmax 后得到一个数组 $ [0.05 , 0.10 , 0.85] $，这就是 softmax 的功能。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026154213233.png" alt="image-20201026154213233" style="zoom: 60%;" />

<p>更形象的映射过程如下图所示：</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20201026154246777.png" alt="image-20201026154246777"></p>
<p>softmax 直白来说就是将原来输出是 $ 3,1,-3 $ 通过 softmax 函数一作用，就映射成为 $ (0,1) $ 的值，而这些值的累和为 $ 1 $（满足概率的性质），那么我们就可以将它理解成概率，在最后选取输出结点的时候，就可以选取概率最大（也就是值对应最大的）结点，作为预测目标！</p>
<h3 id="4-3-3-tanh-激活函数"><a href="#4-3-3-tanh-激活函数" class="headerlink" title="4.3.3 tanh 激活函数"></a>4.3.3 tanh 激活函数</h3><p>函数的值域为 $ (-1,1) $, 定义为：<br>$$<br>f(x) = tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}<br>$$<br>函数图像如下：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026150019062.png" alt="image-20201026150019062" style="zoom:67%;" />



<h4 id="为什么tanh收敛速度比sigmoid快？"><a href="#为什么tanh收敛速度比sigmoid快？" class="headerlink" title="为什么tanh收敛速度比sigmoid快？"></a>为什么tanh收敛速度比sigmoid快？</h4><p>首先看如下两个函数的求导：<br>$$<br>tanh^{,}(x)=1-tanh(x)^{2}\in (0,1)<br>$$</p>
<p>$$<br>s^{,}(x)=s(x)*(1-s(x))\in (0,\frac{1}{4}]<br>$$</p>
<p>由上面两个公式可知 tanh(x) 梯度消失的问题比 sigmoid 轻，所以 Tanh 收敛速度比 Sigmoid 快。</p>
<h3 id="4-3-4-ReLU-激活函数"><a href="#4-3-4-ReLU-激活函数" class="headerlink" title="4.3.4 ReLU 激活函数"></a>4.3.4 ReLU 激活函数</h3><p>函数的值域为 $ [0,+∞) $，定义为：<br>$$<br>f(x) = max(0, x)<br>$$<br>函数图像如下：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026150052566.png" alt="image-20201026150052566" style="zoom:67%;" />



<h4 id="怎样理解-Relu（-lt-0-时）是非线性激活函数？"><a href="#怎样理解-Relu（-lt-0-时）是非线性激活函数？" class="headerlink" title="怎样理解 Relu（&lt; 0 时）是非线性激活函数？"></a>怎样理解 Relu（&lt; 0 时）是非线性激活函数？</h4><p>观察 Relu 函数图像发现以下特点：</p>
<ol>
<li><p>单侧抑制；</p>
</li>
<li><p>相对宽阔的兴奋边界；</p>
</li>
<li><p>稀疏激活性；</p>
</li>
</ol>
<p>ReLU 函数从图像上看，是一个分段线性函数，把所有的负值都变为 0，而正值不变，这样就成为单侧抑制。</p>
<p>因为有了这单侧抑制，才使得神经网络中的神经元也具有了稀疏激活性。</p>
<p><strong>稀疏激活性</strong>：从信号方面来看，即神经元同时只对输入信号的少部分选择性响应，大量信号被刻意的屏蔽了，这样可以提高学习的精度，<u>更好更快地提取稀疏特征</u>。当 $ x&lt;0 $ 时，ReLU 硬饱和，而当 $ x&gt;0 $ 时，则不存在饱和问题。ReLU 能够在 $ x&gt;0 $ 时保持梯度不衰减，从而缓解梯度消失问题。</p>
<h4 id="使用-ReLu-激活函数的优点？-为什么ReLu要好过sigmoid和tanh？"><a href="#使用-ReLu-激活函数的优点？-为什么ReLu要好过sigmoid和tanh？" class="headerlink" title="使用 ReLu 激活函数的优点？/ 为什么ReLu要好过sigmoid和tanh？"></a>使用 ReLu 激活函数的优点？/ 为什么ReLu要好过sigmoid和tanh？</h4><ol>
<li>采用sigmoid等函数，算激活函数时（指数运算），计算量大，反向传播求误差梯度时，求导涉及除法和指数运算，计算量相对大，而采用Relu激活函数，整个过程的计算量节省很多。</li>
<li>对于深层网络，sigmoid函数反向传播时，很容易就会出现梯度消失的情况（在sigmoid接近饱和区时，变换太缓慢，导数趋于0，这种情况会造成信息丢失），这种现象称为饱和，从而无法完成深层网络的训练，为什么会无法完成训练呢，因为神经网络更新w的时候就是依靠导数来更新的，如果导数接近0，那w更新之后还是原来的w了。而ReLU就不会有饱和倾向，不会有特别小的梯度出现。</li>
<li>需注意，Relu 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性。但他也不是没有问题，主要问题有两个：<ol>
<li>0点附近不可微。所以通常在0点只求右导数</li>
<li>它会“谋杀”一些神经元。就是说在BP的过程中很快会让一些神经元的导数永远是0，于是这些神经元等于被抛弃了，也就是被谋杀了。这提高了速度和精度，但是也有些武断，于是为了解决这个问题，引入了Leaky ReLU。Leaky ReLu 不会产生这个问题。</li>
</ol>
</li>
</ol>
<h3 id="4-3-5-Leaky-Relu-激活函数"><a href="#4-3-5-Leaky-Relu-激活函数" class="headerlink" title="4.3.5 Leaky Relu 激活函数"></a>4.3.5 Leaky Relu 激活函数</h3><p>函数定义为： $ f(x) =  \left{<br>\begin{aligned}<br>ax, \quad x&lt;0 \<br>x, \quad x&gt;0<br>\end{aligned}<br>\right. $，值域为 $ (-∞,+∞) $。 </p>
<p>图像如下（$ a = 0.5 $）：</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026150223734.png" alt="image-20201026150223734" style="zoom:67%;" />



<h3 id="4-3-6-SoftPlus-激活函数"><a href="#4-3-6-SoftPlus-激活函数" class="headerlink" title="4.3.6 SoftPlus 激活函数"></a>4.3.6 SoftPlus 激活函数</h3><p>函数的定义为：$ f(x) = ln( 1 + e^x) $，值域为 $ (0,+∞) $。</p>
<p>函数图像如下:</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026150312840.png" alt="image-20201026150312840" style="zoom:67%;" />



<h2 id="4-4-常见激活函数的导数计算？"><a href="#4-4-常见激活函数的导数计算？" class="headerlink" title="4.4 常见激活函数的导数计算？"></a>4.4 常见激活函数的导数计算？</h2><p>对常见激活函数，导数计算如下：</p>
<table>
<thead>
<tr>
<th>原函数</th>
<th>函数表达式</th>
<th>导数</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Sigmoid激活函数</td>
<td>$f(x)=\frac{1}{1+e^{-x}}$</td>
<td>$f^{‘}(x)=\frac{1}{1+e^{-x}}\left( 1- \frac{1}{1+e^{-x}} \right)=f(x)(1-f(x))$</td>
<td>当$x=10$,或$x=-10$，$f^{‘}(x) \approx0$,当$x=0$$f^{‘}(x) =0.25$</td>
</tr>
<tr>
<td>Tanh激活函数</td>
<td>$f(x)=tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}$</td>
<td>$f^{‘}(x)=-(tanh(x))^2$</td>
<td>当$x=10$,或$x=-10$，$f^{‘}(x) \approx0$,当$x=0$$f^{`}(x) =1$</td>
</tr>
<tr>
<td>Relu激活函数</td>
<td>$f(x)=max(0,x)$</td>
<td>$c(u)=\begin{cases} 0,x&lt;0 \ 1,x&gt;0 \ undefined,x=0\end{cases}$</td>
<td>通常$x=0$时，给定其导数为1和0</td>
</tr>
</tbody></table>
<h2 id="4-5-如何选择激活函数？"><a href="#4-5-如何选择激活函数？" class="headerlink" title="4.5 如何选择激活函数？"></a>4.5 如何选择激活函数？</h2><p>选择一个适合的激活函数并不容易，需要考虑很多因素，通常的做法是，如果不确定哪一个激活函数效果更好，可以把它们都试试，然后在验证集或者测试集上进行评价。然后看哪一种表现的更好，就去使用它。</p>
<p>以下是常见的选择情况：</p>
<ol>
<li>如果输出是 0、1 值（二分类问题），则输出层选择 sigmoid 函数，然后其它的所有单元都选择 Relu 函数。</li>
<li>如果在隐藏层上不确定使用哪个激活函数，那么通常会使用 Relu 激活函数。有时，也会使用 tanh 激活函数，但 Relu 的一个优点是：当是负值的时候，导数等于 0。</li>
<li>sigmoid 激活函数：除了输出层是一个二分类问题基本不会用它。</li>
<li>tanh 激活函数：tanh 是非常优秀的，几乎适合所有场合。</li>
<li>ReLu 激活函数：最常用的默认函数，如果不确定用哪个激活函数，就使用 ReLu 或者 Leaky ReLu，再去尝试其他的激活函数。</li>
<li>如果遇到了一些死的神经元，我们可以使用 Leaky ReLU 函数。</li>
</ol>
<h2 id="4-6-交叉熵损失函数"><a href="#4-6-交叉熵损失函数" class="headerlink" title="4.6 交叉熵损失函数"></a>4.6 交叉熵损失函数</h2><p>神经元的输出就是 a = σ(z)，其中$z=\sum w_{j}i_{j}+b$是输⼊的带权和。</p>
<p>$$<br>C=-\frac{1}{n}\sum[ylna+(1-y)ln(1-a)]<br>$$<br>其中 n 是训练数据的总数，求和是在所有的训练输⼊ x 上进⾏的， y 是对应的⽬标输出。</p>
<p>==详情请看这篇文章。（又是一个待办事项…）==</p>
<h1 id="5-Dropout-系列问题"><a href="#5-Dropout-系列问题" class="headerlink" title="5. Dropout 系列问题"></a>5. Dropout 系列问题</h1><h2 id="5-1-为什么要正则化？"><a href="#5-1-为什么要正则化？" class="headerlink" title="5.1 为什么要正则化？"></a>5.1 为什么要正则化？</h2><ol>
<li>深度学习可能存在过拟合问题——高方差，有两个解决方法，一个是正则化，另一个是准备更多的数据，这是非常可靠的方法，但你可能无法时时刻刻准备足够多的训练数据或者获取更多数据的成本很高，但正则化通常有助于避免过拟合或减少你的网络误差。  </li>
<li>如果你怀疑神经网络过度拟合了数据，即存在高方差问题，那么最先想到的方法可能是正则化，另一个解决高方差的方法就是准备更多数据，这也是非常可靠的办法，但你可能无法时时准备足够多的训练数据，或者，获取更多数据的成本很高，但正则化有助于避免过度拟合，或者减少网络误差。</li>
</ol>
<h2 id="5-2-为什么正则化有利于预防过拟合？"><a href="#5-2-为什么正则化有利于预防过拟合？" class="headerlink" title="5.2  为什么正则化有利于预防过拟合？"></a>5.2  为什么正则化有利于预防过拟合？</h2><p>左图是高偏差，右图是高方差，中间是Just Right.</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026225015021.png" alt="image-20201026225015021" style="zoom:80%;" />



<h2 id="5-3-理解dropout正则化"><a href="#5-3-理解dropout正则化" class="headerlink" title="5.3 理解dropout正则化"></a>5.3 理解dropout正则化</h2><p>Dropout可以随机删除网络中的神经单元，它为什么可以通过正则化发挥如此大的作用呢？  </p>
<p>直观上理解：不要依赖于任何一个特征，因为该单元的输入可能随时被清除，因此该单元通过这种方式传播下去，并为单元的四个输入增加一点权重，通过传播所有权重，dropout将产生收缩权重的平方范数的效果，和之前讲的L2正则化类似；实施dropout的结果实它会压缩权重，并完成一些预防过拟合的外层正则化；L2对不同权重的衰减是不同的，它取决于激活函数倍增的大小。 </p>
<h2 id="5-4-dropout率的选择"><a href="#5-4-dropout率的选择" class="headerlink" title="5.4 dropout率的选择"></a>5.4 dropout率的选择</h2><ol>
<li>经过交叉验证，隐含节点 dropout 率等于 0.5 的时候效果最好，原因是 0.5 的时候 dropout 随机生成的网络结构最多。</li>
<li>dropout 也可以被用作一种添加噪声的方法，直接对 input 进行操作。输入层设为更接近 1 的数。使得输入变化不会太大（0.8） </li>
<li>对参数 $ w $ 的训练进行球形限制 (max-normalization)，对 dropout 的训练非常有用。</li>
<li>球形半径 $ c $ 是一个需要调整的参数，可以使用验证集进行参数调优。</li>
<li>dropout 自己虽然也很牛，但是 dropout、max-normalization、large decaying learning rates and high momentum 组合起来效果更好，比如 max-norm regularization 就可以防止大的learning rate 导致的参数 blow up。</li>
<li>使用 pretraining 方法也可以帮助 dropout 训练参数，在使用 dropout 时，要将所有参数都乘以 $ 1/p $。</li>
</ol>
<h2 id="5-5-dropout有什么缺点？"><a href="#5-5-dropout有什么缺点？" class="headerlink" title="5.5 dropout有什么缺点？"></a>5.5 dropout有什么缺点？</h2><p>dropout一大缺点就是代价函数J不再被明确定义，每次迭代，都会随机移除一些节点，如果再三检查梯度下降的性能，实际上是很难进行复查的。定义明确的代价函数J每次迭代后都会下降，因为我们所优化的代价函数J实际上并没有明确定义，或者说在某种程度上很难计算，所以我们失去了调试工具来绘制这样的图片。作者通常会关闭dropout函数，将keep-prob的值设为1，运行代码，确保J函数单调递减。然后打开dropout函数，希望在dropout过程中，代码并未引入bug。作者觉得也可以尝试其它方法，虽然他们并没有关于这些方法性能的数据统计，但我可以把它们与dropout方法一起使用。  (母鸡~)</p>
<h1 id="6-Batch-Size-这块不太懂"><a href="#6-Batch-Size-这块不太懂" class="headerlink" title="6. Batch_Size(这块不太懂==)"></a>6. Batch_Size(这块不太懂==)</h1><p>直观的理解：</p>
<p>Batch Size定义：一次训练所选取的样本数。</p>
<p>Batch Size的大小影响模型的优化程度和速度。同时其直接影响到GPU内存的使用情况，假如你GPU内存不大，该数值最好设置小一点hh。</p>
<h2 id="6-1-为什么需要-Batch-Size？"><a href="#6-1-为什么需要-Batch-Size？" class="headerlink" title="6.1 为什么需要 Batch_Size？"></a>6.1 为什么需要 Batch_Size？</h2><p>Batch的选择，首先决定的是下降的方向。</p>
<p>如果数据集比较小，可采用全数据集的形式，好处是：</p>
<ol>
<li>由全数据集确定的方向能够更好地代表样本总体，从而更准确地朝向极值所在的方向。</li>
<li>由于不同权重的梯度值差别巨大，因此选取一个全局的学习率很困难。 Full Batch Learning 可以使用 Rprop 只基于梯度符号并且针对性单独更新各权值。</li>
</ol>
<p>对于更大的数据集，假如采用全数据集的形式，坏处是：</p>
<ol>
<li>随着数据集的海量增长和内存限制，一次性载入所有的数据进来变得越来越不可行。</li>
<li>以 Rprop 的方式迭代，会由于各个 Batch 之间的采样差异性，各次梯度修正值相互抵消，无法修正。这才有了后来 RMSProp 的妥协方案。 </li>
</ol>
<h2 id="6-2-Batch-Size-值的选择"><a href="#6-2-Batch-Size-值的选择" class="headerlink" title="6.2 Batch_Size 值的选择"></a>6.2 Batch_Size 值的选择</h2><p>假如每次只训练一个样本，即 Batch_Size = 1。线性神经元在均方误差代价函数的错误面是一个抛物面，横截面是椭圆。对于多层神经元、非线性网络，在局部依然近似是抛物面。此时，每次修正方向以各自样本的梯度方向修正，横冲直撞各自为政，难以达到收敛。</p>
<p>既然 Batch_Size 为全数据集或者Batch_Size = 1都有各自缺点，可不可以选择一个适中的Batch_Size值呢？</p>
<p>此时，可采用批梯度下降法（Mini-batches Learning）。因为如果数据集足够充分，那么用一半（甚至少得多）的数据训练算出来的梯度与用全部数据训练出来的梯度是几乎一样的。</p>
<h2 id="6-3-在合理范围内，增大Batch-Size有何好处？"><a href="#6-3-在合理范围内，增大Batch-Size有何好处？" class="headerlink" title="6.3 在合理范围内，增大Batch_Size有何好处？"></a>6.3 在合理范围内，增大Batch_Size有何好处？</h2><ol>
<li>内存利用率提高了，大矩阵乘法的并行化效率提高。</li>
<li>跑完一次 epoch（全数据集）所需的迭代次数减少，对于相同数据量的处理速度进一步加快。</li>
<li>在一定范围内，一般来说 Batch_Size 越大，其确定的下降方向越准，引起训练震荡越小。</li>
</ol>
<h2 id="6-4-盲目增大-Batch-Size-有何坏处？"><a href="#6-4-盲目增大-Batch-Size-有何坏处？" class="headerlink" title="6.4 盲目增大 Batch_Size 有何坏处？"></a>6.4 盲目增大 Batch_Size 有何坏处？</h2><ol>
<li>内存利用率提高了，但是内存容量可能撑不住了。</li>
<li>跑完一次 epoch（全数据集）所需的迭代次数减少，要想达到相同的精度，其所花费的时间大大增加了，从而对参数的修正也就显得更加缓慢。</li>
<li>Batch_Size 增大到一定程度，其确定的下降方向已经基本不再变化。</li>
</ol>
<h2 id="6-5-调节-Batch-Size-对训练效果影响到底如何？"><a href="#6-5-调节-Batch-Size-对训练效果影响到底如何？" class="headerlink" title="6.5 调节 Batch_Size 对训练效果影响到底如何？"></a>6.5 调节 Batch_Size 对训练效果影响到底如何？</h2><ol>
<li>Batch_Size 太小，模型表现效果极其糟糕(error飙升)。</li>
<li>随着 Batch_Size 增大，处理相同数据量的速度越快。</li>
<li>随着 Batch_Size 增大，达到相同精度所需要的 epoch 数量越来越多。</li>
<li>由于上述两种因素的矛盾， Batch_Size 增大到某个时候，达到时间上的最优。</li>
<li>由于最终收敛精度会陷入不同的局部极值，因此 Batch_Size 增大到某些时候，达到最终收敛精度上的最优。 </li>
</ol>
<h1 id="7-归一化"><a href="#7-归一化" class="headerlink" title="7. 归一化"></a>7. 归一化</h1><h2 id="7-1-归一化含义？"><a href="#7-1-归一化含义？" class="headerlink" title="7.1 归一化含义？"></a>7.1 归一化含义？</h2><ol>
<li><p>归纳统一样本的统计分布性。归一化在 $ 0-1$ 之间是统计的概率分布，归一化在$ [-1, +1] $ 之间是统计的坐标分布。</p>
</li>
<li><p>无论是为了建模还是为了计算，首先基本度量单位要同一，神经网络是以样本在事件中的统计分别几率来进行训练（概率计算）和预测，且 sigmoid 函数的取值是 0 到 1 之间的，网络最后一个节点的输出也是如此，所以经常要对样本的输出归一化处理。</p>
</li>
<li><p>归一化是统一在 $ 0-1 $ 之间的统计概率分布，当所有样本的输入信号都为正值时，与第一隐含层神经元相连的权值只能同时增加或减小，从而导致学习速度很慢。</p>
</li>
<li><p>另外在数据中常存在奇异样本数据，奇异样本数据存在所引起的网络训练时间增加，并可能引起网络无法收敛。为了避免出现这种情况及后面数据处理的方便，加快网络学习速度，可以对输入信号进行归一化，使得所有样本的输入信号其均值接近于 0 或与其均方差相比很小。</p>
</li>
</ol>
<h2 id="7-2-为什么要归一化？"><a href="#7-2-为什么要归一化？" class="headerlink" title="7.2 为什么要归一化？"></a>7.2 为什么要归一化？</h2><ol>
<li>为了后面数据处理的方便，归一化的确可以避免一些不必要的数值问题。</li>
<li>为了程序运行时收敛加快。 </li>
<li>同一量纲。样本数据的评价标准不一样，需要对其量纲化，统一评价标准。这算是应用层面的需求。</li>
<li>避免神经元饱和。啥意思？就是当神经元的激活在接近 0 或者 1 时会饱和，在这些区域，梯度几乎为 0，这样，在反向传播过程中，局部梯度就会接近 0，这会有效地“杀死”梯度。</li>
<li>保证输出数据中数值小的不被吞食。 </li>
</ol>
<h2 id="7-3-为什么归一化能提高求解最优解速度？"><a href="#7-3-为什么归一化能提高求解最优解速度？" class="headerlink" title="7.3 为什么归一化能提高求解最优解速度？"></a>7.3 为什么归一化能提高求解最优解速度？</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20201026212202448.png" alt="image-20201026212202448"></p>
<p>上图是代表数据是否均一化的最优解寻解过程（圆圈可以理解为等高线）。左图表示未经归一化操作的寻解过程，右图表示经过归一化后的寻解过程。</p>
<p>当使用梯度下降法寻求最优解时，很有可能走“之字型”路线（垂直等高线走），从而导致需要迭代很多次才能收敛；而右图对两个原始特征进行了归一化，其对应的等高线显得很圆，在梯度下降进行求解时能较快的收敛。</p>
<p>因此如果机器学习模型使用梯度下降法求最优解时，归一化往往非常有必要，否则很难收敛甚至不能收敛。</p>
<h2 id="7-4-3D-图解未归一化"><a href="#7-4-3D-图解未归一化" class="headerlink" title="7.4 3D 图解未归一化"></a>7.4 3D 图解未归一化</h2><p>栗子：</p>
<p>假设 $ w1 $ 的范围在 $ [-10, 10] $，而 $ w2 $ 的范围在 $ [-100, 100] $，梯度每次都前进 1 单位，那么在 $ w1 $ 方向上每次相当于前进了 $ 1/20 $，而在 $ w2 $ 上只相当于 $ 1/200 $！某种意义上来说，在 $ w2 $ 上前进的步长更小一些,而 $ w1 $ 在搜索过程中会比 $ w2 $ “走”得更快。</p>
<p>这样会导致，在搜索过程中更偏向于 $ w1 $ 的方向。走出了“L”形状，或者成为“之”字形。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026212415442.png" alt="image-20201026212415442" style="zoom: 67%;" />



<h2 id="7-5-归一化有哪些类型？"><a href="#7-5-归一化有哪些类型？" class="headerlink" title="7.5 归一化有哪些类型？"></a>7.5 归一化有哪些类型？</h2><h3 id="7-5-1-线性归一化"><a href="#7-5-1-线性归一化" class="headerlink" title="7.5.1 线性归一化"></a>7.5.1 线性归一化</h3><p>$$<br>x^{\prime} = \frac{x-min(x)}{max(x) - min(x)}<br>$$</p>
<ul>
<li><p>适用范围：比较适用在数值比较集中的情况。</p>
</li>
<li><p>缺点：如果 max 和 min 不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。</p>
</li>
</ul>
<h3 id="7-5-2-标准差标准化"><a href="#7-5-2-标准差标准化" class="headerlink" title="7.5.2 标准差标准化"></a>7.5.2 标准差标准化</h3><p>$$<br>x^{\prime} = \frac{x-\mu}{\sigma}<br>$$</p>
<ul>
<li>含义：经过处理的数据符合标准正态分布，即均值为 0，标准差为 1 其中 $ \mu $ 为所有样本数据的均值，$ \sigma $ 为所有样本数据的标准差。</li>
</ul>
<h3 id="7-5-3-非线性归一化"><a href="#7-5-3-非线性归一化" class="headerlink" title="7.5.3 非线性归一化"></a>7.5.3 非线性归一化</h3><ul>
<li>适用范围：经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括 $ log $、指数，正切等。</li>
</ul>
<h2 id="7-6-什么是批归一化（Batch-Normalization）"><a href="#7-6-什么是批归一化（Batch-Normalization）" class="headerlink" title="7.6 什么是批归一化（Batch Normalization）"></a>7.6 什么是批归一化（Batch Normalization）</h2><p>以前在神经网络训练中，只是对输入层数据进行归一化处理，却没有在中间层进行归一化处理。要知道，虽然我们对输入数据进行了归一化处理，但是输入数据经过 $ \sigma(WX+b) $ 这样的矩阵乘法以及非线性运算之后，其数据分布很可能被改变，而随着深度网络的多层运算之后，数据分布的变化将越来越大。如果我们能在网络的中间也进行归一化处理，是否对网络的训练起到改进作用呢？答案是肯定的。 </p>
<p>这种在神经网络中间层也进行归一化处理，使训练效果更好的方法，就是批归一化 Batch Normalization（BN）。</p>
<h3 id="7-6-1-批归一化（BN）优点"><a href="#7-6-1-批归一化（BN）优点" class="headerlink" title="7.6.1 批归一化（BN）优点"></a>7.6.1 批归一化（BN）优点</h3><ol>
<li>减少了人为选择参数。<u>在某些情况下可以取消 dropout 和 L2 正则项参数</u>,或者采取更小的 L2 正则项约束参数；</li>
<li>减少了对学习率的要求。现在我们可以使用初始很大的学习率或者选择了较小的学习率，算法也能够快速训练收敛； </li>
<li>破坏原来的数据分布，一定程度上缓解过拟合（防止每批训练中某一个样本经常被挑选到，文献说这个可以提高 1% 的精度）。 </li>
<li>减少梯度消失，加快收敛速度，提高训练精度。</li>
<li>可以不再使用局部响应归一化。BN 本身就是归一化网络(局部响应归一化在 AlexNet 网络中存在) </li>
</ol>
<h3 id="7-6-2-批归一化（BN）流程"><a href="#7-6-2-批归一化（BN）流程" class="headerlink" title="7.6.2 批归一化（BN）流程"></a>7.6.2 批归一化（BN）流程</h3><p>输入：上一层输出结果 $ X = {x_1, x_2, …, x_m} $，学习参数 $ \gamma, \beta $</p>
<p>算法流程：</p>
<ol>
<li><strong>计算上一层输出数据的均值</strong></li>
</ol>
<p>$$<br>\mu_{\beta} = \frac{1}{m} \sum_{i=1}^m(x_i)<br>$$</p>
<p>​    其中，$ m $ 是此次训练样本 batch 的大小。</p>
<ol start="2">
<li><strong>计算上一层输出数据的标准差</strong></li>
</ol>
<p>$$<br>\sigma_{\beta}^2 = \frac{1}{m} \sum_{i=1}^m (x_i - \mu_{\beta})^2<br>$$</p>
<ol start="3">
<li><strong>归一化处理，得到</strong></li>
</ol>
<p>$$<br>\hat x_i = \frac{x_i + \mu_{\beta}}{\sqrt{\sigma_{\beta}^2} + \epsilon}<br>$$</p>
<p>​    其中 $ \epsilon $ 是为了避免分母为 0 而加进去的接近于 0 的很小值</p>
<ol start="4">
<li><strong>重构，对经过上面归一化处理得到的数据进行重构，得到</strong></li>
</ol>
<p>$$<br>y_i = \gamma \hat x_i + \beta<br>$$</p>
<p>​    其中，$ \gamma, \beta $ 为可学习参数。</p>
<p>注：上述是 BN 训练时的过程，但是当在投入使用时，往往只是输入一个样本，没有所谓的均值 $ \mu_{\beta} $ 和标准差 $ \sigma_{\beta}^2 $。此时，均值 $ \mu_{\beta} $ 是计算所有 batch $ \mu_{\beta} $ 值的平均值得到，标准差 $ \sigma_{\beta}^2 $ 采用每个batch $ \sigma_{\beta}^2 $  的无偏估计得到。</p>
<h3 id="7-6-3-Batch-Normalization在什么时候用比较合适？"><a href="#7-6-3-Batch-Normalization在什么时候用比较合适？" class="headerlink" title="7.6.3 Batch Normalization在什么时候用比较合适？"></a>7.6.3 Batch Normalization在什么时候用比较合适？</h3><p>在CNN中，BN应作用在非线性映射前。在神经网络训练时遇到收敛速度很慢，或梯度爆炸等无法训练的状况时可以尝试BN来解决。另外，在一般使用情况下也可以加入BN来加快训练速度，提高模型精度。</p>
<p>BN比较适用的场景是：每个mini-batch比较大，数据分布比较接近。在进行训练之前，要做好充分的shuffle，否则效果会差很多。另外，由于BN需要在运行过程中统计每个mini-batch的一阶统计量和二阶统计量，因此不适用于动态的网络结构和RNN网络。</p>
<h1 id="8-预训练与微调-fine-tuning"><a href="#8-预训练与微调-fine-tuning" class="headerlink" title="8. 预训练与微调(fine tuning)"></a>8. 预训练与微调(fine tuning)</h1><h2 id="8-1-为什么无监督预训练可以帮助深度学习？"><a href="#8-1-为什么无监督预训练可以帮助深度学习？" class="headerlink" title="8.1 为什么无监督预训练可以帮助深度学习？"></a>8.1 为什么无监督预训练可以帮助深度学习？</h2><p>深度网络存在问题:</p>
<ol>
<li><p>网络越深，需要的训练样本数越多。若用监督则需大量标注样本，不然小规模样本容易造成过拟合。深层网络特征比较多，会出现的多特征问题主要有多样本问题、规则化问题、特征选择问题。</p>
</li>
<li><p>多层神经网络参数优化是个高阶非凸优化问题，经常得到收敛较差的局部解；</p>
</li>
<li><p>梯度消失问题，BP算法计算出的梯度随着深度向前而显著下降，导致前面网络参数贡献很小，更新速度慢。</p>
</li>
</ol>
<p><strong>解决方法：</strong></p>
<p>逐层贪婪训练，无监督预训练（unsupervised pre-training）即训练网络的第一个隐藏层，再训练第二个…最后用这些训练好的网络参数值作为整体网络参数的初始值。</p>
<p>经过预训练最终能得到比较好的局部最优解。</p>
<h2 id="8-2-什么是模型微调-fine-tuning"><a href="#8-2-什么是模型微调-fine-tuning" class="headerlink" title="8.2 什么是模型微调 fine tuning"></a>8.2 什么是模型微调 fine tuning</h2><p>用别人的参数、修改后的网络和自己的数据进行训练，使得参数适应自己的数据，这样一个过程，通常称之为微调（fine tuning). </p>
<p><strong>模型的微调举例说明：</strong></p>
<p>我们知道，CNN 在图像识别这一领域取得了巨大的进步。如果想将 CNN 应用到我们自己的数据集上，这时通常就会面临一个问题：通常我们的 dataset 都不会特别大，一般不会超过 1 万张，甚至更少，每一类图片只有几十或者十几张。这时候，直接应用这些数据训练一个网络的想法就不可行了，因为深度学习成功的一个关键性因素就是大量带标签数据组成的训练集。如果只利用手头上这点数据，即使我们利用非常好的网络结构，也达不到很高的 performance。这时候，fine-tuning 的思想就可以很好解决我们的问题：我们通过对 ImageNet 上训练出来的模型（如CaffeNet,VGGNet,ResNet) 进行微调，然后应用到我们自己的数据集上。</p>
<h2 id="8-3-微调时候网络参数是否更新？"><a href="#8-3-微调时候网络参数是否更新？" class="headerlink" title="8.3 微调时候网络参数是否更新？"></a>8.3 微调时候网络参数是否更新？</h2><p>答案：会更新。</p>
<ol>
<li>finetune 的过程相当于继续训练，跟直接训练的区别是初始化的时候。 </li>
<li>直接训练是按照网络定义指定的方式初始化。</li>
<li>finetune是用你已经有的参数文件来初始化。</li>
</ol>
<h2 id="8-4-fine-tuning-模型的三种状态"><a href="#8-4-fine-tuning-模型的三种状态" class="headerlink" title="8.4 fine-tuning 模型的三种状态"></a>8.4 fine-tuning 模型的三种状态</h2><ol>
<li><p>状态一：只预测，不训练。<br>特点：相对快、简单，针对那些已经训练好，现在要实际对未知数据进行标注的项目，非常高效；</p>
</li>
<li><p>状态二：训练，但只训练最后分类层。<br>特点：fine-tuning的模型最终的分类以及符合要求，现在只是在他们的基础上进行类别降维。</p>
</li>
<li><p>状态三：完全训练，分类层+之前卷积层都训练<br>特点：跟状态二的差异很小，当然状态三比较耗时和需要训练GPU资源，不过非常适合fine-tuning到自己想要的模型里面，预测精度相比状态二也提高不少。</p>
</li>
</ol>
<h1 id="9-学习率"><a href="#9-学习率" class="headerlink" title="9. 学习率"></a>9. 学习率</h1><h2 id="9-1-学习率的作用"><a href="#9-1-学习率的作用" class="headerlink" title="9.1 学习率的作用"></a>9.1 学习率的作用</h2><p>在机器学习中，监督式学习通过定义一个模型，并根据训练集上的数据估计最优参数。梯度下降法是一个广泛被用来最小化模型误差的参数优化算法。梯度下降法通过多次迭代，并在每一步中最小化成本函数（cost 来估计模型的参数）。学习率 (learning rate)，在迭代过程中会控制模型的学习进度。</p>
<p>在梯度下降法中，都是给定的统一的学习率，整个优化过程中都以确定的步长进行更新， 在迭代优化的前期中，学习率较大，则前进的步长就会较长，这时便能以较快的速度进行梯度下降，而在迭代优化的后期，逐步减小学习率的值，减小步长，这样将有助于算法的收敛，更容易接近最优解。故而如何对学习率的更新成为了研究者的关注点。</p>
<p>在模型优化中，常用到的几种学习率衰减方法有：分段常数衰减、多项式衰减、指数衰减、自然指数衰减、余弦衰减、线性余弦衰减、噪声线性余弦衰减</p>
<h2 id="9-2-学习率衰减常用参数有哪些"><a href="#9-2-学习率衰减常用参数有哪些" class="headerlink" title="9.2 学习率衰减常用参数有哪些"></a>9.2 学习率衰减常用参数有哪些</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>learning_rate</td>
<td>初始学习率</td>
</tr>
<tr>
<td>global_step</td>
<td>用于衰减计算的全局步数，非负，用于逐步计算衰减指数</td>
</tr>
<tr>
<td>decay_steps</td>
<td>衰减步数，必须是正值，决定衰减周期</td>
</tr>
<tr>
<td>decay_rate</td>
<td>衰减率</td>
</tr>
<tr>
<td>end_learning_rate</td>
<td>最低的最终学习率</td>
</tr>
<tr>
<td>cycle</td>
<td>学习率下降后是否重新上升</td>
</tr>
<tr>
<td>alpha</td>
<td>最小学习率</td>
</tr>
<tr>
<td>num_periods</td>
<td>衰减余弦部分的周期数</td>
</tr>
<tr>
<td>initial_variance</td>
<td>噪声的初始方差</td>
</tr>
<tr>
<td>variance_decay</td>
<td>衰减噪声的方差</td>
</tr>
</tbody></table>
<h3 id="9-2-1-分段常数衰减"><a href="#9-2-1-分段常数衰减" class="headerlink" title="9.2.1 分段常数衰减"></a>9.2.1 分段常数衰减</h3><p>分段常数衰减需要事先定义好的训练次数区间，在对应区间置不同的学习率的常数值，一般情况刚开始的学习率要大一些，之后要越来越小，要根据样本量的大小设置区间的间隔大小，样本量越大，区间间隔要小一点。下图即为分段常数衰减的学习率变化图，横坐标代表训练次数，纵坐标代表学习率。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026222538375.png" alt="image-20201026222538375" style="zoom: 50%;" />



<h3 id="9-2-2-指数衰减"><a href="#9-2-2-指数衰减" class="headerlink" title="9.2.2 指数衰减"></a>9.2.2 指数衰减</h3><p>以指数衰减方式进行学习率的更新，学习率的大小和训练次数指数相关，其更新规则为：<br>$$<br>decayed{_}learning{_}rate =learning{_}rate*decay{_}rate^{\frac{global{_step}}{decay{_}steps}}<br>$$<br>这种衰减方式简单直接，收敛速度快，是最常用的学习率衰减方式，如下图所示，绿色的为学习率随<br>训练次数的指数衰减方式，红色的即为分段常数衰减，它在一定的训练区间内保持学习率不变。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026223700750.png" alt="image-20201026223700750" style="zoom:50%;" />



<h3 id="9-2-3-自然指数衰减"><a href="#9-2-3-自然指数衰减" class="headerlink" title="9.2.3 自然指数衰减"></a>9.2.3 自然指数衰减</h3><p>它与指数衰减方式相似，不同的在于它的衰减底数是$e$，故而其收敛的速度更快，一般用于相对比较<br>容易训练的网络，便于较快的收敛，其更新规则如下：<br>$$<br>decayed{_}learning{_}rate =learning{_}rate*e^{\frac{-decay{_rate}}{global{_}step}}<br>$$<br>下图为为分段常数衰减、指数衰减、自然指数衰减三种方式的对比图，红色的即为分段常数衰减图，阶梯型曲线。蓝色线为指数衰减图，绿色即为自然指数衰减图，很明可以看到自然指数衰减方式下的学习率衰减程度要大于一般指数衰减方式，有助于更快的收敛。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026223843460.png" alt="image-20201026223843460" style="zoom:50%;" />



<h3 id="9-2-4-多项式衰减-看不懂"><a href="#9-2-4-多项式衰减-看不懂" class="headerlink" title="9.2.4 多项式衰减 (看不懂==)"></a>9.2.4 多项式衰减 (看不懂==)</h3><p>应用多项式衰减的方式进行更新学习率，这里会给定初始学习率和最低学习率取值，然后将会按照<br>给定的衰减方式将学习率从初始值衰减到最低值,其更新规则如下式所示。<br>$$<br>global{_}step=min(global{_}step,decay{_}steps)<br>$$</p>
<p>$$<br>decayed{_}learning{_}rate =(learning{_}rate-end{_}learning{_}rate)* \left( 1-\frac{global{_step}}{decay{_}steps}\right)^{power} \<br> +end{_}learning{_}rate<br>$$</p>
<p>需要注意的是，有两个机制，降到最低学习率后，到训练结束可以一直使用最低学习率进行更新，另一个是再次将学习率调高，使用 decay_steps 的倍数，取第一个大于 global_steps 的结果，如下式所示.它是用来防止神经网络在训练的后期由于学习率过小而导致的网络一直在某个局部最小值附近震荡，这样可以通过在后期增大学习率跳出局部极小值。<br>$$<br>decay{_}steps = decay{_}steps*ceil \left( \frac{global{_}step}{decay{_}steps}\right)<br>$$<br>如下图所示，红色线代表学习率降低至最低后，一直保持学习率不变进行更新，绿色线代表学习率衰减到最低后，又会再次循环往复的升高降低。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026224250502.png" alt="image-20201026224250502" style="zoom:50%;" />



<h3 id="9-2-5-余弦衰减"><a href="#9-2-5-余弦衰减" class="headerlink" title="9.2.5 余弦衰减"></a>9.2.5 余弦衰减</h3><p>余弦衰减就是采用余弦的相关方式进行学习率的衰减，衰减图和余弦函数相似。其更新机制如下式所示：</p>
<p>$$<br>global{_}step=min(global{_}step,decay{_}steps)<br>$$</p>
<p>$$<br>cosine{_}decay=0.5<em>\left( 1+cos\left( \pi</em> \frac{global{_}step}{decay{_}steps}\right)\right)<br>$$</p>
<p>$$<br>decayed=(1-\alpha)*cosine{_}decay+\alpha<br>$$</p>
<p>$$<br>decayed{_}learning{_}rate=learning{_}rate*decayed<br>$$</p>
<p>如下图所示，红色即为标准的余弦衰减曲线，学习率从初始值下降到最低学习率后保持不变。蓝色的线是线性余弦衰减方式曲线，它是学习率从初始学习率以线性的方式下降到最低学习率值。绿色噪声线性余弦衰减方式。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/机器学习/深度学习/image-20201026224331391.png" alt="image-20201026224331391" style="zoom:50%;" />







<h1 id="10-5-深度学习中常用的数据增强方法？"><a href="#10-5-深度学习中常用的数据增强方法？" class="headerlink" title="10.5 深度学习中常用的数据增强方法？"></a>10.5 深度学习中常用的数据增强方法？</h1><ul>
<li><p>Color Jittering：对颜色的数据增强：图像亮度、饱和度、对比度变化（此处对色彩抖动的理解不知是否得当）；</p>
</li>
<li><p>PCA  Jittering：首先按照RGB三个颜色通道计算均值和标准差，再在整个训练集上计算协方差矩阵，进行特征分解，得到特征向量和特征值，用来做PCA Jittering；</p>
</li>
<li><p>Random Scale：尺度变换；</p>
</li>
<li><p>Random Crop：采用随机图像差值方式，对图像进行裁剪、缩放；包括Scale Jittering方法（VGG及ResNet模型使用）或者尺度和长宽比增强变换；</p>
</li>
<li><p>Horizontal/Vertical Flip：水平/垂直翻转；</p>
</li>
<li><p>Shift：平移变换；</p>
</li>
<li><p>Rotation/Reflection：旋转/仿射变换；</p>
</li>
<li><p>Noise：高斯噪声、模糊处理；</p>
</li>
<li><p>Label Shuffle：类别不平衡数据的增广；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记</title>
    <url>/2020/11/14/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这里记录了 Python 的一些知识点。</p>
<p><em><a id="more"></a></em></p>
<h1 id="基础知识">1. 基础知识</h1>
<h2 id="编译器与解释器">1.1 编译器与解释器</h2>
<p>编译器 / 解释器：<strong>高级语言与机器之间的翻译官</strong></p>
<p>都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程有不同而已。</p>
<figure>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 编程语言 /Python/image-20201028172837820.png" alt="image-20201028172837820" /><figcaption>image-20201028172837820</figcaption>
</figure>
<p>用一个通俗的例子进行比喻：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。</p>
<figure>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 编程语言 /Python/image-20201028172917342.png" alt="image-20201028172917342" /><figcaption>image-20201028172917342</figcaption>
</figure>
<ul>
<li>程序入口的编写：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="标识符就是变量名">1.2 标识符(就是变量名)</h2>
<p>所谓的标识符就是对变量、常量、函数、类等对象起的名字，变量名。</p>
<p>Python 对于标识符的命名有如下规定：</p>
<ul>
<li><p>第一个字符必须是字母表中的字母或下划线 **‘_’** ，标识符的其他的部分由字母、数字和下划线组成</p></li>
<li>标识符对大小写敏感，严格区分大小写！</li>
<li><p>变量的命名不要用关键字和内置函数的名字</p></li>
</ul>
<p>一些代码规范：</p>
<ul>
<li>变量名全部小写，常量名全部大写</li>
<li>函数和方法名用小写加下划线， <code>count_star</code></li>
<li>类名用大写驼峰，每个单词的首字母大写， <code>ThreadMixIn</code></li>
<li>模块和包的名字用小写</li>
</ul>
<h2 id="变量与常量">1.3 变量与常量</h2>
<ul>
<li><p>Python 中的变量不需要声明类型。变量可以直接使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="string">&quot;xiaozhang&quot;</span></span><br><span class="line">c = []</span><br><span class="line">d = <span class="number">9</span>-<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>用“=”号来给变量赋值，从右往左的计算顺序。</p></li>
<li><p>每个变量在使用前都必须赋值，变量赋值以后才会被创建。</p></li>
<li><p>在 Python 中，变量本身没有数据类型的概念，通常所说的“变量类型”是变量所引用的对象的类型，或者说是变量的值的类型。</p></li>
<li><p>Python 允许同时为多个变量赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span>，最终大家都是<span class="number">1</span>。</span><br></pre></td></tr></table></figure></li>
<li><p>也可以同时为多个变量赋值，用逗号分隔，逐一对应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>，最后 a 是<span class="number">1</span>，b 是<span class="number">2</span>，c 是<span class="number">3.</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Python 中，一切事物都是对象，变量引用的是对象或者说是对象在内存中的地址。</strong></p>
<ul>
<li><p>栗子：a = 'ABC' 时，Python 解释器干了两件事情：</p>
<ul>
<li>在内存中创建了一个‘ABC’的字符串对象；</li>
<li>在内存中创建了一个名为 a 的变量，并把它指向 'ABC'。</li>
</ul></li>
<li><p>栗子：a 和 b 是什么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">b = a</span><br><span class="line">a = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">print(b)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<ul>
<li>执行 a = ‘Jack’，解释器创建字符串‘Jack’对象和变量 a，并把 a 指向‘Jack’对象；</li>
<li>执行 b = a, 解释器创建变量 b，并且将其指向变量 a 指向的字符串‘Jack’对象。</li>
<li>执行 a = ‘Tom’, 解释器创建字符串‘Tom’对象，并把 a 改为指向‘Tom’对象，与 b 无关。</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/image-20201028163331835.png" /></p></li>
</ul></li>
</ul>
<h2 id="输入输出">1.4 输入输出</h2>
<h3 id="input 输入函数">1.4.1 input 输入函数</h3>
<p>input 函数：获取用户输入，保存成一个 <strong> 字符串</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inp  = <span class="built_in">input</span>(<span class="string">&quot;please input your name: &quot;</span>)</span><br><span class="line">please <span class="built_in">input</span> your name: jack</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inp</span><br><span class="line"><span class="string">&#x27;jack&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(inp)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">&gt;&gt;&gt; age  = input(&quot;please input your age: &quot;)</span><br><span class="line">please <span class="built_in">input</span> your age: <span class="number">18</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age</span><br><span class="line"><span class="string">&#x27;18&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(age)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">&gt;&gt;&gt; a = input(&quot; 请输入一个字符：&quot;)</span><br><span class="line">请输入一个字符：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">input</span>(<span class="string">&quot; 请输入一个字符：&quot;</span>)</span><br><span class="line">请输入一个字符：   前后带有空白   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">&#x27;   前后带有空白   &#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="print- 输出函数">==1.4.2 print 输出函数 ==</h3>
<p>普通的输出没啥可说的。</p>
<p>说一下 <code>print</code> 格式化输出。</p>
<figure>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 编程语言 /Python/image-20201028174609959.png" alt="image-20201028174609959" /><figcaption>image-20201028174609959</figcaption>
</figure>
<figure>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 编程语言 /Python/image-20201028174632071.png" alt="image-20201028174632071" /><figcaption>image-20201028174632071</figcaption>
</figure>
<p>下面是一些经典的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;i am %s&quot;</span> % <span class="string">&quot;jack&quot;</span></span><br><span class="line"><span class="comment">#i am jack</span></span><br><span class="line">s = <span class="string">&quot;i am %s age %d&quot;</span> % (<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">#i am jack age 18</span></span><br><span class="line">s = <span class="string">&quot;i am %(name)s age %(age)d&quot;</span> % &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="comment">#i am jack age 18</span></span><br><span class="line">s = <span class="string">&quot;percent %.2f&quot;</span> % <span class="number">99.97623</span></span><br><span class="line"><span class="comment">#percent 99.98</span></span><br><span class="line">s = <span class="string">&quot;i am %(pp).2f&quot;</span> % &#123;<span class="string">&quot;pp&quot;</span>: <span class="number">123.425556</span>, &#125;</span><br><span class="line"><span class="comment">#i am 123.43</span></span><br><span class="line">s = <span class="string">&quot;i am %.2f %%&quot;</span> % <span class="number">123.425556</span></span><br><span class="line"><span class="comment">#i am 123.43 %</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：如果你想在 print 中打印一个 % 百分符号本身，那么你需要使用 %%，两个百分符转义出一个百分符，也就是 print(&quot;%%&quot;)。</p>
</blockquote>
<h1 id="数据类型">2. 数据类型</h1>
<figure>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 编程语言 /Python/image-20201114232511659.png" alt="image-20201114232511659" /><figcaption>image-20201114232511659</figcaption>
</figure>
<h2 id="数字类型">2.1 数字类型</h2>
<p>数字类型用于存储数学意义上的数值。</p>
<p>数字类型是不可变类型。所谓的不可变类型，指的是类型的值一旦有不同了，那么它就是一个全新的对象。数字 1 和 2 分别代表两个不同的对象，对变量重新赋值一个数字类型，会新建一个数字对象。</p>
<p>还是要强调一下 Python 的变量和数据类型的关系，变量只是对某个对象的引用或者说代号、名字、调用等等，变量本身没有数据类型的概念。类似 1，[2, 3, 4]，“haha”这一类对象才具有数据类型的概念。</p>
<blockquote>
<p>例如：</p>
<p>a = 1 # 创建数字对象 1</p>
<p>a = 2 # 创建数字对象 2，并将 2 赋值给变量 a，a 不再指向数字对象 1</p>
<p>这里，发生了变化的是变量 a 的指向，而不是数字对象 1 变成了数字对象 2。</p>
</blockquote>
<p>Python 支持三种不同的数字类型：整数、浮点数和复数。</p>
<h2 id="字符串">2.2 字符串</h2>
<p><strong>字符串是不可变的序列数据类型</strong>，不能直接修改字符串本身，和数字类型一样</p>
<blockquote>
<p>注：中文符号 &gt; 字母 &gt; 数字 &gt; 英文符号</p>
<p>例: <code>print(min('今天是个好日子！'))</code> 返回 ”！“</p>
</blockquote>
<ul>
<li>字符串的拼接，用 ”+“ 这个符号</li>
</ul>
<h3 id="常用函数">常用函数</h3>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>upper()</td>
<td>函数的作用是将字符串中所有的字母大写，只针对字母。</td>
</tr>
<tr class="even">
<td>lower()</td>
<td>函数的作用是将字符串中所有的字母小写，只针对字母。</td>
</tr>
<tr class="odd">
<td>capitalize()</td>
<td>将字符串的第一个字母变成大写，其它字母变小写。</td>
</tr>
<tr class="even">
<td>swapcase()</td>
<td>将字符串的小写变大写，大写变小写。</td>
</tr>
<tr class="odd">
<td>zfill(参数 = 新字符串希望的宽度)</td>
<td>返回指定长度的字符串，原字符串右对齐，前面填充 0。</td>
</tr>
<tr class="even">
<td>count(参数 = 查询某个元素的元素)</td>
<td>返回当前字符串中某个元素的个数。</td>
</tr>
<tr class="odd">
<td>startswith(参数 = 字符串)</td>
<td>判断字符串开始位是否为某个元素，返回布尔值</td>
</tr>
<tr class="even">
<td>endswith(参数 = 字符串)</td>
<td>判断字符串结尾为是否为某个元素，返回布尔值</td>
</tr>
<tr class="odd">
<td>find(参数 = 查询某个元素的元素)</td>
<td>用于获取子字符串出现的位置，如果存在则返回子字符串中 <u> 第一个字符 </u> 的索引值，如果没有找到则返回 -1</td>
</tr>
<tr class="even">
<td>index(参数 = 查询某个元素的元素)</td>
<td>用于获取子字符串出现的位置，如果存在则返回子字符串中 <u> 第一个字符 </u> 的索引值，如果 index 找不到元素，会导致程序报错</td>
</tr>
<tr class="odd">
<td>strip(参数 = 想去掉的某个元素)</td>
<td>去掉字符串开头与结尾指定元素，默认是空格</td>
</tr>
<tr class="even">
<td>lstrip()</td>
<td>仅去掉字符串开头指定元素或空格</td>
</tr>
<tr class="odd">
<td>rstrip()</td>
<td>仅去掉字符串结尾指定元素或空格</td>
</tr>
<tr class="even">
<td>replace()</td>
<td>用于将字符串中旧元素替换成新元素，并能指定替换的数量</td>
</tr>
<tr class="odd">
<td>isspace()</td>
<td>判断字符串是否是只由空格组成的字符串</td>
</tr>
<tr class="even">
<td>istitle()</td>
<td>判断字符串是否是一个标题类型, 所有单词的首字母大写才属于标题</td>
</tr>
<tr class="odd">
<td>isupper()/islower()</td>
<td>判断字符串的所有字母是否都是大写或者小写</td>
</tr>
<tr class="even">
<td>split()</td>
<td>连接字符串</td>
</tr>
<tr class="odd">
<td>join()</td>
<td>拆分字符串</td>
</tr>
</tbody>
</table>
<ul>
<li><code>spilt(str=&quot;&quot;, num=string.count(str))</code>
<ul>
<li>str -- 分隔符，默认为所有的空字符，包括空格、换行 ()、制表符() 等。</li>
<li>num -- 分割次数。默认为 -1, 即分隔所有。</li>
</ul></li>
<li><code>str.join(sequence)</code>
<ul>
<li>sequence -- 要连接的元素序列。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>]</span><br><span class="line">print(<span class="string">&#x27; &#x27;</span>.join(li))</span><br><span class="line"></span><br><span class="line">b = <span class="string">&#x27;my job is a teacher&#x27;</span></span><br><span class="line">print(b.split())</span><br><span class="line"></span><br><span class="line">b = <span class="string">&#x27;my_name_is_bob&#x27;</span></span><br><span class="line">print(b.split(<span class="string">&#x27;_&#x27;</span>))</span><br><span class="line">print(b.split(<span class="string">&#x27;_&#x27;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>字符串和 bytes 转换：</p>
<ul>
<li><code>encode(encoding='UTF-8,errors='strict')</code> ：将字符串内容转换为 bytes 类型的数据</li>
<li><code>decode(encoding='UTF-8,errors='strict')</code> ：以 <em>encoding</em> 指定的编码格式解码字符串。</li>
</ul>
<h3 id="编码格式">编码格式</h3>
<p>对语言的解析识别 / 标准</p>
<ul>
<li>gbk 中文编码</li>
<li>ASCII 英文编码</li>
<li>utf-8 国际通用编码</li>
</ul>
<h3 id="格式化输出">格式化（输出）</h3>
<ol type="1">
<li>字符符串格式化用操作符 <code>%</code> 来实现</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = <span class="string">&#x27;my name is %s&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;xz&#x27;</span></span><br><span class="line">print(info % name)</span><br></pre></td></tr></table></figure>
<ul>
<li>格式化符</li>
</ul>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%s</td>
<td>格式化字符串，通用类型</td>
</tr>
<tr class="even">
<td>%d</td>
<td>格式化整型</td>
</tr>
<tr class="odd">
<td>%f</td>
<td>格式化浮点型</td>
</tr>
<tr class="even">
<td>%u</td>
<td>格式化无符号整型（正整型）</td>
</tr>
<tr class="odd">
<td>%c</td>
<td>格式化字符</td>
</tr>
<tr class="even">
<td>%o</td>
<td>格式化无符号八进制数</td>
</tr>
<tr class="odd">
<td>%x</td>
<td>格式化无符号 16 进制数</td>
</tr>
<tr class="even">
<td>%e</td>
<td>科学计数法格式化浮点数</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;%u&#x27;</span> % -<span class="number">1</span>)  <span class="comment"># -1</span></span><br><span class="line">print(<span class="string">&#x27;%f&#x27;</span> % <span class="number">3.14</span>)  <span class="comment"># 3.140000</span></span><br><span class="line">print(<span class="string">&#x27;%d&#x27;</span> % <span class="number">10</span>)  <span class="comment"># 10</span></span><br><span class="line">print(<span class="string">&#x27;%d&#x27;</span> % <span class="number">1.2</span>)  <span class="comment">#1</span></span><br><span class="line">print(<span class="string">&#x27;%s&#x27;</span> % <span class="string">&#x27;123&#x27;</span> )  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#123;:f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">1.2</span>))  <span class="comment"># 1.200000</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;%o&#x27;</span> % <span class="number">8</span>)  <span class="comment"># 10</span></span><br><span class="line">print(<span class="string">&#x27;%x&#x27;</span> % <span class="number">32</span>)  <span class="comment"># 20</span></span><br><span class="line"><span class="comment"># print(&#x27;%x&#x27; % &#x27;123ab&#x27;)</span></span><br><span class="line">number = <span class="built_in">int</span>(<span class="string">&#x27;123ab&#x27;</span>, <span class="number">16</span>)</span><br><span class="line">print(number)</span><br><span class="line">print(<span class="string">&#x27;%x&#x27;</span> % number)</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>字符串格式化函数 - <code>format</code></li>
</ol>
<ul>
<li>使用 format 的字符串主体使用 <code>&#123;&#125; 大括号</code> 来代替格式符，可以不取下标，取的话从 0 开始</li>
<li><code>string.format(data, data...)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = <span class="string">&#x27;my name is &#123;&#125;&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;xz&#x27;</span></span><br><span class="line">print(info.<span class="built_in">format</span>(name))</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><code>f-strings</code> <em>新方法</em></li>
</ol>
<ul>
<li>定义一个变量</li>
<li>字符串前加 f 符号</li>
<li>需要格式化的位置使用 <code>&#123; 变量名 &#125;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;xz&#x27;</span>  <span class="comment"># 一定要先定义变量名</span></span><br><span class="line">info = <span class="string">f&#x27;my name is <span class="subst">&#123;name&#125;</span>&#x27;</span></span><br><span class="line">print(info)</span><br></pre></td></tr></table></figure>
<ul>
<li>转义字符</li>
</ul>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>换行，一般用于末尾，strip 对其也有效</td>
</tr>
<tr class="even">
<td></td>
<td>横向制表符</td>
</tr>
<tr class="odd">
<td></td>
<td>响铃</td>
</tr>
<tr class="even">
<td></td>
<td>退格符，光标前移，覆盖（删除前一个）</td>
</tr>
<tr class="odd">
<td></td>
<td>回车</td>
</tr>
<tr class="even">
<td> '</td>
<td>转义字符串中的单引号</td>
</tr>
<tr class="odd">
<td> '‘</td>
<td>转义字符串中的双引号</td>
</tr>
<tr class="even">
<td>\</td>
<td>转移斜杠</td>
</tr>
</tbody>
</table>
<ul>
<li>在字符串前加 r 来将当前字符串的转义字符无效化</li>
</ul>
<h2 id="布尔类型">2.3 布尔类型</h2>
<ul>
<li><p><code>0、0.0、-0.0、空字符串、空列表、空元组、空字典 </code>，这些都被判定为 False。而<code>-1、&quot;False&quot;</code> 也被判断为 True。</p></li>
<li><p><code>None</code> 也不是布尔类型，而是<code>NoneType</code>。</p></li>
</ul>
<blockquote>
<p>平时最容易犯的错误就是获得了一个 None 值，却对它进行各种方法调用，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> list1:</span><br><span class="line">    print(char.join(<span class="string">&quot;A&quot;</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">AttributeError: <span class="string">&#x27;NoneType&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;join&#x27;</span>        </span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="列表 -list">2.4 列表 List</h2>
<p>Python 的列表是一个有序可重复的元素集合，可嵌套、迭代、修改、分片、追加、删除，成员判断。</p>
<p>从数据结构角度看，Python 的列表是一个可变长度的顺序存储结构，每一个位置存放的都是对象的指针。</p>
<p>比如，对于这个列表 <code>alist = [1, “a”, [11,22], &#123;“k1”:”v1”&#125;]</code>，其在内存内的存储方式是这样的：</p>
<figure>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 编程语言 /Python/image-20201028230652247.png" alt="image-20201028230652247" /><figcaption>image-20201028230652247</figcaption>
</figure>
<h3 id="索引">索引</h3>
<p>索引是最左边记录的位置。用数字表示，从 0 开始，<code>len(list)-1</code> 结束。</p>
<ul>
<li>创建</li>
</ul>
<p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表内的元素，可以是其它任意类型的数据，可多层嵌套列表，元素个数无限制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis = []        <span class="comment"># 创建一个空列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, [<span class="number">11</span>,<span class="number">22</span>], &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="string">&#x27;v1&#x27;</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<ul>
<li>访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">3</span>]</span><br><span class="line"><span class="comment">###########</span></span><br><span class="line">IndexError: <span class="built_in">list</span> index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改：直接对元素进行重新赋值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">0</span>] = <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>字符串不可以通过索引修改或删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;comprehensive&quot;</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############</span></span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>删除：使用 <code>del</code> 语句或者 <code>remove()</code> ，<code>pop()</code> 方法删除指定的元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> lis[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis</span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis.remove(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis</span><br><span class="line">[<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis.pop()</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<ul>
<li>常用函数</li>
</ul>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>len(list)</td>
<td>返回列表元素个数，也就是获取列表长度</td>
</tr>
<tr class="even">
<td>max(list)</td>
<td>返回列表元素最大值</td>
</tr>
<tr class="odd">
<td>min(list)</td>
<td>返回列表元素最小值</td>
</tr>
<tr class="even">
<td>list(seq)</td>
<td>将序列转换为列表</td>
</tr>
<tr class="odd">
<td>in/not in</td>
<td>判断某个元素是否在列表中</td>
</tr>
</tbody>
</table>
<h3 id="切片">切片</h3>
<p>切片指的是对序列进行截取，选取序列中的某一段。</p>
<p>切片的语法是： <code>list[start:end]</code>，注意，<strong>区间是左闭右开的</strong>！</p>
<figure>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 编程语言 /Python/image-20201031085919878.png" alt="image-20201031085919878" /><figcaption>image-20201031085919878</figcaption>
</figure>
<ul>
<li>如果下标是负数，从后往前数，是 <code>-1 ~ -len(list)</code></li>
</ul>
<h3 id="列表的常见方法">列表的常见方法</h3>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>append(item)</td>
<td>将一个元素添加到当前原有列表的末尾</td>
</tr>
<tr class="even">
<td>insert(index, new_item)</td>
<td>插入新的元素，在什么位置。如果插入位置不存在，则加在结尾。如果插入位置存在元素，则该元素往后移，将插入元素放入该位置。</td>
</tr>
<tr class="odd">
<td>count(item)</td>
<td>返回当前列表中某个元素的个数</td>
</tr>
<tr class="even">
<td>remove(item)</td>
<td>删除列表的指定元素。如不存在，会报错。如有多个，只删第一个。</td>
</tr>
<tr class="odd">
<td>del item</td>
<td>删掉整个列表</td>
</tr>
<tr class="even">
<td>reverse()</td>
<td>反转当前列表</td>
</tr>
<tr class="odd">
<td>sort(cmp=None, key=None, reverse=False)</td>
<td>对当前列表按照一定规律进行排序且 list 中的元素必须是统一类型，否则程序就会报错。</td>
</tr>
<tr class="even">
<td>clear()</td>
<td>将 list 中的元素都清除，将其变成一个空列表即[]</td>
</tr>
<tr class="odd">
<td>copy()/deepcopy()</td>
<td><strong>浅拷贝 / 深拷贝</strong></td>
</tr>
<tr class="even">
<td>extend()</td>
<td>将其他 list 中的元素导入到当前的 list</td>
</tr>
</tbody>
</table>
<blockquote>
<p>例：append()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = [<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>]</span><br><span class="line">book = [<span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>]</span><br><span class="line">books.append(book)</span><br><span class="line">print(books)</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">[<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, [<span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>]]</span><br></pre></td></tr></table></figure>
<ul>
<li>extend()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&quot;name&quot;</span>]</span><br><span class="line">tuplee=(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>)</span><br><span class="line"></span><br><span class="line">list1.extend(tuplee)</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意：</p>
<ol type="1">
<li><p>其中的类似 append，insert, remove 等方法会修改列表本身，并且没有返回值（严格的说是返回 None）。</p></li>
<li><p>== 浅拷贝与深拷贝 ==</p>
<p>使用浅拷贝，当原容器对象中可变对象中有元素发生变化，拷贝得到的对象也会变化。而使用深拷贝时，不会有这种问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [[<span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;fei&#x27;</span>, <span class="number">66</span>]</span><br><span class="line">list2 = list1.copy()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(list1), <span class="built_in">id</span>(list2))</span><br><span class="line">list2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">123</span></span><br><span class="line">list2[<span class="number">2</span>] = <span class="number">77</span></span><br><span class="line">print(list1, list2)</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"><span class="number">1904206959560</span> <span class="number">1904227747656</span></span><br><span class="line">[[<span class="number">123</span>, <span class="number">2</span>], <span class="string">&#x27;fei&#x27;</span>, <span class="number">66</span>] [[<span class="number">123</span>, <span class="number">2</span>], <span class="string">&#x27;fei&#x27;</span>, <span class="number">77</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">   </span><br><span class="line">list1 = [[<span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;fei&#x27;</span>, <span class="number">66</span>]</span><br><span class="line">list2 = copy.deepcopy(list1)</span><br><span class="line">   </span><br><span class="line">print(<span class="built_in">id</span>(list1), <span class="built_in">id</span>(list2))</span><br><span class="line">list2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">123</span></span><br><span class="line">list2[<span class="number">2</span>] = <span class="number">77</span></span><br><span class="line">print(list1, list2)</span><br><span class="line">   </span><br><span class="line">---------------------------------</span><br><span class="line"><span class="number">1563824640968</span> <span class="number">1563844713928</span></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;fei&#x27;</span>, <span class="number">66</span>] [[<span class="number">123</span>, <span class="number">2</span>], <span class="string">&#x27;fei&#x27;</span>, <span class="number">77</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以理解为：浅拷贝对于一个复杂对象的子对象并不会完全复制，复杂对象的子对象是指比如序列中的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，python 会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。</p>
</blockquote></li>
</ol>
<blockquote>
<p>例题：使用给定的整数 n，编写一个程序生成一个包含 (i, i*i) 的字典，该字典包含 1 到 n 之间的整数(两者都包含)。然后程序应该打印字典。 假设向程序提供以下输入:8，则输出为:{1:1，2:4，3:9，4:16，5:25，6:36，,7:49，8:64}</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">8</span></span><br><span class="line">d = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    d[i] = i * i</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="元组 -tuple">2.5 元组 Tuple</h2>
<p>用圆括号括起来的是元组。</p>
<p>元组也是序列结构，但是是一种 <strong> 不可变序列 </strong>，可以<strong> 简单的理解为内容不可变的列表。除了在内部元素不可修改的区别外</strong>，元组和列表的用法差不多。</p>
<blockquote>
<p>因为元组是不可变的，所以不能在原来的数据基础上再添加数据，因此元组占用的资源会比列表更小。</p>
</blockquote>
<p><strong>元组与列表相同的操作</strong>：</p>
<ul>
<li>使用方括号加下标访问元素</li>
<li>切片（形成新元组对象）</li>
<li>count()/index()</li>
<li>len()/max()/min()/tuple()</li>
</ul>
<p><strong>元组中不允许的操作，确切的说是元组没有的功能</strong>：</p>
<ul>
<li><p>修改、新增元素</p>
<blockquote>
<p><strong>元组只保证它的一级子元素不可变，对于嵌套的元素内部，不保证不可变！</strong>所以，在使用元组的时候，请尽量使用数字、字符串和元组这种不可变的数据类型作为元组的元素，这样就能确保元组不发生变化。</p>
</blockquote></li>
<li><p>删除某个元素（但可以删除整个元组）</p></li>
<li><p>所有会对元组内部元素发生修改动作的方法。例如，元组没有 remove，append，pop 等方法。</p></li>
</ul>
<h2 id="字典 -dic">2.6 字典 Dic</h2>
<p>字典可精确描述为 <strong> 不定长、可变、散列的集合类型</strong>。</p>
<p>字典数据类型是基于 hash 散列算法实现的，采用 <strong> 键值对 (key:value)</strong> 的形式，根据 key 的值计算 value 的地址，具有非常快的查取和插入速度。</p>
<p>字典包含的元素个数不限，值的类型可以是任何数据类型！但是字典的 key 必须是不可变的对象，例如数字、字符串、bytes 和元组，最常见的还是将字符串作为 key。列表、字典、集合等就不可以作为 key。同时，同一个字典内的 key 必须是唯一的，但值则不必。</p>
<blockquote>
<p>字典类型的数据不支持累乘。</p>
</blockquote>
<ul>
<li>创建</li>
</ul>
<ol type="1">
<li><code>dic = &#123;&#125;</code> # 创建空字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;&#125;    <span class="comment"># 创建空字典</span></span><br><span class="line">dic = &#123;<span class="string">&#x27;Alice&#x27;</span>: <span class="string">&#x27;2341&#x27;</span>, <span class="string">&#x27;Beth&#x27;</span>: <span class="string">&#x27;9102&#x27;</span>, <span class="string">&#x27;Cecil&#x27;</span>: <span class="string">&#x27;3258&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="string">&#x27;sape&#x27;</span>, <span class="number">4139</span>), (<span class="string">&#x27;guido&#x27;</span>, <span class="number">4127</span>), (<span class="string">&#x27;jack&#x27;</span>, <span class="number">4098</span>)])</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p><code>update()</code> ：在 update 函数里传入一个新的字典 key 和 value 就可以。存在就覆盖。</p></li>
<li><p><code>setdefault()</code>：传入一个字典 key 和 value，如果键不存在于字典中，将会添加见并键值设为默认值，如果字典中包含有给定键，则返回该键对应的值，若不包含则返回为该键设置的值。</p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;&#125;</span><br><span class="line">dic.setdefault(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line">dic.setdefault(<span class="string">&#x27;sex&#x27;</span>)</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dic[&#x27;Name&#x27;]: &quot;</span>, dic[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dic[&#x27;Age&#x27;]: &quot;</span>, dic[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dic[&#x27;address&#x27;]: &quot;</span>, dic[<span class="string">&#x27;address&#x27;</span>])</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">KeyError: <span class="string">&#x27;address&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>增加和修改</li>
</ul>
<p>增加就是往字典插入新的键值对，修改就是给原有的键赋予新的值。由于一个 key 只能对应一个值，所以，多次对一个 key 赋值，后面的值会把前面的值冲掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;Shanghai&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;Beijing&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">&quot;Age&quot;</span>] = <span class="number">18</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除字典元素、清空字典和删除字典</li>
</ul>
<p>使用 <code>del</code> 关键字删除字典元素或者字典本身，使用字典的 <code>clear()</code> 方法清空字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dic[<span class="string">&#x27;Name&#x27;</span>]</span><br><span class="line">print(dic)</span><br><span class="line">a = dic.pop(<span class="string">&#x27;Class&#x27;</span>)  <span class="comment"># 弹出并返回指定键对应的值。必须提供参数！</span></span><br><span class="line">print(a)</span><br><span class="line">dic.clear()</span><br><span class="line">print(dic)</span><br><span class="line"><span class="keyword">del</span> dic</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">NameError: name <span class="string">&#x27;dic&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&#123;<span class="string">&#x27;Age&#x27;</span>: <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">First</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字典的常见方法">字典的常见方法</h3>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>get(key)</strong></td>
<td><strong>返回指定键的值，如果键不在字典中，则返回 default 值</strong></td>
</tr>
<tr class="even">
<td><strong>items()</strong></td>
<td><strong>以列表返回可遍历的(键, 值) 元组对</strong></td>
</tr>
<tr class="odd">
<td><strong>keys()</strong></td>
<td><strong>以列表返回字典所有的键，假列表，不可对其操作，可以通过 list(dict.keys())变为真列表</strong></td>
</tr>
<tr class="even">
<td><strong>values()</strong></td>
<td><strong>以列表返回字典所有的值，同上</strong></td>
</tr>
<tr class="odd">
<td>pop(key)</td>
<td>删除并返回指定 key 的值</td>
</tr>
<tr class="even">
<td>popitem()</td>
<td>删除并返回字典的最后一个键值对的 (key,value) 形式，不接受参数。且字典如果是空则直接报错</td>
</tr>
<tr class="odd">
<td>setdefault(key, default=None)</td>
<td>和 get()类似, 但如果键不存在于字典中，将会添加键并将值设为 default</td>
</tr>
<tr class="even">
<td>update(dict2)</td>
<td>把字典 dict2 的键 / 值对更新到 dict 里</td>
</tr>
<tr class="odd">
<td>copy()</td>
<td>将当前字典复制到一个新的字典</td>
</tr>
</tbody>
</table>
<p>注：</p>
<ol type="1">
<li><code>get()</code> 和 <code>[]</code> 的区别</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">values = []</span><br><span class="line">values.append(dic[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line">values.append(dic[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">print(values)</span><br><span class="line"><span class="comment"># values.append(dic[&#x27;grade&#x27;])  # KeyError: &#x27;grade&#x27;</span></span><br><span class="line">values.append(dic.get(<span class="string">&#x27;grade&#x27;</span>))</span><br><span class="line">print(values)</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">[<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;20&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="literal">None</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>字典中获取 key 的方法 [] 如果获取不到 key 会直接报错，而 get 如果获取不到 key 会返回默认值，在开发中优先考虑 get 方法来获取 key</p>
</blockquote>
<ol start="2" type="1">
<li><code>get()</code> 与 <code>in</code> 判断的区别</li>
</ol>
<p>字典中的成员判断 in 和 not in 是判断是否有 value，有对、无错，并不判断 value 是不是空。</p>
<p>而 get 判断值的结果，如果 value 是 None 就会返回 False</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="literal">None</span>&#125;  </span><br><span class="line">bool(dict_1.get(&quot;name&quot;)) --&gt; False</span><br></pre></td></tr></table></figure>
<h3 id="遍历字典">遍历字典</h3>
<p><strong>遍历字典获得的键值对是有序的！</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1  直接遍历字典获取键，根据键取值</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic:</span><br><span class="line">    print(key, dic[key])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2  利用 items 方法获取键值，速度很慢，少用！</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">    print(key,value)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3  利用 keys 方法获取键</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic.keys():</span><br><span class="line">    print(key, dic[key])</span><br><span class="line"></span><br><span class="line"><span class="comment">#4  利用 values 方法获取值，但无法获取对应的键。</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dic.values():</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure>
<h2 id="集合 -set">2.7 集合 set</h2>
<p><strong>集合是一个无序不重复元素的集</strong>，基本功能包括关系测试和消除重复元素。集合使用大括号 <code>&#123;&#125;</code> 框定元素，并以逗号进行分隔。成员是不可变类型。</p>
<p>但是注意：<u>如果要创建一个空集合，必须用 set() 而不是 {} ，因为后者创建的是一个空字典</u>。集合除了在形式上最外层用的也是花括号外，其它的和字典没有一毛钱关系。</p>
<p>集合数据类型的核心在于 <strong> 自动去重</strong>。很多时候能省不少事。</p>
<ul>
<li>增加</li>
</ul>
<ol type="1">
<li>通过 add(key)方法可以添加一个元素到 set 中，可以重复添加，但不会有效果</li>
<li>可以通过 update()方法，将另一个对象更新到已有的集合中，这一过程同样会进行去重。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">s.add(<span class="number">5</span>)</span><br><span class="line">print(s)  <span class="comment"># &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line">s.update(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">print(s)  <span class="comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<p>通过 remove(key)方法删除指定元素，或者使用 pop()方法。注意，集合的 pop 方法无法设置参数，删除指定的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span></span><br><span class="line">s.remove(<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">print(s)  <span class="comment"># &#123;1, 2, 3, 4, 5, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span></span><br><span class="line">s.pop(<span class="number">3</span>)  <span class="comment"># TypeError: pop() takes no arguments (1 given)</span></span><br></pre></td></tr></table></figure>
<p><strong>不能从集合取某个元素。因为集合既不支持下标索引也不支持字典那样的通过键获取值。</strong></p>
<h3 id="集合的常用方法">集合的常用方法</h3>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>difference() / -</td>
<td>返回集合的差集</td>
</tr>
<tr class="even">
<td>intersection()</td>
<td>返回集合的交集</td>
</tr>
<tr class="odd">
<td>union()</td>
<td>返回集合的并集</td>
</tr>
<tr class="even">
<td>isdisjoint()</td>
<td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td>
</tr>
<tr class="odd">
<td>issubset()</td>
<td>判断指定集合是否为该方法参数集合的子集。</td>
</tr>
<tr class="even">
<td>add()</td>
<td>为集合添加一个元素</td>
</tr>
<tr class="odd">
<td>update()</td>
<td>给集合添加元素</td>
</tr>
<tr class="even">
<td>pop()</td>
<td>移除元素</td>
</tr>
<tr class="odd">
<td>remove()</td>
<td>移除指定元素</td>
</tr>
</tbody>
</table>
<h1 id="函数">3. 函数</h1>
<p>总结函数的传参方式，有以下四种：</p>
<ul>
<li>位置参数</li>
<li>默认参数</li>
<li>关键参数</li>
<li>非固定参数
<ul>
<li><code>*args</code></li>
<li><code>**kwargs</code></li>
</ul></li>
</ul>
<h2 id="位置参数">3.1 位置参数</h2>
<p>位置参数就是调用函数时穿的实参与形参位置上一一对应的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stu_ingo</span>(<span class="params">name, age, major, country</span>):</span></span><br><span class="line">	print(name, age, major, country)</span><br><span class="line"></span><br><span class="line">stu1 = stu_info(<span class="string">&#x27;jack&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;Chinese&#x27;</span>, <span class="string">&#x27;CN&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="默认参数">3.2 默认参数</h2>
<p>默认参数就是在函数形参中定义好的，当是惨重未穿对应的参数时，参数就会以默认值为准。</p>
<p>注：默认参数必须放在位置参数之后，否则会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stu_ingo</span>(<span class="params">name, age, major, country = <span class="string">&#x27;CN&#x27;</span></span>):</span></span><br><span class="line">	print(name, age, major, country)</span><br><span class="line"></span><br><span class="line">stu1 = stu_info(<span class="string">&#x27;jack&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;Chinese&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="关键参数">3.3 关键参数</h2>
<p>正常情况下，给函数传参数要按照顺序，如果不按顺序就可以用关键参数，只需指定参数名即可（指定参数名的参数叫关键参数）</p>
<p>注：关键参数必须放在位置参数（以位置顺序确定对应关系的参数）之后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stu_ingo</span>(<span class="params">name, age, major, country = <span class="string">&#x27;CN&#x27;</span></span>):</span></span><br><span class="line">	print(name, age, major, country)</span><br><span class="line"></span><br><span class="line">stu1 = stu_info(<span class="string">&#x27;jack&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;Chinese&#x27;</span>, country = <span class="string">&#x27;UK&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="非固定参数">3.4 非固定参数</h2>
<p><code>*args</code>与 <code>**kwargs</code> 是可变类型且 <code>*args</code> 将参数封装成元组类型给函数体调用，<code>**kwargs</code> 将参数封装成字典类型给函数体调用</p>
<blockquote>
<p>栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seq</span>(<span class="params">num, num1, num2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">88</span> :</span><br><span class="line">        print(num1 * num2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(num1 + num2)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 定义变量 tuple1 的值为(5,2,1)</span></span><br><span class="line">tuple1 = (<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 调用函数，传入参数 tuple1，并打印函数返回值</span></span><br><span class="line">seq(*tuple1)  <span class="comment"># *tuple1 可实现对元组 tuple1 的解包</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="args">3.4.1 <code>*args</code></h3>
<p>可同时指定多个用户，传过来的所有参数打包成元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args</span>(<span class="params">first, *args</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;Required argument: &#x27;</span>, first)</span><br><span class="line">    print(<span class="built_in">type</span>(args))</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Optional argument: &#x27;</span>, v)</span><br><span class="line"></span><br><span class="line">test_args(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>第一个参数是必须要传入的参数，所以使用了第一个形参，而后面三个参数则作为可变参数列表传入了实参，并且是作为元组 tuple 来使用的。代码的运行结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Required argument:  <span class="number">1</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">tuple</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Optional</span> <span class="title">argument</span>:</span>  <span class="number">2</span></span><br><span class="line">Optional argument:  <span class="number">3</span></span><br><span class="line">Optional argument:  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="kwargs">3.4.2 <code>**kwargs</code></h3>
<p>可同时指定多个用户，传过来的所有参数打包成元组或字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_kwargs</span>(<span class="params">first, *args, **kwargs</span>):</span></span><br><span class="line">   print(<span class="string">&#x27;Required argument: &#x27;</span>, first)</span><br><span class="line">   print(<span class="built_in">type</span>(kwargs))</span><br><span class="line">   <span class="keyword">for</span> v <span class="keyword">in</span> args:</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;Optional argument (args): &#x27;</span>, v)</span><br><span class="line">   <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;Optional argument %s (kwargs): %s&#x27;</span> % (k, v))</span><br><span class="line"></span><br><span class="line">test_kwargs(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, k1=<span class="number">5</span>, k2=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>正如前面所说的，<code>args</code> 类型是一个 tuple，而 <code>kwargs</code> 则是一个字典 <code>dict</code>，并且 <code>args</code> 只能位于 <code>kwargs</code> 的前面。代码的运行结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Required argument:  <span class="number">1</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">dict</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Optional</span> <span class="title">argument</span> (<span class="params">args</span>):</span>  <span class="number">2</span></span><br><span class="line">Optional argument (args):  <span class="number">3</span></span><br><span class="line">Optional argument (args):  <span class="number">4</span></span><br><span class="line">Optional argument k1 (kwargs): <span class="number">5</span></span><br><span class="line">Optional argument k2 (kwargs): <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="综合练习函数的使用">综合练习：函数的使用</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    学生信息库</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">students = &#123;</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;dewei&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">33</span>,</span><br><span class="line">        <span class="string">&#x27;class_number&#x27;</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 小木 &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;class_number&#x27;</span>: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">3</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 小红 &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="string">&#x27;class_number&#x27;</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;girl&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">4</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 小张 &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="string">&#x27;class_number&#x27;</span>: <span class="string">&#x27;C&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;girl&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">5</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 小安 &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="string">&#x27;class_number&#x27;</span>: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;girl&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查位置参数的判断</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_user_info</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; 没有发现学生姓名 &#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;age&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; 没有发现学生年龄 &#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;sex&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; 没有发现学生性别 &#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;class_number&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; 没有发现学生班级 &#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_students</span>():</span></span><br><span class="line">    <span class="keyword">for</span> id_, value <span class="keyword">in</span> students.items():</span><br><span class="line">        print(<span class="string">&#x27; 学号：&#123;&#125;，姓名：&#123;&#125;，年龄：&#123;&#125;，性别：&#123;&#125;，班级：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            id_, value[<span class="string">&#x27;name&#x27;</span>], value[<span class="string">&#x27;age&#x27;</span>], value[<span class="string">&#x27;sex&#x27;</span>], value[<span class="string">&#x27;class_number&#x27;</span>]</span><br><span class="line">        ))</span><br><span class="line">    <span class="keyword">return</span> students</span><br><span class="line"></span><br><span class="line"><span class="comment"># result = get_all_students()</span></span><br><span class="line"><span class="comment"># print(&#x27;---&#x27;, result)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_student</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    check = check_user_info(**kwargs)</span><br><span class="line">    <span class="keyword">if</span> check != <span class="literal">True</span>:</span><br><span class="line">        print(check)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    id_ = <span class="built_in">max</span>(students) + <span class="number">1</span>  <span class="comment"># 不在长度上加 1，会覆盖以前删掉的号码</span></span><br><span class="line"></span><br><span class="line">    students[id_] = &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: kwargs[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: kwargs[<span class="string">&#x27;age&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>: kwargs[<span class="string">&#x27;sex&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;class_number&#x27;</span>: kwargs[<span class="string">&#x27;class_number&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_student(name=&#x27; 小章鱼 &#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span></span><br><span class="line"><span class="comment"># get_all_students()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_student</span>(<span class="params">student_id</span>):</span></span><br><span class="line">    <span class="keyword">if</span> student_id <span class="keyword">not</span> <span class="keyword">in</span> students:</span><br><span class="line">        print(<span class="string">&#x27; 学号是 &#123;&#125; 号的同学的信息不存在 &#x27;</span>.<span class="built_in">format</span>(student_id))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        user_info = students.pop(student_id)</span><br><span class="line">        print(<span class="string">&#x27; 学号是 &#123;&#125; 的 &#123;&#125; 同学的信息已经被删除了 &#x27;</span>.<span class="built_in">format</span>(student_id, user_info[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete_student(2)</span></span><br><span class="line"><span class="comment"># add_student(name=&#x27; 小章鱼 &#x27;, age=19, sex=&#x27;girl&#x27;, class_number=&#x27;A&#x27;)</span></span><br><span class="line"><span class="comment"># get_all_students()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_student</span>(<span class="params">student_id, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> student_id <span class="keyword">not</span> <span class="keyword">in</span> students:</span><br><span class="line">        print(<span class="string">&#x27; 不存在学号：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(student_id))</span><br><span class="line"></span><br><span class="line">    check = check_user_info(**kwargs)</span><br><span class="line">    <span class="keyword">if</span> check != <span class="literal">True</span>:</span><br><span class="line">        print(check)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    students[student_id] = kwargs</span><br><span class="line">    print(<span class="string">&#x27;&#123;&#125; 同学信息更新完毕 &#x27;</span>.<span class="built_in">format</span>(kwargs[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">update_student(<span class="number">2</span>, name=<span class="string">&#x27;2 小木 &#x27;</span>, age=<span class="number">11</span>, sex=<span class="string">&#x27;boy&#x27;</span>,class_number=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">get_all_students()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找，通过学号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_by_id</span>(<span class="params">student_id</span>):</span></span><br><span class="line">    <span class="keyword">return</span> students.get(student_id)</span><br><span class="line"></span><br><span class="line">print(get_user_by_id(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_users</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    values = <span class="built_in">list</span>(students.values())</span><br><span class="line">    key = <span class="literal">None</span></span><br><span class="line">    value = <span class="literal">None</span></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        key = <span class="string">&#x27;name&#x27;</span></span><br><span class="line">        value = kwargs[key]</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        key = <span class="string">&#x27;age&#x27;</span></span><br><span class="line">        value = kwargs[key]</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;sex&#x27;</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        key = <span class="string">&#x27;sex&#x27;</span></span><br><span class="line">        value = kwargs[key]</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;class_number&#x27;</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        key = <span class="string">&#x27;class_number&#x27;</span></span><br><span class="line">        value = kwargs[key]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27; 没有发现搜索的关键字 &#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> values:</span><br><span class="line">        <span class="keyword">if</span> user[key] == value:</span><br><span class="line">            result.append(user)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;--------------------&#x27;</span>)</span><br><span class="line">users = search_users(sex=<span class="string">&#x27;boy&#x27;</span>)</span><br><span class="line">print(users)</span><br></pre></td></tr></table></figure>
<h1 id="面向对象编程">4. 面向对象编程</h1>
<p>基本概念：</p>
<ul>
<li>面向对象：是一种以对象为核心的编程思想。主要是找出问题中的共性问题，作为对象进行操作。</li>
<li>类：类可以创建实例。</li>
<li>对象：类不能直接使用。通过类创建实例，也就是对象，才能使用。</li>
<li>属性：类中的所有变量都称为属性。</li>
<li>方法：类中的所有函数都成为方法。不过，和函数有所不同的是，类方法至少要包含一个 <code>self</code> 参数。类方法不能单独使用，需要和类的对象一起使用。创建对象后就可以直接调用类中的方法和属性。</li>
</ul>
<h2 id="类的 -self- 参数">4.1 类的 self 参数</h2>
<ul>
<li><code>self</code> 是类函数中的必传参数，且必须定义在第一个参数位置</li>
<li><code>self</code> 是一个对象，他代表实例化的变量自身</li>
<li><code>self</code> 可以直接通过点 <strong><code>.</code></strong> 来定义一个类变量</li>
</ul>
<p><code>self</code> 的举例说明：</p>
<p><strong>1、属性</strong></p>
<ol type="1">
<li>如果变量定义在类下面而不是类的方法下面，那这个变量既是类的属性也是类实例的属性。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = <span class="string">&#x27;xiaozhang&#x27;</span></span><br><span class="line">    age = <span class="string">&#x27;21&#x27;</span></span><br><span class="line"></span><br><span class="line">ps = Person()</span><br><span class="line">print(ps.name)</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line">xiaozhang</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>如果变量定义在类的方法下面，如果加了 <code>self</code> ，那这个变量就是 <u> 类实例 </u> 的属性，而不是类的属性；如果没加 <code>self</code> ，那这个变量就是这个方法的局部变量，既不是类的属性也不是类实例的属性。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&#x27;xiaozhang&#x27;</span></span><br><span class="line">        age = <span class="string">&#x27;21&#x27;</span></span><br><span class="line"></span><br><span class="line">ps = Person()</span><br><span class="line">print(ps.name)</span><br><span class="line">print(ps.age)</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">xiaozhang</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">AttributeError: <span class="string">&#x27;Person&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>2、方法</strong></p>
<ol type="1">
<li>如果在类中定义函数时 <u> 加了</u> <code>self</code> ，那这个函数就是类实例的方法，而不是类的方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27; 小张爱跑步 &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps = Person()</span><br><span class="line">ps.run()</span><br><span class="line"><span class="comment"># Person.run()</span></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">小张爱跑步</span><br><span class="line"><span class="comment"># TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>如果在类中定义函数时 <u> 没加</u> <code>self</code> ，那这个函数就只是类的方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">        print(<span class="string">&#x27; 小张爱跑步 &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps = Person()</span><br><span class="line"><span class="comment"># ps.run()</span></span><br><span class="line">Person.run()</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"><span class="comment"># TypeError: run() takes 0 positional arguments but 1 was given</span></span><br><span class="line">小张爱跑步</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="私有函数与私有变量">4.2 私有函数与私有变量</h2>
<ul>
<li>只希望类内部业务调用使用，不希望被使用者调用</li>
<li>私有函数与变量无法被实例化后的对象所调用</li>
<li><p>而类内部可以调用私有函数与变量</p></li>
<li><p>在变量或者函数前添加两个下横线 <code>__</code></p></li>
</ul>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __cat_type = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        tmp = self.__run()</span><br><span class="line">        print(tmp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="subst">&#123;self.name&#125;</span> <span class="subst">&#123;self.__sex&#125;</span> 开心的奔跑着 &#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self</span>):</span></span><br><span class="line">        tmp = self.__jump()</span><br><span class="line">        print(tmp)                                        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__jump</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.__cat_type&#125;</span>, 小猫 <span class="subst">&#123;self.name&#125;</span> <span class="subst">&#123;self.__sex&#125;</span> 开心的跳着 &#x27;</span></span><br><span class="line"></span><br><span class="line">cat = Cat(name = <span class="string">&#x27; 米粒 &#x27;</span>, sex = <span class="string">&#x27;boy&#x27;</span>)</span><br><span class="line">cat.run()</span><br><span class="line">cat.jump()</span><br><span class="line"><span class="comment"># cat.__run()</span></span><br><span class="line">print(<span class="built_in">dir</span>(cat))  <span class="comment"># dir() 可以查看实例化对象有哪些方法</span></span><br><span class="line">print(cat._Cat__jump())  <span class="comment"># 实例化对象调用私有函数也可以行得通，但是最好不要这样做</span></span><br><span class="line">print(cat._Cat__cat_type)</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">cat, 小猫 米粒 boy 开心的奔跑着</span><br><span class="line">cat, 小猫 米粒 boy 开心的跳着</span><br><span class="line">[<span class="string">&#x27;_Cat__cat_type&#x27;</span>, <span class="string">&#x27;_Cat__jump&#x27;</span>, <span class="string">&#x27;_Cat__run&#x27;</span>, <span class="string">&#x27;_Cat__sex&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;jump&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;run&#x27;</span>]</span><br><span class="line">cat, 小猫 米粒 boy 开心的跳着</span><br><span class="line">cat</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="举个栗子 ---- 编程练习">举个栗子 ---- 编程练习：</h3>
<p>自定义一个交通工具类(Vehicle)，并根据提示对该类进行进一步封装，使其拥有工具类型、速度、体积等属性值。通过自定义实例方法实现交通工具的前移、速度设置、获取当前速度、加速行驶、减速行驶、实例信息展示、实例类型判别等功能。</p>
<p>任务 1、自定义一个交通工具类 (Vehicle) 2、设置类属性 trans_type（固定值为 'SUV'）和实例属性速度 speed（int 类型，单位为 km/h）、体积 size（tuple 类型，单位为米。） 3、自定义方法 show_info()，打印实例的所属类型和速度、体积的值； 4、自定义实例方法如下： （1）定义 move() 方法，实现打印“我已向前移动了 50 米” （2）定义 set_speed(new_speed)方法，设置对应实例的速度为 new_speed km/h （3）定义 get_speed()方法，如果（2）中设置了速度值则打印出来，打印格式为 '我的时速为：设置的速度值 km/h' （4）定义 speed_up()方法，设置每次调用时实例的速度都增加 10km/h，并打印“我的速度由 xx km/ 提升到了 xx km/h” （5）定义 speed_down()方法，设置每次调用时实例的速度都降低 15km/h，并打印“我的速度由 xx km/ 下降到了 xx km/h” 5、自定义方法 transport_identify()，判断实例是否为 Vehicle 类型。若是则打印‘类型匹配’，反之则打印‘类型不匹配’ 6、初始化实例对象 tool_1</p>
<p>任务提示 类的初始化方法中所传参数 size 是元组类型，直接传入实例的长，宽，高即可，如 size=(10,10,10)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 自定义 Vehicle 类属性 </span></span><br><span class="line">    trans_type = <span class="string">&#x27;SUV&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例的初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, speed, size</span>):</span></span><br><span class="line">        self.speed = speed</span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法 show_info，打印实例的速度和体积</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot; 我的所属类型为: &#123;&#125;, 我的速度: &#123;&#125; km/h, 我的体积: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.trans_type, self.speed, self.size))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法 move, 打印“我已向前移动了 50 米”</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot; 我已向前移动了 50 米 &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法 set_speed，设置对应的速度值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_speed</span>(<span class="params">self, new_speed</span>):</span></span><br><span class="line">        self.speed = new_speed  <span class="comment"># 在这里将旧速度与新设置的速度进行统一。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法 get_speed，打印当前的速度值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_speed</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot; 我的时速为 &#123;&#125; km/h&quot;</span>.<span class="built_in">format</span>(self.speed))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法 speed_up，实现对实例的加速</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speed_up</span>(<span class="params">self</span>):</span></span><br><span class="line">        old_speed = self.speed</span><br><span class="line">        self.speed += <span class="number">10</span></span><br><span class="line">        print(<span class="string">&quot; 我的时速由 &#123;&#125; km/h 提升到了 &#123;&#125; km/h&quot;</span>.<span class="built_in">format</span>(old_speed, self.speed))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义实例方法 speed_down，实现对实例的减速</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speed_down</span>(<span class="params">self</span>):</span></span><br><span class="line">        old_speed = self.speed</span><br><span class="line">        self.speed -= <span class="number">15</span></span><br><span class="line">        print(<span class="string">&quot; 我的时速由 &#123;&#125; km/h 下降到了 &#123;&#125; km/h&quot;</span>.<span class="built_in">format</span>(old_speed, self.speed))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义实例方法 transport_identify，实现对实例所属类型的判断</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transport_identify</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.trans_type == <span class="string">&#x27;SUV&#x27;</span>:</span><br><span class="line">            print(<span class="string">&quot; 类型匹配 &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot; 类型不匹配 &quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    tool_1 = Vehicle(<span class="number">20</span>, (<span class="number">3.6</span>, <span class="number">1.9</span>, <span class="number">1.75</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用实例方法 打印实例的速度和体积</span></span><br><span class="line">    tool_1.show_info()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用实例方法 实现实例的前移</span></span><br><span class="line">    tool_1.move()</span><br><span class="line"></span><br><span class="line">    tool_1.set_speed(<span class="number">40</span>)</span><br><span class="line">    <span class="comment"># 调用实例方法 打印当前速度</span></span><br><span class="line">    tool_1.get_speed()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用实例方法 对实例进行加速</span></span><br><span class="line">    tool_1.speed_up()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用实例方法 对实例进行减速</span></span><br><span class="line">    tool_1.speed_down()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用实例方法 判断当前实例的类型</span></span><br><span class="line">    tool_1.transport_identify()</span><br><span class="line">    </span><br><span class="line">---------------------------------------------    </span><br><span class="line"> 我的所属类型为: SUV, 我的速度: <span class="number">20</span> km/h, 我的体积: (<span class="number">3.6</span>, <span class="number">1.9</span>, <span class="number">1.75</span>)</span><br><span class="line">我已向前移动了 <span class="number">50</span> 米</span><br><span class="line">我的时速为 <span class="number">40</span> km/h</span><br><span class="line">我的时速由 <span class="number">40</span> km/h 提升到了 <span class="number">50</span> km/h</span><br><span class="line">我的时速由 <span class="number">50</span> km/h 下降到了 <span class="number">35</span> km/h</span><br><span class="line">类型匹配</span><br></pre></td></tr></table></figure>
<h2 id="类的封装">4.3 类的封装</h2>
<p><strong>封装 </strong>：将<u> 不对外的私有属性或方法 </u> 通过 <u> 可对外使用的函数 </u> 而使用（类中定义私有的，只有类内部使用，外部无法访问）</p>
<ul>
<li>这样做的原因：保护隐私，明确区分内外</li>
</ul>
<blockquote>
<p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。 对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者 self 间接获取被封装的内容。</p>
</blockquote>
<h2 id="装饰器">4.4 装饰器</h2>
<p><strong>装饰器 </strong>：装饰器本质上就是一个 python 函数，他可以让其他函数在<strong> 不需要做任何代码变动的前提下，增加额外的功能 </strong>，装饰器的<strong> 返回值也是一个函数对象</strong>。他们有助于让代码更简短，也更 Pythonic（Python 范儿）。装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等等场景。有了装饰器，我们可以抽离出大量与函数功能本身无关的雷同代码。</p>
<p>我们知道，在 python 中，我们可以像使用变量一样使用函数，这主要依赖于以下几点：</p>
<ul>
<li>函数可以被赋值给其他变量</li>
<li>函数可以被删除</li>
<li>可以在函数里面再定义函数，函数嵌套。</li>
<li><strong>函数可以作为参数传递给另外一个函数</strong></li>
<li>函数可以作为另一个函数的返回值</li>
</ul>
<p>为了更好的理解装饰器，先从对一个简单的函数进行装饰，假设有下面这个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure>
<p>现在我们的需求是要增强 <code>hello()</code> 函数的功能，希望给返回加上 HTML 标签，比如<code>&lt;i&gt;he 不得改变</code>hello()` 函数原来的定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span>(<span class="params">fun</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;i&gt;&quot;</span>+fun()+<span class="string">&quot;&lt;/i&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了一个函数 <code>makeitalic</code>，该函数有一个参数 <code>fun</code>，它是一个函数；在 <code>makeitalic</code> 函数里面我们又定义了一个内部函数 <code>wrapped</code> ，并将该函数作为返回。</p>
<p>现在我们就达到了我们的需求，不改变 <code>hello()</code> 函数的定义，但实现了我们想要的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span>(<span class="params">fun</span>):</span></span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span>():</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="string">&quot;&lt;/i&gt;&quot;</span></span><br><span class="line">          <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">hello = makeitalic(hello)</span><br><span class="line">print(hello()) <span class="comment"># &lt;i&gt;hello world&lt;/i&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面，我们将 <code>hello</code> 函数传入 <code>makeitalic</code> ，再将返回赋值给 <code>hello</code> ，此时，调用 <code>hello()</code> 函数就可以得到我们想要的结果。 不过需要注意的是，由于我们将 <code>makeitalic</code> 的返回赋值给 <code>hello</code> ，此时，<code>hello()</code> 函数仍然存在，但它已不在指向原来定义的 <code>hello()</code> 函数了，而是指向了 <code>wrapped</code>。</p>
<p>现在我们来总结一下，上面例子为了增强原函数 <code>hello</code> 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，在这个返回的函数中，执行了原函数，并对原函数的功能进行了增强。完整的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span>(<span class="params">fun</span>):</span></span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span>():</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="string">&quot;&lt;/i&gt;&quot;</span></span><br><span class="line">          <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">hello = makeitalic(hello)</span><br><span class="line">print(hello())</span><br><span class="line">print(hello.__name__)<span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p>事实上，<code>makeitalic</code> 就是一个装饰器（<code>decorator</code>），它封装了原函数 <code>hello</code>，并返回了一个新函数，用于增强原函数的功能，并将其赋值给 <code>hello</code>。</p>
<p>一般情况下，我们使用装饰器提供的<strong><span class="citation" data-cites="语法糖">@语法糖</span>（Syntactic Sugar）</strong>，来简化上面的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span>(<span class="params">fun</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;i&gt;&quot;</span> + fun() + <span class="string">&quot;&lt;/i&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>这种做法是我们在平时写程序时，常见的操作，但前面例子中的讲解才是内部的实现原理。</p>
<p>像上面的情况，可以动态的修改函数（或类的）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 <code>hello</code>）为参数，并返回一个包装后的函数（比如上面的 <code>wrapped</code>）给被修饰函数（<code>hello</code>）。</p>
<blockquote>
<p>之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，<strong>糖在不改变其所在位置的语法结构的前提下，实现了运行时等价</strong>。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。</p>
<p>之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：<strong>代码更简洁流畅，代码更语义自然</strong>... 写得爽，看着爽，就像吃了糖 hhh。据说还有语法盐 hhh 反人类的代码</p>
</blockquote>
<p>举个简单的栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_str</span>(<span class="params">func</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;func:&#x27;</span>, func)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;args:&#x27;</span>, args, kwargs)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">if</span> result == <span class="string">&#x27;okk&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;result is %s&#x27;</span> % result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;result is failed:%s &#x27;</span> % result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@check_str</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">result = test(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">result = test(<span class="string">&#x27;okk&#x27;</span>)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">func: &lt;function test at <span class="number">0x00000191FC0A9168</span>&gt;</span><br><span class="line">args: (<span class="string">&#x27;no&#x27;</span>,) &#123;&#125;</span><br><span class="line">result <span class="keyword">is</span> failed:no </span><br><span class="line">args: (<span class="string">&#x27;okk&#x27;</span>,) &#123;&#125;</span><br><span class="line">result <span class="keyword">is</span> okk</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小练习：</p>
<figure>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 机器学习 /image-20201231201524698.png" alt="image-20201231201524698" /><figcaption>image-20201231201524698</figcaption>
</figure>
<p>输出：</p>
<p>​ 2018-11-27</p>
<p>​ call hello()</p>
<p>​ hello world</p>
<p>​ 本题考查的是装饰器的应用。代码中函数的执行顺序为先执行 now 函数再执行 hello 函数，执行 now 函数时输出 2018-11-27，当执行 hello 函数时，发现了装饰器 log 函数，因此要先执行装饰器，输出 call hello(): ，然后执行传入的 hello 函数，输出 hello world</p>
</blockquote>
<h2 id="常用的装饰器">4.5 常用的装饰器</h2>
<ul>
<li><code>classmethod</code></li>
<li><code>staticmethod</code></li>
<li><code>property</code></li>
</ul>
<h3 id="classmethod- 的功能">4.5.1 <code>classmethod</code> 的功能</h3>
<p><code>classmethod</code> ：将类函数可以不经过实例化而直接被调用。</p>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a</span>):</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;run&#x27;</span>)</span><br><span class="line">        self.jump()  <span class="comment"># # &gt;&gt;&gt; run/n jump 证明普通的 self 函数可以调用带有 classmethod 装饰器的类函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;jump&#x27;</span>)</span><br><span class="line">        <span class="comment"># cls.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span></span><br><span class="line">                   <span class="comment"># 证明带有 classmethod 装饰器的类函数无法调用 self 函数</span></span><br><span class="line"></span><br><span class="line">t = Test(<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line"><span class="comment"># t.run()</span></span><br><span class="line"><span class="comment"># Test.run()  # TypeError: run() missing 1 required positional argument: &#x27;self&#x27;</span></span><br><span class="line">            <span class="comment"># 因为没有实例化！(这时就可以用 classmethod)</span></span><br><span class="line"><span class="comment"># Test.jump()  # &gt;&gt;&gt; jump</span></span><br><span class="line">t.run()   <span class="comment"># &gt;&gt;&gt; run/n jump</span></span><br></pre></td></tr></table></figure>
<h3 id="staticmethod- 的功能">4.5.2 <code>staticmethod</code> 的功能</h3>
<p><code>staticmethod</code> ：可以将类函数不经过实例化而直接被调用，被该装饰器调用的函数 <strong> 不许传递 <code>self</code> 或 <code>cls</code> 参数</strong>，且无法在该函数内调用其它类函数或类变量。</p>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a</span>):</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;run&#x27;</span>)</span><br><span class="line">        self.sleep()  <span class="comment"># 证明普通的 self 函数可以调用带有 staticmethod 装饰器的类函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;i wanna sleep&#x27;</span>)</span><br><span class="line">        self....  <span class="comment"># 直接报错，都没有 self 参数</span></span><br><span class="line"></span><br><span class="line">t = Test(<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line">Test.sleep()  <span class="comment"># &gt;&gt;&gt; i wanna sleep</span></span><br><span class="line">t.sleep()  <span class="comment"># &gt;&gt;&gt; i wanna sleep</span></span><br><span class="line">t.run()  <span class="comment"># &gt;&gt;&gt; run\n i wanna sleep</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="property- 的功能">4.5.3 <code>property</code> 的功能</h3>
<p><code>property</code> ：将类含糊的执行免去括弧，类似于调用属性(变量)</p>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__name = value</span><br><span class="line"></span><br><span class="line">t = Test(name=<span class="string">&#x27;xiaozhang&#x27;</span>)</span><br><span class="line">print(t.name)</span><br><span class="line"></span><br><span class="line">t.name = <span class="string">&#x27;xiaohong&#x27;</span>  <span class="comment"># AttributeError: can&#x27;t set attribute</span></span><br><span class="line">print(t.name)</span><br></pre></td></tr></table></figure>
<h2 id="类的继承">4.6 类的继承</h2>
<p>1、什么是继承？</p>
<ul>
<li>通过继承基类来得到基类的功能</li>
<li>被继承的类称作父类或基类，继承者称作子类</li>
<li><strong>代码重用</strong></li>
</ul>
<p>2、父类和子类的关系？</p>
<ul>
<li>子类拥有父类的 <strong> 所有属性和方法</strong></li>
<li>父类不具备子类 <strong> 自有 </strong> 的属性和方法</li>
</ul>
<p>3、继承的用法：</p>
<ul>
<li>定义子类时，将父类传入子类参数内</li>
<li>子类实例化可以调用自己与父类的函数与变量</li>
<li>父类无法调用子类的函数与变量</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> is talking&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_sex</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.sex == <span class="string">&#x27;boy&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> is a boy&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> is a girl&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildOne</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play_football</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> is playing football&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildTwo</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play_pingpong</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> is playing pingpong&#x27;</span></span><br><span class="line"></span><br><span class="line">c_one = ChildOne(name=<span class="string">&#x27; 小张 &#x27;</span>, sex=<span class="string">&#x27;girl&#x27;</span>)</span><br><span class="line">result = c_one.play_football()</span><br><span class="line">print(result)</span><br><span class="line">result = c_one.talk()</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">c_two = ChildTwo(name=<span class="string">&#x27; 小红 &#x27;</span>, sex=<span class="string">&#x27;girl&#x27;</span>)</span><br><span class="line">result = c_two.play_pingpong()</span><br><span class="line">print(result)</span><br><span class="line">result = c_two.talk()</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">p = Parent(name=<span class="string">&#x27; 父亲 &#x27;</span>, sex=<span class="string">&#x27;boy&#x27;</span>)</span><br><span class="line">result = p.talk()</span><br><span class="line">print(result)</span><br><span class="line">result = p.is_sex()</span><br><span class="line">print(result)</span><br><span class="line">result = p.playing()  <span class="comment"># AttributeError: &#x27;Parent&#x27; object has no attribute &#x27;playing&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、<strong><code>super</code> 函数 </strong> 的作用 (<strong>单继承</strong>)</p>
<p><code>super</code> ：是 python 子类继承父类的方法而使用的关键字，当子类继承父类后，就可以使用父类的方法。</p>
<blockquote>
<p>注：一般适用于 <strong> 单继承</strong>。</p>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, p</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;hello i am parent %s&#x27;</span> % p)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, c, p</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(p)</span><br><span class="line">        print(<span class="string">&#x27;hello i am child %s&#x27;</span> % c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = Child(c=<span class="string">&#x27; 小张 &#x27;</span>, p=<span class="string">&#x27; 老张 &#x27;</span>)</span><br><span class="line">    </span><br><span class="line">----------------------------------------------------</span><br><span class="line">hello i am parent 老张</span><br><span class="line">hello i am child 小张</span><br></pre></td></tr></table></figure>
<h1 id="差一个 5.5 编程练习">==<strong>差一个 5.5 编程练习</strong>==</h1>
<h3 id="举个栗子 ---- 编程练习 -1">举个栗子 ---- 编程练习：</h3>
<p>自定义两个类 Person 和 Student，且 Student 继承自 Person。Person 类主要描述人的姓名和性别两大基本特征。Student 类除了保持父类的基本属性之外还具有分数、主修两个公有属以及一个私有属性（学号）。请根据上述的基本说明，对 stu 和 stu_2 两个对象的信息进行综 合展示。</p>
<p>任务 1、自定义 Person 类，并重写其构造（初始化）方法 <code>__init__()</code>，将 name 和 gender 参数赋值给实例对象的属性 2、自定义实例方法<code>speak()</code>，功能：打印“hello ! 我是 xxx”。<code>relaton()</code> 方法主要是占位作用，无其他实质性功能 3、自定义 Student 类，继承自 Person 类，并重写其构造（初始化）方法 <code>__init__()</code>，name、gender 参数通过调用父类的构造函数进行赋值，score 和 major 通过子类重写的<code>__init__()</code> 进行赋值。 4、自定义实例方法<code>speak()</code>，功能：打印 '我的学号为 xxxxxxxxxx，很高兴认识大家'; 5、自定义实例方法<code>identify_stu()</code>，功能：判断 Student 对象的学号。若学号为 2018014002，则打印‘我的分组已经完成’，反之则打印‘请稍后，马上为你自动分组’； 6、自定义实例方法<code>set_num(new_num)</code>，功能：将学号重写设置为 new_num； 7、自定义实例方法<code>relation()</code>，功能：判断 Student 是否为 Person 的子类。若成立，则打印‘我的父类是 Person’，反之则打印‘父类在查询中······’ 8、初始化实例对象 stu 和 stu_2，并根据上述效果图调用对应方法</p>
<p>任务提示 Person 类中的实例方法 <code>relation()</code> 为占位功能时，其方法体可用 pass 语句代替</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 重写实例对象的构造（初始化）方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法，格式化打印实例属性 name 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;hello! 我是 %s 。&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法，占位作用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">relation</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="comment"># 重写实例对象的构造（初始化）方法，并调用父类构造方法，实现对实例属性的赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, gender, score, major, __stu_num = <span class="string">&#x27;2018014002&#x27;</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__( name, gender)</span><br><span class="line">        self.score = score</span><br><span class="line">        self.major = major</span><br><span class="line">        self.__stu_num = __stu_num</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法，格式化打印实例属性 stu_num 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27; 我的学号为 %s，很高兴认识大家 &#x27;</span> % self.__stu_num)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法，判断学号是否为既定值，并根据判断结构 进行分类打印</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">identify_stu</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__stu_num == <span class="string">&#x27;2018014002&#x27;</span>:</span><br><span class="line">            print(<span class="string">&quot; 我的分组已经完成 &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot; 请稍后，马上为你自动分组 &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法，设置实例对象的学号为传入的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_num</span>(<span class="params">self, new_num</span>):</span></span><br><span class="line">        self.__stu_num = new_num</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义实例方法，判断该类是否为 Person 类的子类，并进行分类打印</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">relation</span>(<span class="params">self, cls_son, cls_fa</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">issubclass</span>(cls_son, cls_fa):</span><br><span class="line">            print(<span class="string">&quot; 我的父类是 Person&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot; 父类正在查询中....&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stu = Student(<span class="string">&#x27; 小明 &#x27;</span>, <span class="string">&#x27; 男 &#x27;</span>, <span class="number">90</span>, <span class="string">&#x27; 数学 &#x27;</span>)</span><br><span class="line">    <span class="comment"># 调用 speak 方法 打印 stu 对应的值</span></span><br><span class="line">    stu.speak()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用实例方法 鉴别学号是否为指定值</span></span><br><span class="line">    stu.identify_stu()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用实例方法 鉴别实例对象所属的类的父类是否为 Person</span></span><br><span class="line">    stu.relation(Student, Person)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;---&quot;</span> * <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    stu_2 = Student(<span class="string">&#x27; 小红 &#x27;</span>, <span class="string">&#x27; 女 &#x27;</span>, <span class="number">89</span>, <span class="string">&#x27; 英语 &#x27;</span>)</span><br><span class="line">    <span class="comment"># 调用实例方法 设置 stu_2 的学号为 &#x27;2018040625&#x27;</span></span><br><span class="line">    stu_2.set_num(<span class="string">&#x27;2018040625&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用实例方法 打印 stu_2 对应的值</span></span><br><span class="line">    stu_2.speak()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用实例方法 鉴别学号是否为指定值</span></span><br><span class="line">    stu_2.identify_stu()</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"> 我的学号为 <span class="number">2018014002</span>，很高兴认识大家 </span><br><span class="line"> 我的分组已经完成 </span><br><span class="line"> 我的父类是 Person</span><br><span class="line">------------------------------------</span><br><span class="line">我的学号为 <span class="number">2018040625</span>，很高兴认识大家 </span><br><span class="line"> 请稍后，马上为你自动分组</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类的多态">4.7 类的多态</h2>
<p>1、什么是多态？</p>
<p>多态是指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承）</p>
<blockquote>
<p>注：多态和多态性不是同一概念。</p>
<p>什么是多态性？</p>
<ul>
<li><p>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。<strong>子类继承父类；子类重写父类方法</strong></p></li>
<li><p>多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27; 小明的爸爸说了一句话 &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27; 小明的哥哥在奔跑...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27; 小明的哥哥在说话...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27; 小明也说话 &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    b = Brother()</span><br><span class="line">    b.run()</span><br><span class="line">    b.talk()</span><br><span class="line"></span><br><span class="line">    p = Parent()</span><br><span class="line">    p.talk()</span><br><span class="line"></span><br><span class="line">    c = Child()</span><br><span class="line">    c.talk()</span><br><span class="line">    </span><br><span class="line">----------------------------------------------------</span><br><span class="line">小明的哥哥在奔跑...</span><br><span class="line">小明的哥哥在说话...</span><br><span class="line">小明的爸爸说了一句话 </span><br><span class="line"> 小明也说话</span><br></pre></td></tr></table></figure>
<p>2、为什么要使用多态？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span> <span class="comment"># 同一类事物: 动物</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span> <span class="comment"># 动物的形态之一: 猫</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;say miaomiao&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span> <span class="comment"># 动物的形态之二: 狗</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;say wangwang&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span>(<span class="params">Animal</span>):</span> <span class="comment"># 动物的形态之三: 猪</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;say aoao&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c = Cat()</span><br><span class="line">d = Dog()</span><br><span class="line">p = Pig()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">obj</span>):</span></span><br><span class="line">    obj.talk()</span><br><span class="line"></span><br><span class="line">func(c)</span><br><span class="line">func(d)</span><br><span class="line">func(p)</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>say miaomiao</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>say wangwang</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>say aoao</span><br></pre></td></tr></table></figure>
<p>仅仅是用了一个 <code>func(obj)</code> 函数，不同的对象就实现了不同的功能。综上可以说，多态性是 : <strong>一个接口，多种实现</strong></p>
<p><strong>多态性的好处:</strong></p>
<ul>
<li>增加了程序的 <strong> 灵活性</strong>，以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如 <code>func(obj)</code></li>
<li>增加了程序额 <strong> 可扩展性</strong>，通过继承 animal 类创建了一个新的类，使用者无需更改自己的代码，还是用 <code>func(obj)</code> 去调用</li>
</ul>
<h2 id="类的多重继承">4.8 类的多重继承</h2>
<p>1、什么是多重继承？</p>
<p>我理解为一个子类可以继承多个父类。</p>
<p>2、多重继承的方法？</p>
<p><code>class Child(Parent1, Parent 2, Parent 3...)</code>，从左往右依次继承</p>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;tool work&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;car will run&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;food work&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cake</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;i like cake&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">Tool, Food</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Person()</span><br><span class="line">    print(p.car(), <span class="string">&#x27; &#x27;</span>, p.cake())</span><br><span class="line">    print(p.work())  <span class="comment"># 继承的第一个类</span></span><br><span class="line">    print(Person.__mro__)  <span class="comment"># 得到类的继承顺序</span></span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line">car will run   i like cake</span><br><span class="line">tool work</span><br><span class="line">(&lt;class &#x27;__main__.Person&#x27;&gt;, &lt;class &#x27;__main__.Tool&#x27;&gt;, &lt;class &#x27;__main__.Food&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：继承关系可以延续。例，孙子继承父亲，父亲继承爷爷，则孙子也继承爷爷。</p>
</blockquote>
<h3 id="举个栗子 ---- 编程练习 -2">举个栗子 ---- 编程练习：</h3>
<p>圆形、长方形除了是几何学科中的基本图形之外，也还是我们日常生活中最常见的平面图形。请根据面向对象的相关知识，将上述两种平面图形用 Python 语言进行表示，使得我们的程序可以正常对其使用。</p>
<p>任务 1、自定义 Point 类，并重写其构造（初始化）方法 <code>__init__()</code>，将参数 x 和 y 赋值给实例对象的属性 2、自定义该类实例方法 <code>string()</code>，功能：打印“{X：xx, Y：xx}” 3、自定义 Circle 类，继承自 Point 类，并重写其构造（初始化）方法<code>__init__()</code>，x、y 参数通过调用父类的构造函数进行赋值，radius 通过子类重写的<code>__init__()</code> 进行赋值。 4、自定义该类实例方法<code>string()</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; {半径为：xx}” 5、自定义 Size 类，并重写其构造（初始化）方法<code>__init__()</code>，将参数 width 和 height 赋值给实例对象的属性 6、自定义该类实例方法<code>string()</code>，功能：打印“{Width：xx, Height：xx}” 7、自定义 Rectangle 类，继承自 Point 类和 Size 类，并重写其构造（初始化）方法<code>__init__()</code>，x、y、width、height 4 个参数全部通过调用父类的构造函数进行赋值 8、自定义该类实例方法<code>string()</code>，功能：打印“该图形初始化点为：{X：xx, Y：xx}; 长宽分别为：{Width：xx, Height：xx} 9、初始化 Circle 类的对象 c，并调用其格式化输出函数<code>string()</code> 10、初始化 Rectangle 类的对象 r1、r2, 并分别调用其格式化输出函数<code>string()</code></p>
<p>任务提示 1、在自定义 Rectangle 类的构造方法时，调用父类方法必须按照 <code> 类名.__init__(参数列表)</code>的方式进行调用，如 <code>Point.__init__(self, x, y)</code> 2、自定义 Rectangle 类格式化输出方法时，调用父类的格式化输出函数<code>string()</code> 时，应按照 <code> 类名.string(参数)</code>的方式进行调用，如<code>Point.string(self)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    x = <span class="number">1.0</span></span><br><span class="line">    y = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义 Point 类的构造 (初始化) 方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        print(<span class="string">&quot;Point 构造函数被调用...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义 Point 类对象的格式化输出函数(string())</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">string</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;&#123;X: %s, Y: %s&#125;&quot;</span>  % (self.x, self.y))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>(<span class="params">Point</span>):</span></span><br><span class="line">    <span class="comment"># 自定义 Circle 类的构造(初始化) 方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y, radius</span>):</span></span><br><span class="line">        Point.__init__(self, x, y)</span><br><span class="line">        self.radius = radius</span><br><span class="line">        print(<span class="string">&quot;Circle 构造函数被调用...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义 Circle 类对象的格式化输出函数(string())</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">string</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot; 该图形初始化点为: &#123;X: &quot;</span> + <span class="built_in">str</span>(self.x) + <span class="string">&quot;, Y: &quot;</span> + <span class="built_in">str</span>(self.y) \</span><br><span class="line">               + <span class="string">&quot;&#125;, &#123; 半径为: &quot;</span> + <span class="built_in">str</span>(self.radius) + <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 自定义 Size 类的构造(初始化) 方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, width, height</span>):</span></span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">        print(<span class="string">&quot;Size 构造函数被调用...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义 Size 类对象的格式化输出函数(string())</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">string</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;&#123;Height: &quot;</span> + <span class="built_in">str</span>(self.width) + <span class="string">&quot;, Width: &quot;</span> + <span class="built_in">str</span>(self.height) + <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>(<span class="params">Point, Size</span>):</span></span><br><span class="line">    <span class="comment"># 自定义 Rectangle 类的构造(初始化) 方法，并在方法中调用父类的初始化方法以完成初始化 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y, width, height</span>):</span></span><br><span class="line">        Point.__init__(self, x, y)</span><br><span class="line">        Size.__init__(self, width, height)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义 Rectangle 类对象的格式化输出函数(string())</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">string</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot; 该图形初始化点为: &#123;X: &quot;</span> + <span class="built_in">str</span>(self.x) + <span class="string">&quot;, Y: &quot;</span> + <span class="built_in">str</span>(self.y) + <span class="string">&quot;&#125;&quot;</span> + \</span><br><span class="line">              <span class="string">&quot;, 长宽分别为: &#123;Height: &quot;</span> + <span class="built_in">str</span>(self.width) + <span class="string">&quot;, Width: &quot;</span> + <span class="built_in">str</span>(self.height) + <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 实例化 Point 对象，点位置为（3, 3）</span></span><br><span class="line">    p = Point(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">    p.string()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化 Circle 对象，圆心为（5,5），半径为 8</span></span><br><span class="line">    c = Circle(<span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br><span class="line">    c.string()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化 Rectangle 对象，顶点位置（15,30），长和宽分别为 20 和 10</span></span><br><span class="line">    r = Rectangle(<span class="number">15</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line">    r.string()</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line">Point 构造函数被调用...</span><br><span class="line">&#123;X: <span class="number">3</span>, Y: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">Point 构造函数被调用...</span><br><span class="line">Circle 构造函数被调用...</span><br><span class="line"> 该图形初始化点为: &#123;X: <span class="number">5</span>, Y: <span class="number">5</span>&#125;, &#123; 半径为: <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">Point 构造函数被调用...</span><br><span class="line">Size 构造函数被调用...</span><br><span class="line">该图形初始化点为: &#123;X: <span class="number">15</span>, Y: <span class="number">30</span>&#125;, 长宽分别为: &#123;Height: <span class="number">20</span>, Width: <span class="number">10</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>该案例如果用 super()调用拥有同名方法的父类，就只会调用最靠前的拥有同名方法的类，后面的类中同名方法也就无法被调用。</strong></p>
<p><strong>因此本案例多继承中进行父类调用时采用“<code>类名.__init__</code>”的形式。</strong></p>
</blockquote>
<h2 id="类的高级函数">4.9 类的高级函数</h2>
<ul>
<li><code>__str__</code> 函数</li>
<li><code>__gtrattr()__</code> 函数</li>
<li><code>__setattr__</code> 函数</li>
<li><code>__call__</code> 函数</li>
</ul>
<h3 id="str__- 函数">4.9.1 <code>__str__</code> 函数</h3>
<p>如果定义了该函数，当 print 当前实例化对象时候，会返回该函数的 return 信息。</p>
<ul>
<li>通常会返回一个字符串作为类的描述信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 一般会定义一些类的描述信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;this is a test class&#x27;</span></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>
<h3 id="gtrattr__- 函数">4.9.2 <code>__gtrattr__</code> 函数</h3>
<p>当调用的属性或者方法不存在时，会返回该方法定义的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; 这个 key: &#123;&#125; 并不存在 &#x27;</span>.<span class="built_in">format</span>(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(t.a)  # AttributeError: &#x27;Test&#x27; object has no attribute &#x27;a&#x27;</span></span><br><span class="line">print(t.a)  <span class="comment"># &gt;&gt;&gt; 这个 key: a 并不存在</span></span><br></pre></td></tr></table></figure>
<h3 id="setattr__.- 函数">4.9.3 <code>__setattr__.</code> 函数</h3>
<p>拦截当前类中不存在的属性与值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="comment"># print(key, value)</span></span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line">        print(self.__dict__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.name = <span class="string">&#x27; 小明 &#x27;</span></span><br><span class="line">print(t.name)</span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 小明 &#x27;</span>&#125;</span><br><span class="line">小明</span><br></pre></td></tr></table></figure>
<h3 id="call__- 函数">4.9.4 <code>__call__</code> 函数</h3>
<p>本质是将一个类变成一个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, a</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call func will start&#x27;</span>)</span><br><span class="line">        print(a)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t(<span class="string">&#x27;xiaoming&#x27;</span>)</span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line">call func will start</span><br><span class="line">xiaoming</span><br></pre></td></tr></table></figure>
<h1 id="综合练习函数的使用 -1">== 综合练习：函数的使用 ==</h1>
<p>对第三章习题的重构，第三章用的是函数开发，这一章面向类开发。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="异常">5. 异常</h1>
<ul>
<li>异常就是错误</li>
<li><p>异常会导致程序崩溃并停止运行</p></li>
<li><p>python 中的异常机制能监控并捕获异常，将异常部位的程序进行修理使得程序继续正常运行</p></li>
</ul>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt; 代码块 <span class="number">1</span>&gt; 被<span class="keyword">try</span> 关键字检查并保护的业务代码</span><br><span class="line"><span class="keyword">except</span> &lt; 异常的类型 &gt;:</span><br><span class="line">    &lt; 代码块<span class="number">2</span>&gt; <span class="comment"># 代码块 1 出现错误后执行的代码块</span></span><br></pre></td></tr></table></figure>
<p>1、捕获通用异常</p>
<ul>
<li>无法确定是在哪种异常情况下使用的捕获方法</li>
</ul>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt; 代码块 &gt; </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    &lt; 异常代码块 &gt; </span><br></pre></td></tr></table></figure>
<p>2、捕获具体异常</p>
<ul>
<li><p>确定是哪种异常的情况下使用的捕获方法</p></li>
<li><p><code>exceppt &lt; 具体的异常类型 &gt; as e</code></p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UPPER</span>(<span class="params">str_data</span>):</span></span><br><span class="line">    new_str = <span class="string">&#x27;None&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        new_str = str_data.upper()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">        print(<span class="string">&#x27; 程序出错了:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(e))</span><br><span class="line">    <span class="keyword">return</span> new_str</span><br><span class="line"></span><br><span class="line">result = UPPER(<span class="string">&#x27;xiaohong&#x27;</span>)</span><br><span class="line">result1 = UPPER(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;result1 is&#x27;</span>, result1)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        print(<span class="string">&#x27;hello&#x27;</span>)  <span class="comment"># 遇到错误立刻进入 except，所以错误后的代码全都不会执行</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">        print(name)  <span class="comment"># except 里没有对应的异常类型，所以报错了</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure>
<p>3、捕获多个异常</p>
<ol type="1">
<li>可以有多个 except 并列。但当第一个异常捕获到之后，不会再继续往下捕获。</li>
<li>写一个 <code>except (异常类型 1, 异常类型 2) as e</code> 。当 except 代码后边的异常类型使用 <strong> 元组 </strong> 包裹起来，捕获到哪种就抛哪种</li>
</ol>
<h2 id="常用异常类型">5.1 常用异常类型</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">异常名称</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Exception</td>
<td style="text-align: left;">通用异常类型（基类）</td>
</tr>
<tr class="even">
<td style="text-align: left;">ZeroDivisionError</td>
<td style="text-align: left;">不能整除 0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">AttributeError</td>
<td style="text-align: left;">对象没有这个属性</td>
</tr>
<tr class="even">
<td style="text-align: left;">IOError</td>
<td style="text-align: left;">输入输出操作失败</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IndexError</td>
<td style="text-align: left;">没有当前的索引</td>
</tr>
<tr class="even">
<td style="text-align: left;">KeyError</td>
<td style="text-align: left;">没有这个键值（key）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NameError</td>
<td style="text-align: left;">没有这个变量（未初始化对象）</td>
</tr>
<tr class="even">
<td style="text-align: left;">SyntaxError</td>
<td style="text-align: left;">Python 语法错误</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SystemError</td>
<td style="text-align: left;">解释器的系统错误</td>
</tr>
<tr class="even">
<td style="text-align: left;">ValueError</td>
<td style="text-align: left;">传入的参数错误</td>
</tr>
</tbody>
</table>
<p>举个栗子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    t.name</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)  <span class="comment"># &#x27;Test&#x27; object has no attribute &#x27;name&#x27;</span></span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 小明 &#x27;</span>&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    d[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27; 没有对应的键: &#x27;</span>, e)  <span class="comment"># 没有对应的键:  &#x27;age&#x27;</span></span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    l[<span class="number">5</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)  <span class="comment"># list index out of range</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;ssss&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>(name)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)  <span class="comment"># invalid literal for int() with base 10: &#x27;ssss&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    test()</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)  <span class="comment"># test() missing 1 required positional argument: &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="异常中的 finally">5.2 异常中的 finally</h2>
<ul>
<li>无论是否发生异常，只要定义了 <code>finally</code>，就一定会执行其中的代码块。</li>
<li>在函数中，即便在 <code>try</code> 或 <code>except</code> 中进行了 return 也依然会执行 <code>finally</code> 语法块</li>
<li><code>try</code> 语法至少要伴随 <code>except</code> 或 <code>finally</code> 中的一个来使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;finally&#x27;</span></span><br><span class="line">t = test1()</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test4</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;finally&#x27;</span>  <span class="comment"># 即使在 try 和 except 中进行 return，也依然会执行 finally</span></span><br><span class="line">    </span><br><span class="line">--------------------------------------------------</span><br><span class="line">division by zero</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">finally</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义异常类型与抛出异常">5.3 自定义异常类型与抛出异常</h2>
<h3 id="自定义抛出异常 -raise">5.3.1 自定义抛出异常 <code>raise</code></h3>
<p>将信息以报错的形式抛出。</p>
<figure>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/ 编程语言 /Python/image-20210113161932209.png" alt="image-20210113161932209" /><figcaption>image-20210113161932209</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;number 不可以是 100&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> number</span><br><span class="line"></span><br><span class="line">print(test(<span class="number">50</span>))</span><br><span class="line">t = test(<span class="number">100</span>)  <span class="comment"># ValueError: number 不可以是 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> test(number)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">    </span><br><span class="line">t2 = test2(<span class="number">100</span>)</span><br><span class="line">print(t2)</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="number">50</span></span><br><span class="line">number 不可以是<span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义异常类型">5.3.2 自定义异常类型</h3>
<ul>
<li>继承基类 ----<code>Exception</code></li>
<li>在构造函数中定义错误信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberLimitError</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, message</span>):</span></span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameLimitError</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, message</span>):</span></span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27; 小明 &#x27;</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameLimitError(<span class="string">&#x27; 小明不可以被填写 &#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test0</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">if</span> number &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">raise</span> NumberLimitError(<span class="string">&#x27; 数字不可以大于 100&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    test(<span class="string">&#x27; 小明 &#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NameLimitError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    test0(<span class="number">101</span>)</span><br><span class="line"><span class="keyword">except</span> NumberLimitError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"> </span><br><span class="line">--------------------------------------------------</span><br><span class="line">小明不可以被填写 </span><br><span class="line"> 数字不可以大于<span class="number">100</span></span><br></pre></td></tr></table></figure>
<h2 id="断言">5.4 断言</h2>
<p>断言：用于判断一个表达式，在表达式条件为 false 的时候触发异常(为 true 无输出)。</p>
<p>可以对综合案例进行改进：</p>
<h1 id="bug">6. bug</h1>
<p>bug 是程序中出现的错误，但有没有通过异常去捕获，以至于直接抛出，导致程序的崩溃。</p>
<p>如何检查 bug？</p>
<ol type="1">
<li><p>调试工具(eg.pycharm) debug。在想要停止的行的左侧点击一下会出现一个小红点，断点。程序运行到这行会停止(包括这一行)。</p></li>
<li><p>多打印信息。(多 print 可以聚焦错误点，简单)</p></li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络课堂笔记总结</title>
    <url>/2020/09/30/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络知识点总结"><a href="#计算机网络知识点总结" class="headerlink" title="计算机网络知识点总结"></a>计算机网络知识点总结</h1><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200815124453263.png" alt="IMG_2219(20200815-125837)"></p>
<h2 id="一、计算机网络的定义"><a href="#一、计算机网络的定义" class="headerlink" title="一、计算机网络的定义"></a>一、计算机网络的定义</h2><ul>
<li>定义：计算机网络就是一些互连的，自治的计算机系统的集合。</li>
<li>功能：<ol>
<li><strong>数据通信</strong>：计算机网络<code>最基本</code>和<code>最重要</code>的功能，包括连接控制、传输控制、差错控制、流量控制、路由选择、多路复用等子功能；</li>
<li><strong>资源共享</strong>：包括数据资源、软件资源以及硬件资源；</li>
<li><strong>分布式处理</strong>：当计算机网络中某个计算机系统负载过重时，可以将其处理的任务传送给网络中的其他计算机系统进行处理，利用空闲计算机资源提高整个系统的利用率；</li>
<li><strong>信息综合处理</strong>：将分散在各地计算机中的数据资料进行集中处理或分级处理；</li>
<li><strong>负载均衡</strong>：将工作任务均衡地分配给计算机网络中的各台计算机；</li>
<li><strong>提高可靠性</strong>：计算机网络中的各台计算机可以通过网络互为替代机。</li>
</ol>
</li>
</ul>
<h2 id="二、计算机网络的分类"><a href="#二、计算机网络的分类" class="headerlink" title="二、计算机网络的分类"></a>二、计算机网络的分类</h2><p>(1)按分布范围分类：广域网、城域网、局域网、个人区域网；<br>(2)按拓扑结构分类：星形网络、总线型网络、环形网络、网状型网络；<br>(3)按传输技术分类：广播式网络、点对点网络；<br>(4)按使用者分类：公用网、专用网；<br>(5)按数据交换技术分类：电路交换网络、报文交换网络、分组交换网络；</p>
<h2 id="三、介绍一下五层协议"><a href="#三、介绍一下五层协议" class="headerlink" title="三、介绍一下五层协议"></a>三、介绍一下五层协议</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IMG_2219(20200815-125837).PNG" alt="IMG_2219(20200815-125837)"></p>
<h2 id="四、说一说OSI七层模型"><a href="#四、说一说OSI七层模型" class="headerlink" title="四、说一说OSI七层模型"></a>四、说一说OSI七层模型</h2><p>其中表示层和会话层用途如下：</p>
<ul>
<li><p>表示层 ：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。</p>
</li>
<li><p>会话层 ：建立及管理会话。</p>
</li>
</ul>
<p>其余五层同五层协议。</p>
<h2 id="五、说一说TCP-IP四层模型"><a href="#五、说一说TCP-IP四层模型" class="headerlink" title="五、说一说TCP/IP四层模型"></a>五、说一说TCP/IP四层模型</h2><p>TCP/IP参考模型分为四个层次：应用层、传输层、网络互连层和网络接口层。</p>
<p>1、主机到网络层　　</p>
<p>​        实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。　　</p>
<p>2、网络互连层　　</p>
<p>　　网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。　　</p>
<p>3、传输层　　</p>
<p>　　在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。　　</p>
<p>4、应用层　　</p>
<p>​        TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现，为特定应用程序提供数据传输服务。</p>
<h2 id="六、端到端通信和点到点通信的区别？"><a href="#六、端到端通信和点到点通信的区别？" class="headerlink" title="六、端到端通信和点到点通信的区别？"></a>六、端到端通信和点到点通信的区别？</h2><p>从本质上说，由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到 点的服务， 而传输层为网络中的主机提供端到端的通信。 </p>
<ul>
<li>直接相连的结点之间的通信称为点到点通信， 它只提供一台机器到另一台机器之间的通信， 不涉及程序或进程的概念。同时，点到点通信并不能保证数据传输的可靠性，也不能说明源主机 与目的主机之间是哪两个进程在通信，这些工作都是由传输层来完成的。</li>
<li>端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是比点到 点通信更高一级的通信方式，以完成应用程序（进程） 之间的通信。”端” 是指用户程序的端口， 端口号标识了应用层中不同的进程。</li>
</ul>
<h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h1><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200530163458793.png" alt="image-20200530163458793"></p>
<h2 id="一、网络应用模型"><a href="#一、网络应用模型" class="headerlink" title="一、网络应用模型"></a>一、网络应用模型</h2><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710160145030.png" alt="image-20200710160145030"  />

<table>
<thead>
<tr>
<th align="left">客户机（client）</th>
<th align="left">服务器（server）</th>
<th align="left">P2P</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1. 服务请求方</td>
<td align="left">1. 服务提供方</td>
<td align="left">1. 既client又server</td>
</tr>
<tr>
<td align="left">2. 不是一直在线的</td>
<td align="left">2. 是一直在线的（always-on host）</td>
<td align="left">2. 不是一直在线的</td>
</tr>
<tr>
<td align="left">3. 动态IP地址</td>
<td align="left">3. 固定IP地址</td>
<td align="left">3. 动态IP地址</td>
</tr>
<tr>
<td align="left">4. 客户机间接性接入</td>
<td align="left"></td>
<td align="left">4. 间接性接入</td>
</tr>
<tr>
<td align="left">5. 客户机之间不能相连</td>
<td align="left"></td>
<td align="left">5. 之间可以直接相连</td>
</tr>
<tr>
<td align="left">6. 可扩展性差。</td>
<td align="left"></td>
<td align="left">6. 可扩展性好。</td>
</tr>
<tr>
<td align="left">（受网络带宽和服务器硬件限制）</td>
<td align="left">（服务器支持的客户机数有限）</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="二、域名系统DNS"><a href="#二、域名系统DNS" class="headerlink" title="二、域名系统DNS"></a>二、域名系统DNS</h2><h3 id="1、介绍一下域名系统"><a href="#1、介绍一下域名系统" class="headerlink" title="1、介绍一下域名系统"></a>1、介绍一下域名系统</h3><ul>
<li><p><strong>DNS 是一个基于C/S的分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。</strong>这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
</li>
<li><p><strong>运行在UDP上，端口号：53</strong></p>
</li>
</ul>
<h3 id="2、域名服务器与层次域名空间"><a href="#2、域名服务器与层次域名空间" class="headerlink" title="2、域名服务器与层次域名空间"></a>2、域名服务器与层次域名空间</h3><ul>
<li>本地服务器不属于域名服务器层次结构</li>
</ul>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710163447364.png" alt="image-20200710163447364" style="zoom:80%;" />



<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20200710164611776.png" alt="image-20200710164611776" style="zoom: 50%;" />



<h3 id="3、DNS域名解析协议，解析过程"><a href="#3、DNS域名解析协议，解析过程" class="headerlink" title="3、DNS域名解析协议，解析过程"></a>3、DNS域名解析协议，解析过程</h3><ul>
<li><strong>域名解析是指把域名映射成为IP 地址或把IP 地址映射成域名的过程。</strong>前者称为正向解析，后者称 为反向解析。当客户端需要域名解析时，通过本机的DNS 客户端构造一个DNS 请求报文，以<strong>UDP</strong> 数据报方式发往本地域名服务器。域名解析有两种方式：<u>递归查询</u> 和 <u>递归与迭代相结合</u> 的查询</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200710163843009.png" alt="image-20200710163843009"></p>
<h2 id="三、文件传输协议FTP"><a href="#三、文件传输协议FTP" class="headerlink" title="三、文件传输协议FTP"></a>三、文件传输协议FTP</h2><h3 id="1、控制连接-与-数据连接"><a href="#1、控制连接-与-数据连接" class="headerlink" title="1、控制连接 与 数据连接"></a>1、控制连接 与 数据连接</h3><ul>
<li><p>控制连接</p>
<ul>
<li>端口号：21；</li>
<li>控制连接用来传输控制信息；<strong>7 位 ASCII码格式</strong></li>
<li>整个会话期间一直保持打开状态</li>
</ul>
</li>
<li><p>数据连接</p>
<ul>
<li>端口号：20；</li>
<li>数据连接用来连接client与server的数据传送进程，数据传送进程实际完成文件的传送，传送完<strong>关闭连接</strong></li>
</ul>
</li>
<li><p>==FTP工作步骤：==</p>
<ul>
<li><p><em>打开端口号为21的控制连接端口（控制连接：persitent），等待客户端能够连接</em></p>
</li>
<li><p>客户端发出请求，通过控制连接发送给服务器端的控制进程，并在整个会话期间一直保持打开，但是控制连接不用来传输文件</p>
</li>
<li><p>服务器在收到客户进程的文件传输请求时，会创建数据传送进程和数据连接，</p>
<p>数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成对数据的传送。</p>
</li>
<li><p>传送完毕后，关闭数据连接（non-persistent）。</p>
</li>
</ul>
</li>
<li><p>为什么设计两条链接？</p>
<p>因为使用两条独立的连接可使得FTP变得更简单，更容易实现，更有效率。同时在文件传输过程中，还可以利用控制连接控制传输过程，比如：客户可以请求中止，暂停传输等。</p>
</li>
</ul>
<h2 id="四、电子邮件"><a href="#四、电子邮件" class="headerlink" title="四、电子邮件"></a>四、电子邮件</h2><h3 id="1、电子邮件的组成结构"><a href="#1、电子邮件的组成结构" class="headerlink" title="1、电子邮件的组成结构"></a>1、电子邮件的组成结构</h3><ul>
<li><strong>邮件代理（user agent），邮件服务器，电子邮件使用的协议</strong></li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200710215957643.png" alt="image-20200710215957643"></p>
<ul>
<li><strong>电子邮件的收发过程：</strong><ol>
<li>发送方调用用户代理上撰写要发送的邮件。邮件代理用SMTP把邮件发送到发送端邮件服务器</li>
<li>发送端邮件服务器将邮件在邮件缓存队列中等待发送</li>
<li>运行在发送方邮件服务器的<strong>SMTP客户进程</strong>，发现邮件缓存里有待发送的邮件，向 运行在接收端邮件服务器的<strong>SMTP服务器进程</strong>发起 <strong>请求建立TCP连接</strong> 的请求。</li>
<li><strong>建立TCP连接后，SMTP客户进程发送邮件给SMTP服务器进程。发送过后，SMTP关闭TCP连接。</strong></li>
<li>SMTP服务器进程 收到邮件后，放入收件人的用户信箱</li>
<li>接受方收取邮件时，调用用户代理，使用POP3（IMAP）将邮件取回。</li>
</ol>
</li>
</ul>
<h3 id="2、SMTP，MIME；邮件读取协议：POP3、IMAP；"><a href="#2、SMTP，MIME；邮件读取协议：POP3、IMAP；" class="headerlink" title="2、SMTP，MIME；邮件读取协议：POP3、IMAP；"></a>2、SMTP，MIME；邮件读取协议：POP3、IMAP；</h3><ul>
<li><strong>SMTP协议：“push协议”</strong></li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200710231807637.png" alt="image-20200710231807637"></p>
<ul>
<li><strong>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型</strong> </li>
</ul>
<img data-src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200710231734814.png" alt="image-20200710231734814" style="zoom:50%;" />



<ul>
<li><strong>POP3：“pull协议”</strong></li>
</ul>
<img data-src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200710231652740.png" alt="image-20200710231652740" style="zoom:50%;" /> 



<ul>
<li><strong>IMAP</strong><ul>
<li>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。<strong>IMAP 服务器维护了会话期间用户的状态信息。</strong></li>
</ul>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200710231626211.png" alt="image-20200710231626211"></p>
<h3 id="3、电子邮件格式"><a href="#3、电子邮件格式" class="headerlink" title="3、电子邮件格式"></a>3、电子邮件格式</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200710230632107.png" alt="image-20200710230632107"></p>
<h2 id="五、万维网"><a href="#五、万维网" class="headerlink" title="五、万维网"></a>五、万维网</h2><h3 id="1、WWW的概念与组成结构"><a href="#1、WWW的概念与组成结构" class="headerlink" title="1、WWW的概念与组成结构"></a>1、WWW的概念与组成结构</h3><ul>
<li>万维网 WWW (World Wide Web) 并非某种特殊的计算机网络。</li>
<li>万维网是一个大规模的、联机式的信息储藏所。是一个资料空间，在这个空间中：一样有用的事物叫做“资源”，并由URL（统一资源定位符）表示；通过HTTP传送给使用者，使用者单击链接来获取资源。</li>
<li>“链接”：万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li>
<li><strong>万维网的内核部分有三个标准构成：URL，HTTP，HTML</strong></li>
</ul>
<h3 id="2、URL"><a href="#2、URL" class="headerlink" title="2、URL"></a>2、URL</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200711073216041.png" alt="image-20200711073216041"></p>
<h3 id="3、HTTP"><a href="#3、HTTP" class="headerlink" title="3、HTTP"></a>3、HTTP</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200711082317004.png" alt="image-20200711082317004"></p>
<h3 id="4、HTTP连接方式"><a href="#4、HTTP连接方式" class="headerlink" title="4、HTTP连接方式"></a>4、HTTP连接方式</h3><p>HTTP既可以使用持久连接，也可以使用非持久连接。</p>
<ul>
<li><strong>非持久连接</strong></li>
</ul>
<img data-src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200730090528749.png" alt="image-20200730090528749"  />



<ul>
<li><strong>持久连接</strong></li>
</ul>
<p><strong>持久连接</strong>：是指万维网服务器在发送响应之后，仍然保留这条连接，是同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求与响应报文。</p>
<p><strong>非流水线方式</strong>：客户在收到前一个响应之后，才能发出下一个请求</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200730090651069.png" alt="image-20200730090651069"></p>
<h3 id="5、简述HTTP中GET和POST的区别"><a href="#5、简述HTTP中GET和POST的区别" class="headerlink" title="5、简述HTTP中GET和POST的区别"></a>5、简述HTTP中GET和POST的区别</h3><blockquote>
<p>？？？</p>
<ul>
<li><p>GET参数通过URL传递，POST放在Request body中。</p>
</li>
<li><p>GET比POST相对来说！更不安全，因为参数直接暴露在URL上</p>
</li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<ul>
<li>GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）</li>
<li>POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="5-1-GET-和-POST-是什么？"><a href="#5-1-GET-和-POST-是什么？" class="headerlink" title="5.1 GET 和 POST 是什么？"></a>5.1 GET 和 POST 是什么？</h4><blockquote>
<p> GET 和 POST 其实都是 HTTP 的请求方法。除了这 2 个请求方法之外，HTTP 还有 <strong>HEAD、PUT、DELETE、TRACE、CONNECT、OPTIONS</strong> 这 6 个请求方法。</p>
</blockquote>
<blockquote>
<p>GET：请求指定的页面信息，并返回实体主体。</p>
<p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p>
</blockquote>
<h4 id="5-2-GET-和-POST-的特点？"><a href="#5-2-GET-和-POST-的特点？" class="headerlink" title="5.2 GET 和 POST 的特点？"></a>5.2 GET 和 POST 的特点？</h4><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul>
<li>GET 用于信息获取，而且应该是安全和幂等的 。</li>
</ul>
<blockquote>
<p><strong>安全性</strong>指的是非修改信息，即该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用，也就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p>
<p><strong>幂等性</strong> (Idempotence) 则指的是无论调用这个URL 多少次，都不会有不同的结果的 HTTP 方法。而在实际过程中，这个规定没有那么严格。例如在一个新闻应用中，新闻站点的头版不断更新，虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。</p>
</blockquote>
<ul>
<li>GET 方法只产生一个 TCP 数据包，浏览器会把请求头和请求数据一并发送出去，服务器响应 200 ok(返回数据)。</li>
</ul>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><ul>
<li>POST请求方式是既不幂等又不安全。</li>
</ul>
<p>首先<u>POST请求方式往数据库中提交数据的，因此会改变数据库中的数据。</u>其次，POST请求方式每次获得的结果都有可能不一样，因为POST请求是作用在上一级的URL上的，则每一次请求都会添加一份新资源（这也是POST和PUT方式的最大区别，PUT方式是幂等的）。</p>
<blockquote>
<p>幂等性的定义：对数据库的一次操作和多次操作获得的结果是一致的，则认为符合幂等性。</p>
<p>安全性的定义：对数据库的操作没有改变数据库中的数据，则认为符合安全性</p>
</blockquote>
<ul>
<li>POST 方法会产生两个 TCP 数据包，浏览器会先将请求头发送给服务器，待服务器响应100 continue，浏览器再发送请求数据，服务器响应200 ok(返回数据)。这么看起来 GET 请求的传输会比 POST 快上一些（因为GET 方法只发送一个 TCP 数据包），但是实际上在网络良好的情况下它们的传输速度基本相同。</li>
</ul>
<h4 id="5-3-GET-和-POST-的区别？"><a href="#5-3-GET-和-POST-的区别？" class="headerlink" title="5.3 GET 和 POST 的区别？"></a>5.3 GET 和 POST 的区别？</h4><p> 本质是一样的，并无区别！！！</p>
<p>GET 和 POST 是什么？它们是 HTTP 请求协议的请求方法，而 HTTP 又是基于TCP/IP的关于数据如何在万维网中如何通信的协议，<strong>所以 GET/POST 实际上都是 TCP 链接</strong>。</p>
<p><strong>既然 GET 和 POST 的底层都是 TCP，那么为什么 HTTP 还要特别将它们区分出来呢？</strong></p>
<p>其实可以想象一下，如果我们直接使用 TCP 进行数据的传输，那么无论是单纯获取资源的请求还是修改服务器资源的请求在外观上看起来都是 TCP 链接，这样就非常不利于进行管理。所以在 HTTP 协议中，就会对这些不同的请求设置不同的类别进行管理，例如单纯获取资源的请求就规定为 GET、修改服务器资源的请求就规定为 POST，并且也对它们的请求报文的格式做出了相应的要求（例如请求参数 GET 位于 URL 而 POST 则位于请求数据中）。</p>
<p>对于 GET 和 POST 的区别，总结来说就是：<strong>它们的本质都是 TCP 链接，并无区别。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同。</strong></p>
<h3 id="6、HTTP与HTTPS区别"><a href="#6、HTTP与HTTPS区别" class="headerlink" title="6、HTTP与HTTPS区别"></a>6、HTTP与HTTPS区别</h3><table>
<thead>
<tr>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td>http是超文本传输协议，信息是明文传输</td>
<td>https则是具有安全性的ssl加密传输协议</td>
</tr>
<tr>
<td>http的连接很简单，是无状态的</td>
<td>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</td>
</tr>
<tr>
<td></td>
<td>https协议需要到ca申请证书</td>
</tr>
<tr>
<td>端口号80</td>
<td>端口号443</td>
</tr>
</tbody></table>
<h1 id="第五章-传输层"><a href="#第五章-传输层" class="headerlink" title="第五章 传输层"></a>第五章 传输层</h1><h2 id="一、传输层的功能？"><a href="#一、传输层的功能？" class="headerlink" title="一、传输层的功能？"></a>一、传输层的功能？</h2><ol>
<li><p>提供<strong>应用进程</strong>间的逻辑通信。（网络层是提供主机间的逻辑通信）</p>
</li>
<li><p>复用和分用。</p>
<ul>
<li>复用：<strong>发送方</strong>不同的应用进程都可使用同一个传输层协议传输数据</li>
<li>分用：<strong>接收方</strong>的传输层<u>在剥去报文段的首部</u>后能够将这些数据正确的交付给目的应用进程</li>
</ul>
</li>
<li><p>对收到的报文的首部和数据部分进行差错检测(网络层只检查IP 数据报首部)；</p>
</li>
<li><p>提供两种不同的协议：TCP &amp; UDP</p>
</li>
</ol>
<h2 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h2><p>UDP是User Datagram Protocol的简称，中文名是用户数据报协议</p>
<ul>
<li><p><strong>UDP应用：</strong>DNS、SNMP（简单网络管理协议）、TFTP（小文件传输协议）、RTP（实时协议）</p>
</li>
<li><p><strong>特点</strong></p>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200731231921197.png" alt="image-20200731231921197"></p>
<ul>
<li><strong>UDP是面向数据报的传输</strong>，发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，既不合并也不拆分，而是保留这些报文的边界。接收方UDP对IP层交上来UDP数据报，在去除首部之后原封不动上交给上层应用进程</li>
</ul>
<h3 id="1、UDP校验和计算"><a href="#1、UDP校验和计算" class="headerlink" title="1、UDP校验和计算"></a>1、UDP校验和计算</h3><ul>
<li><p>UDP的校验和检查首部和数据部分。使用<u>二进制反码</u>运算求和再取反。</p>
</li>
<li><p><strong>伪首部包含IP首部一些字段</strong>。其目的是让UDP两次检查数据是否已经正确到达目的地，只是单纯为了做校验用的。</p>
</li>
<li><p>步骤：</p>
<ul>
<li>发送方首先添加伪首部。然后把UDP数据报视为许多16位的字连接起来。</li>
<li>按二进制反码计算出这些16位字的和，并将此和的二进制反码写入检验位和字段。</li>
<li>接收方把收到的UDP数据报加上伪首部后，把所有16位的字相加，如果遇到进位，则将高于16字节的进位部分的值加到最低位上（wrap around回卷，就是循环加法）。计算这些16位字的和。</li>
<li>将所有字相加得到的结果应该为一个16位的数，将该数取反则可以得到检验和checksum</li>
<li>当无差错时其结果全为1，否则有差错出现，接收方就应该丢弃这个UDP数据报。</li>
</ul>
</li>
<li><p>这种简单的差错检验方法的检测能力不强，但是好处是简单、处理速度快</p>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200731224105668.png" alt="image-20200731224105668"></p>
<h2 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h2><ul>
<li><strong>特点</strong></li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200731231947938.png" alt="image-20200731231947938"></p>
<ul>
<li><strong>TCP是面向字节流的传输</strong>：即TCP传送时是逐个字节传送的，所以TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段发送的数据的第一个字节的序号。</li>
</ul>
<h2 id="四、TCP和UDP的区别"><a href="#四、TCP和UDP的区别" class="headerlink" title="四、TCP和UDP的区别"></a>四、TCP和UDP的区别</h2><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>1）<strong>TCP提供面向连接的传输</strong>，必须先建立连接，管理连接，释放连接；UDP<strong>提供无连接的传输</strong>，无需建立连接，就不会引入建立连接的时延。</p>
<p>2）<strong>TCP提供可靠的传输（有序，无差错，不丢失，不重复）；UDP提供不可靠的传输，尽最大努力交付。</strong></p>
<p>3）<strong>TCP是面向字节流的传输</strong>，因此它能将信息分割成组，并在接收端将其重组；<strong>UDP是面向数据报的传输</strong>，发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，既不合并也不拆分，而是保留这些报文的边界。接收方UDP对IP层交上来UDP数据报，在去除首部之后原封不动上交给上层应用进程</p>
<p>4）<strong>TCP提供拥塞控制和流量控制机制</strong>；<strong>UDP不提供拥塞控制和流量控制机制。</strong></p>
<p>5）<strong>TCP只能是点对点的（一对一）</strong>。<strong>UDP支持一对一、一对多、多对一和多对多的交互通信。</strong></p>
<p>6）<strong>TCP首部20B。UDP首部8B。</strong></p>
<ul>
<li><strong>TCP应用：</strong></li>
<li><strong>UDP应用：</strong>DNS、SNMP（简单网络管理协议）、TFTP（小文件传输协议）、RTP（实时协议）</li>
</ul>
<h3 id="1、TCP连接管理"><a href="#1、TCP连接管理" class="headerlink" title="1、TCP连接管理"></a>1、TCP连接管理</h3><p>TCP是面向连接的协议，因此每隔TCP连接都有三个阶段：连接建立、数据传送和连接释放</p>
<h4 id="1）连接建立：三次握手"><a href="#1）连接建立：三次握手" class="headerlink" title="1）连接建立：三次握手"></a>1）连接建立：三次握手</h4><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200720215725358.png" alt="image-20200720215725358"></p>
<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p>
<p>1、第一步：源主机A的TCP向主机B发出连接请求报文段，其首部中的SYN(同步)标志位应置为1，表示想与目标主机B进行通信，并发送一个同步序列号X(例：SEQ=100)进行同步，表明在后面传送数据时的第一个数据字节的序号是X＋1（即101）。SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。</p>
<p>2、第二步：目标主机B的TCP收到连接请求报文段后，如同意，则发回确认。在确认报中应将ACK位和SYN位置1，表示客户端的请求被接受。确认号应为X＋1(即为101)，同时也为自己选择一个序号Y。</p>
<p>3、第三步：源主机A的TCP收到目标主机B的确认后要向目标主机B给出确认，其ACK置1，确认号为Y＋1，而自己的序号为X＋1。（TCP的标准规定，SYN置1的报文段要消耗掉一个序号。）</p>
<p>​        运行客户进程的源主机A的TCP通知上层应用进程，连接已经建立。当源主机A向目标主机B发送第一个数据报文段时，其序号仍为X＋1，因为前一个确认报文段并不消耗序号。</p>
<p>　　当运行服务进程的目标主机B的TCP收到源主机A的确认后，也通知其上层应用进程，连接已经建立。至此建立了一个全双工的连接。</p>
<blockquote>
<p>ACK：确认位。TCP规定在连接建立后所有传送的报文段都得把ACK置为1。(ACK = 1:有效)</p>
<p>ack：确认号。期望收到下一个报文段的第一个字节的序号。</p>
</blockquote>
<h4 id="2）数据传输"><a href="#2）数据传输" class="headerlink" title="2）数据传输"></a>2）数据传输</h4><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200801095645291.png" alt="image-20200801095645291"></p>
<h4 id="3）连接释放：四次挥手"><a href="#3）连接释放：四次挥手" class="headerlink" title="3）连接释放：四次挥手"></a>3）连接释放：四次挥手</h4><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200801001922740.png" alt="image-20200801001922740"></p>
<p>1、第一步：客户机打算关闭连接时，向其TCP 发送一个连接释放报文段，并停止发送数据，主动关 闭TCP 连接，该报文段的FIN 标志位被置1, seq= u, 它等于前面已传送过的数据的后一个字节的 序号加1 (FIN 报文段即使不携带数据，也要消耗一个序号）。TCP 是全双工的，即可以想象为一 条TCP 连接上有两条数据通路。发送FIN 报文时，发送FIN 的一端不能再发送数据，即关闭了其中 一条数据通路，但对方还可以发送数据。<br>2、第二步：服务器收到连接释放报文段后即发出确认，确认号是ack = u + 1, 而这个报文段自己的序 号是V, 等于它前面已传送过的数据的后一个字节的序号加1 。此时，从客户机到服务器这个方 向的连接就释放了， TCP 连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服 务器到客户机这个方向的连接并未关闭。<br>3、第三步：若服务器已经没有要向客户机发送的数据，就通知TCP 释放连接，此时其发出FIN= 1 的 连接释放报文段。<br>4、第四步：客户机收到连接释放报文段后，必须发出确认。在确认报文段中， ACK 字段被置为1, 确 认号ack= w + 1, 序号seq= u + 1 。此时TCP 连接还未释放，必须经过时间等待计时器设置的时间 2MSL 后， A 才进入连接关闭状态。</p>
<h3 id="2、为什么不采用“两次握手”建立连接？"><a href="#2、为什么不采用“两次握手”建立连接？" class="headerlink" title="2、为什么不采用“两次握手”建立连接？"></a>2、为什么不采用“两次握手”建立连接？</h3><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好，确认彼此的收发能力)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p>
<ul>
<li>关于这个序列号，为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 <u>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</u></li>
<li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li>
</ul>
<h3 id="3、为什么不采用“三次握手“释放连接？"><a href="#3、为什么不采用“三次握手“释放连接？" class="headerlink" title="3、为什么不采用“三次握手“释放连接？"></a>3、为什么不采用“三次握手“释放连接？</h3><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p>
<p>但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<h3 id="4、为什么发送最后一次握手报文后要等待2MSL-最大报文段生存时间-的时间呢？"><a href="#4、为什么发送最后一次握手报文后要等待2MSL-最大报文段生存时间-的时间呢？" class="headerlink" title="4、为什么发送最后一次握手报文后要等待2MSL(最大报文段生存时间)的时间呢？"></a>4、为什么发送最后一次握手报文后要等待2MSL(最大报文段生存时间)的时间呢？</h3><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<h2 id="五、拥塞控制的四种算法"><a href="#五、拥塞控制的四种算法" class="headerlink" title="五、拥塞控制的四种算法"></a>五、拥塞控制的四种算法</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200801095616550.png" alt="image-20200801095616550"></p>
<ol>
<li>慢开始算法</li>
</ol>
<p>刚开始设置拥塞窗口为1，每收到对一个新的报文段的确认，拥塞窗口加1，这样子逐步增大发送方的拥塞窗口从而使得分组注入网络的速率更加合理。（1-》2-》4-》8）</p>
<ol start="2">
<li>拥塞避免算法</li>
</ol>
<p>发送端的拥塞窗口每经过一个往返时延RTT就增加一个最大报文段长度的大小，通常表现为按线性规律增长。（cwnd++）</p>
<blockquote>
<p>在慢开始和拥塞避免算法中使用了“乘法减小”和“加法增大”方法。</p>
<p>“乘法减小”就是不论在慢开始阶段还是拥塞避免阶段，只要发生超时（很可能出现了网络拥塞），就把阈值设为当前拥塞窗口值的一半。</p>
<p>“加法增大”是指执行拥塞避免后，在收到所有报文段的确认后，把拥塞窗口增加1，让拥塞窗口缓慢增加，以过早的防止网络出现拥塞。</p>
</blockquote>
<ol start="3">
<li>快重传算法（3次冗余ACK）</li>
</ol>
<p>首先要求接收方每收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到3个重复确认就应当立即重传对方尚未收到的报文段。</p>
<ol start="4">
<li>快恢复算法</li>
</ol>
<p>当<strong>发送端收到连续的3个重复的ACK</strong>时，就<strong>重新设置慢开始门限值为拥塞窗口的一半</strong>，同时<strong>将拥塞窗口设为新的慢开始门限值</strong>。若发送窗口值还允许发送报文段，<strong>就按拥塞避免算法继续发送报文段</strong>。</p>
<h2 id="六、拥塞控制与流量控制的区别"><a href="#六、拥塞控制与流量控制的区别" class="headerlink" title="六、拥塞控制与流量控制的区别"></a>六、拥塞控制与流量控制的区别</h2><p>拥塞控制的作用是确保子网能够承载所达到的流量，这是一个全局性的过程，设几个方面的行为：主机、路由器以及路由器内部的转发处理过程等。单一地增加资源并不能解决拥塞。</p>
<p>流量控制与拥塞控制的区别：</p>
<ul>
<li>流量控制往往是指在发送端和接收端之间的点对点通信的控制。流量控制所做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li>拥塞控制必须确保子网能够传送待传送的数据，是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。</li>
</ul>
<h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="一、网络层功能？"><a href="#一、网络层功能？" class="headerlink" title="一、网络层功能？"></a>一、网络层功能？</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200805163758191.png" alt="image-20200805163758191"></p>
<ol>
<li><strong>异构网络互联</strong></li>
</ol>
<p>网络互联，是指两个以上的计算机网络，通过一定的方法，用一种或多种通信设备/中间设备相互连接起来，以构成更大的网络系统。</p>
<ol start="2">
<li><p><strong>路由与转发</strong></p>
<ul>
<li>路由：根据路由算法确定一个进来的分组应该被传送到哪一条输出线路上</li>
<li>转发：路由器根据转发表将用户的IP数据报从合适的端口发送出去</li>
</ul>
</li>
<li><p><strong>拥塞控制</strong></p>
<ul>
<li><p>开环控制：设计网络时事先将有关发生拥塞的因素考虑到，力求在网络工作时不产生拥塞。这是静态的预防方法</p>
</li>
<li><p>闭环控制：事先不考虑有关发生拥塞的各种因素，采用监测网络去监视，即时检测哪里发生了拥塞，然后将拥塞信息传到合适的地方，来调整网络系统的运行，并解决出项的问题。闭环控制是基于反馈环路的概念，是一种动态的方法。</p>
</li>
</ul>
</li>
</ol>
<h2 id="二、数据交换方式"><a href="#二、数据交换方式" class="headerlink" title="二、数据交换方式"></a>二、数据交换方式</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200805230405872.png" alt="image-20200805230405872"></p>
<ol>
<li><strong>电路交换（circuit switching）</strong></li>
</ol>
<ul>
<li><p>电路交换：在发送方和接收方之间通过<u>多台交换机</u>建立一条连接(电路circuit)；</p>
</li>
<li><p>建立连接 -&gt; 通信 -&gt; 释放</p>
</li>
<li><p>电路交换网络中，端系统间通信会话期间，预留了端系统间通信沿路径所需要的资源（缓存、链路传输速率）</p>
</li>
</ul>
<ol start="2">
<li><strong>报文交换（meassge switching）</strong></li>
</ol>
<ul>
<li><p><strong>存储转发；</strong></p>
</li>
<li><p>报文交换方式的数据传输单位是报文，报文就是站点一次性要发送的数据块，其长度不限且可变。当一个站要发送报文时，它将一个目的地址附加到报文上，网络节点根据报文上的目的地址信息，把报文发送到下一个节点，一直逐个节点地转送到目的节点。</p>
</li>
<li><p>每个节点在收到整个报文并检查无误后，就暂存这个报文，然后利用路由信息找出下一个节点的地址，再把整个报文传送给下一个节点。因此，端与端之间无需先通过呼叫建立连接。</p>
</li>
</ul>
<ol start="3">
<li><p><strong>分组交换（packet switching）</strong></p>
<p>分组交换是报文交换的一种改进，它将报文分成若干个分组，每个分组的长度有一个上限，有限长度的分组使得每个节点所需的存储能力降低了，分组可以存储到内存中，提高了交换速度。它适用于交互式通信，如终端与主机通信。</p>
</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200805233942970.png" alt="image-20200805233942970"></p>
<h2 id="三、IPv4"><a href="#三、IPv4" class="headerlink" title="三、IPv4"></a>三、IPv4</h2><h3 id="1、IP数据报"><a href="#1、IP数据报" class="headerlink" title="1、IP数据报"></a>1、IP数据报</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200805234515982.png" alt="image-20200805234515982"></p>
<h3 id="2、IPv4地址分类"><a href="#2、IPv4地址分类" class="headerlink" title="2、IPv4地址分类"></a>2、IPv4地址分类</h3><ul>
<li>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200806114557796.png" alt="image-20200806114557796"></p>
<blockquote>
<p><strong>A类地址</strong>：网络号8位，规定第一位是0，可指派的网络数为$2^7-2$，因为其中网络地址全0的地址是个保留地址，意思是“本网络”，网络号01111111用于本地软件环回测试。后面3B（24位）代表主机号，主机号全0代表该网络，全1代表广播地址，最大主机数为$2^{24}-2$。<br><strong>B类地址</strong>：网络号为16位，规定前两位是10（因此网络地址不可能出现全0），网络地址128.0.0.0不指派，所以可指派的网络数为$2^{14}-1$。主机号也为16位，同样，每一个网络上的最大主机数为$2^{16}-2$。<br><strong>C类地址</strong>：网络号为24位，规定前3位为110（因此网络地址不可能出现全0），网络地址192.0.0.0不指派，所以可指派的网络数为$2^{21}-1$。主机号为8位，同样，每一个网络上的最大主机数为$2^{8}-2$。</p>
</blockquote>
<ul>
<li>特殊IP</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201008084615794.png" alt="image-20201008084615794"></p>
<h3 id="3、网络地址转换NAT"><a href="#3、网络地址转换NAT" class="headerlink" title="3、网络地址转换NAT"></a>3、网络地址转换NAT</h3><ul>
<li>用于实现<u>专用网的主机和因特网的主机的通信</u>。</li>
<li>NAT可以将专用网内部使用的本地IP地址转换成有效的外部全球IP地址，使得这个专用网只需要1个全球IP地址就可以与因特网连通。</li>
<li>使用NAT技术，需要在专用网连接到因特网的路由器上安装NAT软件(NAT 路由器)。<br>NAT技术可大大节省IP地址的消耗，它至少有一个有效的外部全球IP地址，但并没有知己IP地址的个数。</li>
</ul>
<h3 id="4、子网划分"><a href="#4、子网划分" class="headerlink" title="4、子网划分"></a>4、子网划分</h3><ul>
<li><p>两级IP地址的缺点：IP地址空间的利用率低；给每一个物理网络分配一个网络号会是路由表变得太大而使网络性能变坏；两级IP地址不够灵活</p>
</li>
<li><p><strong>子网划分：</strong>将两级IP地址变为三级IP地址，从主机号借用若干个比特作为子网号，而主机号也就相应减少了若干比特，网络号不变。注意子网号不能使用全0和全1.</p>
</li>
<li><p><strong>子网掩码：</strong>子网掩码与IP地址一样，是二进制表示也是由0和1组成，连续的1表示网络地址，连续的0表示主机地址，只有网络地址相同的主机在同一个子网，才能直接通信</p>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200806135152272.png" alt="image-20200806135152272"></p>
<ul>
<li>使用IP地址和子网掩码计算网段和广播地址 ：<ul>
<li><strong>IP地址</strong>和<strong>子网掩码</strong>进行<strong>与</strong>运算，结果是<strong>网络地址</strong>（即主机号全0是网络地址）</li>
<li>将运算结果中的网络地址不变，主机地址变为1，结果就是广播地址</li>
</ul>
</li>
</ul>
<blockquote>
<p>默认子网掩码：A：255.0.0.0    B：255.255.0.0   C：255.255.255.0</p>
</blockquote>
<h3 id="5、无类别域间路由（Classless-Inter-Domain-Routing）"><a href="#5、无类别域间路由（Classless-Inter-Domain-Routing）" class="headerlink" title="5、无类别域间路由（Classless Inter-Domain Routing）"></a>5、无类别域间路由（Classless Inter-Domain Routing）</h3><ul>
<li>它消除了传统的A类、B类和C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间。</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200806141424352.png" alt="image-20200806141424352"></p>
<blockquote>
<p>将网络前缀（整个网络号字段）都相同的连续的IP地址组成“CIDR地址块”，一个CIDR地址块可以表示很多地址，这种地址的聚合称为<code>路由聚合</code>，也称<code>构成超网</code>。</p>
</blockquote>
<h3 id="6、各种情况下路由表表项的结构"><a href="#6、各种情况下路由表表项的结构" class="headerlink" title="6、各种情况下路由表表项的结构"></a>6、各种情况下路由表表项的结构</h3><ul>
<li>没划分子网前的路由表：目的网络地址、下一跳地址；</li>
<li>划分子网后的路由表：目的网络地址、子网掩码、下一跳地址；</li>
<li>使用CIDR后的路由表：网络前缀、下一跳地址。</li>
</ul>
<h2 id="四、IP相关协议"><a href="#四、IP相关协议" class="headerlink" title="四、IP相关协议"></a>四、IP相关协议</h2><h3 id="1、地址解析协议ARP（网络层协议）"><a href="#1、地址解析协议ARP（网络层协议）" class="headerlink" title="1、地址解析协议ARP（网络层协议）"></a>1、地址解析协议ARP（网络层协议）</h3><ul>
<li>在每个主机中都有一个ARP高速缓存，里面存放的是所在局域网上的各主机和路由器的IP地址到硬件地址的映射表，ARP的职责就是动态的维护该表。</li>
<li>ARP请求分组是广播发送的，但ARP响应分组是普通的单播。</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200806150729758.png" alt="image-20200806150729758"></p>
<ul>
<li>同一网络</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200806163646772.png" alt="image-20200806163646772"></p>
<ul>
<li>另一网络</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200806163749164.png" alt="image-20200806163749164"></p>
<h3 id="2、动态主机配置协议DHCP（应用层协议）"><a href="#2、动态主机配置协议DHCP（应用层协议）" class="headerlink" title="2、动态主机配置协议DHCP（应用层协议）"></a>2、动态主机配置协议DHCP（应用层协议）</h3><ul>
<li>常用于给主机动态的分配IP地址，提供了即插即用的连网机制，允许一台计算机加入新的网络和获取IP地址而不用手工参与。</li>
<li>DHCP是<strong>应用层协议</strong>，DHCP报文使用<strong>UDP</strong>传输。</li>
<li>DHCP服务器分配给DHCP客户的IP地址是临时的(<code>租用期</code>内可用)。</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200809143816958.png" alt="image-20200809143816958"></p>
<h3 id="3、网际控制报文协议ICMP（网络层协议）"><a href="#3、网际控制报文协议ICMP（网络层协议）" class="headerlink" title="3、网际控制报文协议ICMP（网络层协议）"></a>3、网际控制报文协议ICMP（网络层协议）</h3><ul>
<li>ICMP 差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况。</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200806165438903.png" alt="image-20200806165438903"></p>
<h2 id="五、IPv6"><a href="#五、IPv6" class="headerlink" title="五、IPv6"></a>五、IPv6</h2><ul>
<li><p>解决IP地址耗尽的方法有三种：</p>
<ul>
<li><p>使用CIDR：它消除了传统的A类、B类和C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间。</p>
</li>
<li><p>使用NAT表：用于实现专用网的主机和因特网的主机的通信。</p>
</li>
<li><p>IPv6：采用更大地址空间的新版本的IPv6。</p>
<blockquote>
<p>前两种都是延长地址的分配结束时间，而IPv6才能根本上解决耗尽问题。IPv4中规定IP地址长度为32，即有2^32-1（符号^表示升幂，下同）个地址；而IPv6中IP地址的长度为128，即有$2^{128}-1$个地址。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200809145920071.png" alt="image-20200809145920071"></p>
<ul>
<li>IPv6优势：<ul>
<li>比IPV4有长得多的地址；</li>
<li>简化了IP分组的基本首部，从而改善吞吐率；</li>
<li>更好的支持选项。从前的一些必选的段现在变成了可选的，路由器可以简单的跳过无关选项，加快了分组的处理速度。</li>
</ul>
</li>
</ul>
<h2 id="六、路由选择协议"><a href="#六、路由选择协议" class="headerlink" title="六、路由选择协议"></a>六、路由选择协议</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200809165549634.png" alt="image-20200809165549634"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200809203206766.png" alt="image-20200809203206766"></p>
<h3 id="1、RIP-路由信息协议"><a href="#1、RIP-路由信息协议" class="headerlink" title="1、RIP(路由信息协议)"></a>1、RIP(路由信息协议)</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200809203233581.png" alt="image-20200809203233581"></p>
<p>RIP 是基于分布式的<strong>距离向量路由算法</strong>的路由选择协议，只适用于小型互联网。RIP 按照固定的时间间隔与相邻路由器交换信息，交换的信息是当前路由表。</p>
<ul>
<li><p><strong>距离向量路由算法</strong>：路由器只掌握<strong>物理相连的邻居</strong>以及链路费用。</p>
</li>
<li><p><strong>优点</strong>：实现简单，开销小，收敛速度快。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>限制了网络规模（16不可达）；</li>
<li>由于路由器之间交换的路由信息是路由器中的完整路由表，所以随着网络规模扩大开销也变大；</li>
<li>坏消息传播的慢，此时收敛时间长。</li>
</ul>
</li>
</ul>
<blockquote>
<p>RIP是应用层协议，使用UDP传送数据；RIP选择的路径不一定是时间最短的，但一定是路径最短的。</p>
</blockquote>
<img data-src="D:\TIM\MobileFile\BA3467D2DE4874CAF07D8E9F307F889D.png" alt="BA3467D2DE4874CAF07D8E9F307F889D" style="zoom: 45%;" />



<h3 id="2、OSPF（开放最短路径优先协议）"><a href="#2、OSPF（开放最短路径优先协议）" class="headerlink" title="2、OSPF（开放最短路径优先协议）"></a>2、OSPF（开放最短路径优先协议）</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200809203257563.png" alt="image-20200809203257563"></p>
<p>OSPF 是基于分布式的<strong>链路状态路由算法</strong>的路由选择协议，适用于大型互联网，只在链路状态发生变化时才向本自治系统中的所有路由器用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。</p>
<p>基于链路状态协议，使用<code>洪泛法</code>（一传十，十传百）向本自制系统内的所有路由器发送信息，只有当链路状态改变时才更新。</p>
<ul>
<li><strong>链路状态路由算法</strong>：所有路由器<strong>掌握完整的网络拓扑信息</strong>和链路费用信息。</li>
</ul>
<h3 id="OSPF-与RIP-相比有以下3-点主要区别："><a href="#OSPF-与RIP-相比有以下3-点主要区别：" class="headerlink" title="OSPF 与RIP 相比有以下3 点主要区别："></a>OSPF 与RIP 相比有以下3 点主要区别：</h3><ol>
<li>OSPF 向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法。</li>
</ol>
<p>​    而RIP 仅向自已相邻 的几个路由器发送信息。 </p>
<ol start="2">
<li><p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛 得快，不会出现RIP” 坏消息传得慢＂的问题。而在RIP 中，不管网络拓扑是否发生变化，路由器 之间都会定期交换路由表的信息。</p>
</li>
<li><p>OSPF发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。”      链路状态”说明本路由器和哪些路由器相邻及该链路的“度量”（或代价）。</p>
</li>
</ol>
<p>​    而在RIP 中，发送的信息是本路由器所知道的全部信息，即完整的路由表。（因此网络规模越来越大，开销也越来越大） </p>
<blockquote>
<p>OSPF工作原理：由于各路由器频繁的交换链路状态信息，因此所有路由器最终都能建立一个链路状态数据库。这个数据库实际上就是全网的拓扑信息图，全网范围一直。然后每个路由器根据这个全网拓扑结构图使用Dijkstra算法计算自己到各个网络的最优路径，以此构造自己的路由表。此后当路由状态发生变化时，每个路由器会重新计算到各个目的网络的最优路径，构造新的路由表。（虽然使用Dijkstra算法会计算完整的最优路径，但是路由表不存储完整路径，只存储“下一跳”，只有到了下一跳路由器才能知道下一跳路由器怎么走）</p>
</blockquote>
<h3 id="3、BGP-边界网关协议"><a href="#3、BGP-边界网关协议" class="headerlink" title="3、BGP(边界网关协议)"></a>3、BGP(边界网关协议)</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200809203323533.png" alt="image-20200809203323533"></p>
<p>基于路径-向量协议，自治系统之间路由器交换信息时使用这个。</p>
<ul>
<li>BGP是应用层协议，基于TCP</li>
<li>BGP 是不同自治系统的路由器之间交换路由信息的 协议，是一种外部网关协议。<ul>
<li> 因特网的规模太大，使得自治系统之间路由选择非常困难。</li>
<li> 对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。</li>
<li> 自治系统之间的路由选择必须考虑有关策略。</li>
</ul>
</li>
<li>边界网关协议(BGP) 只能力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并 非寻找一条最佳路由。</li>
</ul>
<blockquote>
<p>BGP 的工作原理如下：每个自治系统的管理员要选择至少一个路由器（可以有多个）作为该自治系统的<u>“BGP 发言人“</u>。一个BGP 发言人与其他自治系统中的BGP发言人要交换路由信息，就要先 建立TCP 连接（可见BGP 报文是通过TCP 传送的，也就是说BGP 报文是TCP 报文的数据部分）， 然后在此连接上交换BGP 报文以建立BGP 会话，再利用BGP 会话交换路由信息。当所有BGP 发 言人都相互交换网络可达性的信息后，各BGP 发言人就可找出到达各个自治系统的较好路由。</p>
</blockquote>
<h2 id="七、IP组播（多播）"><a href="#七、IP组播（多播）" class="headerlink" title="七、IP组播（多播）"></a>七、IP组播（多播）</h2><h3 id="1、IP组播"><a href="#1、IP组播" class="headerlink" title="1、IP组播"></a>1、IP组播</h3><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200810140316189.png" alt="image-20200810140316189"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200810140144536.png" alt="image-20200810140144536"></p>
<p><strong>组播一定是仅应用于UDP。</strong></p>
<ul>
<li><p>把一个分组发送给多台目的主机，采用的方法并不是让源主机给每台目的知己都发送一份分组，而是将分组发给一个组播地址，该组播地址标示一组主机。网络把这个分组复制后传递给该组中的每一台在主机。</p>
</li>
<li><p>与广播不同，主机组播时仅发送一份数据，组播的数据仅在传送路径分叉时才将数据报复制后继续转发。</p>
</li>
<li><p>组播需要路由器的支持(组播路由器)。</p>
</li>
<li><p>组播的特点：</p>
<ol>
<li>组播地址只能用于目的地址，不能用于源地址；</li>
<li>组播数据报“尽最大努力交付”，不提供可靠交付；</li>
<li>对组播数据报不产生差错报文；</li>
<li>并非所有D类地址都可以作为组播地址。</li>
</ol>
</li>
</ul>
<h3 id="2、网际组管理协议-IGMP"><a href="#2、网际组管理协议-IGMP" class="headerlink" title="2、网际组管理协议 IGMP"></a>2、网际组管理协议 IGMP</h3><ul>
<li><p><strong>IP 多播使用 IGMP 协议</strong>，IGMP 并非在互联网范围内对所有多播组成员进行管理，它不知道 IP 多播组包含的成员个数也不知道这些成员都分布在哪些网络上。</p>
</li>
<li><p>IGMP 协议是：<u>让连接在本地局域网上的多播路由器知道本局域网上是否有主机上的某个进程参加或推出了某个多播组。</u></p>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200810142231432.png" alt="image-20200810142231432"></p>
<h2 id="八、移动IP"><a href="#八、移动IP" class="headerlink" title="八、移动IP"></a>八、移动IP</h2><p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200810142459521.png" alt="image-20200810142459521"></p>
<h3 id="1、移动IP"><a href="#1、移动IP" class="headerlink" title="1、移动IP"></a>1、移动IP</h3><p>移动节点（比如一台笔记本电脑）在本地时使用传统的TCP/IP方式进行通信，而当移动节点漫游到外地网络时，仍需要使用固定的IP地址进行通信，为了能收到信息，<code>移动节点</code>需要向<code>本地代理</code>注册当前的位置地址(也就是<code>转交地址</code>)，本地代理收到后会建立一条<code>隧道</code>，将截获的发送给移动节点的IP分组送到转交地址处，在转交地址处解除隧道封装，最后送到移动节点。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IMG_2201(20200810-143354).PNG" alt="IMG_2201(20200810-143354)"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200810135349266.png" alt="image-20200810135349266"></p>
<h3 id="2、移动IP与动态IP的区别"><a href="#2、移动IP与动态IP的区别" class="headerlink" title="2、移动IP与动态IP的区别"></a>2、移动IP与动态IP的区别</h3><p><strong>移动IP</strong>为移动主机设置了两个IP地址，即主地址和辅地址(转交地址)。移动节点在本地网时使用主地址，在外网需要获得一个辅助的临时地址，但是此时主地址不变，当从外网回来时，辅地址就会被改变或撤销，而主地址依然不变。</p>
<p><strong>动态IP</strong>是指局域网中的计算机可以通过网络中的DHCP服务器动态的获得一个IP地址，所以不需要用户在计算机网络设置中指定IP地址。</p>
<h2 id="九、路由器的主要功能？"><a href="#九、路由器的主要功能？" class="headerlink" title="九、路由器的主要功能？"></a>九、路由器的主要功能？</h2><img data-src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200809203500531.png" alt="image-20200809203500531" style="zoom: 67%;" />



<p><strong>路由器</strong>实质上是一种多个输入端口和多个输出端口的专用计算机，其任务是连接不同的网络转发分组。也就是说，将路由器某个输入端口收到的分组，按照分组要取的目的地（目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。</p>
<ul>
<li>路由器的结构：<ol>
<li>路由选择：根据所选定的<u>路由选择协议</u>构造出路由表，同时经常或定期的和相邻路由器交换路由信息而不断更新和维护路由表，其核心部件是路由选择处理器；</li>
<li>分组转发：包括一组输入端口、交换结构和一组输出端口，交换结构(路由器的核心部件)从输入端口接收到分组后，根据转发表对分组进行处理，然后从一个合适的输出端口转发出去。</li>
</ol>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/A7CAF9BE3412A567CE201ACA40D6A242.png" alt="A7CAF9BE3412A567CE201ACA40D6A242"></p>
<ul>
<li>若接收到的分组是路由器之间交换路由信息的分组，比如RIP和OSPF分组，则把这种分组送交路由器的路由选择部分的选择处理器；</li>
<li>若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，经过交换结构到达合适的输出端口。</li>
<li>当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组，这个分组就要排队，因而产生了<strong>时延</strong>。</li>
</ul>
<h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章  数据链路层"></a>第三章  数据链路层</h1><h2 id="一、数据链路层的功能"><a href="#一、数据链路层的功能" class="headerlink" title="一、数据链路层的功能"></a>一、数据链路层的功能</h2><p>数据链路层 在物理层所提供的服务的基础上 <u>向网络层提供服务</u>，即将原始的、有差错的物理线路改进成<u>逻辑上无差错的数据链路</u>，从而向网络层提供高质量的服务。</p>
<ol>
<li><p><strong>向网络层提供服务</strong>：包括3种：<u>无确认的无连接服务、有确认的无连接服务和有确认的有连接服务（没有无确认的有连接服务）</u></p>
</li>
<li><p><strong>链路管理</strong>：负责数据链路的建立、维持和释放，主要用于面向连接的服务；</p>
</li>
<li><p><strong>帧同步</strong>：接收方确定收到的比特流中以帧的开始位置和结束位置；</p>
</li>
<li><p><strong>差错控制</strong>：用于使接收方确定接收到的数据就是发送方发送的数据；</p>
</li>
<li><p><strong>透明传输</strong>：解决与控制符形同的数据如何发送，就是不管数据是什么样的比特组合，都应当能在链路上发送；</p>
</li>
</ol>
<h2 id="二、组帧（在网络中以帧为最小传输单位，MTU，最大传输单元）"><a href="#二、组帧（在网络中以帧为最小传输单位，MTU，最大传输单元）" class="headerlink" title="二、组帧（在网络中以帧为最小传输单位，MTU，最大传输单元）"></a>二、组帧（在网络中以帧为最小传输单位，MTU，最大传输单元）</h2><h3 id="1、为什么要组帧？"><a href="#1、为什么要组帧？" class="headerlink" title="1、为什么要组帧？"></a>1、为什么要组帧？</h3><p>如果传输比特流出错，只需要重传出错的帧即可，无需重传全部比特流，从而提高效率，值！</p>
<h3 id="2、组帧的4种方法"><a href="#2、组帧的4种方法" class="headerlink" title="2、组帧的4种方法"></a>2、组帧的4种方法</h3><ol>
<li><p><strong>字符计数法</strong>：用一个<code>特殊的字符</code>表示一帧的开始，然后用一个<u>计数字段</u>来表明该帧包含的字节数。当目的主机接收到该帧时，根据此字段提供的字节数，便可知道该帧的结束位和下 一帧的开始位。</p>
<blockquote>
<p>存在问题：若计算字段出错，就无法实现帧同步，因此该方法很少被使用。</p>
</blockquote>
</li>
<li><p><strong>字节填充（的首尾界符）法</strong>：字符填充发使用一些特定的字符来定界一帧的开始和结束。在数据中可能出现的 特殊字符 前面加上转义字符<code>ESC</code>。接收方收到转义字符后就知道，其后面紧跟的是数据信息，二不是控制信息。</p>
</li>
<li><p><strong>比特填充的首尾标识法（零比特填充法）</strong>：使用<code>01111110</code>作为帧的开始和结束标志。若数据部分也出现<code>01111110</code>，可以这样子：（只要遇到5个“1”，立刻就在后面填1个“0”）<br>只要数据帧检测到有5个连续的1，就立刻那个在后面插入0，而接收方没收到连续的5个1，就自动删除后面紧跟的0，以恢复原始数据。</p>
</li>
<li><p><strong>物理编码违例法</strong>：利用物理介质上编码的违法标志来区分帧的开始和结束。</p>
</li>
</ol>
<blockquote>
<p>目前比较常用的是：比特填充法和违规编码法</p>
</blockquote>
<h2 id="三、差错控制"><a href="#三、差错控制" class="headerlink" title="三、差错控制"></a>三、差错控制</h2><h3 id="1、检错编码"><a href="#1、检错编码" class="headerlink" title="1、检错编码"></a>1、检错编码</h3><ol>
<li><p><strong>奇偶校验码</strong>：在信息码后面添加一位校验码，分为<code>奇校验</code>和<code>偶校验</code>：<br>缺点：若同时有两位数据发送改变，则无法检出错误。检错率低</p>
</li>
<li><p><strong>循环冗余码(CRC)</strong><br>优势：检错率极高、开销小、易实现。</p>
</li>
</ol>
<h3 id="2、纠错编码（不但能检错，还能纠错）"><a href="#2、纠错编码（不但能检错，还能纠错）" class="headerlink" title="2、纠错编码（不但能检错，还能纠错）"></a>2、纠错编码（不但能检错，还能纠错）</h3><p><strong>海明码</strong>。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200812011414338.png" alt="image-20200812011414338"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200812011440896.png" alt="image-20200812011440896"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200812011130160.png" alt="image-20200812011130160"></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200812012155028.png" alt="image-20200812012155028"></p>
<h2 id="四、流量控制和可靠传输机制（in-传输层）"><a href="#四、流量控制和可靠传输机制（in-传输层）" class="headerlink" title="四、流量控制和可靠传输机制（in 传输层）"></a>四、流量控制和可靠传输机制（in 传输层）</h2><blockquote>
<p>数据链路层的流量控制与传输层的区别？</p>
<ol>
<li><p>数据链路层的流量控制是点对点的（两个相邻结点之间的），而传输层的流量控制是端到端的（两个主机之间的）。</p>
</li>
<li><p>数据链路层的流量控制手段是：接收方收不下就不回复确认。</p>
<p>传输层的流量控制手段是：接受端给发送端一个窗口公告（告诉他接收端目前的信息，让它慢点发类似的）</p>
</li>
</ol>
</blockquote>
<h3 id="1、流量控制"><a href="#1、流量控制" class="headerlink" title="1、流量控制"></a>1、流量控制</h3><p><strong>含义</strong>：控制发送方发送数据的速率，使接收方来得及接收。<br><strong>基本方法</strong>：由接收方控制发送方的数据流，常见两种方法：</p>
<h3 id="2、可靠传输机制"><a href="#2、可靠传输机制" class="headerlink" title="2、可靠传输机制"></a>2、可靠传输机制</h3><p>与无差错接收（比如在数据链路层使用循环冗余码检验差错检测技术，凡是接收端接收的帧均无差错，有差错的被丢弃了呗）不同，</p>
<p>可靠传输是指<strong>数据链路层发送什么，接收端就接收什么</strong>。传输差错包括<code>无比特差错（可用CRC检测）</code>和<code>无传输差错（更复杂，可能帧没问题，但出现了帧失序或者帧重复）</code>。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200812141447173.png" alt="image-20200812141447173"></p>
<h3 id="3、停止-等待协议（基于停止-等待流量控制技术）"><a href="#3、停止-等待协议（基于停止-等待流量控制技术）" class="headerlink" title="3、停止-等待协议（基于停止-等待流量控制技术）"></a>3、停止-等待协议（基于停止-等待流量控制技术）</h3><ul>
<li><p><strong>原理</strong>：发送方传输一个帧后，就停止发送，必须等待对方的确认才能发送下一帧。若在规定的时间内（超时计时器：比平均RTT长一些，因为发送方和接收方都有发送时延）没有收到确认，则发送超时，并重传原始帧。</p>
<ol>
<li>数据帧丢失</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813085752930.png" alt="image-20200813085752930"></p>
<ol start="2">
<li>ACK丢失</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813085904219.png" alt="image-20200813085904219"></p>
<ol start="3">
<li>ACK迟到</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813091030252.png" alt="image-20200813091030252"></p>
<ul>
<li><strong>信道利用率：</strong>（也叫信道效率）针对发送方而言，是指发送方在一个发送周期的时间内，有效地发送数据所需要的时间占整个发送周期的比率。</li>
<li><strong>信道利用率 = $\frac{数据帧的发送时间}{数据帧的发送时间 + RTT + 确认帧的发送时间}$</strong></li>
<li>*<em>信道利用率 = 信道利用率 * 发送方的发送速率*</em></li>
<li><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813091322288.png" alt="image-20200813091322288"></li>
</ul>
</li>
</ul>
<h3 id="4、滑动窗口机制"><a href="#4、滑动窗口机制" class="headerlink" title="4、滑动窗口机制"></a>4、滑动窗口机制</h3><ul>
<li>只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。</li>
<li>当接收窗口大小为1时，可保证帧按序接收。</li>
</ul>
<h4 id="4-1-后退N帧（GBN）协议（基于滑动窗口流量控制技术）"><a href="#4-1-后退N帧（GBN）协议（基于滑动窗口流量控制技术）" class="headerlink" title="4.1 后退N帧（GBN）协议（基于滑动窗口流量控制技术）"></a>4.1 后退N帧（GBN）协议（基于滑动窗口流量控制技术）</h4><ul>
<li><strong>累计确认！冗余丢弃！</strong></li>
</ul>
<p><strong>原理</strong>：发送方发送完一个数据帧后，不是停下来等待确认帧，而是可以连续再发送若干个数据帧。如果这时收到了接收方的确认帧，那么还可以接着再发送数据帧。如果某个帧出错了，接收方只能简单地丢弃该帧机器所有的后续帧。发送方超时后需重发该出错帧及其后续所有帧。<br><strong>评价</strong>：减少了等待时间，使得整个通信的吞吐量得到提高。但接收方已发行错误帧，就不再接收后续帧，造成了一定浪费。于是有了下面的<code>选择重传协议</code></p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3105B543D1CC214C93F7748FC014C53C.png" alt="3105B543D1CC214C93F7748FC014C53C"></p>
<blockquote>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/E356708BCD2A0D73AF00627F543D0926.png" alt="E356708BCD2A0D73AF00627F543D0926"></p>
<p><strong>答：</strong>GBN采用累计确认，即接收方对按需到达的最后一个分组发送确认。所以收到3的确认帧就表示0，1，2，3的帧已接受，而此时发送方未收到1的确认只能代表确认帧在返回时的过程中丢失，而不代表1号帧未到达接受方。因此需要重传的是4，5，6，7。</p>
</blockquote>
<h4 id="4-2-选择重传（SR）协议（基于滑动窗口流量控制技术）"><a href="#4-2-选择重传（SR）协议（基于滑动窗口流量控制技术）" class="headerlink" title="4.2 选择重传（SR）协议（基于滑动窗口流量控制技术）"></a>4.2 选择重传（SR）协议（基于滑动窗口流量控制技术）</h4><ul>
<li><strong>单一确认！冗余缓存（buffered）</strong></li>
</ul>
<p><strong>原理</strong>：若一帧出错，则其后续帧先存入接收方的缓冲区帧，同时要求发送方重传出错帧，一旦收到重传帧后，就和原先存在缓冲区的其余帧一起按正确的顺序送至主机。<br><strong>评价</strong>：避免了重复传输那些本来已经正确到达接收方的数据帧，进一步提高了信道利用率，但代价是增加了缓冲空间。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/43FE3D2E021E046C7040229B37E7EEAD.png" alt="43FE3D2E021E046C7040229B37E7EEAD"></p>
<h4 id="后退N帧（GBN）协议-vs-选择重传（SR）协议"><a href="#后退N帧（GBN）协议-vs-选择重传（SR）协议" class="headerlink" title="后退N帧（GBN）协议 vs 选择重传（SR）协议"></a>后退N帧（GBN）协议 vs 选择重传（SR）协议</h4><table>
<thead>
<tr>
<th align="center">Go-Back-N</th>
<th align="center">Selective Repeat</th>
</tr>
</thead>
<tbody><tr>
<td align="center">累积ACK</td>
<td align="center">单一ACK</td>
</tr>
<tr>
<td align="center">单一timer</td>
<td align="center">多个timer</td>
</tr>
<tr>
<td align="center">乱序分组丢弃；并生成冗余ACK</td>
<td align="center">乱序分组缓存；并生成单个ACK</td>
</tr>
<tr>
<td align="center">超时重传：丢失及以后的</td>
<td align="center">超时重传：只重传音器超时的那个</td>
</tr>
</tbody></table>
<h3 id="5、介质访问控制（Media-Access-Control，MAC）"><a href="#5、介质访问控制（Media-Access-Control，MAC）" class="headerlink" title="5、介质访问控制（Media Access Control，MAC）"></a>5、介质访问控制（Media Access Control，MAC）</h3><p>介质访问控制：为使用介质的每个结点隔离来自同一信道上其他节点所传送的信号，以协调活动结点的传输。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813133118906.png" alt="image-20200813133118906"></p>
<ol>
<li>信道划分介质访问控制；</li>
<li>随机访问介质访问控制；</li>
<li>轮询访问介质访问控制。</li>
</ol>
<h4 id="5-1-信道划分介质访问控制-静态划分信道"><a href="#5-1-信道划分介质访问控制-静态划分信道" class="headerlink" title="5.1 信道划分介质访问控制(静态划分信道)"></a>5.1 信道划分介质访问控制(静态划分信道)</h4><ol>
<li><p>频分多路复用：<br>将一条信道分割成多个不同频率的信道(类似将马路分割为多个车道)。<br>若复用数之间，则需增加信道的(频率)带宽。</p>
</li>
<li><p>时分多路复用：<br>将一个固定时间分割成多个时间段。<br>但是有可能某个时间段内，要使用的那个人不用了，此时会出现空等状态，太浪费</p>
</li>
<li><p>统计时分多路复用：</p>
<p>于是出现了改进版的，也就是<code>统计时分复用</code>，这是一种动态的时间分配，又称<code>异步时分复用</code>，可以避免浪费（只要没人用就自己用）。</p>
</li>
<li><p>波分多路复用：<br>光的频分多路复用。</p>
</li>
<li><p>码分多路复用：<br>又称<code>码分多址（CDMA）</code>，既共享信道的频率，又共享时间，是一种真正的动态复用技术，抗干扰能力强、保密性强、语音质量好。</p>
</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813134158489.png" alt="image-20200813134158489"></p>
<h4 id="5-2-随机访问介质访问控制（动态划分信道–-gt-随机接入）"><a href="#5-2-随机访问介质访问控制（动态划分信道–-gt-随机接入）" class="headerlink" title="5.2 随机访问介质访问控制（动态划分信道–&gt;随机接入）"></a>5.2 随机访问介质访问控制（动态划分信道–&gt;随机接入）</h4><ul>
<li><code>动态划分信道</code>包括<code>随机接入</code>和<code>受控接入</code></li>
<li><code>随机访问介质访问控制</code>又称<code>争用型协议</code>，因为其核心思想是通过争用，胜利者才可以获得信道，主要有4种协议：</li>
</ul>
<ol>
<li><strong>ALOHA协议</strong>：<br>当网络中的任何一个结点发送数据时，可以不进行任何检测就发送数据。如果在一段时间内没有收到确认，该结点就认为传输过程中发生了冲突。发生冲突的结点需要等待一个随机的数据后再次发生数据。直到发送成功。<br>缺点：信道利用率不理想<br>改进：<u>时分ALOHA</u>：所有结点的时间被划分为间隔相同的时隙，并规定每个节点只有当下一个时隙到来时才可以发送数据。</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813140243367.png"></p>
<ol start="2">
<li><strong>载波侦听多路访问(CSMA)协议</strong>：<br>每个节点在发送数据之前，使用载波侦听技术来判定通信信道是否空闲，常用<strong>3种策略</strong>：</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813143626671.png" alt="image-20200813143626671"></p>
<p>      </p>
<ol start="3">
<li><strong>带冲突检测的载波侦听多路访问（CSMA/CD）协议（collision detection）</strong>：<br><strong>策略</strong>：<strong>先听后发，边听边发，冲突停发，随机重发。</strong><br><strong>争用期</strong>：<u>以太网</u>端到端的往返时延，又称<code>冲突窗口</code>或者<code>碰撞窗口</code>。只有经过争用期这段时间还没有检测到冲突，才能肯定这次发送不会发生冲突。</li>
</ol>
<ol start="4">
<li><strong>CSMA/CA协议（collision avoidance）</strong>：<br>在CSMA基础上增加了<u>冲突避免</u>功能。主要用在<u>无线局域网</u>中。<br>冲突避免要求每个结点在发送数据之前监听信道，若信道空闲，则发送数据。发送完一个帧后，必须等待一段时间，检查接收方是否发回了帧确认，若收到则继续发送，否则表明出现冲突，重发该帧。</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813135052730.png" alt="image-20200813135052730"></p>
<h4 id="5-3-轮询访问介质访问控制（动态划分信道–-gt-受控接入）"><a href="#5-3-轮询访问介质访问控制（动态划分信道–-gt-受控接入）" class="headerlink" title="5.3 轮询访问介质访问控制（动态划分信道–&gt;受控接入）"></a>5.3 轮询访问介质访问控制（动态划分信道–&gt;受控接入）</h4><p>用户不能随意地发送信息，而是通过一个集中控制的监控站经过轮询过程后再决定信道的分配。典型的轮询访问介质访问控制协议就是<code>令牌传递协议</code>。</p>
<h3 id="6、局域网"><a href="#6、局域网" class="headerlink" title="6、局域网"></a>6、局域网</h3><h4 id="6-1-局域网的定义"><a href="#6-1-局域网的定义" class="headerlink" title="6.1 局域网的定义"></a>6.1 局域网的定义</h4><p>局域网是指一个较小范围内的多台计算机或者其他通信设备，通过双绞线、同轴电缆等连接介质互连起来，以达到资源和信息共享目的的互联网络。</p>
<h4 id="6-2-局域网的主要特点"><a href="#6-2-局域网的主要特点" class="headerlink" title="6.2 局域网的主要特点"></a>6.2 局域网的主要特点</h4><ol>
<li>局域网为一个单位所拥有；</li>
<li>地理范围和站点数目有限；</li>
<li>与以前的非光纤的广域网相比，局域网具有较高的数据率、较低的时延和较小的误码率。</li>
</ol>
<h4 id="6-3-局域网的主要优点"><a href="#6-3-局域网的主要优点" class="headerlink" title="6.3 局域网的主要优点"></a>6.3 局域网的主要优点</h4><ol>
<li>具有广播功能，从一个站点可很方便访问全网；</li>
<li>具有便于系统的扩展和演变，各设备的位置可灵活的调整和改变；</li>
<li>提高了系统的可靠性、可用性；</li>
<li>各站为平等关系而不是主从关系。</li>
</ol>
<h4 id="6-4-局域网的主要技术要素"><a href="#6-4-局域网的主要技术要素" class="headerlink" title="6.4 局域网的主要技术要素"></a>6.4 局域网的主要技术要素</h4><ol>
<li><strong>网络拓扑结构</strong>：星形网、环形网、总线型网和树形网。</li>
<li><strong>传输介质</strong>：双绞线（主流）、铜缆、光纤。</li>
<li><strong>介质访问控制方法</strong>：CSMA/CD、令牌总线和令牌环。</li>
</ol>
<h4 id="6-5-一个局域网的典型代表—-以太网"><a href="#6-5-一个局域网的典型代表—-以太网" class="headerlink" title="6.5 一个局域网的典型代表—-以太网"></a>6.5 一个局域网的典型代表—-以太网</h4><ul>
<li><strong>工作原理</strong>：以太网采用<code>IEEE802.3</code>标准，采用<strong>总线拓扑结构</strong>，信息以<strong>广播</strong>形式发送，使用<strong>CSMA/CD</strong>技术对总线进行访问控制，提供的是<strong>不可靠的服务</strong>（无连接，不对发送的数据帧编号，也不要求接收方发回确认）。</li>
<li><strong>以太网的MAC帧</strong>：包括<code>前导码</code>和<code>目的地址、源地址</code>和<code>类型</code>和<code>数据</code>和<code>填充</code>和<code>校验码</code>。</li>
<li><strong>以太网的传输介质</strong>：10Base5（粗缆）、10Base2（细缆）、10Base-T（双绞线）、10Base-F（光纤）。</li>
</ul>
<h4 id="6-5-令牌环网的工作原理"><a href="#6-5-令牌环网的工作原理" class="headerlink" title="6.5 令牌环网的工作原理"></a>6.5 令牌环网的工作原理</h4><blockquote>
<p>(1）当网络空闲时，环路中只有令牌在网络中循环传递；<br>(2) 令牌传递到有数据要发送的结点处，该节点就修改令牌的一个标志位，然后在令牌中附加自己需要的数据，这样就将令牌改换成了一个数据帧，源结点将这个数据帧发送出去；<br>(3)数据帧沿着环路传递，接收到的结点一边转发数据，一边查看帧的目的地址，若是自己的就收下；<br>(4）当数据帧到达了源节点，源节点收到了自己发出去的数据帧，便不再转发了。同时，源节点要通过校验返回的数据帧进行检错，若出错，则重发；<br>(5源节点传送完数据后，重新产生一个令牌，并将其传递给下一个站点，以交出发送数据帧的权限。</p>
</blockquote>
<h3 id="7、广域网"><a href="#7、广域网" class="headerlink" title="7、广域网"></a>7、广域网</h3><h4 id="7-1-广域网定义"><a href="#7-1-广域网定义" class="headerlink" title="7.1 广域网定义"></a>7.1 广域网定义</h4><p>覆盖范围很广的长距离网络。</p>
<h4 id="7-2-PPP（面向字节，无连接）"><a href="#7-2-PPP（面向字节，无连接）" class="headerlink" title="7.2 PPP（面向字节，无连接）"></a>7.2 PPP（面向字节，无连接）</h4><p>PPP（point-to-point protocal）是使用串行线路通信的面向字节的协议，该协议应用在直接连接两个节点的链路上。设计的主要目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一 种共通的解决方案。</p>
<blockquote>
<p>点到点协议（Point to Point Protocol，PPP）是为在同等单元之间传输数据包这样的简单链路设 计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。</p>
</blockquote>
<p>PPP具有以下功能： </p>
<ul>
<li>PPP具有错误检测能力，但不具备纠错能力，只保证无差错接受（通过硬件进行CRC检验）</li>
<li>ppp是不可靠传输协议，不使用序号和确认机制</li>
<li>支支持全双工链路，只支持点对点的链路通信</li>
<li>PPP支持多种网络协议，比如TCP/IP、NetBEUI、NWLINK等； </li>
<li>面向字节的协议</li>
</ul>
<h4 id="7-3-HDLC协议（面向比特）"><a href="#7-3-HDLC协议（面向比特）" class="headerlink" title="7.3 HDLC协议（面向比特）"></a>7.3 HDLC协议（面向比特）</h4><p>HDLC协议可适用于两种配置：</p>
<p>非平衡配置（由一个主站控制整个链路的工作）和平衡配置（链路两端的两个站都是复合站，每个复合站都可以平等地发起数据传输，而不需要得到对方复合站的允许）。</p>
<p>主要有四个特点： </p>
<ol>
<li>对于任何一种比特流都可透明传输。 </li>
<li>全双工通信，较高的数据链路传输效率。 </li>
<li>所有的帧都有帧校验序列（FCS），传输可靠性高。 </li>
<li>用统一的帧格式来实现传输。</li>
</ol>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813181910941.png" alt="image-20200813181910941"></p>
<h3 id="8、数据链路层的设备：网桥-amp-交换机-回来看-然后做126页题"><a href="#8、数据链路层的设备：网桥-amp-交换机-回来看-然后做126页题" class="headerlink" title="==8、数据链路层的设备：网桥 &amp; 交换机 回来看 然后做126页题=="></a>==8、数据链路层的设备：网桥 &amp; 交换机 回来看 然后做126页题==</h3><h4 id="8-1-网桥"><a href="#8-1-网桥" class="headerlink" title="8.1 网桥"></a>8.1 网桥</h4><p>具有<strong>过滤帧</strong>的功能。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>过滤通信量；</li>
<li>扩大了物理范围；</li>
<li>提高了可靠性；</li>
<li>可互连不同物理层、不同MAC子层和不同速率的以太网。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>存储转发增加了时延；</li>
<li>在MAC子层并没有流量控制功能；</li>
<li>具有不同MAC子层的网段桥接在一起时时延更大；</li>
<li>网桥只适合于用户数不太多和通信量不太大的局域网，否则产生广播风暴（传播过多的广播信息而产生网络拥塞）。</li>
</ol>
<p><strong>分类</strong>：透明网桥（选择的不是最佳路由）、源路由网桥（是最佳路由）。</p>
<h4 id="8-2-局域网交换机"><a href="#8-2-局域网交换机" class="headerlink" title="8.2 局域网交换机"></a>8.2 局域网交换机</h4><p><strong>实质</strong>：<strong>多端口网桥。</strong><br><strong>优点</strong>：不仅每个端口节点所占用的带宽不会因为端口节点数量的最佳而减少，而且整个交换机的带宽会随着带宽节点的增加而增加。<br><strong>两种交换模式</strong>：</p>
<ol>
<li>直通式交换：只检查帧的目的地址，帧在被接收后立即发出。速度快，不安全，不支持具有不同速率的端口的交换；</li>
<li>存储转发式交换：先将接收到的帧存储在高速缓存中，检错，若不错则查找转发表，将该帧从查询到的端口转发出去；若出错则丢弃。可靠性高，支持不同速率端口间的转换，但延迟较大。</li>
</ol>
<p><strong>工作原理</strong>：<br>和网桥类似，检测从某端口进入交换机的帧的源MAC地址和目的MAC地址，然后与系统内部的动态查找表进行比较，若数据报的MAC地址不在查找表中，则将该地址加入查找表中，并将数据报发送给相应的目的端口。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200813185405548.png" alt="image-20200813185405548"></p>
<h1 id="集线器、交换机、网桥区别"><a href="#集线器、交换机、网桥区别" class="headerlink" title="==集线器、交换机、网桥区别=="></a>==集线器、交换机、网桥区别==</h1><h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="1、物理层的功能？"><a href="#1、物理层的功能？" class="headerlink" title="1、物理层的功能？"></a>1、物理层的功能？</h2><p>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用 是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
<h2 id="2、信号、信源、信道、信宿"><a href="#2、信号、信源、信道、信宿" class="headerlink" title="2、信号、信源、信道、信宿"></a>2、信号、信源、信道、信宿</h2><ul>
<li><p><strong>信号</strong>是数据（<code>传送信息的实体</code>）的电气或电磁的表现。<br><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200814164850309.png" alt="image-20200814164850309"><br>一句话：基带对应数字信号，宽带对应模拟信号。<br>注意：宽带传输==频带传输(in 考研）。</p>
</li>
<li><p><strong>信源</strong>：通信过程中<u>产生和发送</u>信息的设备或计算机。</p>
</li>
<li><p><strong>信道</strong>：信息传送的道路，也就是信号的传输媒质，分为有线信道和无线信道。</p>
<img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/复习计算机基础知识/复习-计算机网络/image-20201028130741608.png" alt="image-20201028130741608" style="zoom:50%;" />
</li>
<li><p><strong>信宿</strong>：通信过程中<u>接收和处理</u>信息的设备或计算机。</p>
</li>
</ul>
<h2 id="3、速率、波特、码元、带宽"><a href="#3、速率、波特、码元、带宽" class="headerlink" title="3、速率、波特、码元、带宽"></a>3、速率、波特、码元、带宽</h2><ul>
<li><strong>速率</strong>：就是单位时间内传输的数据量，可用波特率和比特率来描述。<br><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200814181139948.png" alt="image-20200814181139948"></li>
</ul>
<ul>
<li><p><strong>码元</strong>：数字通信中数字信号的计量单位。用一个固定市场的信号波形表示一位k进制数，这个时长内的信号成为k进制码元。</p>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200814181933593.png" alt="image-20200814181933593"></p>
</li>
</ul>
<ul>
<li><strong>带宽</strong>：带宽是用来表示<code>网络的通信线路</code>所能<code>传送数据的能力</code>，表示<u>单位时间内从网络中的某一点到另一点所能通过的<code>最高数据率</code>。</u><br>此时，带宽的单位不再是赫兹(Hz)，而是<code>bit/s</code>。</li>
</ul>
<h2 id="4、通信方式："><a href="#4、通信方式：" class="headerlink" title="4、通信方式："></a>4、通信方式：</h2><h3 id="4-1-单工-amp-半双工-amp-全双工"><a href="#4-1-单工-amp-半双工-amp-全双工" class="headerlink" title="4.1 单工&amp;半双工&amp;全双工"></a>4.1 单工&amp;半双工&amp;全双工</h3><p>从通信双方信息的交互来看：</p>
<ol>
<li><strong>单工通信</strong>：只有一个方向的通信而没有反方向的交互；需要一条信道（广播）</li>
<li><strong>半双工通信</strong>：通信双方都可以收发信息，但不能同时；需要两条信道（对讲机）</li>
<li><strong>全双工通信</strong>：通信双方可以同时收发信息；需要两条信道（打电话）</li>
</ol>
<h3 id="4-2-串行传输-amp-并行传输"><a href="#4-2-串行传输-amp-并行传输" class="headerlink" title="4.2 串行传输&amp;并行传输"></a>4.2 串行传输&amp;并行传输</h3><ol>
<li><strong>串行传输</strong>：将表示1个字符的8位二进制数按由低位到高位的顺序依次发送。<ul>
<li>速度慢，费用低，适合远距离</li>
</ul>
</li>
<li><strong>并行传输</strong>：将表示1个字符的8位二进制数同时通过8条信道发送。<ul>
<li>速度快，费用高，适合近距离</li>
</ul>
</li>
</ol>
<h3 id="4-3-同步传输-amp-异步传输"><a href="#4-3-同步传输-amp-异步传输" class="headerlink" title="4.3 同步传输&amp;异步传输"></a>4.3 同步传输&amp;异步传输</h3><ul>
<li><p><strong>同步通信</strong></p>
<p>同步通信的通信双方必须先建立同步， 即<strong>双方的时钟要调整到同一个频率</strong>。收发双方<u>不停地</u> 发送和接收连续的同步比特流，是一个区块。主要有两种同步方式： 一种是全网同步， 即用一个非常精确的主 时钟对全网所有结点上的时钟进行同步；另一种是准同步， 即各结点的时钟之间允许有微小的误 差，然后采用其他措施实现同步传输。同步通信数据率较高，但实现的代价也较高。 </p>
</li>
<li><p><strong>异步通信</strong></p>
<p>异步通信在发送字符时，<u>所发送的字符之间的时间间隔可以是任意的，但接收端必须时刻做 好接收的准备。发送端可以在任意时刻开始发送字符，</u> <strong>因此必须在每个字符开始和结束的地方加 上标志， 即开始位和停止位</strong>，以便使接收端能够正确地将每个字符接收下来。异步通信也可以帧 作为发送的单位。这时，帧的首部和尾部必须设有一些特殊的比特组合，使得接收端能够找出一 帧的开始（即帧定界）。异步通信的通信设备简单、便宜，但传输效率较低（因为标志的开销所 占比例较大）。</p>
</li>
</ul>
<h2 id="5、奈氏准则（奈奎斯特定理）"><a href="#5、奈氏准则（奈奎斯特定理）" class="headerlink" title="5、奈氏准则（奈奎斯特定理）"></a>5、奈氏准则（奈奎斯特定理）</h2><ul>
<li><p><strong>由来：寻找在保证不出现码间串扰的条件下的码元的最大传输速率。</strong></p>
<blockquote>
<p>码间串扰：具体的信道所能通过的频率范围总是有限的，所以信号中的大部分高频分量就过不去了，这样在传输共享中会衰减，导致在接收端收到的信号的波形就<u>失去了码元之间的清晰界限</u>，这种现象就是码间串扰</p>
</blockquote>
</li>
</ul>
<p><img data-src="https://gitee.com/stuxiaozhang/blogimage/raw/master/img/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200814195905803.png" alt="image-20200814195905803"></p>
<ul>
<li><strong>奈奎斯特定理</strong>:<br>$$C_{max}=f_{采样}*log_2N(bit/s)$$ 其中，<code>f</code>代表<code>理想低通信道</code>的带宽，<code>N</code>表示每个码元的离散电平的数目。</li>
</ul>
<ul>
<li><strong>区分低通信道和带通信道</strong></li>
</ul>
<p><code>低通信道</code>就是信号的频率只要不超过某个上限值，都可以不失真地通过信道（有上限，无下限），理想低通信道的最高码元传输速率是每秒2个码元；<br><code>带通信道</code>既有上限也有下限，理想带通信道的最高码元传输速率是每秒1个码元。</p>
<h2 id="6、香农定理"><a href="#6、香农定理" class="headerlink" title="6、香农定理"></a>6、香农定理</h2><p>公式：<br>$$C_{max}=W*log_2(1+S/N)(bit/s)$$ 其中，<code>W</code>为信道的带宽，$S/N$为信噪比。<br><strong>想要提高信息的传输速率，需要增大信噪比或者提高带宽</strong>（注意：仅仅提高改善编码不可能超过香农公式算出的速率）。</p>
<h2 id="7、对比奈奎斯特定理和香农定理"><a href="#7、对比奈奎斯特定理和香农定理" class="headerlink" title="7、对比奈奎斯特定理和香农定理"></a>7、对比奈奎斯特定理和香农定理</h2><p><strong>奈奎斯特定理</strong>：</p>
<p>寻找在保证不出现码间串扰的条件下的码元的最大传输速率。只考虑了带宽与码元速率的关系。</p>
<ol>
<li>指出了<strong>码元的传输速率是受限的</strong>，不能任意提高，否则在接收端就无法判定码元是0还是1（码间串扰）;</li>
<li>是在理想条件下推出来的(无噪声);</li>
<li>并没有对信息传输速率给出限制（可以无限大，只要编码技术足够好）。</li>
</ol>
<p><strong>香农定理</strong>:</p>
<p>不仅考虑了带宽与码元速率的关系，也考虑了信噪比。</p>
<ol>
<li><strong>给出了信息传输速率的极限值</strong>，只要传输带宽（Hz）和信噪比确定了，传输速率也就确定了;</li>
<li>有噪声。</li>
</ol>
<h2 id="8、编码与调制"><a href="#8、编码与调制" class="headerlink" title="8、编码与调制"></a>8、编码与调制</h2><ul>
<li><strong>编码</strong>：将模拟数据或数字数据<strong>转换为数字信号</strong>的过程。</li>
<li><strong>调制</strong>：将模拟数据或数字数据<strong>转化为模拟信号</strong>的过程。</li>
</ul>
<h3 id="8-1-编码"><a href="#8-1-编码" class="headerlink" title="8.1 编码"></a>8.1 编码</h3><ol>
<li>数字数据 编码为 数字信号：<br>用于基带信号传输中。（数字发送器）<br>常用编码方式：<ol>
<li>非归零码；</li>
<li>曼彻斯特编码；（1：先1后0   0：先0后1）</li>
<li>差分曼彻斯特编码。</li>
</ol>
</li>
</ol>
<ol start="2">
<li>模拟数据 编码为 数字信号：<br>典型例子就是<code>脉冲编码调制PCM</code>，有3个步骤：采样、量化、编码。</li>
</ol>
<h3 id="8-2-调制"><a href="#8-2-调制" class="headerlink" title="8.2 调制"></a>8.2 调制</h3><ol>
<li><p>数字数据 调制为 模拟信号：（调制器）</p>
<ol>
<li>带通调制：将基带信号的频带范围搬移到较高的频段以便在信道中传输（3种方法：调频，调幅，调相）；</li>
<li>基带调制：改变基带信号的低频成分的波形（仍是基带信号）。</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>模拟数据 调制为 模拟信号：（放大器调制器）</p>
<p>（原因）</p>
<ol>
<li>为了实现传输的有效性，可能需要较高的频率；</li>
<li>充分利用带宽。</li>
</ol>
</li>
</ol>
<h2 id="9、-数据传输方式-电路交换、报文交换、分组交换"><a href="#9、-数据传输方式-电路交换、报文交换、分组交换" class="headerlink" title="9、==数据传输方式(电路交换、报文交换、分组交换)=="></a>9、==数据传输方式(电路交换、报文交换、分组交换)==</h2><p><img data-src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200805230405872.png" alt="image-20200805230405872"></p>
<ol>
<li><strong>电路交换（circuit switching）</strong></li>
</ol>
<ul>
<li><p>电路交换：在发送方和接收方之间通过多台交换机建立一条连接(电路circuit)物理通信路径；</p>
</li>
<li><p>建立连接 -&gt; 通信 -&gt; 释放</p>
</li>
<li><p>电路交换网络中，端系统间通信会话期间，预留了端系统间通信沿路径所需要的资源（缓存、链路传输速率）</p>
</li>
<li><p>优点：</p>
<ul>
<li>通信时延小；实时性强；</li>
<li>有序传输；控制简单；使用范围广（数字/模拟信号均可传输）；</li>
<li>避免冲突。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>建立连接时间长；</li>
<li>信道利用率低；</li>
<li>灵活性差（任一节点出错都需要建立新的连接）。</li>
<li>缺乏统一标准(电路交换时，数据之大，不同规格终端难以相互通信，也很难进行差错控制)；</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>报文交换（meassge switching）</strong></li>
</ol>
<ul>
<li><p><strong>数据交换的单位是报文，报文携带目的地址、源地址等信息；报文交换在交换节点时采用存储转发方式。</strong></p>
</li>
<li><p>报文交换方式的数据传输单位是报文，报文就是站点一次性要发送的数据块，其长度不限且可变。当一个站要发送报文时，它将一个目的地址附加到报文上，网络节点根据报文上的目的地址信息，把报文发送到下一个节点，一直逐个节点地转送到目的节点。</p>
</li>
<li><p>每个节点在收到整个报文并检查无误后，就暂存这个报文，然后利用路由信息找出下一个节点的地址，再把整个报文传送给下一个节点。因此，端与端之间无需先通过呼叫建立连接。</p>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li>无需建立连接(因此不存在连接时延)；</li>
<li>动态分配线路；</li>
<li>提高了可靠性；</li>
<li>提高线路利用率；</li>
<li>提供多目标服务（一个报文可以发送到多个目的地址）。</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li>由于数据进入交换节点后要经理存储、转发这一过程，从而引起转发时延；</li>
<li>报文交换对报文的大小没有限制，这就要求网络节点有大量的存储缓存空间。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>分组交换（packet switching）</strong></li>
</ol>
<ul>
<li><strong>仍采用存储转发方式，但将一个长报文先分割为若干较短的分组，然后逐个转发分组（每个分组都携带目的地址、源地址和编号信息）。</strong></li>
</ul>
<p>分组交换是报文交换的一种改进，它将报文分成若干个分组，每个分组的长度有一个上限，有限长度的分组使得每个节点所需的存储能力降低了，分组可以存储到内存中，提高了交换速度。它适用于交互式通信，如终端与主机通信。</p>
<p><img data-src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200805233942970.png" alt="image-20200805233942970"></p>
<ul>
<li>优点：<ol>
<li>加速传输（分组是逐个传输的，所以可以使后一个分组的存储操作与前一个分组的转发操作并行；传输一个分组所需缓冲区较小，因此因缓冲区不足而等待发送的概率以及等待时间也会减小）；</li>
<li>简化了存储管理（分组长度固定，相应缓冲区大小也固定）；</li>
<li>减少了出错概率和重发数据量(因为分组较短，所以出错概率也较小，这样既提高了可靠性，又降低了传输时延)；</li>
</ol>
</li>
<li>缺点：<ol>
<li>存在传输时延（尽管比报文交换的传输时延少，但相对于电路交换，仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力）；</li>
<li>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组的现象，分组到达目的节点时，要重排，很麻烦；若采用虚电路服务，虽无失序问题，单有呼叫建立、数据传输和虚电路释放3个过程。</li>
</ol>
</li>
</ul>
<h2 id="10、电路交换、报文交换、分组交换的应用场景"><a href="#10、电路交换、报文交换、分组交换的应用场景" class="headerlink" title="10、电路交换、报文交换、分组交换的应用场景"></a>10、电路交换、报文交换、分组交换的应用场景</h2><ul>
<li>传送的数据量很大，且其传送时间远大于呼叫时间–&gt;<strong>电路交换；</strong></li>
<li>端到端的通路由很多段链路组成–&gt;分组交换；</li>
<li>从提高整个网络的信道利用率来看，报文交换和分组交换优于电路交换，其中<strong>分组交换比报文交换的时延小，尤其适合计算机之间的突发式的数据通信。</strong> </li>
</ul>
<h2 id="11、分组交换的方式（无连接的数据报方式、面向连接的虚电路方式）"><a href="#11、分组交换的方式（无连接的数据报方式、面向连接的虚电路方式）" class="headerlink" title="11、分组交换的方式（无连接的数据报方式、面向连接的虚电路方式）"></a>11、分组交换的方式（无连接的数据报方式、面向连接的虚电路方式）</h2><ul>
<li>数据报：<ul>
<li>发送分组前无需建立连接；</li>
<li>网络尽最大努力交付，传输不保证可靠性，可能乱序或丢失；</li>
<li>在具有多个分组的报文中，交换机尚未接收完第二个分组，已经收到的第一个分组就可以转发出去，不仅减小了延迟，而且大大提高了吞吐量；</li>
<li>当某一台交换机或一段链路故障时，可相应地更新转发表，寻找到另一条替代路径转发分组，对故障适应能力强；</li>
<li>发送方和接收方不独占某一链路，所以资源利用率高。</li>
</ul>
</li>
</ul>
<ul>
<li>虚电路：发送数据之前，在源主机和目的主机之间建立一条虚连接(逻辑上的连接)。<ul>
<li>用户之间必须建立连接，数据传输过程中不再需要寻找路径，相对数据报方式开销小；</li>
<li>分组走相同路径，故按序到达；</li>
<li>分组首部并不包含目的地址，而是包含虚电路标识符，相对数据报方式开销小；</li>
<li>当某个交换机或某条链路出现故障而彻底失效时，所有经过该交换机或该链路的虚电路将遭到破坏。</li>
</ul>
</li>
</ul>
<p><img data-src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200805233942970.png" alt="image-20200805233942970"></p>
<h2 id="12、传输介质分类"><a href="#12、传输介质分类" class="headerlink" title="12、传输介质分类"></a>12、传输介质分类</h2><ul>
<li>导向性传输介质：双绞线（无屏蔽双绞线和屏蔽双绞线）、同轴电缆、光纤；</li>
<li>非导向性传输介质：短波、微波、红外线与可见光。</li>
</ul>
<h2 id="13、物理层接口特性"><a href="#13、物理层接口特性" class="headerlink" title="13、物理层接口特性"></a>13、物理层接口特性</h2><ul>
<li>机械特性、电气特性、功能特性、规程特性。</li>
</ul>
<h2 id="14、物理层设备（中继器、集线器）"><a href="#14、物理层设备（中继器、集线器）" class="headerlink" title="14、物理层设备（中继器、集线器）"></a>14、物理层设备（中继器、集线器）</h2><h3 id="14-1-中继器"><a href="#14-1-中继器" class="headerlink" title="14.1 中继器"></a>14.1 中继器</h3><p>中继器：主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后，因噪声或其他原因而造成失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。其原理是信号再生，而非简单的衰减的信号放大。中继器有两个端口，数据从一个端口输入，从另一个端口输出。端口仅用作信号的电气部分，而不管数据中是否有错误数据或不适用于网段的数据。</p>
<h3 id="14-2-集线器"><a href="#14-2-集线器" class="headerlink" title="14.2 集线器"></a>14.2 集线器</h3><p>集线器实质上是多端口的中继器，也工作在物理层。</p>
<p>当hub工作时，一个端口接收到数据信号后，由于信号在从端口到hub的传输过程中已经有衰减，所以hub该信号进行整形放大，使之恢复到发送时的状态，紧接着转发到其他处于工作状态的端口。如果同时2个或多个端口输入，那么输出时会发生冲突，致使这些数据都无效。</p>
<p>从hub的工作方式来看，他在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而不具备信号的定向传送能力，即信号传输的方向是固定的，是一个标准的共享式设备。</p>
<blockquote>
<p>中继器、集线器（多端口的中继器，处在网络中心，也叫<code>HUb</code>）。<br>注意：中继器放大模拟信号，放大器放大数字信号<br>这俩货的缺点：<br>1）扩大了冲突域且总的吞吐量未提高；<br>2）不能互联使用不同以太网技术的局域网。</p>
</blockquote>
<h3 id="附加题：简述一下Cookie-和-Session的区别"><a href="#附加题：简述一下Cookie-和-Session的区别" class="headerlink" title="附加题：简述一下Cookie 和 Session的区别"></a>附加题：简述一下Cookie 和 Session的区别</h3><p>Cookie 和 <strong>Session</strong>都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p>Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 </p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
